/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("pages/index",{

/***/ "../node_modules/ethers/dist/ethers.umd.js":
/*!*************************************************!*\
  !*** ../node_modules/ethers/dist/ethers.umd.js ***!
  \*************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval("/* provided dependency */ var process = __webpack_require__(/*! process */ \"../node_modules/process/browser.js\");\n(function (global, factory) {\n\t true ? module.exports = factory() :\n\t0;\n}(this, (function () { 'use strict';\n\n\tvar commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof __webpack_require__.g !== 'undefined' ? __webpack_require__.g : typeof self !== 'undefined' ? self : {};\n\n\tfunction getDefaultExportFromCjs (x) {\n\t\treturn x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;\n\t}\n\n\tfunction createCommonjsModule(fn, basedir, module) {\n\t\treturn module = {\n\t\t\tpath: basedir,\n\t\t\texports: {},\n\t\t\trequire: function (path, base) {\n\t\t\t\treturn commonjsRequire(path, (base === undefined || base === null) ? module.path : base);\n\t\t\t}\n\t\t}, fn(module, module.exports), module.exports;\n\t}\n\n\tfunction getDefaultExportFromNamespaceIfPresent (n) {\n\t\treturn n && Object.prototype.hasOwnProperty.call(n, 'default') ? n['default'] : n;\n\t}\n\n\tfunction getDefaultExportFromNamespaceIfNotNamed (n) {\n\t\treturn n && Object.prototype.hasOwnProperty.call(n, 'default') && Object.keys(n).length === 1 ? n['default'] : n;\n\t}\n\n\tfunction getAugmentedNamespace(n) {\n\t\tif (n.__esModule) return n;\n\t\tvar a = Object.defineProperty({}, '__esModule', {value: true});\n\t\tObject.keys(n).forEach(function (k) {\n\t\t\tvar d = Object.getOwnPropertyDescriptor(n, k);\n\t\t\tObject.defineProperty(a, k, d.get ? d : {\n\t\t\t\tenumerable: true,\n\t\t\t\tget: function () {\n\t\t\t\t\treturn n[k];\n\t\t\t\t}\n\t\t\t});\n\t\t});\n\t\treturn a;\n\t}\n\n\tfunction commonjsRequire () {\n\t\tthrow new Error('Dynamic requires are not currently supported by @rollup/plugin-commonjs');\n\t}\n\n\tvar bn = createCommonjsModule(function (module) {\n\t(function (module, exports) {\n\t  'use strict';\n\n\t  // Utils\n\t  function assert (val, msg) {\n\t    if (!val) throw new Error(msg || 'Assertion failed');\n\t  }\n\n\t  // Could use `inherits` module, but don't want to move from single file\n\t  // architecture yet.\n\t  function inherits (ctor, superCtor) {\n\t    ctor.super_ = superCtor;\n\t    var TempCtor = function () {};\n\t    TempCtor.prototype = superCtor.prototype;\n\t    ctor.prototype = new TempCtor();\n\t    ctor.prototype.constructor = ctor;\n\t  }\n\n\t  // BN\n\n\t  function BN (number, base, endian) {\n\t    if (BN.isBN(number)) {\n\t      return number;\n\t    }\n\n\t    this.negative = 0;\n\t    this.words = null;\n\t    this.length = 0;\n\n\t    // Reduction context\n\t    this.red = null;\n\n\t    if (number !== null) {\n\t      if (base === 'le' || base === 'be') {\n\t        endian = base;\n\t        base = 10;\n\t      }\n\n\t      this._init(number || 0, base || 10, endian || 'be');\n\t    }\n\t  }\n\t  if (typeof module === 'object') {\n\t    module.exports = BN;\n\t  } else {\n\t    exports.BN = BN;\n\t  }\n\n\t  BN.BN = BN;\n\t  BN.wordSize = 26;\n\n\t  var Buffer;\n\t  try {\n\t    if (typeof window !== 'undefined' && typeof window.Buffer !== 'undefined') {\n\t      Buffer = window.Buffer;\n\t    } else {\n\t      Buffer = /*RicMoo:ethers:require(buffer)*/(null).Buffer;\n\t    }\n\t  } catch (e) {\n\t  }\n\n\t  BN.isBN = function isBN (num) {\n\t    if (num instanceof BN) {\n\t      return true;\n\t    }\n\n\t    return num !== null && typeof num === 'object' &&\n\t      num.constructor.wordSize === BN.wordSize && Array.isArray(num.words);\n\t  };\n\n\t  BN.max = function max (left, right) {\n\t    if (left.cmp(right) > 0) return left;\n\t    return right;\n\t  };\n\n\t  BN.min = function min (left, right) {\n\t    if (left.cmp(right) < 0) return left;\n\t    return right;\n\t  };\n\n\t  BN.prototype._init = function init (number, base, endian) {\n\t    if (typeof number === 'number') {\n\t      return this._initNumber(number, base, endian);\n\t    }\n\n\t    if (typeof number === 'object') {\n\t      return this._initArray(number, base, endian);\n\t    }\n\n\t    if (base === 'hex') {\n\t      base = 16;\n\t    }\n\t    assert(base === (base | 0) && base >= 2 && base <= 36);\n\n\t    number = number.toString().replace(/\\s+/g, '');\n\t    var start = 0;\n\t    if (number[0] === '-') {\n\t      start++;\n\t      this.negative = 1;\n\t    }\n\n\t    if (start < number.length) {\n\t      if (base === 16) {\n\t        this._parseHex(number, start, endian);\n\t      } else {\n\t        this._parseBase(number, base, start);\n\t        if (endian === 'le') {\n\t          this._initArray(this.toArray(), base, endian);\n\t        }\n\t      }\n\t    }\n\t  };\n\n\t  BN.prototype._initNumber = function _initNumber (number, base, endian) {\n\t    if (number < 0) {\n\t      this.negative = 1;\n\t      number = -number;\n\t    }\n\t    if (number < 0x4000000) {\n\t      this.words = [ number & 0x3ffffff ];\n\t      this.length = 1;\n\t    } else if (number < 0x10000000000000) {\n\t      this.words = [\n\t        number & 0x3ffffff,\n\t        (number / 0x4000000) & 0x3ffffff\n\t      ];\n\t      this.length = 2;\n\t    } else {\n\t      assert(number < 0x20000000000000); // 2 ^ 53 (unsafe)\n\t      this.words = [\n\t        number & 0x3ffffff,\n\t        (number / 0x4000000) & 0x3ffffff,\n\t        1\n\t      ];\n\t      this.length = 3;\n\t    }\n\n\t    if (endian !== 'le') return;\n\n\t    // Reverse the bytes\n\t    this._initArray(this.toArray(), base, endian);\n\t  };\n\n\t  BN.prototype._initArray = function _initArray (number, base, endian) {\n\t    // Perhaps a Uint8Array\n\t    assert(typeof number.length === 'number');\n\t    if (number.length <= 0) {\n\t      this.words = [ 0 ];\n\t      this.length = 1;\n\t      return this;\n\t    }\n\n\t    this.length = Math.ceil(number.length / 3);\n\t    this.words = new Array(this.length);\n\t    for (var i = 0; i < this.length; i++) {\n\t      this.words[i] = 0;\n\t    }\n\n\t    var j, w;\n\t    var off = 0;\n\t    if (endian === 'be') {\n\t      for (i = number.length - 1, j = 0; i >= 0; i -= 3) {\n\t        w = number[i] | (number[i - 1] << 8) | (number[i - 2] << 16);\n\t        this.words[j] |= (w << off) & 0x3ffffff;\n\t        this.words[j + 1] = (w >>> (26 - off)) & 0x3ffffff;\n\t        off += 24;\n\t        if (off >= 26) {\n\t          off -= 26;\n\t          j++;\n\t        }\n\t      }\n\t    } else if (endian === 'le') {\n\t      for (i = 0, j = 0; i < number.length; i += 3) {\n\t        w = number[i] | (number[i + 1] << 8) | (number[i + 2] << 16);\n\t        this.words[j] |= (w << off) & 0x3ffffff;\n\t        this.words[j + 1] = (w >>> (26 - off)) & 0x3ffffff;\n\t        off += 24;\n\t        if (off >= 26) {\n\t          off -= 26;\n\t          j++;\n\t        }\n\t      }\n\t    }\n\t    return this.strip();\n\t  };\n\n\t  function parseHex4Bits (string, index) {\n\t    var c = string.charCodeAt(index);\n\t    // 'A' - 'F'\n\t    if (c >= 65 && c <= 70) {\n\t      return c - 55;\n\t    // 'a' - 'f'\n\t    } else if (c >= 97 && c <= 102) {\n\t      return c - 87;\n\t    // '0' - '9'\n\t    } else {\n\t      return (c - 48) & 0xf;\n\t    }\n\t  }\n\n\t  function parseHexByte (string, lowerBound, index) {\n\t    var r = parseHex4Bits(string, index);\n\t    if (index - 1 >= lowerBound) {\n\t      r |= parseHex4Bits(string, index - 1) << 4;\n\t    }\n\t    return r;\n\t  }\n\n\t  BN.prototype._parseHex = function _parseHex (number, start, endian) {\n\t    // Create possibly bigger array to ensure that it fits the number\n\t    this.length = Math.ceil((number.length - start) / 6);\n\t    this.words = new Array(this.length);\n\t    for (var i = 0; i < this.length; i++) {\n\t      this.words[i] = 0;\n\t    }\n\n\t    // 24-bits chunks\n\t    var off = 0;\n\t    var j = 0;\n\n\t    var w;\n\t    if (endian === 'be') {\n\t      for (i = number.length - 1; i >= start; i -= 2) {\n\t        w = parseHexByte(number, start, i) << off;\n\t        this.words[j] |= w & 0x3ffffff;\n\t        if (off >= 18) {\n\t          off -= 18;\n\t          j += 1;\n\t          this.words[j] |= w >>> 26;\n\t        } else {\n\t          off += 8;\n\t        }\n\t      }\n\t    } else {\n\t      var parseLength = number.length - start;\n\t      for (i = parseLength % 2 === 0 ? start + 1 : start; i < number.length; i += 2) {\n\t        w = parseHexByte(number, start, i) << off;\n\t        this.words[j] |= w & 0x3ffffff;\n\t        if (off >= 18) {\n\t          off -= 18;\n\t          j += 1;\n\t          this.words[j] |= w >>> 26;\n\t        } else {\n\t          off += 8;\n\t        }\n\t      }\n\t    }\n\n\t    this.strip();\n\t  };\n\n\t  function parseBase (str, start, end, mul) {\n\t    var r = 0;\n\t    var len = Math.min(str.length, end);\n\t    for (var i = start; i < len; i++) {\n\t      var c = str.charCodeAt(i) - 48;\n\n\t      r *= mul;\n\n\t      // 'a'\n\t      if (c >= 49) {\n\t        r += c - 49 + 0xa;\n\n\t      // 'A'\n\t      } else if (c >= 17) {\n\t        r += c - 17 + 0xa;\n\n\t      // '0' - '9'\n\t      } else {\n\t        r += c;\n\t      }\n\t    }\n\t    return r;\n\t  }\n\n\t  BN.prototype._parseBase = function _parseBase (number, base, start) {\n\t    // Initialize as zero\n\t    this.words = [ 0 ];\n\t    this.length = 1;\n\n\t    // Find length of limb in base\n\t    for (var limbLen = 0, limbPow = 1; limbPow <= 0x3ffffff; limbPow *= base) {\n\t      limbLen++;\n\t    }\n\t    limbLen--;\n\t    limbPow = (limbPow / base) | 0;\n\n\t    var total = number.length - start;\n\t    var mod = total % limbLen;\n\t    var end = Math.min(total, total - mod) + start;\n\n\t    var word = 0;\n\t    for (var i = start; i < end; i += limbLen) {\n\t      word = parseBase(number, i, i + limbLen, base);\n\n\t      this.imuln(limbPow);\n\t      if (this.words[0] + word < 0x4000000) {\n\t        this.words[0] += word;\n\t      } else {\n\t        this._iaddn(word);\n\t      }\n\t    }\n\n\t    if (mod !== 0) {\n\t      var pow = 1;\n\t      word = parseBase(number, i, number.length, base);\n\n\t      for (i = 0; i < mod; i++) {\n\t        pow *= base;\n\t      }\n\n\t      this.imuln(pow);\n\t      if (this.words[0] + word < 0x4000000) {\n\t        this.words[0] += word;\n\t      } else {\n\t        this._iaddn(word);\n\t      }\n\t    }\n\n\t    this.strip();\n\t  };\n\n\t  BN.prototype.copy = function copy (dest) {\n\t    dest.words = new Array(this.length);\n\t    for (var i = 0; i < this.length; i++) {\n\t      dest.words[i] = this.words[i];\n\t    }\n\t    dest.length = this.length;\n\t    dest.negative = this.negative;\n\t    dest.red = this.red;\n\t  };\n\n\t  BN.prototype.clone = function clone () {\n\t    var r = new BN(null);\n\t    this.copy(r);\n\t    return r;\n\t  };\n\n\t  BN.prototype._expand = function _expand (size) {\n\t    while (this.length < size) {\n\t      this.words[this.length++] = 0;\n\t    }\n\t    return this;\n\t  };\n\n\t  // Remove leading `0` from `this`\n\t  BN.prototype.strip = function strip () {\n\t    while (this.length > 1 && this.words[this.length - 1] === 0) {\n\t      this.length--;\n\t    }\n\t    return this._normSign();\n\t  };\n\n\t  BN.prototype._normSign = function _normSign () {\n\t    // -0 = 0\n\t    if (this.length === 1 && this.words[0] === 0) {\n\t      this.negative = 0;\n\t    }\n\t    return this;\n\t  };\n\n\t  BN.prototype.inspect = function inspect () {\n\t    return (this.red ? '<BN-R: ' : '<BN: ') + this.toString(16) + '>';\n\t  };\n\n\t  /*\n\n\t  var zeros = [];\n\t  var groupSizes = [];\n\t  var groupBases = [];\n\n\t  var s = '';\n\t  var i = -1;\n\t  while (++i < BN.wordSize) {\n\t    zeros[i] = s;\n\t    s += '0';\n\t  }\n\t  groupSizes[0] = 0;\n\t  groupSizes[1] = 0;\n\t  groupBases[0] = 0;\n\t  groupBases[1] = 0;\n\t  var base = 2 - 1;\n\t  while (++base < 36 + 1) {\n\t    var groupSize = 0;\n\t    var groupBase = 1;\n\t    while (groupBase < (1 << BN.wordSize) / base) {\n\t      groupBase *= base;\n\t      groupSize += 1;\n\t    }\n\t    groupSizes[base] = groupSize;\n\t    groupBases[base] = groupBase;\n\t  }\n\n\t  */\n\n\t  var zeros = [\n\t    '',\n\t    '0',\n\t    '00',\n\t    '000',\n\t    '0000',\n\t    '00000',\n\t    '000000',\n\t    '0000000',\n\t    '00000000',\n\t    '000000000',\n\t    '0000000000',\n\t    '00000000000',\n\t    '000000000000',\n\t    '0000000000000',\n\t    '00000000000000',\n\t    '000000000000000',\n\t    '0000000000000000',\n\t    '00000000000000000',\n\t    '000000000000000000',\n\t    '0000000000000000000',\n\t    '00000000000000000000',\n\t    '000000000000000000000',\n\t    '0000000000000000000000',\n\t    '00000000000000000000000',\n\t    '000000000000000000000000',\n\t    '0000000000000000000000000'\n\t  ];\n\n\t  var groupSizes = [\n\t    0, 0,\n\t    25, 16, 12, 11, 10, 9, 8,\n\t    8, 7, 7, 7, 7, 6, 6,\n\t    6, 6, 6, 6, 6, 5, 5,\n\t    5, 5, 5, 5, 5, 5, 5,\n\t    5, 5, 5, 5, 5, 5, 5\n\t  ];\n\n\t  var groupBases = [\n\t    0, 0,\n\t    33554432, 43046721, 16777216, 48828125, 60466176, 40353607, 16777216,\n\t    43046721, 10000000, 19487171, 35831808, 62748517, 7529536, 11390625,\n\t    16777216, 24137569, 34012224, 47045881, 64000000, 4084101, 5153632,\n\t    6436343, 7962624, 9765625, 11881376, 14348907, 17210368, 20511149,\n\t    24300000, 28629151, 33554432, 39135393, 45435424, 52521875, 60466176\n\t  ];\n\n\t  BN.prototype.toString = function toString (base, padding) {\n\t    base = base || 10;\n\t    padding = padding | 0 || 1;\n\n\t    var out;\n\t    if (base === 16 || base === 'hex') {\n\t      out = '';\n\t      var off = 0;\n\t      var carry = 0;\n\t      for (var i = 0; i < this.length; i++) {\n\t        var w = this.words[i];\n\t        var word = (((w << off) | carry) & 0xffffff).toString(16);\n\t        carry = (w >>> (24 - off)) & 0xffffff;\n\t        if (carry !== 0 || i !== this.length - 1) {\n\t          out = zeros[6 - word.length] + word + out;\n\t        } else {\n\t          out = word + out;\n\t        }\n\t        off += 2;\n\t        if (off >= 26) {\n\t          off -= 26;\n\t          i--;\n\t        }\n\t      }\n\t      if (carry !== 0) {\n\t        out = carry.toString(16) + out;\n\t      }\n\t      while (out.length % padding !== 0) {\n\t        out = '0' + out;\n\t      }\n\t      if (this.negative !== 0) {\n\t        out = '-' + out;\n\t      }\n\t      return out;\n\t    }\n\n\t    if (base === (base | 0) && base >= 2 && base <= 36) {\n\t      // var groupSize = Math.floor(BN.wordSize * Math.LN2 / Math.log(base));\n\t      var groupSize = groupSizes[base];\n\t      // var groupBase = Math.pow(base, groupSize);\n\t      var groupBase = groupBases[base];\n\t      out = '';\n\t      var c = this.clone();\n\t      c.negative = 0;\n\t      while (!c.isZero()) {\n\t        var r = c.modn(groupBase).toString(base);\n\t        c = c.idivn(groupBase);\n\n\t        if (!c.isZero()) {\n\t          out = zeros[groupSize - r.length] + r + out;\n\t        } else {\n\t          out = r + out;\n\t        }\n\t      }\n\t      if (this.isZero()) {\n\t        out = '0' + out;\n\t      }\n\t      while (out.length % padding !== 0) {\n\t        out = '0' + out;\n\t      }\n\t      if (this.negative !== 0) {\n\t        out = '-' + out;\n\t      }\n\t      return out;\n\t    }\n\n\t    assert(false, 'Base should be between 2 and 36');\n\t  };\n\n\t  BN.prototype.toNumber = function toNumber () {\n\t    var ret = this.words[0];\n\t    if (this.length === 2) {\n\t      ret += this.words[1] * 0x4000000;\n\t    } else if (this.length === 3 && this.words[2] === 0x01) {\n\t      // NOTE: at this stage it is known that the top bit is set\n\t      ret += 0x10000000000000 + (this.words[1] * 0x4000000);\n\t    } else if (this.length > 2) {\n\t      assert(false, 'Number can only safely store up to 53 bits');\n\t    }\n\t    return (this.negative !== 0) ? -ret : ret;\n\t  };\n\n\t  BN.prototype.toJSON = function toJSON () {\n\t    return this.toString(16);\n\t  };\n\n\t  BN.prototype.toBuffer = function toBuffer (endian, length) {\n\t    assert(typeof Buffer !== 'undefined');\n\t    return this.toArrayLike(Buffer, endian, length);\n\t  };\n\n\t  BN.prototype.toArray = function toArray (endian, length) {\n\t    return this.toArrayLike(Array, endian, length);\n\t  };\n\n\t  BN.prototype.toArrayLike = function toArrayLike (ArrayType, endian, length) {\n\t    var byteLength = this.byteLength();\n\t    var reqLength = length || Math.max(1, byteLength);\n\t    assert(byteLength <= reqLength, 'byte array longer than desired length');\n\t    assert(reqLength > 0, 'Requested array length <= 0');\n\n\t    this.strip();\n\t    var littleEndian = endian === 'le';\n\t    var res = new ArrayType(reqLength);\n\n\t    var b, i;\n\t    var q = this.clone();\n\t    if (!littleEndian) {\n\t      // Assume big-endian\n\t      for (i = 0; i < reqLength - byteLength; i++) {\n\t        res[i] = 0;\n\t      }\n\n\t      for (i = 0; !q.isZero(); i++) {\n\t        b = q.andln(0xff);\n\t        q.iushrn(8);\n\n\t        res[reqLength - i - 1] = b;\n\t      }\n\t    } else {\n\t      for (i = 0; !q.isZero(); i++) {\n\t        b = q.andln(0xff);\n\t        q.iushrn(8);\n\n\t        res[i] = b;\n\t      }\n\n\t      for (; i < reqLength; i++) {\n\t        res[i] = 0;\n\t      }\n\t    }\n\n\t    return res;\n\t  };\n\n\t  if (Math.clz32) {\n\t    BN.prototype._countBits = function _countBits (w) {\n\t      return 32 - Math.clz32(w);\n\t    };\n\t  } else {\n\t    BN.prototype._countBits = function _countBits (w) {\n\t      var t = w;\n\t      var r = 0;\n\t      if (t >= 0x1000) {\n\t        r += 13;\n\t        t >>>= 13;\n\t      }\n\t      if (t >= 0x40) {\n\t        r += 7;\n\t        t >>>= 7;\n\t      }\n\t      if (t >= 0x8) {\n\t        r += 4;\n\t        t >>>= 4;\n\t      }\n\t      if (t >= 0x02) {\n\t        r += 2;\n\t        t >>>= 2;\n\t      }\n\t      return r + t;\n\t    };\n\t  }\n\n\t  BN.prototype._zeroBits = function _zeroBits (w) {\n\t    // Short-cut\n\t    if (w === 0) return 26;\n\n\t    var t = w;\n\t    var r = 0;\n\t    if ((t & 0x1fff) === 0) {\n\t      r += 13;\n\t      t >>>= 13;\n\t    }\n\t    if ((t & 0x7f) === 0) {\n\t      r += 7;\n\t      t >>>= 7;\n\t    }\n\t    if ((t & 0xf) === 0) {\n\t      r += 4;\n\t      t >>>= 4;\n\t    }\n\t    if ((t & 0x3) === 0) {\n\t      r += 2;\n\t      t >>>= 2;\n\t    }\n\t    if ((t & 0x1) === 0) {\n\t      r++;\n\t    }\n\t    return r;\n\t  };\n\n\t  // Return number of used bits in a BN\n\t  BN.prototype.bitLength = function bitLength () {\n\t    var w = this.words[this.length - 1];\n\t    var hi = this._countBits(w);\n\t    return (this.length - 1) * 26 + hi;\n\t  };\n\n\t  function toBitArray (num) {\n\t    var w = new Array(num.bitLength());\n\n\t    for (var bit = 0; bit < w.length; bit++) {\n\t      var off = (bit / 26) | 0;\n\t      var wbit = bit % 26;\n\n\t      w[bit] = (num.words[off] & (1 << wbit)) >>> wbit;\n\t    }\n\n\t    return w;\n\t  }\n\n\t  // Number of trailing zero bits\n\t  BN.prototype.zeroBits = function zeroBits () {\n\t    if (this.isZero()) return 0;\n\n\t    var r = 0;\n\t    for (var i = 0; i < this.length; i++) {\n\t      var b = this._zeroBits(this.words[i]);\n\t      r += b;\n\t      if (b !== 26) break;\n\t    }\n\t    return r;\n\t  };\n\n\t  BN.prototype.byteLength = function byteLength () {\n\t    return Math.ceil(this.bitLength() / 8);\n\t  };\n\n\t  BN.prototype.toTwos = function toTwos (width) {\n\t    if (this.negative !== 0) {\n\t      return this.abs().inotn(width).iaddn(1);\n\t    }\n\t    return this.clone();\n\t  };\n\n\t  BN.prototype.fromTwos = function fromTwos (width) {\n\t    if (this.testn(width - 1)) {\n\t      return this.notn(width).iaddn(1).ineg();\n\t    }\n\t    return this.clone();\n\t  };\n\n\t  BN.prototype.isNeg = function isNeg () {\n\t    return this.negative !== 0;\n\t  };\n\n\t  // Return negative clone of `this`\n\t  BN.prototype.neg = function neg () {\n\t    return this.clone().ineg();\n\t  };\n\n\t  BN.prototype.ineg = function ineg () {\n\t    if (!this.isZero()) {\n\t      this.negative ^= 1;\n\t    }\n\n\t    return this;\n\t  };\n\n\t  // Or `num` with `this` in-place\n\t  BN.prototype.iuor = function iuor (num) {\n\t    while (this.length < num.length) {\n\t      this.words[this.length++] = 0;\n\t    }\n\n\t    for (var i = 0; i < num.length; i++) {\n\t      this.words[i] = this.words[i] | num.words[i];\n\t    }\n\n\t    return this.strip();\n\t  };\n\n\t  BN.prototype.ior = function ior (num) {\n\t    assert((this.negative | num.negative) === 0);\n\t    return this.iuor(num);\n\t  };\n\n\t  // Or `num` with `this`\n\t  BN.prototype.or = function or (num) {\n\t    if (this.length > num.length) return this.clone().ior(num);\n\t    return num.clone().ior(this);\n\t  };\n\n\t  BN.prototype.uor = function uor (num) {\n\t    if (this.length > num.length) return this.clone().iuor(num);\n\t    return num.clone().iuor(this);\n\t  };\n\n\t  // And `num` with `this` in-place\n\t  BN.prototype.iuand = function iuand (num) {\n\t    // b = min-length(num, this)\n\t    var b;\n\t    if (this.length > num.length) {\n\t      b = num;\n\t    } else {\n\t      b = this;\n\t    }\n\n\t    for (var i = 0; i < b.length; i++) {\n\t      this.words[i] = this.words[i] & num.words[i];\n\t    }\n\n\t    this.length = b.length;\n\n\t    return this.strip();\n\t  };\n\n\t  BN.prototype.iand = function iand (num) {\n\t    assert((this.negative | num.negative) === 0);\n\t    return this.iuand(num);\n\t  };\n\n\t  // And `num` with `this`\n\t  BN.prototype.and = function and (num) {\n\t    if (this.length > num.length) return this.clone().iand(num);\n\t    return num.clone().iand(this);\n\t  };\n\n\t  BN.prototype.uand = function uand (num) {\n\t    if (this.length > num.length) return this.clone().iuand(num);\n\t    return num.clone().iuand(this);\n\t  };\n\n\t  // Xor `num` with `this` in-place\n\t  BN.prototype.iuxor = function iuxor (num) {\n\t    // a.length > b.length\n\t    var a;\n\t    var b;\n\t    if (this.length > num.length) {\n\t      a = this;\n\t      b = num;\n\t    } else {\n\t      a = num;\n\t      b = this;\n\t    }\n\n\t    for (var i = 0; i < b.length; i++) {\n\t      this.words[i] = a.words[i] ^ b.words[i];\n\t    }\n\n\t    if (this !== a) {\n\t      for (; i < a.length; i++) {\n\t        this.words[i] = a.words[i];\n\t      }\n\t    }\n\n\t    this.length = a.length;\n\n\t    return this.strip();\n\t  };\n\n\t  BN.prototype.ixor = function ixor (num) {\n\t    assert((this.negative | num.negative) === 0);\n\t    return this.iuxor(num);\n\t  };\n\n\t  // Xor `num` with `this`\n\t  BN.prototype.xor = function xor (num) {\n\t    if (this.length > num.length) return this.clone().ixor(num);\n\t    return num.clone().ixor(this);\n\t  };\n\n\t  BN.prototype.uxor = function uxor (num) {\n\t    if (this.length > num.length) return this.clone().iuxor(num);\n\t    return num.clone().iuxor(this);\n\t  };\n\n\t  // Not ``this`` with ``width`` bitwidth\n\t  BN.prototype.inotn = function inotn (width) {\n\t    assert(typeof width === 'number' && width >= 0);\n\n\t    var bytesNeeded = Math.ceil(width / 26) | 0;\n\t    var bitsLeft = width % 26;\n\n\t    // Extend the buffer with leading zeroes\n\t    this._expand(bytesNeeded);\n\n\t    if (bitsLeft > 0) {\n\t      bytesNeeded--;\n\t    }\n\n\t    // Handle complete words\n\t    for (var i = 0; i < bytesNeeded; i++) {\n\t      this.words[i] = ~this.words[i] & 0x3ffffff;\n\t    }\n\n\t    // Handle the residue\n\t    if (bitsLeft > 0) {\n\t      this.words[i] = ~this.words[i] & (0x3ffffff >> (26 - bitsLeft));\n\t    }\n\n\t    // And remove leading zeroes\n\t    return this.strip();\n\t  };\n\n\t  BN.prototype.notn = function notn (width) {\n\t    return this.clone().inotn(width);\n\t  };\n\n\t  // Set `bit` of `this`\n\t  BN.prototype.setn = function setn (bit, val) {\n\t    assert(typeof bit === 'number' && bit >= 0);\n\n\t    var off = (bit / 26) | 0;\n\t    var wbit = bit % 26;\n\n\t    this._expand(off + 1);\n\n\t    if (val) {\n\t      this.words[off] = this.words[off] | (1 << wbit);\n\t    } else {\n\t      this.words[off] = this.words[off] & ~(1 << wbit);\n\t    }\n\n\t    return this.strip();\n\t  };\n\n\t  // Add `num` to `this` in-place\n\t  BN.prototype.iadd = function iadd (num) {\n\t    var r;\n\n\t    // negative + positive\n\t    if (this.negative !== 0 && num.negative === 0) {\n\t      this.negative = 0;\n\t      r = this.isub(num);\n\t      this.negative ^= 1;\n\t      return this._normSign();\n\n\t    // positive + negative\n\t    } else if (this.negative === 0 && num.negative !== 0) {\n\t      num.negative = 0;\n\t      r = this.isub(num);\n\t      num.negative = 1;\n\t      return r._normSign();\n\t    }\n\n\t    // a.length > b.length\n\t    var a, b;\n\t    if (this.length > num.length) {\n\t      a = this;\n\t      b = num;\n\t    } else {\n\t      a = num;\n\t      b = this;\n\t    }\n\n\t    var carry = 0;\n\t    for (var i = 0; i < b.length; i++) {\n\t      r = (a.words[i] | 0) + (b.words[i] | 0) + carry;\n\t      this.words[i] = r & 0x3ffffff;\n\t      carry = r >>> 26;\n\t    }\n\t    for (; carry !== 0 && i < a.length; i++) {\n\t      r = (a.words[i] | 0) + carry;\n\t      this.words[i] = r & 0x3ffffff;\n\t      carry = r >>> 26;\n\t    }\n\n\t    this.length = a.length;\n\t    if (carry !== 0) {\n\t      this.words[this.length] = carry;\n\t      this.length++;\n\t    // Copy the rest of the words\n\t    } else if (a !== this) {\n\t      for (; i < a.length; i++) {\n\t        this.words[i] = a.words[i];\n\t      }\n\t    }\n\n\t    return this;\n\t  };\n\n\t  // Add `num` to `this`\n\t  BN.prototype.add = function add (num) {\n\t    var res;\n\t    if (num.negative !== 0 && this.negative === 0) {\n\t      num.negative = 0;\n\t      res = this.sub(num);\n\t      num.negative ^= 1;\n\t      return res;\n\t    } else if (num.negative === 0 && this.negative !== 0) {\n\t      this.negative = 0;\n\t      res = num.sub(this);\n\t      this.negative = 1;\n\t      return res;\n\t    }\n\n\t    if (this.length > num.length) return this.clone().iadd(num);\n\n\t    return num.clone().iadd(this);\n\t  };\n\n\t  // Subtract `num` from `this` in-place\n\t  BN.prototype.isub = function isub (num) {\n\t    // this - (-num) = this + num\n\t    if (num.negative !== 0) {\n\t      num.negative = 0;\n\t      var r = this.iadd(num);\n\t      num.negative = 1;\n\t      return r._normSign();\n\n\t    // -this - num = -(this + num)\n\t    } else if (this.negative !== 0) {\n\t      this.negative = 0;\n\t      this.iadd(num);\n\t      this.negative = 1;\n\t      return this._normSign();\n\t    }\n\n\t    // At this point both numbers are positive\n\t    var cmp = this.cmp(num);\n\n\t    // Optimization - zeroify\n\t    if (cmp === 0) {\n\t      this.negative = 0;\n\t      this.length = 1;\n\t      this.words[0] = 0;\n\t      return this;\n\t    }\n\n\t    // a > b\n\t    var a, b;\n\t    if (cmp > 0) {\n\t      a = this;\n\t      b = num;\n\t    } else {\n\t      a = num;\n\t      b = this;\n\t    }\n\n\t    var carry = 0;\n\t    for (var i = 0; i < b.length; i++) {\n\t      r = (a.words[i] | 0) - (b.words[i] | 0) + carry;\n\t      carry = r >> 26;\n\t      this.words[i] = r & 0x3ffffff;\n\t    }\n\t    for (; carry !== 0 && i < a.length; i++) {\n\t      r = (a.words[i] | 0) + carry;\n\t      carry = r >> 26;\n\t      this.words[i] = r & 0x3ffffff;\n\t    }\n\n\t    // Copy rest of the words\n\t    if (carry === 0 && i < a.length && a !== this) {\n\t      for (; i < a.length; i++) {\n\t        this.words[i] = a.words[i];\n\t      }\n\t    }\n\n\t    this.length = Math.max(this.length, i);\n\n\t    if (a !== this) {\n\t      this.negative = 1;\n\t    }\n\n\t    return this.strip();\n\t  };\n\n\t  // Subtract `num` from `this`\n\t  BN.prototype.sub = function sub (num) {\n\t    return this.clone().isub(num);\n\t  };\n\n\t  function smallMulTo (self, num, out) {\n\t    out.negative = num.negative ^ self.negative;\n\t    var len = (self.length + num.length) | 0;\n\t    out.length = len;\n\t    len = (len - 1) | 0;\n\n\t    // Peel one iteration (compiler can't do it, because of code complexity)\n\t    var a = self.words[0] | 0;\n\t    var b = num.words[0] | 0;\n\t    var r = a * b;\n\n\t    var lo = r & 0x3ffffff;\n\t    var carry = (r / 0x4000000) | 0;\n\t    out.words[0] = lo;\n\n\t    for (var k = 1; k < len; k++) {\n\t      // Sum all words with the same `i + j = k` and accumulate `ncarry`,\n\t      // note that ncarry could be >= 0x3ffffff\n\t      var ncarry = carry >>> 26;\n\t      var rword = carry & 0x3ffffff;\n\t      var maxJ = Math.min(k, num.length - 1);\n\t      for (var j = Math.max(0, k - self.length + 1); j <= maxJ; j++) {\n\t        var i = (k - j) | 0;\n\t        a = self.words[i] | 0;\n\t        b = num.words[j] | 0;\n\t        r = a * b + rword;\n\t        ncarry += (r / 0x4000000) | 0;\n\t        rword = r & 0x3ffffff;\n\t      }\n\t      out.words[k] = rword | 0;\n\t      carry = ncarry | 0;\n\t    }\n\t    if (carry !== 0) {\n\t      out.words[k] = carry | 0;\n\t    } else {\n\t      out.length--;\n\t    }\n\n\t    return out.strip();\n\t  }\n\n\t  // TODO(indutny): it may be reasonable to omit it for users who don't need\n\t  // to work with 256-bit numbers, otherwise it gives 20% improvement for 256-bit\n\t  // multiplication (like elliptic secp256k1).\n\t  var comb10MulTo = function comb10MulTo (self, num, out) {\n\t    var a = self.words;\n\t    var b = num.words;\n\t    var o = out.words;\n\t    var c = 0;\n\t    var lo;\n\t    var mid;\n\t    var hi;\n\t    var a0 = a[0] | 0;\n\t    var al0 = a0 & 0x1fff;\n\t    var ah0 = a0 >>> 13;\n\t    var a1 = a[1] | 0;\n\t    var al1 = a1 & 0x1fff;\n\t    var ah1 = a1 >>> 13;\n\t    var a2 = a[2] | 0;\n\t    var al2 = a2 & 0x1fff;\n\t    var ah2 = a2 >>> 13;\n\t    var a3 = a[3] | 0;\n\t    var al3 = a3 & 0x1fff;\n\t    var ah3 = a3 >>> 13;\n\t    var a4 = a[4] | 0;\n\t    var al4 = a4 & 0x1fff;\n\t    var ah4 = a4 >>> 13;\n\t    var a5 = a[5] | 0;\n\t    var al5 = a5 & 0x1fff;\n\t    var ah5 = a5 >>> 13;\n\t    var a6 = a[6] | 0;\n\t    var al6 = a6 & 0x1fff;\n\t    var ah6 = a6 >>> 13;\n\t    var a7 = a[7] | 0;\n\t    var al7 = a7 & 0x1fff;\n\t    var ah7 = a7 >>> 13;\n\t    var a8 = a[8] | 0;\n\t    var al8 = a8 & 0x1fff;\n\t    var ah8 = a8 >>> 13;\n\t    var a9 = a[9] | 0;\n\t    var al9 = a9 & 0x1fff;\n\t    var ah9 = a9 >>> 13;\n\t    var b0 = b[0] | 0;\n\t    var bl0 = b0 & 0x1fff;\n\t    var bh0 = b0 >>> 13;\n\t    var b1 = b[1] | 0;\n\t    var bl1 = b1 & 0x1fff;\n\t    var bh1 = b1 >>> 13;\n\t    var b2 = b[2] | 0;\n\t    var bl2 = b2 & 0x1fff;\n\t    var bh2 = b2 >>> 13;\n\t    var b3 = b[3] | 0;\n\t    var bl3 = b3 & 0x1fff;\n\t    var bh3 = b3 >>> 13;\n\t    var b4 = b[4] | 0;\n\t    var bl4 = b4 & 0x1fff;\n\t    var bh4 = b4 >>> 13;\n\t    var b5 = b[5] | 0;\n\t    var bl5 = b5 & 0x1fff;\n\t    var bh5 = b5 >>> 13;\n\t    var b6 = b[6] | 0;\n\t    var bl6 = b6 & 0x1fff;\n\t    var bh6 = b6 >>> 13;\n\t    var b7 = b[7] | 0;\n\t    var bl7 = b7 & 0x1fff;\n\t    var bh7 = b7 >>> 13;\n\t    var b8 = b[8] | 0;\n\t    var bl8 = b8 & 0x1fff;\n\t    var bh8 = b8 >>> 13;\n\t    var b9 = b[9] | 0;\n\t    var bl9 = b9 & 0x1fff;\n\t    var bh9 = b9 >>> 13;\n\n\t    out.negative = self.negative ^ num.negative;\n\t    out.length = 19;\n\t    /* k = 0 */\n\t    lo = Math.imul(al0, bl0);\n\t    mid = Math.imul(al0, bh0);\n\t    mid = (mid + Math.imul(ah0, bl0)) | 0;\n\t    hi = Math.imul(ah0, bh0);\n\t    var w0 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;\n\t    c = (((hi + (mid >>> 13)) | 0) + (w0 >>> 26)) | 0;\n\t    w0 &= 0x3ffffff;\n\t    /* k = 1 */\n\t    lo = Math.imul(al1, bl0);\n\t    mid = Math.imul(al1, bh0);\n\t    mid = (mid + Math.imul(ah1, bl0)) | 0;\n\t    hi = Math.imul(ah1, bh0);\n\t    lo = (lo + Math.imul(al0, bl1)) | 0;\n\t    mid = (mid + Math.imul(al0, bh1)) | 0;\n\t    mid = (mid + Math.imul(ah0, bl1)) | 0;\n\t    hi = (hi + Math.imul(ah0, bh1)) | 0;\n\t    var w1 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;\n\t    c = (((hi + (mid >>> 13)) | 0) + (w1 >>> 26)) | 0;\n\t    w1 &= 0x3ffffff;\n\t    /* k = 2 */\n\t    lo = Math.imul(al2, bl0);\n\t    mid = Math.imul(al2, bh0);\n\t    mid = (mid + Math.imul(ah2, bl0)) | 0;\n\t    hi = Math.imul(ah2, bh0);\n\t    lo = (lo + Math.imul(al1, bl1)) | 0;\n\t    mid = (mid + Math.imul(al1, bh1)) | 0;\n\t    mid = (mid + Math.imul(ah1, bl1)) | 0;\n\t    hi = (hi + Math.imul(ah1, bh1)) | 0;\n\t    lo = (lo + Math.imul(al0, bl2)) | 0;\n\t    mid = (mid + Math.imul(al0, bh2)) | 0;\n\t    mid = (mid + Math.imul(ah0, bl2)) | 0;\n\t    hi = (hi + Math.imul(ah0, bh2)) | 0;\n\t    var w2 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;\n\t    c = (((hi + (mid >>> 13)) | 0) + (w2 >>> 26)) | 0;\n\t    w2 &= 0x3ffffff;\n\t    /* k = 3 */\n\t    lo = Math.imul(al3, bl0);\n\t    mid = Math.imul(al3, bh0);\n\t    mid = (mid + Math.imul(ah3, bl0)) | 0;\n\t    hi = Math.imul(ah3, bh0);\n\t    lo = (lo + Math.imul(al2, bl1)) | 0;\n\t    mid = (mid + Math.imul(al2, bh1)) | 0;\n\t    mid = (mid + Math.imul(ah2, bl1)) | 0;\n\t    hi = (hi + Math.imul(ah2, bh1)) | 0;\n\t    lo = (lo + Math.imul(al1, bl2)) | 0;\n\t    mid = (mid + Math.imul(al1, bh2)) | 0;\n\t    mid = (mid + Math.imul(ah1, bl2)) | 0;\n\t    hi = (hi + Math.imul(ah1, bh2)) | 0;\n\t    lo = (lo + Math.imul(al0, bl3)) | 0;\n\t    mid = (mid + Math.imul(al0, bh3)) | 0;\n\t    mid = (mid + Math.imul(ah0, bl3)) | 0;\n\t    hi = (hi + Math.imul(ah0, bh3)) | 0;\n\t    var w3 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;\n\t    c = (((hi + (mid >>> 13)) | 0) + (w3 >>> 26)) | 0;\n\t    w3 &= 0x3ffffff;\n\t    /* k = 4 */\n\t    lo = Math.imul(al4, bl0);\n\t    mid = Math.imul(al4, bh0);\n\t    mid = (mid + Math.imul(ah4, bl0)) | 0;\n\t    hi = Math.imul(ah4, bh0);\n\t    lo = (lo + Math.imul(al3, bl1)) | 0;\n\t    mid = (mid + Math.imul(al3, bh1)) | 0;\n\t    mid = (mid + Math.imul(ah3, bl1)) | 0;\n\t    hi = (hi + Math.imul(ah3, bh1)) | 0;\n\t    lo = (lo + Math.imul(al2, bl2)) | 0;\n\t    mid = (mid + Math.imul(al2, bh2)) | 0;\n\t    mid = (mid + Math.imul(ah2, bl2)) | 0;\n\t    hi = (hi + Math.imul(ah2, bh2)) | 0;\n\t    lo = (lo + Math.imul(al1, bl3)) | 0;\n\t    mid = (mid + Math.imul(al1, bh3)) | 0;\n\t    mid = (mid + Math.imul(ah1, bl3)) | 0;\n\t    hi = (hi + Math.imul(ah1, bh3)) | 0;\n\t    lo = (lo + Math.imul(al0, bl4)) | 0;\n\t    mid = (mid + Math.imul(al0, bh4)) | 0;\n\t    mid = (mid + Math.imul(ah0, bl4)) | 0;\n\t    hi = (hi + Math.imul(ah0, bh4)) | 0;\n\t    var w4 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;\n\t    c = (((hi + (mid >>> 13)) | 0) + (w4 >>> 26)) | 0;\n\t    w4 &= 0x3ffffff;\n\t    /* k = 5 */\n\t    lo = Math.imul(al5, bl0);\n\t    mid = Math.imul(al5, bh0);\n\t    mid = (mid + Math.imul(ah5, bl0)) | 0;\n\t    hi = Math.imul(ah5, bh0);\n\t    lo = (lo + Math.imul(al4, bl1)) | 0;\n\t    mid = (mid + Math.imul(al4, bh1)) | 0;\n\t    mid = (mid + Math.imul(ah4, bl1)) | 0;\n\t    hi = (hi + Math.imul(ah4, bh1)) | 0;\n\t    lo = (lo + Math.imul(al3, bl2)) | 0;\n\t    mid = (mid + Math.imul(al3, bh2)) | 0;\n\t    mid = (mid + Math.imul(ah3, bl2)) | 0;\n\t    hi = (hi + Math.imul(ah3, bh2)) | 0;\n\t    lo = (lo + Math.imul(al2, bl3)) | 0;\n\t    mid = (mid + Math.imul(al2, bh3)) | 0;\n\t    mid = (mid + Math.imul(ah2, bl3)) | 0;\n\t    hi = (hi + Math.imul(ah2, bh3)) | 0;\n\t    lo = (lo + Math.imul(al1, bl4)) | 0;\n\t    mid = (mid + Math.imul(al1, bh4)) | 0;\n\t    mid = (mid + Math.imul(ah1, bl4)) | 0;\n\t    hi = (hi + Math.imul(ah1, bh4)) | 0;\n\t    lo = (lo + Math.imul(al0, bl5)) | 0;\n\t    mid = (mid + Math.imul(al0, bh5)) | 0;\n\t    mid = (mid + Math.imul(ah0, bl5)) | 0;\n\t    hi = (hi + Math.imul(ah0, bh5)) | 0;\n\t    var w5 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;\n\t    c = (((hi + (mid >>> 13)) | 0) + (w5 >>> 26)) | 0;\n\t    w5 &= 0x3ffffff;\n\t    /* k = 6 */\n\t    lo = Math.imul(al6, bl0);\n\t    mid = Math.imul(al6, bh0);\n\t    mid = (mid + Math.imul(ah6, bl0)) | 0;\n\t    hi = Math.imul(ah6, bh0);\n\t    lo = (lo + Math.imul(al5, bl1)) | 0;\n\t    mid = (mid + Math.imul(al5, bh1)) | 0;\n\t    mid = (mid + Math.imul(ah5, bl1)) | 0;\n\t    hi = (hi + Math.imul(ah5, bh1)) | 0;\n\t    lo = (lo + Math.imul(al4, bl2)) | 0;\n\t    mid = (mid + Math.imul(al4, bh2)) | 0;\n\t    mid = (mid + Math.imul(ah4, bl2)) | 0;\n\t    hi = (hi + Math.imul(ah4, bh2)) | 0;\n\t    lo = (lo + Math.imul(al3, bl3)) | 0;\n\t    mid = (mid + Math.imul(al3, bh3)) | 0;\n\t    mid = (mid + Math.imul(ah3, bl3)) | 0;\n\t    hi = (hi + Math.imul(ah3, bh3)) | 0;\n\t    lo = (lo + Math.imul(al2, bl4)) | 0;\n\t    mid = (mid + Math.imul(al2, bh4)) | 0;\n\t    mid = (mid + Math.imul(ah2, bl4)) | 0;\n\t    hi = (hi + Math.imul(ah2, bh4)) | 0;\n\t    lo = (lo + Math.imul(al1, bl5)) | 0;\n\t    mid = (mid + Math.imul(al1, bh5)) | 0;\n\t    mid = (mid + Math.imul(ah1, bl5)) | 0;\n\t    hi = (hi + Math.imul(ah1, bh5)) | 0;\n\t    lo = (lo + Math.imul(al0, bl6)) | 0;\n\t    mid = (mid + Math.imul(al0, bh6)) | 0;\n\t    mid = (mid + Math.imul(ah0, bl6)) | 0;\n\t    hi = (hi + Math.imul(ah0, bh6)) | 0;\n\t    var w6 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;\n\t    c = (((hi + (mid >>> 13)) | 0) + (w6 >>> 26)) | 0;\n\t    w6 &= 0x3ffffff;\n\t    /* k = 7 */\n\t    lo = Math.imul(al7, bl0);\n\t    mid = Math.imul(al7, bh0);\n\t    mid = (mid + Math.imul(ah7, bl0)) | 0;\n\t    hi = Math.imul(ah7, bh0);\n\t    lo = (lo + Math.imul(al6, bl1)) | 0;\n\t    mid = (mid + Math.imul(al6, bh1)) | 0;\n\t    mid = (mid + Math.imul(ah6, bl1)) | 0;\n\t    hi = (hi + Math.imul(ah6, bh1)) | 0;\n\t    lo = (lo + Math.imul(al5, bl2)) | 0;\n\t    mid = (mid + Math.imul(al5, bh2)) | 0;\n\t    mid = (mid + Math.imul(ah5, bl2)) | 0;\n\t    hi = (hi + Math.imul(ah5, bh2)) | 0;\n\t    lo = (lo + Math.imul(al4, bl3)) | 0;\n\t    mid = (mid + Math.imul(al4, bh3)) | 0;\n\t    mid = (mid + Math.imul(ah4, bl3)) | 0;\n\t    hi = (hi + Math.imul(ah4, bh3)) | 0;\n\t    lo = (lo + Math.imul(al3, bl4)) | 0;\n\t    mid = (mid + Math.imul(al3, bh4)) | 0;\n\t    mid = (mid + Math.imul(ah3, bl4)) | 0;\n\t    hi = (hi + Math.imul(ah3, bh4)) | 0;\n\t    lo = (lo + Math.imul(al2, bl5)) | 0;\n\t    mid = (mid + Math.imul(al2, bh5)) | 0;\n\t    mid = (mid + Math.imul(ah2, bl5)) | 0;\n\t    hi = (hi + Math.imul(ah2, bh5)) | 0;\n\t    lo = (lo + Math.imul(al1, bl6)) | 0;\n\t    mid = (mid + Math.imul(al1, bh6)) | 0;\n\t    mid = (mid + Math.imul(ah1, bl6)) | 0;\n\t    hi = (hi + Math.imul(ah1, bh6)) | 0;\n\t    lo = (lo + Math.imul(al0, bl7)) | 0;\n\t    mid = (mid + Math.imul(al0, bh7)) | 0;\n\t    mid = (mid + Math.imul(ah0, bl7)) | 0;\n\t    hi = (hi + Math.imul(ah0, bh7)) | 0;\n\t    var w7 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;\n\t    c = (((hi + (mid >>> 13)) | 0) + (w7 >>> 26)) | 0;\n\t    w7 &= 0x3ffffff;\n\t    /* k = 8 */\n\t    lo = Math.imul(al8, bl0);\n\t    mid = Math.imul(al8, bh0);\n\t    mid = (mid + Math.imul(ah8, bl0)) | 0;\n\t    hi = Math.imul(ah8, bh0);\n\t    lo = (lo + Math.imul(al7, bl1)) | 0;\n\t    mid = (mid + Math.imul(al7, bh1)) | 0;\n\t    mid = (mid + Math.imul(ah7, bl1)) | 0;\n\t    hi = (hi + Math.imul(ah7, bh1)) | 0;\n\t    lo = (lo + Math.imul(al6, bl2)) | 0;\n\t    mid = (mid + Math.imul(al6, bh2)) | 0;\n\t    mid = (mid + Math.imul(ah6, bl2)) | 0;\n\t    hi = (hi + Math.imul(ah6, bh2)) | 0;\n\t    lo = (lo + Math.imul(al5, bl3)) | 0;\n\t    mid = (mid + Math.imul(al5, bh3)) | 0;\n\t    mid = (mid + Math.imul(ah5, bl3)) | 0;\n\t    hi = (hi + Math.imul(ah5, bh3)) | 0;\n\t    lo = (lo + Math.imul(al4, bl4)) | 0;\n\t    mid = (mid + Math.imul(al4, bh4)) | 0;\n\t    mid = (mid + Math.imul(ah4, bl4)) | 0;\n\t    hi = (hi + Math.imul(ah4, bh4)) | 0;\n\t    lo = (lo + Math.imul(al3, bl5)) | 0;\n\t    mid = (mid + Math.imul(al3, bh5)) | 0;\n\t    mid = (mid + Math.imul(ah3, bl5)) | 0;\n\t    hi = (hi + Math.imul(ah3, bh5)) | 0;\n\t    lo = (lo + Math.imul(al2, bl6)) | 0;\n\t    mid = (mid + Math.imul(al2, bh6)) | 0;\n\t    mid = (mid + Math.imul(ah2, bl6)) | 0;\n\t    hi = (hi + Math.imul(ah2, bh6)) | 0;\n\t    lo = (lo + Math.imul(al1, bl7)) | 0;\n\t    mid = (mid + Math.imul(al1, bh7)) | 0;\n\t    mid = (mid + Math.imul(ah1, bl7)) | 0;\n\t    hi = (hi + Math.imul(ah1, bh7)) | 0;\n\t    lo = (lo + Math.imul(al0, bl8)) | 0;\n\t    mid = (mid + Math.imul(al0, bh8)) | 0;\n\t    mid = (mid + Math.imul(ah0, bl8)) | 0;\n\t    hi = (hi + Math.imul(ah0, bh8)) | 0;\n\t    var w8 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;\n\t    c = (((hi + (mid >>> 13)) | 0) + (w8 >>> 26)) | 0;\n\t    w8 &= 0x3ffffff;\n\t    /* k = 9 */\n\t    lo = Math.imul(al9, bl0);\n\t    mid = Math.imul(al9, bh0);\n\t    mid = (mid + Math.imul(ah9, bl0)) | 0;\n\t    hi = Math.imul(ah9, bh0);\n\t    lo = (lo + Math.imul(al8, bl1)) | 0;\n\t    mid = (mid + Math.imul(al8, bh1)) | 0;\n\t    mid = (mid + Math.imul(ah8, bl1)) | 0;\n\t    hi = (hi + Math.imul(ah8, bh1)) | 0;\n\t    lo = (lo + Math.imul(al7, bl2)) | 0;\n\t    mid = (mid + Math.imul(al7, bh2)) | 0;\n\t    mid = (mid + Math.imul(ah7, bl2)) | 0;\n\t    hi = (hi + Math.imul(ah7, bh2)) | 0;\n\t    lo = (lo + Math.imul(al6, bl3)) | 0;\n\t    mid = (mid + Math.imul(al6, bh3)) | 0;\n\t    mid = (mid + Math.imul(ah6, bl3)) | 0;\n\t    hi = (hi + Math.imul(ah6, bh3)) | 0;\n\t    lo = (lo + Math.imul(al5, bl4)) | 0;\n\t    mid = (mid + Math.imul(al5, bh4)) | 0;\n\t    mid = (mid + Math.imul(ah5, bl4)) | 0;\n\t    hi = (hi + Math.imul(ah5, bh4)) | 0;\n\t    lo = (lo + Math.imul(al4, bl5)) | 0;\n\t    mid = (mid + Math.imul(al4, bh5)) | 0;\n\t    mid = (mid + Math.imul(ah4, bl5)) | 0;\n\t    hi = (hi + Math.imul(ah4, bh5)) | 0;\n\t    lo = (lo + Math.imul(al3, bl6)) | 0;\n\t    mid = (mid + Math.imul(al3, bh6)) | 0;\n\t    mid = (mid + Math.imul(ah3, bl6)) | 0;\n\t    hi = (hi + Math.imul(ah3, bh6)) | 0;\n\t    lo = (lo + Math.imul(al2, bl7)) | 0;\n\t    mid = (mid + Math.imul(al2, bh7)) | 0;\n\t    mid = (mid + Math.imul(ah2, bl7)) | 0;\n\t    hi = (hi + Math.imul(ah2, bh7)) | 0;\n\t    lo = (lo + Math.imul(al1, bl8)) | 0;\n\t    mid = (mid + Math.imul(al1, bh8)) | 0;\n\t    mid = (mid + Math.imul(ah1, bl8)) | 0;\n\t    hi = (hi + Math.imul(ah1, bh8)) | 0;\n\t    lo = (lo + Math.imul(al0, bl9)) | 0;\n\t    mid = (mid + Math.imul(al0, bh9)) | 0;\n\t    mid = (mid + Math.imul(ah0, bl9)) | 0;\n\t    hi = (hi + Math.imul(ah0, bh9)) | 0;\n\t    var w9 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;\n\t    c = (((hi + (mid >>> 13)) | 0) + (w9 >>> 26)) | 0;\n\t    w9 &= 0x3ffffff;\n\t    /* k = 10 */\n\t    lo = Math.imul(al9, bl1);\n\t    mid = Math.imul(al9, bh1);\n\t    mid = (mid + Math.imul(ah9, bl1)) | 0;\n\t    hi = Math.imul(ah9, bh1);\n\t    lo = (lo + Math.imul(al8, bl2)) | 0;\n\t    mid = (mid + Math.imul(al8, bh2)) | 0;\n\t    mid = (mid + Math.imul(ah8, bl2)) | 0;\n\t    hi = (hi + Math.imul(ah8, bh2)) | 0;\n\t    lo = (lo + Math.imul(al7, bl3)) | 0;\n\t    mid = (mid + Math.imul(al7, bh3)) | 0;\n\t    mid = (mid + Math.imul(ah7, bl3)) | 0;\n\t    hi = (hi + Math.imul(ah7, bh3)) | 0;\n\t    lo = (lo + Math.imul(al6, bl4)) | 0;\n\t    mid = (mid + Math.imul(al6, bh4)) | 0;\n\t    mid = (mid + Math.imul(ah6, bl4)) | 0;\n\t    hi = (hi + Math.imul(ah6, bh4)) | 0;\n\t    lo = (lo + Math.imul(al5, bl5)) | 0;\n\t    mid = (mid + Math.imul(al5, bh5)) | 0;\n\t    mid = (mid + Math.imul(ah5, bl5)) | 0;\n\t    hi = (hi + Math.imul(ah5, bh5)) | 0;\n\t    lo = (lo + Math.imul(al4, bl6)) | 0;\n\t    mid = (mid + Math.imul(al4, bh6)) | 0;\n\t    mid = (mid + Math.imul(ah4, bl6)) | 0;\n\t    hi = (hi + Math.imul(ah4, bh6)) | 0;\n\t    lo = (lo + Math.imul(al3, bl7)) | 0;\n\t    mid = (mid + Math.imul(al3, bh7)) | 0;\n\t    mid = (mid + Math.imul(ah3, bl7)) | 0;\n\t    hi = (hi + Math.imul(ah3, bh7)) | 0;\n\t    lo = (lo + Math.imul(al2, bl8)) | 0;\n\t    mid = (mid + Math.imul(al2, bh8)) | 0;\n\t    mid = (mid + Math.imul(ah2, bl8)) | 0;\n\t    hi = (hi + Math.imul(ah2, bh8)) | 0;\n\t    lo = (lo + Math.imul(al1, bl9)) | 0;\n\t    mid = (mid + Math.imul(al1, bh9)) | 0;\n\t    mid = (mid + Math.imul(ah1, bl9)) | 0;\n\t    hi = (hi + Math.imul(ah1, bh9)) | 0;\n\t    var w10 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;\n\t    c = (((hi + (mid >>> 13)) | 0) + (w10 >>> 26)) | 0;\n\t    w10 &= 0x3ffffff;\n\t    /* k = 11 */\n\t    lo = Math.imul(al9, bl2);\n\t    mid = Math.imul(al9, bh2);\n\t    mid = (mid + Math.imul(ah9, bl2)) | 0;\n\t    hi = Math.imul(ah9, bh2);\n\t    lo = (lo + Math.imul(al8, bl3)) | 0;\n\t    mid = (mid + Math.imul(al8, bh3)) | 0;\n\t    mid = (mid + Math.imul(ah8, bl3)) | 0;\n\t    hi = (hi + Math.imul(ah8, bh3)) | 0;\n\t    lo = (lo + Math.imul(al7, bl4)) | 0;\n\t    mid = (mid + Math.imul(al7, bh4)) | 0;\n\t    mid = (mid + Math.imul(ah7, bl4)) | 0;\n\t    hi = (hi + Math.imul(ah7, bh4)) | 0;\n\t    lo = (lo + Math.imul(al6, bl5)) | 0;\n\t    mid = (mid + Math.imul(al6, bh5)) | 0;\n\t    mid = (mid + Math.imul(ah6, bl5)) | 0;\n\t    hi = (hi + Math.imul(ah6, bh5)) | 0;\n\t    lo = (lo + Math.imul(al5, bl6)) | 0;\n\t    mid = (mid + Math.imul(al5, bh6)) | 0;\n\t    mid = (mid + Math.imul(ah5, bl6)) | 0;\n\t    hi = (hi + Math.imul(ah5, bh6)) | 0;\n\t    lo = (lo + Math.imul(al4, bl7)) | 0;\n\t    mid = (mid + Math.imul(al4, bh7)) | 0;\n\t    mid = (mid + Math.imul(ah4, bl7)) | 0;\n\t    hi = (hi + Math.imul(ah4, bh7)) | 0;\n\t    lo = (lo + Math.imul(al3, bl8)) | 0;\n\t    mid = (mid + Math.imul(al3, bh8)) | 0;\n\t    mid = (mid + Math.imul(ah3, bl8)) | 0;\n\t    hi = (hi + Math.imul(ah3, bh8)) | 0;\n\t    lo = (lo + Math.imul(al2, bl9)) | 0;\n\t    mid = (mid + Math.imul(al2, bh9)) | 0;\n\t    mid = (mid + Math.imul(ah2, bl9)) | 0;\n\t    hi = (hi + Math.imul(ah2, bh9)) | 0;\n\t    var w11 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;\n\t    c = (((hi + (mid >>> 13)) | 0) + (w11 >>> 26)) | 0;\n\t    w11 &= 0x3ffffff;\n\t    /* k = 12 */\n\t    lo = Math.imul(al9, bl3);\n\t    mid = Math.imul(al9, bh3);\n\t    mid = (mid + Math.imul(ah9, bl3)) | 0;\n\t    hi = Math.imul(ah9, bh3);\n\t    lo = (lo + Math.imul(al8, bl4)) | 0;\n\t    mid = (mid + Math.imul(al8, bh4)) | 0;\n\t    mid = (mid + Math.imul(ah8, bl4)) | 0;\n\t    hi = (hi + Math.imul(ah8, bh4)) | 0;\n\t    lo = (lo + Math.imul(al7, bl5)) | 0;\n\t    mid = (mid + Math.imul(al7, bh5)) | 0;\n\t    mid = (mid + Math.imul(ah7, bl5)) | 0;\n\t    hi = (hi + Math.imul(ah7, bh5)) | 0;\n\t    lo = (lo + Math.imul(al6, bl6)) | 0;\n\t    mid = (mid + Math.imul(al6, bh6)) | 0;\n\t    mid = (mid + Math.imul(ah6, bl6)) | 0;\n\t    hi = (hi + Math.imul(ah6, bh6)) | 0;\n\t    lo = (lo + Math.imul(al5, bl7)) | 0;\n\t    mid = (mid + Math.imul(al5, bh7)) | 0;\n\t    mid = (mid + Math.imul(ah5, bl7)) | 0;\n\t    hi = (hi + Math.imul(ah5, bh7)) | 0;\n\t    lo = (lo + Math.imul(al4, bl8)) | 0;\n\t    mid = (mid + Math.imul(al4, bh8)) | 0;\n\t    mid = (mid + Math.imul(ah4, bl8)) | 0;\n\t    hi = (hi + Math.imul(ah4, bh8)) | 0;\n\t    lo = (lo + Math.imul(al3, bl9)) | 0;\n\t    mid = (mid + Math.imul(al3, bh9)) | 0;\n\t    mid = (mid + Math.imul(ah3, bl9)) | 0;\n\t    hi = (hi + Math.imul(ah3, bh9)) | 0;\n\t    var w12 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;\n\t    c = (((hi + (mid >>> 13)) | 0) + (w12 >>> 26)) | 0;\n\t    w12 &= 0x3ffffff;\n\t    /* k = 13 */\n\t    lo = Math.imul(al9, bl4);\n\t    mid = Math.imul(al9, bh4);\n\t    mid = (mid + Math.imul(ah9, bl4)) | 0;\n\t    hi = Math.imul(ah9, bh4);\n\t    lo = (lo + Math.imul(al8, bl5)) | 0;\n\t    mid = (mid + Math.imul(al8, bh5)) | 0;\n\t    mid = (mid + Math.imul(ah8, bl5)) | 0;\n\t    hi = (hi + Math.imul(ah8, bh5)) | 0;\n\t    lo = (lo + Math.imul(al7, bl6)) | 0;\n\t    mid = (mid + Math.imul(al7, bh6)) | 0;\n\t    mid = (mid + Math.imul(ah7, bl6)) | 0;\n\t    hi = (hi + Math.imul(ah7, bh6)) | 0;\n\t    lo = (lo + Math.imul(al6, bl7)) | 0;\n\t    mid = (mid + Math.imul(al6, bh7)) | 0;\n\t    mid = (mid + Math.imul(ah6, bl7)) | 0;\n\t    hi = (hi + Math.imul(ah6, bh7)) | 0;\n\t    lo = (lo + Math.imul(al5, bl8)) | 0;\n\t    mid = (mid + Math.imul(al5, bh8)) | 0;\n\t    mid = (mid + Math.imul(ah5, bl8)) | 0;\n\t    hi = (hi + Math.imul(ah5, bh8)) | 0;\n\t    lo = (lo + Math.imul(al4, bl9)) | 0;\n\t    mid = (mid + Math.imul(al4, bh9)) | 0;\n\t    mid = (mid + Math.imul(ah4, bl9)) | 0;\n\t    hi = (hi + Math.imul(ah4, bh9)) | 0;\n\t    var w13 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;\n\t    c = (((hi + (mid >>> 13)) | 0) + (w13 >>> 26)) | 0;\n\t    w13 &= 0x3ffffff;\n\t    /* k = 14 */\n\t    lo = Math.imul(al9, bl5);\n\t    mid = Math.imul(al9, bh5);\n\t    mid = (mid + Math.imul(ah9, bl5)) | 0;\n\t    hi = Math.imul(ah9, bh5);\n\t    lo = (lo + Math.imul(al8, bl6)) | 0;\n\t    mid = (mid + Math.imul(al8, bh6)) | 0;\n\t    mid = (mid + Math.imul(ah8, bl6)) | 0;\n\t    hi = (hi + Math.imul(ah8, bh6)) | 0;\n\t    lo = (lo + Math.imul(al7, bl7)) | 0;\n\t    mid = (mid + Math.imul(al7, bh7)) | 0;\n\t    mid = (mid + Math.imul(ah7, bl7)) | 0;\n\t    hi = (hi + Math.imul(ah7, bh7)) | 0;\n\t    lo = (lo + Math.imul(al6, bl8)) | 0;\n\t    mid = (mid + Math.imul(al6, bh8)) | 0;\n\t    mid = (mid + Math.imul(ah6, bl8)) | 0;\n\t    hi = (hi + Math.imul(ah6, bh8)) | 0;\n\t    lo = (lo + Math.imul(al5, bl9)) | 0;\n\t    mid = (mid + Math.imul(al5, bh9)) | 0;\n\t    mid = (mid + Math.imul(ah5, bl9)) | 0;\n\t    hi = (hi + Math.imul(ah5, bh9)) | 0;\n\t    var w14 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;\n\t    c = (((hi + (mid >>> 13)) | 0) + (w14 >>> 26)) | 0;\n\t    w14 &= 0x3ffffff;\n\t    /* k = 15 */\n\t    lo = Math.imul(al9, bl6);\n\t    mid = Math.imul(al9, bh6);\n\t    mid = (mid + Math.imul(ah9, bl6)) | 0;\n\t    hi = Math.imul(ah9, bh6);\n\t    lo = (lo + Math.imul(al8, bl7)) | 0;\n\t    mid = (mid + Math.imul(al8, bh7)) | 0;\n\t    mid = (mid + Math.imul(ah8, bl7)) | 0;\n\t    hi = (hi + Math.imul(ah8, bh7)) | 0;\n\t    lo = (lo + Math.imul(al7, bl8)) | 0;\n\t    mid = (mid + Math.imul(al7, bh8)) | 0;\n\t    mid = (mid + Math.imul(ah7, bl8)) | 0;\n\t    hi = (hi + Math.imul(ah7, bh8)) | 0;\n\t    lo = (lo + Math.imul(al6, bl9)) | 0;\n\t    mid = (mid + Math.imul(al6, bh9)) | 0;\n\t    mid = (mid + Math.imul(ah6, bl9)) | 0;\n\t    hi = (hi + Math.imul(ah6, bh9)) | 0;\n\t    var w15 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;\n\t    c = (((hi + (mid >>> 13)) | 0) + (w15 >>> 26)) | 0;\n\t    w15 &= 0x3ffffff;\n\t    /* k = 16 */\n\t    lo = Math.imul(al9, bl7);\n\t    mid = Math.imul(al9, bh7);\n\t    mid = (mid + Math.imul(ah9, bl7)) | 0;\n\t    hi = Math.imul(ah9, bh7);\n\t    lo = (lo + Math.imul(al8, bl8)) | 0;\n\t    mid = (mid + Math.imul(al8, bh8)) | 0;\n\t    mid = (mid + Math.imul(ah8, bl8)) | 0;\n\t    hi = (hi + Math.imul(ah8, bh8)) | 0;\n\t    lo = (lo + Math.imul(al7, bl9)) | 0;\n\t    mid = (mid + Math.imul(al7, bh9)) | 0;\n\t    mid = (mid + Math.imul(ah7, bl9)) | 0;\n\t    hi = (hi + Math.imul(ah7, bh9)) | 0;\n\t    var w16 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;\n\t    c = (((hi + (mid >>> 13)) | 0) + (w16 >>> 26)) | 0;\n\t    w16 &= 0x3ffffff;\n\t    /* k = 17 */\n\t    lo = Math.imul(al9, bl8);\n\t    mid = Math.imul(al9, bh8);\n\t    mid = (mid + Math.imul(ah9, bl8)) | 0;\n\t    hi = Math.imul(ah9, bh8);\n\t    lo = (lo + Math.imul(al8, bl9)) | 0;\n\t    mid = (mid + Math.imul(al8, bh9)) | 0;\n\t    mid = (mid + Math.imul(ah8, bl9)) | 0;\n\t    hi = (hi + Math.imul(ah8, bh9)) | 0;\n\t    var w17 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;\n\t    c = (((hi + (mid >>> 13)) | 0) + (w17 >>> 26)) | 0;\n\t    w17 &= 0x3ffffff;\n\t    /* k = 18 */\n\t    lo = Math.imul(al9, bl9);\n\t    mid = Math.imul(al9, bh9);\n\t    mid = (mid + Math.imul(ah9, bl9)) | 0;\n\t    hi = Math.imul(ah9, bh9);\n\t    var w18 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;\n\t    c = (((hi + (mid >>> 13)) | 0) + (w18 >>> 26)) | 0;\n\t    w18 &= 0x3ffffff;\n\t    o[0] = w0;\n\t    o[1] = w1;\n\t    o[2] = w2;\n\t    o[3] = w3;\n\t    o[4] = w4;\n\t    o[5] = w5;\n\t    o[6] = w6;\n\t    o[7] = w7;\n\t    o[8] = w8;\n\t    o[9] = w9;\n\t    o[10] = w10;\n\t    o[11] = w11;\n\t    o[12] = w12;\n\t    o[13] = w13;\n\t    o[14] = w14;\n\t    o[15] = w15;\n\t    o[16] = w16;\n\t    o[17] = w17;\n\t    o[18] = w18;\n\t    if (c !== 0) {\n\t      o[19] = c;\n\t      out.length++;\n\t    }\n\t    return out;\n\t  };\n\n\t  // Polyfill comb\n\t  if (!Math.imul) {\n\t    comb10MulTo = smallMulTo;\n\t  }\n\n\t  function bigMulTo (self, num, out) {\n\t    out.negative = num.negative ^ self.negative;\n\t    out.length = self.length + num.length;\n\n\t    var carry = 0;\n\t    var hncarry = 0;\n\t    for (var k = 0; k < out.length - 1; k++) {\n\t      // Sum all words with the same `i + j = k` and accumulate `ncarry`,\n\t      // note that ncarry could be >= 0x3ffffff\n\t      var ncarry = hncarry;\n\t      hncarry = 0;\n\t      var rword = carry & 0x3ffffff;\n\t      var maxJ = Math.min(k, num.length - 1);\n\t      for (var j = Math.max(0, k - self.length + 1); j <= maxJ; j++) {\n\t        var i = k - j;\n\t        var a = self.words[i] | 0;\n\t        var b = num.words[j] | 0;\n\t        var r = a * b;\n\n\t        var lo = r & 0x3ffffff;\n\t        ncarry = (ncarry + ((r / 0x4000000) | 0)) | 0;\n\t        lo = (lo + rword) | 0;\n\t        rword = lo & 0x3ffffff;\n\t        ncarry = (ncarry + (lo >>> 26)) | 0;\n\n\t        hncarry += ncarry >>> 26;\n\t        ncarry &= 0x3ffffff;\n\t      }\n\t      out.words[k] = rword;\n\t      carry = ncarry;\n\t      ncarry = hncarry;\n\t    }\n\t    if (carry !== 0) {\n\t      out.words[k] = carry;\n\t    } else {\n\t      out.length--;\n\t    }\n\n\t    return out.strip();\n\t  }\n\n\t  function jumboMulTo (self, num, out) {\n\t    var fftm = new FFTM();\n\t    return fftm.mulp(self, num, out);\n\t  }\n\n\t  BN.prototype.mulTo = function mulTo (num, out) {\n\t    var res;\n\t    var len = this.length + num.length;\n\t    if (this.length === 10 && num.length === 10) {\n\t      res = comb10MulTo(this, num, out);\n\t    } else if (len < 63) {\n\t      res = smallMulTo(this, num, out);\n\t    } else if (len < 1024) {\n\t      res = bigMulTo(this, num, out);\n\t    } else {\n\t      res = jumboMulTo(this, num, out);\n\t    }\n\n\t    return res;\n\t  };\n\n\t  // Cooley-Tukey algorithm for FFT\n\t  // slightly revisited to rely on looping instead of recursion\n\n\t  function FFTM (x, y) {\n\t    this.x = x;\n\t    this.y = y;\n\t  }\n\n\t  FFTM.prototype.makeRBT = function makeRBT (N) {\n\t    var t = new Array(N);\n\t    var l = BN.prototype._countBits(N) - 1;\n\t    for (var i = 0; i < N; i++) {\n\t      t[i] = this.revBin(i, l, N);\n\t    }\n\n\t    return t;\n\t  };\n\n\t  // Returns binary-reversed representation of `x`\n\t  FFTM.prototype.revBin = function revBin (x, l, N) {\n\t    if (x === 0 || x === N - 1) return x;\n\n\t    var rb = 0;\n\t    for (var i = 0; i < l; i++) {\n\t      rb |= (x & 1) << (l - i - 1);\n\t      x >>= 1;\n\t    }\n\n\t    return rb;\n\t  };\n\n\t  // Performs \"tweedling\" phase, therefore 'emulating'\n\t  // behaviour of the recursive algorithm\n\t  FFTM.prototype.permute = function permute (rbt, rws, iws, rtws, itws, N) {\n\t    for (var i = 0; i < N; i++) {\n\t      rtws[i] = rws[rbt[i]];\n\t      itws[i] = iws[rbt[i]];\n\t    }\n\t  };\n\n\t  FFTM.prototype.transform = function transform (rws, iws, rtws, itws, N, rbt) {\n\t    this.permute(rbt, rws, iws, rtws, itws, N);\n\n\t    for (var s = 1; s < N; s <<= 1) {\n\t      var l = s << 1;\n\n\t      var rtwdf = Math.cos(2 * Math.PI / l);\n\t      var itwdf = Math.sin(2 * Math.PI / l);\n\n\t      for (var p = 0; p < N; p += l) {\n\t        var rtwdf_ = rtwdf;\n\t        var itwdf_ = itwdf;\n\n\t        for (var j = 0; j < s; j++) {\n\t          var re = rtws[p + j];\n\t          var ie = itws[p + j];\n\n\t          var ro = rtws[p + j + s];\n\t          var io = itws[p + j + s];\n\n\t          var rx = rtwdf_ * ro - itwdf_ * io;\n\n\t          io = rtwdf_ * io + itwdf_ * ro;\n\t          ro = rx;\n\n\t          rtws[p + j] = re + ro;\n\t          itws[p + j] = ie + io;\n\n\t          rtws[p + j + s] = re - ro;\n\t          itws[p + j + s] = ie - io;\n\n\t          /* jshint maxdepth : false */\n\t          if (j !== l) {\n\t            rx = rtwdf * rtwdf_ - itwdf * itwdf_;\n\n\t            itwdf_ = rtwdf * itwdf_ + itwdf * rtwdf_;\n\t            rtwdf_ = rx;\n\t          }\n\t        }\n\t      }\n\t    }\n\t  };\n\n\t  FFTM.prototype.guessLen13b = function guessLen13b (n, m) {\n\t    var N = Math.max(m, n) | 1;\n\t    var odd = N & 1;\n\t    var i = 0;\n\t    for (N = N / 2 | 0; N; N = N >>> 1) {\n\t      i++;\n\t    }\n\n\t    return 1 << i + 1 + odd;\n\t  };\n\n\t  FFTM.prototype.conjugate = function conjugate (rws, iws, N) {\n\t    if (N <= 1) return;\n\n\t    for (var i = 0; i < N / 2; i++) {\n\t      var t = rws[i];\n\n\t      rws[i] = rws[N - i - 1];\n\t      rws[N - i - 1] = t;\n\n\t      t = iws[i];\n\n\t      iws[i] = -iws[N - i - 1];\n\t      iws[N - i - 1] = -t;\n\t    }\n\t  };\n\n\t  FFTM.prototype.normalize13b = function normalize13b (ws, N) {\n\t    var carry = 0;\n\t    for (var i = 0; i < N / 2; i++) {\n\t      var w = Math.round(ws[2 * i + 1] / N) * 0x2000 +\n\t        Math.round(ws[2 * i] / N) +\n\t        carry;\n\n\t      ws[i] = w & 0x3ffffff;\n\n\t      if (w < 0x4000000) {\n\t        carry = 0;\n\t      } else {\n\t        carry = w / 0x4000000 | 0;\n\t      }\n\t    }\n\n\t    return ws;\n\t  };\n\n\t  FFTM.prototype.convert13b = function convert13b (ws, len, rws, N) {\n\t    var carry = 0;\n\t    for (var i = 0; i < len; i++) {\n\t      carry = carry + (ws[i] | 0);\n\n\t      rws[2 * i] = carry & 0x1fff; carry = carry >>> 13;\n\t      rws[2 * i + 1] = carry & 0x1fff; carry = carry >>> 13;\n\t    }\n\n\t    // Pad with zeroes\n\t    for (i = 2 * len; i < N; ++i) {\n\t      rws[i] = 0;\n\t    }\n\n\t    assert(carry === 0);\n\t    assert((carry & ~0x1fff) === 0);\n\t  };\n\n\t  FFTM.prototype.stub = function stub (N) {\n\t    var ph = new Array(N);\n\t    for (var i = 0; i < N; i++) {\n\t      ph[i] = 0;\n\t    }\n\n\t    return ph;\n\t  };\n\n\t  FFTM.prototype.mulp = function mulp (x, y, out) {\n\t    var N = 2 * this.guessLen13b(x.length, y.length);\n\n\t    var rbt = this.makeRBT(N);\n\n\t    var _ = this.stub(N);\n\n\t    var rws = new Array(N);\n\t    var rwst = new Array(N);\n\t    var iwst = new Array(N);\n\n\t    var nrws = new Array(N);\n\t    var nrwst = new Array(N);\n\t    var niwst = new Array(N);\n\n\t    var rmws = out.words;\n\t    rmws.length = N;\n\n\t    this.convert13b(x.words, x.length, rws, N);\n\t    this.convert13b(y.words, y.length, nrws, N);\n\n\t    this.transform(rws, _, rwst, iwst, N, rbt);\n\t    this.transform(nrws, _, nrwst, niwst, N, rbt);\n\n\t    for (var i = 0; i < N; i++) {\n\t      var rx = rwst[i] * nrwst[i] - iwst[i] * niwst[i];\n\t      iwst[i] = rwst[i] * niwst[i] + iwst[i] * nrwst[i];\n\t      rwst[i] = rx;\n\t    }\n\n\t    this.conjugate(rwst, iwst, N);\n\t    this.transform(rwst, iwst, rmws, _, N, rbt);\n\t    this.conjugate(rmws, _, N);\n\t    this.normalize13b(rmws, N);\n\n\t    out.negative = x.negative ^ y.negative;\n\t    out.length = x.length + y.length;\n\t    return out.strip();\n\t  };\n\n\t  // Multiply `this` by `num`\n\t  BN.prototype.mul = function mul (num) {\n\t    var out = new BN(null);\n\t    out.words = new Array(this.length + num.length);\n\t    return this.mulTo(num, out);\n\t  };\n\n\t  // Multiply employing FFT\n\t  BN.prototype.mulf = function mulf (num) {\n\t    var out = new BN(null);\n\t    out.words = new Array(this.length + num.length);\n\t    return jumboMulTo(this, num, out);\n\t  };\n\n\t  // In-place Multiplication\n\t  BN.prototype.imul = function imul (num) {\n\t    return this.clone().mulTo(num, this);\n\t  };\n\n\t  BN.prototype.imuln = function imuln (num) {\n\t    assert(typeof num === 'number');\n\t    assert(num < 0x4000000);\n\n\t    // Carry\n\t    var carry = 0;\n\t    for (var i = 0; i < this.length; i++) {\n\t      var w = (this.words[i] | 0) * num;\n\t      var lo = (w & 0x3ffffff) + (carry & 0x3ffffff);\n\t      carry >>= 26;\n\t      carry += (w / 0x4000000) | 0;\n\t      // NOTE: lo is 27bit maximum\n\t      carry += lo >>> 26;\n\t      this.words[i] = lo & 0x3ffffff;\n\t    }\n\n\t    if (carry !== 0) {\n\t      this.words[i] = carry;\n\t      this.length++;\n\t    }\n\n\t    return this;\n\t  };\n\n\t  BN.prototype.muln = function muln (num) {\n\t    return this.clone().imuln(num);\n\t  };\n\n\t  // `this` * `this`\n\t  BN.prototype.sqr = function sqr () {\n\t    return this.mul(this);\n\t  };\n\n\t  // `this` * `this` in-place\n\t  BN.prototype.isqr = function isqr () {\n\t    return this.imul(this.clone());\n\t  };\n\n\t  // Math.pow(`this`, `num`)\n\t  BN.prototype.pow = function pow (num) {\n\t    var w = toBitArray(num);\n\t    if (w.length === 0) return new BN(1);\n\n\t    // Skip leading zeroes\n\t    var res = this;\n\t    for (var i = 0; i < w.length; i++, res = res.sqr()) {\n\t      if (w[i] !== 0) break;\n\t    }\n\n\t    if (++i < w.length) {\n\t      for (var q = res.sqr(); i < w.length; i++, q = q.sqr()) {\n\t        if (w[i] === 0) continue;\n\n\t        res = res.mul(q);\n\t      }\n\t    }\n\n\t    return res;\n\t  };\n\n\t  // Shift-left in-place\n\t  BN.prototype.iushln = function iushln (bits) {\n\t    assert(typeof bits === 'number' && bits >= 0);\n\t    var r = bits % 26;\n\t    var s = (bits - r) / 26;\n\t    var carryMask = (0x3ffffff >>> (26 - r)) << (26 - r);\n\t    var i;\n\n\t    if (r !== 0) {\n\t      var carry = 0;\n\n\t      for (i = 0; i < this.length; i++) {\n\t        var newCarry = this.words[i] & carryMask;\n\t        var c = ((this.words[i] | 0) - newCarry) << r;\n\t        this.words[i] = c | carry;\n\t        carry = newCarry >>> (26 - r);\n\t      }\n\n\t      if (carry) {\n\t        this.words[i] = carry;\n\t        this.length++;\n\t      }\n\t    }\n\n\t    if (s !== 0) {\n\t      for (i = this.length - 1; i >= 0; i--) {\n\t        this.words[i + s] = this.words[i];\n\t      }\n\n\t      for (i = 0; i < s; i++) {\n\t        this.words[i] = 0;\n\t      }\n\n\t      this.length += s;\n\t    }\n\n\t    return this.strip();\n\t  };\n\n\t  BN.prototype.ishln = function ishln (bits) {\n\t    // TODO(indutny): implement me\n\t    assert(this.negative === 0);\n\t    return this.iushln(bits);\n\t  };\n\n\t  // Shift-right in-place\n\t  // NOTE: `hint` is a lowest bit before trailing zeroes\n\t  // NOTE: if `extended` is present - it will be filled with destroyed bits\n\t  BN.prototype.iushrn = function iushrn (bits, hint, extended) {\n\t    assert(typeof bits === 'number' && bits >= 0);\n\t    var h;\n\t    if (hint) {\n\t      h = (hint - (hint % 26)) / 26;\n\t    } else {\n\t      h = 0;\n\t    }\n\n\t    var r = bits % 26;\n\t    var s = Math.min((bits - r) / 26, this.length);\n\t    var mask = 0x3ffffff ^ ((0x3ffffff >>> r) << r);\n\t    var maskedWords = extended;\n\n\t    h -= s;\n\t    h = Math.max(0, h);\n\n\t    // Extended mode, copy masked part\n\t    if (maskedWords) {\n\t      for (var i = 0; i < s; i++) {\n\t        maskedWords.words[i] = this.words[i];\n\t      }\n\t      maskedWords.length = s;\n\t    }\n\n\t    if (s === 0) {\n\t      // No-op, we should not move anything at all\n\t    } else if (this.length > s) {\n\t      this.length -= s;\n\t      for (i = 0; i < this.length; i++) {\n\t        this.words[i] = this.words[i + s];\n\t      }\n\t    } else {\n\t      this.words[0] = 0;\n\t      this.length = 1;\n\t    }\n\n\t    var carry = 0;\n\t    for (i = this.length - 1; i >= 0 && (carry !== 0 || i >= h); i--) {\n\t      var word = this.words[i] | 0;\n\t      this.words[i] = (carry << (26 - r)) | (word >>> r);\n\t      carry = word & mask;\n\t    }\n\n\t    // Push carried bits as a mask\n\t    if (maskedWords && carry !== 0) {\n\t      maskedWords.words[maskedWords.length++] = carry;\n\t    }\n\n\t    if (this.length === 0) {\n\t      this.words[0] = 0;\n\t      this.length = 1;\n\t    }\n\n\t    return this.strip();\n\t  };\n\n\t  BN.prototype.ishrn = function ishrn (bits, hint, extended) {\n\t    // TODO(indutny): implement me\n\t    assert(this.negative === 0);\n\t    return this.iushrn(bits, hint, extended);\n\t  };\n\n\t  // Shift-left\n\t  BN.prototype.shln = function shln (bits) {\n\t    return this.clone().ishln(bits);\n\t  };\n\n\t  BN.prototype.ushln = function ushln (bits) {\n\t    return this.clone().iushln(bits);\n\t  };\n\n\t  // Shift-right\n\t  BN.prototype.shrn = function shrn (bits) {\n\t    return this.clone().ishrn(bits);\n\t  };\n\n\t  BN.prototype.ushrn = function ushrn (bits) {\n\t    return this.clone().iushrn(bits);\n\t  };\n\n\t  // Test if n bit is set\n\t  BN.prototype.testn = function testn (bit) {\n\t    assert(typeof bit === 'number' && bit >= 0);\n\t    var r = bit % 26;\n\t    var s = (bit - r) / 26;\n\t    var q = 1 << r;\n\n\t    // Fast case: bit is much higher than all existing words\n\t    if (this.length <= s) return false;\n\n\t    // Check bit and return\n\t    var w = this.words[s];\n\n\t    return !!(w & q);\n\t  };\n\n\t  // Return only lowers bits of number (in-place)\n\t  BN.prototype.imaskn = function imaskn (bits) {\n\t    assert(typeof bits === 'number' && bits >= 0);\n\t    var r = bits % 26;\n\t    var s = (bits - r) / 26;\n\n\t    assert(this.negative === 0, 'imaskn works only with positive numbers');\n\n\t    if (this.length <= s) {\n\t      return this;\n\t    }\n\n\t    if (r !== 0) {\n\t      s++;\n\t    }\n\t    this.length = Math.min(s, this.length);\n\n\t    if (r !== 0) {\n\t      var mask = 0x3ffffff ^ ((0x3ffffff >>> r) << r);\n\t      this.words[this.length - 1] &= mask;\n\t    }\n\n\t    return this.strip();\n\t  };\n\n\t  // Return only lowers bits of number\n\t  BN.prototype.maskn = function maskn (bits) {\n\t    return this.clone().imaskn(bits);\n\t  };\n\n\t  // Add plain number `num` to `this`\n\t  BN.prototype.iaddn = function iaddn (num) {\n\t    assert(typeof num === 'number');\n\t    assert(num < 0x4000000);\n\t    if (num < 0) return this.isubn(-num);\n\n\t    // Possible sign change\n\t    if (this.negative !== 0) {\n\t      if (this.length === 1 && (this.words[0] | 0) < num) {\n\t        this.words[0] = num - (this.words[0] | 0);\n\t        this.negative = 0;\n\t        return this;\n\t      }\n\n\t      this.negative = 0;\n\t      this.isubn(num);\n\t      this.negative = 1;\n\t      return this;\n\t    }\n\n\t    // Add without checks\n\t    return this._iaddn(num);\n\t  };\n\n\t  BN.prototype._iaddn = function _iaddn (num) {\n\t    this.words[0] += num;\n\n\t    // Carry\n\t    for (var i = 0; i < this.length && this.words[i] >= 0x4000000; i++) {\n\t      this.words[i] -= 0x4000000;\n\t      if (i === this.length - 1) {\n\t        this.words[i + 1] = 1;\n\t      } else {\n\t        this.words[i + 1]++;\n\t      }\n\t    }\n\t    this.length = Math.max(this.length, i + 1);\n\n\t    return this;\n\t  };\n\n\t  // Subtract plain number `num` from `this`\n\t  BN.prototype.isubn = function isubn (num) {\n\t    assert(typeof num === 'number');\n\t    assert(num < 0x4000000);\n\t    if (num < 0) return this.iaddn(-num);\n\n\t    if (this.negative !== 0) {\n\t      this.negative = 0;\n\t      this.iaddn(num);\n\t      this.negative = 1;\n\t      return this;\n\t    }\n\n\t    this.words[0] -= num;\n\n\t    if (this.length === 1 && this.words[0] < 0) {\n\t      this.words[0] = -this.words[0];\n\t      this.negative = 1;\n\t    } else {\n\t      // Carry\n\t      for (var i = 0; i < this.length && this.words[i] < 0; i++) {\n\t        this.words[i] += 0x4000000;\n\t        this.words[i + 1] -= 1;\n\t      }\n\t    }\n\n\t    return this.strip();\n\t  };\n\n\t  BN.prototype.addn = function addn (num) {\n\t    return this.clone().iaddn(num);\n\t  };\n\n\t  BN.prototype.subn = function subn (num) {\n\t    return this.clone().isubn(num);\n\t  };\n\n\t  BN.prototype.iabs = function iabs () {\n\t    this.negative = 0;\n\n\t    return this;\n\t  };\n\n\t  BN.prototype.abs = function abs () {\n\t    return this.clone().iabs();\n\t  };\n\n\t  BN.prototype._ishlnsubmul = function _ishlnsubmul (num, mul, shift) {\n\t    var len = num.length + shift;\n\t    var i;\n\n\t    this._expand(len);\n\n\t    var w;\n\t    var carry = 0;\n\t    for (i = 0; i < num.length; i++) {\n\t      w = (this.words[i + shift] | 0) + carry;\n\t      var right = (num.words[i] | 0) * mul;\n\t      w -= right & 0x3ffffff;\n\t      carry = (w >> 26) - ((right / 0x4000000) | 0);\n\t      this.words[i + shift] = w & 0x3ffffff;\n\t    }\n\t    for (; i < this.length - shift; i++) {\n\t      w = (this.words[i + shift] | 0) + carry;\n\t      carry = w >> 26;\n\t      this.words[i + shift] = w & 0x3ffffff;\n\t    }\n\n\t    if (carry === 0) return this.strip();\n\n\t    // Subtraction overflow\n\t    assert(carry === -1);\n\t    carry = 0;\n\t    for (i = 0; i < this.length; i++) {\n\t      w = -(this.words[i] | 0) + carry;\n\t      carry = w >> 26;\n\t      this.words[i] = w & 0x3ffffff;\n\t    }\n\t    this.negative = 1;\n\n\t    return this.strip();\n\t  };\n\n\t  BN.prototype._wordDiv = function _wordDiv (num, mode) {\n\t    var shift = this.length - num.length;\n\n\t    var a = this.clone();\n\t    var b = num;\n\n\t    // Normalize\n\t    var bhi = b.words[b.length - 1] | 0;\n\t    var bhiBits = this._countBits(bhi);\n\t    shift = 26 - bhiBits;\n\t    if (shift !== 0) {\n\t      b = b.ushln(shift);\n\t      a.iushln(shift);\n\t      bhi = b.words[b.length - 1] | 0;\n\t    }\n\n\t    // Initialize quotient\n\t    var m = a.length - b.length;\n\t    var q;\n\n\t    if (mode !== 'mod') {\n\t      q = new BN(null);\n\t      q.length = m + 1;\n\t      q.words = new Array(q.length);\n\t      for (var i = 0; i < q.length; i++) {\n\t        q.words[i] = 0;\n\t      }\n\t    }\n\n\t    var diff = a.clone()._ishlnsubmul(b, 1, m);\n\t    if (diff.negative === 0) {\n\t      a = diff;\n\t      if (q) {\n\t        q.words[m] = 1;\n\t      }\n\t    }\n\n\t    for (var j = m - 1; j >= 0; j--) {\n\t      var qj = (a.words[b.length + j] | 0) * 0x4000000 +\n\t        (a.words[b.length + j - 1] | 0);\n\n\t      // NOTE: (qj / bhi) is (0x3ffffff * 0x4000000 + 0x3ffffff) / 0x2000000 max\n\t      // (0x7ffffff)\n\t      qj = Math.min((qj / bhi) | 0, 0x3ffffff);\n\n\t      a._ishlnsubmul(b, qj, j);\n\t      while (a.negative !== 0) {\n\t        qj--;\n\t        a.negative = 0;\n\t        a._ishlnsubmul(b, 1, j);\n\t        if (!a.isZero()) {\n\t          a.negative ^= 1;\n\t        }\n\t      }\n\t      if (q) {\n\t        q.words[j] = qj;\n\t      }\n\t    }\n\t    if (q) {\n\t      q.strip();\n\t    }\n\t    a.strip();\n\n\t    // Denormalize\n\t    if (mode !== 'div' && shift !== 0) {\n\t      a.iushrn(shift);\n\t    }\n\n\t    return {\n\t      div: q || null,\n\t      mod: a\n\t    };\n\t  };\n\n\t  // NOTE: 1) `mode` can be set to `mod` to request mod only,\n\t  //       to `div` to request div only, or be absent to\n\t  //       request both div & mod\n\t  //       2) `positive` is true if unsigned mod is requested\n\t  BN.prototype.divmod = function divmod (num, mode, positive) {\n\t    assert(!num.isZero());\n\n\t    if (this.isZero()) {\n\t      return {\n\t        div: new BN(0),\n\t        mod: new BN(0)\n\t      };\n\t    }\n\n\t    var div, mod, res;\n\t    if (this.negative !== 0 && num.negative === 0) {\n\t      res = this.neg().divmod(num, mode);\n\n\t      if (mode !== 'mod') {\n\t        div = res.div.neg();\n\t      }\n\n\t      if (mode !== 'div') {\n\t        mod = res.mod.neg();\n\t        if (positive && mod.negative !== 0) {\n\t          mod.iadd(num);\n\t        }\n\t      }\n\n\t      return {\n\t        div: div,\n\t        mod: mod\n\t      };\n\t    }\n\n\t    if (this.negative === 0 && num.negative !== 0) {\n\t      res = this.divmod(num.neg(), mode);\n\n\t      if (mode !== 'mod') {\n\t        div = res.div.neg();\n\t      }\n\n\t      return {\n\t        div: div,\n\t        mod: res.mod\n\t      };\n\t    }\n\n\t    if ((this.negative & num.negative) !== 0) {\n\t      res = this.neg().divmod(num.neg(), mode);\n\n\t      if (mode !== 'div') {\n\t        mod = res.mod.neg();\n\t        if (positive && mod.negative !== 0) {\n\t          mod.isub(num);\n\t        }\n\t      }\n\n\t      return {\n\t        div: res.div,\n\t        mod: mod\n\t      };\n\t    }\n\n\t    // Both numbers are positive at this point\n\n\t    // Strip both numbers to approximate shift value\n\t    if (num.length > this.length || this.cmp(num) < 0) {\n\t      return {\n\t        div: new BN(0),\n\t        mod: this\n\t      };\n\t    }\n\n\t    // Very short reduction\n\t    if (num.length === 1) {\n\t      if (mode === 'div') {\n\t        return {\n\t          div: this.divn(num.words[0]),\n\t          mod: null\n\t        };\n\t      }\n\n\t      if (mode === 'mod') {\n\t        return {\n\t          div: null,\n\t          mod: new BN(this.modn(num.words[0]))\n\t        };\n\t      }\n\n\t      return {\n\t        div: this.divn(num.words[0]),\n\t        mod: new BN(this.modn(num.words[0]))\n\t      };\n\t    }\n\n\t    return this._wordDiv(num, mode);\n\t  };\n\n\t  // Find `this` / `num`\n\t  BN.prototype.div = function div (num) {\n\t    return this.divmod(num, 'div', false).div;\n\t  };\n\n\t  // Find `this` % `num`\n\t  BN.prototype.mod = function mod (num) {\n\t    return this.divmod(num, 'mod', false).mod;\n\t  };\n\n\t  BN.prototype.umod = function umod (num) {\n\t    return this.divmod(num, 'mod', true).mod;\n\t  };\n\n\t  // Find Round(`this` / `num`)\n\t  BN.prototype.divRound = function divRound (num) {\n\t    var dm = this.divmod(num);\n\n\t    // Fast case - exact division\n\t    if (dm.mod.isZero()) return dm.div;\n\n\t    var mod = dm.div.negative !== 0 ? dm.mod.isub(num) : dm.mod;\n\n\t    var half = num.ushrn(1);\n\t    var r2 = num.andln(1);\n\t    var cmp = mod.cmp(half);\n\n\t    // Round down\n\t    if (cmp < 0 || r2 === 1 && cmp === 0) return dm.div;\n\n\t    // Round up\n\t    return dm.div.negative !== 0 ? dm.div.isubn(1) : dm.div.iaddn(1);\n\t  };\n\n\t  BN.prototype.modn = function modn (num) {\n\t    assert(num <= 0x3ffffff);\n\t    var p = (1 << 26) % num;\n\n\t    var acc = 0;\n\t    for (var i = this.length - 1; i >= 0; i--) {\n\t      acc = (p * acc + (this.words[i] | 0)) % num;\n\t    }\n\n\t    return acc;\n\t  };\n\n\t  // In-place division by number\n\t  BN.prototype.idivn = function idivn (num) {\n\t    assert(num <= 0x3ffffff);\n\n\t    var carry = 0;\n\t    for (var i = this.length - 1; i >= 0; i--) {\n\t      var w = (this.words[i] | 0) + carry * 0x4000000;\n\t      this.words[i] = (w / num) | 0;\n\t      carry = w % num;\n\t    }\n\n\t    return this.strip();\n\t  };\n\n\t  BN.prototype.divn = function divn (num) {\n\t    return this.clone().idivn(num);\n\t  };\n\n\t  BN.prototype.egcd = function egcd (p) {\n\t    assert(p.negative === 0);\n\t    assert(!p.isZero());\n\n\t    var x = this;\n\t    var y = p.clone();\n\n\t    if (x.negative !== 0) {\n\t      x = x.umod(p);\n\t    } else {\n\t      x = x.clone();\n\t    }\n\n\t    // A * x + B * y = x\n\t    var A = new BN(1);\n\t    var B = new BN(0);\n\n\t    // C * x + D * y = y\n\t    var C = new BN(0);\n\t    var D = new BN(1);\n\n\t    var g = 0;\n\n\t    while (x.isEven() && y.isEven()) {\n\t      x.iushrn(1);\n\t      y.iushrn(1);\n\t      ++g;\n\t    }\n\n\t    var yp = y.clone();\n\t    var xp = x.clone();\n\n\t    while (!x.isZero()) {\n\t      for (var i = 0, im = 1; (x.words[0] & im) === 0 && i < 26; ++i, im <<= 1);\n\t      if (i > 0) {\n\t        x.iushrn(i);\n\t        while (i-- > 0) {\n\t          if (A.isOdd() || B.isOdd()) {\n\t            A.iadd(yp);\n\t            B.isub(xp);\n\t          }\n\n\t          A.iushrn(1);\n\t          B.iushrn(1);\n\t        }\n\t      }\n\n\t      for (var j = 0, jm = 1; (y.words[0] & jm) === 0 && j < 26; ++j, jm <<= 1);\n\t      if (j > 0) {\n\t        y.iushrn(j);\n\t        while (j-- > 0) {\n\t          if (C.isOdd() || D.isOdd()) {\n\t            C.iadd(yp);\n\t            D.isub(xp);\n\t          }\n\n\t          C.iushrn(1);\n\t          D.iushrn(1);\n\t        }\n\t      }\n\n\t      if (x.cmp(y) >= 0) {\n\t        x.isub(y);\n\t        A.isub(C);\n\t        B.isub(D);\n\t      } else {\n\t        y.isub(x);\n\t        C.isub(A);\n\t        D.isub(B);\n\t      }\n\t    }\n\n\t    return {\n\t      a: C,\n\t      b: D,\n\t      gcd: y.iushln(g)\n\t    };\n\t  };\n\n\t  // This is reduced incarnation of the binary EEA\n\t  // above, designated to invert members of the\n\t  // _prime_ fields F(p) at a maximal speed\n\t  BN.prototype._invmp = function _invmp (p) {\n\t    assert(p.negative === 0);\n\t    assert(!p.isZero());\n\n\t    var a = this;\n\t    var b = p.clone();\n\n\t    if (a.negative !== 0) {\n\t      a = a.umod(p);\n\t    } else {\n\t      a = a.clone();\n\t    }\n\n\t    var x1 = new BN(1);\n\t    var x2 = new BN(0);\n\n\t    var delta = b.clone();\n\n\t    while (a.cmpn(1) > 0 && b.cmpn(1) > 0) {\n\t      for (var i = 0, im = 1; (a.words[0] & im) === 0 && i < 26; ++i, im <<= 1);\n\t      if (i > 0) {\n\t        a.iushrn(i);\n\t        while (i-- > 0) {\n\t          if (x1.isOdd()) {\n\t            x1.iadd(delta);\n\t          }\n\n\t          x1.iushrn(1);\n\t        }\n\t      }\n\n\t      for (var j = 0, jm = 1; (b.words[0] & jm) === 0 && j < 26; ++j, jm <<= 1);\n\t      if (j > 0) {\n\t        b.iushrn(j);\n\t        while (j-- > 0) {\n\t          if (x2.isOdd()) {\n\t            x2.iadd(delta);\n\t          }\n\n\t          x2.iushrn(1);\n\t        }\n\t      }\n\n\t      if (a.cmp(b) >= 0) {\n\t        a.isub(b);\n\t        x1.isub(x2);\n\t      } else {\n\t        b.isub(a);\n\t        x2.isub(x1);\n\t      }\n\t    }\n\n\t    var res;\n\t    if (a.cmpn(1) === 0) {\n\t      res = x1;\n\t    } else {\n\t      res = x2;\n\t    }\n\n\t    if (res.cmpn(0) < 0) {\n\t      res.iadd(p);\n\t    }\n\n\t    return res;\n\t  };\n\n\t  BN.prototype.gcd = function gcd (num) {\n\t    if (this.isZero()) return num.abs();\n\t    if (num.isZero()) return this.abs();\n\n\t    var a = this.clone();\n\t    var b = num.clone();\n\t    a.negative = 0;\n\t    b.negative = 0;\n\n\t    // Remove common factor of two\n\t    for (var shift = 0; a.isEven() && b.isEven(); shift++) {\n\t      a.iushrn(1);\n\t      b.iushrn(1);\n\t    }\n\n\t    do {\n\t      while (a.isEven()) {\n\t        a.iushrn(1);\n\t      }\n\t      while (b.isEven()) {\n\t        b.iushrn(1);\n\t      }\n\n\t      var r = a.cmp(b);\n\t      if (r < 0) {\n\t        // Swap `a` and `b` to make `a` always bigger than `b`\n\t        var t = a;\n\t        a = b;\n\t        b = t;\n\t      } else if (r === 0 || b.cmpn(1) === 0) {\n\t        break;\n\t      }\n\n\t      a.isub(b);\n\t    } while (true);\n\n\t    return b.iushln(shift);\n\t  };\n\n\t  // Invert number in the field F(num)\n\t  BN.prototype.invm = function invm (num) {\n\t    return this.egcd(num).a.umod(num);\n\t  };\n\n\t  BN.prototype.isEven = function isEven () {\n\t    return (this.words[0] & 1) === 0;\n\t  };\n\n\t  BN.prototype.isOdd = function isOdd () {\n\t    return (this.words[0] & 1) === 1;\n\t  };\n\n\t  // And first word and num\n\t  BN.prototype.andln = function andln (num) {\n\t    return this.words[0] & num;\n\t  };\n\n\t  // Increment at the bit position in-line\n\t  BN.prototype.bincn = function bincn (bit) {\n\t    assert(typeof bit === 'number');\n\t    var r = bit % 26;\n\t    var s = (bit - r) / 26;\n\t    var q = 1 << r;\n\n\t    // Fast case: bit is much higher than all existing words\n\t    if (this.length <= s) {\n\t      this._expand(s + 1);\n\t      this.words[s] |= q;\n\t      return this;\n\t    }\n\n\t    // Add bit and propagate, if needed\n\t    var carry = q;\n\t    for (var i = s; carry !== 0 && i < this.length; i++) {\n\t      var w = this.words[i] | 0;\n\t      w += carry;\n\t      carry = w >>> 26;\n\t      w &= 0x3ffffff;\n\t      this.words[i] = w;\n\t    }\n\t    if (carry !== 0) {\n\t      this.words[i] = carry;\n\t      this.length++;\n\t    }\n\t    return this;\n\t  };\n\n\t  BN.prototype.isZero = function isZero () {\n\t    return this.length === 1 && this.words[0] === 0;\n\t  };\n\n\t  BN.prototype.cmpn = function cmpn (num) {\n\t    var negative = num < 0;\n\n\t    if (this.negative !== 0 && !negative) return -1;\n\t    if (this.negative === 0 && negative) return 1;\n\n\t    this.strip();\n\n\t    var res;\n\t    if (this.length > 1) {\n\t      res = 1;\n\t    } else {\n\t      if (negative) {\n\t        num = -num;\n\t      }\n\n\t      assert(num <= 0x3ffffff, 'Number is too big');\n\n\t      var w = this.words[0] | 0;\n\t      res = w === num ? 0 : w < num ? -1 : 1;\n\t    }\n\t    if (this.negative !== 0) return -res | 0;\n\t    return res;\n\t  };\n\n\t  // Compare two numbers and return:\n\t  // 1 - if `this` > `num`\n\t  // 0 - if `this` == `num`\n\t  // -1 - if `this` < `num`\n\t  BN.prototype.cmp = function cmp (num) {\n\t    if (this.negative !== 0 && num.negative === 0) return -1;\n\t    if (this.negative === 0 && num.negative !== 0) return 1;\n\n\t    var res = this.ucmp(num);\n\t    if (this.negative !== 0) return -res | 0;\n\t    return res;\n\t  };\n\n\t  // Unsigned comparison\n\t  BN.prototype.ucmp = function ucmp (num) {\n\t    // At this point both numbers have the same sign\n\t    if (this.length > num.length) return 1;\n\t    if (this.length < num.length) return -1;\n\n\t    var res = 0;\n\t    for (var i = this.length - 1; i >= 0; i--) {\n\t      var a = this.words[i] | 0;\n\t      var b = num.words[i] | 0;\n\n\t      if (a === b) continue;\n\t      if (a < b) {\n\t        res = -1;\n\t      } else if (a > b) {\n\t        res = 1;\n\t      }\n\t      break;\n\t    }\n\t    return res;\n\t  };\n\n\t  BN.prototype.gtn = function gtn (num) {\n\t    return this.cmpn(num) === 1;\n\t  };\n\n\t  BN.prototype.gt = function gt (num) {\n\t    return this.cmp(num) === 1;\n\t  };\n\n\t  BN.prototype.gten = function gten (num) {\n\t    return this.cmpn(num) >= 0;\n\t  };\n\n\t  BN.prototype.gte = function gte (num) {\n\t    return this.cmp(num) >= 0;\n\t  };\n\n\t  BN.prototype.ltn = function ltn (num) {\n\t    return this.cmpn(num) === -1;\n\t  };\n\n\t  BN.prototype.lt = function lt (num) {\n\t    return this.cmp(num) === -1;\n\t  };\n\n\t  BN.prototype.lten = function lten (num) {\n\t    return this.cmpn(num) <= 0;\n\t  };\n\n\t  BN.prototype.lte = function lte (num) {\n\t    return this.cmp(num) <= 0;\n\t  };\n\n\t  BN.prototype.eqn = function eqn (num) {\n\t    return this.cmpn(num) === 0;\n\t  };\n\n\t  BN.prototype.eq = function eq (num) {\n\t    return this.cmp(num) === 0;\n\t  };\n\n\t  //\n\t  // A reduce context, could be using montgomery or something better, depending\n\t  // on the `m` itself.\n\t  //\n\t  BN.red = function red (num) {\n\t    return new Red(num);\n\t  };\n\n\t  BN.prototype.toRed = function toRed (ctx) {\n\t    assert(!this.red, 'Already a number in reduction context');\n\t    assert(this.negative === 0, 'red works only with positives');\n\t    return ctx.convertTo(this)._forceRed(ctx);\n\t  };\n\n\t  BN.prototype.fromRed = function fromRed () {\n\t    assert(this.red, 'fromRed works only with numbers in reduction context');\n\t    return this.red.convertFrom(this);\n\t  };\n\n\t  BN.prototype._forceRed = function _forceRed (ctx) {\n\t    this.red = ctx;\n\t    return this;\n\t  };\n\n\t  BN.prototype.forceRed = function forceRed (ctx) {\n\t    assert(!this.red, 'Already a number in reduction context');\n\t    return this._forceRed(ctx);\n\t  };\n\n\t  BN.prototype.redAdd = function redAdd (num) {\n\t    assert(this.red, 'redAdd works only with red numbers');\n\t    return this.red.add(this, num);\n\t  };\n\n\t  BN.prototype.redIAdd = function redIAdd (num) {\n\t    assert(this.red, 'redIAdd works only with red numbers');\n\t    return this.red.iadd(this, num);\n\t  };\n\n\t  BN.prototype.redSub = function redSub (num) {\n\t    assert(this.red, 'redSub works only with red numbers');\n\t    return this.red.sub(this, num);\n\t  };\n\n\t  BN.prototype.redISub = function redISub (num) {\n\t    assert(this.red, 'redISub works only with red numbers');\n\t    return this.red.isub(this, num);\n\t  };\n\n\t  BN.prototype.redShl = function redShl (num) {\n\t    assert(this.red, 'redShl works only with red numbers');\n\t    return this.red.shl(this, num);\n\t  };\n\n\t  BN.prototype.redMul = function redMul (num) {\n\t    assert(this.red, 'redMul works only with red numbers');\n\t    this.red._verify2(this, num);\n\t    return this.red.mul(this, num);\n\t  };\n\n\t  BN.prototype.redIMul = function redIMul (num) {\n\t    assert(this.red, 'redMul works only with red numbers');\n\t    this.red._verify2(this, num);\n\t    return this.red.imul(this, num);\n\t  };\n\n\t  BN.prototype.redSqr = function redSqr () {\n\t    assert(this.red, 'redSqr works only with red numbers');\n\t    this.red._verify1(this);\n\t    return this.red.sqr(this);\n\t  };\n\n\t  BN.prototype.redISqr = function redISqr () {\n\t    assert(this.red, 'redISqr works only with red numbers');\n\t    this.red._verify1(this);\n\t    return this.red.isqr(this);\n\t  };\n\n\t  // Square root over p\n\t  BN.prototype.redSqrt = function redSqrt () {\n\t    assert(this.red, 'redSqrt works only with red numbers');\n\t    this.red._verify1(this);\n\t    return this.red.sqrt(this);\n\t  };\n\n\t  BN.prototype.redInvm = function redInvm () {\n\t    assert(this.red, 'redInvm works only with red numbers');\n\t    this.red._verify1(this);\n\t    return this.red.invm(this);\n\t  };\n\n\t  // Return negative clone of `this` % `red modulo`\n\t  BN.prototype.redNeg = function redNeg () {\n\t    assert(this.red, 'redNeg works only with red numbers');\n\t    this.red._verify1(this);\n\t    return this.red.neg(this);\n\t  };\n\n\t  BN.prototype.redPow = function redPow (num) {\n\t    assert(this.red && !num.red, 'redPow(normalNum)');\n\t    this.red._verify1(this);\n\t    return this.red.pow(this, num);\n\t  };\n\n\t  // Prime numbers with efficient reduction\n\t  var primes = {\n\t    k256: null,\n\t    p224: null,\n\t    p192: null,\n\t    p25519: null\n\t  };\n\n\t  // Pseudo-Mersenne prime\n\t  function MPrime (name, p) {\n\t    // P = 2 ^ N - K\n\t    this.name = name;\n\t    this.p = new BN(p, 16);\n\t    this.n = this.p.bitLength();\n\t    this.k = new BN(1).iushln(this.n).isub(this.p);\n\n\t    this.tmp = this._tmp();\n\t  }\n\n\t  MPrime.prototype._tmp = function _tmp () {\n\t    var tmp = new BN(null);\n\t    tmp.words = new Array(Math.ceil(this.n / 13));\n\t    return tmp;\n\t  };\n\n\t  MPrime.prototype.ireduce = function ireduce (num) {\n\t    // Assumes that `num` is less than `P^2`\n\t    // num = HI * (2 ^ N - K) + HI * K + LO = HI * K + LO (mod P)\n\t    var r = num;\n\t    var rlen;\n\n\t    do {\n\t      this.split(r, this.tmp);\n\t      r = this.imulK(r);\n\t      r = r.iadd(this.tmp);\n\t      rlen = r.bitLength();\n\t    } while (rlen > this.n);\n\n\t    var cmp = rlen < this.n ? -1 : r.ucmp(this.p);\n\t    if (cmp === 0) {\n\t      r.words[0] = 0;\n\t      r.length = 1;\n\t    } else if (cmp > 0) {\n\t      r.isub(this.p);\n\t    } else {\n\t      if (r.strip !== undefined) {\n\t        // r is BN v4 instance\n\t        r.strip();\n\t      } else {\n\t        // r is BN v5 instance\n\t        r._strip();\n\t      }\n\t    }\n\n\t    return r;\n\t  };\n\n\t  MPrime.prototype.split = function split (input, out) {\n\t    input.iushrn(this.n, 0, out);\n\t  };\n\n\t  MPrime.prototype.imulK = function imulK (num) {\n\t    return num.imul(this.k);\n\t  };\n\n\t  function K256 () {\n\t    MPrime.call(\n\t      this,\n\t      'k256',\n\t      'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f');\n\t  }\n\t  inherits(K256, MPrime);\n\n\t  K256.prototype.split = function split (input, output) {\n\t    // 256 = 9 * 26 + 22\n\t    var mask = 0x3fffff;\n\n\t    var outLen = Math.min(input.length, 9);\n\t    for (var i = 0; i < outLen; i++) {\n\t      output.words[i] = input.words[i];\n\t    }\n\t    output.length = outLen;\n\n\t    if (input.length <= 9) {\n\t      input.words[0] = 0;\n\t      input.length = 1;\n\t      return;\n\t    }\n\n\t    // Shift by 9 limbs\n\t    var prev = input.words[9];\n\t    output.words[output.length++] = prev & mask;\n\n\t    for (i = 10; i < input.length; i++) {\n\t      var next = input.words[i] | 0;\n\t      input.words[i - 10] = ((next & mask) << 4) | (prev >>> 22);\n\t      prev = next;\n\t    }\n\t    prev >>>= 22;\n\t    input.words[i - 10] = prev;\n\t    if (prev === 0 && input.length > 10) {\n\t      input.length -= 10;\n\t    } else {\n\t      input.length -= 9;\n\t    }\n\t  };\n\n\t  K256.prototype.imulK = function imulK (num) {\n\t    // K = 0x1000003d1 = [ 0x40, 0x3d1 ]\n\t    num.words[num.length] = 0;\n\t    num.words[num.length + 1] = 0;\n\t    num.length += 2;\n\n\t    // bounded at: 0x40 * 0x3ffffff + 0x3d0 = 0x100000390\n\t    var lo = 0;\n\t    for (var i = 0; i < num.length; i++) {\n\t      var w = num.words[i] | 0;\n\t      lo += w * 0x3d1;\n\t      num.words[i] = lo & 0x3ffffff;\n\t      lo = w * 0x40 + ((lo / 0x4000000) | 0);\n\t    }\n\n\t    // Fast length reduction\n\t    if (num.words[num.length - 1] === 0) {\n\t      num.length--;\n\t      if (num.words[num.length - 1] === 0) {\n\t        num.length--;\n\t      }\n\t    }\n\t    return num;\n\t  };\n\n\t  function P224 () {\n\t    MPrime.call(\n\t      this,\n\t      'p224',\n\t      'ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001');\n\t  }\n\t  inherits(P224, MPrime);\n\n\t  function P192 () {\n\t    MPrime.call(\n\t      this,\n\t      'p192',\n\t      'ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff');\n\t  }\n\t  inherits(P192, MPrime);\n\n\t  function P25519 () {\n\t    // 2 ^ 255 - 19\n\t    MPrime.call(\n\t      this,\n\t      '25519',\n\t      '7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed');\n\t  }\n\t  inherits(P25519, MPrime);\n\n\t  P25519.prototype.imulK = function imulK (num) {\n\t    // K = 0x13\n\t    var carry = 0;\n\t    for (var i = 0; i < num.length; i++) {\n\t      var hi = (num.words[i] | 0) * 0x13 + carry;\n\t      var lo = hi & 0x3ffffff;\n\t      hi >>>= 26;\n\n\t      num.words[i] = lo;\n\t      carry = hi;\n\t    }\n\t    if (carry !== 0) {\n\t      num.words[num.length++] = carry;\n\t    }\n\t    return num;\n\t  };\n\n\t  // Exported mostly for testing purposes, use plain name instead\n\t  BN._prime = function prime (name) {\n\t    // Cached version of prime\n\t    if (primes[name]) return primes[name];\n\n\t    var prime;\n\t    if (name === 'k256') {\n\t      prime = new K256();\n\t    } else if (name === 'p224') {\n\t      prime = new P224();\n\t    } else if (name === 'p192') {\n\t      prime = new P192();\n\t    } else if (name === 'p25519') {\n\t      prime = new P25519();\n\t    } else {\n\t      throw new Error('Unknown prime ' + name);\n\t    }\n\t    primes[name] = prime;\n\n\t    return prime;\n\t  };\n\n\t  //\n\t  // Base reduction engine\n\t  //\n\t  function Red (m) {\n\t    if (typeof m === 'string') {\n\t      var prime = BN._prime(m);\n\t      this.m = prime.p;\n\t      this.prime = prime;\n\t    } else {\n\t      assert(m.gtn(1), 'modulus must be greater than 1');\n\t      this.m = m;\n\t      this.prime = null;\n\t    }\n\t  }\n\n\t  Red.prototype._verify1 = function _verify1 (a) {\n\t    assert(a.negative === 0, 'red works only with positives');\n\t    assert(a.red, 'red works only with red numbers');\n\t  };\n\n\t  Red.prototype._verify2 = function _verify2 (a, b) {\n\t    assert((a.negative | b.negative) === 0, 'red works only with positives');\n\t    assert(a.red && a.red === b.red,\n\t      'red works only with red numbers');\n\t  };\n\n\t  Red.prototype.imod = function imod (a) {\n\t    if (this.prime) return this.prime.ireduce(a)._forceRed(this);\n\t    return a.umod(this.m)._forceRed(this);\n\t  };\n\n\t  Red.prototype.neg = function neg (a) {\n\t    if (a.isZero()) {\n\t      return a.clone();\n\t    }\n\n\t    return this.m.sub(a)._forceRed(this);\n\t  };\n\n\t  Red.prototype.add = function add (a, b) {\n\t    this._verify2(a, b);\n\n\t    var res = a.add(b);\n\t    if (res.cmp(this.m) >= 0) {\n\t      res.isub(this.m);\n\t    }\n\t    return res._forceRed(this);\n\t  };\n\n\t  Red.prototype.iadd = function iadd (a, b) {\n\t    this._verify2(a, b);\n\n\t    var res = a.iadd(b);\n\t    if (res.cmp(this.m) >= 0) {\n\t      res.isub(this.m);\n\t    }\n\t    return res;\n\t  };\n\n\t  Red.prototype.sub = function sub (a, b) {\n\t    this._verify2(a, b);\n\n\t    var res = a.sub(b);\n\t    if (res.cmpn(0) < 0) {\n\t      res.iadd(this.m);\n\t    }\n\t    return res._forceRed(this);\n\t  };\n\n\t  Red.prototype.isub = function isub (a, b) {\n\t    this._verify2(a, b);\n\n\t    var res = a.isub(b);\n\t    if (res.cmpn(0) < 0) {\n\t      res.iadd(this.m);\n\t    }\n\t    return res;\n\t  };\n\n\t  Red.prototype.shl = function shl (a, num) {\n\t    this._verify1(a);\n\t    return this.imod(a.ushln(num));\n\t  };\n\n\t  Red.prototype.imul = function imul (a, b) {\n\t    this._verify2(a, b);\n\t    return this.imod(a.imul(b));\n\t  };\n\n\t  Red.prototype.mul = function mul (a, b) {\n\t    this._verify2(a, b);\n\t    return this.imod(a.mul(b));\n\t  };\n\n\t  Red.prototype.isqr = function isqr (a) {\n\t    return this.imul(a, a.clone());\n\t  };\n\n\t  Red.prototype.sqr = function sqr (a) {\n\t    return this.mul(a, a);\n\t  };\n\n\t  Red.prototype.sqrt = function sqrt (a) {\n\t    if (a.isZero()) return a.clone();\n\n\t    var mod3 = this.m.andln(3);\n\t    assert(mod3 % 2 === 1);\n\n\t    // Fast case\n\t    if (mod3 === 3) {\n\t      var pow = this.m.add(new BN(1)).iushrn(2);\n\t      return this.pow(a, pow);\n\t    }\n\n\t    // Tonelli-Shanks algorithm (Totally unoptimized and slow)\n\t    //\n\t    // Find Q and S, that Q * 2 ^ S = (P - 1)\n\t    var q = this.m.subn(1);\n\t    var s = 0;\n\t    while (!q.isZero() && q.andln(1) === 0) {\n\t      s++;\n\t      q.iushrn(1);\n\t    }\n\t    assert(!q.isZero());\n\n\t    var one = new BN(1).toRed(this);\n\t    var nOne = one.redNeg();\n\n\t    // Find quadratic non-residue\n\t    // NOTE: Max is such because of generalized Riemann hypothesis.\n\t    var lpow = this.m.subn(1).iushrn(1);\n\t    var z = this.m.bitLength();\n\t    z = new BN(2 * z * z).toRed(this);\n\n\t    while (this.pow(z, lpow).cmp(nOne) !== 0) {\n\t      z.redIAdd(nOne);\n\t    }\n\n\t    var c = this.pow(z, q);\n\t    var r = this.pow(a, q.addn(1).iushrn(1));\n\t    var t = this.pow(a, q);\n\t    var m = s;\n\t    while (t.cmp(one) !== 0) {\n\t      var tmp = t;\n\t      for (var i = 0; tmp.cmp(one) !== 0; i++) {\n\t        tmp = tmp.redSqr();\n\t      }\n\t      assert(i < m);\n\t      var b = this.pow(c, new BN(1).iushln(m - i - 1));\n\n\t      r = r.redMul(b);\n\t      c = b.redSqr();\n\t      t = t.redMul(c);\n\t      m = i;\n\t    }\n\n\t    return r;\n\t  };\n\n\t  Red.prototype.invm = function invm (a) {\n\t    var inv = a._invmp(this.m);\n\t    if (inv.negative !== 0) {\n\t      inv.negative = 0;\n\t      return this.imod(inv).redNeg();\n\t    } else {\n\t      return this.imod(inv);\n\t    }\n\t  };\n\n\t  Red.prototype.pow = function pow (a, num) {\n\t    if (num.isZero()) return new BN(1).toRed(this);\n\t    if (num.cmpn(1) === 0) return a.clone();\n\n\t    var windowSize = 4;\n\t    var wnd = new Array(1 << windowSize);\n\t    wnd[0] = new BN(1).toRed(this);\n\t    wnd[1] = a;\n\t    for (var i = 2; i < wnd.length; i++) {\n\t      wnd[i] = this.mul(wnd[i - 1], a);\n\t    }\n\n\t    var res = wnd[0];\n\t    var current = 0;\n\t    var currentLen = 0;\n\t    var start = num.bitLength() % 26;\n\t    if (start === 0) {\n\t      start = 26;\n\t    }\n\n\t    for (i = num.length - 1; i >= 0; i--) {\n\t      var word = num.words[i];\n\t      for (var j = start - 1; j >= 0; j--) {\n\t        var bit = (word >> j) & 1;\n\t        if (res !== wnd[0]) {\n\t          res = this.sqr(res);\n\t        }\n\n\t        if (bit === 0 && current === 0) {\n\t          currentLen = 0;\n\t          continue;\n\t        }\n\n\t        current <<= 1;\n\t        current |= bit;\n\t        currentLen++;\n\t        if (currentLen !== windowSize && (i !== 0 || j !== 0)) continue;\n\n\t        res = this.mul(res, wnd[current]);\n\t        currentLen = 0;\n\t        current = 0;\n\t      }\n\t      start = 26;\n\t    }\n\n\t    return res;\n\t  };\n\n\t  Red.prototype.convertTo = function convertTo (num) {\n\t    var r = num.umod(this.m);\n\n\t    return r === num ? r.clone() : r;\n\t  };\n\n\t  Red.prototype.convertFrom = function convertFrom (num) {\n\t    var res = num.clone();\n\t    res.red = null;\n\t    return res;\n\t  };\n\n\t  //\n\t  // Montgomery method engine\n\t  //\n\n\t  BN.mont = function mont (num) {\n\t    return new Mont(num);\n\t  };\n\n\t  function Mont (m) {\n\t    Red.call(this, m);\n\n\t    this.shift = this.m.bitLength();\n\t    if (this.shift % 26 !== 0) {\n\t      this.shift += 26 - (this.shift % 26);\n\t    }\n\n\t    this.r = new BN(1).iushln(this.shift);\n\t    this.r2 = this.imod(this.r.sqr());\n\t    this.rinv = this.r._invmp(this.m);\n\n\t    this.minv = this.rinv.mul(this.r).isubn(1).div(this.m);\n\t    this.minv = this.minv.umod(this.r);\n\t    this.minv = this.r.sub(this.minv);\n\t  }\n\t  inherits(Mont, Red);\n\n\t  Mont.prototype.convertTo = function convertTo (num) {\n\t    return this.imod(num.ushln(this.shift));\n\t  };\n\n\t  Mont.prototype.convertFrom = function convertFrom (num) {\n\t    var r = this.imod(num.mul(this.rinv));\n\t    r.red = null;\n\t    return r;\n\t  };\n\n\t  Mont.prototype.imul = function imul (a, b) {\n\t    if (a.isZero() || b.isZero()) {\n\t      a.words[0] = 0;\n\t      a.length = 1;\n\t      return a;\n\t    }\n\n\t    var t = a.imul(b);\n\t    var c = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);\n\t    var u = t.isub(c).iushrn(this.shift);\n\t    var res = u;\n\n\t    if (u.cmp(this.m) >= 0) {\n\t      res = u.isub(this.m);\n\t    } else if (u.cmpn(0) < 0) {\n\t      res = u.iadd(this.m);\n\t    }\n\n\t    return res._forceRed(this);\n\t  };\n\n\t  Mont.prototype.mul = function mul (a, b) {\n\t    if (a.isZero() || b.isZero()) return new BN(0)._forceRed(this);\n\n\t    var t = a.mul(b);\n\t    var c = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);\n\t    var u = t.isub(c).iushrn(this.shift);\n\t    var res = u;\n\t    if (u.cmp(this.m) >= 0) {\n\t      res = u.isub(this.m);\n\t    } else if (u.cmpn(0) < 0) {\n\t      res = u.iadd(this.m);\n\t    }\n\n\t    return res._forceRed(this);\n\t  };\n\n\t  Mont.prototype.invm = function invm (a) {\n\t    // (AR)^-1 * R^2 = (A^-1 * R^-1) * R^2 = A^-1 * R\n\t    var res = this.imod(a._invmp(this.m).mul(this.r2));\n\t    return res._forceRed(this);\n\t  };\n\t})( false || module, commonjsGlobal);\n\t});\n\n\tvar _version = createCommonjsModule(function (module, exports) {\n\t\"use strict\";\n\tObject.defineProperty(exports, \"__esModule\", { value: true });\n\texports.version = void 0;\n\texports.version = \"logger/5.5.0\";\n\n\t});\n\n\tvar _version$1 = /*@__PURE__*/getDefaultExportFromCjs(_version);\n\n\tvar lib = createCommonjsModule(function (module, exports) {\n\t\"use strict\";\n\tObject.defineProperty(exports, \"__esModule\", { value: true });\n\texports.Logger = exports.ErrorCode = exports.LogLevel = void 0;\n\tvar _permanentCensorErrors = false;\n\tvar _censorErrors = false;\n\tvar LogLevels = { debug: 1, \"default\": 2, info: 2, warning: 3, error: 4, off: 5 };\n\tvar _logLevel = LogLevels[\"default\"];\n\n\tvar _globalLogger = null;\n\tfunction _checkNormalize() {\n\t    try {\n\t        var missing_1 = [];\n\t        // Make sure all forms of normalization are supported\n\t        [\"NFD\", \"NFC\", \"NFKD\", \"NFKC\"].forEach(function (form) {\n\t            try {\n\t                if (\"test\".normalize(form) !== \"test\") {\n\t                    throw new Error(\"bad normalize\");\n\t                }\n\t                ;\n\t            }\n\t            catch (error) {\n\t                missing_1.push(form);\n\t            }\n\t        });\n\t        if (missing_1.length) {\n\t            throw new Error(\"missing \" + missing_1.join(\", \"));\n\t        }\n\t        if (String.fromCharCode(0xe9).normalize(\"NFD\") !== String.fromCharCode(0x65, 0x0301)) {\n\t            throw new Error(\"broken implementation\");\n\t        }\n\t    }\n\t    catch (error) {\n\t        return error.message;\n\t    }\n\t    return null;\n\t}\n\tvar _normalizeError = _checkNormalize();\n\tvar LogLevel;\n\t(function (LogLevel) {\n\t    LogLevel[\"DEBUG\"] = \"DEBUG\";\n\t    LogLevel[\"INFO\"] = \"INFO\";\n\t    LogLevel[\"WARNING\"] = \"WARNING\";\n\t    LogLevel[\"ERROR\"] = \"ERROR\";\n\t    LogLevel[\"OFF\"] = \"OFF\";\n\t})(LogLevel = exports.LogLevel || (exports.LogLevel = {}));\n\tvar ErrorCode;\n\t(function (ErrorCode) {\n\t    ///////////////////\n\t    // Generic Errors\n\t    // Unknown Error\n\t    ErrorCode[\"UNKNOWN_ERROR\"] = \"UNKNOWN_ERROR\";\n\t    // Not Implemented\n\t    ErrorCode[\"NOT_IMPLEMENTED\"] = \"NOT_IMPLEMENTED\";\n\t    // Unsupported Operation\n\t    //   - operation\n\t    ErrorCode[\"UNSUPPORTED_OPERATION\"] = \"UNSUPPORTED_OPERATION\";\n\t    // Network Error (i.e. Ethereum Network, such as an invalid chain ID)\n\t    //   - event (\"noNetwork\" is not re-thrown in provider.ready; otherwise thrown)\n\t    ErrorCode[\"NETWORK_ERROR\"] = \"NETWORK_ERROR\";\n\t    // Some sort of bad response from the server\n\t    ErrorCode[\"SERVER_ERROR\"] = \"SERVER_ERROR\";\n\t    // Timeout\n\t    ErrorCode[\"TIMEOUT\"] = \"TIMEOUT\";\n\t    ///////////////////\n\t    // Operational  Errors\n\t    // Buffer Overrun\n\t    ErrorCode[\"BUFFER_OVERRUN\"] = \"BUFFER_OVERRUN\";\n\t    // Numeric Fault\n\t    //   - operation: the operation being executed\n\t    //   - fault: the reason this faulted\n\t    ErrorCode[\"NUMERIC_FAULT\"] = \"NUMERIC_FAULT\";\n\t    ///////////////////\n\t    // Argument Errors\n\t    // Missing new operator to an object\n\t    //  - name: The name of the class\n\t    ErrorCode[\"MISSING_NEW\"] = \"MISSING_NEW\";\n\t    // Invalid argument (e.g. value is incompatible with type) to a function:\n\t    //   - argument: The argument name that was invalid\n\t    //   - value: The value of the argument\n\t    ErrorCode[\"INVALID_ARGUMENT\"] = \"INVALID_ARGUMENT\";\n\t    // Missing argument to a function:\n\t    //   - count: The number of arguments received\n\t    //   - expectedCount: The number of arguments expected\n\t    ErrorCode[\"MISSING_ARGUMENT\"] = \"MISSING_ARGUMENT\";\n\t    // Too many arguments\n\t    //   - count: The number of arguments received\n\t    //   - expectedCount: The number of arguments expected\n\t    ErrorCode[\"UNEXPECTED_ARGUMENT\"] = \"UNEXPECTED_ARGUMENT\";\n\t    ///////////////////\n\t    // Blockchain Errors\n\t    // Call exception\n\t    //  - transaction: the transaction\n\t    //  - address?: the contract address\n\t    //  - args?: The arguments passed into the function\n\t    //  - method?: The Solidity method signature\n\t    //  - errorSignature?: The EIP848 error signature\n\t    //  - errorArgs?: The EIP848 error parameters\n\t    //  - reason: The reason (only for EIP848 \"Error(string)\")\n\t    ErrorCode[\"CALL_EXCEPTION\"] = \"CALL_EXCEPTION\";\n\t    // Insufficient funds (< value + gasLimit * gasPrice)\n\t    //   - transaction: the transaction attempted\n\t    ErrorCode[\"INSUFFICIENT_FUNDS\"] = \"INSUFFICIENT_FUNDS\";\n\t    // Nonce has already been used\n\t    //   - transaction: the transaction attempted\n\t    ErrorCode[\"NONCE_EXPIRED\"] = \"NONCE_EXPIRED\";\n\t    // The replacement fee for the transaction is too low\n\t    //   - transaction: the transaction attempted\n\t    ErrorCode[\"REPLACEMENT_UNDERPRICED\"] = \"REPLACEMENT_UNDERPRICED\";\n\t    // The gas limit could not be estimated\n\t    //   - transaction: the transaction passed to estimateGas\n\t    ErrorCode[\"UNPREDICTABLE_GAS_LIMIT\"] = \"UNPREDICTABLE_GAS_LIMIT\";\n\t    // The transaction was replaced by one with a higher gas price\n\t    //   - reason: \"cancelled\", \"replaced\" or \"repriced\"\n\t    //   - cancelled: true if reason == \"cancelled\" or reason == \"replaced\")\n\t    //   - hash: original transaction hash\n\t    //   - replacement: the full TransactionsResponse for the replacement\n\t    //   - receipt: the receipt of the replacement\n\t    ErrorCode[\"TRANSACTION_REPLACED\"] = \"TRANSACTION_REPLACED\";\n\t})(ErrorCode = exports.ErrorCode || (exports.ErrorCode = {}));\n\t;\n\tvar HEX = \"0123456789abcdef\";\n\tvar Logger = /** @class */ (function () {\n\t    function Logger(version) {\n\t        Object.defineProperty(this, \"version\", {\n\t            enumerable: true,\n\t            value: version,\n\t            writable: false\n\t        });\n\t    }\n\t    Logger.prototype._log = function (logLevel, args) {\n\t        var level = logLevel.toLowerCase();\n\t        if (LogLevels[level] == null) {\n\t            this.throwArgumentError(\"invalid log level name\", \"logLevel\", logLevel);\n\t        }\n\t        if (_logLevel > LogLevels[level]) {\n\t            return;\n\t        }\n\t        console.log.apply(console, args);\n\t    };\n\t    Logger.prototype.debug = function () {\n\t        var args = [];\n\t        for (var _i = 0; _i < arguments.length; _i++) {\n\t            args[_i] = arguments[_i];\n\t        }\n\t        this._log(Logger.levels.DEBUG, args);\n\t    };\n\t    Logger.prototype.info = function () {\n\t        var args = [];\n\t        for (var _i = 0; _i < arguments.length; _i++) {\n\t            args[_i] = arguments[_i];\n\t        }\n\t        this._log(Logger.levels.INFO, args);\n\t    };\n\t    Logger.prototype.warn = function () {\n\t        var args = [];\n\t        for (var _i = 0; _i < arguments.length; _i++) {\n\t            args[_i] = arguments[_i];\n\t        }\n\t        this._log(Logger.levels.WARNING, args);\n\t    };\n\t    Logger.prototype.makeError = function (message, code, params) {\n\t        // Errors are being censored\n\t        if (_censorErrors) {\n\t            return this.makeError(\"censored error\", code, {});\n\t        }\n\t        if (!code) {\n\t            code = Logger.errors.UNKNOWN_ERROR;\n\t        }\n\t        if (!params) {\n\t            params = {};\n\t        }\n\t        var messageDetails = [];\n\t        Object.keys(params).forEach(function (key) {\n\t            var value = params[key];\n\t            try {\n\t                if (value instanceof Uint8Array) {\n\t                    var hex = \"\";\n\t                    for (var i = 0; i < value.length; i++) {\n\t                        hex += HEX[value[i] >> 4];\n\t                        hex += HEX[value[i] & 0x0f];\n\t                    }\n\t                    messageDetails.push(key + \"=Uint8Array(0x\" + hex + \")\");\n\t                }\n\t                else {\n\t                    messageDetails.push(key + \"=\" + JSON.stringify(value));\n\t                }\n\t            }\n\t            catch (error) {\n\t                messageDetails.push(key + \"=\" + JSON.stringify(params[key].toString()));\n\t            }\n\t        });\n\t        messageDetails.push(\"code=\" + code);\n\t        messageDetails.push(\"version=\" + this.version);\n\t        var reason = message;\n\t        if (messageDetails.length) {\n\t            message += \" (\" + messageDetails.join(\", \") + \")\";\n\t        }\n\t        // @TODO: Any??\n\t        var error = new Error(message);\n\t        error.reason = reason;\n\t        error.code = code;\n\t        Object.keys(params).forEach(function (key) {\n\t            error[key] = params[key];\n\t        });\n\t        return error;\n\t    };\n\t    Logger.prototype.throwError = function (message, code, params) {\n\t        throw this.makeError(message, code, params);\n\t    };\n\t    Logger.prototype.throwArgumentError = function (message, name, value) {\n\t        return this.throwError(message, Logger.errors.INVALID_ARGUMENT, {\n\t            argument: name,\n\t            value: value\n\t        });\n\t    };\n\t    Logger.prototype.assert = function (condition, message, code, params) {\n\t        if (!!condition) {\n\t            return;\n\t        }\n\t        this.throwError(message, code, params);\n\t    };\n\t    Logger.prototype.assertArgument = function (condition, message, name, value) {\n\t        if (!!condition) {\n\t            return;\n\t        }\n\t        this.throwArgumentError(message, name, value);\n\t    };\n\t    Logger.prototype.checkNormalize = function (message) {\n\t        if (message == null) {\n\t            message = \"platform missing String.prototype.normalize\";\n\t        }\n\t        if (_normalizeError) {\n\t            this.throwError(\"platform missing String.prototype.normalize\", Logger.errors.UNSUPPORTED_OPERATION, {\n\t                operation: \"String.prototype.normalize\", form: _normalizeError\n\t            });\n\t        }\n\t    };\n\t    Logger.prototype.checkSafeUint53 = function (value, message) {\n\t        if (typeof (value) !== \"number\") {\n\t            return;\n\t        }\n\t        if (message == null) {\n\t            message = \"value not safe\";\n\t        }\n\t        if (value < 0 || value >= 0x1fffffffffffff) {\n\t            this.throwError(message, Logger.errors.NUMERIC_FAULT, {\n\t                operation: \"checkSafeInteger\",\n\t                fault: \"out-of-safe-range\",\n\t                value: value\n\t            });\n\t        }\n\t        if (value % 1) {\n\t            this.throwError(message, Logger.errors.NUMERIC_FAULT, {\n\t                operation: \"checkSafeInteger\",\n\t                fault: \"non-integer\",\n\t                value: value\n\t            });\n\t        }\n\t    };\n\t    Logger.prototype.checkArgumentCount = function (count, expectedCount, message) {\n\t        if (message) {\n\t            message = \": \" + message;\n\t        }\n\t        else {\n\t            message = \"\";\n\t        }\n\t        if (count < expectedCount) {\n\t            this.throwError(\"missing argument\" + message, Logger.errors.MISSING_ARGUMENT, {\n\t                count: count,\n\t                expectedCount: expectedCount\n\t            });\n\t        }\n\t        if (count > expectedCount) {\n\t            this.throwError(\"too many arguments\" + message, Logger.errors.UNEXPECTED_ARGUMENT, {\n\t                count: count,\n\t                expectedCount: expectedCount\n\t            });\n\t        }\n\t    };\n\t    Logger.prototype.checkNew = function (target, kind) {\n\t        if (target === Object || target == null) {\n\t            this.throwError(\"missing new\", Logger.errors.MISSING_NEW, { name: kind.name });\n\t        }\n\t    };\n\t    Logger.prototype.checkAbstract = function (target, kind) {\n\t        if (target === kind) {\n\t            this.throwError(\"cannot instantiate abstract class \" + JSON.stringify(kind.name) + \" directly; use a sub-class\", Logger.errors.UNSUPPORTED_OPERATION, { name: target.name, operation: \"new\" });\n\t        }\n\t        else if (target === Object || target == null) {\n\t            this.throwError(\"missing new\", Logger.errors.MISSING_NEW, { name: kind.name });\n\t        }\n\t    };\n\t    Logger.globalLogger = function () {\n\t        if (!_globalLogger) {\n\t            _globalLogger = new Logger(_version.version);\n\t        }\n\t        return _globalLogger;\n\t    };\n\t    Logger.setCensorship = function (censorship, permanent) {\n\t        if (!censorship && permanent) {\n\t            this.globalLogger().throwError(\"cannot permanently disable censorship\", Logger.errors.UNSUPPORTED_OPERATION, {\n\t                operation: \"setCensorship\"\n\t            });\n\t        }\n\t        if (_permanentCensorErrors) {\n\t            if (!censorship) {\n\t                return;\n\t            }\n\t            this.globalLogger().throwError(\"error censorship permanent\", Logger.errors.UNSUPPORTED_OPERATION, {\n\t                operation: \"setCensorship\"\n\t            });\n\t        }\n\t        _censorErrors = !!censorship;\n\t        _permanentCensorErrors = !!permanent;\n\t    };\n\t    Logger.setLogLevel = function (logLevel) {\n\t        var level = LogLevels[logLevel.toLowerCase()];\n\t        if (level == null) {\n\t            Logger.globalLogger().warn(\"invalid log level - \" + logLevel);\n\t            return;\n\t        }\n\t        _logLevel = level;\n\t    };\n\t    Logger.from = function (version) {\n\t        return new Logger(version);\n\t    };\n\t    Logger.errors = ErrorCode;\n\t    Logger.levels = LogLevel;\n\t    return Logger;\n\t}());\n\texports.Logger = Logger;\n\n\t});\n\n\tvar index = /*@__PURE__*/getDefaultExportFromCjs(lib);\n\n\tvar _version$2 = createCommonjsModule(function (module, exports) {\n\t\"use strict\";\n\tObject.defineProperty(exports, \"__esModule\", { value: true });\n\texports.version = void 0;\n\texports.version = \"bytes/5.5.0\";\n\n\t});\n\n\tvar _version$3 = /*@__PURE__*/getDefaultExportFromCjs(_version$2);\n\n\tvar lib$1 = createCommonjsModule(function (module, exports) {\n\t\"use strict\";\n\tObject.defineProperty(exports, \"__esModule\", { value: true });\n\texports.joinSignature = exports.splitSignature = exports.hexZeroPad = exports.hexStripZeros = exports.hexValue = exports.hexConcat = exports.hexDataSlice = exports.hexDataLength = exports.hexlify = exports.isHexString = exports.zeroPad = exports.stripZeros = exports.concat = exports.arrayify = exports.isBytes = exports.isBytesLike = void 0;\n\n\n\tvar logger = new lib.Logger(_version$2.version);\n\t///////////////////////////////\n\tfunction isHexable(value) {\n\t    return !!(value.toHexString);\n\t}\n\tfunction addSlice(array) {\n\t    if (array.slice) {\n\t        return array;\n\t    }\n\t    array.slice = function () {\n\t        var args = Array.prototype.slice.call(arguments);\n\t        return addSlice(new Uint8Array(Array.prototype.slice.apply(array, args)));\n\t    };\n\t    return array;\n\t}\n\tfunction isBytesLike(value) {\n\t    return ((isHexString(value) && !(value.length % 2)) || isBytes(value));\n\t}\n\texports.isBytesLike = isBytesLike;\n\tfunction isInteger(value) {\n\t    return (typeof (value) === \"number\" && value == value && (value % 1) === 0);\n\t}\n\tfunction isBytes(value) {\n\t    if (value == null) {\n\t        return false;\n\t    }\n\t    if (value.constructor === Uint8Array) {\n\t        return true;\n\t    }\n\t    if (typeof (value) === \"string\") {\n\t        return false;\n\t    }\n\t    if (!isInteger(value.length) || value.length < 0) {\n\t        return false;\n\t    }\n\t    for (var i = 0; i < value.length; i++) {\n\t        var v = value[i];\n\t        if (!isInteger(v) || v < 0 || v >= 256) {\n\t            return false;\n\t        }\n\t    }\n\t    return true;\n\t}\n\texports.isBytes = isBytes;\n\tfunction arrayify(value, options) {\n\t    if (!options) {\n\t        options = {};\n\t    }\n\t    if (typeof (value) === \"number\") {\n\t        logger.checkSafeUint53(value, \"invalid arrayify value\");\n\t        var result = [];\n\t        while (value) {\n\t            result.unshift(value & 0xff);\n\t            value = parseInt(String(value / 256));\n\t        }\n\t        if (result.length === 0) {\n\t            result.push(0);\n\t        }\n\t        return addSlice(new Uint8Array(result));\n\t    }\n\t    if (options.allowMissingPrefix && typeof (value) === \"string\" && value.substring(0, 2) !== \"0x\") {\n\t        value = \"0x\" + value;\n\t    }\n\t    if (isHexable(value)) {\n\t        value = value.toHexString();\n\t    }\n\t    if (isHexString(value)) {\n\t        var hex = value.substring(2);\n\t        if (hex.length % 2) {\n\t            if (options.hexPad === \"left\") {\n\t                hex = \"0x0\" + hex.substring(2);\n\t            }\n\t            else if (options.hexPad === \"right\") {\n\t                hex += \"0\";\n\t            }\n\t            else {\n\t                logger.throwArgumentError(\"hex data is odd-length\", \"value\", value);\n\t            }\n\t        }\n\t        var result = [];\n\t        for (var i = 0; i < hex.length; i += 2) {\n\t            result.push(parseInt(hex.substring(i, i + 2), 16));\n\t        }\n\t        return addSlice(new Uint8Array(result));\n\t    }\n\t    if (isBytes(value)) {\n\t        return addSlice(new Uint8Array(value));\n\t    }\n\t    return logger.throwArgumentError(\"invalid arrayify value\", \"value\", value);\n\t}\n\texports.arrayify = arrayify;\n\tfunction concat(items) {\n\t    var objects = items.map(function (item) { return arrayify(item); });\n\t    var length = objects.reduce(function (accum, item) { return (accum + item.length); }, 0);\n\t    var result = new Uint8Array(length);\n\t    objects.reduce(function (offset, object) {\n\t        result.set(object, offset);\n\t        return offset + object.length;\n\t    }, 0);\n\t    return addSlice(result);\n\t}\n\texports.concat = concat;\n\tfunction stripZeros(value) {\n\t    var result = arrayify(value);\n\t    if (result.length === 0) {\n\t        return result;\n\t    }\n\t    // Find the first non-zero entry\n\t    var start = 0;\n\t    while (start < result.length && result[start] === 0) {\n\t        start++;\n\t    }\n\t    // If we started with zeros, strip them\n\t    if (start) {\n\t        result = result.slice(start);\n\t    }\n\t    return result;\n\t}\n\texports.stripZeros = stripZeros;\n\tfunction zeroPad(value, length) {\n\t    value = arrayify(value);\n\t    if (value.length > length) {\n\t        logger.throwArgumentError(\"value out of range\", \"value\", arguments[0]);\n\t    }\n\t    var result = new Uint8Array(length);\n\t    result.set(value, length - value.length);\n\t    return addSlice(result);\n\t}\n\texports.zeroPad = zeroPad;\n\tfunction isHexString(value, length) {\n\t    if (typeof (value) !== \"string\" || !value.match(/^0x[0-9A-Fa-f]*$/)) {\n\t        return false;\n\t    }\n\t    if (length && value.length !== 2 + 2 * length) {\n\t        return false;\n\t    }\n\t    return true;\n\t}\n\texports.isHexString = isHexString;\n\tvar HexCharacters = \"0123456789abcdef\";\n\tfunction hexlify(value, options) {\n\t    if (!options) {\n\t        options = {};\n\t    }\n\t    if (typeof (value) === \"number\") {\n\t        logger.checkSafeUint53(value, \"invalid hexlify value\");\n\t        var hex = \"\";\n\t        while (value) {\n\t            hex = HexCharacters[value & 0xf] + hex;\n\t            value = Math.floor(value / 16);\n\t        }\n\t        if (hex.length) {\n\t            if (hex.length % 2) {\n\t                hex = \"0\" + hex;\n\t            }\n\t            return \"0x\" + hex;\n\t        }\n\t        return \"0x00\";\n\t    }\n\t    if (typeof (value) === \"bigint\") {\n\t        value = value.toString(16);\n\t        if (value.length % 2) {\n\t            return (\"0x0\" + value);\n\t        }\n\t        return \"0x\" + value;\n\t    }\n\t    if (options.allowMissingPrefix && typeof (value) === \"string\" && value.substring(0, 2) !== \"0x\") {\n\t        value = \"0x\" + value;\n\t    }\n\t    if (isHexable(value)) {\n\t        return value.toHexString();\n\t    }\n\t    if (isHexString(value)) {\n\t        if (value.length % 2) {\n\t            if (options.hexPad === \"left\") {\n\t                value = \"0x0\" + value.substring(2);\n\t            }\n\t            else if (options.hexPad === \"right\") {\n\t                value += \"0\";\n\t            }\n\t            else {\n\t                logger.throwArgumentError(\"hex data is odd-length\", \"value\", value);\n\t            }\n\t        }\n\t        return value.toLowerCase();\n\t    }\n\t    if (isBytes(value)) {\n\t        var result = \"0x\";\n\t        for (var i = 0; i < value.length; i++) {\n\t            var v = value[i];\n\t            result += HexCharacters[(v & 0xf0) >> 4] + HexCharacters[v & 0x0f];\n\t        }\n\t        return result;\n\t    }\n\t    return logger.throwArgumentError(\"invalid hexlify value\", \"value\", value);\n\t}\n\texports.hexlify = hexlify;\n\t/*\n\tfunction unoddify(value: BytesLike | Hexable | number): BytesLike | Hexable | number {\n\t    if (typeof(value) === \"string\" && value.length % 2 && value.substring(0, 2) === \"0x\") {\n\t        return \"0x0\" + value.substring(2);\n\t    }\n\t    return value;\n\t}\n\t*/\n\tfunction hexDataLength(data) {\n\t    if (typeof (data) !== \"string\") {\n\t        data = hexlify(data);\n\t    }\n\t    else if (!isHexString(data) || (data.length % 2)) {\n\t        return null;\n\t    }\n\t    return (data.length - 2) / 2;\n\t}\n\texports.hexDataLength = hexDataLength;\n\tfunction hexDataSlice(data, offset, endOffset) {\n\t    if (typeof (data) !== \"string\") {\n\t        data = hexlify(data);\n\t    }\n\t    else if (!isHexString(data) || (data.length % 2)) {\n\t        logger.throwArgumentError(\"invalid hexData\", \"value\", data);\n\t    }\n\t    offset = 2 + 2 * offset;\n\t    if (endOffset != null) {\n\t        return \"0x\" + data.substring(offset, 2 + 2 * endOffset);\n\t    }\n\t    return \"0x\" + data.substring(offset);\n\t}\n\texports.hexDataSlice = hexDataSlice;\n\tfunction hexConcat(items) {\n\t    var result = \"0x\";\n\t    items.forEach(function (item) {\n\t        result += hexlify(item).substring(2);\n\t    });\n\t    return result;\n\t}\n\texports.hexConcat = hexConcat;\n\tfunction hexValue(value) {\n\t    var trimmed = hexStripZeros(hexlify(value, { hexPad: \"left\" }));\n\t    if (trimmed === \"0x\") {\n\t        return \"0x0\";\n\t    }\n\t    return trimmed;\n\t}\n\texports.hexValue = hexValue;\n\tfunction hexStripZeros(value) {\n\t    if (typeof (value) !== \"string\") {\n\t        value = hexlify(value);\n\t    }\n\t    if (!isHexString(value)) {\n\t        logger.throwArgumentError(\"invalid hex string\", \"value\", value);\n\t    }\n\t    value = value.substring(2);\n\t    var offset = 0;\n\t    while (offset < value.length && value[offset] === \"0\") {\n\t        offset++;\n\t    }\n\t    return \"0x\" + value.substring(offset);\n\t}\n\texports.hexStripZeros = hexStripZeros;\n\tfunction hexZeroPad(value, length) {\n\t    if (typeof (value) !== \"string\") {\n\t        value = hexlify(value);\n\t    }\n\t    else if (!isHexString(value)) {\n\t        logger.throwArgumentError(\"invalid hex string\", \"value\", value);\n\t    }\n\t    if (value.length > 2 * length + 2) {\n\t        logger.throwArgumentError(\"value out of range\", \"value\", arguments[1]);\n\t    }\n\t    while (value.length < 2 * length + 2) {\n\t        value = \"0x0\" + value.substring(2);\n\t    }\n\t    return value;\n\t}\n\texports.hexZeroPad = hexZeroPad;\n\tfunction splitSignature(signature) {\n\t    var result = {\n\t        r: \"0x\",\n\t        s: \"0x\",\n\t        _vs: \"0x\",\n\t        recoveryParam: 0,\n\t        v: 0\n\t    };\n\t    if (isBytesLike(signature)) {\n\t        var bytes = arrayify(signature);\n\t        if (bytes.length !== 65) {\n\t            logger.throwArgumentError(\"invalid signature string; must be 65 bytes\", \"signature\", signature);\n\t        }\n\t        // Get the r, s and v\n\t        result.r = hexlify(bytes.slice(0, 32));\n\t        result.s = hexlify(bytes.slice(32, 64));\n\t        result.v = bytes[64];\n\t        // Allow a recid to be used as the v\n\t        if (result.v < 27) {\n\t            if (result.v === 0 || result.v === 1) {\n\t                result.v += 27;\n\t            }\n\t            else {\n\t                logger.throwArgumentError(\"signature invalid v byte\", \"signature\", signature);\n\t            }\n\t        }\n\t        // Compute recoveryParam from v\n\t        result.recoveryParam = 1 - (result.v % 2);\n\t        // Compute _vs from recoveryParam and s\n\t        if (result.recoveryParam) {\n\t            bytes[32] |= 0x80;\n\t        }\n\t        result._vs = hexlify(bytes.slice(32, 64));\n\t    }\n\t    else {\n\t        result.r = signature.r;\n\t        result.s = signature.s;\n\t        result.v = signature.v;\n\t        result.recoveryParam = signature.recoveryParam;\n\t        result._vs = signature._vs;\n\t        // If the _vs is available, use it to populate missing s, v and recoveryParam\n\t        // and verify non-missing s, v and recoveryParam\n\t        if (result._vs != null) {\n\t            var vs_1 = zeroPad(arrayify(result._vs), 32);\n\t            result._vs = hexlify(vs_1);\n\t            // Set or check the recid\n\t            var recoveryParam = ((vs_1[0] >= 128) ? 1 : 0);\n\t            if (result.recoveryParam == null) {\n\t                result.recoveryParam = recoveryParam;\n\t            }\n\t            else if (result.recoveryParam !== recoveryParam) {\n\t                logger.throwArgumentError(\"signature recoveryParam mismatch _vs\", \"signature\", signature);\n\t            }\n\t            // Set or check the s\n\t            vs_1[0] &= 0x7f;\n\t            var s = hexlify(vs_1);\n\t            if (result.s == null) {\n\t                result.s = s;\n\t            }\n\t            else if (result.s !== s) {\n\t                logger.throwArgumentError(\"signature v mismatch _vs\", \"signature\", signature);\n\t            }\n\t        }\n\t        // Use recid and v to populate each other\n\t        if (result.recoveryParam == null) {\n\t            if (result.v == null) {\n\t                logger.throwArgumentError(\"signature missing v and recoveryParam\", \"signature\", signature);\n\t            }\n\t            else if (result.v === 0 || result.v === 1) {\n\t                result.recoveryParam = result.v;\n\t            }\n\t            else {\n\t                result.recoveryParam = 1 - (result.v % 2);\n\t            }\n\t        }\n\t        else {\n\t            if (result.v == null) {\n\t                result.v = 27 + result.recoveryParam;\n\t            }\n\t            else {\n\t                var recId = (result.v === 0 || result.v === 1) ? result.v : (1 - (result.v % 2));\n\t                if (result.recoveryParam !== recId) {\n\t                    logger.throwArgumentError(\"signature recoveryParam mismatch v\", \"signature\", signature);\n\t                }\n\t            }\n\t        }\n\t        if (result.r == null || !isHexString(result.r)) {\n\t            logger.throwArgumentError(\"signature missing or invalid r\", \"signature\", signature);\n\t        }\n\t        else {\n\t            result.r = hexZeroPad(result.r, 32);\n\t        }\n\t        if (result.s == null || !isHexString(result.s)) {\n\t            logger.throwArgumentError(\"signature missing or invalid s\", \"signature\", signature);\n\t        }\n\t        else {\n\t            result.s = hexZeroPad(result.s, 32);\n\t        }\n\t        var vs = arrayify(result.s);\n\t        if (vs[0] >= 128) {\n\t            logger.throwArgumentError(\"signature s out of range\", \"signature\", signature);\n\t        }\n\t        if (result.recoveryParam) {\n\t            vs[0] |= 0x80;\n\t        }\n\t        var _vs = hexlify(vs);\n\t        if (result._vs) {\n\t            if (!isHexString(result._vs)) {\n\t                logger.throwArgumentError(\"signature invalid _vs\", \"signature\", signature);\n\t            }\n\t            result._vs = hexZeroPad(result._vs, 32);\n\t        }\n\t        // Set or check the _vs\n\t        if (result._vs == null) {\n\t            result._vs = _vs;\n\t        }\n\t        else if (result._vs !== _vs) {\n\t            logger.throwArgumentError(\"signature _vs mismatch v and s\", \"signature\", signature);\n\t        }\n\t    }\n\t    return result;\n\t}\n\texports.splitSignature = splitSignature;\n\tfunction joinSignature(signature) {\n\t    signature = splitSignature(signature);\n\t    return hexlify(concat([\n\t        signature.r,\n\t        signature.s,\n\t        (signature.recoveryParam ? \"0x1c\" : \"0x1b\")\n\t    ]));\n\t}\n\texports.joinSignature = joinSignature;\n\n\t});\n\n\tvar index$1 = /*@__PURE__*/getDefaultExportFromCjs(lib$1);\n\n\tvar _version$4 = createCommonjsModule(function (module, exports) {\n\t\"use strict\";\n\tObject.defineProperty(exports, \"__esModule\", { value: true });\n\texports.version = void 0;\n\texports.version = \"bignumber/5.5.0\";\n\n\t});\n\n\tvar _version$5 = /*@__PURE__*/getDefaultExportFromCjs(_version$4);\n\n\tvar bignumber = createCommonjsModule(function (module, exports) {\n\t\"use strict\";\n\tvar __importDefault = (commonjsGlobal && commonjsGlobal.__importDefault) || function (mod) {\n\t    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n\t};\n\tObject.defineProperty(exports, \"__esModule\", { value: true });\n\texports._base16To36 = exports._base36To16 = exports.BigNumber = exports.isBigNumberish = void 0;\n\t/**\n\t *  BigNumber\n\t *\n\t *  A wrapper around the BN.js object. We use the BN.js library\n\t *  because it is used by elliptic, so it is required regardless.\n\t *\n\t */\n\tvar bn_js_1 = __importDefault(bn);\n\tvar BN = bn_js_1.default.BN;\n\n\n\n\tvar logger = new lib.Logger(_version$4.version);\n\tvar _constructorGuard = {};\n\tvar MAX_SAFE = 0x1fffffffffffff;\n\tfunction isBigNumberish(value) {\n\t    return (value != null) && (BigNumber.isBigNumber(value) ||\n\t        (typeof (value) === \"number\" && (value % 1) === 0) ||\n\t        (typeof (value) === \"string\" && !!value.match(/^-?[0-9]+$/)) ||\n\t        (0, lib$1.isHexString)(value) ||\n\t        (typeof (value) === \"bigint\") ||\n\t        (0, lib$1.isBytes)(value));\n\t}\n\texports.isBigNumberish = isBigNumberish;\n\t// Only warn about passing 10 into radix once\n\tvar _warnedToStringRadix = false;\n\tvar BigNumber = /** @class */ (function () {\n\t    function BigNumber(constructorGuard, hex) {\n\t        var _newTarget = this.constructor;\n\t        logger.checkNew(_newTarget, BigNumber);\n\t        if (constructorGuard !== _constructorGuard) {\n\t            logger.throwError(\"cannot call constructor directly; use BigNumber.from\", lib.Logger.errors.UNSUPPORTED_OPERATION, {\n\t                operation: \"new (BigNumber)\"\n\t            });\n\t        }\n\t        this._hex = hex;\n\t        this._isBigNumber = true;\n\t        Object.freeze(this);\n\t    }\n\t    BigNumber.prototype.fromTwos = function (value) {\n\t        return toBigNumber(toBN(this).fromTwos(value));\n\t    };\n\t    BigNumber.prototype.toTwos = function (value) {\n\t        return toBigNumber(toBN(this).toTwos(value));\n\t    };\n\t    BigNumber.prototype.abs = function () {\n\t        if (this._hex[0] === \"-\") {\n\t            return BigNumber.from(this._hex.substring(1));\n\t        }\n\t        return this;\n\t    };\n\t    BigNumber.prototype.add = function (other) {\n\t        return toBigNumber(toBN(this).add(toBN(other)));\n\t    };\n\t    BigNumber.prototype.sub = function (other) {\n\t        return toBigNumber(toBN(this).sub(toBN(other)));\n\t    };\n\t    BigNumber.prototype.div = function (other) {\n\t        var o = BigNumber.from(other);\n\t        if (o.isZero()) {\n\t            throwFault(\"division by zero\", \"div\");\n\t        }\n\t        return toBigNumber(toBN(this).div(toBN(other)));\n\t    };\n\t    BigNumber.prototype.mul = function (other) {\n\t        return toBigNumber(toBN(this).mul(toBN(other)));\n\t    };\n\t    BigNumber.prototype.mod = function (other) {\n\t        var value = toBN(other);\n\t        if (value.isNeg()) {\n\t            throwFault(\"cannot modulo negative values\", \"mod\");\n\t        }\n\t        return toBigNumber(toBN(this).umod(value));\n\t    };\n\t    BigNumber.prototype.pow = function (other) {\n\t        var value = toBN(other);\n\t        if (value.isNeg()) {\n\t            throwFault(\"cannot raise to negative values\", \"pow\");\n\t        }\n\t        return toBigNumber(toBN(this).pow(value));\n\t    };\n\t    BigNumber.prototype.and = function (other) {\n\t        var value = toBN(other);\n\t        if (this.isNegative() || value.isNeg()) {\n\t            throwFault(\"cannot 'and' negative values\", \"and\");\n\t        }\n\t        return toBigNumber(toBN(this).and(value));\n\t    };\n\t    BigNumber.prototype.or = function (other) {\n\t        var value = toBN(other);\n\t        if (this.isNegative() || value.isNeg()) {\n\t            throwFault(\"cannot 'or' negative values\", \"or\");\n\t        }\n\t        return toBigNumber(toBN(this).or(value));\n\t    };\n\t    BigNumber.prototype.xor = function (other) {\n\t        var value = toBN(other);\n\t        if (this.isNegative() || value.isNeg()) {\n\t            throwFault(\"cannot 'xor' negative values\", \"xor\");\n\t        }\n\t        return toBigNumber(toBN(this).xor(value));\n\t    };\n\t    BigNumber.prototype.mask = function (value) {\n\t        if (this.isNegative() || value < 0) {\n\t            throwFault(\"cannot mask negative values\", \"mask\");\n\t        }\n\t        return toBigNumber(toBN(this).maskn(value));\n\t    };\n\t    BigNumber.prototype.shl = function (value) {\n\t        if (this.isNegative() || value < 0) {\n\t            throwFault(\"cannot shift negative values\", \"shl\");\n\t        }\n\t        return toBigNumber(toBN(this).shln(value));\n\t    };\n\t    BigNumber.prototype.shr = function (value) {\n\t        if (this.isNegative() || value < 0) {\n\t            throwFault(\"cannot shift negative values\", \"shr\");\n\t        }\n\t        return toBigNumber(toBN(this).shrn(value));\n\t    };\n\t    BigNumber.prototype.eq = function (other) {\n\t        return toBN(this).eq(toBN(other));\n\t    };\n\t    BigNumber.prototype.lt = function (other) {\n\t        return toBN(this).lt(toBN(other));\n\t    };\n\t    BigNumber.prototype.lte = function (other) {\n\t        return toBN(this).lte(toBN(other));\n\t    };\n\t    BigNumber.prototype.gt = function (other) {\n\t        return toBN(this).gt(toBN(other));\n\t    };\n\t    BigNumber.prototype.gte = function (other) {\n\t        return toBN(this).gte(toBN(other));\n\t    };\n\t    BigNumber.prototype.isNegative = function () {\n\t        return (this._hex[0] === \"-\");\n\t    };\n\t    BigNumber.prototype.isZero = function () {\n\t        return toBN(this).isZero();\n\t    };\n\t    BigNumber.prototype.toNumber = function () {\n\t        try {\n\t            return toBN(this).toNumber();\n\t        }\n\t        catch (error) {\n\t            throwFault(\"overflow\", \"toNumber\", this.toString());\n\t        }\n\t        return null;\n\t    };\n\t    BigNumber.prototype.toBigInt = function () {\n\t        try {\n\t            return BigInt(this.toString());\n\t        }\n\t        catch (e) { }\n\t        return logger.throwError(\"this platform does not support BigInt\", lib.Logger.errors.UNSUPPORTED_OPERATION, {\n\t            value: this.toString()\n\t        });\n\t    };\n\t    BigNumber.prototype.toString = function () {\n\t        // Lots of people expect this, which we do not support, so check (See: #889)\n\t        if (arguments.length > 0) {\n\t            if (arguments[0] === 10) {\n\t                if (!_warnedToStringRadix) {\n\t                    _warnedToStringRadix = true;\n\t                    logger.warn(\"BigNumber.toString does not accept any parameters; base-10 is assumed\");\n\t                }\n\t            }\n\t            else if (arguments[0] === 16) {\n\t                logger.throwError(\"BigNumber.toString does not accept any parameters; use bigNumber.toHexString()\", lib.Logger.errors.UNEXPECTED_ARGUMENT, {});\n\t            }\n\t            else {\n\t                logger.throwError(\"BigNumber.toString does not accept parameters\", lib.Logger.errors.UNEXPECTED_ARGUMENT, {});\n\t            }\n\t        }\n\t        return toBN(this).toString(10);\n\t    };\n\t    BigNumber.prototype.toHexString = function () {\n\t        return this._hex;\n\t    };\n\t    BigNumber.prototype.toJSON = function (key) {\n\t        return { type: \"BigNumber\", hex: this.toHexString() };\n\t    };\n\t    BigNumber.from = function (value) {\n\t        if (value instanceof BigNumber) {\n\t            return value;\n\t        }\n\t        if (typeof (value) === \"string\") {\n\t            if (value.match(/^-?0x[0-9a-f]+$/i)) {\n\t                return new BigNumber(_constructorGuard, toHex(value));\n\t            }\n\t            if (value.match(/^-?[0-9]+$/)) {\n\t                return new BigNumber(_constructorGuard, toHex(new BN(value)));\n\t            }\n\t            return logger.throwArgumentError(\"invalid BigNumber string\", \"value\", value);\n\t        }\n\t        if (typeof (value) === \"number\") {\n\t            if (value % 1) {\n\t                throwFault(\"underflow\", \"BigNumber.from\", value);\n\t            }\n\t            if (value >= MAX_SAFE || value <= -MAX_SAFE) {\n\t                throwFault(\"overflow\", \"BigNumber.from\", value);\n\t            }\n\t            return BigNumber.from(String(value));\n\t        }\n\t        var anyValue = value;\n\t        if (typeof (anyValue) === \"bigint\") {\n\t            return BigNumber.from(anyValue.toString());\n\t        }\n\t        if ((0, lib$1.isBytes)(anyValue)) {\n\t            return BigNumber.from((0, lib$1.hexlify)(anyValue));\n\t        }\n\t        if (anyValue) {\n\t            // Hexable interface (takes priority)\n\t            if (anyValue.toHexString) {\n\t                var hex = anyValue.toHexString();\n\t                if (typeof (hex) === \"string\") {\n\t                    return BigNumber.from(hex);\n\t                }\n\t            }\n\t            else {\n\t                // For now, handle legacy JSON-ified values (goes away in v6)\n\t                var hex = anyValue._hex;\n\t                // New-form JSON\n\t                if (hex == null && anyValue.type === \"BigNumber\") {\n\t                    hex = anyValue.hex;\n\t                }\n\t                if (typeof (hex) === \"string\") {\n\t                    if ((0, lib$1.isHexString)(hex) || (hex[0] === \"-\" && (0, lib$1.isHexString)(hex.substring(1)))) {\n\t                        return BigNumber.from(hex);\n\t                    }\n\t                }\n\t            }\n\t        }\n\t        return logger.throwArgumentError(\"invalid BigNumber value\", \"value\", value);\n\t    };\n\t    BigNumber.isBigNumber = function (value) {\n\t        return !!(value && value._isBigNumber);\n\t    };\n\t    return BigNumber;\n\t}());\n\texports.BigNumber = BigNumber;\n\t// Normalize the hex string\n\tfunction toHex(value) {\n\t    // For BN, call on the hex string\n\t    if (typeof (value) !== \"string\") {\n\t        return toHex(value.toString(16));\n\t    }\n\t    // If negative, prepend the negative sign to the normalized positive value\n\t    if (value[0] === \"-\") {\n\t        // Strip off the negative sign\n\t        value = value.substring(1);\n\t        // Cannot have multiple negative signs (e.g. \"--0x04\")\n\t        if (value[0] === \"-\") {\n\t            logger.throwArgumentError(\"invalid hex\", \"value\", value);\n\t        }\n\t        // Call toHex on the positive component\n\t        value = toHex(value);\n\t        // Do not allow \"-0x00\"\n\t        if (value === \"0x00\") {\n\t            return value;\n\t        }\n\t        // Negate the value\n\t        return \"-\" + value;\n\t    }\n\t    // Add a \"0x\" prefix if missing\n\t    if (value.substring(0, 2) !== \"0x\") {\n\t        value = \"0x\" + value;\n\t    }\n\t    // Normalize zero\n\t    if (value === \"0x\") {\n\t        return \"0x00\";\n\t    }\n\t    // Make the string even length\n\t    if (value.length % 2) {\n\t        value = \"0x0\" + value.substring(2);\n\t    }\n\t    // Trim to smallest even-length string\n\t    while (value.length > 4 && value.substring(0, 4) === \"0x00\") {\n\t        value = \"0x\" + value.substring(4);\n\t    }\n\t    return value;\n\t}\n\tfunction toBigNumber(value) {\n\t    return BigNumber.from(toHex(value));\n\t}\n\tfunction toBN(value) {\n\t    var hex = BigNumber.from(value).toHexString();\n\t    if (hex[0] === \"-\") {\n\t        return (new BN(\"-\" + hex.substring(3), 16));\n\t    }\n\t    return new BN(hex.substring(2), 16);\n\t}\n\tfunction throwFault(fault, operation, value) {\n\t    var params = { fault: fault, operation: operation };\n\t    if (value != null) {\n\t        params.value = value;\n\t    }\n\t    return logger.throwError(fault, lib.Logger.errors.NUMERIC_FAULT, params);\n\t}\n\t// value should have no prefix\n\tfunction _base36To16(value) {\n\t    return (new BN(value, 36)).toString(16);\n\t}\n\texports._base36To16 = _base36To16;\n\t// value should have no prefix\n\tfunction _base16To36(value) {\n\t    return (new BN(value, 16)).toString(36);\n\t}\n\texports._base16To36 = _base16To36;\n\n\t});\n\n\tvar bignumber$1 = /*@__PURE__*/getDefaultExportFromCjs(bignumber);\n\n\tvar fixednumber = createCommonjsModule(function (module, exports) {\n\t\"use strict\";\n\tObject.defineProperty(exports, \"__esModule\", { value: true });\n\texports.FixedNumber = exports.FixedFormat = exports.parseFixed = exports.formatFixed = void 0;\n\n\n\n\tvar logger = new lib.Logger(_version$4.version);\n\n\tvar _constructorGuard = {};\n\tvar Zero = bignumber.BigNumber.from(0);\n\tvar NegativeOne = bignumber.BigNumber.from(-1);\n\tfunction throwFault(message, fault, operation, value) {\n\t    var params = { fault: fault, operation: operation };\n\t    if (value !== undefined) {\n\t        params.value = value;\n\t    }\n\t    return logger.throwError(message, lib.Logger.errors.NUMERIC_FAULT, params);\n\t}\n\t// Constant to pull zeros from for multipliers\n\tvar zeros = \"0\";\n\twhile (zeros.length < 256) {\n\t    zeros += zeros;\n\t}\n\t// Returns a string \"1\" followed by decimal \"0\"s\n\tfunction getMultiplier(decimals) {\n\t    if (typeof (decimals) !== \"number\") {\n\t        try {\n\t            decimals = bignumber.BigNumber.from(decimals).toNumber();\n\t        }\n\t        catch (e) { }\n\t    }\n\t    if (typeof (decimals) === \"number\" && decimals >= 0 && decimals <= 256 && !(decimals % 1)) {\n\t        return (\"1\" + zeros.substring(0, decimals));\n\t    }\n\t    return logger.throwArgumentError(\"invalid decimal size\", \"decimals\", decimals);\n\t}\n\tfunction formatFixed(value, decimals) {\n\t    if (decimals == null) {\n\t        decimals = 0;\n\t    }\n\t    var multiplier = getMultiplier(decimals);\n\t    // Make sure wei is a big number (convert as necessary)\n\t    value = bignumber.BigNumber.from(value);\n\t    var negative = value.lt(Zero);\n\t    if (negative) {\n\t        value = value.mul(NegativeOne);\n\t    }\n\t    var fraction = value.mod(multiplier).toString();\n\t    while (fraction.length < multiplier.length - 1) {\n\t        fraction = \"0\" + fraction;\n\t    }\n\t    // Strip training 0\n\t    fraction = fraction.match(/^([0-9]*[1-9]|0)(0*)/)[1];\n\t    var whole = value.div(multiplier).toString();\n\t    if (multiplier.length === 1) {\n\t        value = whole;\n\t    }\n\t    else {\n\t        value = whole + \".\" + fraction;\n\t    }\n\t    if (negative) {\n\t        value = \"-\" + value;\n\t    }\n\t    return value;\n\t}\n\texports.formatFixed = formatFixed;\n\tfunction parseFixed(value, decimals) {\n\t    if (decimals == null) {\n\t        decimals = 0;\n\t    }\n\t    var multiplier = getMultiplier(decimals);\n\t    if (typeof (value) !== \"string\" || !value.match(/^-?[0-9.]+$/)) {\n\t        logger.throwArgumentError(\"invalid decimal value\", \"value\", value);\n\t    }\n\t    // Is it negative?\n\t    var negative = (value.substring(0, 1) === \"-\");\n\t    if (negative) {\n\t        value = value.substring(1);\n\t    }\n\t    if (value === \".\") {\n\t        logger.throwArgumentError(\"missing value\", \"value\", value);\n\t    }\n\t    // Split it into a whole and fractional part\n\t    var comps = value.split(\".\");\n\t    if (comps.length > 2) {\n\t        logger.throwArgumentError(\"too many decimal points\", \"value\", value);\n\t    }\n\t    var whole = comps[0], fraction = comps[1];\n\t    if (!whole) {\n\t        whole = \"0\";\n\t    }\n\t    if (!fraction) {\n\t        fraction = \"0\";\n\t    }\n\t    // Trim trailing zeros\n\t    while (fraction[fraction.length - 1] === \"0\") {\n\t        fraction = fraction.substring(0, fraction.length - 1);\n\t    }\n\t    // Check the fraction doesn't exceed our decimals size\n\t    if (fraction.length > multiplier.length - 1) {\n\t        throwFault(\"fractional component exceeds decimals\", \"underflow\", \"parseFixed\");\n\t    }\n\t    // If decimals is 0, we have an empty string for fraction\n\t    if (fraction === \"\") {\n\t        fraction = \"0\";\n\t    }\n\t    // Fully pad the string with zeros to get to wei\n\t    while (fraction.length < multiplier.length - 1) {\n\t        fraction += \"0\";\n\t    }\n\t    var wholeValue = bignumber.BigNumber.from(whole);\n\t    var fractionValue = bignumber.BigNumber.from(fraction);\n\t    var wei = (wholeValue.mul(multiplier)).add(fractionValue);\n\t    if (negative) {\n\t        wei = wei.mul(NegativeOne);\n\t    }\n\t    return wei;\n\t}\n\texports.parseFixed = parseFixed;\n\tvar FixedFormat = /** @class */ (function () {\n\t    function FixedFormat(constructorGuard, signed, width, decimals) {\n\t        if (constructorGuard !== _constructorGuard) {\n\t            logger.throwError(\"cannot use FixedFormat constructor; use FixedFormat.from\", lib.Logger.errors.UNSUPPORTED_OPERATION, {\n\t                operation: \"new FixedFormat\"\n\t            });\n\t        }\n\t        this.signed = signed;\n\t        this.width = width;\n\t        this.decimals = decimals;\n\t        this.name = (signed ? \"\" : \"u\") + \"fixed\" + String(width) + \"x\" + String(decimals);\n\t        this._multiplier = getMultiplier(decimals);\n\t        Object.freeze(this);\n\t    }\n\t    FixedFormat.from = function (value) {\n\t        if (value instanceof FixedFormat) {\n\t            return value;\n\t        }\n\t        if (typeof (value) === \"number\") {\n\t            value = \"fixed128x\" + value;\n\t        }\n\t        var signed = true;\n\t        var width = 128;\n\t        var decimals = 18;\n\t        if (typeof (value) === \"string\") {\n\t            if (value === \"fixed\") {\n\t                // defaults...\n\t            }\n\t            else if (value === \"ufixed\") {\n\t                signed = false;\n\t            }\n\t            else {\n\t                var match = value.match(/^(u?)fixed([0-9]+)x([0-9]+)$/);\n\t                if (!match) {\n\t                    logger.throwArgumentError(\"invalid fixed format\", \"format\", value);\n\t                }\n\t                signed = (match[1] !== \"u\");\n\t                width = parseInt(match[2]);\n\t                decimals = parseInt(match[3]);\n\t            }\n\t        }\n\t        else if (value) {\n\t            var check = function (key, type, defaultValue) {\n\t                if (value[key] == null) {\n\t                    return defaultValue;\n\t                }\n\t                if (typeof (value[key]) !== type) {\n\t                    logger.throwArgumentError(\"invalid fixed format (\" + key + \" not \" + type + \")\", \"format.\" + key, value[key]);\n\t                }\n\t                return value[key];\n\t            };\n\t            signed = check(\"signed\", \"boolean\", signed);\n\t            width = check(\"width\", \"number\", width);\n\t            decimals = check(\"decimals\", \"number\", decimals);\n\t        }\n\t        if (width % 8) {\n\t            logger.throwArgumentError(\"invalid fixed format width (not byte aligned)\", \"format.width\", width);\n\t        }\n\t        if (decimals > 80) {\n\t            logger.throwArgumentError(\"invalid fixed format (decimals too large)\", \"format.decimals\", decimals);\n\t        }\n\t        return new FixedFormat(_constructorGuard, signed, width, decimals);\n\t    };\n\t    return FixedFormat;\n\t}());\n\texports.FixedFormat = FixedFormat;\n\tvar FixedNumber = /** @class */ (function () {\n\t    function FixedNumber(constructorGuard, hex, value, format) {\n\t        var _newTarget = this.constructor;\n\t        logger.checkNew(_newTarget, FixedNumber);\n\t        if (constructorGuard !== _constructorGuard) {\n\t            logger.throwError(\"cannot use FixedNumber constructor; use FixedNumber.from\", lib.Logger.errors.UNSUPPORTED_OPERATION, {\n\t                operation: \"new FixedFormat\"\n\t            });\n\t        }\n\t        this.format = format;\n\t        this._hex = hex;\n\t        this._value = value;\n\t        this._isFixedNumber = true;\n\t        Object.freeze(this);\n\t    }\n\t    FixedNumber.prototype._checkFormat = function (other) {\n\t        if (this.format.name !== other.format.name) {\n\t            logger.throwArgumentError(\"incompatible format; use fixedNumber.toFormat\", \"other\", other);\n\t        }\n\t    };\n\t    FixedNumber.prototype.addUnsafe = function (other) {\n\t        this._checkFormat(other);\n\t        var a = parseFixed(this._value, this.format.decimals);\n\t        var b = parseFixed(other._value, other.format.decimals);\n\t        return FixedNumber.fromValue(a.add(b), this.format.decimals, this.format);\n\t    };\n\t    FixedNumber.prototype.subUnsafe = function (other) {\n\t        this._checkFormat(other);\n\t        var a = parseFixed(this._value, this.format.decimals);\n\t        var b = parseFixed(other._value, other.format.decimals);\n\t        return FixedNumber.fromValue(a.sub(b), this.format.decimals, this.format);\n\t    };\n\t    FixedNumber.prototype.mulUnsafe = function (other) {\n\t        this._checkFormat(other);\n\t        var a = parseFixed(this._value, this.format.decimals);\n\t        var b = parseFixed(other._value, other.format.decimals);\n\t        return FixedNumber.fromValue(a.mul(b).div(this.format._multiplier), this.format.decimals, this.format);\n\t    };\n\t    FixedNumber.prototype.divUnsafe = function (other) {\n\t        this._checkFormat(other);\n\t        var a = parseFixed(this._value, this.format.decimals);\n\t        var b = parseFixed(other._value, other.format.decimals);\n\t        return FixedNumber.fromValue(a.mul(this.format._multiplier).div(b), this.format.decimals, this.format);\n\t    };\n\t    FixedNumber.prototype.floor = function () {\n\t        var comps = this.toString().split(\".\");\n\t        if (comps.length === 1) {\n\t            comps.push(\"0\");\n\t        }\n\t        var result = FixedNumber.from(comps[0], this.format);\n\t        var hasFraction = !comps[1].match(/^(0*)$/);\n\t        if (this.isNegative() && hasFraction) {\n\t            result = result.subUnsafe(ONE.toFormat(result.format));\n\t        }\n\t        return result;\n\t    };\n\t    FixedNumber.prototype.ceiling = function () {\n\t        var comps = this.toString().split(\".\");\n\t        if (comps.length === 1) {\n\t            comps.push(\"0\");\n\t        }\n\t        var result = FixedNumber.from(comps[0], this.format);\n\t        var hasFraction = !comps[1].match(/^(0*)$/);\n\t        if (!this.isNegative() && hasFraction) {\n\t            result = result.addUnsafe(ONE.toFormat(result.format));\n\t        }\n\t        return result;\n\t    };\n\t    // @TODO: Support other rounding algorithms\n\t    FixedNumber.prototype.round = function (decimals) {\n\t        if (decimals == null) {\n\t            decimals = 0;\n\t        }\n\t        // If we are already in range, we're done\n\t        var comps = this.toString().split(\".\");\n\t        if (comps.length === 1) {\n\t            comps.push(\"0\");\n\t        }\n\t        if (decimals < 0 || decimals > 80 || (decimals % 1)) {\n\t            logger.throwArgumentError(\"invalid decimal count\", \"decimals\", decimals);\n\t        }\n\t        if (comps[1].length <= decimals) {\n\t            return this;\n\t        }\n\t        var factor = FixedNumber.from(\"1\" + zeros.substring(0, decimals), this.format);\n\t        var bump = BUMP.toFormat(this.format);\n\t        return this.mulUnsafe(factor).addUnsafe(bump).floor().divUnsafe(factor);\n\t    };\n\t    FixedNumber.prototype.isZero = function () {\n\t        return (this._value === \"0.0\" || this._value === \"0\");\n\t    };\n\t    FixedNumber.prototype.isNegative = function () {\n\t        return (this._value[0] === \"-\");\n\t    };\n\t    FixedNumber.prototype.toString = function () { return this._value; };\n\t    FixedNumber.prototype.toHexString = function (width) {\n\t        if (width == null) {\n\t            return this._hex;\n\t        }\n\t        if (width % 8) {\n\t            logger.throwArgumentError(\"invalid byte width\", \"width\", width);\n\t        }\n\t        var hex = bignumber.BigNumber.from(this._hex).fromTwos(this.format.width).toTwos(width).toHexString();\n\t        return (0, lib$1.hexZeroPad)(hex, width / 8);\n\t    };\n\t    FixedNumber.prototype.toUnsafeFloat = function () { return parseFloat(this.toString()); };\n\t    FixedNumber.prototype.toFormat = function (format) {\n\t        return FixedNumber.fromString(this._value, format);\n\t    };\n\t    FixedNumber.fromValue = function (value, decimals, format) {\n\t        // If decimals looks more like a format, and there is no format, shift the parameters\n\t        if (format == null && decimals != null && !(0, bignumber.isBigNumberish)(decimals)) {\n\t            format = decimals;\n\t            decimals = null;\n\t        }\n\t        if (decimals == null) {\n\t            decimals = 0;\n\t        }\n\t        if (format == null) {\n\t            format = \"fixed\";\n\t        }\n\t        return FixedNumber.fromString(formatFixed(value, decimals), FixedFormat.from(format));\n\t    };\n\t    FixedNumber.fromString = function (value, format) {\n\t        if (format == null) {\n\t            format = \"fixed\";\n\t        }\n\t        var fixedFormat = FixedFormat.from(format);\n\t        var numeric = parseFixed(value, fixedFormat.decimals);\n\t        if (!fixedFormat.signed && numeric.lt(Zero)) {\n\t            throwFault(\"unsigned value cannot be negative\", \"overflow\", \"value\", value);\n\t        }\n\t        var hex = null;\n\t        if (fixedFormat.signed) {\n\t            hex = numeric.toTwos(fixedFormat.width).toHexString();\n\t        }\n\t        else {\n\t            hex = numeric.toHexString();\n\t            hex = (0, lib$1.hexZeroPad)(hex, fixedFormat.width / 8);\n\t        }\n\t        var decimal = formatFixed(numeric, fixedFormat.decimals);\n\t        return new FixedNumber(_constructorGuard, hex, decimal, fixedFormat);\n\t    };\n\t    FixedNumber.fromBytes = function (value, format) {\n\t        if (format == null) {\n\t            format = \"fixed\";\n\t        }\n\t        var fixedFormat = FixedFormat.from(format);\n\t        if ((0, lib$1.arrayify)(value).length > fixedFormat.width / 8) {\n\t            throw new Error(\"overflow\");\n\t        }\n\t        var numeric = bignumber.BigNumber.from(value);\n\t        if (fixedFormat.signed) {\n\t            numeric = numeric.fromTwos(fixedFormat.width);\n\t        }\n\t        var hex = numeric.toTwos((fixedFormat.signed ? 0 : 1) + fixedFormat.width).toHexString();\n\t        var decimal = formatFixed(numeric, fixedFormat.decimals);\n\t        return new FixedNumber(_constructorGuard, hex, decimal, fixedFormat);\n\t    };\n\t    FixedNumber.from = function (value, format) {\n\t        if (typeof (value) === \"string\") {\n\t            return FixedNumber.fromString(value, format);\n\t        }\n\t        if ((0, lib$1.isBytes)(value)) {\n\t            return FixedNumber.fromBytes(value, format);\n\t        }\n\t        try {\n\t            return FixedNumber.fromValue(value, 0, format);\n\t        }\n\t        catch (error) {\n\t            // Allow NUMERIC_FAULT to bubble up\n\t            if (error.code !== lib.Logger.errors.INVALID_ARGUMENT) {\n\t                throw error;\n\t            }\n\t        }\n\t        return logger.throwArgumentError(\"invalid FixedNumber value\", \"value\", value);\n\t    };\n\t    FixedNumber.isFixedNumber = function (value) {\n\t        return !!(value && value._isFixedNumber);\n\t    };\n\t    return FixedNumber;\n\t}());\n\texports.FixedNumber = FixedNumber;\n\tvar ONE = FixedNumber.from(1);\n\tvar BUMP = FixedNumber.from(\"0.5\");\n\n\t});\n\n\tvar fixednumber$1 = /*@__PURE__*/getDefaultExportFromCjs(fixednumber);\n\n\tvar lib$2 = createCommonjsModule(function (module, exports) {\n\t\"use strict\";\n\tObject.defineProperty(exports, \"__esModule\", { value: true });\n\texports._base36To16 = exports._base16To36 = exports.parseFixed = exports.FixedNumber = exports.FixedFormat = exports.formatFixed = exports.BigNumber = void 0;\n\n\tObject.defineProperty(exports, \"BigNumber\", { enumerable: true, get: function () { return bignumber.BigNumber; } });\n\n\tObject.defineProperty(exports, \"formatFixed\", { enumerable: true, get: function () { return fixednumber.formatFixed; } });\n\tObject.defineProperty(exports, \"FixedFormat\", { enumerable: true, get: function () { return fixednumber.FixedFormat; } });\n\tObject.defineProperty(exports, \"FixedNumber\", { enumerable: true, get: function () { return fixednumber.FixedNumber; } });\n\tObject.defineProperty(exports, \"parseFixed\", { enumerable: true, get: function () { return fixednumber.parseFixed; } });\n\t// Internal methods used by address\n\tvar bignumber_2 = bignumber;\n\tObject.defineProperty(exports, \"_base16To36\", { enumerable: true, get: function () { return bignumber_2._base16To36; } });\n\tObject.defineProperty(exports, \"_base36To16\", { enumerable: true, get: function () { return bignumber_2._base36To16; } });\n\n\t});\n\n\tvar index$2 = /*@__PURE__*/getDefaultExportFromCjs(lib$2);\n\n\tvar _version$6 = createCommonjsModule(function (module, exports) {\n\t\"use strict\";\n\tObject.defineProperty(exports, \"__esModule\", { value: true });\n\texports.version = void 0;\n\texports.version = \"properties/5.5.0\";\n\n\t});\n\n\tvar _version$7 = /*@__PURE__*/getDefaultExportFromCjs(_version$6);\n\n\tvar lib$3 = createCommonjsModule(function (module, exports) {\n\t\"use strict\";\n\tvar __awaiter = (commonjsGlobal && commonjsGlobal.__awaiter) || function (thisArg, _arguments, P, generator) {\n\t    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n\t    return new (P || (P = Promise))(function (resolve, reject) {\n\t        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n\t        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n\t        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n\t        step((generator = generator.apply(thisArg, _arguments || [])).next());\n\t    });\n\t};\n\tvar __generator = (commonjsGlobal && commonjsGlobal.__generator) || function (thisArg, body) {\n\t    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\n\t    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\n\t    function verb(n) { return function (v) { return step([n, v]); }; }\n\t    function step(op) {\n\t        if (f) throw new TypeError(\"Generator is already executing.\");\n\t        while (_) try {\n\t            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n\t            if (y = 0, t) op = [op[0] & 2, t.value];\n\t            switch (op[0]) {\n\t                case 0: case 1: t = op; break;\n\t                case 4: _.label++; return { value: op[1], done: false };\n\t                case 5: _.label++; y = op[1]; op = [0]; continue;\n\t                case 7: op = _.ops.pop(); _.trys.pop(); continue;\n\t                default:\n\t                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\n\t                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\n\t                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\n\t                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\n\t                    if (t[2]) _.ops.pop();\n\t                    _.trys.pop(); continue;\n\t            }\n\t            op = body.call(thisArg, _);\n\t        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\n\t        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\n\t    }\n\t};\n\tObject.defineProperty(exports, \"__esModule\", { value: true });\n\texports.Description = exports.deepCopy = exports.shallowCopy = exports.checkProperties = exports.resolveProperties = exports.getStatic = exports.defineReadOnly = void 0;\n\n\n\tvar logger = new lib.Logger(_version$6.version);\n\tfunction defineReadOnly(object, name, value) {\n\t    Object.defineProperty(object, name, {\n\t        enumerable: true,\n\t        value: value,\n\t        writable: false,\n\t    });\n\t}\n\texports.defineReadOnly = defineReadOnly;\n\t// Crawl up the constructor chain to find a static method\n\tfunction getStatic(ctor, key) {\n\t    for (var i = 0; i < 32; i++) {\n\t        if (ctor[key]) {\n\t            return ctor[key];\n\t        }\n\t        if (!ctor.prototype || typeof (ctor.prototype) !== \"object\") {\n\t            break;\n\t        }\n\t        ctor = Object.getPrototypeOf(ctor.prototype).constructor;\n\t    }\n\t    return null;\n\t}\n\texports.getStatic = getStatic;\n\tfunction resolveProperties(object) {\n\t    return __awaiter(this, void 0, void 0, function () {\n\t        var promises, results;\n\t        return __generator(this, function (_a) {\n\t            switch (_a.label) {\n\t                case 0:\n\t                    promises = Object.keys(object).map(function (key) {\n\t                        var value = object[key];\n\t                        return Promise.resolve(value).then(function (v) { return ({ key: key, value: v }); });\n\t                    });\n\t                    return [4 /*yield*/, Promise.all(promises)];\n\t                case 1:\n\t                    results = _a.sent();\n\t                    return [2 /*return*/, results.reduce(function (accum, result) {\n\t                            accum[(result.key)] = result.value;\n\t                            return accum;\n\t                        }, {})];\n\t            }\n\t        });\n\t    });\n\t}\n\texports.resolveProperties = resolveProperties;\n\tfunction checkProperties(object, properties) {\n\t    if (!object || typeof (object) !== \"object\") {\n\t        logger.throwArgumentError(\"invalid object\", \"object\", object);\n\t    }\n\t    Object.keys(object).forEach(function (key) {\n\t        if (!properties[key]) {\n\t            logger.throwArgumentError(\"invalid object key - \" + key, \"transaction:\" + key, object);\n\t        }\n\t    });\n\t}\n\texports.checkProperties = checkProperties;\n\tfunction shallowCopy(object) {\n\t    var result = {};\n\t    for (var key in object) {\n\t        result[key] = object[key];\n\t    }\n\t    return result;\n\t}\n\texports.shallowCopy = shallowCopy;\n\tvar opaque = { bigint: true, boolean: true, \"function\": true, number: true, string: true };\n\tfunction _isFrozen(object) {\n\t    // Opaque objects are not mutable, so safe to copy by assignment\n\t    if (object === undefined || object === null || opaque[typeof (object)]) {\n\t        return true;\n\t    }\n\t    if (Array.isArray(object) || typeof (object) === \"object\") {\n\t        if (!Object.isFrozen(object)) {\n\t            return false;\n\t        }\n\t        var keys = Object.keys(object);\n\t        for (var i = 0; i < keys.length; i++) {\n\t            var value = null;\n\t            try {\n\t                value = object[keys[i]];\n\t            }\n\t            catch (error) {\n\t                // If accessing a value triggers an error, it is a getter\n\t                // designed to do so (e.g. Result) and is therefore \"frozen\"\n\t                continue;\n\t            }\n\t            if (!_isFrozen(value)) {\n\t                return false;\n\t            }\n\t        }\n\t        return true;\n\t    }\n\t    return logger.throwArgumentError(\"Cannot deepCopy \" + typeof (object), \"object\", object);\n\t}\n\t// Returns a new copy of object, such that no properties may be replaced.\n\t// New properties may be added only to objects.\n\tfunction _deepCopy(object) {\n\t    if (_isFrozen(object)) {\n\t        return object;\n\t    }\n\t    // Arrays are mutable, so we need to create a copy\n\t    if (Array.isArray(object)) {\n\t        return Object.freeze(object.map(function (item) { return deepCopy(item); }));\n\t    }\n\t    if (typeof (object) === \"object\") {\n\t        var result = {};\n\t        for (var key in object) {\n\t            var value = object[key];\n\t            if (value === undefined) {\n\t                continue;\n\t            }\n\t            defineReadOnly(result, key, deepCopy(value));\n\t        }\n\t        return result;\n\t    }\n\t    return logger.throwArgumentError(\"Cannot deepCopy \" + typeof (object), \"object\", object);\n\t}\n\tfunction deepCopy(object) {\n\t    return _deepCopy(object);\n\t}\n\texports.deepCopy = deepCopy;\n\tvar Description = /** @class */ (function () {\n\t    function Description(info) {\n\t        for (var key in info) {\n\t            this[key] = deepCopy(info[key]);\n\t        }\n\t    }\n\t    return Description;\n\t}());\n\texports.Description = Description;\n\n\t});\n\n\tvar index$3 = /*@__PURE__*/getDefaultExportFromCjs(lib$3);\n\n\tvar _version$8 = createCommonjsModule(function (module, exports) {\n\t\"use strict\";\n\tObject.defineProperty(exports, \"__esModule\", { value: true });\n\texports.version = void 0;\n\texports.version = \"abi/5.5.0\";\n\n\t});\n\n\tvar _version$9 = /*@__PURE__*/getDefaultExportFromCjs(_version$8);\n\n\tvar fragments = createCommonjsModule(function (module, exports) {\n\t\"use strict\";\n\tvar __extends = (commonjsGlobal && commonjsGlobal.__extends) || (function () {\n\t    var extendStatics = function (d, b) {\n\t        extendStatics = Object.setPrototypeOf ||\n\t            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n\t            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n\t        return extendStatics(d, b);\n\t    };\n\t    return function (d, b) {\n\t        if (typeof b !== \"function\" && b !== null)\n\t            throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n\t        extendStatics(d, b);\n\t        function __() { this.constructor = d; }\n\t        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n\t    };\n\t})();\n\tObject.defineProperty(exports, \"__esModule\", { value: true });\n\texports.ErrorFragment = exports.FunctionFragment = exports.ConstructorFragment = exports.EventFragment = exports.Fragment = exports.ParamType = exports.FormatTypes = void 0;\n\n\n\n\n\tvar logger = new lib.Logger(_version$8.version);\n\t;\n\tvar _constructorGuard = {};\n\tvar ModifiersBytes = { calldata: true, memory: true, storage: true };\n\tvar ModifiersNest = { calldata: true, memory: true };\n\tfunction checkModifier(type, name) {\n\t    if (type === \"bytes\" || type === \"string\") {\n\t        if (ModifiersBytes[name]) {\n\t            return true;\n\t        }\n\t    }\n\t    else if (type === \"address\") {\n\t        if (name === \"payable\") {\n\t            return true;\n\t        }\n\t    }\n\t    else if (type.indexOf(\"[\") >= 0 || type === \"tuple\") {\n\t        if (ModifiersNest[name]) {\n\t            return true;\n\t        }\n\t    }\n\t    if (ModifiersBytes[name] || name === \"payable\") {\n\t        logger.throwArgumentError(\"invalid modifier\", \"name\", name);\n\t    }\n\t    return false;\n\t}\n\t// @TODO: Make sure that children of an indexed tuple are marked with a null indexed\n\tfunction parseParamType(param, allowIndexed) {\n\t    var originalParam = param;\n\t    function throwError(i) {\n\t        logger.throwArgumentError(\"unexpected character at position \" + i, \"param\", param);\n\t    }\n\t    param = param.replace(/\\s/g, \" \");\n\t    function newNode(parent) {\n\t        var node = { type: \"\", name: \"\", parent: parent, state: { allowType: true } };\n\t        if (allowIndexed) {\n\t            node.indexed = false;\n\t        }\n\t        return node;\n\t    }\n\t    var parent = { type: \"\", name: \"\", state: { allowType: true } };\n\t    var node = parent;\n\t    for (var i = 0; i < param.length; i++) {\n\t        var c = param[i];\n\t        switch (c) {\n\t            case \"(\":\n\t                if (node.state.allowType && node.type === \"\") {\n\t                    node.type = \"tuple\";\n\t                }\n\t                else if (!node.state.allowParams) {\n\t                    throwError(i);\n\t                }\n\t                node.state.allowType = false;\n\t                node.type = verifyType(node.type);\n\t                node.components = [newNode(node)];\n\t                node = node.components[0];\n\t                break;\n\t            case \")\":\n\t                delete node.state;\n\t                if (node.name === \"indexed\") {\n\t                    if (!allowIndexed) {\n\t                        throwError(i);\n\t                    }\n\t                    node.indexed = true;\n\t                    node.name = \"\";\n\t                }\n\t                if (checkModifier(node.type, node.name)) {\n\t                    node.name = \"\";\n\t                }\n\t                node.type = verifyType(node.type);\n\t                var child = node;\n\t                node = node.parent;\n\t                if (!node) {\n\t                    throwError(i);\n\t                }\n\t                delete child.parent;\n\t                node.state.allowParams = false;\n\t                node.state.allowName = true;\n\t                node.state.allowArray = true;\n\t                break;\n\t            case \",\":\n\t                delete node.state;\n\t                if (node.name === \"indexed\") {\n\t                    if (!allowIndexed) {\n\t                        throwError(i);\n\t                    }\n\t                    node.indexed = true;\n\t                    node.name = \"\";\n\t                }\n\t                if (checkModifier(node.type, node.name)) {\n\t                    node.name = \"\";\n\t                }\n\t                node.type = verifyType(node.type);\n\t                var sibling = newNode(node.parent);\n\t                //{ type: \"\", name: \"\", parent: node.parent, state: { allowType: true } };\n\t                node.parent.components.push(sibling);\n\t                delete node.parent;\n\t                node = sibling;\n\t                break;\n\t            // Hit a space...\n\t            case \" \":\n\t                // If reading type, the type is done and may read a param or name\n\t                if (node.state.allowType) {\n\t                    if (node.type !== \"\") {\n\t                        node.type = verifyType(node.type);\n\t                        delete node.state.allowType;\n\t                        node.state.allowName = true;\n\t                        node.state.allowParams = true;\n\t                    }\n\t                }\n\t                // If reading name, the name is done\n\t                if (node.state.allowName) {\n\t                    if (node.name !== \"\") {\n\t                        if (node.name === \"indexed\") {\n\t                            if (!allowIndexed) {\n\t                                throwError(i);\n\t                            }\n\t                            if (node.indexed) {\n\t                                throwError(i);\n\t                            }\n\t                            node.indexed = true;\n\t                            node.name = \"\";\n\t                        }\n\t                        else if (checkModifier(node.type, node.name)) {\n\t                            node.name = \"\";\n\t                        }\n\t                        else {\n\t                            node.state.allowName = false;\n\t                        }\n\t                    }\n\t                }\n\t                break;\n\t            case \"[\":\n\t                if (!node.state.allowArray) {\n\t                    throwError(i);\n\t                }\n\t                node.type += c;\n\t                node.state.allowArray = false;\n\t                node.state.allowName = false;\n\t                node.state.readArray = true;\n\t                break;\n\t            case \"]\":\n\t                if (!node.state.readArray) {\n\t                    throwError(i);\n\t                }\n\t                node.type += c;\n\t                node.state.readArray = false;\n\t                node.state.allowArray = true;\n\t                node.state.allowName = true;\n\t                break;\n\t            default:\n\t                if (node.state.allowType) {\n\t                    node.type += c;\n\t                    node.state.allowParams = true;\n\t                    node.state.allowArray = true;\n\t                }\n\t                else if (node.state.allowName) {\n\t                    node.name += c;\n\t                    delete node.state.allowArray;\n\t                }\n\t                else if (node.state.readArray) {\n\t                    node.type += c;\n\t                }\n\t                else {\n\t                    throwError(i);\n\t                }\n\t        }\n\t    }\n\t    if (node.parent) {\n\t        logger.throwArgumentError(\"unexpected eof\", \"param\", param);\n\t    }\n\t    delete parent.state;\n\t    if (node.name === \"indexed\") {\n\t        if (!allowIndexed) {\n\t            throwError(originalParam.length - 7);\n\t        }\n\t        if (node.indexed) {\n\t            throwError(originalParam.length - 7);\n\t        }\n\t        node.indexed = true;\n\t        node.name = \"\";\n\t    }\n\t    else if (checkModifier(node.type, node.name)) {\n\t        node.name = \"\";\n\t    }\n\t    parent.type = verifyType(parent.type);\n\t    return parent;\n\t}\n\tfunction populate(object, params) {\n\t    for (var key in params) {\n\t        (0, lib$3.defineReadOnly)(object, key, params[key]);\n\t    }\n\t}\n\texports.FormatTypes = Object.freeze({\n\t    // Bare formatting, as is needed for computing a sighash of an event or function\n\t    sighash: \"sighash\",\n\t    // Human-Readable with Minimal spacing and without names (compact human-readable)\n\t    minimal: \"minimal\",\n\t    // Human-Readable with nice spacing, including all names\n\t    full: \"full\",\n\t    // JSON-format a la Solidity\n\t    json: \"json\"\n\t});\n\tvar paramTypeArray = new RegExp(/^(.*)\\[([0-9]*)\\]$/);\n\tvar ParamType = /** @class */ (function () {\n\t    function ParamType(constructorGuard, params) {\n\t        if (constructorGuard !== _constructorGuard) {\n\t            logger.throwError(\"use fromString\", lib.Logger.errors.UNSUPPORTED_OPERATION, {\n\t                operation: \"new ParamType()\"\n\t            });\n\t        }\n\t        populate(this, params);\n\t        var match = this.type.match(paramTypeArray);\n\t        if (match) {\n\t            populate(this, {\n\t                arrayLength: parseInt(match[2] || \"-1\"),\n\t                arrayChildren: ParamType.fromObject({\n\t                    type: match[1],\n\t                    components: this.components\n\t                }),\n\t                baseType: \"array\"\n\t            });\n\t        }\n\t        else {\n\t            populate(this, {\n\t                arrayLength: null,\n\t                arrayChildren: null,\n\t                baseType: ((this.components != null) ? \"tuple\" : this.type)\n\t            });\n\t        }\n\t        this._isParamType = true;\n\t        Object.freeze(this);\n\t    }\n\t    // Format the parameter fragment\n\t    //   - sighash: \"(uint256,address)\"\n\t    //   - minimal: \"tuple(uint256,address) indexed\"\n\t    //   - full:    \"tuple(uint256 foo, address bar) indexed baz\"\n\t    ParamType.prototype.format = function (format) {\n\t        if (!format) {\n\t            format = exports.FormatTypes.sighash;\n\t        }\n\t        if (!exports.FormatTypes[format]) {\n\t            logger.throwArgumentError(\"invalid format type\", \"format\", format);\n\t        }\n\t        if (format === exports.FormatTypes.json) {\n\t            var result_1 = {\n\t                type: ((this.baseType === \"tuple\") ? \"tuple\" : this.type),\n\t                name: (this.name || undefined)\n\t            };\n\t            if (typeof (this.indexed) === \"boolean\") {\n\t                result_1.indexed = this.indexed;\n\t            }\n\t            if (this.components) {\n\t                result_1.components = this.components.map(function (comp) { return JSON.parse(comp.format(format)); });\n\t            }\n\t            return JSON.stringify(result_1);\n\t        }\n\t        var result = \"\";\n\t        // Array\n\t        if (this.baseType === \"array\") {\n\t            result += this.arrayChildren.format(format);\n\t            result += \"[\" + (this.arrayLength < 0 ? \"\" : String(this.arrayLength)) + \"]\";\n\t        }\n\t        else {\n\t            if (this.baseType === \"tuple\") {\n\t                if (format !== exports.FormatTypes.sighash) {\n\t                    result += this.type;\n\t                }\n\t                result += \"(\" + this.components.map(function (comp) { return comp.format(format); }).join((format === exports.FormatTypes.full) ? \", \" : \",\") + \")\";\n\t            }\n\t            else {\n\t                result += this.type;\n\t            }\n\t        }\n\t        if (format !== exports.FormatTypes.sighash) {\n\t            if (this.indexed === true) {\n\t                result += \" indexed\";\n\t            }\n\t            if (format === exports.FormatTypes.full && this.name) {\n\t                result += \" \" + this.name;\n\t            }\n\t        }\n\t        return result;\n\t    };\n\t    ParamType.from = function (value, allowIndexed) {\n\t        if (typeof (value) === \"string\") {\n\t            return ParamType.fromString(value, allowIndexed);\n\t        }\n\t        return ParamType.fromObject(value);\n\t    };\n\t    ParamType.fromObject = function (value) {\n\t        if (ParamType.isParamType(value)) {\n\t            return value;\n\t        }\n\t        return new ParamType(_constructorGuard, {\n\t            name: (value.name || null),\n\t            type: verifyType(value.type),\n\t            indexed: ((value.indexed == null) ? null : !!value.indexed),\n\t            components: (value.components ? value.components.map(ParamType.fromObject) : null)\n\t        });\n\t    };\n\t    ParamType.fromString = function (value, allowIndexed) {\n\t        function ParamTypify(node) {\n\t            return ParamType.fromObject({\n\t                name: node.name,\n\t                type: node.type,\n\t                indexed: node.indexed,\n\t                components: node.components\n\t            });\n\t        }\n\t        return ParamTypify(parseParamType(value, !!allowIndexed));\n\t    };\n\t    ParamType.isParamType = function (value) {\n\t        return !!(value != null && value._isParamType);\n\t    };\n\t    return ParamType;\n\t}());\n\texports.ParamType = ParamType;\n\t;\n\tfunction parseParams(value, allowIndex) {\n\t    return splitNesting(value).map(function (param) { return ParamType.fromString(param, allowIndex); });\n\t}\n\tvar Fragment = /** @class */ (function () {\n\t    function Fragment(constructorGuard, params) {\n\t        if (constructorGuard !== _constructorGuard) {\n\t            logger.throwError(\"use a static from method\", lib.Logger.errors.UNSUPPORTED_OPERATION, {\n\t                operation: \"new Fragment()\"\n\t            });\n\t        }\n\t        populate(this, params);\n\t        this._isFragment = true;\n\t        Object.freeze(this);\n\t    }\n\t    Fragment.from = function (value) {\n\t        if (Fragment.isFragment(value)) {\n\t            return value;\n\t        }\n\t        if (typeof (value) === \"string\") {\n\t            return Fragment.fromString(value);\n\t        }\n\t        return Fragment.fromObject(value);\n\t    };\n\t    Fragment.fromObject = function (value) {\n\t        if (Fragment.isFragment(value)) {\n\t            return value;\n\t        }\n\t        switch (value.type) {\n\t            case \"function\":\n\t                return FunctionFragment.fromObject(value);\n\t            case \"event\":\n\t                return EventFragment.fromObject(value);\n\t            case \"constructor\":\n\t                return ConstructorFragment.fromObject(value);\n\t            case \"error\":\n\t                return ErrorFragment.fromObject(value);\n\t            case \"fallback\":\n\t            case \"receive\":\n\t                // @TODO: Something? Maybe return a FunctionFragment? A custom DefaultFunctionFragment?\n\t                return null;\n\t        }\n\t        return logger.throwArgumentError(\"invalid fragment object\", \"value\", value);\n\t    };\n\t    Fragment.fromString = function (value) {\n\t        // Make sure the \"returns\" is surrounded by a space and all whitespace is exactly one space\n\t        value = value.replace(/\\s/g, \" \");\n\t        value = value.replace(/\\(/g, \" (\").replace(/\\)/g, \") \").replace(/\\s+/g, \" \");\n\t        value = value.trim();\n\t        if (value.split(\" \")[0] === \"event\") {\n\t            return EventFragment.fromString(value.substring(5).trim());\n\t        }\n\t        else if (value.split(\" \")[0] === \"function\") {\n\t            return FunctionFragment.fromString(value.substring(8).trim());\n\t        }\n\t        else if (value.split(\"(\")[0].trim() === \"constructor\") {\n\t            return ConstructorFragment.fromString(value.trim());\n\t        }\n\t        else if (value.split(\" \")[0] === \"error\") {\n\t            return ErrorFragment.fromString(value.substring(5).trim());\n\t        }\n\t        return logger.throwArgumentError(\"unsupported fragment\", \"value\", value);\n\t    };\n\t    Fragment.isFragment = function (value) {\n\t        return !!(value && value._isFragment);\n\t    };\n\t    return Fragment;\n\t}());\n\texports.Fragment = Fragment;\n\tvar EventFragment = /** @class */ (function (_super) {\n\t    __extends(EventFragment, _super);\n\t    function EventFragment() {\n\t        return _super !== null && _super.apply(this, arguments) || this;\n\t    }\n\t    EventFragment.prototype.format = function (format) {\n\t        if (!format) {\n\t            format = exports.FormatTypes.sighash;\n\t        }\n\t        if (!exports.FormatTypes[format]) {\n\t            logger.throwArgumentError(\"invalid format type\", \"format\", format);\n\t        }\n\t        if (format === exports.FormatTypes.json) {\n\t            return JSON.stringify({\n\t                type: \"event\",\n\t                anonymous: this.anonymous,\n\t                name: this.name,\n\t                inputs: this.inputs.map(function (input) { return JSON.parse(input.format(format)); })\n\t            });\n\t        }\n\t        var result = \"\";\n\t        if (format !== exports.FormatTypes.sighash) {\n\t            result += \"event \";\n\t        }\n\t        result += this.name + \"(\" + this.inputs.map(function (input) { return input.format(format); }).join((format === exports.FormatTypes.full) ? \", \" : \",\") + \") \";\n\t        if (format !== exports.FormatTypes.sighash) {\n\t            if (this.anonymous) {\n\t                result += \"anonymous \";\n\t            }\n\t        }\n\t        return result.trim();\n\t    };\n\t    EventFragment.from = function (value) {\n\t        if (typeof (value) === \"string\") {\n\t            return EventFragment.fromString(value);\n\t        }\n\t        return EventFragment.fromObject(value);\n\t    };\n\t    EventFragment.fromObject = function (value) {\n\t        if (EventFragment.isEventFragment(value)) {\n\t            return value;\n\t        }\n\t        if (value.type !== \"event\") {\n\t            logger.throwArgumentError(\"invalid event object\", \"value\", value);\n\t        }\n\t        var params = {\n\t            name: verifyIdentifier(value.name),\n\t            anonymous: value.anonymous,\n\t            inputs: (value.inputs ? value.inputs.map(ParamType.fromObject) : []),\n\t            type: \"event\"\n\t        };\n\t        return new EventFragment(_constructorGuard, params);\n\t    };\n\t    EventFragment.fromString = function (value) {\n\t        var match = value.match(regexParen);\n\t        if (!match) {\n\t            logger.throwArgumentError(\"invalid event string\", \"value\", value);\n\t        }\n\t        var anonymous = false;\n\t        match[3].split(\" \").forEach(function (modifier) {\n\t            switch (modifier.trim()) {\n\t                case \"anonymous\":\n\t                    anonymous = true;\n\t                    break;\n\t                case \"\":\n\t                    break;\n\t                default:\n\t                    logger.warn(\"unknown modifier: \" + modifier);\n\t            }\n\t        });\n\t        return EventFragment.fromObject({\n\t            name: match[1].trim(),\n\t            anonymous: anonymous,\n\t            inputs: parseParams(match[2], true),\n\t            type: \"event\"\n\t        });\n\t    };\n\t    EventFragment.isEventFragment = function (value) {\n\t        return (value && value._isFragment && value.type === \"event\");\n\t    };\n\t    return EventFragment;\n\t}(Fragment));\n\texports.EventFragment = EventFragment;\n\tfunction parseGas(value, params) {\n\t    params.gas = null;\n\t    var comps = value.split(\"@\");\n\t    if (comps.length !== 1) {\n\t        if (comps.length > 2) {\n\t            logger.throwArgumentError(\"invalid human-readable ABI signature\", \"value\", value);\n\t        }\n\t        if (!comps[1].match(/^[0-9]+$/)) {\n\t            logger.throwArgumentError(\"invalid human-readable ABI signature gas\", \"value\", value);\n\t        }\n\t        params.gas = lib$2.BigNumber.from(comps[1]);\n\t        return comps[0];\n\t    }\n\t    return value;\n\t}\n\tfunction parseModifiers(value, params) {\n\t    params.constant = false;\n\t    params.payable = false;\n\t    params.stateMutability = \"nonpayable\";\n\t    value.split(\" \").forEach(function (modifier) {\n\t        switch (modifier.trim()) {\n\t            case \"constant\":\n\t                params.constant = true;\n\t                break;\n\t            case \"payable\":\n\t                params.payable = true;\n\t                params.stateMutability = \"payable\";\n\t                break;\n\t            case \"nonpayable\":\n\t                params.payable = false;\n\t                params.stateMutability = \"nonpayable\";\n\t                break;\n\t            case \"pure\":\n\t                params.constant = true;\n\t                params.stateMutability = \"pure\";\n\t                break;\n\t            case \"view\":\n\t                params.constant = true;\n\t                params.stateMutability = \"view\";\n\t                break;\n\t            case \"external\":\n\t            case \"public\":\n\t            case \"\":\n\t                break;\n\t            default:\n\t                console.log(\"unknown modifier: \" + modifier);\n\t        }\n\t    });\n\t}\n\tfunction verifyState(value) {\n\t    var result = {\n\t        constant: false,\n\t        payable: true,\n\t        stateMutability: \"payable\"\n\t    };\n\t    if (value.stateMutability != null) {\n\t        result.stateMutability = value.stateMutability;\n\t        // Set (and check things are consistent) the constant property\n\t        result.constant = (result.stateMutability === \"view\" || result.stateMutability === \"pure\");\n\t        if (value.constant != null) {\n\t            if ((!!value.constant) !== result.constant) {\n\t                logger.throwArgumentError(\"cannot have constant function with mutability \" + result.stateMutability, \"value\", value);\n\t            }\n\t        }\n\t        // Set (and check things are consistent) the payable property\n\t        result.payable = (result.stateMutability === \"payable\");\n\t        if (value.payable != null) {\n\t            if ((!!value.payable) !== result.payable) {\n\t                logger.throwArgumentError(\"cannot have payable function with mutability \" + result.stateMutability, \"value\", value);\n\t            }\n\t        }\n\t    }\n\t    else if (value.payable != null) {\n\t        result.payable = !!value.payable;\n\t        // If payable we can assume non-constant; otherwise we can't assume\n\t        if (value.constant == null && !result.payable && value.type !== \"constructor\") {\n\t            logger.throwArgumentError(\"unable to determine stateMutability\", \"value\", value);\n\t        }\n\t        result.constant = !!value.constant;\n\t        if (result.constant) {\n\t            result.stateMutability = \"view\";\n\t        }\n\t        else {\n\t            result.stateMutability = (result.payable ? \"payable\" : \"nonpayable\");\n\t        }\n\t        if (result.payable && result.constant) {\n\t            logger.throwArgumentError(\"cannot have constant payable function\", \"value\", value);\n\t        }\n\t    }\n\t    else if (value.constant != null) {\n\t        result.constant = !!value.constant;\n\t        result.payable = !result.constant;\n\t        result.stateMutability = (result.constant ? \"view\" : \"payable\");\n\t    }\n\t    else if (value.type !== \"constructor\") {\n\t        logger.throwArgumentError(\"unable to determine stateMutability\", \"value\", value);\n\t    }\n\t    return result;\n\t}\n\tvar ConstructorFragment = /** @class */ (function (_super) {\n\t    __extends(ConstructorFragment, _super);\n\t    function ConstructorFragment() {\n\t        return _super !== null && _super.apply(this, arguments) || this;\n\t    }\n\t    ConstructorFragment.prototype.format = function (format) {\n\t        if (!format) {\n\t            format = exports.FormatTypes.sighash;\n\t        }\n\t        if (!exports.FormatTypes[format]) {\n\t            logger.throwArgumentError(\"invalid format type\", \"format\", format);\n\t        }\n\t        if (format === exports.FormatTypes.json) {\n\t            return JSON.stringify({\n\t                type: \"constructor\",\n\t                stateMutability: ((this.stateMutability !== \"nonpayable\") ? this.stateMutability : undefined),\n\t                payable: this.payable,\n\t                gas: (this.gas ? this.gas.toNumber() : undefined),\n\t                inputs: this.inputs.map(function (input) { return JSON.parse(input.format(format)); })\n\t            });\n\t        }\n\t        if (format === exports.FormatTypes.sighash) {\n\t            logger.throwError(\"cannot format a constructor for sighash\", lib.Logger.errors.UNSUPPORTED_OPERATION, {\n\t                operation: \"format(sighash)\"\n\t            });\n\t        }\n\t        var result = \"constructor(\" + this.inputs.map(function (input) { return input.format(format); }).join((format === exports.FormatTypes.full) ? \", \" : \",\") + \") \";\n\t        if (this.stateMutability && this.stateMutability !== \"nonpayable\") {\n\t            result += this.stateMutability + \" \";\n\t        }\n\t        return result.trim();\n\t    };\n\t    ConstructorFragment.from = function (value) {\n\t        if (typeof (value) === \"string\") {\n\t            return ConstructorFragment.fromString(value);\n\t        }\n\t        return ConstructorFragment.fromObject(value);\n\t    };\n\t    ConstructorFragment.fromObject = function (value) {\n\t        if (ConstructorFragment.isConstructorFragment(value)) {\n\t            return value;\n\t        }\n\t        if (value.type !== \"constructor\") {\n\t            logger.throwArgumentError(\"invalid constructor object\", \"value\", value);\n\t        }\n\t        var state = verifyState(value);\n\t        if (state.constant) {\n\t            logger.throwArgumentError(\"constructor cannot be constant\", \"value\", value);\n\t        }\n\t        var params = {\n\t            name: null,\n\t            type: value.type,\n\t            inputs: (value.inputs ? value.inputs.map(ParamType.fromObject) : []),\n\t            payable: state.payable,\n\t            stateMutability: state.stateMutability,\n\t            gas: (value.gas ? lib$2.BigNumber.from(value.gas) : null)\n\t        };\n\t        return new ConstructorFragment(_constructorGuard, params);\n\t    };\n\t    ConstructorFragment.fromString = function (value) {\n\t        var params = { type: \"constructor\" };\n\t        value = parseGas(value, params);\n\t        var parens = value.match(regexParen);\n\t        if (!parens || parens[1].trim() !== \"constructor\") {\n\t            logger.throwArgumentError(\"invalid constructor string\", \"value\", value);\n\t        }\n\t        params.inputs = parseParams(parens[2].trim(), false);\n\t        parseModifiers(parens[3].trim(), params);\n\t        return ConstructorFragment.fromObject(params);\n\t    };\n\t    ConstructorFragment.isConstructorFragment = function (value) {\n\t        return (value && value._isFragment && value.type === \"constructor\");\n\t    };\n\t    return ConstructorFragment;\n\t}(Fragment));\n\texports.ConstructorFragment = ConstructorFragment;\n\tvar FunctionFragment = /** @class */ (function (_super) {\n\t    __extends(FunctionFragment, _super);\n\t    function FunctionFragment() {\n\t        return _super !== null && _super.apply(this, arguments) || this;\n\t    }\n\t    FunctionFragment.prototype.format = function (format) {\n\t        if (!format) {\n\t            format = exports.FormatTypes.sighash;\n\t        }\n\t        if (!exports.FormatTypes[format]) {\n\t            logger.throwArgumentError(\"invalid format type\", \"format\", format);\n\t        }\n\t        if (format === exports.FormatTypes.json) {\n\t            return JSON.stringify({\n\t                type: \"function\",\n\t                name: this.name,\n\t                constant: this.constant,\n\t                stateMutability: ((this.stateMutability !== \"nonpayable\") ? this.stateMutability : undefined),\n\t                payable: this.payable,\n\t                gas: (this.gas ? this.gas.toNumber() : undefined),\n\t                inputs: this.inputs.map(function (input) { return JSON.parse(input.format(format)); }),\n\t                outputs: this.outputs.map(function (output) { return JSON.parse(output.format(format)); }),\n\t            });\n\t        }\n\t        var result = \"\";\n\t        if (format !== exports.FormatTypes.sighash) {\n\t            result += \"function \";\n\t        }\n\t        result += this.name + \"(\" + this.inputs.map(function (input) { return input.format(format); }).join((format === exports.FormatTypes.full) ? \", \" : \",\") + \") \";\n\t        if (format !== exports.FormatTypes.sighash) {\n\t            if (this.stateMutability) {\n\t                if (this.stateMutability !== \"nonpayable\") {\n\t                    result += (this.stateMutability + \" \");\n\t                }\n\t            }\n\t            else if (this.constant) {\n\t                result += \"view \";\n\t            }\n\t            if (this.outputs && this.outputs.length) {\n\t                result += \"returns (\" + this.outputs.map(function (output) { return output.format(format); }).join(\", \") + \") \";\n\t            }\n\t            if (this.gas != null) {\n\t                result += \"@\" + this.gas.toString() + \" \";\n\t            }\n\t        }\n\t        return result.trim();\n\t    };\n\t    FunctionFragment.from = function (value) {\n\t        if (typeof (value) === \"string\") {\n\t            return FunctionFragment.fromString(value);\n\t        }\n\t        return FunctionFragment.fromObject(value);\n\t    };\n\t    FunctionFragment.fromObject = function (value) {\n\t        if (FunctionFragment.isFunctionFragment(value)) {\n\t            return value;\n\t        }\n\t        if (value.type !== \"function\") {\n\t            logger.throwArgumentError(\"invalid function object\", \"value\", value);\n\t        }\n\t        var state = verifyState(value);\n\t        var params = {\n\t            type: value.type,\n\t            name: verifyIdentifier(value.name),\n\t            constant: state.constant,\n\t            inputs: (value.inputs ? value.inputs.map(ParamType.fromObject) : []),\n\t            outputs: (value.outputs ? value.outputs.map(ParamType.fromObject) : []),\n\t            payable: state.payable,\n\t            stateMutability: state.stateMutability,\n\t            gas: (value.gas ? lib$2.BigNumber.from(value.gas) : null)\n\t        };\n\t        return new FunctionFragment(_constructorGuard, params);\n\t    };\n\t    FunctionFragment.fromString = function (value) {\n\t        var params = { type: \"function\" };\n\t        value = parseGas(value, params);\n\t        var comps = value.split(\" returns \");\n\t        if (comps.length > 2) {\n\t            logger.throwArgumentError(\"invalid function string\", \"value\", value);\n\t        }\n\t        var parens = comps[0].match(regexParen);\n\t        if (!parens) {\n\t            logger.throwArgumentError(\"invalid function signature\", \"value\", value);\n\t        }\n\t        params.name = parens[1].trim();\n\t        if (params.name) {\n\t            verifyIdentifier(params.name);\n\t        }\n\t        params.inputs = parseParams(parens[2], false);\n\t        parseModifiers(parens[3].trim(), params);\n\t        // We have outputs\n\t        if (comps.length > 1) {\n\t            var returns = comps[1].match(regexParen);\n\t            if (returns[1].trim() != \"\" || returns[3].trim() != \"\") {\n\t                logger.throwArgumentError(\"unexpected tokens\", \"value\", value);\n\t            }\n\t            params.outputs = parseParams(returns[2], false);\n\t        }\n\t        else {\n\t            params.outputs = [];\n\t        }\n\t        return FunctionFragment.fromObject(params);\n\t    };\n\t    FunctionFragment.isFunctionFragment = function (value) {\n\t        return (value && value._isFragment && value.type === \"function\");\n\t    };\n\t    return FunctionFragment;\n\t}(ConstructorFragment));\n\texports.FunctionFragment = FunctionFragment;\n\t//export class StructFragment extends Fragment {\n\t//}\n\tfunction checkForbidden(fragment) {\n\t    var sig = fragment.format();\n\t    if (sig === \"Error(string)\" || sig === \"Panic(uint256)\") {\n\t        logger.throwArgumentError(\"cannot specify user defined \" + sig + \" error\", \"fragment\", fragment);\n\t    }\n\t    return fragment;\n\t}\n\tvar ErrorFragment = /** @class */ (function (_super) {\n\t    __extends(ErrorFragment, _super);\n\t    function ErrorFragment() {\n\t        return _super !== null && _super.apply(this, arguments) || this;\n\t    }\n\t    ErrorFragment.prototype.format = function (format) {\n\t        if (!format) {\n\t            format = exports.FormatTypes.sighash;\n\t        }\n\t        if (!exports.FormatTypes[format]) {\n\t            logger.throwArgumentError(\"invalid format type\", \"format\", format);\n\t        }\n\t        if (format === exports.FormatTypes.json) {\n\t            return JSON.stringify({\n\t                type: \"error\",\n\t                name: this.name,\n\t                inputs: this.inputs.map(function (input) { return JSON.parse(input.format(format)); }),\n\t            });\n\t        }\n\t        var result = \"\";\n\t        if (format !== exports.FormatTypes.sighash) {\n\t            result += \"error \";\n\t        }\n\t        result += this.name + \"(\" + this.inputs.map(function (input) { return input.format(format); }).join((format === exports.FormatTypes.full) ? \", \" : \",\") + \") \";\n\t        return result.trim();\n\t    };\n\t    ErrorFragment.from = function (value) {\n\t        if (typeof (value) === \"string\") {\n\t            return ErrorFragment.fromString(value);\n\t        }\n\t        return ErrorFragment.fromObject(value);\n\t    };\n\t    ErrorFragment.fromObject = function (value) {\n\t        if (ErrorFragment.isErrorFragment(value)) {\n\t            return value;\n\t        }\n\t        if (value.type !== \"error\") {\n\t            logger.throwArgumentError(\"invalid error object\", \"value\", value);\n\t        }\n\t        var params = {\n\t            type: value.type,\n\t            name: verifyIdentifier(value.name),\n\t            inputs: (value.inputs ? value.inputs.map(ParamType.fromObject) : [])\n\t        };\n\t        return checkForbidden(new ErrorFragment(_constructorGuard, params));\n\t    };\n\t    ErrorFragment.fromString = function (value) {\n\t        var params = { type: \"error\" };\n\t        var parens = value.match(regexParen);\n\t        if (!parens) {\n\t            logger.throwArgumentError(\"invalid error signature\", \"value\", value);\n\t        }\n\t        params.name = parens[1].trim();\n\t        if (params.name) {\n\t            verifyIdentifier(params.name);\n\t        }\n\t        params.inputs = parseParams(parens[2], false);\n\t        return checkForbidden(ErrorFragment.fromObject(params));\n\t    };\n\t    ErrorFragment.isErrorFragment = function (value) {\n\t        return (value && value._isFragment && value.type === \"error\");\n\t    };\n\t    return ErrorFragment;\n\t}(Fragment));\n\texports.ErrorFragment = ErrorFragment;\n\tfunction verifyType(type) {\n\t    // These need to be transformed to their full description\n\t    if (type.match(/^uint($|[^1-9])/)) {\n\t        type = \"uint256\" + type.substring(4);\n\t    }\n\t    else if (type.match(/^int($|[^1-9])/)) {\n\t        type = \"int256\" + type.substring(3);\n\t    }\n\t    // @TODO: more verification\n\t    return type;\n\t}\n\t// See: https://github.com/ethereum/solidity/blob/1f8f1a3db93a548d0555e3e14cfc55a10e25b60e/docs/grammar/SolidityLexer.g4#L234\n\tvar regexIdentifier = new RegExp(\"^[a-zA-Z$_][a-zA-Z0-9$_]*$\");\n\tfunction verifyIdentifier(value) {\n\t    if (!value || !value.match(regexIdentifier)) {\n\t        logger.throwArgumentError(\"invalid identifier \\\"\" + value + \"\\\"\", \"value\", value);\n\t    }\n\t    return value;\n\t}\n\tvar regexParen = new RegExp(\"^([^)(]*)\\\\((.*)\\\\)([^)(]*)$\");\n\tfunction splitNesting(value) {\n\t    value = value.trim();\n\t    var result = [];\n\t    var accum = \"\";\n\t    var depth = 0;\n\t    for (var offset = 0; offset < value.length; offset++) {\n\t        var c = value[offset];\n\t        if (c === \",\" && depth === 0) {\n\t            result.push(accum);\n\t            accum = \"\";\n\t        }\n\t        else {\n\t            accum += c;\n\t            if (c === \"(\") {\n\t                depth++;\n\t            }\n\t            else if (c === \")\") {\n\t                depth--;\n\t                if (depth === -1) {\n\t                    logger.throwArgumentError(\"unbalanced parenthesis\", \"value\", value);\n\t                }\n\t            }\n\t        }\n\t    }\n\t    if (accum) {\n\t        result.push(accum);\n\t    }\n\t    return result;\n\t}\n\n\t});\n\n\tvar fragments$1 = /*@__PURE__*/getDefaultExportFromCjs(fragments);\n\n\tvar abstractCoder = createCommonjsModule(function (module, exports) {\n\t\"use strict\";\n\tObject.defineProperty(exports, \"__esModule\", { value: true });\n\texports.Reader = exports.Writer = exports.Coder = exports.checkResultErrors = void 0;\n\n\n\n\n\n\tvar logger = new lib.Logger(_version$8.version);\n\tfunction checkResultErrors(result) {\n\t    // Find the first error (if any)\n\t    var errors = [];\n\t    var checkErrors = function (path, object) {\n\t        if (!Array.isArray(object)) {\n\t            return;\n\t        }\n\t        for (var key in object) {\n\t            var childPath = path.slice();\n\t            childPath.push(key);\n\t            try {\n\t                checkErrors(childPath, object[key]);\n\t            }\n\t            catch (error) {\n\t                errors.push({ path: childPath, error: error });\n\t            }\n\t        }\n\t    };\n\t    checkErrors([], result);\n\t    return errors;\n\t}\n\texports.checkResultErrors = checkResultErrors;\n\tvar Coder = /** @class */ (function () {\n\t    function Coder(name, type, localName, dynamic) {\n\t        // @TODO: defineReadOnly these\n\t        this.name = name;\n\t        this.type = type;\n\t        this.localName = localName;\n\t        this.dynamic = dynamic;\n\t    }\n\t    Coder.prototype._throwError = function (message, value) {\n\t        logger.throwArgumentError(message, this.localName, value);\n\t    };\n\t    return Coder;\n\t}());\n\texports.Coder = Coder;\n\tvar Writer = /** @class */ (function () {\n\t    function Writer(wordSize) {\n\t        (0, lib$3.defineReadOnly)(this, \"wordSize\", wordSize || 32);\n\t        this._data = [];\n\t        this._dataLength = 0;\n\t        this._padding = new Uint8Array(wordSize);\n\t    }\n\t    Object.defineProperty(Writer.prototype, \"data\", {\n\t        get: function () {\n\t            return (0, lib$1.hexConcat)(this._data);\n\t        },\n\t        enumerable: false,\n\t        configurable: true\n\t    });\n\t    Object.defineProperty(Writer.prototype, \"length\", {\n\t        get: function () { return this._dataLength; },\n\t        enumerable: false,\n\t        configurable: true\n\t    });\n\t    Writer.prototype._writeData = function (data) {\n\t        this._data.push(data);\n\t        this._dataLength += data.length;\n\t        return data.length;\n\t    };\n\t    Writer.prototype.appendWriter = function (writer) {\n\t        return this._writeData((0, lib$1.concat)(writer._data));\n\t    };\n\t    // Arrayish items; padded on the right to wordSize\n\t    Writer.prototype.writeBytes = function (value) {\n\t        var bytes = (0, lib$1.arrayify)(value);\n\t        var paddingOffset = bytes.length % this.wordSize;\n\t        if (paddingOffset) {\n\t            bytes = (0, lib$1.concat)([bytes, this._padding.slice(paddingOffset)]);\n\t        }\n\t        return this._writeData(bytes);\n\t    };\n\t    Writer.prototype._getValue = function (value) {\n\t        var bytes = (0, lib$1.arrayify)(lib$2.BigNumber.from(value));\n\t        if (bytes.length > this.wordSize) {\n\t            logger.throwError(\"value out-of-bounds\", lib.Logger.errors.BUFFER_OVERRUN, {\n\t                length: this.wordSize,\n\t                offset: bytes.length\n\t            });\n\t        }\n\t        if (bytes.length % this.wordSize) {\n\t            bytes = (0, lib$1.concat)([this._padding.slice(bytes.length % this.wordSize), bytes]);\n\t        }\n\t        return bytes;\n\t    };\n\t    // BigNumberish items; padded on the left to wordSize\n\t    Writer.prototype.writeValue = function (value) {\n\t        return this._writeData(this._getValue(value));\n\t    };\n\t    Writer.prototype.writeUpdatableValue = function () {\n\t        var _this = this;\n\t        var offset = this._data.length;\n\t        this._data.push(this._padding);\n\t        this._dataLength += this.wordSize;\n\t        return function (value) {\n\t            _this._data[offset] = _this._getValue(value);\n\t        };\n\t    };\n\t    return Writer;\n\t}());\n\texports.Writer = Writer;\n\tvar Reader = /** @class */ (function () {\n\t    function Reader(data, wordSize, coerceFunc, allowLoose) {\n\t        (0, lib$3.defineReadOnly)(this, \"_data\", (0, lib$1.arrayify)(data));\n\t        (0, lib$3.defineReadOnly)(this, \"wordSize\", wordSize || 32);\n\t        (0, lib$3.defineReadOnly)(this, \"_coerceFunc\", coerceFunc);\n\t        (0, lib$3.defineReadOnly)(this, \"allowLoose\", allowLoose);\n\t        this._offset = 0;\n\t    }\n\t    Object.defineProperty(Reader.prototype, \"data\", {\n\t        get: function () { return (0, lib$1.hexlify)(this._data); },\n\t        enumerable: false,\n\t        configurable: true\n\t    });\n\t    Object.defineProperty(Reader.prototype, \"consumed\", {\n\t        get: function () { return this._offset; },\n\t        enumerable: false,\n\t        configurable: true\n\t    });\n\t    // The default Coerce function\n\t    Reader.coerce = function (name, value) {\n\t        var match = name.match(\"^u?int([0-9]+)$\");\n\t        if (match && parseInt(match[1]) <= 48) {\n\t            value = value.toNumber();\n\t        }\n\t        return value;\n\t    };\n\t    Reader.prototype.coerce = function (name, value) {\n\t        if (this._coerceFunc) {\n\t            return this._coerceFunc(name, value);\n\t        }\n\t        return Reader.coerce(name, value);\n\t    };\n\t    Reader.prototype._peekBytes = function (offset, length, loose) {\n\t        var alignedLength = Math.ceil(length / this.wordSize) * this.wordSize;\n\t        if (this._offset + alignedLength > this._data.length) {\n\t            if (this.allowLoose && loose && this._offset + length <= this._data.length) {\n\t                alignedLength = length;\n\t            }\n\t            else {\n\t                logger.throwError(\"data out-of-bounds\", lib.Logger.errors.BUFFER_OVERRUN, {\n\t                    length: this._data.length,\n\t                    offset: this._offset + alignedLength\n\t                });\n\t            }\n\t        }\n\t        return this._data.slice(this._offset, this._offset + alignedLength);\n\t    };\n\t    Reader.prototype.subReader = function (offset) {\n\t        return new Reader(this._data.slice(this._offset + offset), this.wordSize, this._coerceFunc, this.allowLoose);\n\t    };\n\t    Reader.prototype.readBytes = function (length, loose) {\n\t        var bytes = this._peekBytes(0, length, !!loose);\n\t        this._offset += bytes.length;\n\t        // @TODO: Make sure the length..end bytes are all 0?\n\t        return bytes.slice(0, length);\n\t    };\n\t    Reader.prototype.readValue = function () {\n\t        return lib$2.BigNumber.from(this.readBytes(this.wordSize));\n\t    };\n\t    return Reader;\n\t}());\n\texports.Reader = Reader;\n\n\t});\n\n\tvar abstractCoder$1 = /*@__PURE__*/getDefaultExportFromCjs(abstractCoder);\n\n\tvar sha3 = createCommonjsModule(function (module) {\n\t/**\n\t * [js-sha3]{@link https://github.com/emn178/js-sha3}\n\t *\n\t * @version 0.8.0\n\t * @author Chen, Yi-Cyuan [emn178@gmail.com]\n\t * @copyright Chen, Yi-Cyuan 2015-2018\n\t * @license MIT\n\t */\n\t/*jslint bitwise: true */\n\t(function () {\n\t  'use strict';\n\n\t  var INPUT_ERROR = 'input is invalid type';\n\t  var FINALIZE_ERROR = 'finalize already called';\n\t  var WINDOW = typeof window === 'object';\n\t  var root = WINDOW ? window : {};\n\t  if (root.JS_SHA3_NO_WINDOW) {\n\t    WINDOW = false;\n\t  }\n\t  var WEB_WORKER = !WINDOW && typeof self === 'object';\n\t  var NODE_JS = !root.JS_SHA3_NO_NODE_JS && typeof process === 'object' && process.versions && process.versions.node;\n\t  if (NODE_JS) {\n\t    root = commonjsGlobal;\n\t  } else if (WEB_WORKER) {\n\t    root = self;\n\t  }\n\t  var COMMON_JS = !root.JS_SHA3_NO_COMMON_JS && 'object' === 'object' && module.exports;\n\t  var AMD =  false && 0;\n\t  var ARRAY_BUFFER = !root.JS_SHA3_NO_ARRAY_BUFFER && typeof ArrayBuffer !== 'undefined';\n\t  var HEX_CHARS = '0123456789abcdef'.split('');\n\t  var SHAKE_PADDING = [31, 7936, 2031616, 520093696];\n\t  var CSHAKE_PADDING = [4, 1024, 262144, 67108864];\n\t  var KECCAK_PADDING = [1, 256, 65536, 16777216];\n\t  var PADDING = [6, 1536, 393216, 100663296];\n\t  var SHIFT = [0, 8, 16, 24];\n\t  var RC = [1, 0, 32898, 0, 32906, 2147483648, 2147516416, 2147483648, 32907, 0, 2147483649,\n\t    0, 2147516545, 2147483648, 32777, 2147483648, 138, 0, 136, 0, 2147516425, 0,\n\t    2147483658, 0, 2147516555, 0, 139, 2147483648, 32905, 2147483648, 32771,\n\t    2147483648, 32770, 2147483648, 128, 2147483648, 32778, 0, 2147483658, 2147483648,\n\t    2147516545, 2147483648, 32896, 2147483648, 2147483649, 0, 2147516424, 2147483648];\n\t  var BITS = [224, 256, 384, 512];\n\t  var SHAKE_BITS = [128, 256];\n\t  var OUTPUT_TYPES = ['hex', 'buffer', 'arrayBuffer', 'array', 'digest'];\n\t  var CSHAKE_BYTEPAD = {\n\t    '128': 168,\n\t    '256': 136\n\t  };\n\n\t  if (root.JS_SHA3_NO_NODE_JS || !Array.isArray) {\n\t    Array.isArray = function (obj) {\n\t      return Object.prototype.toString.call(obj) === '[object Array]';\n\t    };\n\t  }\n\n\t  if (ARRAY_BUFFER && (root.JS_SHA3_NO_ARRAY_BUFFER_IS_VIEW || !ArrayBuffer.isView)) {\n\t    ArrayBuffer.isView = function (obj) {\n\t      return typeof obj === 'object' && obj.buffer && obj.buffer.constructor === ArrayBuffer;\n\t    };\n\t  }\n\n\t  var createOutputMethod = function (bits, padding, outputType) {\n\t    return function (message) {\n\t      return new Keccak(bits, padding, bits).update(message)[outputType]();\n\t    };\n\t  };\n\n\t  var createShakeOutputMethod = function (bits, padding, outputType) {\n\t    return function (message, outputBits) {\n\t      return new Keccak(bits, padding, outputBits).update(message)[outputType]();\n\t    };\n\t  };\n\n\t  var createCshakeOutputMethod = function (bits, padding, outputType) {\n\t    return function (message, outputBits, n, s) {\n\t      return methods['cshake' + bits].update(message, outputBits, n, s)[outputType]();\n\t    };\n\t  };\n\n\t  var createKmacOutputMethod = function (bits, padding, outputType) {\n\t    return function (key, message, outputBits, s) {\n\t      return methods['kmac' + bits].update(key, message, outputBits, s)[outputType]();\n\t    };\n\t  };\n\n\t  var createOutputMethods = function (method, createMethod, bits, padding) {\n\t    for (var i = 0; i < OUTPUT_TYPES.length; ++i) {\n\t      var type = OUTPUT_TYPES[i];\n\t      method[type] = createMethod(bits, padding, type);\n\t    }\n\t    return method;\n\t  };\n\n\t  var createMethod = function (bits, padding) {\n\t    var method = createOutputMethod(bits, padding, 'hex');\n\t    method.create = function () {\n\t      return new Keccak(bits, padding, bits);\n\t    };\n\t    method.update = function (message) {\n\t      return method.create().update(message);\n\t    };\n\t    return createOutputMethods(method, createOutputMethod, bits, padding);\n\t  };\n\n\t  var createShakeMethod = function (bits, padding) {\n\t    var method = createShakeOutputMethod(bits, padding, 'hex');\n\t    method.create = function (outputBits) {\n\t      return new Keccak(bits, padding, outputBits);\n\t    };\n\t    method.update = function (message, outputBits) {\n\t      return method.create(outputBits).update(message);\n\t    };\n\t    return createOutputMethods(method, createShakeOutputMethod, bits, padding);\n\t  };\n\n\t  var createCshakeMethod = function (bits, padding) {\n\t    var w = CSHAKE_BYTEPAD[bits];\n\t    var method = createCshakeOutputMethod(bits, padding, 'hex');\n\t    method.create = function (outputBits, n, s) {\n\t      if (!n && !s) {\n\t        return methods['shake' + bits].create(outputBits);\n\t      } else {\n\t        return new Keccak(bits, padding, outputBits).bytepad([n, s], w);\n\t      }\n\t    };\n\t    method.update = function (message, outputBits, n, s) {\n\t      return method.create(outputBits, n, s).update(message);\n\t    };\n\t    return createOutputMethods(method, createCshakeOutputMethod, bits, padding);\n\t  };\n\n\t  var createKmacMethod = function (bits, padding) {\n\t    var w = CSHAKE_BYTEPAD[bits];\n\t    var method = createKmacOutputMethod(bits, padding, 'hex');\n\t    method.create = function (key, outputBits, s) {\n\t      return new Kmac(bits, padding, outputBits).bytepad(['KMAC', s], w).bytepad([key], w);\n\t    };\n\t    method.update = function (key, message, outputBits, s) {\n\t      return method.create(key, outputBits, s).update(message);\n\t    };\n\t    return createOutputMethods(method, createKmacOutputMethod, bits, padding);\n\t  };\n\n\t  var algorithms = [\n\t    { name: 'keccak', padding: KECCAK_PADDING, bits: BITS, createMethod: createMethod },\n\t    { name: 'sha3', padding: PADDING, bits: BITS, createMethod: createMethod },\n\t    { name: 'shake', padding: SHAKE_PADDING, bits: SHAKE_BITS, createMethod: createShakeMethod },\n\t    { name: 'cshake', padding: CSHAKE_PADDING, bits: SHAKE_BITS, createMethod: createCshakeMethod },\n\t    { name: 'kmac', padding: CSHAKE_PADDING, bits: SHAKE_BITS, createMethod: createKmacMethod }\n\t  ];\n\n\t  var methods = {}, methodNames = [];\n\n\t  for (var i = 0; i < algorithms.length; ++i) {\n\t    var algorithm = algorithms[i];\n\t    var bits = algorithm.bits;\n\t    for (var j = 0; j < bits.length; ++j) {\n\t      var methodName = algorithm.name + '_' + bits[j];\n\t      methodNames.push(methodName);\n\t      methods[methodName] = algorithm.createMethod(bits[j], algorithm.padding);\n\t      if (algorithm.name !== 'sha3') {\n\t        var newMethodName = algorithm.name + bits[j];\n\t        methodNames.push(newMethodName);\n\t        methods[newMethodName] = methods[methodName];\n\t      }\n\t    }\n\t  }\n\n\t  function Keccak(bits, padding, outputBits) {\n\t    this.blocks = [];\n\t    this.s = [];\n\t    this.padding = padding;\n\t    this.outputBits = outputBits;\n\t    this.reset = true;\n\t    this.finalized = false;\n\t    this.block = 0;\n\t    this.start = 0;\n\t    this.blockCount = (1600 - (bits << 1)) >> 5;\n\t    this.byteCount = this.blockCount << 2;\n\t    this.outputBlocks = outputBits >> 5;\n\t    this.extraBytes = (outputBits & 31) >> 3;\n\n\t    for (var i = 0; i < 50; ++i) {\n\t      this.s[i] = 0;\n\t    }\n\t  }\n\n\t  Keccak.prototype.update = function (message) {\n\t    if (this.finalized) {\n\t      throw new Error(FINALIZE_ERROR);\n\t    }\n\t    var notString, type = typeof message;\n\t    if (type !== 'string') {\n\t      if (type === 'object') {\n\t        if (message === null) {\n\t          throw new Error(INPUT_ERROR);\n\t        } else if (ARRAY_BUFFER && message.constructor === ArrayBuffer) {\n\t          message = new Uint8Array(message);\n\t        } else if (!Array.isArray(message)) {\n\t          if (!ARRAY_BUFFER || !ArrayBuffer.isView(message)) {\n\t            throw new Error(INPUT_ERROR);\n\t          }\n\t        }\n\t      } else {\n\t        throw new Error(INPUT_ERROR);\n\t      }\n\t      notString = true;\n\t    }\n\t    var blocks = this.blocks, byteCount = this.byteCount, length = message.length,\n\t      blockCount = this.blockCount, index = 0, s = this.s, i, code;\n\n\t    while (index < length) {\n\t      if (this.reset) {\n\t        this.reset = false;\n\t        blocks[0] = this.block;\n\t        for (i = 1; i < blockCount + 1; ++i) {\n\t          blocks[i] = 0;\n\t        }\n\t      }\n\t      if (notString) {\n\t        for (i = this.start; index < length && i < byteCount; ++index) {\n\t          blocks[i >> 2] |= message[index] << SHIFT[i++ & 3];\n\t        }\n\t      } else {\n\t        for (i = this.start; index < length && i < byteCount; ++index) {\n\t          code = message.charCodeAt(index);\n\t          if (code < 0x80) {\n\t            blocks[i >> 2] |= code << SHIFT[i++ & 3];\n\t          } else if (code < 0x800) {\n\t            blocks[i >> 2] |= (0xc0 | (code >> 6)) << SHIFT[i++ & 3];\n\t            blocks[i >> 2] |= (0x80 | (code & 0x3f)) << SHIFT[i++ & 3];\n\t          } else if (code < 0xd800 || code >= 0xe000) {\n\t            blocks[i >> 2] |= (0xe0 | (code >> 12)) << SHIFT[i++ & 3];\n\t            blocks[i >> 2] |= (0x80 | ((code >> 6) & 0x3f)) << SHIFT[i++ & 3];\n\t            blocks[i >> 2] |= (0x80 | (code & 0x3f)) << SHIFT[i++ & 3];\n\t          } else {\n\t            code = 0x10000 + (((code & 0x3ff) << 10) | (message.charCodeAt(++index) & 0x3ff));\n\t            blocks[i >> 2] |= (0xf0 | (code >> 18)) << SHIFT[i++ & 3];\n\t            blocks[i >> 2] |= (0x80 | ((code >> 12) & 0x3f)) << SHIFT[i++ & 3];\n\t            blocks[i >> 2] |= (0x80 | ((code >> 6) & 0x3f)) << SHIFT[i++ & 3];\n\t            blocks[i >> 2] |= (0x80 | (code & 0x3f)) << SHIFT[i++ & 3];\n\t          }\n\t        }\n\t      }\n\t      this.lastByteIndex = i;\n\t      if (i >= byteCount) {\n\t        this.start = i - byteCount;\n\t        this.block = blocks[blockCount];\n\t        for (i = 0; i < blockCount; ++i) {\n\t          s[i] ^= blocks[i];\n\t        }\n\t        f(s);\n\t        this.reset = true;\n\t      } else {\n\t        this.start = i;\n\t      }\n\t    }\n\t    return this;\n\t  };\n\n\t  Keccak.prototype.encode = function (x, right) {\n\t    var o = x & 255, n = 1;\n\t    var bytes = [o];\n\t    x = x >> 8;\n\t    o = x & 255;\n\t    while (o > 0) {\n\t      bytes.unshift(o);\n\t      x = x >> 8;\n\t      o = x & 255;\n\t      ++n;\n\t    }\n\t    if (right) {\n\t      bytes.push(n);\n\t    } else {\n\t      bytes.unshift(n);\n\t    }\n\t    this.update(bytes);\n\t    return bytes.length;\n\t  };\n\n\t  Keccak.prototype.encodeString = function (str) {\n\t    var notString, type = typeof str;\n\t    if (type !== 'string') {\n\t      if (type === 'object') {\n\t        if (str === null) {\n\t          throw new Error(INPUT_ERROR);\n\t        } else if (ARRAY_BUFFER && str.constructor === ArrayBuffer) {\n\t          str = new Uint8Array(str);\n\t        } else if (!Array.isArray(str)) {\n\t          if (!ARRAY_BUFFER || !ArrayBuffer.isView(str)) {\n\t            throw new Error(INPUT_ERROR);\n\t          }\n\t        }\n\t      } else {\n\t        throw new Error(INPUT_ERROR);\n\t      }\n\t      notString = true;\n\t    }\n\t    var bytes = 0, length = str.length;\n\t    if (notString) {\n\t      bytes = length;\n\t    } else {\n\t      for (var i = 0; i < str.length; ++i) {\n\t        var code = str.charCodeAt(i);\n\t        if (code < 0x80) {\n\t          bytes += 1;\n\t        } else if (code < 0x800) {\n\t          bytes += 2;\n\t        } else if (code < 0xd800 || code >= 0xe000) {\n\t          bytes += 3;\n\t        } else {\n\t          code = 0x10000 + (((code & 0x3ff) << 10) | (str.charCodeAt(++i) & 0x3ff));\n\t          bytes += 4;\n\t        }\n\t      }\n\t    }\n\t    bytes += this.encode(bytes * 8);\n\t    this.update(str);\n\t    return bytes;\n\t  };\n\n\t  Keccak.prototype.bytepad = function (strs, w) {\n\t    var bytes = this.encode(w);\n\t    for (var i = 0; i < strs.length; ++i) {\n\t      bytes += this.encodeString(strs[i]);\n\t    }\n\t    var paddingBytes = w - bytes % w;\n\t    var zeros = [];\n\t    zeros.length = paddingBytes;\n\t    this.update(zeros);\n\t    return this;\n\t  };\n\n\t  Keccak.prototype.finalize = function () {\n\t    if (this.finalized) {\n\t      return;\n\t    }\n\t    this.finalized = true;\n\t    var blocks = this.blocks, i = this.lastByteIndex, blockCount = this.blockCount, s = this.s;\n\t    blocks[i >> 2] |= this.padding[i & 3];\n\t    if (this.lastByteIndex === this.byteCount) {\n\t      blocks[0] = blocks[blockCount];\n\t      for (i = 1; i < blockCount + 1; ++i) {\n\t        blocks[i] = 0;\n\t      }\n\t    }\n\t    blocks[blockCount - 1] |= 0x80000000;\n\t    for (i = 0; i < blockCount; ++i) {\n\t      s[i] ^= blocks[i];\n\t    }\n\t    f(s);\n\t  };\n\n\t  Keccak.prototype.toString = Keccak.prototype.hex = function () {\n\t    this.finalize();\n\n\t    var blockCount = this.blockCount, s = this.s, outputBlocks = this.outputBlocks,\n\t      extraBytes = this.extraBytes, i = 0, j = 0;\n\t    var hex = '', block;\n\t    while (j < outputBlocks) {\n\t      for (i = 0; i < blockCount && j < outputBlocks; ++i, ++j) {\n\t        block = s[i];\n\t        hex += HEX_CHARS[(block >> 4) & 0x0F] + HEX_CHARS[block & 0x0F] +\n\t          HEX_CHARS[(block >> 12) & 0x0F] + HEX_CHARS[(block >> 8) & 0x0F] +\n\t          HEX_CHARS[(block >> 20) & 0x0F] + HEX_CHARS[(block >> 16) & 0x0F] +\n\t          HEX_CHARS[(block >> 28) & 0x0F] + HEX_CHARS[(block >> 24) & 0x0F];\n\t      }\n\t      if (j % blockCount === 0) {\n\t        f(s);\n\t        i = 0;\n\t      }\n\t    }\n\t    if (extraBytes) {\n\t      block = s[i];\n\t      hex += HEX_CHARS[(block >> 4) & 0x0F] + HEX_CHARS[block & 0x0F];\n\t      if (extraBytes > 1) {\n\t        hex += HEX_CHARS[(block >> 12) & 0x0F] + HEX_CHARS[(block >> 8) & 0x0F];\n\t      }\n\t      if (extraBytes > 2) {\n\t        hex += HEX_CHARS[(block >> 20) & 0x0F] + HEX_CHARS[(block >> 16) & 0x0F];\n\t      }\n\t    }\n\t    return hex;\n\t  };\n\n\t  Keccak.prototype.arrayBuffer = function () {\n\t    this.finalize();\n\n\t    var blockCount = this.blockCount, s = this.s, outputBlocks = this.outputBlocks,\n\t      extraBytes = this.extraBytes, i = 0, j = 0;\n\t    var bytes = this.outputBits >> 3;\n\t    var buffer;\n\t    if (extraBytes) {\n\t      buffer = new ArrayBuffer((outputBlocks + 1) << 2);\n\t    } else {\n\t      buffer = new ArrayBuffer(bytes);\n\t    }\n\t    var array = new Uint32Array(buffer);\n\t    while (j < outputBlocks) {\n\t      for (i = 0; i < blockCount && j < outputBlocks; ++i, ++j) {\n\t        array[j] = s[i];\n\t      }\n\t      if (j % blockCount === 0) {\n\t        f(s);\n\t      }\n\t    }\n\t    if (extraBytes) {\n\t      array[i] = s[i];\n\t      buffer = buffer.slice(0, bytes);\n\t    }\n\t    return buffer;\n\t  };\n\n\t  Keccak.prototype.buffer = Keccak.prototype.arrayBuffer;\n\n\t  Keccak.prototype.digest = Keccak.prototype.array = function () {\n\t    this.finalize();\n\n\t    var blockCount = this.blockCount, s = this.s, outputBlocks = this.outputBlocks,\n\t      extraBytes = this.extraBytes, i = 0, j = 0;\n\t    var array = [], offset, block;\n\t    while (j < outputBlocks) {\n\t      for (i = 0; i < blockCount && j < outputBlocks; ++i, ++j) {\n\t        offset = j << 2;\n\t        block = s[i];\n\t        array[offset] = block & 0xFF;\n\t        array[offset + 1] = (block >> 8) & 0xFF;\n\t        array[offset + 2] = (block >> 16) & 0xFF;\n\t        array[offset + 3] = (block >> 24) & 0xFF;\n\t      }\n\t      if (j % blockCount === 0) {\n\t        f(s);\n\t      }\n\t    }\n\t    if (extraBytes) {\n\t      offset = j << 2;\n\t      block = s[i];\n\t      array[offset] = block & 0xFF;\n\t      if (extraBytes > 1) {\n\t        array[offset + 1] = (block >> 8) & 0xFF;\n\t      }\n\t      if (extraBytes > 2) {\n\t        array[offset + 2] = (block >> 16) & 0xFF;\n\t      }\n\t    }\n\t    return array;\n\t  };\n\n\t  function Kmac(bits, padding, outputBits) {\n\t    Keccak.call(this, bits, padding, outputBits);\n\t  }\n\n\t  Kmac.prototype = new Keccak();\n\n\t  Kmac.prototype.finalize = function () {\n\t    this.encode(this.outputBits, true);\n\t    return Keccak.prototype.finalize.call(this);\n\t  };\n\n\t  var f = function (s) {\n\t    var h, l, n, c0, c1, c2, c3, c4, c5, c6, c7, c8, c9,\n\t      b0, b1, b2, b3, b4, b5, b6, b7, b8, b9, b10, b11, b12, b13, b14, b15, b16, b17,\n\t      b18, b19, b20, b21, b22, b23, b24, b25, b26, b27, b28, b29, b30, b31, b32, b33,\n\t      b34, b35, b36, b37, b38, b39, b40, b41, b42, b43, b44, b45, b46, b47, b48, b49;\n\t    for (n = 0; n < 48; n += 2) {\n\t      c0 = s[0] ^ s[10] ^ s[20] ^ s[30] ^ s[40];\n\t      c1 = s[1] ^ s[11] ^ s[21] ^ s[31] ^ s[41];\n\t      c2 = s[2] ^ s[12] ^ s[22] ^ s[32] ^ s[42];\n\t      c3 = s[3] ^ s[13] ^ s[23] ^ s[33] ^ s[43];\n\t      c4 = s[4] ^ s[14] ^ s[24] ^ s[34] ^ s[44];\n\t      c5 = s[5] ^ s[15] ^ s[25] ^ s[35] ^ s[45];\n\t      c6 = s[6] ^ s[16] ^ s[26] ^ s[36] ^ s[46];\n\t      c7 = s[7] ^ s[17] ^ s[27] ^ s[37] ^ s[47];\n\t      c8 = s[8] ^ s[18] ^ s[28] ^ s[38] ^ s[48];\n\t      c9 = s[9] ^ s[19] ^ s[29] ^ s[39] ^ s[49];\n\n\t      h = c8 ^ ((c2 << 1) | (c3 >>> 31));\n\t      l = c9 ^ ((c3 << 1) | (c2 >>> 31));\n\t      s[0] ^= h;\n\t      s[1] ^= l;\n\t      s[10] ^= h;\n\t      s[11] ^= l;\n\t      s[20] ^= h;\n\t      s[21] ^= l;\n\t      s[30] ^= h;\n\t      s[31] ^= l;\n\t      s[40] ^= h;\n\t      s[41] ^= l;\n\t      h = c0 ^ ((c4 << 1) | (c5 >>> 31));\n\t      l = c1 ^ ((c5 << 1) | (c4 >>> 31));\n\t      s[2] ^= h;\n\t      s[3] ^= l;\n\t      s[12] ^= h;\n\t      s[13] ^= l;\n\t      s[22] ^= h;\n\t      s[23] ^= l;\n\t      s[32] ^= h;\n\t      s[33] ^= l;\n\t      s[42] ^= h;\n\t      s[43] ^= l;\n\t      h = c2 ^ ((c6 << 1) | (c7 >>> 31));\n\t      l = c3 ^ ((c7 << 1) | (c6 >>> 31));\n\t      s[4] ^= h;\n\t      s[5] ^= l;\n\t      s[14] ^= h;\n\t      s[15] ^= l;\n\t      s[24] ^= h;\n\t      s[25] ^= l;\n\t      s[34] ^= h;\n\t      s[35] ^= l;\n\t      s[44] ^= h;\n\t      s[45] ^= l;\n\t      h = c4 ^ ((c8 << 1) | (c9 >>> 31));\n\t      l = c5 ^ ((c9 << 1) | (c8 >>> 31));\n\t      s[6] ^= h;\n\t      s[7] ^= l;\n\t      s[16] ^= h;\n\t      s[17] ^= l;\n\t      s[26] ^= h;\n\t      s[27] ^= l;\n\t      s[36] ^= h;\n\t      s[37] ^= l;\n\t      s[46] ^= h;\n\t      s[47] ^= l;\n\t      h = c6 ^ ((c0 << 1) | (c1 >>> 31));\n\t      l = c7 ^ ((c1 << 1) | (c0 >>> 31));\n\t      s[8] ^= h;\n\t      s[9] ^= l;\n\t      s[18] ^= h;\n\t      s[19] ^= l;\n\t      s[28] ^= h;\n\t      s[29] ^= l;\n\t      s[38] ^= h;\n\t      s[39] ^= l;\n\t      s[48] ^= h;\n\t      s[49] ^= l;\n\n\t      b0 = s[0];\n\t      b1 = s[1];\n\t      b32 = (s[11] << 4) | (s[10] >>> 28);\n\t      b33 = (s[10] << 4) | (s[11] >>> 28);\n\t      b14 = (s[20] << 3) | (s[21] >>> 29);\n\t      b15 = (s[21] << 3) | (s[20] >>> 29);\n\t      b46 = (s[31] << 9) | (s[30] >>> 23);\n\t      b47 = (s[30] << 9) | (s[31] >>> 23);\n\t      b28 = (s[40] << 18) | (s[41] >>> 14);\n\t      b29 = (s[41] << 18) | (s[40] >>> 14);\n\t      b20 = (s[2] << 1) | (s[3] >>> 31);\n\t      b21 = (s[3] << 1) | (s[2] >>> 31);\n\t      b2 = (s[13] << 12) | (s[12] >>> 20);\n\t      b3 = (s[12] << 12) | (s[13] >>> 20);\n\t      b34 = (s[22] << 10) | (s[23] >>> 22);\n\t      b35 = (s[23] << 10) | (s[22] >>> 22);\n\t      b16 = (s[33] << 13) | (s[32] >>> 19);\n\t      b17 = (s[32] << 13) | (s[33] >>> 19);\n\t      b48 = (s[42] << 2) | (s[43] >>> 30);\n\t      b49 = (s[43] << 2) | (s[42] >>> 30);\n\t      b40 = (s[5] << 30) | (s[4] >>> 2);\n\t      b41 = (s[4] << 30) | (s[5] >>> 2);\n\t      b22 = (s[14] << 6) | (s[15] >>> 26);\n\t      b23 = (s[15] << 6) | (s[14] >>> 26);\n\t      b4 = (s[25] << 11) | (s[24] >>> 21);\n\t      b5 = (s[24] << 11) | (s[25] >>> 21);\n\t      b36 = (s[34] << 15) | (s[35] >>> 17);\n\t      b37 = (s[35] << 15) | (s[34] >>> 17);\n\t      b18 = (s[45] << 29) | (s[44] >>> 3);\n\t      b19 = (s[44] << 29) | (s[45] >>> 3);\n\t      b10 = (s[6] << 28) | (s[7] >>> 4);\n\t      b11 = (s[7] << 28) | (s[6] >>> 4);\n\t      b42 = (s[17] << 23) | (s[16] >>> 9);\n\t      b43 = (s[16] << 23) | (s[17] >>> 9);\n\t      b24 = (s[26] << 25) | (s[27] >>> 7);\n\t      b25 = (s[27] << 25) | (s[26] >>> 7);\n\t      b6 = (s[36] << 21) | (s[37] >>> 11);\n\t      b7 = (s[37] << 21) | (s[36] >>> 11);\n\t      b38 = (s[47] << 24) | (s[46] >>> 8);\n\t      b39 = (s[46] << 24) | (s[47] >>> 8);\n\t      b30 = (s[8] << 27) | (s[9] >>> 5);\n\t      b31 = (s[9] << 27) | (s[8] >>> 5);\n\t      b12 = (s[18] << 20) | (s[19] >>> 12);\n\t      b13 = (s[19] << 20) | (s[18] >>> 12);\n\t      b44 = (s[29] << 7) | (s[28] >>> 25);\n\t      b45 = (s[28] << 7) | (s[29] >>> 25);\n\t      b26 = (s[38] << 8) | (s[39] >>> 24);\n\t      b27 = (s[39] << 8) | (s[38] >>> 24);\n\t      b8 = (s[48] << 14) | (s[49] >>> 18);\n\t      b9 = (s[49] << 14) | (s[48] >>> 18);\n\n\t      s[0] = b0 ^ (~b2 & b4);\n\t      s[1] = b1 ^ (~b3 & b5);\n\t      s[10] = b10 ^ (~b12 & b14);\n\t      s[11] = b11 ^ (~b13 & b15);\n\t      s[20] = b20 ^ (~b22 & b24);\n\t      s[21] = b21 ^ (~b23 & b25);\n\t      s[30] = b30 ^ (~b32 & b34);\n\t      s[31] = b31 ^ (~b33 & b35);\n\t      s[40] = b40 ^ (~b42 & b44);\n\t      s[41] = b41 ^ (~b43 & b45);\n\t      s[2] = b2 ^ (~b4 & b6);\n\t      s[3] = b3 ^ (~b5 & b7);\n\t      s[12] = b12 ^ (~b14 & b16);\n\t      s[13] = b13 ^ (~b15 & b17);\n\t      s[22] = b22 ^ (~b24 & b26);\n\t      s[23] = b23 ^ (~b25 & b27);\n\t      s[32] = b32 ^ (~b34 & b36);\n\t      s[33] = b33 ^ (~b35 & b37);\n\t      s[42] = b42 ^ (~b44 & b46);\n\t      s[43] = b43 ^ (~b45 & b47);\n\t      s[4] = b4 ^ (~b6 & b8);\n\t      s[5] = b5 ^ (~b7 & b9);\n\t      s[14] = b14 ^ (~b16 & b18);\n\t      s[15] = b15 ^ (~b17 & b19);\n\t      s[24] = b24 ^ (~b26 & b28);\n\t      s[25] = b25 ^ (~b27 & b29);\n\t      s[34] = b34 ^ (~b36 & b38);\n\t      s[35] = b35 ^ (~b37 & b39);\n\t      s[44] = b44 ^ (~b46 & b48);\n\t      s[45] = b45 ^ (~b47 & b49);\n\t      s[6] = b6 ^ (~b8 & b0);\n\t      s[7] = b7 ^ (~b9 & b1);\n\t      s[16] = b16 ^ (~b18 & b10);\n\t      s[17] = b17 ^ (~b19 & b11);\n\t      s[26] = b26 ^ (~b28 & b20);\n\t      s[27] = b27 ^ (~b29 & b21);\n\t      s[36] = b36 ^ (~b38 & b30);\n\t      s[37] = b37 ^ (~b39 & b31);\n\t      s[46] = b46 ^ (~b48 & b40);\n\t      s[47] = b47 ^ (~b49 & b41);\n\t      s[8] = b8 ^ (~b0 & b2);\n\t      s[9] = b9 ^ (~b1 & b3);\n\t      s[18] = b18 ^ (~b10 & b12);\n\t      s[19] = b19 ^ (~b11 & b13);\n\t      s[28] = b28 ^ (~b20 & b22);\n\t      s[29] = b29 ^ (~b21 & b23);\n\t      s[38] = b38 ^ (~b30 & b32);\n\t      s[39] = b39 ^ (~b31 & b33);\n\t      s[48] = b48 ^ (~b40 & b42);\n\t      s[49] = b49 ^ (~b41 & b43);\n\n\t      s[0] ^= RC[n];\n\t      s[1] ^= RC[n + 1];\n\t    }\n\t  };\n\n\t  if (COMMON_JS) {\n\t    module.exports = methods;\n\t  } else {\n\t    for (i = 0; i < methodNames.length; ++i) {\n\t      root[methodNames[i]] = methods[methodNames[i]];\n\t    }\n\t    if (AMD) {\n\t      undefined(function () {\n\t        return methods;\n\t      });\n\t    }\n\t  }\n\t})();\n\t});\n\n\tvar lib$4 = createCommonjsModule(function (module, exports) {\n\t\"use strict\";\n\tvar __importDefault = (commonjsGlobal && commonjsGlobal.__importDefault) || function (mod) {\n\t    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n\t};\n\tObject.defineProperty(exports, \"__esModule\", { value: true });\n\texports.keccak256 = void 0;\n\tvar js_sha3_1 = __importDefault(sha3);\n\n\tfunction keccak256(data) {\n\t    return '0x' + js_sha3_1.default.keccak_256((0, lib$1.arrayify)(data));\n\t}\n\texports.keccak256 = keccak256;\n\n\t});\n\n\tvar index$4 = /*@__PURE__*/getDefaultExportFromCjs(lib$4);\n\n\tvar _version$a = createCommonjsModule(function (module, exports) {\n\t\"use strict\";\n\tObject.defineProperty(exports, \"__esModule\", { value: true });\n\texports.version = void 0;\n\texports.version = \"rlp/5.5.0\";\n\n\t});\n\n\tvar _version$b = /*@__PURE__*/getDefaultExportFromCjs(_version$a);\n\n\tvar lib$5 = createCommonjsModule(function (module, exports) {\n\t\"use strict\";\n\tObject.defineProperty(exports, \"__esModule\", { value: true });\n\texports.decode = exports.encode = void 0;\n\t//See: https://github.com/ethereum/wiki/wiki/RLP\n\n\n\n\tvar logger = new lib.Logger(_version$a.version);\n\tfunction arrayifyInteger(value) {\n\t    var result = [];\n\t    while (value) {\n\t        result.unshift(value & 0xff);\n\t        value >>= 8;\n\t    }\n\t    return result;\n\t}\n\tfunction unarrayifyInteger(data, offset, length) {\n\t    var result = 0;\n\t    for (var i = 0; i < length; i++) {\n\t        result = (result * 256) + data[offset + i];\n\t    }\n\t    return result;\n\t}\n\tfunction _encode(object) {\n\t    if (Array.isArray(object)) {\n\t        var payload_1 = [];\n\t        object.forEach(function (child) {\n\t            payload_1 = payload_1.concat(_encode(child));\n\t        });\n\t        if (payload_1.length <= 55) {\n\t            payload_1.unshift(0xc0 + payload_1.length);\n\t            return payload_1;\n\t        }\n\t        var length_1 = arrayifyInteger(payload_1.length);\n\t        length_1.unshift(0xf7 + length_1.length);\n\t        return length_1.concat(payload_1);\n\t    }\n\t    if (!(0, lib$1.isBytesLike)(object)) {\n\t        logger.throwArgumentError(\"RLP object must be BytesLike\", \"object\", object);\n\t    }\n\t    var data = Array.prototype.slice.call((0, lib$1.arrayify)(object));\n\t    if (data.length === 1 && data[0] <= 0x7f) {\n\t        return data;\n\t    }\n\t    else if (data.length <= 55) {\n\t        data.unshift(0x80 + data.length);\n\t        return data;\n\t    }\n\t    var length = arrayifyInteger(data.length);\n\t    length.unshift(0xb7 + length.length);\n\t    return length.concat(data);\n\t}\n\tfunction encode(object) {\n\t    return (0, lib$1.hexlify)(_encode(object));\n\t}\n\texports.encode = encode;\n\tfunction _decodeChildren(data, offset, childOffset, length) {\n\t    var result = [];\n\t    while (childOffset < offset + 1 + length) {\n\t        var decoded = _decode(data, childOffset);\n\t        result.push(decoded.result);\n\t        childOffset += decoded.consumed;\n\t        if (childOffset > offset + 1 + length) {\n\t            logger.throwError(\"child data too short\", lib.Logger.errors.BUFFER_OVERRUN, {});\n\t        }\n\t    }\n\t    return { consumed: (1 + length), result: result };\n\t}\n\t// returns { consumed: number, result: Object }\n\tfunction _decode(data, offset) {\n\t    if (data.length === 0) {\n\t        logger.throwError(\"data too short\", lib.Logger.errors.BUFFER_OVERRUN, {});\n\t    }\n\t    // Array with extra length prefix\n\t    if (data[offset] >= 0xf8) {\n\t        var lengthLength = data[offset] - 0xf7;\n\t        if (offset + 1 + lengthLength > data.length) {\n\t            logger.throwError(\"data short segment too short\", lib.Logger.errors.BUFFER_OVERRUN, {});\n\t        }\n\t        var length_2 = unarrayifyInteger(data, offset + 1, lengthLength);\n\t        if (offset + 1 + lengthLength + length_2 > data.length) {\n\t            logger.throwError(\"data long segment too short\", lib.Logger.errors.BUFFER_OVERRUN, {});\n\t        }\n\t        return _decodeChildren(data, offset, offset + 1 + lengthLength, lengthLength + length_2);\n\t    }\n\t    else if (data[offset] >= 0xc0) {\n\t        var length_3 = data[offset] - 0xc0;\n\t        if (offset + 1 + length_3 > data.length) {\n\t            logger.throwError(\"data array too short\", lib.Logger.errors.BUFFER_OVERRUN, {});\n\t        }\n\t        return _decodeChildren(data, offset, offset + 1, length_3);\n\t    }\n\t    else if (data[offset] >= 0xb8) {\n\t        var lengthLength = data[offset] - 0xb7;\n\t        if (offset + 1 + lengthLength > data.length) {\n\t            logger.throwError(\"data array too short\", lib.Logger.errors.BUFFER_OVERRUN, {});\n\t        }\n\t        var length_4 = unarrayifyInteger(data, offset + 1, lengthLength);\n\t        if (offset + 1 + lengthLength + length_4 > data.length) {\n\t            logger.throwError(\"data array too short\", lib.Logger.errors.BUFFER_OVERRUN, {});\n\t        }\n\t        var result = (0, lib$1.hexlify)(data.slice(offset + 1 + lengthLength, offset + 1 + lengthLength + length_4));\n\t        return { consumed: (1 + lengthLength + length_4), result: result };\n\t    }\n\t    else if (data[offset] >= 0x80) {\n\t        var length_5 = data[offset] - 0x80;\n\t        if (offset + 1 + length_5 > data.length) {\n\t            logger.throwError(\"data too short\", lib.Logger.errors.BUFFER_OVERRUN, {});\n\t        }\n\t        var result = (0, lib$1.hexlify)(data.slice(offset + 1, offset + 1 + length_5));\n\t        return { consumed: (1 + length_5), result: result };\n\t    }\n\t    return { consumed: 1, result: (0, lib$1.hexlify)(data[offset]) };\n\t}\n\tfunction decode(data) {\n\t    var bytes = (0, lib$1.arrayify)(data);\n\t    var decoded = _decode(bytes, 0);\n\t    if (decoded.consumed !== bytes.length) {\n\t        logger.throwArgumentError(\"invalid rlp data\", \"data\", data);\n\t    }\n\t    return decoded.result;\n\t}\n\texports.decode = decode;\n\n\t});\n\n\tvar index$5 = /*@__PURE__*/getDefaultExportFromCjs(lib$5);\n\n\tvar _version$c = createCommonjsModule(function (module, exports) {\n\t\"use strict\";\n\tObject.defineProperty(exports, \"__esModule\", { value: true });\n\texports.version = void 0;\n\texports.version = \"address/5.5.0\";\n\n\t});\n\n\tvar _version$d = /*@__PURE__*/getDefaultExportFromCjs(_version$c);\n\n\tvar lib$6 = createCommonjsModule(function (module, exports) {\n\t\"use strict\";\n\tObject.defineProperty(exports, \"__esModule\", { value: true });\n\texports.getCreate2Address = exports.getContractAddress = exports.getIcapAddress = exports.isAddress = exports.getAddress = void 0;\n\n\n\n\n\n\n\tvar logger = new lib.Logger(_version$c.version);\n\tfunction getChecksumAddress(address) {\n\t    if (!(0, lib$1.isHexString)(address, 20)) {\n\t        logger.throwArgumentError(\"invalid address\", \"address\", address);\n\t    }\n\t    address = address.toLowerCase();\n\t    var chars = address.substring(2).split(\"\");\n\t    var expanded = new Uint8Array(40);\n\t    for (var i = 0; i < 40; i++) {\n\t        expanded[i] = chars[i].charCodeAt(0);\n\t    }\n\t    var hashed = (0, lib$1.arrayify)((0, lib$4.keccak256)(expanded));\n\t    for (var i = 0; i < 40; i += 2) {\n\t        if ((hashed[i >> 1] >> 4) >= 8) {\n\t            chars[i] = chars[i].toUpperCase();\n\t        }\n\t        if ((hashed[i >> 1] & 0x0f) >= 8) {\n\t            chars[i + 1] = chars[i + 1].toUpperCase();\n\t        }\n\t    }\n\t    return \"0x\" + chars.join(\"\");\n\t}\n\t// Shims for environments that are missing some required constants and functions\n\tvar MAX_SAFE_INTEGER = 0x1fffffffffffff;\n\tfunction log10(x) {\n\t    if (Math.log10) {\n\t        return Math.log10(x);\n\t    }\n\t    return Math.log(x) / Math.LN10;\n\t}\n\t// See: https://en.wikipedia.org/wiki/International_Bank_Account_Number\n\t// Create lookup table\n\tvar ibanLookup = {};\n\tfor (var i = 0; i < 10; i++) {\n\t    ibanLookup[String(i)] = String(i);\n\t}\n\tfor (var i = 0; i < 26; i++) {\n\t    ibanLookup[String.fromCharCode(65 + i)] = String(10 + i);\n\t}\n\t// How many decimal digits can we process? (for 64-bit float, this is 15)\n\tvar safeDigits = Math.floor(log10(MAX_SAFE_INTEGER));\n\tfunction ibanChecksum(address) {\n\t    address = address.toUpperCase();\n\t    address = address.substring(4) + address.substring(0, 2) + \"00\";\n\t    var expanded = address.split(\"\").map(function (c) { return ibanLookup[c]; }).join(\"\");\n\t    // Javascript can handle integers safely up to 15 (decimal) digits\n\t    while (expanded.length >= safeDigits) {\n\t        var block = expanded.substring(0, safeDigits);\n\t        expanded = parseInt(block, 10) % 97 + expanded.substring(block.length);\n\t    }\n\t    var checksum = String(98 - (parseInt(expanded, 10) % 97));\n\t    while (checksum.length < 2) {\n\t        checksum = \"0\" + checksum;\n\t    }\n\t    return checksum;\n\t}\n\t;\n\tfunction getAddress(address) {\n\t    var result = null;\n\t    if (typeof (address) !== \"string\") {\n\t        logger.throwArgumentError(\"invalid address\", \"address\", address);\n\t    }\n\t    if (address.match(/^(0x)?[0-9a-fA-F]{40}$/)) {\n\t        // Missing the 0x prefix\n\t        if (address.substring(0, 2) !== \"0x\") {\n\t            address = \"0x\" + address;\n\t        }\n\t        result = getChecksumAddress(address);\n\t        // It is a checksummed address with a bad checksum\n\t        if (address.match(/([A-F].*[a-f])|([a-f].*[A-F])/) && result !== address) {\n\t            logger.throwArgumentError(\"bad address checksum\", \"address\", address);\n\t        }\n\t        // Maybe ICAP? (we only support direct mode)\n\t    }\n\t    else if (address.match(/^XE[0-9]{2}[0-9A-Za-z]{30,31}$/)) {\n\t        // It is an ICAP address with a bad checksum\n\t        if (address.substring(2, 4) !== ibanChecksum(address)) {\n\t            logger.throwArgumentError(\"bad icap checksum\", \"address\", address);\n\t        }\n\t        result = (0, lib$2._base36To16)(address.substring(4));\n\t        while (result.length < 40) {\n\t            result = \"0\" + result;\n\t        }\n\t        result = getChecksumAddress(\"0x\" + result);\n\t    }\n\t    else {\n\t        logger.throwArgumentError(\"invalid address\", \"address\", address);\n\t    }\n\t    return result;\n\t}\n\texports.getAddress = getAddress;\n\tfunction isAddress(address) {\n\t    try {\n\t        getAddress(address);\n\t        return true;\n\t    }\n\t    catch (error) { }\n\t    return false;\n\t}\n\texports.isAddress = isAddress;\n\tfunction getIcapAddress(address) {\n\t    var base36 = (0, lib$2._base16To36)(getAddress(address).substring(2)).toUpperCase();\n\t    while (base36.length < 30) {\n\t        base36 = \"0\" + base36;\n\t    }\n\t    return \"XE\" + ibanChecksum(\"XE00\" + base36) + base36;\n\t}\n\texports.getIcapAddress = getIcapAddress;\n\t// http://ethereum.stackexchange.com/questions/760/how-is-the-address-of-an-ethereum-contract-computed\n\tfunction getContractAddress(transaction) {\n\t    var from = null;\n\t    try {\n\t        from = getAddress(transaction.from);\n\t    }\n\t    catch (error) {\n\t        logger.throwArgumentError(\"missing from address\", \"transaction\", transaction);\n\t    }\n\t    var nonce = (0, lib$1.stripZeros)((0, lib$1.arrayify)(lib$2.BigNumber.from(transaction.nonce).toHexString()));\n\t    return getAddress((0, lib$1.hexDataSlice)((0, lib$4.keccak256)((0, lib$5.encode)([from, nonce])), 12));\n\t}\n\texports.getContractAddress = getContractAddress;\n\tfunction getCreate2Address(from, salt, initCodeHash) {\n\t    if ((0, lib$1.hexDataLength)(salt) !== 32) {\n\t        logger.throwArgumentError(\"salt must be 32 bytes\", \"salt\", salt);\n\t    }\n\t    if ((0, lib$1.hexDataLength)(initCodeHash) !== 32) {\n\t        logger.throwArgumentError(\"initCodeHash must be 32 bytes\", \"initCodeHash\", initCodeHash);\n\t    }\n\t    return getAddress((0, lib$1.hexDataSlice)((0, lib$4.keccak256)((0, lib$1.concat)([\"0xff\", getAddress(from), salt, initCodeHash])), 12));\n\t}\n\texports.getCreate2Address = getCreate2Address;\n\n\t});\n\n\tvar index$6 = /*@__PURE__*/getDefaultExportFromCjs(lib$6);\n\n\tvar address = createCommonjsModule(function (module, exports) {\n\t\"use strict\";\n\tvar __extends = (commonjsGlobal && commonjsGlobal.__extends) || (function () {\n\t    var extendStatics = function (d, b) {\n\t        extendStatics = Object.setPrototypeOf ||\n\t            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n\t            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n\t        return extendStatics(d, b);\n\t    };\n\t    return function (d, b) {\n\t        if (typeof b !== \"function\" && b !== null)\n\t            throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n\t        extendStatics(d, b);\n\t        function __() { this.constructor = d; }\n\t        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n\t    };\n\t})();\n\tObject.defineProperty(exports, \"__esModule\", { value: true });\n\texports.AddressCoder = void 0;\n\n\n\n\tvar AddressCoder = /** @class */ (function (_super) {\n\t    __extends(AddressCoder, _super);\n\t    function AddressCoder(localName) {\n\t        return _super.call(this, \"address\", \"address\", localName, false) || this;\n\t    }\n\t    AddressCoder.prototype.defaultValue = function () {\n\t        return \"0x0000000000000000000000000000000000000000\";\n\t    };\n\t    AddressCoder.prototype.encode = function (writer, value) {\n\t        try {\n\t            value = (0, lib$6.getAddress)(value);\n\t        }\n\t        catch (error) {\n\t            this._throwError(error.message, value);\n\t        }\n\t        return writer.writeValue(value);\n\t    };\n\t    AddressCoder.prototype.decode = function (reader) {\n\t        return (0, lib$6.getAddress)((0, lib$1.hexZeroPad)(reader.readValue().toHexString(), 20));\n\t    };\n\t    return AddressCoder;\n\t}(abstractCoder.Coder));\n\texports.AddressCoder = AddressCoder;\n\n\t});\n\n\tvar address$1 = /*@__PURE__*/getDefaultExportFromCjs(address);\n\n\tvar anonymous = createCommonjsModule(function (module, exports) {\n\t\"use strict\";\n\tvar __extends = (commonjsGlobal && commonjsGlobal.__extends) || (function () {\n\t    var extendStatics = function (d, b) {\n\t        extendStatics = Object.setPrototypeOf ||\n\t            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n\t            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n\t        return extendStatics(d, b);\n\t    };\n\t    return function (d, b) {\n\t        if (typeof b !== \"function\" && b !== null)\n\t            throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n\t        extendStatics(d, b);\n\t        function __() { this.constructor = d; }\n\t        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n\t    };\n\t})();\n\tObject.defineProperty(exports, \"__esModule\", { value: true });\n\texports.AnonymousCoder = void 0;\n\n\t// Clones the functionality of an existing Coder, but without a localName\n\tvar AnonymousCoder = /** @class */ (function (_super) {\n\t    __extends(AnonymousCoder, _super);\n\t    function AnonymousCoder(coder) {\n\t        var _this = _super.call(this, coder.name, coder.type, undefined, coder.dynamic) || this;\n\t        _this.coder = coder;\n\t        return _this;\n\t    }\n\t    AnonymousCoder.prototype.defaultValue = function () {\n\t        return this.coder.defaultValue();\n\t    };\n\t    AnonymousCoder.prototype.encode = function (writer, value) {\n\t        return this.coder.encode(writer, value);\n\t    };\n\t    AnonymousCoder.prototype.decode = function (reader) {\n\t        return this.coder.decode(reader);\n\t    };\n\t    return AnonymousCoder;\n\t}(abstractCoder.Coder));\n\texports.AnonymousCoder = AnonymousCoder;\n\n\t});\n\n\tvar anonymous$1 = /*@__PURE__*/getDefaultExportFromCjs(anonymous);\n\n\tvar array = createCommonjsModule(function (module, exports) {\n\t\"use strict\";\n\tvar __extends = (commonjsGlobal && commonjsGlobal.__extends) || (function () {\n\t    var extendStatics = function (d, b) {\n\t        extendStatics = Object.setPrototypeOf ||\n\t            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n\t            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n\t        return extendStatics(d, b);\n\t    };\n\t    return function (d, b) {\n\t        if (typeof b !== \"function\" && b !== null)\n\t            throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n\t        extendStatics(d, b);\n\t        function __() { this.constructor = d; }\n\t        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n\t    };\n\t})();\n\tObject.defineProperty(exports, \"__esModule\", { value: true });\n\texports.ArrayCoder = exports.unpack = exports.pack = void 0;\n\n\n\tvar logger = new lib.Logger(_version$8.version);\n\n\n\tfunction pack(writer, coders, values) {\n\t    var arrayValues = null;\n\t    if (Array.isArray(values)) {\n\t        arrayValues = values;\n\t    }\n\t    else if (values && typeof (values) === \"object\") {\n\t        var unique_1 = {};\n\t        arrayValues = coders.map(function (coder) {\n\t            var name = coder.localName;\n\t            if (!name) {\n\t                logger.throwError(\"cannot encode object for signature with missing names\", lib.Logger.errors.INVALID_ARGUMENT, {\n\t                    argument: \"values\",\n\t                    coder: coder,\n\t                    value: values\n\t                });\n\t            }\n\t            if (unique_1[name]) {\n\t                logger.throwError(\"cannot encode object for signature with duplicate names\", lib.Logger.errors.INVALID_ARGUMENT, {\n\t                    argument: \"values\",\n\t                    coder: coder,\n\t                    value: values\n\t                });\n\t            }\n\t            unique_1[name] = true;\n\t            return values[name];\n\t        });\n\t    }\n\t    else {\n\t        logger.throwArgumentError(\"invalid tuple value\", \"tuple\", values);\n\t    }\n\t    if (coders.length !== arrayValues.length) {\n\t        logger.throwArgumentError(\"types/value length mismatch\", \"tuple\", values);\n\t    }\n\t    var staticWriter = new abstractCoder.Writer(writer.wordSize);\n\t    var dynamicWriter = new abstractCoder.Writer(writer.wordSize);\n\t    var updateFuncs = [];\n\t    coders.forEach(function (coder, index) {\n\t        var value = arrayValues[index];\n\t        if (coder.dynamic) {\n\t            // Get current dynamic offset (for the future pointer)\n\t            var dynamicOffset_1 = dynamicWriter.length;\n\t            // Encode the dynamic value into the dynamicWriter\n\t            coder.encode(dynamicWriter, value);\n\t            // Prepare to populate the correct offset once we are done\n\t            var updateFunc_1 = staticWriter.writeUpdatableValue();\n\t            updateFuncs.push(function (baseOffset) {\n\t                updateFunc_1(baseOffset + dynamicOffset_1);\n\t            });\n\t        }\n\t        else {\n\t            coder.encode(staticWriter, value);\n\t        }\n\t    });\n\t    // Backfill all the dynamic offsets, now that we know the static length\n\t    updateFuncs.forEach(function (func) { func(staticWriter.length); });\n\t    var length = writer.appendWriter(staticWriter);\n\t    length += writer.appendWriter(dynamicWriter);\n\t    return length;\n\t}\n\texports.pack = pack;\n\tfunction unpack(reader, coders) {\n\t    var values = [];\n\t    // A reader anchored to this base\n\t    var baseReader = reader.subReader(0);\n\t    coders.forEach(function (coder) {\n\t        var value = null;\n\t        if (coder.dynamic) {\n\t            var offset = reader.readValue();\n\t            var offsetReader = baseReader.subReader(offset.toNumber());\n\t            try {\n\t                value = coder.decode(offsetReader);\n\t            }\n\t            catch (error) {\n\t                // Cannot recover from this\n\t                if (error.code === lib.Logger.errors.BUFFER_OVERRUN) {\n\t                    throw error;\n\t                }\n\t                value = error;\n\t                value.baseType = coder.name;\n\t                value.name = coder.localName;\n\t                value.type = coder.type;\n\t            }\n\t        }\n\t        else {\n\t            try {\n\t                value = coder.decode(reader);\n\t            }\n\t            catch (error) {\n\t                // Cannot recover from this\n\t                if (error.code === lib.Logger.errors.BUFFER_OVERRUN) {\n\t                    throw error;\n\t                }\n\t                value = error;\n\t                value.baseType = coder.name;\n\t                value.name = coder.localName;\n\t                value.type = coder.type;\n\t            }\n\t        }\n\t        if (value != undefined) {\n\t            values.push(value);\n\t        }\n\t    });\n\t    // We only output named properties for uniquely named coders\n\t    var uniqueNames = coders.reduce(function (accum, coder) {\n\t        var name = coder.localName;\n\t        if (name) {\n\t            if (!accum[name]) {\n\t                accum[name] = 0;\n\t            }\n\t            accum[name]++;\n\t        }\n\t        return accum;\n\t    }, {});\n\t    // Add any named parameters (i.e. tuples)\n\t    coders.forEach(function (coder, index) {\n\t        var name = coder.localName;\n\t        if (!name || uniqueNames[name] !== 1) {\n\t            return;\n\t        }\n\t        if (name === \"length\") {\n\t            name = \"_length\";\n\t        }\n\t        if (values[name] != null) {\n\t            return;\n\t        }\n\t        var value = values[index];\n\t        if (value instanceof Error) {\n\t            Object.defineProperty(values, name, {\n\t                enumerable: true,\n\t                get: function () { throw value; }\n\t            });\n\t        }\n\t        else {\n\t            values[name] = value;\n\t        }\n\t    });\n\t    var _loop_1 = function (i) {\n\t        var value = values[i];\n\t        if (value instanceof Error) {\n\t            Object.defineProperty(values, i, {\n\t                enumerable: true,\n\t                get: function () { throw value; }\n\t            });\n\t        }\n\t    };\n\t    for (var i = 0; i < values.length; i++) {\n\t        _loop_1(i);\n\t    }\n\t    return Object.freeze(values);\n\t}\n\texports.unpack = unpack;\n\tvar ArrayCoder = /** @class */ (function (_super) {\n\t    __extends(ArrayCoder, _super);\n\t    function ArrayCoder(coder, length, localName) {\n\t        var _this = this;\n\t        var type = (coder.type + \"[\" + (length >= 0 ? length : \"\") + \"]\");\n\t        var dynamic = (length === -1 || coder.dynamic);\n\t        _this = _super.call(this, \"array\", type, localName, dynamic) || this;\n\t        _this.coder = coder;\n\t        _this.length = length;\n\t        return _this;\n\t    }\n\t    ArrayCoder.prototype.defaultValue = function () {\n\t        // Verifies the child coder is valid (even if the array is dynamic or 0-length)\n\t        var defaultChild = this.coder.defaultValue();\n\t        var result = [];\n\t        for (var i = 0; i < this.length; i++) {\n\t            result.push(defaultChild);\n\t        }\n\t        return result;\n\t    };\n\t    ArrayCoder.prototype.encode = function (writer, value) {\n\t        if (!Array.isArray(value)) {\n\t            this._throwError(\"expected array value\", value);\n\t        }\n\t        var count = this.length;\n\t        if (count === -1) {\n\t            count = value.length;\n\t            writer.writeValue(value.length);\n\t        }\n\t        logger.checkArgumentCount(value.length, count, \"coder array\" + (this.localName ? (\" \" + this.localName) : \"\"));\n\t        var coders = [];\n\t        for (var i = 0; i < value.length; i++) {\n\t            coders.push(this.coder);\n\t        }\n\t        return pack(writer, coders, value);\n\t    };\n\t    ArrayCoder.prototype.decode = function (reader) {\n\t        var count = this.length;\n\t        if (count === -1) {\n\t            count = reader.readValue().toNumber();\n\t            // Check that there is *roughly* enough data to ensure\n\t            // stray random data is not being read as a length. Each\n\t            // slot requires at least 32 bytes for their value (or 32\n\t            // bytes as a link to the data). This could use a much\n\t            // tighter bound, but we are erroring on the side of safety.\n\t            if (count * 32 > reader._data.length) {\n\t                logger.throwError(\"insufficient data length\", lib.Logger.errors.BUFFER_OVERRUN, {\n\t                    length: reader._data.length,\n\t                    count: count\n\t                });\n\t            }\n\t        }\n\t        var coders = [];\n\t        for (var i = 0; i < count; i++) {\n\t            coders.push(new anonymous.AnonymousCoder(this.coder));\n\t        }\n\t        return reader.coerce(this.name, unpack(reader, coders));\n\t    };\n\t    return ArrayCoder;\n\t}(abstractCoder.Coder));\n\texports.ArrayCoder = ArrayCoder;\n\n\t});\n\n\tvar array$1 = /*@__PURE__*/getDefaultExportFromCjs(array);\n\n\tvar boolean_1 = createCommonjsModule(function (module, exports) {\n\t\"use strict\";\n\tvar __extends = (commonjsGlobal && commonjsGlobal.__extends) || (function () {\n\t    var extendStatics = function (d, b) {\n\t        extendStatics = Object.setPrototypeOf ||\n\t            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n\t            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n\t        return extendStatics(d, b);\n\t    };\n\t    return function (d, b) {\n\t        if (typeof b !== \"function\" && b !== null)\n\t            throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n\t        extendStatics(d, b);\n\t        function __() { this.constructor = d; }\n\t        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n\t    };\n\t})();\n\tObject.defineProperty(exports, \"__esModule\", { value: true });\n\texports.BooleanCoder = void 0;\n\n\tvar BooleanCoder = /** @class */ (function (_super) {\n\t    __extends(BooleanCoder, _super);\n\t    function BooleanCoder(localName) {\n\t        return _super.call(this, \"bool\", \"bool\", localName, false) || this;\n\t    }\n\t    BooleanCoder.prototype.defaultValue = function () {\n\t        return false;\n\t    };\n\t    BooleanCoder.prototype.encode = function (writer, value) {\n\t        return writer.writeValue(value ? 1 : 0);\n\t    };\n\t    BooleanCoder.prototype.decode = function (reader) {\n\t        return reader.coerce(this.type, !reader.readValue().isZero());\n\t    };\n\t    return BooleanCoder;\n\t}(abstractCoder.Coder));\n\texports.BooleanCoder = BooleanCoder;\n\n\t});\n\n\tvar boolean = /*@__PURE__*/getDefaultExportFromCjs(boolean_1);\n\n\tvar bytes = createCommonjsModule(function (module, exports) {\n\t\"use strict\";\n\tvar __extends = (commonjsGlobal && commonjsGlobal.__extends) || (function () {\n\t    var extendStatics = function (d, b) {\n\t        extendStatics = Object.setPrototypeOf ||\n\t            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n\t            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n\t        return extendStatics(d, b);\n\t    };\n\t    return function (d, b) {\n\t        if (typeof b !== \"function\" && b !== null)\n\t            throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n\t        extendStatics(d, b);\n\t        function __() { this.constructor = d; }\n\t        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n\t    };\n\t})();\n\tObject.defineProperty(exports, \"__esModule\", { value: true });\n\texports.BytesCoder = exports.DynamicBytesCoder = void 0;\n\n\n\tvar DynamicBytesCoder = /** @class */ (function (_super) {\n\t    __extends(DynamicBytesCoder, _super);\n\t    function DynamicBytesCoder(type, localName) {\n\t        return _super.call(this, type, type, localName, true) || this;\n\t    }\n\t    DynamicBytesCoder.prototype.defaultValue = function () {\n\t        return \"0x\";\n\t    };\n\t    DynamicBytesCoder.prototype.encode = function (writer, value) {\n\t        value = (0, lib$1.arrayify)(value);\n\t        var length = writer.writeValue(value.length);\n\t        length += writer.writeBytes(value);\n\t        return length;\n\t    };\n\t    DynamicBytesCoder.prototype.decode = function (reader) {\n\t        return reader.readBytes(reader.readValue().toNumber(), true);\n\t    };\n\t    return DynamicBytesCoder;\n\t}(abstractCoder.Coder));\n\texports.DynamicBytesCoder = DynamicBytesCoder;\n\tvar BytesCoder = /** @class */ (function (_super) {\n\t    __extends(BytesCoder, _super);\n\t    function BytesCoder(localName) {\n\t        return _super.call(this, \"bytes\", localName) || this;\n\t    }\n\t    BytesCoder.prototype.decode = function (reader) {\n\t        return reader.coerce(this.name, (0, lib$1.hexlify)(_super.prototype.decode.call(this, reader)));\n\t    };\n\t    return BytesCoder;\n\t}(DynamicBytesCoder));\n\texports.BytesCoder = BytesCoder;\n\n\t});\n\n\tvar bytes$1 = /*@__PURE__*/getDefaultExportFromCjs(bytes);\n\n\tvar fixedBytes = createCommonjsModule(function (module, exports) {\n\t\"use strict\";\n\tvar __extends = (commonjsGlobal && commonjsGlobal.__extends) || (function () {\n\t    var extendStatics = function (d, b) {\n\t        extendStatics = Object.setPrototypeOf ||\n\t            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n\t            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n\t        return extendStatics(d, b);\n\t    };\n\t    return function (d, b) {\n\t        if (typeof b !== \"function\" && b !== null)\n\t            throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n\t        extendStatics(d, b);\n\t        function __() { this.constructor = d; }\n\t        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n\t    };\n\t})();\n\tObject.defineProperty(exports, \"__esModule\", { value: true });\n\texports.FixedBytesCoder = void 0;\n\n\n\t// @TODO: Merge this with bytes\n\tvar FixedBytesCoder = /** @class */ (function (_super) {\n\t    __extends(FixedBytesCoder, _super);\n\t    function FixedBytesCoder(size, localName) {\n\t        var _this = this;\n\t        var name = \"bytes\" + String(size);\n\t        _this = _super.call(this, name, name, localName, false) || this;\n\t        _this.size = size;\n\t        return _this;\n\t    }\n\t    FixedBytesCoder.prototype.defaultValue = function () {\n\t        return (\"0x0000000000000000000000000000000000000000000000000000000000000000\").substring(0, 2 + this.size * 2);\n\t    };\n\t    FixedBytesCoder.prototype.encode = function (writer, value) {\n\t        var data = (0, lib$1.arrayify)(value);\n\t        if (data.length !== this.size) {\n\t            this._throwError(\"incorrect data length\", value);\n\t        }\n\t        return writer.writeBytes(data);\n\t    };\n\t    FixedBytesCoder.prototype.decode = function (reader) {\n\t        return reader.coerce(this.name, (0, lib$1.hexlify)(reader.readBytes(this.size)));\n\t    };\n\t    return FixedBytesCoder;\n\t}(abstractCoder.Coder));\n\texports.FixedBytesCoder = FixedBytesCoder;\n\n\t});\n\n\tvar fixedBytes$1 = /*@__PURE__*/getDefaultExportFromCjs(fixedBytes);\n\n\tvar _null = createCommonjsModule(function (module, exports) {\n\t\"use strict\";\n\tvar __extends = (commonjsGlobal && commonjsGlobal.__extends) || (function () {\n\t    var extendStatics = function (d, b) {\n\t        extendStatics = Object.setPrototypeOf ||\n\t            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n\t            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n\t        return extendStatics(d, b);\n\t    };\n\t    return function (d, b) {\n\t        if (typeof b !== \"function\" && b !== null)\n\t            throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n\t        extendStatics(d, b);\n\t        function __() { this.constructor = d; }\n\t        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n\t    };\n\t})();\n\tObject.defineProperty(exports, \"__esModule\", { value: true });\n\texports.NullCoder = void 0;\n\n\tvar NullCoder = /** @class */ (function (_super) {\n\t    __extends(NullCoder, _super);\n\t    function NullCoder(localName) {\n\t        return _super.call(this, \"null\", \"\", localName, false) || this;\n\t    }\n\t    NullCoder.prototype.defaultValue = function () {\n\t        return null;\n\t    };\n\t    NullCoder.prototype.encode = function (writer, value) {\n\t        if (value != null) {\n\t            this._throwError(\"not null\", value);\n\t        }\n\t        return writer.writeBytes([]);\n\t    };\n\t    NullCoder.prototype.decode = function (reader) {\n\t        reader.readBytes(0);\n\t        return reader.coerce(this.name, null);\n\t    };\n\t    return NullCoder;\n\t}(abstractCoder.Coder));\n\texports.NullCoder = NullCoder;\n\n\t});\n\n\tvar _null$1 = /*@__PURE__*/getDefaultExportFromCjs(_null);\n\n\tvar addresses = createCommonjsModule(function (module, exports) {\n\t\"use strict\";\n\tObject.defineProperty(exports, \"__esModule\", { value: true });\n\texports.AddressZero = void 0;\n\texports.AddressZero = \"0x0000000000000000000000000000000000000000\";\n\n\t});\n\n\tvar addresses$1 = /*@__PURE__*/getDefaultExportFromCjs(addresses);\n\n\tvar bignumbers = createCommonjsModule(function (module, exports) {\n\t\"use strict\";\n\tObject.defineProperty(exports, \"__esModule\", { value: true });\n\texports.MaxInt256 = exports.MinInt256 = exports.MaxUint256 = exports.WeiPerEther = exports.Two = exports.One = exports.Zero = exports.NegativeOne = void 0;\n\n\tvar NegativeOne = ( /*#__PURE__*/lib$2.BigNumber.from(-1));\n\texports.NegativeOne = NegativeOne;\n\tvar Zero = ( /*#__PURE__*/lib$2.BigNumber.from(0));\n\texports.Zero = Zero;\n\tvar One = ( /*#__PURE__*/lib$2.BigNumber.from(1));\n\texports.One = One;\n\tvar Two = ( /*#__PURE__*/lib$2.BigNumber.from(2));\n\texports.Two = Two;\n\tvar WeiPerEther = ( /*#__PURE__*/lib$2.BigNumber.from(\"1000000000000000000\"));\n\texports.WeiPerEther = WeiPerEther;\n\tvar MaxUint256 = ( /*#__PURE__*/lib$2.BigNumber.from(\"0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\"));\n\texports.MaxUint256 = MaxUint256;\n\tvar MinInt256 = ( /*#__PURE__*/lib$2.BigNumber.from(\"-0x8000000000000000000000000000000000000000000000000000000000000000\"));\n\texports.MinInt256 = MinInt256;\n\tvar MaxInt256 = ( /*#__PURE__*/lib$2.BigNumber.from(\"0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\"));\n\texports.MaxInt256 = MaxInt256;\n\n\t});\n\n\tvar bignumbers$1 = /*@__PURE__*/getDefaultExportFromCjs(bignumbers);\n\n\tvar hashes = createCommonjsModule(function (module, exports) {\n\t\"use strict\";\n\tObject.defineProperty(exports, \"__esModule\", { value: true });\n\texports.HashZero = void 0;\n\texports.HashZero = \"0x0000000000000000000000000000000000000000000000000000000000000000\";\n\n\t});\n\n\tvar hashes$1 = /*@__PURE__*/getDefaultExportFromCjs(hashes);\n\n\tvar strings = createCommonjsModule(function (module, exports) {\n\t\"use strict\";\n\tObject.defineProperty(exports, \"__esModule\", { value: true });\n\texports.EtherSymbol = void 0;\n\t// NFKC (composed)             // (decomposed)\n\texports.EtherSymbol = \"\\u039e\"; // \"\\uD835\\uDF63\";\n\n\t});\n\n\tvar strings$1 = /*@__PURE__*/getDefaultExportFromCjs(strings);\n\n\tvar lib$7 = createCommonjsModule(function (module, exports) {\n\t\"use strict\";\n\tObject.defineProperty(exports, \"__esModule\", { value: true });\n\texports.EtherSymbol = exports.HashZero = exports.MaxInt256 = exports.MinInt256 = exports.MaxUint256 = exports.WeiPerEther = exports.Two = exports.One = exports.Zero = exports.NegativeOne = exports.AddressZero = void 0;\n\n\tObject.defineProperty(exports, \"AddressZero\", { enumerable: true, get: function () { return addresses.AddressZero; } });\n\n\tObject.defineProperty(exports, \"NegativeOne\", { enumerable: true, get: function () { return bignumbers.NegativeOne; } });\n\tObject.defineProperty(exports, \"Zero\", { enumerable: true, get: function () { return bignumbers.Zero; } });\n\tObject.defineProperty(exports, \"One\", { enumerable: true, get: function () { return bignumbers.One; } });\n\tObject.defineProperty(exports, \"Two\", { enumerable: true, get: function () { return bignumbers.Two; } });\n\tObject.defineProperty(exports, \"WeiPerEther\", { enumerable: true, get: function () { return bignumbers.WeiPerEther; } });\n\tObject.defineProperty(exports, \"MaxUint256\", { enumerable: true, get: function () { return bignumbers.MaxUint256; } });\n\tObject.defineProperty(exports, \"MinInt256\", { enumerable: true, get: function () { return bignumbers.MinInt256; } });\n\tObject.defineProperty(exports, \"MaxInt256\", { enumerable: true, get: function () { return bignumbers.MaxInt256; } });\n\n\tObject.defineProperty(exports, \"HashZero\", { enumerable: true, get: function () { return hashes.HashZero; } });\n\n\tObject.defineProperty(exports, \"EtherSymbol\", { enumerable: true, get: function () { return strings.EtherSymbol; } });\n\n\t});\n\n\tvar index$7 = /*@__PURE__*/getDefaultExportFromCjs(lib$7);\n\n\tvar number = createCommonjsModule(function (module, exports) {\n\t\"use strict\";\n\tvar __extends = (commonjsGlobal && commonjsGlobal.__extends) || (function () {\n\t    var extendStatics = function (d, b) {\n\t        extendStatics = Object.setPrototypeOf ||\n\t            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n\t            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n\t        return extendStatics(d, b);\n\t    };\n\t    return function (d, b) {\n\t        if (typeof b !== \"function\" && b !== null)\n\t            throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n\t        extendStatics(d, b);\n\t        function __() { this.constructor = d; }\n\t        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n\t    };\n\t})();\n\tObject.defineProperty(exports, \"__esModule\", { value: true });\n\texports.NumberCoder = void 0;\n\n\n\n\tvar NumberCoder = /** @class */ (function (_super) {\n\t    __extends(NumberCoder, _super);\n\t    function NumberCoder(size, signed, localName) {\n\t        var _this = this;\n\t        var name = ((signed ? \"int\" : \"uint\") + (size * 8));\n\t        _this = _super.call(this, name, name, localName, false) || this;\n\t        _this.size = size;\n\t        _this.signed = signed;\n\t        return _this;\n\t    }\n\t    NumberCoder.prototype.defaultValue = function () {\n\t        return 0;\n\t    };\n\t    NumberCoder.prototype.encode = function (writer, value) {\n\t        var v = lib$2.BigNumber.from(value);\n\t        // Check bounds are safe for encoding\n\t        var maxUintValue = lib$7.MaxUint256.mask(writer.wordSize * 8);\n\t        if (this.signed) {\n\t            var bounds = maxUintValue.mask(this.size * 8 - 1);\n\t            if (v.gt(bounds) || v.lt(bounds.add(lib$7.One).mul(lib$7.NegativeOne))) {\n\t                this._throwError(\"value out-of-bounds\", value);\n\t            }\n\t        }\n\t        else if (v.lt(lib$7.Zero) || v.gt(maxUintValue.mask(this.size * 8))) {\n\t            this._throwError(\"value out-of-bounds\", value);\n\t        }\n\t        v = v.toTwos(this.size * 8).mask(this.size * 8);\n\t        if (this.signed) {\n\t            v = v.fromTwos(this.size * 8).toTwos(8 * writer.wordSize);\n\t        }\n\t        return writer.writeValue(v);\n\t    };\n\t    NumberCoder.prototype.decode = function (reader) {\n\t        var value = reader.readValue().mask(this.size * 8);\n\t        if (this.signed) {\n\t            value = value.fromTwos(this.size * 8);\n\t        }\n\t        return reader.coerce(this.name, value);\n\t    };\n\t    return NumberCoder;\n\t}(abstractCoder.Coder));\n\texports.NumberCoder = NumberCoder;\n\n\t});\n\n\tvar number$1 = /*@__PURE__*/getDefaultExportFromCjs(number);\n\n\tvar _version$e = createCommonjsModule(function (module, exports) {\n\t\"use strict\";\n\tObject.defineProperty(exports, \"__esModule\", { value: true });\n\texports.version = void 0;\n\texports.version = \"strings/5.5.0\";\n\n\t});\n\n\tvar _version$f = /*@__PURE__*/getDefaultExportFromCjs(_version$e);\n\n\tvar utf8 = createCommonjsModule(function (module, exports) {\n\t\"use strict\";\n\tObject.defineProperty(exports, \"__esModule\", { value: true });\n\texports.toUtf8CodePoints = exports.toUtf8String = exports._toUtf8String = exports._toEscapedUtf8String = exports.toUtf8Bytes = exports.Utf8ErrorFuncs = exports.Utf8ErrorReason = exports.UnicodeNormalizationForm = void 0;\n\n\n\n\tvar logger = new lib.Logger(_version$e.version);\n\t///////////////////////////////\n\tvar UnicodeNormalizationForm;\n\t(function (UnicodeNormalizationForm) {\n\t    UnicodeNormalizationForm[\"current\"] = \"\";\n\t    UnicodeNormalizationForm[\"NFC\"] = \"NFC\";\n\t    UnicodeNormalizationForm[\"NFD\"] = \"NFD\";\n\t    UnicodeNormalizationForm[\"NFKC\"] = \"NFKC\";\n\t    UnicodeNormalizationForm[\"NFKD\"] = \"NFKD\";\n\t})(UnicodeNormalizationForm = exports.UnicodeNormalizationForm || (exports.UnicodeNormalizationForm = {}));\n\t;\n\tvar Utf8ErrorReason;\n\t(function (Utf8ErrorReason) {\n\t    // A continuation byte was present where there was nothing to continue\n\t    // - offset = the index the codepoint began in\n\t    Utf8ErrorReason[\"UNEXPECTED_CONTINUE\"] = \"unexpected continuation byte\";\n\t    // An invalid (non-continuation) byte to start a UTF-8 codepoint was found\n\t    // - offset = the index the codepoint began in\n\t    Utf8ErrorReason[\"BAD_PREFIX\"] = \"bad codepoint prefix\";\n\t    // The string is too short to process the expected codepoint\n\t    // - offset = the index the codepoint began in\n\t    Utf8ErrorReason[\"OVERRUN\"] = \"string overrun\";\n\t    // A missing continuation byte was expected but not found\n\t    // - offset = the index the continuation byte was expected at\n\t    Utf8ErrorReason[\"MISSING_CONTINUE\"] = \"missing continuation byte\";\n\t    // The computed code point is outside the range for UTF-8\n\t    // - offset       = start of this codepoint\n\t    // - badCodepoint = the computed codepoint; outside the UTF-8 range\n\t    Utf8ErrorReason[\"OUT_OF_RANGE\"] = \"out of UTF-8 range\";\n\t    // UTF-8 strings may not contain UTF-16 surrogate pairs\n\t    // - offset       = start of this codepoint\n\t    // - badCodepoint = the computed codepoint; inside the UTF-16 surrogate range\n\t    Utf8ErrorReason[\"UTF16_SURROGATE\"] = \"UTF-16 surrogate\";\n\t    // The string is an overlong representation\n\t    // - offset       = start of this codepoint\n\t    // - badCodepoint = the computed codepoint; already bounds checked\n\t    Utf8ErrorReason[\"OVERLONG\"] = \"overlong representation\";\n\t})(Utf8ErrorReason = exports.Utf8ErrorReason || (exports.Utf8ErrorReason = {}));\n\t;\n\tfunction errorFunc(reason, offset, bytes, output, badCodepoint) {\n\t    return logger.throwArgumentError(\"invalid codepoint at offset \" + offset + \"; \" + reason, \"bytes\", bytes);\n\t}\n\tfunction ignoreFunc(reason, offset, bytes, output, badCodepoint) {\n\t    // If there is an invalid prefix (including stray continuation), skip any additional continuation bytes\n\t    if (reason === Utf8ErrorReason.BAD_PREFIX || reason === Utf8ErrorReason.UNEXPECTED_CONTINUE) {\n\t        var i = 0;\n\t        for (var o = offset + 1; o < bytes.length; o++) {\n\t            if (bytes[o] >> 6 !== 0x02) {\n\t                break;\n\t            }\n\t            i++;\n\t        }\n\t        return i;\n\t    }\n\t    // This byte runs us past the end of the string, so just jump to the end\n\t    // (but the first byte was read already read and therefore skipped)\n\t    if (reason === Utf8ErrorReason.OVERRUN) {\n\t        return bytes.length - offset - 1;\n\t    }\n\t    // Nothing to skip\n\t    return 0;\n\t}\n\tfunction replaceFunc(reason, offset, bytes, output, badCodepoint) {\n\t    // Overlong representations are otherwise \"valid\" code points; just non-deistingtished\n\t    if (reason === Utf8ErrorReason.OVERLONG) {\n\t        output.push(badCodepoint);\n\t        return 0;\n\t    }\n\t    // Put the replacement character into the output\n\t    output.push(0xfffd);\n\t    // Otherwise, process as if ignoring errors\n\t    return ignoreFunc(reason, offset, bytes, output, badCodepoint);\n\t}\n\t// Common error handing strategies\n\texports.Utf8ErrorFuncs = Object.freeze({\n\t    error: errorFunc,\n\t    ignore: ignoreFunc,\n\t    replace: replaceFunc\n\t});\n\t// http://stackoverflow.com/questions/13356493/decode-utf-8-with-javascript#13691499\n\tfunction getUtf8CodePoints(bytes, onError) {\n\t    if (onError == null) {\n\t        onError = exports.Utf8ErrorFuncs.error;\n\t    }\n\t    bytes = (0, lib$1.arrayify)(bytes);\n\t    var result = [];\n\t    var i = 0;\n\t    // Invalid bytes are ignored\n\t    while (i < bytes.length) {\n\t        var c = bytes[i++];\n\t        // 0xxx xxxx\n\t        if (c >> 7 === 0) {\n\t            result.push(c);\n\t            continue;\n\t        }\n\t        // Multibyte; how many bytes left for this character?\n\t        var extraLength = null;\n\t        var overlongMask = null;\n\t        // 110x xxxx 10xx xxxx\n\t        if ((c & 0xe0) === 0xc0) {\n\t            extraLength = 1;\n\t            overlongMask = 0x7f;\n\t            // 1110 xxxx 10xx xxxx 10xx xxxx\n\t        }\n\t        else if ((c & 0xf0) === 0xe0) {\n\t            extraLength = 2;\n\t            overlongMask = 0x7ff;\n\t            // 1111 0xxx 10xx xxxx 10xx xxxx 10xx xxxx\n\t        }\n\t        else if ((c & 0xf8) === 0xf0) {\n\t            extraLength = 3;\n\t            overlongMask = 0xffff;\n\t        }\n\t        else {\n\t            if ((c & 0xc0) === 0x80) {\n\t                i += onError(Utf8ErrorReason.UNEXPECTED_CONTINUE, i - 1, bytes, result);\n\t            }\n\t            else {\n\t                i += onError(Utf8ErrorReason.BAD_PREFIX, i - 1, bytes, result);\n\t            }\n\t            continue;\n\t        }\n\t        // Do we have enough bytes in our data?\n\t        if (i - 1 + extraLength >= bytes.length) {\n\t            i += onError(Utf8ErrorReason.OVERRUN, i - 1, bytes, result);\n\t            continue;\n\t        }\n\t        // Remove the length prefix from the char\n\t        var res = c & ((1 << (8 - extraLength - 1)) - 1);\n\t        for (var j = 0; j < extraLength; j++) {\n\t            var nextChar = bytes[i];\n\t            // Invalid continuation byte\n\t            if ((nextChar & 0xc0) != 0x80) {\n\t                i += onError(Utf8ErrorReason.MISSING_CONTINUE, i, bytes, result);\n\t                res = null;\n\t                break;\n\t            }\n\t            ;\n\t            res = (res << 6) | (nextChar & 0x3f);\n\t            i++;\n\t        }\n\t        // See above loop for invalid continuation byte\n\t        if (res === null) {\n\t            continue;\n\t        }\n\t        // Maximum code point\n\t        if (res > 0x10ffff) {\n\t            i += onError(Utf8ErrorReason.OUT_OF_RANGE, i - 1 - extraLength, bytes, result, res);\n\t            continue;\n\t        }\n\t        // Reserved for UTF-16 surrogate halves\n\t        if (res >= 0xd800 && res <= 0xdfff) {\n\t            i += onError(Utf8ErrorReason.UTF16_SURROGATE, i - 1 - extraLength, bytes, result, res);\n\t            continue;\n\t        }\n\t        // Check for overlong sequences (more bytes than needed)\n\t        if (res <= overlongMask) {\n\t            i += onError(Utf8ErrorReason.OVERLONG, i - 1 - extraLength, bytes, result, res);\n\t            continue;\n\t        }\n\t        result.push(res);\n\t    }\n\t    return result;\n\t}\n\t// http://stackoverflow.com/questions/18729405/how-to-convert-utf8-string-to-byte-array\n\tfunction toUtf8Bytes(str, form) {\n\t    if (form === void 0) { form = UnicodeNormalizationForm.current; }\n\t    if (form != UnicodeNormalizationForm.current) {\n\t        logger.checkNormalize();\n\t        str = str.normalize(form);\n\t    }\n\t    var result = [];\n\t    for (var i = 0; i < str.length; i++) {\n\t        var c = str.charCodeAt(i);\n\t        if (c < 0x80) {\n\t            result.push(c);\n\t        }\n\t        else if (c < 0x800) {\n\t            result.push((c >> 6) | 0xc0);\n\t            result.push((c & 0x3f) | 0x80);\n\t        }\n\t        else if ((c & 0xfc00) == 0xd800) {\n\t            i++;\n\t            var c2 = str.charCodeAt(i);\n\t            if (i >= str.length || (c2 & 0xfc00) !== 0xdc00) {\n\t                throw new Error(\"invalid utf-8 string\");\n\t            }\n\t            // Surrogate Pair\n\t            var pair = 0x10000 + ((c & 0x03ff) << 10) + (c2 & 0x03ff);\n\t            result.push((pair >> 18) | 0xf0);\n\t            result.push(((pair >> 12) & 0x3f) | 0x80);\n\t            result.push(((pair >> 6) & 0x3f) | 0x80);\n\t            result.push((pair & 0x3f) | 0x80);\n\t        }\n\t        else {\n\t            result.push((c >> 12) | 0xe0);\n\t            result.push(((c >> 6) & 0x3f) | 0x80);\n\t            result.push((c & 0x3f) | 0x80);\n\t        }\n\t    }\n\t    return (0, lib$1.arrayify)(result);\n\t}\n\texports.toUtf8Bytes = toUtf8Bytes;\n\t;\n\tfunction escapeChar(value) {\n\t    var hex = (\"0000\" + value.toString(16));\n\t    return \"\\\\u\" + hex.substring(hex.length - 4);\n\t}\n\tfunction _toEscapedUtf8String(bytes, onError) {\n\t    return '\"' + getUtf8CodePoints(bytes, onError).map(function (codePoint) {\n\t        if (codePoint < 256) {\n\t            switch (codePoint) {\n\t                case 8: return \"\\\\b\";\n\t                case 9: return \"\\\\t\";\n\t                case 10: return \"\\\\n\";\n\t                case 13: return \"\\\\r\";\n\t                case 34: return \"\\\\\\\"\";\n\t                case 92: return \"\\\\\\\\\";\n\t            }\n\t            if (codePoint >= 32 && codePoint < 127) {\n\t                return String.fromCharCode(codePoint);\n\t            }\n\t        }\n\t        if (codePoint <= 0xffff) {\n\t            return escapeChar(codePoint);\n\t        }\n\t        codePoint -= 0x10000;\n\t        return escapeChar(((codePoint >> 10) & 0x3ff) + 0xd800) + escapeChar((codePoint & 0x3ff) + 0xdc00);\n\t    }).join(\"\") + '\"';\n\t}\n\texports._toEscapedUtf8String = _toEscapedUtf8String;\n\tfunction _toUtf8String(codePoints) {\n\t    return codePoints.map(function (codePoint) {\n\t        if (codePoint <= 0xffff) {\n\t            return String.fromCharCode(codePoint);\n\t        }\n\t        codePoint -= 0x10000;\n\t        return String.fromCharCode((((codePoint >> 10) & 0x3ff) + 0xd800), ((codePoint & 0x3ff) + 0xdc00));\n\t    }).join(\"\");\n\t}\n\texports._toUtf8String = _toUtf8String;\n\tfunction toUtf8String(bytes, onError) {\n\t    return _toUtf8String(getUtf8CodePoints(bytes, onError));\n\t}\n\texports.toUtf8String = toUtf8String;\n\tfunction toUtf8CodePoints(str, form) {\n\t    if (form === void 0) { form = UnicodeNormalizationForm.current; }\n\t    return getUtf8CodePoints(toUtf8Bytes(str, form));\n\t}\n\texports.toUtf8CodePoints = toUtf8CodePoints;\n\n\t});\n\n\tvar utf8$1 = /*@__PURE__*/getDefaultExportFromCjs(utf8);\n\n\tvar bytes32 = createCommonjsModule(function (module, exports) {\n\t\"use strict\";\n\tObject.defineProperty(exports, \"__esModule\", { value: true });\n\texports.parseBytes32String = exports.formatBytes32String = void 0;\n\n\n\n\tfunction formatBytes32String(text) {\n\t    // Get the bytes\n\t    var bytes = (0, utf8.toUtf8Bytes)(text);\n\t    // Check we have room for null-termination\n\t    if (bytes.length > 31) {\n\t        throw new Error(\"bytes32 string must be less than 32 bytes\");\n\t    }\n\t    // Zero-pad (implicitly null-terminates)\n\t    return (0, lib$1.hexlify)((0, lib$1.concat)([bytes, lib$7.HashZero]).slice(0, 32));\n\t}\n\texports.formatBytes32String = formatBytes32String;\n\tfunction parseBytes32String(bytes) {\n\t    var data = (0, lib$1.arrayify)(bytes);\n\t    // Must be 32 bytes with a null-termination\n\t    if (data.length !== 32) {\n\t        throw new Error(\"invalid bytes32 - not 32 bytes long\");\n\t    }\n\t    if (data[31] !== 0) {\n\t        throw new Error(\"invalid bytes32 string - no null terminator\");\n\t    }\n\t    // Find the null termination\n\t    var length = 31;\n\t    while (data[length - 1] === 0) {\n\t        length--;\n\t    }\n\t    // Determine the string value\n\t    return (0, utf8.toUtf8String)(data.slice(0, length));\n\t}\n\texports.parseBytes32String = parseBytes32String;\n\n\t});\n\n\tvar bytes32$1 = /*@__PURE__*/getDefaultExportFromCjs(bytes32);\n\n\tvar idna = createCommonjsModule(function (module, exports) {\n\t\"use strict\";\n\tObject.defineProperty(exports, \"__esModule\", { value: true });\n\texports.nameprep = exports._nameprepTableC = exports._nameprepTableB2 = exports._nameprepTableA1 = void 0;\n\n\tfunction bytes2(data) {\n\t    if ((data.length % 4) !== 0) {\n\t        throw new Error(\"bad data\");\n\t    }\n\t    var result = [];\n\t    for (var i = 0; i < data.length; i += 4) {\n\t        result.push(parseInt(data.substring(i, i + 4), 16));\n\t    }\n\t    return result;\n\t}\n\tfunction createTable(data, func) {\n\t    if (!func) {\n\t        func = function (value) { return [parseInt(value, 16)]; };\n\t    }\n\t    var lo = 0;\n\t    var result = {};\n\t    data.split(\",\").forEach(function (pair) {\n\t        var comps = pair.split(\":\");\n\t        lo += parseInt(comps[0], 16);\n\t        result[lo] = func(comps[1]);\n\t    });\n\t    return result;\n\t}\n\tfunction createRangeTable(data) {\n\t    var hi = 0;\n\t    return data.split(\",\").map(function (v) {\n\t        var comps = v.split(\"-\");\n\t        if (comps.length === 1) {\n\t            comps[1] = \"0\";\n\t        }\n\t        else if (comps[1] === \"\") {\n\t            comps[1] = \"1\";\n\t        }\n\t        var lo = hi + parseInt(comps[0], 16);\n\t        hi = parseInt(comps[1], 16);\n\t        return { l: lo, h: hi };\n\t    });\n\t}\n\tfunction matchMap(value, ranges) {\n\t    var lo = 0;\n\t    for (var i = 0; i < ranges.length; i++) {\n\t        var range = ranges[i];\n\t        lo += range.l;\n\t        if (value >= lo && value <= lo + range.h && ((value - lo) % (range.d || 1)) === 0) {\n\t            if (range.e && range.e.indexOf(value - lo) !== -1) {\n\t                continue;\n\t            }\n\t            return range;\n\t        }\n\t    }\n\t    return null;\n\t}\n\tvar Table_A_1_ranges = createRangeTable(\"221,13-1b,5f-,40-10,51-f,11-3,3-3,2-2,2-4,8,2,15,2d,28-8,88,48,27-,3-5,11-20,27-,8,28,3-5,12,18,b-a,1c-4,6-16,2-d,2-2,2,1b-4,17-9,8f-,10,f,1f-2,1c-34,33-14e,4,36-,13-,6-2,1a-f,4,9-,3-,17,8,2-2,5-,2,8-,3-,4-8,2-3,3,6-,16-6,2-,7-3,3-,17,8,3,3,3-,2,6-3,3-,4-a,5,2-6,10-b,4,8,2,4,17,8,3,6-,b,4,4-,2-e,2-4,b-10,4,9-,3-,17,8,3-,5-,9-2,3-,4-7,3-3,3,4-3,c-10,3,7-2,4,5-2,3,2,3-2,3-2,4-2,9,4-3,6-2,4,5-8,2-e,d-d,4,9,4,18,b,6-3,8,4,5-6,3-8,3-3,b-11,3,9,4,18,b,6-3,8,4,5-6,3-6,2,3-3,b-11,3,9,4,18,11-3,7-,4,5-8,2-7,3-3,b-11,3,13-2,19,a,2-,8-2,2-3,7,2,9-11,4-b,3b-3,1e-24,3,2-,3,2-,2-5,5,8,4,2,2-,3,e,4-,6,2,7-,b-,3-21,49,23-5,1c-3,9,25,10-,2-2f,23,6,3,8-2,5-5,1b-45,27-9,2a-,2-3,5b-4,45-4,53-5,8,40,2,5-,8,2,5-,28,2,5-,20,2,5-,8,2,5-,8,8,18,20,2,5-,8,28,14-5,1d-22,56-b,277-8,1e-2,52-e,e,8-a,18-8,15-b,e,4,3-b,5e-2,b-15,10,b-5,59-7,2b-555,9d-3,5b-5,17-,7-,27-,7-,9,2,2,2,20-,36,10,f-,7,14-,4,a,54-3,2-6,6-5,9-,1c-10,13-1d,1c-14,3c-,10-6,32-b,240-30,28-18,c-14,a0,115-,3,66-,b-76,5,5-,1d,24,2,5-2,2,8-,35-2,19,f-10,1d-3,311-37f,1b,5a-b,d7-19,d-3,41,57-,68-4,29-3,5f,29-37,2e-2,25-c,2c-2,4e-3,30,78-3,64-,20,19b7-49,51a7-59,48e-2,38-738,2ba5-5b,222f-,3c-94,8-b,6-4,1b,6,2,3,3,6d-20,16e-f,41-,37-7,2e-2,11-f,5-b,18-,b,14,5-3,6,88-,2,bf-2,7-,7-,7-,4-2,8,8-9,8-2ff,20,5-b,1c-b4,27-,27-cbb1,f7-9,28-2,b5-221,56,48,3-,2-,3-,5,d,2,5,3,42,5-,9,8,1d,5,6,2-2,8,153-3,123-3,33-27fd,a6da-5128,21f-5df,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3,2-1d,61-ff7d\");\n\t// @TODO: Make this relative...\n\tvar Table_B_1_flags = \"ad,34f,1806,180b,180c,180d,200b,200c,200d,2060,feff\".split(\",\").map(function (v) { return parseInt(v, 16); });\n\tvar Table_B_2_ranges = [\n\t    { h: 25, s: 32, l: 65 },\n\t    { h: 30, s: 32, e: [23], l: 127 },\n\t    { h: 54, s: 1, e: [48], l: 64, d: 2 },\n\t    { h: 14, s: 1, l: 57, d: 2 },\n\t    { h: 44, s: 1, l: 17, d: 2 },\n\t    { h: 10, s: 1, e: [2, 6, 8], l: 61, d: 2 },\n\t    { h: 16, s: 1, l: 68, d: 2 },\n\t    { h: 84, s: 1, e: [18, 24, 66], l: 19, d: 2 },\n\t    { h: 26, s: 32, e: [17], l: 435 },\n\t    { h: 22, s: 1, l: 71, d: 2 },\n\t    { h: 15, s: 80, l: 40 },\n\t    { h: 31, s: 32, l: 16 },\n\t    { h: 32, s: 1, l: 80, d: 2 },\n\t    { h: 52, s: 1, l: 42, d: 2 },\n\t    { h: 12, s: 1, l: 55, d: 2 },\n\t    { h: 40, s: 1, e: [38], l: 15, d: 2 },\n\t    { h: 14, s: 1, l: 48, d: 2 },\n\t    { h: 37, s: 48, l: 49 },\n\t    { h: 148, s: 1, l: 6351, d: 2 },\n\t    { h: 88, s: 1, l: 160, d: 2 },\n\t    { h: 15, s: 16, l: 704 },\n\t    { h: 25, s: 26, l: 854 },\n\t    { h: 25, s: 32, l: 55915 },\n\t    { h: 37, s: 40, l: 1247 },\n\t    { h: 25, s: -119711, l: 53248 },\n\t    { h: 25, s: -119763, l: 52 },\n\t    { h: 25, s: -119815, l: 52 },\n\t    { h: 25, s: -119867, e: [1, 4, 5, 7, 8, 11, 12, 17], l: 52 },\n\t    { h: 25, s: -119919, l: 52 },\n\t    { h: 24, s: -119971, e: [2, 7, 8, 17], l: 52 },\n\t    { h: 24, s: -120023, e: [2, 7, 13, 15, 16, 17], l: 52 },\n\t    { h: 25, s: -120075, l: 52 },\n\t    { h: 25, s: -120127, l: 52 },\n\t    { h: 25, s: -120179, l: 52 },\n\t    { h: 25, s: -120231, l: 52 },\n\t    { h: 25, s: -120283, l: 52 },\n\t    { h: 25, s: -120335, l: 52 },\n\t    { h: 24, s: -119543, e: [17], l: 56 },\n\t    { h: 24, s: -119601, e: [17], l: 58 },\n\t    { h: 24, s: -119659, e: [17], l: 58 },\n\t    { h: 24, s: -119717, e: [17], l: 58 },\n\t    { h: 24, s: -119775, e: [17], l: 58 }\n\t];\n\tvar Table_B_2_lut_abs = createTable(\"b5:3bc,c3:ff,7:73,2:253,5:254,3:256,1:257,5:259,1:25b,3:260,1:263,2:269,1:268,5:26f,1:272,2:275,7:280,3:283,5:288,3:28a,1:28b,5:292,3f:195,1:1bf,29:19e,125:3b9,8b:3b2,1:3b8,1:3c5,3:3c6,1:3c0,1a:3ba,1:3c1,1:3c3,2:3b8,1:3b5,1bc9:3b9,1c:1f76,1:1f77,f:1f7a,1:1f7b,d:1f78,1:1f79,1:1f7c,1:1f7d,107:63,5:25b,4:68,1:68,1:68,3:69,1:69,1:6c,3:6e,4:70,1:71,1:72,1:72,1:72,7:7a,2:3c9,2:7a,2:6b,1:e5,1:62,1:63,3:65,1:66,2:6d,b:3b3,1:3c0,6:64,1b574:3b8,1a:3c3,20:3b8,1a:3c3,20:3b8,1a:3c3,20:3b8,1a:3c3,20:3b8,1a:3c3\");\n\tvar Table_B_2_lut_rel = createTable(\"179:1,2:1,2:1,5:1,2:1,a:4f,a:1,8:1,2:1,2:1,3:1,5:1,3:1,4:1,2:1,3:1,4:1,8:2,1:1,2:2,1:1,2:2,27:2,195:26,2:25,1:25,1:25,2:40,2:3f,1:3f,33:1,11:-6,1:-9,1ac7:-3a,6d:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,9:-8,1:-8,1:-8,1:-8,1:-8,1:-8,b:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,9:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,9:-8,1:-8,1:-8,1:-8,1:-8,1:-8,c:-8,2:-8,2:-8,2:-8,9:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,49:-8,1:-8,1:-4a,1:-4a,d:-56,1:-56,1:-56,1:-56,d:-8,1:-8,f:-8,1:-8,3:-7\");\n\tvar Table_B_2_complex = createTable(\"df:00730073,51:00690307,19:02BC006E,a7:006A030C,18a:002003B9,16:03B903080301,20:03C503080301,1d7:05650582,190f:00680331,1:00740308,1:0077030A,1:0079030A,1:006102BE,b6:03C50313,2:03C503130300,2:03C503130301,2:03C503130342,2a:1F0003B9,1:1F0103B9,1:1F0203B9,1:1F0303B9,1:1F0403B9,1:1F0503B9,1:1F0603B9,1:1F0703B9,1:1F0003B9,1:1F0103B9,1:1F0203B9,1:1F0303B9,1:1F0403B9,1:1F0503B9,1:1F0603B9,1:1F0703B9,1:1F2003B9,1:1F2103B9,1:1F2203B9,1:1F2303B9,1:1F2403B9,1:1F2503B9,1:1F2603B9,1:1F2703B9,1:1F2003B9,1:1F2103B9,1:1F2203B9,1:1F2303B9,1:1F2403B9,1:1F2503B9,1:1F2603B9,1:1F2703B9,1:1F6003B9,1:1F6103B9,1:1F6203B9,1:1F6303B9,1:1F6403B9,1:1F6503B9,1:1F6603B9,1:1F6703B9,1:1F6003B9,1:1F6103B9,1:1F6203B9,1:1F6303B9,1:1F6403B9,1:1F6503B9,1:1F6603B9,1:1F6703B9,3:1F7003B9,1:03B103B9,1:03AC03B9,2:03B10342,1:03B1034203B9,5:03B103B9,6:1F7403B9,1:03B703B9,1:03AE03B9,2:03B70342,1:03B7034203B9,5:03B703B9,6:03B903080300,1:03B903080301,3:03B90342,1:03B903080342,b:03C503080300,1:03C503080301,1:03C10313,2:03C50342,1:03C503080342,b:1F7C03B9,1:03C903B9,1:03CE03B9,2:03C90342,1:03C9034203B9,5:03C903B9,ac:00720073,5b:00B00063,6:00B00066,d:006E006F,a:0073006D,1:00740065006C,1:0074006D,124f:006800700061,2:00610075,2:006F0076,b:00700061,1:006E0061,1:03BC0061,1:006D0061,1:006B0061,1:006B0062,1:006D0062,1:00670062,3:00700066,1:006E0066,1:03BC0066,4:0068007A,1:006B0068007A,1:006D0068007A,1:00670068007A,1:00740068007A,15:00700061,1:006B00700061,1:006D00700061,1:006700700061,8:00700076,1:006E0076,1:03BC0076,1:006D0076,1:006B0076,1:006D0076,1:00700077,1:006E0077,1:03BC0077,1:006D0077,1:006B0077,1:006D0077,1:006B03C9,1:006D03C9,2:00620071,3:00632215006B0067,1:0063006F002E,1:00640062,1:00670079,2:00680070,2:006B006B,1:006B006D,9:00700068,2:00700070006D,1:00700072,2:00730076,1:00770062,c723:00660066,1:00660069,1:0066006C,1:006600660069,1:00660066006C,1:00730074,1:00730074,d:05740576,1:05740565,1:0574056B,1:057E0576,1:0574056D\", bytes2);\n\tvar Table_C_ranges = createRangeTable(\"80-20,2a0-,39c,32,f71,18e,7f2-f,19-7,30-4,7-5,f81-b,5,a800-20ff,4d1-1f,110,fa-6,d174-7,2e84-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,2,1f-5f,ff7f-20001\");\n\tfunction flatten(values) {\n\t    return values.reduce(function (accum, value) {\n\t        value.forEach(function (value) { accum.push(value); });\n\t        return accum;\n\t    }, []);\n\t}\n\tfunction _nameprepTableA1(codepoint) {\n\t    return !!matchMap(codepoint, Table_A_1_ranges);\n\t}\n\texports._nameprepTableA1 = _nameprepTableA1;\n\tfunction _nameprepTableB2(codepoint) {\n\t    var range = matchMap(codepoint, Table_B_2_ranges);\n\t    if (range) {\n\t        return [codepoint + range.s];\n\t    }\n\t    var codes = Table_B_2_lut_abs[codepoint];\n\t    if (codes) {\n\t        return codes;\n\t    }\n\t    var shift = Table_B_2_lut_rel[codepoint];\n\t    if (shift) {\n\t        return [codepoint + shift[0]];\n\t    }\n\t    var complex = Table_B_2_complex[codepoint];\n\t    if (complex) {\n\t        return complex;\n\t    }\n\t    return null;\n\t}\n\texports._nameprepTableB2 = _nameprepTableB2;\n\tfunction _nameprepTableC(codepoint) {\n\t    return !!matchMap(codepoint, Table_C_ranges);\n\t}\n\texports._nameprepTableC = _nameprepTableC;\n\tfunction nameprep(value) {\n\t    // This allows platforms with incomplete normalize to bypass\n\t    // it for very basic names which the built-in toLowerCase\n\t    // will certainly handle correctly\n\t    if (value.match(/^[a-z0-9-]*$/i) && value.length <= 59) {\n\t        return value.toLowerCase();\n\t    }\n\t    // Get the code points (keeping the current normalization)\n\t    var codes = (0, utf8.toUtf8CodePoints)(value);\n\t    codes = flatten(codes.map(function (code) {\n\t        // Substitute Table B.1 (Maps to Nothing)\n\t        if (Table_B_1_flags.indexOf(code) >= 0) {\n\t            return [];\n\t        }\n\t        if (code >= 0xfe00 && code <= 0xfe0f) {\n\t            return [];\n\t        }\n\t        // Substitute Table B.2 (Case Folding)\n\t        var codesTableB2 = _nameprepTableB2(code);\n\t        if (codesTableB2) {\n\t            return codesTableB2;\n\t        }\n\t        // No Substitution\n\t        return [code];\n\t    }));\n\t    // Normalize using form KC\n\t    codes = (0, utf8.toUtf8CodePoints)((0, utf8._toUtf8String)(codes), utf8.UnicodeNormalizationForm.NFKC);\n\t    // Prohibit Tables C.1.2, C.2.2, C.3, C.4, C.5, C.6, C.7, C.8, C.9\n\t    codes.forEach(function (code) {\n\t        if (_nameprepTableC(code)) {\n\t            throw new Error(\"STRINGPREP_CONTAINS_PROHIBITED\");\n\t        }\n\t    });\n\t    // Prohibit Unassigned Code Points (Table A.1)\n\t    codes.forEach(function (code) {\n\t        if (_nameprepTableA1(code)) {\n\t            throw new Error(\"STRINGPREP_CONTAINS_UNASSIGNED\");\n\t        }\n\t    });\n\t    // IDNA extras\n\t    var name = (0, utf8._toUtf8String)(codes);\n\t    // IDNA: 4.2.3.1\n\t    if (name.substring(0, 1) === \"-\" || name.substring(2, 4) === \"--\" || name.substring(name.length - 1) === \"-\") {\n\t        throw new Error(\"invalid hyphen\");\n\t    }\n\t    // IDNA: 4.2.4\n\t    if (name.length > 63) {\n\t        throw new Error(\"too long\");\n\t    }\n\t    return name;\n\t}\n\texports.nameprep = nameprep;\n\n\t});\n\n\tvar idna$1 = /*@__PURE__*/getDefaultExportFromCjs(idna);\n\n\tvar lib$8 = createCommonjsModule(function (module, exports) {\n\t\"use strict\";\n\tObject.defineProperty(exports, \"__esModule\", { value: true });\n\texports.nameprep = exports.parseBytes32String = exports.formatBytes32String = exports.UnicodeNormalizationForm = exports.Utf8ErrorReason = exports.Utf8ErrorFuncs = exports.toUtf8String = exports.toUtf8CodePoints = exports.toUtf8Bytes = exports._toEscapedUtf8String = void 0;\n\n\tObject.defineProperty(exports, \"formatBytes32String\", { enumerable: true, get: function () { return bytes32.formatBytes32String; } });\n\tObject.defineProperty(exports, \"parseBytes32String\", { enumerable: true, get: function () { return bytes32.parseBytes32String; } });\n\n\tObject.defineProperty(exports, \"nameprep\", { enumerable: true, get: function () { return idna.nameprep; } });\n\n\tObject.defineProperty(exports, \"_toEscapedUtf8String\", { enumerable: true, get: function () { return utf8._toEscapedUtf8String; } });\n\tObject.defineProperty(exports, \"toUtf8Bytes\", { enumerable: true, get: function () { return utf8.toUtf8Bytes; } });\n\tObject.defineProperty(exports, \"toUtf8CodePoints\", { enumerable: true, get: function () { return utf8.toUtf8CodePoints; } });\n\tObject.defineProperty(exports, \"toUtf8String\", { enumerable: true, get: function () { return utf8.toUtf8String; } });\n\tObject.defineProperty(exports, \"UnicodeNormalizationForm\", { enumerable: true, get: function () { return utf8.UnicodeNormalizationForm; } });\n\tObject.defineProperty(exports, \"Utf8ErrorFuncs\", { enumerable: true, get: function () { return utf8.Utf8ErrorFuncs; } });\n\tObject.defineProperty(exports, \"Utf8ErrorReason\", { enumerable: true, get: function () { return utf8.Utf8ErrorReason; } });\n\n\t});\n\n\tvar index$8 = /*@__PURE__*/getDefaultExportFromCjs(lib$8);\n\n\tvar string = createCommonjsModule(function (module, exports) {\n\t\"use strict\";\n\tvar __extends = (commonjsGlobal && commonjsGlobal.__extends) || (function () {\n\t    var extendStatics = function (d, b) {\n\t        extendStatics = Object.setPrototypeOf ||\n\t            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n\t            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n\t        return extendStatics(d, b);\n\t    };\n\t    return function (d, b) {\n\t        if (typeof b !== \"function\" && b !== null)\n\t            throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n\t        extendStatics(d, b);\n\t        function __() { this.constructor = d; }\n\t        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n\t    };\n\t})();\n\tObject.defineProperty(exports, \"__esModule\", { value: true });\n\texports.StringCoder = void 0;\n\n\n\tvar StringCoder = /** @class */ (function (_super) {\n\t    __extends(StringCoder, _super);\n\t    function StringCoder(localName) {\n\t        return _super.call(this, \"string\", localName) || this;\n\t    }\n\t    StringCoder.prototype.defaultValue = function () {\n\t        return \"\";\n\t    };\n\t    StringCoder.prototype.encode = function (writer, value) {\n\t        return _super.prototype.encode.call(this, writer, (0, lib$8.toUtf8Bytes)(value));\n\t    };\n\t    StringCoder.prototype.decode = function (reader) {\n\t        return (0, lib$8.toUtf8String)(_super.prototype.decode.call(this, reader));\n\t    };\n\t    return StringCoder;\n\t}(bytes.DynamicBytesCoder));\n\texports.StringCoder = StringCoder;\n\n\t});\n\n\tvar string$1 = /*@__PURE__*/getDefaultExportFromCjs(string);\n\n\tvar tuple = createCommonjsModule(function (module, exports) {\n\t\"use strict\";\n\tvar __extends = (commonjsGlobal && commonjsGlobal.__extends) || (function () {\n\t    var extendStatics = function (d, b) {\n\t        extendStatics = Object.setPrototypeOf ||\n\t            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n\t            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n\t        return extendStatics(d, b);\n\t    };\n\t    return function (d, b) {\n\t        if (typeof b !== \"function\" && b !== null)\n\t            throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n\t        extendStatics(d, b);\n\t        function __() { this.constructor = d; }\n\t        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n\t    };\n\t})();\n\tObject.defineProperty(exports, \"__esModule\", { value: true });\n\texports.TupleCoder = void 0;\n\n\n\tvar TupleCoder = /** @class */ (function (_super) {\n\t    __extends(TupleCoder, _super);\n\t    function TupleCoder(coders, localName) {\n\t        var _this = this;\n\t        var dynamic = false;\n\t        var types = [];\n\t        coders.forEach(function (coder) {\n\t            if (coder.dynamic) {\n\t                dynamic = true;\n\t            }\n\t            types.push(coder.type);\n\t        });\n\t        var type = (\"tuple(\" + types.join(\",\") + \")\");\n\t        _this = _super.call(this, \"tuple\", type, localName, dynamic) || this;\n\t        _this.coders = coders;\n\t        return _this;\n\t    }\n\t    TupleCoder.prototype.defaultValue = function () {\n\t        var values = [];\n\t        this.coders.forEach(function (coder) {\n\t            values.push(coder.defaultValue());\n\t        });\n\t        // We only output named properties for uniquely named coders\n\t        var uniqueNames = this.coders.reduce(function (accum, coder) {\n\t            var name = coder.localName;\n\t            if (name) {\n\t                if (!accum[name]) {\n\t                    accum[name] = 0;\n\t                }\n\t                accum[name]++;\n\t            }\n\t            return accum;\n\t        }, {});\n\t        // Add named values\n\t        this.coders.forEach(function (coder, index) {\n\t            var name = coder.localName;\n\t            if (!name || uniqueNames[name] !== 1) {\n\t                return;\n\t            }\n\t            if (name === \"length\") {\n\t                name = \"_length\";\n\t            }\n\t            if (values[name] != null) {\n\t                return;\n\t            }\n\t            values[name] = values[index];\n\t        });\n\t        return Object.freeze(values);\n\t    };\n\t    TupleCoder.prototype.encode = function (writer, value) {\n\t        return (0, array.pack)(writer, this.coders, value);\n\t    };\n\t    TupleCoder.prototype.decode = function (reader) {\n\t        return reader.coerce(this.name, (0, array.unpack)(reader, this.coders));\n\t    };\n\t    return TupleCoder;\n\t}(abstractCoder.Coder));\n\texports.TupleCoder = TupleCoder;\n\n\t});\n\n\tvar tuple$1 = /*@__PURE__*/getDefaultExportFromCjs(tuple);\n\n\tvar abiCoder = createCommonjsModule(function (module, exports) {\n\t\"use strict\";\n\tObject.defineProperty(exports, \"__esModule\", { value: true });\n\texports.defaultAbiCoder = exports.AbiCoder = void 0;\n\t// See: https://github.com/ethereum/wiki/wiki/Ethereum-Contract-ABI\n\n\n\n\n\tvar logger = new lib.Logger(_version$8.version);\n\n\n\n\n\n\n\n\n\n\n\n\tvar paramTypeBytes = new RegExp(/^bytes([0-9]*)$/);\n\tvar paramTypeNumber = new RegExp(/^(u?int)([0-9]*)$/);\n\tvar AbiCoder = /** @class */ (function () {\n\t    function AbiCoder(coerceFunc) {\n\t        var _newTarget = this.constructor;\n\t        logger.checkNew(_newTarget, AbiCoder);\n\t        (0, lib$3.defineReadOnly)(this, \"coerceFunc\", coerceFunc || null);\n\t    }\n\t    AbiCoder.prototype._getCoder = function (param) {\n\t        var _this = this;\n\t        switch (param.baseType) {\n\t            case \"address\":\n\t                return new address.AddressCoder(param.name);\n\t            case \"bool\":\n\t                return new boolean_1.BooleanCoder(param.name);\n\t            case \"string\":\n\t                return new string.StringCoder(param.name);\n\t            case \"bytes\":\n\t                return new bytes.BytesCoder(param.name);\n\t            case \"array\":\n\t                return new array.ArrayCoder(this._getCoder(param.arrayChildren), param.arrayLength, param.name);\n\t            case \"tuple\":\n\t                return new tuple.TupleCoder((param.components || []).map(function (component) {\n\t                    return _this._getCoder(component);\n\t                }), param.name);\n\t            case \"\":\n\t                return new _null.NullCoder(param.name);\n\t        }\n\t        // u?int[0-9]*\n\t        var match = param.type.match(paramTypeNumber);\n\t        if (match) {\n\t            var size = parseInt(match[2] || \"256\");\n\t            if (size === 0 || size > 256 || (size % 8) !== 0) {\n\t                logger.throwArgumentError(\"invalid \" + match[1] + \" bit length\", \"param\", param);\n\t            }\n\t            return new number.NumberCoder(size / 8, (match[1] === \"int\"), param.name);\n\t        }\n\t        // bytes[0-9]+\n\t        match = param.type.match(paramTypeBytes);\n\t        if (match) {\n\t            var size = parseInt(match[1]);\n\t            if (size === 0 || size > 32) {\n\t                logger.throwArgumentError(\"invalid bytes length\", \"param\", param);\n\t            }\n\t            return new fixedBytes.FixedBytesCoder(size, param.name);\n\t        }\n\t        return logger.throwArgumentError(\"invalid type\", \"type\", param.type);\n\t    };\n\t    AbiCoder.prototype._getWordSize = function () { return 32; };\n\t    AbiCoder.prototype._getReader = function (data, allowLoose) {\n\t        return new abstractCoder.Reader(data, this._getWordSize(), this.coerceFunc, allowLoose);\n\t    };\n\t    AbiCoder.prototype._getWriter = function () {\n\t        return new abstractCoder.Writer(this._getWordSize());\n\t    };\n\t    AbiCoder.prototype.getDefaultValue = function (types) {\n\t        var _this = this;\n\t        var coders = types.map(function (type) { return _this._getCoder(fragments.ParamType.from(type)); });\n\t        var coder = new tuple.TupleCoder(coders, \"_\");\n\t        return coder.defaultValue();\n\t    };\n\t    AbiCoder.prototype.encode = function (types, values) {\n\t        var _this = this;\n\t        if (types.length !== values.length) {\n\t            logger.throwError(\"types/values length mismatch\", lib.Logger.errors.INVALID_ARGUMENT, {\n\t                count: { types: types.length, values: values.length },\n\t                value: { types: types, values: values }\n\t            });\n\t        }\n\t        var coders = types.map(function (type) { return _this._getCoder(fragments.ParamType.from(type)); });\n\t        var coder = (new tuple.TupleCoder(coders, \"_\"));\n\t        var writer = this._getWriter();\n\t        coder.encode(writer, values);\n\t        return writer.data;\n\t    };\n\t    AbiCoder.prototype.decode = function (types, data, loose) {\n\t        var _this = this;\n\t        var coders = types.map(function (type) { return _this._getCoder(fragments.ParamType.from(type)); });\n\t        var coder = new tuple.TupleCoder(coders, \"_\");\n\t        return coder.decode(this._getReader((0, lib$1.arrayify)(data), loose));\n\t    };\n\t    return AbiCoder;\n\t}());\n\texports.AbiCoder = AbiCoder;\n\texports.defaultAbiCoder = new AbiCoder();\n\n\t});\n\n\tvar abiCoder$1 = /*@__PURE__*/getDefaultExportFromCjs(abiCoder);\n\n\tvar id_1 = createCommonjsModule(function (module, exports) {\n\t\"use strict\";\n\tObject.defineProperty(exports, \"__esModule\", { value: true });\n\texports.id = void 0;\n\n\n\tfunction id(text) {\n\t    return (0, lib$4.keccak256)((0, lib$8.toUtf8Bytes)(text));\n\t}\n\texports.id = id;\n\n\t});\n\n\tvar id = /*@__PURE__*/getDefaultExportFromCjs(id_1);\n\n\tvar _version$g = createCommonjsModule(function (module, exports) {\n\t\"use strict\";\n\tObject.defineProperty(exports, \"__esModule\", { value: true });\n\texports.version = void 0;\n\texports.version = \"hash/5.5.0\";\n\n\t});\n\n\tvar _version$h = /*@__PURE__*/getDefaultExportFromCjs(_version$g);\n\n\tvar namehash_1 = createCommonjsModule(function (module, exports) {\n\t\"use strict\";\n\tObject.defineProperty(exports, \"__esModule\", { value: true });\n\texports.namehash = exports.isValidName = void 0;\n\n\n\n\n\n\tvar logger = new lib.Logger(_version$g.version);\n\tvar Zeros = new Uint8Array(32);\n\tZeros.fill(0);\n\tvar Partition = new RegExp(\"^((.*)\\\\.)?([^.]+)$\");\n\tfunction isValidName(name) {\n\t    try {\n\t        var comps = name.split(\".\");\n\t        for (var i = 0; i < comps.length; i++) {\n\t            if ((0, lib$8.nameprep)(comps[i]).length === 0) {\n\t                throw new Error(\"empty\");\n\t            }\n\t        }\n\t        return true;\n\t    }\n\t    catch (error) { }\n\t    return false;\n\t}\n\texports.isValidName = isValidName;\n\tfunction namehash(name) {\n\t    /* istanbul ignore if */\n\t    if (typeof (name) !== \"string\") {\n\t        logger.throwArgumentError(\"invalid ENS name; not a string\", \"name\", name);\n\t    }\n\t    var current = name;\n\t    var result = Zeros;\n\t    while (current.length) {\n\t        var partition = current.match(Partition);\n\t        if (partition == null || partition[2] === \"\") {\n\t            logger.throwArgumentError(\"invalid ENS address; missing component\", \"name\", name);\n\t        }\n\t        var label = (0, lib$8.toUtf8Bytes)((0, lib$8.nameprep)(partition[3]));\n\t        result = (0, lib$4.keccak256)((0, lib$1.concat)([result, (0, lib$4.keccak256)(label)]));\n\t        current = partition[2] || \"\";\n\t    }\n\t    return (0, lib$1.hexlify)(result);\n\t}\n\texports.namehash = namehash;\n\n\t});\n\n\tvar namehash = /*@__PURE__*/getDefaultExportFromCjs(namehash_1);\n\n\tvar message = createCommonjsModule(function (module, exports) {\n\t\"use strict\";\n\tObject.defineProperty(exports, \"__esModule\", { value: true });\n\texports.hashMessage = exports.messagePrefix = void 0;\n\n\n\n\texports.messagePrefix = \"\\x19Ethereum Signed Message:\\n\";\n\tfunction hashMessage(message) {\n\t    if (typeof (message) === \"string\") {\n\t        message = (0, lib$8.toUtf8Bytes)(message);\n\t    }\n\t    return (0, lib$4.keccak256)((0, lib$1.concat)([\n\t        (0, lib$8.toUtf8Bytes)(exports.messagePrefix),\n\t        (0, lib$8.toUtf8Bytes)(String(message.length)),\n\t        message\n\t    ]));\n\t}\n\texports.hashMessage = hashMessage;\n\n\t});\n\n\tvar message$1 = /*@__PURE__*/getDefaultExportFromCjs(message);\n\n\tvar typedData = createCommonjsModule(function (module, exports) {\n\t\"use strict\";\n\tvar __awaiter = (commonjsGlobal && commonjsGlobal.__awaiter) || function (thisArg, _arguments, P, generator) {\n\t    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n\t    return new (P || (P = Promise))(function (resolve, reject) {\n\t        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n\t        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n\t        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n\t        step((generator = generator.apply(thisArg, _arguments || [])).next());\n\t    });\n\t};\n\tvar __generator = (commonjsGlobal && commonjsGlobal.__generator) || function (thisArg, body) {\n\t    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\n\t    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\n\t    function verb(n) { return function (v) { return step([n, v]); }; }\n\t    function step(op) {\n\t        if (f) throw new TypeError(\"Generator is already executing.\");\n\t        while (_) try {\n\t            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n\t            if (y = 0, t) op = [op[0] & 2, t.value];\n\t            switch (op[0]) {\n\t                case 0: case 1: t = op; break;\n\t                case 4: _.label++; return { value: op[1], done: false };\n\t                case 5: _.label++; y = op[1]; op = [0]; continue;\n\t                case 7: op = _.ops.pop(); _.trys.pop(); continue;\n\t                default:\n\t                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\n\t                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\n\t                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\n\t                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\n\t                    if (t[2]) _.ops.pop();\n\t                    _.trys.pop(); continue;\n\t            }\n\t            op = body.call(thisArg, _);\n\t        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\n\t        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\n\t    }\n\t};\n\tObject.defineProperty(exports, \"__esModule\", { value: true });\n\texports.TypedDataEncoder = void 0;\n\n\n\n\n\n\n\n\tvar logger = new lib.Logger(_version$g.version);\n\n\tvar padding = new Uint8Array(32);\n\tpadding.fill(0);\n\tvar NegativeOne = lib$2.BigNumber.from(-1);\n\tvar Zero = lib$2.BigNumber.from(0);\n\tvar One = lib$2.BigNumber.from(1);\n\tvar MaxUint256 = lib$2.BigNumber.from(\"0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\");\n\tfunction hexPadRight(value) {\n\t    var bytes = (0, lib$1.arrayify)(value);\n\t    var padOffset = bytes.length % 32;\n\t    if (padOffset) {\n\t        return (0, lib$1.hexConcat)([bytes, padding.slice(padOffset)]);\n\t    }\n\t    return (0, lib$1.hexlify)(bytes);\n\t}\n\tvar hexTrue = (0, lib$1.hexZeroPad)(One.toHexString(), 32);\n\tvar hexFalse = (0, lib$1.hexZeroPad)(Zero.toHexString(), 32);\n\tvar domainFieldTypes = {\n\t    name: \"string\",\n\t    version: \"string\",\n\t    chainId: \"uint256\",\n\t    verifyingContract: \"address\",\n\t    salt: \"bytes32\"\n\t};\n\tvar domainFieldNames = [\n\t    \"name\", \"version\", \"chainId\", \"verifyingContract\", \"salt\"\n\t];\n\tfunction checkString(key) {\n\t    return function (value) {\n\t        if (typeof (value) !== \"string\") {\n\t            logger.throwArgumentError(\"invalid domain value for \" + JSON.stringify(key), \"domain.\" + key, value);\n\t        }\n\t        return value;\n\t    };\n\t}\n\tvar domainChecks = {\n\t    name: checkString(\"name\"),\n\t    version: checkString(\"version\"),\n\t    chainId: function (value) {\n\t        try {\n\t            return lib$2.BigNumber.from(value).toString();\n\t        }\n\t        catch (error) { }\n\t        return logger.throwArgumentError(\"invalid domain value for \\\"chainId\\\"\", \"domain.chainId\", value);\n\t    },\n\t    verifyingContract: function (value) {\n\t        try {\n\t            return (0, lib$6.getAddress)(value).toLowerCase();\n\t        }\n\t        catch (error) { }\n\t        return logger.throwArgumentError(\"invalid domain value \\\"verifyingContract\\\"\", \"domain.verifyingContract\", value);\n\t    },\n\t    salt: function (value) {\n\t        try {\n\t            var bytes = (0, lib$1.arrayify)(value);\n\t            if (bytes.length !== 32) {\n\t                throw new Error(\"bad length\");\n\t            }\n\t            return (0, lib$1.hexlify)(bytes);\n\t        }\n\t        catch (error) { }\n\t        return logger.throwArgumentError(\"invalid domain value \\\"salt\\\"\", \"domain.salt\", value);\n\t    }\n\t};\n\tfunction getBaseEncoder(type) {\n\t    // intXX and uintXX\n\t    {\n\t        var match = type.match(/^(u?)int(\\d*)$/);\n\t        if (match) {\n\t            var signed = (match[1] === \"\");\n\t            var width = parseInt(match[2] || \"256\");\n\t            if (width % 8 !== 0 || width > 256 || (match[2] && match[2] !== String(width))) {\n\t                logger.throwArgumentError(\"invalid numeric width\", \"type\", type);\n\t            }\n\t            var boundsUpper_1 = MaxUint256.mask(signed ? (width - 1) : width);\n\t            var boundsLower_1 = signed ? boundsUpper_1.add(One).mul(NegativeOne) : Zero;\n\t            return function (value) {\n\t                var v = lib$2.BigNumber.from(value);\n\t                if (v.lt(boundsLower_1) || v.gt(boundsUpper_1)) {\n\t                    logger.throwArgumentError(\"value out-of-bounds for \" + type, \"value\", value);\n\t                }\n\t                return (0, lib$1.hexZeroPad)(v.toTwos(256).toHexString(), 32);\n\t            };\n\t        }\n\t    }\n\t    // bytesXX\n\t    {\n\t        var match = type.match(/^bytes(\\d+)$/);\n\t        if (match) {\n\t            var width_1 = parseInt(match[1]);\n\t            if (width_1 === 0 || width_1 > 32 || match[1] !== String(width_1)) {\n\t                logger.throwArgumentError(\"invalid bytes width\", \"type\", type);\n\t            }\n\t            return function (value) {\n\t                var bytes = (0, lib$1.arrayify)(value);\n\t                if (bytes.length !== width_1) {\n\t                    logger.throwArgumentError(\"invalid length for \" + type, \"value\", value);\n\t                }\n\t                return hexPadRight(value);\n\t            };\n\t        }\n\t    }\n\t    switch (type) {\n\t        case \"address\": return function (value) {\n\t            return (0, lib$1.hexZeroPad)((0, lib$6.getAddress)(value), 32);\n\t        };\n\t        case \"bool\": return function (value) {\n\t            return ((!value) ? hexFalse : hexTrue);\n\t        };\n\t        case \"bytes\": return function (value) {\n\t            return (0, lib$4.keccak256)(value);\n\t        };\n\t        case \"string\": return function (value) {\n\t            return (0, id_1.id)(value);\n\t        };\n\t    }\n\t    return null;\n\t}\n\tfunction encodeType(name, fields) {\n\t    return name + \"(\" + fields.map(function (_a) {\n\t        var name = _a.name, type = _a.type;\n\t        return (type + \" \" + name);\n\t    }).join(\",\") + \")\";\n\t}\n\tvar TypedDataEncoder = /** @class */ (function () {\n\t    function TypedDataEncoder(types) {\n\t        (0, lib$3.defineReadOnly)(this, \"types\", Object.freeze((0, lib$3.deepCopy)(types)));\n\t        (0, lib$3.defineReadOnly)(this, \"_encoderCache\", {});\n\t        (0, lib$3.defineReadOnly)(this, \"_types\", {});\n\t        // Link struct types to their direct child structs\n\t        var links = {};\n\t        // Link structs to structs which contain them as a child\n\t        var parents = {};\n\t        // Link all subtypes within a given struct\n\t        var subtypes = {};\n\t        Object.keys(types).forEach(function (type) {\n\t            links[type] = {};\n\t            parents[type] = [];\n\t            subtypes[type] = {};\n\t        });\n\t        var _loop_1 = function (name_1) {\n\t            var uniqueNames = {};\n\t            types[name_1].forEach(function (field) {\n\t                // Check each field has a unique name\n\t                if (uniqueNames[field.name]) {\n\t                    logger.throwArgumentError(\"duplicate variable name \" + JSON.stringify(field.name) + \" in \" + JSON.stringify(name_1), \"types\", types);\n\t                }\n\t                uniqueNames[field.name] = true;\n\t                // Get the base type (drop any array specifiers)\n\t                var baseType = field.type.match(/^([^\\x5b]*)(\\x5b|$)/)[1];\n\t                if (baseType === name_1) {\n\t                    logger.throwArgumentError(\"circular type reference to \" + JSON.stringify(baseType), \"types\", types);\n\t                }\n\t                // Is this a base encoding type?\n\t                var encoder = getBaseEncoder(baseType);\n\t                if (encoder) {\n\t                    return;\n\t                }\n\t                if (!parents[baseType]) {\n\t                    logger.throwArgumentError(\"unknown type \" + JSON.stringify(baseType), \"types\", types);\n\t                }\n\t                // Add linkage\n\t                parents[baseType].push(name_1);\n\t                links[name_1][baseType] = true;\n\t            });\n\t        };\n\t        for (var name_1 in types) {\n\t            _loop_1(name_1);\n\t        }\n\t        // Deduce the primary type\n\t        var primaryTypes = Object.keys(parents).filter(function (n) { return (parents[n].length === 0); });\n\t        if (primaryTypes.length === 0) {\n\t            logger.throwArgumentError(\"missing primary type\", \"types\", types);\n\t        }\n\t        else if (primaryTypes.length > 1) {\n\t            logger.throwArgumentError(\"ambiguous primary types or unused types: \" + primaryTypes.map(function (t) { return (JSON.stringify(t)); }).join(\", \"), \"types\", types);\n\t        }\n\t        (0, lib$3.defineReadOnly)(this, \"primaryType\", primaryTypes[0]);\n\t        // Check for circular type references\n\t        function checkCircular(type, found) {\n\t            if (found[type]) {\n\t                logger.throwArgumentError(\"circular type reference to \" + JSON.stringify(type), \"types\", types);\n\t            }\n\t            found[type] = true;\n\t            Object.keys(links[type]).forEach(function (child) {\n\t                if (!parents[child]) {\n\t                    return;\n\t                }\n\t                // Recursively check children\n\t                checkCircular(child, found);\n\t                // Mark all ancestors as having this decendant\n\t                Object.keys(found).forEach(function (subtype) {\n\t                    subtypes[subtype][child] = true;\n\t                });\n\t            });\n\t            delete found[type];\n\t        }\n\t        checkCircular(this.primaryType, {});\n\t        // Compute each fully describe type\n\t        for (var name_2 in subtypes) {\n\t            var st = Object.keys(subtypes[name_2]);\n\t            st.sort();\n\t            this._types[name_2] = encodeType(name_2, types[name_2]) + st.map(function (t) { return encodeType(t, types[t]); }).join(\"\");\n\t        }\n\t    }\n\t    TypedDataEncoder.prototype.getEncoder = function (type) {\n\t        var encoder = this._encoderCache[type];\n\t        if (!encoder) {\n\t            encoder = this._encoderCache[type] = this._getEncoder(type);\n\t        }\n\t        return encoder;\n\t    };\n\t    TypedDataEncoder.prototype._getEncoder = function (type) {\n\t        var _this = this;\n\t        // Basic encoder type (address, bool, uint256, etc)\n\t        {\n\t            var encoder = getBaseEncoder(type);\n\t            if (encoder) {\n\t                return encoder;\n\t            }\n\t        }\n\t        // Array\n\t        var match = type.match(/^(.*)(\\x5b(\\d*)\\x5d)$/);\n\t        if (match) {\n\t            var subtype_1 = match[1];\n\t            var subEncoder_1 = this.getEncoder(subtype_1);\n\t            var length_1 = parseInt(match[3]);\n\t            return function (value) {\n\t                if (length_1 >= 0 && value.length !== length_1) {\n\t                    logger.throwArgumentError(\"array length mismatch; expected length ${ arrayLength }\", \"value\", value);\n\t                }\n\t                var result = value.map(subEncoder_1);\n\t                if (_this._types[subtype_1]) {\n\t                    result = result.map(lib$4.keccak256);\n\t                }\n\t                return (0, lib$4.keccak256)((0, lib$1.hexConcat)(result));\n\t            };\n\t        }\n\t        // Struct\n\t        var fields = this.types[type];\n\t        if (fields) {\n\t            var encodedType_1 = (0, id_1.id)(this._types[type]);\n\t            return function (value) {\n\t                var values = fields.map(function (_a) {\n\t                    var name = _a.name, type = _a.type;\n\t                    var result = _this.getEncoder(type)(value[name]);\n\t                    if (_this._types[type]) {\n\t                        return (0, lib$4.keccak256)(result);\n\t                    }\n\t                    return result;\n\t                });\n\t                values.unshift(encodedType_1);\n\t                return (0, lib$1.hexConcat)(values);\n\t            };\n\t        }\n\t        return logger.throwArgumentError(\"unknown type: \" + type, \"type\", type);\n\t    };\n\t    TypedDataEncoder.prototype.encodeType = function (name) {\n\t        var result = this._types[name];\n\t        if (!result) {\n\t            logger.throwArgumentError(\"unknown type: \" + JSON.stringify(name), \"name\", name);\n\t        }\n\t        return result;\n\t    };\n\t    TypedDataEncoder.prototype.encodeData = function (type, value) {\n\t        return this.getEncoder(type)(value);\n\t    };\n\t    TypedDataEncoder.prototype.hashStruct = function (name, value) {\n\t        return (0, lib$4.keccak256)(this.encodeData(name, value));\n\t    };\n\t    TypedDataEncoder.prototype.encode = function (value) {\n\t        return this.encodeData(this.primaryType, value);\n\t    };\n\t    TypedDataEncoder.prototype.hash = function (value) {\n\t        return this.hashStruct(this.primaryType, value);\n\t    };\n\t    TypedDataEncoder.prototype._visit = function (type, value, callback) {\n\t        var _this = this;\n\t        // Basic encoder type (address, bool, uint256, etc)\n\t        {\n\t            var encoder = getBaseEncoder(type);\n\t            if (encoder) {\n\t                return callback(type, value);\n\t            }\n\t        }\n\t        // Array\n\t        var match = type.match(/^(.*)(\\x5b(\\d*)\\x5d)$/);\n\t        if (match) {\n\t            var subtype_2 = match[1];\n\t            var length_2 = parseInt(match[3]);\n\t            if (length_2 >= 0 && value.length !== length_2) {\n\t                logger.throwArgumentError(\"array length mismatch; expected length ${ arrayLength }\", \"value\", value);\n\t            }\n\t            return value.map(function (v) { return _this._visit(subtype_2, v, callback); });\n\t        }\n\t        // Struct\n\t        var fields = this.types[type];\n\t        if (fields) {\n\t            return fields.reduce(function (accum, _a) {\n\t                var name = _a.name, type = _a.type;\n\t                accum[name] = _this._visit(type, value[name], callback);\n\t                return accum;\n\t            }, {});\n\t        }\n\t        return logger.throwArgumentError(\"unknown type: \" + type, \"type\", type);\n\t    };\n\t    TypedDataEncoder.prototype.visit = function (value, callback) {\n\t        return this._visit(this.primaryType, value, callback);\n\t    };\n\t    TypedDataEncoder.from = function (types) {\n\t        return new TypedDataEncoder(types);\n\t    };\n\t    TypedDataEncoder.getPrimaryType = function (types) {\n\t        return TypedDataEncoder.from(types).primaryType;\n\t    };\n\t    TypedDataEncoder.hashStruct = function (name, types, value) {\n\t        return TypedDataEncoder.from(types).hashStruct(name, value);\n\t    };\n\t    TypedDataEncoder.hashDomain = function (domain) {\n\t        var domainFields = [];\n\t        for (var name_3 in domain) {\n\t            var type = domainFieldTypes[name_3];\n\t            if (!type) {\n\t                logger.throwArgumentError(\"invalid typed-data domain key: \" + JSON.stringify(name_3), \"domain\", domain);\n\t            }\n\t            domainFields.push({ name: name_3, type: type });\n\t        }\n\t        domainFields.sort(function (a, b) {\n\t            return domainFieldNames.indexOf(a.name) - domainFieldNames.indexOf(b.name);\n\t        });\n\t        return TypedDataEncoder.hashStruct(\"EIP712Domain\", { EIP712Domain: domainFields }, domain);\n\t    };\n\t    TypedDataEncoder.encode = function (domain, types, value) {\n\t        return (0, lib$1.hexConcat)([\n\t            \"0x1901\",\n\t            TypedDataEncoder.hashDomain(domain),\n\t            TypedDataEncoder.from(types).hash(value)\n\t        ]);\n\t    };\n\t    TypedDataEncoder.hash = function (domain, types, value) {\n\t        return (0, lib$4.keccak256)(TypedDataEncoder.encode(domain, types, value));\n\t    };\n\t    // Replaces all address types with ENS names with their looked up address\n\t    TypedDataEncoder.resolveNames = function (domain, types, value, resolveName) {\n\t        return __awaiter(this, void 0, void 0, function () {\n\t            var ensCache, encoder, _a, _b, _i, name_4, _c, _d;\n\t            return __generator(this, function (_e) {\n\t                switch (_e.label) {\n\t                    case 0:\n\t                        // Make a copy to isolate it from the object passed in\n\t                        domain = (0, lib$3.shallowCopy)(domain);\n\t                        ensCache = {};\n\t                        // Do we need to look up the domain's verifyingContract?\n\t                        if (domain.verifyingContract && !(0, lib$1.isHexString)(domain.verifyingContract, 20)) {\n\t                            ensCache[domain.verifyingContract] = \"0x\";\n\t                        }\n\t                        encoder = TypedDataEncoder.from(types);\n\t                        // Get a list of all the addresses\n\t                        encoder.visit(value, function (type, value) {\n\t                            if (type === \"address\" && !(0, lib$1.isHexString)(value, 20)) {\n\t                                ensCache[value] = \"0x\";\n\t                            }\n\t                            return value;\n\t                        });\n\t                        _a = [];\n\t                        for (_b in ensCache)\n\t                            _a.push(_b);\n\t                        _i = 0;\n\t                        _e.label = 1;\n\t                    case 1:\n\t                        if (!(_i < _a.length)) return [3 /*break*/, 4];\n\t                        name_4 = _a[_i];\n\t                        _c = ensCache;\n\t                        _d = name_4;\n\t                        return [4 /*yield*/, resolveName(name_4)];\n\t                    case 2:\n\t                        _c[_d] = _e.sent();\n\t                        _e.label = 3;\n\t                    case 3:\n\t                        _i++;\n\t                        return [3 /*break*/, 1];\n\t                    case 4:\n\t                        // Replace the domain verifyingContract if needed\n\t                        if (domain.verifyingContract && ensCache[domain.verifyingContract]) {\n\t                            domain.verifyingContract = ensCache[domain.verifyingContract];\n\t                        }\n\t                        // Replace all ENS names with their address\n\t                        value = encoder.visit(value, function (type, value) {\n\t                            if (type === \"address\" && ensCache[value]) {\n\t                                return ensCache[value];\n\t                            }\n\t                            return value;\n\t                        });\n\t                        return [2 /*return*/, { domain: domain, value: value }];\n\t                }\n\t            });\n\t        });\n\t    };\n\t    TypedDataEncoder.getPayload = function (domain, types, value) {\n\t        // Validate the domain fields\n\t        TypedDataEncoder.hashDomain(domain);\n\t        // Derive the EIP712Domain Struct reference type\n\t        var domainValues = {};\n\t        var domainTypes = [];\n\t        domainFieldNames.forEach(function (name) {\n\t            var value = domain[name];\n\t            if (value == null) {\n\t                return;\n\t            }\n\t            domainValues[name] = domainChecks[name](value);\n\t            domainTypes.push({ name: name, type: domainFieldTypes[name] });\n\t        });\n\t        var encoder = TypedDataEncoder.from(types);\n\t        var typesWithDomain = (0, lib$3.shallowCopy)(types);\n\t        if (typesWithDomain.EIP712Domain) {\n\t            logger.throwArgumentError(\"types must not contain EIP712Domain type\", \"types.EIP712Domain\", types);\n\t        }\n\t        else {\n\t            typesWithDomain.EIP712Domain = domainTypes;\n\t        }\n\t        // Validate the data structures and types\n\t        encoder.encode(value);\n\t        return {\n\t            types: typesWithDomain,\n\t            domain: domainValues,\n\t            primaryType: encoder.primaryType,\n\t            message: encoder.visit(value, function (type, value) {\n\t                // bytes\n\t                if (type.match(/^bytes(\\d*)/)) {\n\t                    return (0, lib$1.hexlify)((0, lib$1.arrayify)(value));\n\t                }\n\t                // uint or int\n\t                if (type.match(/^u?int/)) {\n\t                    return lib$2.BigNumber.from(value).toString();\n\t                }\n\t                switch (type) {\n\t                    case \"address\":\n\t                        return value.toLowerCase();\n\t                    case \"bool\":\n\t                        return !!value;\n\t                    case \"string\":\n\t                        if (typeof (value) !== \"string\") {\n\t                            logger.throwArgumentError(\"invalid string\", \"value\", value);\n\t                        }\n\t                        return value;\n\t                }\n\t                return logger.throwArgumentError(\"unsupported type\", \"type\", type);\n\t            })\n\t        };\n\t    };\n\t    return TypedDataEncoder;\n\t}());\n\texports.TypedDataEncoder = TypedDataEncoder;\n\n\t});\n\n\tvar typedData$1 = /*@__PURE__*/getDefaultExportFromCjs(typedData);\n\n\tvar lib$9 = createCommonjsModule(function (module, exports) {\n\t\"use strict\";\n\tObject.defineProperty(exports, \"__esModule\", { value: true });\n\texports._TypedDataEncoder = exports.hashMessage = exports.messagePrefix = exports.isValidName = exports.namehash = exports.id = void 0;\n\n\tObject.defineProperty(exports, \"id\", { enumerable: true, get: function () { return id_1.id; } });\n\n\tObject.defineProperty(exports, \"isValidName\", { enumerable: true, get: function () { return namehash_1.isValidName; } });\n\tObject.defineProperty(exports, \"namehash\", { enumerable: true, get: function () { return namehash_1.namehash; } });\n\n\tObject.defineProperty(exports, \"hashMessage\", { enumerable: true, get: function () { return message.hashMessage; } });\n\tObject.defineProperty(exports, \"messagePrefix\", { enumerable: true, get: function () { return message.messagePrefix; } });\n\n\tObject.defineProperty(exports, \"_TypedDataEncoder\", { enumerable: true, get: function () { return typedData.TypedDataEncoder; } });\n\n\t});\n\n\tvar index$9 = /*@__PURE__*/getDefaultExportFromCjs(lib$9);\n\n\tvar _interface = createCommonjsModule(function (module, exports) {\n\t\"use strict\";\n\tvar __extends = (commonjsGlobal && commonjsGlobal.__extends) || (function () {\n\t    var extendStatics = function (d, b) {\n\t        extendStatics = Object.setPrototypeOf ||\n\t            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n\t            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n\t        return extendStatics(d, b);\n\t    };\n\t    return function (d, b) {\n\t        if (typeof b !== \"function\" && b !== null)\n\t            throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n\t        extendStatics(d, b);\n\t        function __() { this.constructor = d; }\n\t        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n\t    };\n\t})();\n\tObject.defineProperty(exports, \"__esModule\", { value: true });\n\texports.Interface = exports.Indexed = exports.ErrorDescription = exports.TransactionDescription = exports.LogDescription = exports.checkResultErrors = void 0;\n\n\n\n\n\n\n\n\n\tObject.defineProperty(exports, \"checkResultErrors\", { enumerable: true, get: function () { return abstractCoder.checkResultErrors; } });\n\n\n\n\tvar logger = new lib.Logger(_version$8.version);\n\tvar LogDescription = /** @class */ (function (_super) {\n\t    __extends(LogDescription, _super);\n\t    function LogDescription() {\n\t        return _super !== null && _super.apply(this, arguments) || this;\n\t    }\n\t    return LogDescription;\n\t}(lib$3.Description));\n\texports.LogDescription = LogDescription;\n\tvar TransactionDescription = /** @class */ (function (_super) {\n\t    __extends(TransactionDescription, _super);\n\t    function TransactionDescription() {\n\t        return _super !== null && _super.apply(this, arguments) || this;\n\t    }\n\t    return TransactionDescription;\n\t}(lib$3.Description));\n\texports.TransactionDescription = TransactionDescription;\n\tvar ErrorDescription = /** @class */ (function (_super) {\n\t    __extends(ErrorDescription, _super);\n\t    function ErrorDescription() {\n\t        return _super !== null && _super.apply(this, arguments) || this;\n\t    }\n\t    return ErrorDescription;\n\t}(lib$3.Description));\n\texports.ErrorDescription = ErrorDescription;\n\tvar Indexed = /** @class */ (function (_super) {\n\t    __extends(Indexed, _super);\n\t    function Indexed() {\n\t        return _super !== null && _super.apply(this, arguments) || this;\n\t    }\n\t    Indexed.isIndexed = function (value) {\n\t        return !!(value && value._isIndexed);\n\t    };\n\t    return Indexed;\n\t}(lib$3.Description));\n\texports.Indexed = Indexed;\n\tvar BuiltinErrors = {\n\t    \"0x08c379a0\": { signature: \"Error(string)\", name: \"Error\", inputs: [\"string\"], reason: true },\n\t    \"0x4e487b71\": { signature: \"Panic(uint256)\", name: \"Panic\", inputs: [\"uint256\"] }\n\t};\n\tfunction wrapAccessError(property, error) {\n\t    var wrap = new Error(\"deferred error during ABI decoding triggered accessing \" + property);\n\t    wrap.error = error;\n\t    return wrap;\n\t}\n\t/*\n\tfunction checkNames(fragment: Fragment, type: \"input\" | \"output\", params: Array<ParamType>): void {\n\t    params.reduce((accum, param) => {\n\t        if (param.name) {\n\t            if (accum[param.name]) {\n\t                logger.throwArgumentError(`duplicate ${ type } parameter ${ JSON.stringify(param.name) } in ${ fragment.format(\"full\") }`, \"fragment\", fragment);\n\t            }\n\t            accum[param.name] = true;\n\t        }\n\t        return accum;\n\t    }, <{ [ name: string ]: boolean }>{ });\n\t}\n\t*/\n\tvar Interface = /** @class */ (function () {\n\t    function Interface(fragments$1) {\n\t        var _newTarget = this.constructor;\n\t        var _this = this;\n\t        logger.checkNew(_newTarget, Interface);\n\t        var abi = [];\n\t        if (typeof (fragments$1) === \"string\") {\n\t            abi = JSON.parse(fragments$1);\n\t        }\n\t        else {\n\t            abi = fragments$1;\n\t        }\n\t        (0, lib$3.defineReadOnly)(this, \"fragments\", abi.map(function (fragment) {\n\t            return fragments.Fragment.from(fragment);\n\t        }).filter(function (fragment) { return (fragment != null); }));\n\t        (0, lib$3.defineReadOnly)(this, \"_abiCoder\", (0, lib$3.getStatic)(_newTarget, \"getAbiCoder\")());\n\t        (0, lib$3.defineReadOnly)(this, \"functions\", {});\n\t        (0, lib$3.defineReadOnly)(this, \"errors\", {});\n\t        (0, lib$3.defineReadOnly)(this, \"events\", {});\n\t        (0, lib$3.defineReadOnly)(this, \"structs\", {});\n\t        // Add all fragments by their signature\n\t        this.fragments.forEach(function (fragment) {\n\t            var bucket = null;\n\t            switch (fragment.type) {\n\t                case \"constructor\":\n\t                    if (_this.deploy) {\n\t                        logger.warn(\"duplicate definition - constructor\");\n\t                        return;\n\t                    }\n\t                    //checkNames(fragment, \"input\", fragment.inputs);\n\t                    (0, lib$3.defineReadOnly)(_this, \"deploy\", fragment);\n\t                    return;\n\t                case \"function\":\n\t                    //checkNames(fragment, \"input\", fragment.inputs);\n\t                    //checkNames(fragment, \"output\", (<FunctionFragment>fragment).outputs);\n\t                    bucket = _this.functions;\n\t                    break;\n\t                case \"event\":\n\t                    //checkNames(fragment, \"input\", fragment.inputs);\n\t                    bucket = _this.events;\n\t                    break;\n\t                case \"error\":\n\t                    bucket = _this.errors;\n\t                    break;\n\t                default:\n\t                    return;\n\t            }\n\t            var signature = fragment.format();\n\t            if (bucket[signature]) {\n\t                logger.warn(\"duplicate definition - \" + signature);\n\t                return;\n\t            }\n\t            bucket[signature] = fragment;\n\t        });\n\t        // If we do not have a constructor add a default\n\t        if (!this.deploy) {\n\t            (0, lib$3.defineReadOnly)(this, \"deploy\", fragments.ConstructorFragment.from({\n\t                payable: false,\n\t                type: \"constructor\"\n\t            }));\n\t        }\n\t        (0, lib$3.defineReadOnly)(this, \"_isInterface\", true);\n\t    }\n\t    Interface.prototype.format = function (format) {\n\t        if (!format) {\n\t            format = fragments.FormatTypes.full;\n\t        }\n\t        if (format === fragments.FormatTypes.sighash) {\n\t            logger.throwArgumentError(\"interface does not support formatting sighash\", \"format\", format);\n\t        }\n\t        var abi = this.fragments.map(function (fragment) { return fragment.format(format); });\n\t        // We need to re-bundle the JSON fragments a bit\n\t        if (format === fragments.FormatTypes.json) {\n\t            return JSON.stringify(abi.map(function (j) { return JSON.parse(j); }));\n\t        }\n\t        return abi;\n\t    };\n\t    // Sub-classes can override these to handle other blockchains\n\t    Interface.getAbiCoder = function () {\n\t        return abiCoder.defaultAbiCoder;\n\t    };\n\t    Interface.getAddress = function (address) {\n\t        return (0, lib$6.getAddress)(address);\n\t    };\n\t    Interface.getSighash = function (fragment) {\n\t        return (0, lib$1.hexDataSlice)((0, lib$9.id)(fragment.format()), 0, 4);\n\t    };\n\t    Interface.getEventTopic = function (eventFragment) {\n\t        return (0, lib$9.id)(eventFragment.format());\n\t    };\n\t    // Find a function definition by any means necessary (unless it is ambiguous)\n\t    Interface.prototype.getFunction = function (nameOrSignatureOrSighash) {\n\t        if ((0, lib$1.isHexString)(nameOrSignatureOrSighash)) {\n\t            for (var name_1 in this.functions) {\n\t                if (nameOrSignatureOrSighash === this.getSighash(name_1)) {\n\t                    return this.functions[name_1];\n\t                }\n\t            }\n\t            logger.throwArgumentError(\"no matching function\", \"sighash\", nameOrSignatureOrSighash);\n\t        }\n\t        // It is a bare name, look up the function (will return null if ambiguous)\n\t        if (nameOrSignatureOrSighash.indexOf(\"(\") === -1) {\n\t            var name_2 = nameOrSignatureOrSighash.trim();\n\t            var matching = Object.keys(this.functions).filter(function (f) { return (f.split(\"(\" /* fix:) */)[0] === name_2); });\n\t            if (matching.length === 0) {\n\t                logger.throwArgumentError(\"no matching function\", \"name\", name_2);\n\t            }\n\t            else if (matching.length > 1) {\n\t                logger.throwArgumentError(\"multiple matching functions\", \"name\", name_2);\n\t            }\n\t            return this.functions[matching[0]];\n\t        }\n\t        // Normalize the signature and lookup the function\n\t        var result = this.functions[fragments.FunctionFragment.fromString(nameOrSignatureOrSighash).format()];\n\t        if (!result) {\n\t            logger.throwArgumentError(\"no matching function\", \"signature\", nameOrSignatureOrSighash);\n\t        }\n\t        return result;\n\t    };\n\t    // Find an event definition by any means necessary (unless it is ambiguous)\n\t    Interface.prototype.getEvent = function (nameOrSignatureOrTopic) {\n\t        if ((0, lib$1.isHexString)(nameOrSignatureOrTopic)) {\n\t            var topichash = nameOrSignatureOrTopic.toLowerCase();\n\t            for (var name_3 in this.events) {\n\t                if (topichash === this.getEventTopic(name_3)) {\n\t                    return this.events[name_3];\n\t                }\n\t            }\n\t            logger.throwArgumentError(\"no matching event\", \"topichash\", topichash);\n\t        }\n\t        // It is a bare name, look up the function (will return null if ambiguous)\n\t        if (nameOrSignatureOrTopic.indexOf(\"(\") === -1) {\n\t            var name_4 = nameOrSignatureOrTopic.trim();\n\t            var matching = Object.keys(this.events).filter(function (f) { return (f.split(\"(\" /* fix:) */)[0] === name_4); });\n\t            if (matching.length === 0) {\n\t                logger.throwArgumentError(\"no matching event\", \"name\", name_4);\n\t            }\n\t            else if (matching.length > 1) {\n\t                logger.throwArgumentError(\"multiple matching events\", \"name\", name_4);\n\t            }\n\t            return this.events[matching[0]];\n\t        }\n\t        // Normalize the signature and lookup the function\n\t        var result = this.events[fragments.EventFragment.fromString(nameOrSignatureOrTopic).format()];\n\t        if (!result) {\n\t            logger.throwArgumentError(\"no matching event\", \"signature\", nameOrSignatureOrTopic);\n\t        }\n\t        return result;\n\t    };\n\t    // Find a function definition by any means necessary (unless it is ambiguous)\n\t    Interface.prototype.getError = function (nameOrSignatureOrSighash) {\n\t        if ((0, lib$1.isHexString)(nameOrSignatureOrSighash)) {\n\t            var getSighash = (0, lib$3.getStatic)(this.constructor, \"getSighash\");\n\t            for (var name_5 in this.errors) {\n\t                var error = this.errors[name_5];\n\t                if (nameOrSignatureOrSighash === getSighash(error)) {\n\t                    return this.errors[name_5];\n\t                }\n\t            }\n\t            logger.throwArgumentError(\"no matching error\", \"sighash\", nameOrSignatureOrSighash);\n\t        }\n\t        // It is a bare name, look up the function (will return null if ambiguous)\n\t        if (nameOrSignatureOrSighash.indexOf(\"(\") === -1) {\n\t            var name_6 = nameOrSignatureOrSighash.trim();\n\t            var matching = Object.keys(this.errors).filter(function (f) { return (f.split(\"(\" /* fix:) */)[0] === name_6); });\n\t            if (matching.length === 0) {\n\t                logger.throwArgumentError(\"no matching error\", \"name\", name_6);\n\t            }\n\t            else if (matching.length > 1) {\n\t                logger.throwArgumentError(\"multiple matching errors\", \"name\", name_6);\n\t            }\n\t            return this.errors[matching[0]];\n\t        }\n\t        // Normalize the signature and lookup the function\n\t        var result = this.errors[fragments.FunctionFragment.fromString(nameOrSignatureOrSighash).format()];\n\t        if (!result) {\n\t            logger.throwArgumentError(\"no matching error\", \"signature\", nameOrSignatureOrSighash);\n\t        }\n\t        return result;\n\t    };\n\t    // Get the sighash (the bytes4 selector) used by Solidity to identify a function\n\t    Interface.prototype.getSighash = function (fragment) {\n\t        if (typeof (fragment) === \"string\") {\n\t            try {\n\t                fragment = this.getFunction(fragment);\n\t            }\n\t            catch (error) {\n\t                try {\n\t                    fragment = this.getError(fragment);\n\t                }\n\t                catch (_) {\n\t                    throw error;\n\t                }\n\t            }\n\t        }\n\t        return (0, lib$3.getStatic)(this.constructor, \"getSighash\")(fragment);\n\t    };\n\t    // Get the topic (the bytes32 hash) used by Solidity to identify an event\n\t    Interface.prototype.getEventTopic = function (eventFragment) {\n\t        if (typeof (eventFragment) === \"string\") {\n\t            eventFragment = this.getEvent(eventFragment);\n\t        }\n\t        return (0, lib$3.getStatic)(this.constructor, \"getEventTopic\")(eventFragment);\n\t    };\n\t    Interface.prototype._decodeParams = function (params, data) {\n\t        return this._abiCoder.decode(params, data);\n\t    };\n\t    Interface.prototype._encodeParams = function (params, values) {\n\t        return this._abiCoder.encode(params, values);\n\t    };\n\t    Interface.prototype.encodeDeploy = function (values) {\n\t        return this._encodeParams(this.deploy.inputs, values || []);\n\t    };\n\t    Interface.prototype.decodeErrorResult = function (fragment, data) {\n\t        if (typeof (fragment) === \"string\") {\n\t            fragment = this.getError(fragment);\n\t        }\n\t        var bytes = (0, lib$1.arrayify)(data);\n\t        if ((0, lib$1.hexlify)(bytes.slice(0, 4)) !== this.getSighash(fragment)) {\n\t            logger.throwArgumentError(\"data signature does not match error \" + fragment.name + \".\", \"data\", (0, lib$1.hexlify)(bytes));\n\t        }\n\t        return this._decodeParams(fragment.inputs, bytes.slice(4));\n\t    };\n\t    Interface.prototype.encodeErrorResult = function (fragment, values) {\n\t        if (typeof (fragment) === \"string\") {\n\t            fragment = this.getError(fragment);\n\t        }\n\t        return (0, lib$1.hexlify)((0, lib$1.concat)([\n\t            this.getSighash(fragment),\n\t            this._encodeParams(fragment.inputs, values || [])\n\t        ]));\n\t    };\n\t    // Decode the data for a function call (e.g. tx.data)\n\t    Interface.prototype.decodeFunctionData = function (functionFragment, data) {\n\t        if (typeof (functionFragment) === \"string\") {\n\t            functionFragment = this.getFunction(functionFragment);\n\t        }\n\t        var bytes = (0, lib$1.arrayify)(data);\n\t        if ((0, lib$1.hexlify)(bytes.slice(0, 4)) !== this.getSighash(functionFragment)) {\n\t            logger.throwArgumentError(\"data signature does not match function \" + functionFragment.name + \".\", \"data\", (0, lib$1.hexlify)(bytes));\n\t        }\n\t        return this._decodeParams(functionFragment.inputs, bytes.slice(4));\n\t    };\n\t    // Encode the data for a function call (e.g. tx.data)\n\t    Interface.prototype.encodeFunctionData = function (functionFragment, values) {\n\t        if (typeof (functionFragment) === \"string\") {\n\t            functionFragment = this.getFunction(functionFragment);\n\t        }\n\t        return (0, lib$1.hexlify)((0, lib$1.concat)([\n\t            this.getSighash(functionFragment),\n\t            this._encodeParams(functionFragment.inputs, values || [])\n\t        ]));\n\t    };\n\t    // Decode the result from a function call (e.g. from eth_call)\n\t    Interface.prototype.decodeFunctionResult = function (functionFragment, data) {\n\t        if (typeof (functionFragment) === \"string\") {\n\t            functionFragment = this.getFunction(functionFragment);\n\t        }\n\t        var bytes = (0, lib$1.arrayify)(data);\n\t        var reason = null;\n\t        var errorArgs = null;\n\t        var errorName = null;\n\t        var errorSignature = null;\n\t        switch (bytes.length % this._abiCoder._getWordSize()) {\n\t            case 0:\n\t                try {\n\t                    return this._abiCoder.decode(functionFragment.outputs, bytes);\n\t                }\n\t                catch (error) { }\n\t                break;\n\t            case 4: {\n\t                var selector = (0, lib$1.hexlify)(bytes.slice(0, 4));\n\t                var builtin = BuiltinErrors[selector];\n\t                if (builtin) {\n\t                    errorArgs = this._abiCoder.decode(builtin.inputs, bytes.slice(4));\n\t                    errorName = builtin.name;\n\t                    errorSignature = builtin.signature;\n\t                    if (builtin.reason) {\n\t                        reason = errorArgs[0];\n\t                    }\n\t                }\n\t                else {\n\t                    try {\n\t                        var error = this.getError(selector);\n\t                        errorArgs = this._abiCoder.decode(error.inputs, bytes.slice(4));\n\t                        errorName = error.name;\n\t                        errorSignature = error.format();\n\t                    }\n\t                    catch (error) {\n\t                        console.log(error);\n\t                    }\n\t                }\n\t                break;\n\t            }\n\t        }\n\t        return logger.throwError(\"call revert exception\", lib.Logger.errors.CALL_EXCEPTION, {\n\t            method: functionFragment.format(),\n\t            errorArgs: errorArgs,\n\t            errorName: errorName,\n\t            errorSignature: errorSignature,\n\t            reason: reason\n\t        });\n\t    };\n\t    // Encode the result for a function call (e.g. for eth_call)\n\t    Interface.prototype.encodeFunctionResult = function (functionFragment, values) {\n\t        if (typeof (functionFragment) === \"string\") {\n\t            functionFragment = this.getFunction(functionFragment);\n\t        }\n\t        return (0, lib$1.hexlify)(this._abiCoder.encode(functionFragment.outputs, values || []));\n\t    };\n\t    // Create the filter for the event with search criteria (e.g. for eth_filterLog)\n\t    Interface.prototype.encodeFilterTopics = function (eventFragment, values) {\n\t        var _this = this;\n\t        if (typeof (eventFragment) === \"string\") {\n\t            eventFragment = this.getEvent(eventFragment);\n\t        }\n\t        if (values.length > eventFragment.inputs.length) {\n\t            logger.throwError(\"too many arguments for \" + eventFragment.format(), lib.Logger.errors.UNEXPECTED_ARGUMENT, {\n\t                argument: \"values\",\n\t                value: values\n\t            });\n\t        }\n\t        var topics = [];\n\t        if (!eventFragment.anonymous) {\n\t            topics.push(this.getEventTopic(eventFragment));\n\t        }\n\t        var encodeTopic = function (param, value) {\n\t            if (param.type === \"string\") {\n\t                return (0, lib$9.id)(value);\n\t            }\n\t            else if (param.type === \"bytes\") {\n\t                return (0, lib$4.keccak256)((0, lib$1.hexlify)(value));\n\t            }\n\t            // Check addresses are valid\n\t            if (param.type === \"address\") {\n\t                _this._abiCoder.encode([\"address\"], [value]);\n\t            }\n\t            return (0, lib$1.hexZeroPad)((0, lib$1.hexlify)(value), 32);\n\t        };\n\t        values.forEach(function (value, index) {\n\t            var param = eventFragment.inputs[index];\n\t            if (!param.indexed) {\n\t                if (value != null) {\n\t                    logger.throwArgumentError(\"cannot filter non-indexed parameters; must be null\", (\"contract.\" + param.name), value);\n\t                }\n\t                return;\n\t            }\n\t            if (value == null) {\n\t                topics.push(null);\n\t            }\n\t            else if (param.baseType === \"array\" || param.baseType === \"tuple\") {\n\t                logger.throwArgumentError(\"filtering with tuples or arrays not supported\", (\"contract.\" + param.name), value);\n\t            }\n\t            else if (Array.isArray(value)) {\n\t                topics.push(value.map(function (value) { return encodeTopic(param, value); }));\n\t            }\n\t            else {\n\t                topics.push(encodeTopic(param, value));\n\t            }\n\t        });\n\t        // Trim off trailing nulls\n\t        while (topics.length && topics[topics.length - 1] === null) {\n\t            topics.pop();\n\t        }\n\t        return topics;\n\t    };\n\t    Interface.prototype.encodeEventLog = function (eventFragment, values) {\n\t        var _this = this;\n\t        if (typeof (eventFragment) === \"string\") {\n\t            eventFragment = this.getEvent(eventFragment);\n\t        }\n\t        var topics = [];\n\t        var dataTypes = [];\n\t        var dataValues = [];\n\t        if (!eventFragment.anonymous) {\n\t            topics.push(this.getEventTopic(eventFragment));\n\t        }\n\t        if (values.length !== eventFragment.inputs.length) {\n\t            logger.throwArgumentError(\"event arguments/values mismatch\", \"values\", values);\n\t        }\n\t        eventFragment.inputs.forEach(function (param, index) {\n\t            var value = values[index];\n\t            if (param.indexed) {\n\t                if (param.type === \"string\") {\n\t                    topics.push((0, lib$9.id)(value));\n\t                }\n\t                else if (param.type === \"bytes\") {\n\t                    topics.push((0, lib$4.keccak256)(value));\n\t                }\n\t                else if (param.baseType === \"tuple\" || param.baseType === \"array\") {\n\t                    // @TODO\n\t                    throw new Error(\"not implemented\");\n\t                }\n\t                else {\n\t                    topics.push(_this._abiCoder.encode([param.type], [value]));\n\t                }\n\t            }\n\t            else {\n\t                dataTypes.push(param);\n\t                dataValues.push(value);\n\t            }\n\t        });\n\t        return {\n\t            data: this._abiCoder.encode(dataTypes, dataValues),\n\t            topics: topics\n\t        };\n\t    };\n\t    // Decode a filter for the event and the search criteria\n\t    Interface.prototype.decodeEventLog = function (eventFragment, data, topics) {\n\t        if (typeof (eventFragment) === \"string\") {\n\t            eventFragment = this.getEvent(eventFragment);\n\t        }\n\t        if (topics != null && !eventFragment.anonymous) {\n\t            var topicHash = this.getEventTopic(eventFragment);\n\t            if (!(0, lib$1.isHexString)(topics[0], 32) || topics[0].toLowerCase() !== topicHash) {\n\t                logger.throwError(\"fragment/topic mismatch\", lib.Logger.errors.INVALID_ARGUMENT, { argument: \"topics[0]\", expected: topicHash, value: topics[0] });\n\t            }\n\t            topics = topics.slice(1);\n\t        }\n\t        var indexed = [];\n\t        var nonIndexed = [];\n\t        var dynamic = [];\n\t        eventFragment.inputs.forEach(function (param, index) {\n\t            if (param.indexed) {\n\t                if (param.type === \"string\" || param.type === \"bytes\" || param.baseType === \"tuple\" || param.baseType === \"array\") {\n\t                    indexed.push(fragments.ParamType.fromObject({ type: \"bytes32\", name: param.name }));\n\t                    dynamic.push(true);\n\t                }\n\t                else {\n\t                    indexed.push(param);\n\t                    dynamic.push(false);\n\t                }\n\t            }\n\t            else {\n\t                nonIndexed.push(param);\n\t                dynamic.push(false);\n\t            }\n\t        });\n\t        var resultIndexed = (topics != null) ? this._abiCoder.decode(indexed, (0, lib$1.concat)(topics)) : null;\n\t        var resultNonIndexed = this._abiCoder.decode(nonIndexed, data, true);\n\t        var result = [];\n\t        var nonIndexedIndex = 0, indexedIndex = 0;\n\t        eventFragment.inputs.forEach(function (param, index) {\n\t            if (param.indexed) {\n\t                if (resultIndexed == null) {\n\t                    result[index] = new Indexed({ _isIndexed: true, hash: null });\n\t                }\n\t                else if (dynamic[index]) {\n\t                    result[index] = new Indexed({ _isIndexed: true, hash: resultIndexed[indexedIndex++] });\n\t                }\n\t                else {\n\t                    try {\n\t                        result[index] = resultIndexed[indexedIndex++];\n\t                    }\n\t                    catch (error) {\n\t                        result[index] = error;\n\t                    }\n\t                }\n\t            }\n\t            else {\n\t                try {\n\t                    result[index] = resultNonIndexed[nonIndexedIndex++];\n\t                }\n\t                catch (error) {\n\t                    result[index] = error;\n\t                }\n\t            }\n\t            // Add the keyword argument if named and safe\n\t            if (param.name && result[param.name] == null) {\n\t                var value_1 = result[index];\n\t                // Make error named values throw on access\n\t                if (value_1 instanceof Error) {\n\t                    Object.defineProperty(result, param.name, {\n\t                        enumerable: true,\n\t                        get: function () { throw wrapAccessError(\"property \" + JSON.stringify(param.name), value_1); }\n\t                    });\n\t                }\n\t                else {\n\t                    result[param.name] = value_1;\n\t                }\n\t            }\n\t        });\n\t        var _loop_1 = function (i) {\n\t            var value = result[i];\n\t            if (value instanceof Error) {\n\t                Object.defineProperty(result, i, {\n\t                    enumerable: true,\n\t                    get: function () { throw wrapAccessError(\"index \" + i, value); }\n\t                });\n\t            }\n\t        };\n\t        // Make all error indexed values throw on access\n\t        for (var i = 0; i < result.length; i++) {\n\t            _loop_1(i);\n\t        }\n\t        return Object.freeze(result);\n\t    };\n\t    // Given a transaction, find the matching function fragment (if any) and\n\t    // determine all its properties and call parameters\n\t    Interface.prototype.parseTransaction = function (tx) {\n\t        var fragment = this.getFunction(tx.data.substring(0, 10).toLowerCase());\n\t        if (!fragment) {\n\t            return null;\n\t        }\n\t        return new TransactionDescription({\n\t            args: this._abiCoder.decode(fragment.inputs, \"0x\" + tx.data.substring(10)),\n\t            functionFragment: fragment,\n\t            name: fragment.name,\n\t            signature: fragment.format(),\n\t            sighash: this.getSighash(fragment),\n\t            value: lib$2.BigNumber.from(tx.value || \"0\"),\n\t        });\n\t    };\n\t    // @TODO\n\t    //parseCallResult(data: BytesLike): ??\n\t    // Given an event log, find the matching event fragment (if any) and\n\t    // determine all its properties and values\n\t    Interface.prototype.parseLog = function (log) {\n\t        var fragment = this.getEvent(log.topics[0]);\n\t        if (!fragment || fragment.anonymous) {\n\t            return null;\n\t        }\n\t        // @TODO: If anonymous, and the only method, and the input count matches, should we parse?\n\t        //        Probably not, because just because it is the only event in the ABI does\n\t        //        not mean we have the full ABI; maybe just a fragment?\n\t        return new LogDescription({\n\t            eventFragment: fragment,\n\t            name: fragment.name,\n\t            signature: fragment.format(),\n\t            topic: this.getEventTopic(fragment),\n\t            args: this.decodeEventLog(fragment, log.data, log.topics)\n\t        });\n\t    };\n\t    Interface.prototype.parseError = function (data) {\n\t        var hexData = (0, lib$1.hexlify)(data);\n\t        var fragment = this.getError(hexData.substring(0, 10).toLowerCase());\n\t        if (!fragment) {\n\t            return null;\n\t        }\n\t        return new ErrorDescription({\n\t            args: this._abiCoder.decode(fragment.inputs, \"0x\" + hexData.substring(10)),\n\t            errorFragment: fragment,\n\t            name: fragment.name,\n\t            signature: fragment.format(),\n\t            sighash: this.getSighash(fragment),\n\t        });\n\t    };\n\t    /*\n\t    static from(value: Array<Fragment | string | JsonAbi> | string | Interface) {\n\t        if (Interface.isInterface(value)) {\n\t            return value;\n\t        }\n\t        if (typeof(value) === \"string\") {\n\t            return new Interface(JSON.parse(value));\n\t        }\n\t        return new Interface(value);\n\t    }\n\t    */\n\t    Interface.isInterface = function (value) {\n\t        return !!(value && value._isInterface);\n\t    };\n\t    return Interface;\n\t}());\n\texports.Interface = Interface;\n\n\t});\n\n\tvar _interface$1 = /*@__PURE__*/getDefaultExportFromCjs(_interface);\n\n\tvar lib$a = createCommonjsModule(function (module, exports) {\n\t\"use strict\";\n\tObject.defineProperty(exports, \"__esModule\", { value: true });\n\texports.TransactionDescription = exports.LogDescription = exports.checkResultErrors = exports.Indexed = exports.Interface = exports.defaultAbiCoder = exports.AbiCoder = exports.FormatTypes = exports.ParamType = exports.FunctionFragment = exports.Fragment = exports.EventFragment = exports.ErrorFragment = exports.ConstructorFragment = void 0;\n\n\tObject.defineProperty(exports, \"ConstructorFragment\", { enumerable: true, get: function () { return fragments.ConstructorFragment; } });\n\tObject.defineProperty(exports, \"ErrorFragment\", { enumerable: true, get: function () { return fragments.ErrorFragment; } });\n\tObject.defineProperty(exports, \"EventFragment\", { enumerable: true, get: function () { return fragments.EventFragment; } });\n\tObject.defineProperty(exports, \"FormatTypes\", { enumerable: true, get: function () { return fragments.FormatTypes; } });\n\tObject.defineProperty(exports, \"Fragment\", { enumerable: true, get: function () { return fragments.Fragment; } });\n\tObject.defineProperty(exports, \"FunctionFragment\", { enumerable: true, get: function () { return fragments.FunctionFragment; } });\n\tObject.defineProperty(exports, \"ParamType\", { enumerable: true, get: function () { return fragments.ParamType; } });\n\n\tObject.defineProperty(exports, \"AbiCoder\", { enumerable: true, get: function () { return abiCoder.AbiCoder; } });\n\tObject.defineProperty(exports, \"defaultAbiCoder\", { enumerable: true, get: function () { return abiCoder.defaultAbiCoder; } });\n\n\tObject.defineProperty(exports, \"checkResultErrors\", { enumerable: true, get: function () { return _interface.checkResultErrors; } });\n\tObject.defineProperty(exports, \"Indexed\", { enumerable: true, get: function () { return _interface.Indexed; } });\n\tObject.defineProperty(exports, \"Interface\", { enumerable: true, get: function () { return _interface.Interface; } });\n\tObject.defineProperty(exports, \"LogDescription\", { enumerable: true, get: function () { return _interface.LogDescription; } });\n\tObject.defineProperty(exports, \"TransactionDescription\", { enumerable: true, get: function () { return _interface.TransactionDescription; } });\n\n\t});\n\n\tvar index$a = /*@__PURE__*/getDefaultExportFromCjs(lib$a);\n\n\tvar _version$i = createCommonjsModule(function (module, exports) {\n\t\"use strict\";\n\tObject.defineProperty(exports, \"__esModule\", { value: true });\n\texports.version = void 0;\n\texports.version = \"abstract-provider/5.5.1\";\n\n\t});\n\n\tvar _version$j = /*@__PURE__*/getDefaultExportFromCjs(_version$i);\n\n\tvar lib$b = createCommonjsModule(function (module, exports) {\n\t\"use strict\";\n\tvar __extends = (commonjsGlobal && commonjsGlobal.__extends) || (function () {\n\t    var extendStatics = function (d, b) {\n\t        extendStatics = Object.setPrototypeOf ||\n\t            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n\t            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n\t        return extendStatics(d, b);\n\t    };\n\t    return function (d, b) {\n\t        if (typeof b !== \"function\" && b !== null)\n\t            throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n\t        extendStatics(d, b);\n\t        function __() { this.constructor = d; }\n\t        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n\t    };\n\t})();\n\tvar __awaiter = (commonjsGlobal && commonjsGlobal.__awaiter) || function (thisArg, _arguments, P, generator) {\n\t    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n\t    return new (P || (P = Promise))(function (resolve, reject) {\n\t        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n\t        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n\t        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n\t        step((generator = generator.apply(thisArg, _arguments || [])).next());\n\t    });\n\t};\n\tvar __generator = (commonjsGlobal && commonjsGlobal.__generator) || function (thisArg, body) {\n\t    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\n\t    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\n\t    function verb(n) { return function (v) { return step([n, v]); }; }\n\t    function step(op) {\n\t        if (f) throw new TypeError(\"Generator is already executing.\");\n\t        while (_) try {\n\t            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n\t            if (y = 0, t) op = [op[0] & 2, t.value];\n\t            switch (op[0]) {\n\t                case 0: case 1: t = op; break;\n\t                case 4: _.label++; return { value: op[1], done: false };\n\t                case 5: _.label++; y = op[1]; op = [0]; continue;\n\t                case 7: op = _.ops.pop(); _.trys.pop(); continue;\n\t                default:\n\t                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\n\t                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\n\t                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\n\t                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\n\t                    if (t[2]) _.ops.pop();\n\t                    _.trys.pop(); continue;\n\t            }\n\t            op = body.call(thisArg, _);\n\t        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\n\t        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\n\t    }\n\t};\n\tObject.defineProperty(exports, \"__esModule\", { value: true });\n\texports.Provider = exports.TransactionOrderForkEvent = exports.TransactionForkEvent = exports.BlockForkEvent = exports.ForkEvent = void 0;\n\n\n\n\n\n\tvar logger = new lib.Logger(_version$i.version);\n\t;\n\t;\n\t//export type CallTransactionable = {\n\t//    call(transaction: TransactionRequest): Promise<TransactionResponse>;\n\t//};\n\tvar ForkEvent = /** @class */ (function (_super) {\n\t    __extends(ForkEvent, _super);\n\t    function ForkEvent() {\n\t        return _super !== null && _super.apply(this, arguments) || this;\n\t    }\n\t    ForkEvent.isForkEvent = function (value) {\n\t        return !!(value && value._isForkEvent);\n\t    };\n\t    return ForkEvent;\n\t}(lib$3.Description));\n\texports.ForkEvent = ForkEvent;\n\tvar BlockForkEvent = /** @class */ (function (_super) {\n\t    __extends(BlockForkEvent, _super);\n\t    function BlockForkEvent(blockHash, expiry) {\n\t        var _this = this;\n\t        if (!(0, lib$1.isHexString)(blockHash, 32)) {\n\t            logger.throwArgumentError(\"invalid blockHash\", \"blockHash\", blockHash);\n\t        }\n\t        _this = _super.call(this, {\n\t            _isForkEvent: true,\n\t            _isBlockForkEvent: true,\n\t            expiry: (expiry || 0),\n\t            blockHash: blockHash\n\t        }) || this;\n\t        return _this;\n\t    }\n\t    return BlockForkEvent;\n\t}(ForkEvent));\n\texports.BlockForkEvent = BlockForkEvent;\n\tvar TransactionForkEvent = /** @class */ (function (_super) {\n\t    __extends(TransactionForkEvent, _super);\n\t    function TransactionForkEvent(hash, expiry) {\n\t        var _this = this;\n\t        if (!(0, lib$1.isHexString)(hash, 32)) {\n\t            logger.throwArgumentError(\"invalid transaction hash\", \"hash\", hash);\n\t        }\n\t        _this = _super.call(this, {\n\t            _isForkEvent: true,\n\t            _isTransactionForkEvent: true,\n\t            expiry: (expiry || 0),\n\t            hash: hash\n\t        }) || this;\n\t        return _this;\n\t    }\n\t    return TransactionForkEvent;\n\t}(ForkEvent));\n\texports.TransactionForkEvent = TransactionForkEvent;\n\tvar TransactionOrderForkEvent = /** @class */ (function (_super) {\n\t    __extends(TransactionOrderForkEvent, _super);\n\t    function TransactionOrderForkEvent(beforeHash, afterHash, expiry) {\n\t        var _this = this;\n\t        if (!(0, lib$1.isHexString)(beforeHash, 32)) {\n\t            logger.throwArgumentError(\"invalid transaction hash\", \"beforeHash\", beforeHash);\n\t        }\n\t        if (!(0, lib$1.isHexString)(afterHash, 32)) {\n\t            logger.throwArgumentError(\"invalid transaction hash\", \"afterHash\", afterHash);\n\t        }\n\t        _this = _super.call(this, {\n\t            _isForkEvent: true,\n\t            _isTransactionOrderForkEvent: true,\n\t            expiry: (expiry || 0),\n\t            beforeHash: beforeHash,\n\t            afterHash: afterHash\n\t        }) || this;\n\t        return _this;\n\t    }\n\t    return TransactionOrderForkEvent;\n\t}(ForkEvent));\n\texports.TransactionOrderForkEvent = TransactionOrderForkEvent;\n\t///////////////////////////////\n\t// Exported Abstracts\n\tvar Provider = /** @class */ (function () {\n\t    function Provider() {\n\t        var _newTarget = this.constructor;\n\t        logger.checkAbstract(_newTarget, Provider);\n\t        (0, lib$3.defineReadOnly)(this, \"_isProvider\", true);\n\t    }\n\t    Provider.prototype.getFeeData = function () {\n\t        return __awaiter(this, void 0, void 0, function () {\n\t            var _a, block, gasPrice, maxFeePerGas, maxPriorityFeePerGas;\n\t            return __generator(this, function (_b) {\n\t                switch (_b.label) {\n\t                    case 0: return [4 /*yield*/, (0, lib$3.resolveProperties)({\n\t                            block: this.getBlock(\"latest\"),\n\t                            gasPrice: this.getGasPrice().catch(function (error) {\n\t                                // @TODO: Why is this now failing on Calaveras?\n\t                                //console.log(error);\n\t                                return null;\n\t                            })\n\t                        })];\n\t                    case 1:\n\t                        _a = _b.sent(), block = _a.block, gasPrice = _a.gasPrice;\n\t                        maxFeePerGas = null, maxPriorityFeePerGas = null;\n\t                        if (block && block.baseFeePerGas) {\n\t                            // We may want to compute this more accurately in the future,\n\t                            // using the formula \"check if the base fee is correct\".\n\t                            // See: https://eips.ethereum.org/EIPS/eip-1559\n\t                            maxPriorityFeePerGas = lib$2.BigNumber.from(\"2500000000\");\n\t                            maxFeePerGas = block.baseFeePerGas.mul(2).add(maxPriorityFeePerGas);\n\t                        }\n\t                        return [2 /*return*/, { maxFeePerGas: maxFeePerGas, maxPriorityFeePerGas: maxPriorityFeePerGas, gasPrice: gasPrice }];\n\t                }\n\t            });\n\t        });\n\t    };\n\t    // Alias for \"on\"\n\t    Provider.prototype.addListener = function (eventName, listener) {\n\t        return this.on(eventName, listener);\n\t    };\n\t    // Alias for \"off\"\n\t    Provider.prototype.removeListener = function (eventName, listener) {\n\t        return this.off(eventName, listener);\n\t    };\n\t    Provider.isProvider = function (value) {\n\t        return !!(value && value._isProvider);\n\t    };\n\t    return Provider;\n\t}());\n\texports.Provider = Provider;\n\n\t});\n\n\tvar index$b = /*@__PURE__*/getDefaultExportFromCjs(lib$b);\n\n\tvar _version$k = createCommonjsModule(function (module, exports) {\n\t\"use strict\";\n\tObject.defineProperty(exports, \"__esModule\", { value: true });\n\texports.version = void 0;\n\texports.version = \"abstract-signer/5.5.0\";\n\n\t});\n\n\tvar _version$l = /*@__PURE__*/getDefaultExportFromCjs(_version$k);\n\n\tvar lib$c = createCommonjsModule(function (module, exports) {\n\t\"use strict\";\n\tvar __extends = (commonjsGlobal && commonjsGlobal.__extends) || (function () {\n\t    var extendStatics = function (d, b) {\n\t        extendStatics = Object.setPrototypeOf ||\n\t            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n\t            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n\t        return extendStatics(d, b);\n\t    };\n\t    return function (d, b) {\n\t        if (typeof b !== \"function\" && b !== null)\n\t            throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n\t        extendStatics(d, b);\n\t        function __() { this.constructor = d; }\n\t        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n\t    };\n\t})();\n\tvar __awaiter = (commonjsGlobal && commonjsGlobal.__awaiter) || function (thisArg, _arguments, P, generator) {\n\t    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n\t    return new (P || (P = Promise))(function (resolve, reject) {\n\t        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n\t        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n\t        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n\t        step((generator = generator.apply(thisArg, _arguments || [])).next());\n\t    });\n\t};\n\tvar __generator = (commonjsGlobal && commonjsGlobal.__generator) || function (thisArg, body) {\n\t    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\n\t    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\n\t    function verb(n) { return function (v) { return step([n, v]); }; }\n\t    function step(op) {\n\t        if (f) throw new TypeError(\"Generator is already executing.\");\n\t        while (_) try {\n\t            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n\t            if (y = 0, t) op = [op[0] & 2, t.value];\n\t            switch (op[0]) {\n\t                case 0: case 1: t = op; break;\n\t                case 4: _.label++; return { value: op[1], done: false };\n\t                case 5: _.label++; y = op[1]; op = [0]; continue;\n\t                case 7: op = _.ops.pop(); _.trys.pop(); continue;\n\t                default:\n\t                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\n\t                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\n\t                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\n\t                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\n\t                    if (t[2]) _.ops.pop();\n\t                    _.trys.pop(); continue;\n\t            }\n\t            op = body.call(thisArg, _);\n\t        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\n\t        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\n\t    }\n\t};\n\tObject.defineProperty(exports, \"__esModule\", { value: true });\n\texports.VoidSigner = exports.Signer = void 0;\n\n\n\n\tvar logger = new lib.Logger(_version$k.version);\n\tvar allowedTransactionKeys = [\n\t    \"accessList\", \"chainId\", \"customData\", \"data\", \"from\", \"gasLimit\", \"gasPrice\", \"maxFeePerGas\", \"maxPriorityFeePerGas\", \"nonce\", \"to\", \"type\", \"value\"\n\t];\n\tvar forwardErrors = [\n\t    lib.Logger.errors.INSUFFICIENT_FUNDS,\n\t    lib.Logger.errors.NONCE_EXPIRED,\n\t    lib.Logger.errors.REPLACEMENT_UNDERPRICED,\n\t];\n\t;\n\t;\n\tvar Signer = /** @class */ (function () {\n\t    ///////////////////\n\t    // Sub-classes MUST call super\n\t    function Signer() {\n\t        var _newTarget = this.constructor;\n\t        logger.checkAbstract(_newTarget, Signer);\n\t        (0, lib$3.defineReadOnly)(this, \"_isSigner\", true);\n\t    }\n\t    ///////////////////\n\t    // Sub-classes MAY override these\n\t    Signer.prototype.getBalance = function (blockTag) {\n\t        return __awaiter(this, void 0, void 0, function () {\n\t            return __generator(this, function (_a) {\n\t                switch (_a.label) {\n\t                    case 0:\n\t                        this._checkProvider(\"getBalance\");\n\t                        return [4 /*yield*/, this.provider.getBalance(this.getAddress(), blockTag)];\n\t                    case 1: return [2 /*return*/, _a.sent()];\n\t                }\n\t            });\n\t        });\n\t    };\n\t    Signer.prototype.getTransactionCount = function (blockTag) {\n\t        return __awaiter(this, void 0, void 0, function () {\n\t            return __generator(this, function (_a) {\n\t                switch (_a.label) {\n\t                    case 0:\n\t                        this._checkProvider(\"getTransactionCount\");\n\t                        return [4 /*yield*/, this.provider.getTransactionCount(this.getAddress(), blockTag)];\n\t                    case 1: return [2 /*return*/, _a.sent()];\n\t                }\n\t            });\n\t        });\n\t    };\n\t    // Populates \"from\" if unspecified, and estimates the gas for the transaction\n\t    Signer.prototype.estimateGas = function (transaction) {\n\t        return __awaiter(this, void 0, void 0, function () {\n\t            var tx;\n\t            return __generator(this, function (_a) {\n\t                switch (_a.label) {\n\t                    case 0:\n\t                        this._checkProvider(\"estimateGas\");\n\t                        return [4 /*yield*/, (0, lib$3.resolveProperties)(this.checkTransaction(transaction))];\n\t                    case 1:\n\t                        tx = _a.sent();\n\t                        return [4 /*yield*/, this.provider.estimateGas(tx)];\n\t                    case 2: return [2 /*return*/, _a.sent()];\n\t                }\n\t            });\n\t        });\n\t    };\n\t    // Populates \"from\" if unspecified, and calls with the transaction\n\t    Signer.prototype.call = function (transaction, blockTag) {\n\t        return __awaiter(this, void 0, void 0, function () {\n\t            var tx;\n\t            return __generator(this, function (_a) {\n\t                switch (_a.label) {\n\t                    case 0:\n\t                        this._checkProvider(\"call\");\n\t                        return [4 /*yield*/, (0, lib$3.resolveProperties)(this.checkTransaction(transaction))];\n\t                    case 1:\n\t                        tx = _a.sent();\n\t                        return [4 /*yield*/, this.provider.call(tx, blockTag)];\n\t                    case 2: return [2 /*return*/, _a.sent()];\n\t                }\n\t            });\n\t        });\n\t    };\n\t    // Populates all fields in a transaction, signs it and sends it to the network\n\t    Signer.prototype.sendTransaction = function (transaction) {\n\t        return __awaiter(this, void 0, void 0, function () {\n\t            var tx, signedTx;\n\t            return __generator(this, function (_a) {\n\t                switch (_a.label) {\n\t                    case 0:\n\t                        this._checkProvider(\"sendTransaction\");\n\t                        return [4 /*yield*/, this.populateTransaction(transaction)];\n\t                    case 1:\n\t                        tx = _a.sent();\n\t                        return [4 /*yield*/, this.signTransaction(tx)];\n\t                    case 2:\n\t                        signedTx = _a.sent();\n\t                        return [4 /*yield*/, this.provider.sendTransaction(signedTx)];\n\t                    case 3: return [2 /*return*/, _a.sent()];\n\t                }\n\t            });\n\t        });\n\t    };\n\t    Signer.prototype.getChainId = function () {\n\t        return __awaiter(this, void 0, void 0, function () {\n\t            var network;\n\t            return __generator(this, function (_a) {\n\t                switch (_a.label) {\n\t                    case 0:\n\t                        this._checkProvider(\"getChainId\");\n\t                        return [4 /*yield*/, this.provider.getNetwork()];\n\t                    case 1:\n\t                        network = _a.sent();\n\t                        return [2 /*return*/, network.chainId];\n\t                }\n\t            });\n\t        });\n\t    };\n\t    Signer.prototype.getGasPrice = function () {\n\t        return __awaiter(this, void 0, void 0, function () {\n\t            return __generator(this, function (_a) {\n\t                switch (_a.label) {\n\t                    case 0:\n\t                        this._checkProvider(\"getGasPrice\");\n\t                        return [4 /*yield*/, this.provider.getGasPrice()];\n\t                    case 1: return [2 /*return*/, _a.sent()];\n\t                }\n\t            });\n\t        });\n\t    };\n\t    Signer.prototype.getFeeData = function () {\n\t        return __awaiter(this, void 0, void 0, function () {\n\t            return __generator(this, function (_a) {\n\t                switch (_a.label) {\n\t                    case 0:\n\t                        this._checkProvider(\"getFeeData\");\n\t                        return [4 /*yield*/, this.provider.getFeeData()];\n\t                    case 1: return [2 /*return*/, _a.sent()];\n\t                }\n\t            });\n\t        });\n\t    };\n\t    Signer.prototype.resolveName = function (name) {\n\t        return __awaiter(this, void 0, void 0, function () {\n\t            return __generator(this, function (_a) {\n\t                switch (_a.label) {\n\t                    case 0:\n\t                        this._checkProvider(\"resolveName\");\n\t                        return [4 /*yield*/, this.provider.resolveName(name)];\n\t                    case 1: return [2 /*return*/, _a.sent()];\n\t                }\n\t            });\n\t        });\n\t    };\n\t    // Checks a transaction does not contain invalid keys and if\n\t    // no \"from\" is provided, populates it.\n\t    // - does NOT require a provider\n\t    // - adds \"from\" is not present\n\t    // - returns a COPY (safe to mutate the result)\n\t    // By default called from: (overriding these prevents it)\n\t    //   - call\n\t    //   - estimateGas\n\t    //   - populateTransaction (and therefor sendTransaction)\n\t    Signer.prototype.checkTransaction = function (transaction) {\n\t        for (var key in transaction) {\n\t            if (allowedTransactionKeys.indexOf(key) === -1) {\n\t                logger.throwArgumentError(\"invalid transaction key: \" + key, \"transaction\", transaction);\n\t            }\n\t        }\n\t        var tx = (0, lib$3.shallowCopy)(transaction);\n\t        if (tx.from == null) {\n\t            tx.from = this.getAddress();\n\t        }\n\t        else {\n\t            // Make sure any provided address matches this signer\n\t            tx.from = Promise.all([\n\t                Promise.resolve(tx.from),\n\t                this.getAddress()\n\t            ]).then(function (result) {\n\t                if (result[0].toLowerCase() !== result[1].toLowerCase()) {\n\t                    logger.throwArgumentError(\"from address mismatch\", \"transaction\", transaction);\n\t                }\n\t                return result[0];\n\t            });\n\t        }\n\t        return tx;\n\t    };\n\t    // Populates ALL keys for a transaction and checks that \"from\" matches\n\t    // this Signer. Should be used by sendTransaction but NOT by signTransaction.\n\t    // By default called from: (overriding these prevents it)\n\t    //   - sendTransaction\n\t    //\n\t    // Notes:\n\t    //  - We allow gasPrice for EIP-1559 as long as it matches maxFeePerGas\n\t    Signer.prototype.populateTransaction = function (transaction) {\n\t        return __awaiter(this, void 0, void 0, function () {\n\t            var tx, hasEip1559, feeData, gasPrice;\n\t            var _this = this;\n\t            return __generator(this, function (_a) {\n\t                switch (_a.label) {\n\t                    case 0: return [4 /*yield*/, (0, lib$3.resolveProperties)(this.checkTransaction(transaction))];\n\t                    case 1:\n\t                        tx = _a.sent();\n\t                        if (tx.to != null) {\n\t                            tx.to = Promise.resolve(tx.to).then(function (to) { return __awaiter(_this, void 0, void 0, function () {\n\t                                var address;\n\t                                return __generator(this, function (_a) {\n\t                                    switch (_a.label) {\n\t                                        case 0:\n\t                                            if (to == null) {\n\t                                                return [2 /*return*/, null];\n\t                                            }\n\t                                            return [4 /*yield*/, this.resolveName(to)];\n\t                                        case 1:\n\t                                            address = _a.sent();\n\t                                            if (address == null) {\n\t                                                logger.throwArgumentError(\"provided ENS name resolves to null\", \"tx.to\", to);\n\t                                            }\n\t                                            return [2 /*return*/, address];\n\t                                    }\n\t                                });\n\t                            }); });\n\t                            // Prevent this error from causing an UnhandledPromiseException\n\t                            tx.to.catch(function (error) { });\n\t                        }\n\t                        hasEip1559 = (tx.maxFeePerGas != null || tx.maxPriorityFeePerGas != null);\n\t                        if (tx.gasPrice != null && (tx.type === 2 || hasEip1559)) {\n\t                            logger.throwArgumentError(\"eip-1559 transaction do not support gasPrice\", \"transaction\", transaction);\n\t                        }\n\t                        else if ((tx.type === 0 || tx.type === 1) && hasEip1559) {\n\t                            logger.throwArgumentError(\"pre-eip-1559 transaction do not support maxFeePerGas/maxPriorityFeePerGas\", \"transaction\", transaction);\n\t                        }\n\t                        if (!((tx.type === 2 || tx.type == null) && (tx.maxFeePerGas != null && tx.maxPriorityFeePerGas != null))) return [3 /*break*/, 2];\n\t                        // Fully-formed EIP-1559 transaction (skip getFeeData)\n\t                        tx.type = 2;\n\t                        return [3 /*break*/, 5];\n\t                    case 2:\n\t                        if (!(tx.type === 0 || tx.type === 1)) return [3 /*break*/, 3];\n\t                        // Explicit Legacy or EIP-2930 transaction\n\t                        // Populate missing gasPrice\n\t                        if (tx.gasPrice == null) {\n\t                            tx.gasPrice = this.getGasPrice();\n\t                        }\n\t                        return [3 /*break*/, 5];\n\t                    case 3: return [4 /*yield*/, this.getFeeData()];\n\t                    case 4:\n\t                        feeData = _a.sent();\n\t                        if (tx.type == null) {\n\t                            // We need to auto-detect the intended type of this transaction...\n\t                            if (feeData.maxFeePerGas != null && feeData.maxPriorityFeePerGas != null) {\n\t                                // The network supports EIP-1559!\n\t                                // Upgrade transaction from null to eip-1559\n\t                                tx.type = 2;\n\t                                if (tx.gasPrice != null) {\n\t                                    gasPrice = tx.gasPrice;\n\t                                    delete tx.gasPrice;\n\t                                    tx.maxFeePerGas = gasPrice;\n\t                                    tx.maxPriorityFeePerGas = gasPrice;\n\t                                }\n\t                                else {\n\t                                    // Populate missing fee data\n\t                                    if (tx.maxFeePerGas == null) {\n\t                                        tx.maxFeePerGas = feeData.maxFeePerGas;\n\t                                    }\n\t                                    if (tx.maxPriorityFeePerGas == null) {\n\t                                        tx.maxPriorityFeePerGas = feeData.maxPriorityFeePerGas;\n\t                                    }\n\t                                }\n\t                            }\n\t                            else if (feeData.gasPrice != null) {\n\t                                // Network doesn't support EIP-1559...\n\t                                // ...but they are trying to use EIP-1559 properties\n\t                                if (hasEip1559) {\n\t                                    logger.throwError(\"network does not support EIP-1559\", lib.Logger.errors.UNSUPPORTED_OPERATION, {\n\t                                        operation: \"populateTransaction\"\n\t                                    });\n\t                                }\n\t                                // Populate missing fee data\n\t                                if (tx.gasPrice == null) {\n\t                                    tx.gasPrice = feeData.gasPrice;\n\t                                }\n\t                                // Explicitly set untyped transaction to legacy\n\t                                tx.type = 0;\n\t                            }\n\t                            else {\n\t                                // getFeeData has failed us.\n\t                                logger.throwError(\"failed to get consistent fee data\", lib.Logger.errors.UNSUPPORTED_OPERATION, {\n\t                                    operation: \"signer.getFeeData\"\n\t                                });\n\t                            }\n\t                        }\n\t                        else if (tx.type === 2) {\n\t                            // Explicitly using EIP-1559\n\t                            // Populate missing fee data\n\t                            if (tx.maxFeePerGas == null) {\n\t                                tx.maxFeePerGas = feeData.maxFeePerGas;\n\t                            }\n\t                            if (tx.maxPriorityFeePerGas == null) {\n\t                                tx.maxPriorityFeePerGas = feeData.maxPriorityFeePerGas;\n\t                            }\n\t                        }\n\t                        _a.label = 5;\n\t                    case 5:\n\t                        if (tx.nonce == null) {\n\t                            tx.nonce = this.getTransactionCount(\"pending\");\n\t                        }\n\t                        if (tx.gasLimit == null) {\n\t                            tx.gasLimit = this.estimateGas(tx).catch(function (error) {\n\t                                if (forwardErrors.indexOf(error.code) >= 0) {\n\t                                    throw error;\n\t                                }\n\t                                return logger.throwError(\"cannot estimate gas; transaction may fail or may require manual gas limit\", lib.Logger.errors.UNPREDICTABLE_GAS_LIMIT, {\n\t                                    error: error,\n\t                                    tx: tx\n\t                                });\n\t                            });\n\t                        }\n\t                        if (tx.chainId == null) {\n\t                            tx.chainId = this.getChainId();\n\t                        }\n\t                        else {\n\t                            tx.chainId = Promise.all([\n\t                                Promise.resolve(tx.chainId),\n\t                                this.getChainId()\n\t                            ]).then(function (results) {\n\t                                if (results[1] !== 0 && results[0] !== results[1]) {\n\t                                    logger.throwArgumentError(\"chainId address mismatch\", \"transaction\", transaction);\n\t                                }\n\t                                return results[0];\n\t                            });\n\t                        }\n\t                        return [4 /*yield*/, (0, lib$3.resolveProperties)(tx)];\n\t                    case 6: return [2 /*return*/, _a.sent()];\n\t                }\n\t            });\n\t        });\n\t    };\n\t    ///////////////////\n\t    // Sub-classes SHOULD leave these alone\n\t    Signer.prototype._checkProvider = function (operation) {\n\t        if (!this.provider) {\n\t            logger.throwError(\"missing provider\", lib.Logger.errors.UNSUPPORTED_OPERATION, {\n\t                operation: (operation || \"_checkProvider\")\n\t            });\n\t        }\n\t    };\n\t    Signer.isSigner = function (value) {\n\t        return !!(value && value._isSigner);\n\t    };\n\t    return Signer;\n\t}());\n\texports.Signer = Signer;\n\tvar VoidSigner = /** @class */ (function (_super) {\n\t    __extends(VoidSigner, _super);\n\t    function VoidSigner(address, provider) {\n\t        var _newTarget = this.constructor;\n\t        var _this = this;\n\t        logger.checkNew(_newTarget, VoidSigner);\n\t        _this = _super.call(this) || this;\n\t        (0, lib$3.defineReadOnly)(_this, \"address\", address);\n\t        (0, lib$3.defineReadOnly)(_this, \"provider\", provider || null);\n\t        return _this;\n\t    }\n\t    VoidSigner.prototype.getAddress = function () {\n\t        return Promise.resolve(this.address);\n\t    };\n\t    VoidSigner.prototype._fail = function (message, operation) {\n\t        return Promise.resolve().then(function () {\n\t            logger.throwError(message, lib.Logger.errors.UNSUPPORTED_OPERATION, { operation: operation });\n\t        });\n\t    };\n\t    VoidSigner.prototype.signMessage = function (message) {\n\t        return this._fail(\"VoidSigner cannot sign messages\", \"signMessage\");\n\t    };\n\t    VoidSigner.prototype.signTransaction = function (transaction) {\n\t        return this._fail(\"VoidSigner cannot sign transactions\", \"signTransaction\");\n\t    };\n\t    VoidSigner.prototype._signTypedData = function (domain, types, value) {\n\t        return this._fail(\"VoidSigner cannot sign typed data\", \"signTypedData\");\n\t    };\n\t    VoidSigner.prototype.connect = function (provider) {\n\t        return new VoidSigner(this.address, provider);\n\t    };\n\t    return VoidSigner;\n\t}(Signer));\n\texports.VoidSigner = VoidSigner;\n\n\t});\n\n\tvar index$c = /*@__PURE__*/getDefaultExportFromCjs(lib$c);\n\n\tvar minimalisticAssert = assert;\n\n\tfunction assert(val, msg) {\n\t  if (!val)\n\t    throw new Error(msg || 'Assertion failed');\n\t}\n\n\tassert.equal = function assertEqual(l, r, msg) {\n\t  if (l != r)\n\t    throw new Error(msg || ('Assertion failed: ' + l + ' != ' + r));\n\t};\n\n\tvar utils_1 = createCommonjsModule(function (module, exports) {\n\t'use strict';\n\n\tvar utils = exports;\n\n\tfunction toArray(msg, enc) {\n\t  if (Array.isArray(msg))\n\t    return msg.slice();\n\t  if (!msg)\n\t    return [];\n\t  var res = [];\n\t  if (typeof msg !== 'string') {\n\t    for (var i = 0; i < msg.length; i++)\n\t      res[i] = msg[i] | 0;\n\t    return res;\n\t  }\n\t  if (enc === 'hex') {\n\t    msg = msg.replace(/[^a-z0-9]+/ig, '');\n\t    if (msg.length % 2 !== 0)\n\t      msg = '0' + msg;\n\t    for (var i = 0; i < msg.length; i += 2)\n\t      res.push(parseInt(msg[i] + msg[i + 1], 16));\n\t  } else {\n\t    for (var i = 0; i < msg.length; i++) {\n\t      var c = msg.charCodeAt(i);\n\t      var hi = c >> 8;\n\t      var lo = c & 0xff;\n\t      if (hi)\n\t        res.push(hi, lo);\n\t      else\n\t        res.push(lo);\n\t    }\n\t  }\n\t  return res;\n\t}\n\tutils.toArray = toArray;\n\n\tfunction zero2(word) {\n\t  if (word.length === 1)\n\t    return '0' + word;\n\t  else\n\t    return word;\n\t}\n\tutils.zero2 = zero2;\n\n\tfunction toHex(msg) {\n\t  var res = '';\n\t  for (var i = 0; i < msg.length; i++)\n\t    res += zero2(msg[i].toString(16));\n\t  return res;\n\t}\n\tutils.toHex = toHex;\n\n\tutils.encode = function encode(arr, enc) {\n\t  if (enc === 'hex')\n\t    return toHex(arr);\n\t  else\n\t    return arr;\n\t};\n\t});\n\n\tvar utils_1$1 = createCommonjsModule(function (module, exports) {\n\t'use strict';\n\n\tvar utils = exports;\n\n\n\n\n\tutils.assert = minimalisticAssert;\n\tutils.toArray = utils_1.toArray;\n\tutils.zero2 = utils_1.zero2;\n\tutils.toHex = utils_1.toHex;\n\tutils.encode = utils_1.encode;\n\n\t// Represent num in a w-NAF form\n\tfunction getNAF(num, w, bits) {\n\t  var naf = new Array(Math.max(num.bitLength(), bits) + 1);\n\t  naf.fill(0);\n\n\t  var ws = 1 << (w + 1);\n\t  var k = num.clone();\n\n\t  for (var i = 0; i < naf.length; i++) {\n\t    var z;\n\t    var mod = k.andln(ws - 1);\n\t    if (k.isOdd()) {\n\t      if (mod > (ws >> 1) - 1)\n\t        z = (ws >> 1) - mod;\n\t      else\n\t        z = mod;\n\t      k.isubn(z);\n\t    } else {\n\t      z = 0;\n\t    }\n\n\t    naf[i] = z;\n\t    k.iushrn(1);\n\t  }\n\n\t  return naf;\n\t}\n\tutils.getNAF = getNAF;\n\n\t// Represent k1, k2 in a Joint Sparse Form\n\tfunction getJSF(k1, k2) {\n\t  var jsf = [\n\t    [],\n\t    [],\n\t  ];\n\n\t  k1 = k1.clone();\n\t  k2 = k2.clone();\n\t  var d1 = 0;\n\t  var d2 = 0;\n\t  var m8;\n\t  while (k1.cmpn(-d1) > 0 || k2.cmpn(-d2) > 0) {\n\t    // First phase\n\t    var m14 = (k1.andln(3) + d1) & 3;\n\t    var m24 = (k2.andln(3) + d2) & 3;\n\t    if (m14 === 3)\n\t      m14 = -1;\n\t    if (m24 === 3)\n\t      m24 = -1;\n\t    var u1;\n\t    if ((m14 & 1) === 0) {\n\t      u1 = 0;\n\t    } else {\n\t      m8 = (k1.andln(7) + d1) & 7;\n\t      if ((m8 === 3 || m8 === 5) && m24 === 2)\n\t        u1 = -m14;\n\t      else\n\t        u1 = m14;\n\t    }\n\t    jsf[0].push(u1);\n\n\t    var u2;\n\t    if ((m24 & 1) === 0) {\n\t      u2 = 0;\n\t    } else {\n\t      m8 = (k2.andln(7) + d2) & 7;\n\t      if ((m8 === 3 || m8 === 5) && m14 === 2)\n\t        u2 = -m24;\n\t      else\n\t        u2 = m24;\n\t    }\n\t    jsf[1].push(u2);\n\n\t    // Second phase\n\t    if (2 * d1 === u1 + 1)\n\t      d1 = 1 - d1;\n\t    if (2 * d2 === u2 + 1)\n\t      d2 = 1 - d2;\n\t    k1.iushrn(1);\n\t    k2.iushrn(1);\n\t  }\n\n\t  return jsf;\n\t}\n\tutils.getJSF = getJSF;\n\n\tfunction cachedProperty(obj, name, computer) {\n\t  var key = '_' + name;\n\t  obj.prototype[name] = function cachedProperty() {\n\t    return this[key] !== undefined ? this[key] :\n\t      this[key] = computer.call(this);\n\t  };\n\t}\n\tutils.cachedProperty = cachedProperty;\n\n\tfunction parseBytes(bytes) {\n\t  return typeof bytes === 'string' ? utils.toArray(bytes, 'hex') :\n\t    bytes;\n\t}\n\tutils.parseBytes = parseBytes;\n\n\tfunction intFromLE(bytes) {\n\t  return new bn(bytes, 'hex', 'le');\n\t}\n\tutils.intFromLE = intFromLE;\n\t});\n\n\t'use strict';\n\n\n\n\tvar getNAF = utils_1$1.getNAF;\n\tvar getJSF = utils_1$1.getJSF;\n\tvar assert$1 = utils_1$1.assert;\n\n\tfunction BaseCurve(type, conf) {\n\t  this.type = type;\n\t  this.p = new bn(conf.p, 16);\n\n\t  // Use Montgomery, when there is no fast reduction for the prime\n\t  this.red = conf.prime ? bn.red(conf.prime) : bn.mont(this.p);\n\n\t  // Useful for many curves\n\t  this.zero = new bn(0).toRed(this.red);\n\t  this.one = new bn(1).toRed(this.red);\n\t  this.two = new bn(2).toRed(this.red);\n\n\t  // Curve configuration, optional\n\t  this.n = conf.n && new bn(conf.n, 16);\n\t  this.g = conf.g && this.pointFromJSON(conf.g, conf.gRed);\n\n\t  // Temporary arrays\n\t  this._wnafT1 = new Array(4);\n\t  this._wnafT2 = new Array(4);\n\t  this._wnafT3 = new Array(4);\n\t  this._wnafT4 = new Array(4);\n\n\t  this._bitLength = this.n ? this.n.bitLength() : 0;\n\n\t  // Generalized Greg Maxwell's trick\n\t  var adjustCount = this.n && this.p.div(this.n);\n\t  if (!adjustCount || adjustCount.cmpn(100) > 0) {\n\t    this.redN = null;\n\t  } else {\n\t    this._maxwellTrick = true;\n\t    this.redN = this.n.toRed(this.red);\n\t  }\n\t}\n\tvar base = BaseCurve;\n\n\tBaseCurve.prototype.point = function point() {\n\t  throw new Error('Not implemented');\n\t};\n\n\tBaseCurve.prototype.validate = function validate() {\n\t  throw new Error('Not implemented');\n\t};\n\n\tBaseCurve.prototype._fixedNafMul = function _fixedNafMul(p, k) {\n\t  assert$1(p.precomputed);\n\t  var doubles = p._getDoubles();\n\n\t  var naf = getNAF(k, 1, this._bitLength);\n\t  var I = (1 << (doubles.step + 1)) - (doubles.step % 2 === 0 ? 2 : 1);\n\t  I /= 3;\n\n\t  // Translate into more windowed form\n\t  var repr = [];\n\t  var j;\n\t  var nafW;\n\t  for (j = 0; j < naf.length; j += doubles.step) {\n\t    nafW = 0;\n\t    for (var l = j + doubles.step - 1; l >= j; l--)\n\t      nafW = (nafW << 1) + naf[l];\n\t    repr.push(nafW);\n\t  }\n\n\t  var a = this.jpoint(null, null, null);\n\t  var b = this.jpoint(null, null, null);\n\t  for (var i = I; i > 0; i--) {\n\t    for (j = 0; j < repr.length; j++) {\n\t      nafW = repr[j];\n\t      if (nafW === i)\n\t        b = b.mixedAdd(doubles.points[j]);\n\t      else if (nafW === -i)\n\t        b = b.mixedAdd(doubles.points[j].neg());\n\t    }\n\t    a = a.add(b);\n\t  }\n\t  return a.toP();\n\t};\n\n\tBaseCurve.prototype._wnafMul = function _wnafMul(p, k) {\n\t  var w = 4;\n\n\t  // Precompute window\n\t  var nafPoints = p._getNAFPoints(w);\n\t  w = nafPoints.wnd;\n\t  var wnd = nafPoints.points;\n\n\t  // Get NAF form\n\t  var naf = getNAF(k, w, this._bitLength);\n\n\t  // Add `this`*(N+1) for every w-NAF index\n\t  var acc = this.jpoint(null, null, null);\n\t  for (var i = naf.length - 1; i >= 0; i--) {\n\t    // Count zeroes\n\t    for (var l = 0; i >= 0 && naf[i] === 0; i--)\n\t      l++;\n\t    if (i >= 0)\n\t      l++;\n\t    acc = acc.dblp(l);\n\n\t    if (i < 0)\n\t      break;\n\t    var z = naf[i];\n\t    assert$1(z !== 0);\n\t    if (p.type === 'affine') {\n\t      // J +- P\n\t      if (z > 0)\n\t        acc = acc.mixedAdd(wnd[(z - 1) >> 1]);\n\t      else\n\t        acc = acc.mixedAdd(wnd[(-z - 1) >> 1].neg());\n\t    } else {\n\t      // J +- J\n\t      if (z > 0)\n\t        acc = acc.add(wnd[(z - 1) >> 1]);\n\t      else\n\t        acc = acc.add(wnd[(-z - 1) >> 1].neg());\n\t    }\n\t  }\n\t  return p.type === 'affine' ? acc.toP() : acc;\n\t};\n\n\tBaseCurve.prototype._wnafMulAdd = function _wnafMulAdd(defW,\n\t  points,\n\t  coeffs,\n\t  len,\n\t  jacobianResult) {\n\t  var wndWidth = this._wnafT1;\n\t  var wnd = this._wnafT2;\n\t  var naf = this._wnafT3;\n\n\t  // Fill all arrays\n\t  var max = 0;\n\t  var i;\n\t  var j;\n\t  var p;\n\t  for (i = 0; i < len; i++) {\n\t    p = points[i];\n\t    var nafPoints = p._getNAFPoints(defW);\n\t    wndWidth[i] = nafPoints.wnd;\n\t    wnd[i] = nafPoints.points;\n\t  }\n\n\t  // Comb small window NAFs\n\t  for (i = len - 1; i >= 1; i -= 2) {\n\t    var a = i - 1;\n\t    var b = i;\n\t    if (wndWidth[a] !== 1 || wndWidth[b] !== 1) {\n\t      naf[a] = getNAF(coeffs[a], wndWidth[a], this._bitLength);\n\t      naf[b] = getNAF(coeffs[b], wndWidth[b], this._bitLength);\n\t      max = Math.max(naf[a].length, max);\n\t      max = Math.max(naf[b].length, max);\n\t      continue;\n\t    }\n\n\t    var comb = [\n\t      points[a], /* 1 */\n\t      null, /* 3 */\n\t      null, /* 5 */\n\t      points[b], /* 7 */\n\t    ];\n\n\t    // Try to avoid Projective points, if possible\n\t    if (points[a].y.cmp(points[b].y) === 0) {\n\t      comb[1] = points[a].add(points[b]);\n\t      comb[2] = points[a].toJ().mixedAdd(points[b].neg());\n\t    } else if (points[a].y.cmp(points[b].y.redNeg()) === 0) {\n\t      comb[1] = points[a].toJ().mixedAdd(points[b]);\n\t      comb[2] = points[a].add(points[b].neg());\n\t    } else {\n\t      comb[1] = points[a].toJ().mixedAdd(points[b]);\n\t      comb[2] = points[a].toJ().mixedAdd(points[b].neg());\n\t    }\n\n\t    var index = [\n\t      -3, /* -1 -1 */\n\t      -1, /* -1 0 */\n\t      -5, /* -1 1 */\n\t      -7, /* 0 -1 */\n\t      0, /* 0 0 */\n\t      7, /* 0 1 */\n\t      5, /* 1 -1 */\n\t      1, /* 1 0 */\n\t      3,  /* 1 1 */\n\t    ];\n\n\t    var jsf = getJSF(coeffs[a], coeffs[b]);\n\t    max = Math.max(jsf[0].length, max);\n\t    naf[a] = new Array(max);\n\t    naf[b] = new Array(max);\n\t    for (j = 0; j < max; j++) {\n\t      var ja = jsf[0][j] | 0;\n\t      var jb = jsf[1][j] | 0;\n\n\t      naf[a][j] = index[(ja + 1) * 3 + (jb + 1)];\n\t      naf[b][j] = 0;\n\t      wnd[a] = comb;\n\t    }\n\t  }\n\n\t  var acc = this.jpoint(null, null, null);\n\t  var tmp = this._wnafT4;\n\t  for (i = max; i >= 0; i--) {\n\t    var k = 0;\n\n\t    while (i >= 0) {\n\t      var zero = true;\n\t      for (j = 0; j < len; j++) {\n\t        tmp[j] = naf[j][i] | 0;\n\t        if (tmp[j] !== 0)\n\t          zero = false;\n\t      }\n\t      if (!zero)\n\t        break;\n\t      k++;\n\t      i--;\n\t    }\n\t    if (i >= 0)\n\t      k++;\n\t    acc = acc.dblp(k);\n\t    if (i < 0)\n\t      break;\n\n\t    for (j = 0; j < len; j++) {\n\t      var z = tmp[j];\n\t      p;\n\t      if (z === 0)\n\t        continue;\n\t      else if (z > 0)\n\t        p = wnd[j][(z - 1) >> 1];\n\t      else if (z < 0)\n\t        p = wnd[j][(-z - 1) >> 1].neg();\n\n\t      if (p.type === 'affine')\n\t        acc = acc.mixedAdd(p);\n\t      else\n\t        acc = acc.add(p);\n\t    }\n\t  }\n\t  // Zeroify references\n\t  for (i = 0; i < len; i++)\n\t    wnd[i] = null;\n\n\t  if (jacobianResult)\n\t    return acc;\n\t  else\n\t    return acc.toP();\n\t};\n\n\tfunction BasePoint(curve, type) {\n\t  this.curve = curve;\n\t  this.type = type;\n\t  this.precomputed = null;\n\t}\n\tBaseCurve.BasePoint = BasePoint;\n\n\tBasePoint.prototype.eq = function eq(/*other*/) {\n\t  throw new Error('Not implemented');\n\t};\n\n\tBasePoint.prototype.validate = function validate() {\n\t  return this.curve.validate(this);\n\t};\n\n\tBaseCurve.prototype.decodePoint = function decodePoint(bytes, enc) {\n\t  bytes = utils_1$1.toArray(bytes, enc);\n\n\t  var len = this.p.byteLength();\n\n\t  // uncompressed, hybrid-odd, hybrid-even\n\t  if ((bytes[0] === 0x04 || bytes[0] === 0x06 || bytes[0] === 0x07) &&\n\t      bytes.length - 1 === 2 * len) {\n\t    if (bytes[0] === 0x06)\n\t      assert$1(bytes[bytes.length - 1] % 2 === 0);\n\t    else if (bytes[0] === 0x07)\n\t      assert$1(bytes[bytes.length - 1] % 2 === 1);\n\n\t    var res =  this.point(bytes.slice(1, 1 + len),\n\t      bytes.slice(1 + len, 1 + 2 * len));\n\n\t    return res;\n\t  } else if ((bytes[0] === 0x02 || bytes[0] === 0x03) &&\n\t              bytes.length - 1 === len) {\n\t    return this.pointFromX(bytes.slice(1, 1 + len), bytes[0] === 0x03);\n\t  }\n\t  throw new Error('Unknown point format');\n\t};\n\n\tBasePoint.prototype.encodeCompressed = function encodeCompressed(enc) {\n\t  return this.encode(enc, true);\n\t};\n\n\tBasePoint.prototype._encode = function _encode(compact) {\n\t  var len = this.curve.p.byteLength();\n\t  var x = this.getX().toArray('be', len);\n\n\t  if (compact)\n\t    return [ this.getY().isEven() ? 0x02 : 0x03 ].concat(x);\n\n\t  return [ 0x04 ].concat(x, this.getY().toArray('be', len));\n\t};\n\n\tBasePoint.prototype.encode = function encode(enc, compact) {\n\t  return utils_1$1.encode(this._encode(compact), enc);\n\t};\n\n\tBasePoint.prototype.precompute = function precompute(power) {\n\t  if (this.precomputed)\n\t    return this;\n\n\t  var precomputed = {\n\t    doubles: null,\n\t    naf: null,\n\t    beta: null,\n\t  };\n\t  precomputed.naf = this._getNAFPoints(8);\n\t  precomputed.doubles = this._getDoubles(4, power);\n\t  precomputed.beta = this._getBeta();\n\t  this.precomputed = precomputed;\n\n\t  return this;\n\t};\n\n\tBasePoint.prototype._hasDoubles = function _hasDoubles(k) {\n\t  if (!this.precomputed)\n\t    return false;\n\n\t  var doubles = this.precomputed.doubles;\n\t  if (!doubles)\n\t    return false;\n\n\t  return doubles.points.length >= Math.ceil((k.bitLength() + 1) / doubles.step);\n\t};\n\n\tBasePoint.prototype._getDoubles = function _getDoubles(step, power) {\n\t  if (this.precomputed && this.precomputed.doubles)\n\t    return this.precomputed.doubles;\n\n\t  var doubles = [ this ];\n\t  var acc = this;\n\t  for (var i = 0; i < power; i += step) {\n\t    for (var j = 0; j < step; j++)\n\t      acc = acc.dbl();\n\t    doubles.push(acc);\n\t  }\n\t  return {\n\t    step: step,\n\t    points: doubles,\n\t  };\n\t};\n\n\tBasePoint.prototype._getNAFPoints = function _getNAFPoints(wnd) {\n\t  if (this.precomputed && this.precomputed.naf)\n\t    return this.precomputed.naf;\n\n\t  var res = [ this ];\n\t  var max = (1 << wnd) - 1;\n\t  var dbl = max === 1 ? null : this.dbl();\n\t  for (var i = 1; i < max; i++)\n\t    res[i] = res[i - 1].add(dbl);\n\t  return {\n\t    wnd: wnd,\n\t    points: res,\n\t  };\n\t};\n\n\tBasePoint.prototype._getBeta = function _getBeta() {\n\t  return null;\n\t};\n\n\tBasePoint.prototype.dblp = function dblp(k) {\n\t  var r = this;\n\t  for (var i = 0; i < k; i++)\n\t    r = r.dbl();\n\t  return r;\n\t};\n\n\tvar inherits_browser = createCommonjsModule(function (module) {\n\tif (typeof Object.create === 'function') {\n\t  // implementation from standard node.js 'util' module\n\t  module.exports = function inherits(ctor, superCtor) {\n\t    if (superCtor) {\n\t      ctor.super_ = superCtor;\n\t      ctor.prototype = Object.create(superCtor.prototype, {\n\t        constructor: {\n\t          value: ctor,\n\t          enumerable: false,\n\t          writable: true,\n\t          configurable: true\n\t        }\n\t      });\n\t    }\n\t  };\n\t} else {\n\t  // old school shim for old browsers\n\t  module.exports = function inherits(ctor, superCtor) {\n\t    if (superCtor) {\n\t      ctor.super_ = superCtor;\n\t      var TempCtor = function () {};\n\t      TempCtor.prototype = superCtor.prototype;\n\t      ctor.prototype = new TempCtor();\n\t      ctor.prototype.constructor = ctor;\n\t    }\n\t  };\n\t}\n\t});\n\n\t'use strict';\n\n\n\n\n\n\n\tvar assert$2 = utils_1$1.assert;\n\n\tfunction ShortCurve(conf) {\n\t  base.call(this, 'short', conf);\n\n\t  this.a = new bn(conf.a, 16).toRed(this.red);\n\t  this.b = new bn(conf.b, 16).toRed(this.red);\n\t  this.tinv = this.two.redInvm();\n\n\t  this.zeroA = this.a.fromRed().cmpn(0) === 0;\n\t  this.threeA = this.a.fromRed().sub(this.p).cmpn(-3) === 0;\n\n\t  // If the curve is endomorphic, precalculate beta and lambda\n\t  this.endo = this._getEndomorphism(conf);\n\t  this._endoWnafT1 = new Array(4);\n\t  this._endoWnafT2 = new Array(4);\n\t}\n\tinherits_browser(ShortCurve, base);\n\tvar short_1 = ShortCurve;\n\n\tShortCurve.prototype._getEndomorphism = function _getEndomorphism(conf) {\n\t  // No efficient endomorphism\n\t  if (!this.zeroA || !this.g || !this.n || this.p.modn(3) !== 1)\n\t    return;\n\n\t  // Compute beta and lambda, that lambda * P = (beta * Px; Py)\n\t  var beta;\n\t  var lambda;\n\t  if (conf.beta) {\n\t    beta = new bn(conf.beta, 16).toRed(this.red);\n\t  } else {\n\t    var betas = this._getEndoRoots(this.p);\n\t    // Choose the smallest beta\n\t    beta = betas[0].cmp(betas[1]) < 0 ? betas[0] : betas[1];\n\t    beta = beta.toRed(this.red);\n\t  }\n\t  if (conf.lambda) {\n\t    lambda = new bn(conf.lambda, 16);\n\t  } else {\n\t    // Choose the lambda that is matching selected beta\n\t    var lambdas = this._getEndoRoots(this.n);\n\t    if (this.g.mul(lambdas[0]).x.cmp(this.g.x.redMul(beta)) === 0) {\n\t      lambda = lambdas[0];\n\t    } else {\n\t      lambda = lambdas[1];\n\t      assert$2(this.g.mul(lambda).x.cmp(this.g.x.redMul(beta)) === 0);\n\t    }\n\t  }\n\n\t  // Get basis vectors, used for balanced length-two representation\n\t  var basis;\n\t  if (conf.basis) {\n\t    basis = conf.basis.map(function(vec) {\n\t      return {\n\t        a: new bn(vec.a, 16),\n\t        b: new bn(vec.b, 16),\n\t      };\n\t    });\n\t  } else {\n\t    basis = this._getEndoBasis(lambda);\n\t  }\n\n\t  return {\n\t    beta: beta,\n\t    lambda: lambda,\n\t    basis: basis,\n\t  };\n\t};\n\n\tShortCurve.prototype._getEndoRoots = function _getEndoRoots(num) {\n\t  // Find roots of for x^2 + x + 1 in F\n\t  // Root = (-1 +- Sqrt(-3)) / 2\n\t  //\n\t  var red = num === this.p ? this.red : bn.mont(num);\n\t  var tinv = new bn(2).toRed(red).redInvm();\n\t  var ntinv = tinv.redNeg();\n\n\t  var s = new bn(3).toRed(red).redNeg().redSqrt().redMul(tinv);\n\n\t  var l1 = ntinv.redAdd(s).fromRed();\n\t  var l2 = ntinv.redSub(s).fromRed();\n\t  return [ l1, l2 ];\n\t};\n\n\tShortCurve.prototype._getEndoBasis = function _getEndoBasis(lambda) {\n\t  // aprxSqrt >= sqrt(this.n)\n\t  var aprxSqrt = this.n.ushrn(Math.floor(this.n.bitLength() / 2));\n\n\t  // 3.74\n\t  // Run EGCD, until r(L + 1) < aprxSqrt\n\t  var u = lambda;\n\t  var v = this.n.clone();\n\t  var x1 = new bn(1);\n\t  var y1 = new bn(0);\n\t  var x2 = new bn(0);\n\t  var y2 = new bn(1);\n\n\t  // NOTE: all vectors are roots of: a + b * lambda = 0 (mod n)\n\t  var a0;\n\t  var b0;\n\t  // First vector\n\t  var a1;\n\t  var b1;\n\t  // Second vector\n\t  var a2;\n\t  var b2;\n\n\t  var prevR;\n\t  var i = 0;\n\t  var r;\n\t  var x;\n\t  while (u.cmpn(0) !== 0) {\n\t    var q = v.div(u);\n\t    r = v.sub(q.mul(u));\n\t    x = x2.sub(q.mul(x1));\n\t    var y = y2.sub(q.mul(y1));\n\n\t    if (!a1 && r.cmp(aprxSqrt) < 0) {\n\t      a0 = prevR.neg();\n\t      b0 = x1;\n\t      a1 = r.neg();\n\t      b1 = x;\n\t    } else if (a1 && ++i === 2) {\n\t      break;\n\t    }\n\t    prevR = r;\n\n\t    v = u;\n\t    u = r;\n\t    x2 = x1;\n\t    x1 = x;\n\t    y2 = y1;\n\t    y1 = y;\n\t  }\n\t  a2 = r.neg();\n\t  b2 = x;\n\n\t  var len1 = a1.sqr().add(b1.sqr());\n\t  var len2 = a2.sqr().add(b2.sqr());\n\t  if (len2.cmp(len1) >= 0) {\n\t    a2 = a0;\n\t    b2 = b0;\n\t  }\n\n\t  // Normalize signs\n\t  if (a1.negative) {\n\t    a1 = a1.neg();\n\t    b1 = b1.neg();\n\t  }\n\t  if (a2.negative) {\n\t    a2 = a2.neg();\n\t    b2 = b2.neg();\n\t  }\n\n\t  return [\n\t    { a: a1, b: b1 },\n\t    { a: a2, b: b2 },\n\t  ];\n\t};\n\n\tShortCurve.prototype._endoSplit = function _endoSplit(k) {\n\t  var basis = this.endo.basis;\n\t  var v1 = basis[0];\n\t  var v2 = basis[1];\n\n\t  var c1 = v2.b.mul(k).divRound(this.n);\n\t  var c2 = v1.b.neg().mul(k).divRound(this.n);\n\n\t  var p1 = c1.mul(v1.a);\n\t  var p2 = c2.mul(v2.a);\n\t  var q1 = c1.mul(v1.b);\n\t  var q2 = c2.mul(v2.b);\n\n\t  // Calculate answer\n\t  var k1 = k.sub(p1).sub(p2);\n\t  var k2 = q1.add(q2).neg();\n\t  return { k1: k1, k2: k2 };\n\t};\n\n\tShortCurve.prototype.pointFromX = function pointFromX(x, odd) {\n\t  x = new bn(x, 16);\n\t  if (!x.red)\n\t    x = x.toRed(this.red);\n\n\t  var y2 = x.redSqr().redMul(x).redIAdd(x.redMul(this.a)).redIAdd(this.b);\n\t  var y = y2.redSqrt();\n\t  if (y.redSqr().redSub(y2).cmp(this.zero) !== 0)\n\t    throw new Error('invalid point');\n\n\t  // XXX Is there any way to tell if the number is odd without converting it\n\t  // to non-red form?\n\t  var isOdd = y.fromRed().isOdd();\n\t  if (odd && !isOdd || !odd && isOdd)\n\t    y = y.redNeg();\n\n\t  return this.point(x, y);\n\t};\n\n\tShortCurve.prototype.validate = function validate(point) {\n\t  if (point.inf)\n\t    return true;\n\n\t  var x = point.x;\n\t  var y = point.y;\n\n\t  var ax = this.a.redMul(x);\n\t  var rhs = x.redSqr().redMul(x).redIAdd(ax).redIAdd(this.b);\n\t  return y.redSqr().redISub(rhs).cmpn(0) === 0;\n\t};\n\n\tShortCurve.prototype._endoWnafMulAdd =\n\t    function _endoWnafMulAdd(points, coeffs, jacobianResult) {\n\t      var npoints = this._endoWnafT1;\n\t      var ncoeffs = this._endoWnafT2;\n\t      for (var i = 0; i < points.length; i++) {\n\t        var split = this._endoSplit(coeffs[i]);\n\t        var p = points[i];\n\t        var beta = p._getBeta();\n\n\t        if (split.k1.negative) {\n\t          split.k1.ineg();\n\t          p = p.neg(true);\n\t        }\n\t        if (split.k2.negative) {\n\t          split.k2.ineg();\n\t          beta = beta.neg(true);\n\t        }\n\n\t        npoints[i * 2] = p;\n\t        npoints[i * 2 + 1] = beta;\n\t        ncoeffs[i * 2] = split.k1;\n\t        ncoeffs[i * 2 + 1] = split.k2;\n\t      }\n\t      var res = this._wnafMulAdd(1, npoints, ncoeffs, i * 2, jacobianResult);\n\n\t      // Clean-up references to points and coefficients\n\t      for (var j = 0; j < i * 2; j++) {\n\t        npoints[j] = null;\n\t        ncoeffs[j] = null;\n\t      }\n\t      return res;\n\t    };\n\n\tfunction Point(curve, x, y, isRed) {\n\t  base.BasePoint.call(this, curve, 'affine');\n\t  if (x === null && y === null) {\n\t    this.x = null;\n\t    this.y = null;\n\t    this.inf = true;\n\t  } else {\n\t    this.x = new bn(x, 16);\n\t    this.y = new bn(y, 16);\n\t    // Force redgomery representation when loading from JSON\n\t    if (isRed) {\n\t      this.x.forceRed(this.curve.red);\n\t      this.y.forceRed(this.curve.red);\n\t    }\n\t    if (!this.x.red)\n\t      this.x = this.x.toRed(this.curve.red);\n\t    if (!this.y.red)\n\t      this.y = this.y.toRed(this.curve.red);\n\t    this.inf = false;\n\t  }\n\t}\n\tinherits_browser(Point, base.BasePoint);\n\n\tShortCurve.prototype.point = function point(x, y, isRed) {\n\t  return new Point(this, x, y, isRed);\n\t};\n\n\tShortCurve.prototype.pointFromJSON = function pointFromJSON(obj, red) {\n\t  return Point.fromJSON(this, obj, red);\n\t};\n\n\tPoint.prototype._getBeta = function _getBeta() {\n\t  if (!this.curve.endo)\n\t    return;\n\n\t  var pre = this.precomputed;\n\t  if (pre && pre.beta)\n\t    return pre.beta;\n\n\t  var beta = this.curve.point(this.x.redMul(this.curve.endo.beta), this.y);\n\t  if (pre) {\n\t    var curve = this.curve;\n\t    var endoMul = function(p) {\n\t      return curve.point(p.x.redMul(curve.endo.beta), p.y);\n\t    };\n\t    pre.beta = beta;\n\t    beta.precomputed = {\n\t      beta: null,\n\t      naf: pre.naf && {\n\t        wnd: pre.naf.wnd,\n\t        points: pre.naf.points.map(endoMul),\n\t      },\n\t      doubles: pre.doubles && {\n\t        step: pre.doubles.step,\n\t        points: pre.doubles.points.map(endoMul),\n\t      },\n\t    };\n\t  }\n\t  return beta;\n\t};\n\n\tPoint.prototype.toJSON = function toJSON() {\n\t  if (!this.precomputed)\n\t    return [ this.x, this.y ];\n\n\t  return [ this.x, this.y, this.precomputed && {\n\t    doubles: this.precomputed.doubles && {\n\t      step: this.precomputed.doubles.step,\n\t      points: this.precomputed.doubles.points.slice(1),\n\t    },\n\t    naf: this.precomputed.naf && {\n\t      wnd: this.precomputed.naf.wnd,\n\t      points: this.precomputed.naf.points.slice(1),\n\t    },\n\t  } ];\n\t};\n\n\tPoint.fromJSON = function fromJSON(curve, obj, red) {\n\t  if (typeof obj === 'string')\n\t    obj = JSON.parse(obj);\n\t  var res = curve.point(obj[0], obj[1], red);\n\t  if (!obj[2])\n\t    return res;\n\n\t  function obj2point(obj) {\n\t    return curve.point(obj[0], obj[1], red);\n\t  }\n\n\t  var pre = obj[2];\n\t  res.precomputed = {\n\t    beta: null,\n\t    doubles: pre.doubles && {\n\t      step: pre.doubles.step,\n\t      points: [ res ].concat(pre.doubles.points.map(obj2point)),\n\t    },\n\t    naf: pre.naf && {\n\t      wnd: pre.naf.wnd,\n\t      points: [ res ].concat(pre.naf.points.map(obj2point)),\n\t    },\n\t  };\n\t  return res;\n\t};\n\n\tPoint.prototype.inspect = function inspect() {\n\t  if (this.isInfinity())\n\t    return '<EC Point Infinity>';\n\t  return '<EC Point x: ' + this.x.fromRed().toString(16, 2) +\n\t      ' y: ' + this.y.fromRed().toString(16, 2) + '>';\n\t};\n\n\tPoint.prototype.isInfinity = function isInfinity() {\n\t  return this.inf;\n\t};\n\n\tPoint.prototype.add = function add(p) {\n\t  // O + P = P\n\t  if (this.inf)\n\t    return p;\n\n\t  // P + O = P\n\t  if (p.inf)\n\t    return this;\n\n\t  // P + P = 2P\n\t  if (this.eq(p))\n\t    return this.dbl();\n\n\t  // P + (-P) = O\n\t  if (this.neg().eq(p))\n\t    return this.curve.point(null, null);\n\n\t  // P + Q = O\n\t  if (this.x.cmp(p.x) === 0)\n\t    return this.curve.point(null, null);\n\n\t  var c = this.y.redSub(p.y);\n\t  if (c.cmpn(0) !== 0)\n\t    c = c.redMul(this.x.redSub(p.x).redInvm());\n\t  var nx = c.redSqr().redISub(this.x).redISub(p.x);\n\t  var ny = c.redMul(this.x.redSub(nx)).redISub(this.y);\n\t  return this.curve.point(nx, ny);\n\t};\n\n\tPoint.prototype.dbl = function dbl() {\n\t  if (this.inf)\n\t    return this;\n\n\t  // 2P = O\n\t  var ys1 = this.y.redAdd(this.y);\n\t  if (ys1.cmpn(0) === 0)\n\t    return this.curve.point(null, null);\n\n\t  var a = this.curve.a;\n\n\t  var x2 = this.x.redSqr();\n\t  var dyinv = ys1.redInvm();\n\t  var c = x2.redAdd(x2).redIAdd(x2).redIAdd(a).redMul(dyinv);\n\n\t  var nx = c.redSqr().redISub(this.x.redAdd(this.x));\n\t  var ny = c.redMul(this.x.redSub(nx)).redISub(this.y);\n\t  return this.curve.point(nx, ny);\n\t};\n\n\tPoint.prototype.getX = function getX() {\n\t  return this.x.fromRed();\n\t};\n\n\tPoint.prototype.getY = function getY() {\n\t  return this.y.fromRed();\n\t};\n\n\tPoint.prototype.mul = function mul(k) {\n\t  k = new bn(k, 16);\n\t  if (this.isInfinity())\n\t    return this;\n\t  else if (this._hasDoubles(k))\n\t    return this.curve._fixedNafMul(this, k);\n\t  else if (this.curve.endo)\n\t    return this.curve._endoWnafMulAdd([ this ], [ k ]);\n\t  else\n\t    return this.curve._wnafMul(this, k);\n\t};\n\n\tPoint.prototype.mulAdd = function mulAdd(k1, p2, k2) {\n\t  var points = [ this, p2 ];\n\t  var coeffs = [ k1, k2 ];\n\t  if (this.curve.endo)\n\t    return this.curve._endoWnafMulAdd(points, coeffs);\n\t  else\n\t    return this.curve._wnafMulAdd(1, points, coeffs, 2);\n\t};\n\n\tPoint.prototype.jmulAdd = function jmulAdd(k1, p2, k2) {\n\t  var points = [ this, p2 ];\n\t  var coeffs = [ k1, k2 ];\n\t  if (this.curve.endo)\n\t    return this.curve._endoWnafMulAdd(points, coeffs, true);\n\t  else\n\t    return this.curve._wnafMulAdd(1, points, coeffs, 2, true);\n\t};\n\n\tPoint.prototype.eq = function eq(p) {\n\t  return this === p ||\n\t         this.inf === p.inf &&\n\t             (this.inf || this.x.cmp(p.x) === 0 && this.y.cmp(p.y) === 0);\n\t};\n\n\tPoint.prototype.neg = function neg(_precompute) {\n\t  if (this.inf)\n\t    return this;\n\n\t  var res = this.curve.point(this.x, this.y.redNeg());\n\t  if (_precompute && this.precomputed) {\n\t    var pre = this.precomputed;\n\t    var negate = function(p) {\n\t      return p.neg();\n\t    };\n\t    res.precomputed = {\n\t      naf: pre.naf && {\n\t        wnd: pre.naf.wnd,\n\t        points: pre.naf.points.map(negate),\n\t      },\n\t      doubles: pre.doubles && {\n\t        step: pre.doubles.step,\n\t        points: pre.doubles.points.map(negate),\n\t      },\n\t    };\n\t  }\n\t  return res;\n\t};\n\n\tPoint.prototype.toJ = function toJ() {\n\t  if (this.inf)\n\t    return this.curve.jpoint(null, null, null);\n\n\t  var res = this.curve.jpoint(this.x, this.y, this.curve.one);\n\t  return res;\n\t};\n\n\tfunction JPoint(curve, x, y, z) {\n\t  base.BasePoint.call(this, curve, 'jacobian');\n\t  if (x === null && y === null && z === null) {\n\t    this.x = this.curve.one;\n\t    this.y = this.curve.one;\n\t    this.z = new bn(0);\n\t  } else {\n\t    this.x = new bn(x, 16);\n\t    this.y = new bn(y, 16);\n\t    this.z = new bn(z, 16);\n\t  }\n\t  if (!this.x.red)\n\t    this.x = this.x.toRed(this.curve.red);\n\t  if (!this.y.red)\n\t    this.y = this.y.toRed(this.curve.red);\n\t  if (!this.z.red)\n\t    this.z = this.z.toRed(this.curve.red);\n\n\t  this.zOne = this.z === this.curve.one;\n\t}\n\tinherits_browser(JPoint, base.BasePoint);\n\n\tShortCurve.prototype.jpoint = function jpoint(x, y, z) {\n\t  return new JPoint(this, x, y, z);\n\t};\n\n\tJPoint.prototype.toP = function toP() {\n\t  if (this.isInfinity())\n\t    return this.curve.point(null, null);\n\n\t  var zinv = this.z.redInvm();\n\t  var zinv2 = zinv.redSqr();\n\t  var ax = this.x.redMul(zinv2);\n\t  var ay = this.y.redMul(zinv2).redMul(zinv);\n\n\t  return this.curve.point(ax, ay);\n\t};\n\n\tJPoint.prototype.neg = function neg() {\n\t  return this.curve.jpoint(this.x, this.y.redNeg(), this.z);\n\t};\n\n\tJPoint.prototype.add = function add(p) {\n\t  // O + P = P\n\t  if (this.isInfinity())\n\t    return p;\n\n\t  // P + O = P\n\t  if (p.isInfinity())\n\t    return this;\n\n\t  // 12M + 4S + 7A\n\t  var pz2 = p.z.redSqr();\n\t  var z2 = this.z.redSqr();\n\t  var u1 = this.x.redMul(pz2);\n\t  var u2 = p.x.redMul(z2);\n\t  var s1 = this.y.redMul(pz2.redMul(p.z));\n\t  var s2 = p.y.redMul(z2.redMul(this.z));\n\n\t  var h = u1.redSub(u2);\n\t  var r = s1.redSub(s2);\n\t  if (h.cmpn(0) === 0) {\n\t    if (r.cmpn(0) !== 0)\n\t      return this.curve.jpoint(null, null, null);\n\t    else\n\t      return this.dbl();\n\t  }\n\n\t  var h2 = h.redSqr();\n\t  var h3 = h2.redMul(h);\n\t  var v = u1.redMul(h2);\n\n\t  var nx = r.redSqr().redIAdd(h3).redISub(v).redISub(v);\n\t  var ny = r.redMul(v.redISub(nx)).redISub(s1.redMul(h3));\n\t  var nz = this.z.redMul(p.z).redMul(h);\n\n\t  return this.curve.jpoint(nx, ny, nz);\n\t};\n\n\tJPoint.prototype.mixedAdd = function mixedAdd(p) {\n\t  // O + P = P\n\t  if (this.isInfinity())\n\t    return p.toJ();\n\n\t  // P + O = P\n\t  if (p.isInfinity())\n\t    return this;\n\n\t  // 8M + 3S + 7A\n\t  var z2 = this.z.redSqr();\n\t  var u1 = this.x;\n\t  var u2 = p.x.redMul(z2);\n\t  var s1 = this.y;\n\t  var s2 = p.y.redMul(z2).redMul(this.z);\n\n\t  var h = u1.redSub(u2);\n\t  var r = s1.redSub(s2);\n\t  if (h.cmpn(0) === 0) {\n\t    if (r.cmpn(0) !== 0)\n\t      return this.curve.jpoint(null, null, null);\n\t    else\n\t      return this.dbl();\n\t  }\n\n\t  var h2 = h.redSqr();\n\t  var h3 = h2.redMul(h);\n\t  var v = u1.redMul(h2);\n\n\t  var nx = r.redSqr().redIAdd(h3).redISub(v).redISub(v);\n\t  var ny = r.redMul(v.redISub(nx)).redISub(s1.redMul(h3));\n\t  var nz = this.z.redMul(h);\n\n\t  return this.curve.jpoint(nx, ny, nz);\n\t};\n\n\tJPoint.prototype.dblp = function dblp(pow) {\n\t  if (pow === 0)\n\t    return this;\n\t  if (this.isInfinity())\n\t    return this;\n\t  if (!pow)\n\t    return this.dbl();\n\n\t  var i;\n\t  if (this.curve.zeroA || this.curve.threeA) {\n\t    var r = this;\n\t    for (i = 0; i < pow; i++)\n\t      r = r.dbl();\n\t    return r;\n\t  }\n\n\t  // 1M + 2S + 1A + N * (4S + 5M + 8A)\n\t  // N = 1 => 6M + 6S + 9A\n\t  var a = this.curve.a;\n\t  var tinv = this.curve.tinv;\n\n\t  var jx = this.x;\n\t  var jy = this.y;\n\t  var jz = this.z;\n\t  var jz4 = jz.redSqr().redSqr();\n\n\t  // Reuse results\n\t  var jyd = jy.redAdd(jy);\n\t  for (i = 0; i < pow; i++) {\n\t    var jx2 = jx.redSqr();\n\t    var jyd2 = jyd.redSqr();\n\t    var jyd4 = jyd2.redSqr();\n\t    var c = jx2.redAdd(jx2).redIAdd(jx2).redIAdd(a.redMul(jz4));\n\n\t    var t1 = jx.redMul(jyd2);\n\t    var nx = c.redSqr().redISub(t1.redAdd(t1));\n\t    var t2 = t1.redISub(nx);\n\t    var dny = c.redMul(t2);\n\t    dny = dny.redIAdd(dny).redISub(jyd4);\n\t    var nz = jyd.redMul(jz);\n\t    if (i + 1 < pow)\n\t      jz4 = jz4.redMul(jyd4);\n\n\t    jx = nx;\n\t    jz = nz;\n\t    jyd = dny;\n\t  }\n\n\t  return this.curve.jpoint(jx, jyd.redMul(tinv), jz);\n\t};\n\n\tJPoint.prototype.dbl = function dbl() {\n\t  if (this.isInfinity())\n\t    return this;\n\n\t  if (this.curve.zeroA)\n\t    return this._zeroDbl();\n\t  else if (this.curve.threeA)\n\t    return this._threeDbl();\n\t  else\n\t    return this._dbl();\n\t};\n\n\tJPoint.prototype._zeroDbl = function _zeroDbl() {\n\t  var nx;\n\t  var ny;\n\t  var nz;\n\t  // Z = 1\n\t  if (this.zOne) {\n\t    // hyperelliptic.org/EFD/g1p/auto-shortw-jacobian-0.html\n\t    //     #doubling-mdbl-2007-bl\n\t    // 1M + 5S + 14A\n\n\t    // XX = X1^2\n\t    var xx = this.x.redSqr();\n\t    // YY = Y1^2\n\t    var yy = this.y.redSqr();\n\t    // YYYY = YY^2\n\t    var yyyy = yy.redSqr();\n\t    // S = 2 * ((X1 + YY)^2 - XX - YYYY)\n\t    var s = this.x.redAdd(yy).redSqr().redISub(xx).redISub(yyyy);\n\t    s = s.redIAdd(s);\n\t    // M = 3 * XX + a; a = 0\n\t    var m = xx.redAdd(xx).redIAdd(xx);\n\t    // T = M ^ 2 - 2*S\n\t    var t = m.redSqr().redISub(s).redISub(s);\n\n\t    // 8 * YYYY\n\t    var yyyy8 = yyyy.redIAdd(yyyy);\n\t    yyyy8 = yyyy8.redIAdd(yyyy8);\n\t    yyyy8 = yyyy8.redIAdd(yyyy8);\n\n\t    // X3 = T\n\t    nx = t;\n\t    // Y3 = M * (S - T) - 8 * YYYY\n\t    ny = m.redMul(s.redISub(t)).redISub(yyyy8);\n\t    // Z3 = 2*Y1\n\t    nz = this.y.redAdd(this.y);\n\t  } else {\n\t    // hyperelliptic.org/EFD/g1p/auto-shortw-jacobian-0.html\n\t    //     #doubling-dbl-2009-l\n\t    // 2M + 5S + 13A\n\n\t    // A = X1^2\n\t    var a = this.x.redSqr();\n\t    // B = Y1^2\n\t    var b = this.y.redSqr();\n\t    // C = B^2\n\t    var c = b.redSqr();\n\t    // D = 2 * ((X1 + B)^2 - A - C)\n\t    var d = this.x.redAdd(b).redSqr().redISub(a).redISub(c);\n\t    d = d.redIAdd(d);\n\t    // E = 3 * A\n\t    var e = a.redAdd(a).redIAdd(a);\n\t    // F = E^2\n\t    var f = e.redSqr();\n\n\t    // 8 * C\n\t    var c8 = c.redIAdd(c);\n\t    c8 = c8.redIAdd(c8);\n\t    c8 = c8.redIAdd(c8);\n\n\t    // X3 = F - 2 * D\n\t    nx = f.redISub(d).redISub(d);\n\t    // Y3 = E * (D - X3) - 8 * C\n\t    ny = e.redMul(d.redISub(nx)).redISub(c8);\n\t    // Z3 = 2 * Y1 * Z1\n\t    nz = this.y.redMul(this.z);\n\t    nz = nz.redIAdd(nz);\n\t  }\n\n\t  return this.curve.jpoint(nx, ny, nz);\n\t};\n\n\tJPoint.prototype._threeDbl = function _threeDbl() {\n\t  var nx;\n\t  var ny;\n\t  var nz;\n\t  // Z = 1\n\t  if (this.zOne) {\n\t    // hyperelliptic.org/EFD/g1p/auto-shortw-jacobian-3.html\n\t    //     #doubling-mdbl-2007-bl\n\t    // 1M + 5S + 15A\n\n\t    // XX = X1^2\n\t    var xx = this.x.redSqr();\n\t    // YY = Y1^2\n\t    var yy = this.y.redSqr();\n\t    // YYYY = YY^2\n\t    var yyyy = yy.redSqr();\n\t    // S = 2 * ((X1 + YY)^2 - XX - YYYY)\n\t    var s = this.x.redAdd(yy).redSqr().redISub(xx).redISub(yyyy);\n\t    s = s.redIAdd(s);\n\t    // M = 3 * XX + a\n\t    var m = xx.redAdd(xx).redIAdd(xx).redIAdd(this.curve.a);\n\t    // T = M^2 - 2 * S\n\t    var t = m.redSqr().redISub(s).redISub(s);\n\t    // X3 = T\n\t    nx = t;\n\t    // Y3 = M * (S - T) - 8 * YYYY\n\t    var yyyy8 = yyyy.redIAdd(yyyy);\n\t    yyyy8 = yyyy8.redIAdd(yyyy8);\n\t    yyyy8 = yyyy8.redIAdd(yyyy8);\n\t    ny = m.redMul(s.redISub(t)).redISub(yyyy8);\n\t    // Z3 = 2 * Y1\n\t    nz = this.y.redAdd(this.y);\n\t  } else {\n\t    // hyperelliptic.org/EFD/g1p/auto-shortw-jacobian-3.html#doubling-dbl-2001-b\n\t    // 3M + 5S\n\n\t    // delta = Z1^2\n\t    var delta = this.z.redSqr();\n\t    // gamma = Y1^2\n\t    var gamma = this.y.redSqr();\n\t    // beta = X1 * gamma\n\t    var beta = this.x.redMul(gamma);\n\t    // alpha = 3 * (X1 - delta) * (X1 + delta)\n\t    var alpha = this.x.redSub(delta).redMul(this.x.redAdd(delta));\n\t    alpha = alpha.redAdd(alpha).redIAdd(alpha);\n\t    // X3 = alpha^2 - 8 * beta\n\t    var beta4 = beta.redIAdd(beta);\n\t    beta4 = beta4.redIAdd(beta4);\n\t    var beta8 = beta4.redAdd(beta4);\n\t    nx = alpha.redSqr().redISub(beta8);\n\t    // Z3 = (Y1 + Z1)^2 - gamma - delta\n\t    nz = this.y.redAdd(this.z).redSqr().redISub(gamma).redISub(delta);\n\t    // Y3 = alpha * (4 * beta - X3) - 8 * gamma^2\n\t    var ggamma8 = gamma.redSqr();\n\t    ggamma8 = ggamma8.redIAdd(ggamma8);\n\t    ggamma8 = ggamma8.redIAdd(ggamma8);\n\t    ggamma8 = ggamma8.redIAdd(ggamma8);\n\t    ny = alpha.redMul(beta4.redISub(nx)).redISub(ggamma8);\n\t  }\n\n\t  return this.curve.jpoint(nx, ny, nz);\n\t};\n\n\tJPoint.prototype._dbl = function _dbl() {\n\t  var a = this.curve.a;\n\n\t  // 4M + 6S + 10A\n\t  var jx = this.x;\n\t  var jy = this.y;\n\t  var jz = this.z;\n\t  var jz4 = jz.redSqr().redSqr();\n\n\t  var jx2 = jx.redSqr();\n\t  var jy2 = jy.redSqr();\n\n\t  var c = jx2.redAdd(jx2).redIAdd(jx2).redIAdd(a.redMul(jz4));\n\n\t  var jxd4 = jx.redAdd(jx);\n\t  jxd4 = jxd4.redIAdd(jxd4);\n\t  var t1 = jxd4.redMul(jy2);\n\t  var nx = c.redSqr().redISub(t1.redAdd(t1));\n\t  var t2 = t1.redISub(nx);\n\n\t  var jyd8 = jy2.redSqr();\n\t  jyd8 = jyd8.redIAdd(jyd8);\n\t  jyd8 = jyd8.redIAdd(jyd8);\n\t  jyd8 = jyd8.redIAdd(jyd8);\n\t  var ny = c.redMul(t2).redISub(jyd8);\n\t  var nz = jy.redAdd(jy).redMul(jz);\n\n\t  return this.curve.jpoint(nx, ny, nz);\n\t};\n\n\tJPoint.prototype.trpl = function trpl() {\n\t  if (!this.curve.zeroA)\n\t    return this.dbl().add(this);\n\n\t  // hyperelliptic.org/EFD/g1p/auto-shortw-jacobian-0.html#tripling-tpl-2007-bl\n\t  // 5M + 10S + ...\n\n\t  // XX = X1^2\n\t  var xx = this.x.redSqr();\n\t  // YY = Y1^2\n\t  var yy = this.y.redSqr();\n\t  // ZZ = Z1^2\n\t  var zz = this.z.redSqr();\n\t  // YYYY = YY^2\n\t  var yyyy = yy.redSqr();\n\t  // M = 3 * XX + a * ZZ2; a = 0\n\t  var m = xx.redAdd(xx).redIAdd(xx);\n\t  // MM = M^2\n\t  var mm = m.redSqr();\n\t  // E = 6 * ((X1 + YY)^2 - XX - YYYY) - MM\n\t  var e = this.x.redAdd(yy).redSqr().redISub(xx).redISub(yyyy);\n\t  e = e.redIAdd(e);\n\t  e = e.redAdd(e).redIAdd(e);\n\t  e = e.redISub(mm);\n\t  // EE = E^2\n\t  var ee = e.redSqr();\n\t  // T = 16*YYYY\n\t  var t = yyyy.redIAdd(yyyy);\n\t  t = t.redIAdd(t);\n\t  t = t.redIAdd(t);\n\t  t = t.redIAdd(t);\n\t  // U = (M + E)^2 - MM - EE - T\n\t  var u = m.redIAdd(e).redSqr().redISub(mm).redISub(ee).redISub(t);\n\t  // X3 = 4 * (X1 * EE - 4 * YY * U)\n\t  var yyu4 = yy.redMul(u);\n\t  yyu4 = yyu4.redIAdd(yyu4);\n\t  yyu4 = yyu4.redIAdd(yyu4);\n\t  var nx = this.x.redMul(ee).redISub(yyu4);\n\t  nx = nx.redIAdd(nx);\n\t  nx = nx.redIAdd(nx);\n\t  // Y3 = 8 * Y1 * (U * (T - U) - E * EE)\n\t  var ny = this.y.redMul(u.redMul(t.redISub(u)).redISub(e.redMul(ee)));\n\t  ny = ny.redIAdd(ny);\n\t  ny = ny.redIAdd(ny);\n\t  ny = ny.redIAdd(ny);\n\t  // Z3 = (Z1 + E)^2 - ZZ - EE\n\t  var nz = this.z.redAdd(e).redSqr().redISub(zz).redISub(ee);\n\n\t  return this.curve.jpoint(nx, ny, nz);\n\t};\n\n\tJPoint.prototype.mul = function mul(k, kbase) {\n\t  k = new bn(k, kbase);\n\n\t  return this.curve._wnafMul(this, k);\n\t};\n\n\tJPoint.prototype.eq = function eq(p) {\n\t  if (p.type === 'affine')\n\t    return this.eq(p.toJ());\n\n\t  if (this === p)\n\t    return true;\n\n\t  // x1 * z2^2 == x2 * z1^2\n\t  var z2 = this.z.redSqr();\n\t  var pz2 = p.z.redSqr();\n\t  if (this.x.redMul(pz2).redISub(p.x.redMul(z2)).cmpn(0) !== 0)\n\t    return false;\n\n\t  // y1 * z2^3 == y2 * z1^3\n\t  var z3 = z2.redMul(this.z);\n\t  var pz3 = pz2.redMul(p.z);\n\t  return this.y.redMul(pz3).redISub(p.y.redMul(z3)).cmpn(0) === 0;\n\t};\n\n\tJPoint.prototype.eqXToP = function eqXToP(x) {\n\t  var zs = this.z.redSqr();\n\t  var rx = x.toRed(this.curve.red).redMul(zs);\n\t  if (this.x.cmp(rx) === 0)\n\t    return true;\n\n\t  var xc = x.clone();\n\t  var t = this.curve.redN.redMul(zs);\n\t  for (;;) {\n\t    xc.iadd(this.curve.n);\n\t    if (xc.cmp(this.curve.p) >= 0)\n\t      return false;\n\n\t    rx.redIAdd(t);\n\t    if (this.x.cmp(rx) === 0)\n\t      return true;\n\t  }\n\t};\n\n\tJPoint.prototype.inspect = function inspect() {\n\t  if (this.isInfinity())\n\t    return '<EC JPoint Infinity>';\n\t  return '<EC JPoint x: ' + this.x.toString(16, 2) +\n\t      ' y: ' + this.y.toString(16, 2) +\n\t      ' z: ' + this.z.toString(16, 2) + '>';\n\t};\n\n\tJPoint.prototype.isInfinity = function isInfinity() {\n\t  // XXX This code assumes that zero is always zero in red\n\t  return this.z.cmpn(0) === 0;\n\t};\n\n\tvar curve_1 = createCommonjsModule(function (module, exports) {\n\t'use strict';\n\n\tvar curve = exports;\n\n\tcurve.base = base;\n\tcurve.short = short_1;\n\tcurve.mont = /*RicMoo:ethers:require(./mont)*/(null);\n\tcurve.edwards = /*RicMoo:ethers:require(./edwards)*/(null);\n\t});\n\n\t'use strict';\n\n\n\n\n\tvar inherits_1 = inherits_browser;\n\n\tfunction isSurrogatePair(msg, i) {\n\t  if ((msg.charCodeAt(i) & 0xFC00) !== 0xD800) {\n\t    return false;\n\t  }\n\t  if (i < 0 || i + 1 >= msg.length) {\n\t    return false;\n\t  }\n\t  return (msg.charCodeAt(i + 1) & 0xFC00) === 0xDC00;\n\t}\n\n\tfunction toArray(msg, enc) {\n\t  if (Array.isArray(msg))\n\t    return msg.slice();\n\t  if (!msg)\n\t    return [];\n\t  var res = [];\n\t  if (typeof msg === 'string') {\n\t    if (!enc) {\n\t      // Inspired by stringToUtf8ByteArray() in closure-library by Google\n\t      // https://github.com/google/closure-library/blob/8598d87242af59aac233270742c8984e2b2bdbe0/closure/goog/crypt/crypt.js#L117-L143\n\t      // Apache License 2.0\n\t      // https://github.com/google/closure-library/blob/master/LICENSE\n\t      var p = 0;\n\t      for (var i = 0; i < msg.length; i++) {\n\t        var c = msg.charCodeAt(i);\n\t        if (c < 128) {\n\t          res[p++] = c;\n\t        } else if (c < 2048) {\n\t          res[p++] = (c >> 6) | 192;\n\t          res[p++] = (c & 63) | 128;\n\t        } else if (isSurrogatePair(msg, i)) {\n\t          c = 0x10000 + ((c & 0x03FF) << 10) + (msg.charCodeAt(++i) & 0x03FF);\n\t          res[p++] = (c >> 18) | 240;\n\t          res[p++] = ((c >> 12) & 63) | 128;\n\t          res[p++] = ((c >> 6) & 63) | 128;\n\t          res[p++] = (c & 63) | 128;\n\t        } else {\n\t          res[p++] = (c >> 12) | 224;\n\t          res[p++] = ((c >> 6) & 63) | 128;\n\t          res[p++] = (c & 63) | 128;\n\t        }\n\t      }\n\t    } else if (enc === 'hex') {\n\t      msg = msg.replace(/[^a-z0-9]+/ig, '');\n\t      if (msg.length % 2 !== 0)\n\t        msg = '0' + msg;\n\t      for (i = 0; i < msg.length; i += 2)\n\t        res.push(parseInt(msg[i] + msg[i + 1], 16));\n\t    }\n\t  } else {\n\t    for (i = 0; i < msg.length; i++)\n\t      res[i] = msg[i] | 0;\n\t  }\n\t  return res;\n\t}\n\tvar toArray_1 = toArray;\n\n\tfunction toHex(msg) {\n\t  var res = '';\n\t  for (var i = 0; i < msg.length; i++)\n\t    res += zero2(msg[i].toString(16));\n\t  return res;\n\t}\n\tvar toHex_1 = toHex;\n\n\tfunction htonl(w) {\n\t  var res = (w >>> 24) |\n\t            ((w >>> 8) & 0xff00) |\n\t            ((w << 8) & 0xff0000) |\n\t            ((w & 0xff) << 24);\n\t  return res >>> 0;\n\t}\n\tvar htonl_1 = htonl;\n\n\tfunction toHex32(msg, endian) {\n\t  var res = '';\n\t  for (var i = 0; i < msg.length; i++) {\n\t    var w = msg[i];\n\t    if (endian === 'little')\n\t      w = htonl(w);\n\t    res += zero8(w.toString(16));\n\t  }\n\t  return res;\n\t}\n\tvar toHex32_1 = toHex32;\n\n\tfunction zero2(word) {\n\t  if (word.length === 1)\n\t    return '0' + word;\n\t  else\n\t    return word;\n\t}\n\tvar zero2_1 = zero2;\n\n\tfunction zero8(word) {\n\t  if (word.length === 7)\n\t    return '0' + word;\n\t  else if (word.length === 6)\n\t    return '00' + word;\n\t  else if (word.length === 5)\n\t    return '000' + word;\n\t  else if (word.length === 4)\n\t    return '0000' + word;\n\t  else if (word.length === 3)\n\t    return '00000' + word;\n\t  else if (word.length === 2)\n\t    return '000000' + word;\n\t  else if (word.length === 1)\n\t    return '0000000' + word;\n\t  else\n\t    return word;\n\t}\n\tvar zero8_1 = zero8;\n\n\tfunction join32(msg, start, end, endian) {\n\t  var len = end - start;\n\t  minimalisticAssert(len % 4 === 0);\n\t  var res = new Array(len / 4);\n\t  for (var i = 0, k = start; i < res.length; i++, k += 4) {\n\t    var w;\n\t    if (endian === 'big')\n\t      w = (msg[k] << 24) | (msg[k + 1] << 16) | (msg[k + 2] << 8) | msg[k + 3];\n\t    else\n\t      w = (msg[k + 3] << 24) | (msg[k + 2] << 16) | (msg[k + 1] << 8) | msg[k];\n\t    res[i] = w >>> 0;\n\t  }\n\t  return res;\n\t}\n\tvar join32_1 = join32;\n\n\tfunction split32(msg, endian) {\n\t  var res = new Array(msg.length * 4);\n\t  for (var i = 0, k = 0; i < msg.length; i++, k += 4) {\n\t    var m = msg[i];\n\t    if (endian === 'big') {\n\t      res[k] = m >>> 24;\n\t      res[k + 1] = (m >>> 16) & 0xff;\n\t      res[k + 2] = (m >>> 8) & 0xff;\n\t      res[k + 3] = m & 0xff;\n\t    } else {\n\t      res[k + 3] = m >>> 24;\n\t      res[k + 2] = (m >>> 16) & 0xff;\n\t      res[k + 1] = (m >>> 8) & 0xff;\n\t      res[k] = m & 0xff;\n\t    }\n\t  }\n\t  return res;\n\t}\n\tvar split32_1 = split32;\n\n\tfunction rotr32(w, b) {\n\t  return (w >>> b) | (w << (32 - b));\n\t}\n\tvar rotr32_1 = rotr32;\n\n\tfunction rotl32(w, b) {\n\t  return (w << b) | (w >>> (32 - b));\n\t}\n\tvar rotl32_1 = rotl32;\n\n\tfunction sum32(a, b) {\n\t  return (a + b) >>> 0;\n\t}\n\tvar sum32_1 = sum32;\n\n\tfunction sum32_3(a, b, c) {\n\t  return (a + b + c) >>> 0;\n\t}\n\tvar sum32_3_1 = sum32_3;\n\n\tfunction sum32_4(a, b, c, d) {\n\t  return (a + b + c + d) >>> 0;\n\t}\n\tvar sum32_4_1 = sum32_4;\n\n\tfunction sum32_5(a, b, c, d, e) {\n\t  return (a + b + c + d + e) >>> 0;\n\t}\n\tvar sum32_5_1 = sum32_5;\n\n\tfunction sum64(buf, pos, ah, al) {\n\t  var bh = buf[pos];\n\t  var bl = buf[pos + 1];\n\n\t  var lo = (al + bl) >>> 0;\n\t  var hi = (lo < al ? 1 : 0) + ah + bh;\n\t  buf[pos] = hi >>> 0;\n\t  buf[pos + 1] = lo;\n\t}\n\tvar sum64_1 = sum64;\n\n\tfunction sum64_hi(ah, al, bh, bl) {\n\t  var lo = (al + bl) >>> 0;\n\t  var hi = (lo < al ? 1 : 0) + ah + bh;\n\t  return hi >>> 0;\n\t}\n\tvar sum64_hi_1 = sum64_hi;\n\n\tfunction sum64_lo(ah, al, bh, bl) {\n\t  var lo = al + bl;\n\t  return lo >>> 0;\n\t}\n\tvar sum64_lo_1 = sum64_lo;\n\n\tfunction sum64_4_hi(ah, al, bh, bl, ch, cl, dh, dl) {\n\t  var carry = 0;\n\t  var lo = al;\n\t  lo = (lo + bl) >>> 0;\n\t  carry += lo < al ? 1 : 0;\n\t  lo = (lo + cl) >>> 0;\n\t  carry += lo < cl ? 1 : 0;\n\t  lo = (lo + dl) >>> 0;\n\t  carry += lo < dl ? 1 : 0;\n\n\t  var hi = ah + bh + ch + dh + carry;\n\t  return hi >>> 0;\n\t}\n\tvar sum64_4_hi_1 = sum64_4_hi;\n\n\tfunction sum64_4_lo(ah, al, bh, bl, ch, cl, dh, dl) {\n\t  var lo = al + bl + cl + dl;\n\t  return lo >>> 0;\n\t}\n\tvar sum64_4_lo_1 = sum64_4_lo;\n\n\tfunction sum64_5_hi(ah, al, bh, bl, ch, cl, dh, dl, eh, el) {\n\t  var carry = 0;\n\t  var lo = al;\n\t  lo = (lo + bl) >>> 0;\n\t  carry += lo < al ? 1 : 0;\n\t  lo = (lo + cl) >>> 0;\n\t  carry += lo < cl ? 1 : 0;\n\t  lo = (lo + dl) >>> 0;\n\t  carry += lo < dl ? 1 : 0;\n\t  lo = (lo + el) >>> 0;\n\t  carry += lo < el ? 1 : 0;\n\n\t  var hi = ah + bh + ch + dh + eh + carry;\n\t  return hi >>> 0;\n\t}\n\tvar sum64_5_hi_1 = sum64_5_hi;\n\n\tfunction sum64_5_lo(ah, al, bh, bl, ch, cl, dh, dl, eh, el) {\n\t  var lo = al + bl + cl + dl + el;\n\n\t  return lo >>> 0;\n\t}\n\tvar sum64_5_lo_1 = sum64_5_lo;\n\n\tfunction rotr64_hi(ah, al, num) {\n\t  var r = (al << (32 - num)) | (ah >>> num);\n\t  return r >>> 0;\n\t}\n\tvar rotr64_hi_1 = rotr64_hi;\n\n\tfunction rotr64_lo(ah, al, num) {\n\t  var r = (ah << (32 - num)) | (al >>> num);\n\t  return r >>> 0;\n\t}\n\tvar rotr64_lo_1 = rotr64_lo;\n\n\tfunction shr64_hi(ah, al, num) {\n\t  return ah >>> num;\n\t}\n\tvar shr64_hi_1 = shr64_hi;\n\n\tfunction shr64_lo(ah, al, num) {\n\t  var r = (ah << (32 - num)) | (al >>> num);\n\t  return r >>> 0;\n\t}\n\tvar shr64_lo_1 = shr64_lo;\n\n\tvar utils = {\n\t\tinherits: inherits_1,\n\t\ttoArray: toArray_1,\n\t\ttoHex: toHex_1,\n\t\thtonl: htonl_1,\n\t\ttoHex32: toHex32_1,\n\t\tzero2: zero2_1,\n\t\tzero8: zero8_1,\n\t\tjoin32: join32_1,\n\t\tsplit32: split32_1,\n\t\trotr32: rotr32_1,\n\t\trotl32: rotl32_1,\n\t\tsum32: sum32_1,\n\t\tsum32_3: sum32_3_1,\n\t\tsum32_4: sum32_4_1,\n\t\tsum32_5: sum32_5_1,\n\t\tsum64: sum64_1,\n\t\tsum64_hi: sum64_hi_1,\n\t\tsum64_lo: sum64_lo_1,\n\t\tsum64_4_hi: sum64_4_hi_1,\n\t\tsum64_4_lo: sum64_4_lo_1,\n\t\tsum64_5_hi: sum64_5_hi_1,\n\t\tsum64_5_lo: sum64_5_lo_1,\n\t\trotr64_hi: rotr64_hi_1,\n\t\trotr64_lo: rotr64_lo_1,\n\t\tshr64_hi: shr64_hi_1,\n\t\tshr64_lo: shr64_lo_1\n\t};\n\n\t'use strict';\n\n\n\n\n\tfunction BlockHash() {\n\t  this.pending = null;\n\t  this.pendingTotal = 0;\n\t  this.blockSize = this.constructor.blockSize;\n\t  this.outSize = this.constructor.outSize;\n\t  this.hmacStrength = this.constructor.hmacStrength;\n\t  this.padLength = this.constructor.padLength / 8;\n\t  this.endian = 'big';\n\n\t  this._delta8 = this.blockSize / 8;\n\t  this._delta32 = this.blockSize / 32;\n\t}\n\tvar BlockHash_1 = BlockHash;\n\n\tBlockHash.prototype.update = function update(msg, enc) {\n\t  // Convert message to array, pad it, and join into 32bit blocks\n\t  msg = utils.toArray(msg, enc);\n\t  if (!this.pending)\n\t    this.pending = msg;\n\t  else\n\t    this.pending = this.pending.concat(msg);\n\t  this.pendingTotal += msg.length;\n\n\t  // Enough data, try updating\n\t  if (this.pending.length >= this._delta8) {\n\t    msg = this.pending;\n\n\t    // Process pending data in blocks\n\t    var r = msg.length % this._delta8;\n\t    this.pending = msg.slice(msg.length - r, msg.length);\n\t    if (this.pending.length === 0)\n\t      this.pending = null;\n\n\t    msg = utils.join32(msg, 0, msg.length - r, this.endian);\n\t    for (var i = 0; i < msg.length; i += this._delta32)\n\t      this._update(msg, i, i + this._delta32);\n\t  }\n\n\t  return this;\n\t};\n\n\tBlockHash.prototype.digest = function digest(enc) {\n\t  this.update(this._pad());\n\t  minimalisticAssert(this.pending === null);\n\n\t  return this._digest(enc);\n\t};\n\n\tBlockHash.prototype._pad = function pad() {\n\t  var len = this.pendingTotal;\n\t  var bytes = this._delta8;\n\t  var k = bytes - ((len + this.padLength) % bytes);\n\t  var res = new Array(k + this.padLength);\n\t  res[0] = 0x80;\n\t  for (var i = 1; i < k; i++)\n\t    res[i] = 0;\n\n\t  // Append length\n\t  len <<= 3;\n\t  if (this.endian === 'big') {\n\t    for (var t = 8; t < this.padLength; t++)\n\t      res[i++] = 0;\n\n\t    res[i++] = 0;\n\t    res[i++] = 0;\n\t    res[i++] = 0;\n\t    res[i++] = 0;\n\t    res[i++] = (len >>> 24) & 0xff;\n\t    res[i++] = (len >>> 16) & 0xff;\n\t    res[i++] = (len >>> 8) & 0xff;\n\t    res[i++] = len & 0xff;\n\t  } else {\n\t    res[i++] = len & 0xff;\n\t    res[i++] = (len >>> 8) & 0xff;\n\t    res[i++] = (len >>> 16) & 0xff;\n\t    res[i++] = (len >>> 24) & 0xff;\n\t    res[i++] = 0;\n\t    res[i++] = 0;\n\t    res[i++] = 0;\n\t    res[i++] = 0;\n\n\t    for (t = 8; t < this.padLength; t++)\n\t      res[i++] = 0;\n\t  }\n\n\t  return res;\n\t};\n\n\tvar common = {\n\t\tBlockHash: BlockHash_1\n\t};\n\n\t'use strict';\n\n\n\tvar rotr32$1 = utils.rotr32;\n\n\tfunction ft_1(s, x, y, z) {\n\t  if (s === 0)\n\t    return ch32(x, y, z);\n\t  if (s === 1 || s === 3)\n\t    return p32(x, y, z);\n\t  if (s === 2)\n\t    return maj32(x, y, z);\n\t}\n\tvar ft_1_1 = ft_1;\n\n\tfunction ch32(x, y, z) {\n\t  return (x & y) ^ ((~x) & z);\n\t}\n\tvar ch32_1 = ch32;\n\n\tfunction maj32(x, y, z) {\n\t  return (x & y) ^ (x & z) ^ (y & z);\n\t}\n\tvar maj32_1 = maj32;\n\n\tfunction p32(x, y, z) {\n\t  return x ^ y ^ z;\n\t}\n\tvar p32_1 = p32;\n\n\tfunction s0_256(x) {\n\t  return rotr32$1(x, 2) ^ rotr32$1(x, 13) ^ rotr32$1(x, 22);\n\t}\n\tvar s0_256_1 = s0_256;\n\n\tfunction s1_256(x) {\n\t  return rotr32$1(x, 6) ^ rotr32$1(x, 11) ^ rotr32$1(x, 25);\n\t}\n\tvar s1_256_1 = s1_256;\n\n\tfunction g0_256(x) {\n\t  return rotr32$1(x, 7) ^ rotr32$1(x, 18) ^ (x >>> 3);\n\t}\n\tvar g0_256_1 = g0_256;\n\n\tfunction g1_256(x) {\n\t  return rotr32$1(x, 17) ^ rotr32$1(x, 19) ^ (x >>> 10);\n\t}\n\tvar g1_256_1 = g1_256;\n\n\tvar common$1 = {\n\t\tft_1: ft_1_1,\n\t\tch32: ch32_1,\n\t\tmaj32: maj32_1,\n\t\tp32: p32_1,\n\t\ts0_256: s0_256_1,\n\t\ts1_256: s1_256_1,\n\t\tg0_256: g0_256_1,\n\t\tg1_256: g1_256_1\n\t};\n\n\t'use strict';\n\n\n\n\n\n\tvar rotl32$1 = utils.rotl32;\n\tvar sum32$1 = utils.sum32;\n\tvar sum32_5$1 = utils.sum32_5;\n\tvar ft_1$1 = common$1.ft_1;\n\tvar BlockHash$1 = common.BlockHash;\n\n\tvar sha1_K = [\n\t  0x5A827999, 0x6ED9EBA1,\n\t  0x8F1BBCDC, 0xCA62C1D6\n\t];\n\n\tfunction SHA1() {\n\t  if (!(this instanceof SHA1))\n\t    return new SHA1();\n\n\t  BlockHash$1.call(this);\n\t  this.h = [\n\t    0x67452301, 0xefcdab89, 0x98badcfe,\n\t    0x10325476, 0xc3d2e1f0 ];\n\t  this.W = new Array(80);\n\t}\n\n\tutils.inherits(SHA1, BlockHash$1);\n\tvar _1 = SHA1;\n\n\tSHA1.blockSize = 512;\n\tSHA1.outSize = 160;\n\tSHA1.hmacStrength = 80;\n\tSHA1.padLength = 64;\n\n\tSHA1.prototype._update = function _update(msg, start) {\n\t  var W = this.W;\n\n\t  for (var i = 0; i < 16; i++)\n\t    W[i] = msg[start + i];\n\n\t  for(; i < W.length; i++)\n\t    W[i] = rotl32$1(W[i - 3] ^ W[i - 8] ^ W[i - 14] ^ W[i - 16], 1);\n\n\t  var a = this.h[0];\n\t  var b = this.h[1];\n\t  var c = this.h[2];\n\t  var d = this.h[3];\n\t  var e = this.h[4];\n\n\t  for (i = 0; i < W.length; i++) {\n\t    var s = ~~(i / 20);\n\t    var t = sum32_5$1(rotl32$1(a, 5), ft_1$1(s, b, c, d), e, W[i], sha1_K[s]);\n\t    e = d;\n\t    d = c;\n\t    c = rotl32$1(b, 30);\n\t    b = a;\n\t    a = t;\n\t  }\n\n\t  this.h[0] = sum32$1(this.h[0], a);\n\t  this.h[1] = sum32$1(this.h[1], b);\n\t  this.h[2] = sum32$1(this.h[2], c);\n\t  this.h[3] = sum32$1(this.h[3], d);\n\t  this.h[4] = sum32$1(this.h[4], e);\n\t};\n\n\tSHA1.prototype._digest = function digest(enc) {\n\t  if (enc === 'hex')\n\t    return utils.toHex32(this.h, 'big');\n\t  else\n\t    return utils.split32(this.h, 'big');\n\t};\n\n\t'use strict';\n\n\n\n\n\n\n\tvar sum32$2 = utils.sum32;\n\tvar sum32_4$1 = utils.sum32_4;\n\tvar sum32_5$2 = utils.sum32_5;\n\tvar ch32$1 = common$1.ch32;\n\tvar maj32$1 = common$1.maj32;\n\tvar s0_256$1 = common$1.s0_256;\n\tvar s1_256$1 = common$1.s1_256;\n\tvar g0_256$1 = common$1.g0_256;\n\tvar g1_256$1 = common$1.g1_256;\n\n\tvar BlockHash$2 = common.BlockHash;\n\n\tvar sha256_K = [\n\t  0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5,\n\t  0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,\n\t  0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3,\n\t  0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,\n\t  0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc,\n\t  0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,\n\t  0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7,\n\t  0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,\n\t  0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13,\n\t  0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,\n\t  0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3,\n\t  0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,\n\t  0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5,\n\t  0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,\n\t  0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208,\n\t  0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2\n\t];\n\n\tfunction SHA256() {\n\t  if (!(this instanceof SHA256))\n\t    return new SHA256();\n\n\t  BlockHash$2.call(this);\n\t  this.h = [\n\t    0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a,\n\t    0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19\n\t  ];\n\t  this.k = sha256_K;\n\t  this.W = new Array(64);\n\t}\n\tutils.inherits(SHA256, BlockHash$2);\n\tvar _256 = SHA256;\n\n\tSHA256.blockSize = 512;\n\tSHA256.outSize = 256;\n\tSHA256.hmacStrength = 192;\n\tSHA256.padLength = 64;\n\n\tSHA256.prototype._update = function _update(msg, start) {\n\t  var W = this.W;\n\n\t  for (var i = 0; i < 16; i++)\n\t    W[i] = msg[start + i];\n\t  for (; i < W.length; i++)\n\t    W[i] = sum32_4$1(g1_256$1(W[i - 2]), W[i - 7], g0_256$1(W[i - 15]), W[i - 16]);\n\n\t  var a = this.h[0];\n\t  var b = this.h[1];\n\t  var c = this.h[2];\n\t  var d = this.h[3];\n\t  var e = this.h[4];\n\t  var f = this.h[5];\n\t  var g = this.h[6];\n\t  var h = this.h[7];\n\n\t  minimalisticAssert(this.k.length === W.length);\n\t  for (i = 0; i < W.length; i++) {\n\t    var T1 = sum32_5$2(h, s1_256$1(e), ch32$1(e, f, g), this.k[i], W[i]);\n\t    var T2 = sum32$2(s0_256$1(a), maj32$1(a, b, c));\n\t    h = g;\n\t    g = f;\n\t    f = e;\n\t    e = sum32$2(d, T1);\n\t    d = c;\n\t    c = b;\n\t    b = a;\n\t    a = sum32$2(T1, T2);\n\t  }\n\n\t  this.h[0] = sum32$2(this.h[0], a);\n\t  this.h[1] = sum32$2(this.h[1], b);\n\t  this.h[2] = sum32$2(this.h[2], c);\n\t  this.h[3] = sum32$2(this.h[3], d);\n\t  this.h[4] = sum32$2(this.h[4], e);\n\t  this.h[5] = sum32$2(this.h[5], f);\n\t  this.h[6] = sum32$2(this.h[6], g);\n\t  this.h[7] = sum32$2(this.h[7], h);\n\t};\n\n\tSHA256.prototype._digest = function digest(enc) {\n\t  if (enc === 'hex')\n\t    return utils.toHex32(this.h, 'big');\n\t  else\n\t    return utils.split32(this.h, 'big');\n\t};\n\n\t'use strict';\n\n\n\n\n\tfunction SHA224() {\n\t  if (!(this instanceof SHA224))\n\t    return new SHA224();\n\n\t  _256.call(this);\n\t  this.h = [\n\t    0xc1059ed8, 0x367cd507, 0x3070dd17, 0xf70e5939,\n\t    0xffc00b31, 0x68581511, 0x64f98fa7, 0xbefa4fa4 ];\n\t}\n\tutils.inherits(SHA224, _256);\n\tvar _224 = SHA224;\n\n\tSHA224.blockSize = 512;\n\tSHA224.outSize = 224;\n\tSHA224.hmacStrength = 192;\n\tSHA224.padLength = 64;\n\n\tSHA224.prototype._digest = function digest(enc) {\n\t  // Just truncate output\n\t  if (enc === 'hex')\n\t    return utils.toHex32(this.h.slice(0, 7), 'big');\n\t  else\n\t    return utils.split32(this.h.slice(0, 7), 'big');\n\t};\n\n\t'use strict';\n\n\n\n\n\n\tvar rotr64_hi$1 = utils.rotr64_hi;\n\tvar rotr64_lo$1 = utils.rotr64_lo;\n\tvar shr64_hi$1 = utils.shr64_hi;\n\tvar shr64_lo$1 = utils.shr64_lo;\n\tvar sum64$1 = utils.sum64;\n\tvar sum64_hi$1 = utils.sum64_hi;\n\tvar sum64_lo$1 = utils.sum64_lo;\n\tvar sum64_4_hi$1 = utils.sum64_4_hi;\n\tvar sum64_4_lo$1 = utils.sum64_4_lo;\n\tvar sum64_5_hi$1 = utils.sum64_5_hi;\n\tvar sum64_5_lo$1 = utils.sum64_5_lo;\n\n\tvar BlockHash$3 = common.BlockHash;\n\n\tvar sha512_K = [\n\t  0x428a2f98, 0xd728ae22, 0x71374491, 0x23ef65cd,\n\t  0xb5c0fbcf, 0xec4d3b2f, 0xe9b5dba5, 0x8189dbbc,\n\t  0x3956c25b, 0xf348b538, 0x59f111f1, 0xb605d019,\n\t  0x923f82a4, 0xaf194f9b, 0xab1c5ed5, 0xda6d8118,\n\t  0xd807aa98, 0xa3030242, 0x12835b01, 0x45706fbe,\n\t  0x243185be, 0x4ee4b28c, 0x550c7dc3, 0xd5ffb4e2,\n\t  0x72be5d74, 0xf27b896f, 0x80deb1fe, 0x3b1696b1,\n\t  0x9bdc06a7, 0x25c71235, 0xc19bf174, 0xcf692694,\n\t  0xe49b69c1, 0x9ef14ad2, 0xefbe4786, 0x384f25e3,\n\t  0x0fc19dc6, 0x8b8cd5b5, 0x240ca1cc, 0x77ac9c65,\n\t  0x2de92c6f, 0x592b0275, 0x4a7484aa, 0x6ea6e483,\n\t  0x5cb0a9dc, 0xbd41fbd4, 0x76f988da, 0x831153b5,\n\t  0x983e5152, 0xee66dfab, 0xa831c66d, 0x2db43210,\n\t  0xb00327c8, 0x98fb213f, 0xbf597fc7, 0xbeef0ee4,\n\t  0xc6e00bf3, 0x3da88fc2, 0xd5a79147, 0x930aa725,\n\t  0x06ca6351, 0xe003826f, 0x14292967, 0x0a0e6e70,\n\t  0x27b70a85, 0x46d22ffc, 0x2e1b2138, 0x5c26c926,\n\t  0x4d2c6dfc, 0x5ac42aed, 0x53380d13, 0x9d95b3df,\n\t  0x650a7354, 0x8baf63de, 0x766a0abb, 0x3c77b2a8,\n\t  0x81c2c92e, 0x47edaee6, 0x92722c85, 0x1482353b,\n\t  0xa2bfe8a1, 0x4cf10364, 0xa81a664b, 0xbc423001,\n\t  0xc24b8b70, 0xd0f89791, 0xc76c51a3, 0x0654be30,\n\t  0xd192e819, 0xd6ef5218, 0xd6990624, 0x5565a910,\n\t  0xf40e3585, 0x5771202a, 0x106aa070, 0x32bbd1b8,\n\t  0x19a4c116, 0xb8d2d0c8, 0x1e376c08, 0x5141ab53,\n\t  0x2748774c, 0xdf8eeb99, 0x34b0bcb5, 0xe19b48a8,\n\t  0x391c0cb3, 0xc5c95a63, 0x4ed8aa4a, 0xe3418acb,\n\t  0x5b9cca4f, 0x7763e373, 0x682e6ff3, 0xd6b2b8a3,\n\t  0x748f82ee, 0x5defb2fc, 0x78a5636f, 0x43172f60,\n\t  0x84c87814, 0xa1f0ab72, 0x8cc70208, 0x1a6439ec,\n\t  0x90befffa, 0x23631e28, 0xa4506ceb, 0xde82bde9,\n\t  0xbef9a3f7, 0xb2c67915, 0xc67178f2, 0xe372532b,\n\t  0xca273ece, 0xea26619c, 0xd186b8c7, 0x21c0c207,\n\t  0xeada7dd6, 0xcde0eb1e, 0xf57d4f7f, 0xee6ed178,\n\t  0x06f067aa, 0x72176fba, 0x0a637dc5, 0xa2c898a6,\n\t  0x113f9804, 0xbef90dae, 0x1b710b35, 0x131c471b,\n\t  0x28db77f5, 0x23047d84, 0x32caab7b, 0x40c72493,\n\t  0x3c9ebe0a, 0x15c9bebc, 0x431d67c4, 0x9c100d4c,\n\t  0x4cc5d4be, 0xcb3e42b6, 0x597f299c, 0xfc657e2a,\n\t  0x5fcb6fab, 0x3ad6faec, 0x6c44198c, 0x4a475817\n\t];\n\n\tfunction SHA512() {\n\t  if (!(this instanceof SHA512))\n\t    return new SHA512();\n\n\t  BlockHash$3.call(this);\n\t  this.h = [\n\t    0x6a09e667, 0xf3bcc908,\n\t    0xbb67ae85, 0x84caa73b,\n\t    0x3c6ef372, 0xfe94f82b,\n\t    0xa54ff53a, 0x5f1d36f1,\n\t    0x510e527f, 0xade682d1,\n\t    0x9b05688c, 0x2b3e6c1f,\n\t    0x1f83d9ab, 0xfb41bd6b,\n\t    0x5be0cd19, 0x137e2179 ];\n\t  this.k = sha512_K;\n\t  this.W = new Array(160);\n\t}\n\tutils.inherits(SHA512, BlockHash$3);\n\tvar _512 = SHA512;\n\n\tSHA512.blockSize = 1024;\n\tSHA512.outSize = 512;\n\tSHA512.hmacStrength = 192;\n\tSHA512.padLength = 128;\n\n\tSHA512.prototype._prepareBlock = function _prepareBlock(msg, start) {\n\t  var W = this.W;\n\n\t  // 32 x 32bit words\n\t  for (var i = 0; i < 32; i++)\n\t    W[i] = msg[start + i];\n\t  for (; i < W.length; i += 2) {\n\t    var c0_hi = g1_512_hi(W[i - 4], W[i - 3]);  // i - 2\n\t    var c0_lo = g1_512_lo(W[i - 4], W[i - 3]);\n\t    var c1_hi = W[i - 14];  // i - 7\n\t    var c1_lo = W[i - 13];\n\t    var c2_hi = g0_512_hi(W[i - 30], W[i - 29]);  // i - 15\n\t    var c2_lo = g0_512_lo(W[i - 30], W[i - 29]);\n\t    var c3_hi = W[i - 32];  // i - 16\n\t    var c3_lo = W[i - 31];\n\n\t    W[i] = sum64_4_hi$1(\n\t      c0_hi, c0_lo,\n\t      c1_hi, c1_lo,\n\t      c2_hi, c2_lo,\n\t      c3_hi, c3_lo);\n\t    W[i + 1] = sum64_4_lo$1(\n\t      c0_hi, c0_lo,\n\t      c1_hi, c1_lo,\n\t      c2_hi, c2_lo,\n\t      c3_hi, c3_lo);\n\t  }\n\t};\n\n\tSHA512.prototype._update = function _update(msg, start) {\n\t  this._prepareBlock(msg, start);\n\n\t  var W = this.W;\n\n\t  var ah = this.h[0];\n\t  var al = this.h[1];\n\t  var bh = this.h[2];\n\t  var bl = this.h[3];\n\t  var ch = this.h[4];\n\t  var cl = this.h[5];\n\t  var dh = this.h[6];\n\t  var dl = this.h[7];\n\t  var eh = this.h[8];\n\t  var el = this.h[9];\n\t  var fh = this.h[10];\n\t  var fl = this.h[11];\n\t  var gh = this.h[12];\n\t  var gl = this.h[13];\n\t  var hh = this.h[14];\n\t  var hl = this.h[15];\n\n\t  minimalisticAssert(this.k.length === W.length);\n\t  for (var i = 0; i < W.length; i += 2) {\n\t    var c0_hi = hh;\n\t    var c0_lo = hl;\n\t    var c1_hi = s1_512_hi(eh, el);\n\t    var c1_lo = s1_512_lo(eh, el);\n\t    var c2_hi = ch64_hi(eh, el, fh, fl, gh, gl);\n\t    var c2_lo = ch64_lo(eh, el, fh, fl, gh, gl);\n\t    var c3_hi = this.k[i];\n\t    var c3_lo = this.k[i + 1];\n\t    var c4_hi = W[i];\n\t    var c4_lo = W[i + 1];\n\n\t    var T1_hi = sum64_5_hi$1(\n\t      c0_hi, c0_lo,\n\t      c1_hi, c1_lo,\n\t      c2_hi, c2_lo,\n\t      c3_hi, c3_lo,\n\t      c4_hi, c4_lo);\n\t    var T1_lo = sum64_5_lo$1(\n\t      c0_hi, c0_lo,\n\t      c1_hi, c1_lo,\n\t      c2_hi, c2_lo,\n\t      c3_hi, c3_lo,\n\t      c4_hi, c4_lo);\n\n\t    c0_hi = s0_512_hi(ah, al);\n\t    c0_lo = s0_512_lo(ah, al);\n\t    c1_hi = maj64_hi(ah, al, bh, bl, ch, cl);\n\t    c1_lo = maj64_lo(ah, al, bh, bl, ch, cl);\n\n\t    var T2_hi = sum64_hi$1(c0_hi, c0_lo, c1_hi, c1_lo);\n\t    var T2_lo = sum64_lo$1(c0_hi, c0_lo, c1_hi, c1_lo);\n\n\t    hh = gh;\n\t    hl = gl;\n\n\t    gh = fh;\n\t    gl = fl;\n\n\t    fh = eh;\n\t    fl = el;\n\n\t    eh = sum64_hi$1(dh, dl, T1_hi, T1_lo);\n\t    el = sum64_lo$1(dl, dl, T1_hi, T1_lo);\n\n\t    dh = ch;\n\t    dl = cl;\n\n\t    ch = bh;\n\t    cl = bl;\n\n\t    bh = ah;\n\t    bl = al;\n\n\t    ah = sum64_hi$1(T1_hi, T1_lo, T2_hi, T2_lo);\n\t    al = sum64_lo$1(T1_hi, T1_lo, T2_hi, T2_lo);\n\t  }\n\n\t  sum64$1(this.h, 0, ah, al);\n\t  sum64$1(this.h, 2, bh, bl);\n\t  sum64$1(this.h, 4, ch, cl);\n\t  sum64$1(this.h, 6, dh, dl);\n\t  sum64$1(this.h, 8, eh, el);\n\t  sum64$1(this.h, 10, fh, fl);\n\t  sum64$1(this.h, 12, gh, gl);\n\t  sum64$1(this.h, 14, hh, hl);\n\t};\n\n\tSHA512.prototype._digest = function digest(enc) {\n\t  if (enc === 'hex')\n\t    return utils.toHex32(this.h, 'big');\n\t  else\n\t    return utils.split32(this.h, 'big');\n\t};\n\n\tfunction ch64_hi(xh, xl, yh, yl, zh) {\n\t  var r = (xh & yh) ^ ((~xh) & zh);\n\t  if (r < 0)\n\t    r += 0x100000000;\n\t  return r;\n\t}\n\n\tfunction ch64_lo(xh, xl, yh, yl, zh, zl) {\n\t  var r = (xl & yl) ^ ((~xl) & zl);\n\t  if (r < 0)\n\t    r += 0x100000000;\n\t  return r;\n\t}\n\n\tfunction maj64_hi(xh, xl, yh, yl, zh) {\n\t  var r = (xh & yh) ^ (xh & zh) ^ (yh & zh);\n\t  if (r < 0)\n\t    r += 0x100000000;\n\t  return r;\n\t}\n\n\tfunction maj64_lo(xh, xl, yh, yl, zh, zl) {\n\t  var r = (xl & yl) ^ (xl & zl) ^ (yl & zl);\n\t  if (r < 0)\n\t    r += 0x100000000;\n\t  return r;\n\t}\n\n\tfunction s0_512_hi(xh, xl) {\n\t  var c0_hi = rotr64_hi$1(xh, xl, 28);\n\t  var c1_hi = rotr64_hi$1(xl, xh, 2);  // 34\n\t  var c2_hi = rotr64_hi$1(xl, xh, 7);  // 39\n\n\t  var r = c0_hi ^ c1_hi ^ c2_hi;\n\t  if (r < 0)\n\t    r += 0x100000000;\n\t  return r;\n\t}\n\n\tfunction s0_512_lo(xh, xl) {\n\t  var c0_lo = rotr64_lo$1(xh, xl, 28);\n\t  var c1_lo = rotr64_lo$1(xl, xh, 2);  // 34\n\t  var c2_lo = rotr64_lo$1(xl, xh, 7);  // 39\n\n\t  var r = c0_lo ^ c1_lo ^ c2_lo;\n\t  if (r < 0)\n\t    r += 0x100000000;\n\t  return r;\n\t}\n\n\tfunction s1_512_hi(xh, xl) {\n\t  var c0_hi = rotr64_hi$1(xh, xl, 14);\n\t  var c1_hi = rotr64_hi$1(xh, xl, 18);\n\t  var c2_hi = rotr64_hi$1(xl, xh, 9);  // 41\n\n\t  var r = c0_hi ^ c1_hi ^ c2_hi;\n\t  if (r < 0)\n\t    r += 0x100000000;\n\t  return r;\n\t}\n\n\tfunction s1_512_lo(xh, xl) {\n\t  var c0_lo = rotr64_lo$1(xh, xl, 14);\n\t  var c1_lo = rotr64_lo$1(xh, xl, 18);\n\t  var c2_lo = rotr64_lo$1(xl, xh, 9);  // 41\n\n\t  var r = c0_lo ^ c1_lo ^ c2_lo;\n\t  if (r < 0)\n\t    r += 0x100000000;\n\t  return r;\n\t}\n\n\tfunction g0_512_hi(xh, xl) {\n\t  var c0_hi = rotr64_hi$1(xh, xl, 1);\n\t  var c1_hi = rotr64_hi$1(xh, xl, 8);\n\t  var c2_hi = shr64_hi$1(xh, xl, 7);\n\n\t  var r = c0_hi ^ c1_hi ^ c2_hi;\n\t  if (r < 0)\n\t    r += 0x100000000;\n\t  return r;\n\t}\n\n\tfunction g0_512_lo(xh, xl) {\n\t  var c0_lo = rotr64_lo$1(xh, xl, 1);\n\t  var c1_lo = rotr64_lo$1(xh, xl, 8);\n\t  var c2_lo = shr64_lo$1(xh, xl, 7);\n\n\t  var r = c0_lo ^ c1_lo ^ c2_lo;\n\t  if (r < 0)\n\t    r += 0x100000000;\n\t  return r;\n\t}\n\n\tfunction g1_512_hi(xh, xl) {\n\t  var c0_hi = rotr64_hi$1(xh, xl, 19);\n\t  var c1_hi = rotr64_hi$1(xl, xh, 29);  // 61\n\t  var c2_hi = shr64_hi$1(xh, xl, 6);\n\n\t  var r = c0_hi ^ c1_hi ^ c2_hi;\n\t  if (r < 0)\n\t    r += 0x100000000;\n\t  return r;\n\t}\n\n\tfunction g1_512_lo(xh, xl) {\n\t  var c0_lo = rotr64_lo$1(xh, xl, 19);\n\t  var c1_lo = rotr64_lo$1(xl, xh, 29);  // 61\n\t  var c2_lo = shr64_lo$1(xh, xl, 6);\n\n\t  var r = c0_lo ^ c1_lo ^ c2_lo;\n\t  if (r < 0)\n\t    r += 0x100000000;\n\t  return r;\n\t}\n\n\t'use strict';\n\n\n\n\n\n\tfunction SHA384() {\n\t  if (!(this instanceof SHA384))\n\t    return new SHA384();\n\n\t  _512.call(this);\n\t  this.h = [\n\t    0xcbbb9d5d, 0xc1059ed8,\n\t    0x629a292a, 0x367cd507,\n\t    0x9159015a, 0x3070dd17,\n\t    0x152fecd8, 0xf70e5939,\n\t    0x67332667, 0xffc00b31,\n\t    0x8eb44a87, 0x68581511,\n\t    0xdb0c2e0d, 0x64f98fa7,\n\t    0x47b5481d, 0xbefa4fa4 ];\n\t}\n\tutils.inherits(SHA384, _512);\n\tvar _384 = SHA384;\n\n\tSHA384.blockSize = 1024;\n\tSHA384.outSize = 384;\n\tSHA384.hmacStrength = 192;\n\tSHA384.padLength = 128;\n\n\tSHA384.prototype._digest = function digest(enc) {\n\t  if (enc === 'hex')\n\t    return utils.toHex32(this.h.slice(0, 12), 'big');\n\t  else\n\t    return utils.split32(this.h.slice(0, 12), 'big');\n\t};\n\n\t'use strict';\n\n\tvar sha1 = _1;\n\tvar sha224 = _224;\n\tvar sha256 = _256;\n\tvar sha384 = _384;\n\tvar sha512 = _512;\n\n\tvar sha = {\n\t\tsha1: sha1,\n\t\tsha224: sha224,\n\t\tsha256: sha256,\n\t\tsha384: sha384,\n\t\tsha512: sha512\n\t};\n\n\t'use strict';\n\n\n\n\n\tvar rotl32$2 = utils.rotl32;\n\tvar sum32$3 = utils.sum32;\n\tvar sum32_3$1 = utils.sum32_3;\n\tvar sum32_4$2 = utils.sum32_4;\n\tvar BlockHash$4 = common.BlockHash;\n\n\tfunction RIPEMD160() {\n\t  if (!(this instanceof RIPEMD160))\n\t    return new RIPEMD160();\n\n\t  BlockHash$4.call(this);\n\n\t  this.h = [ 0x67452301, 0xefcdab89, 0x98badcfe, 0x10325476, 0xc3d2e1f0 ];\n\t  this.endian = 'little';\n\t}\n\tutils.inherits(RIPEMD160, BlockHash$4);\n\tvar ripemd160 = RIPEMD160;\n\n\tRIPEMD160.blockSize = 512;\n\tRIPEMD160.outSize = 160;\n\tRIPEMD160.hmacStrength = 192;\n\tRIPEMD160.padLength = 64;\n\n\tRIPEMD160.prototype._update = function update(msg, start) {\n\t  var A = this.h[0];\n\t  var B = this.h[1];\n\t  var C = this.h[2];\n\t  var D = this.h[3];\n\t  var E = this.h[4];\n\t  var Ah = A;\n\t  var Bh = B;\n\t  var Ch = C;\n\t  var Dh = D;\n\t  var Eh = E;\n\t  for (var j = 0; j < 80; j++) {\n\t    var T = sum32$3(\n\t      rotl32$2(\n\t        sum32_4$2(A, f(j, B, C, D), msg[r[j] + start], K(j)),\n\t        s[j]),\n\t      E);\n\t    A = E;\n\t    E = D;\n\t    D = rotl32$2(C, 10);\n\t    C = B;\n\t    B = T;\n\t    T = sum32$3(\n\t      rotl32$2(\n\t        sum32_4$2(Ah, f(79 - j, Bh, Ch, Dh), msg[rh[j] + start], Kh(j)),\n\t        sh[j]),\n\t      Eh);\n\t    Ah = Eh;\n\t    Eh = Dh;\n\t    Dh = rotl32$2(Ch, 10);\n\t    Ch = Bh;\n\t    Bh = T;\n\t  }\n\t  T = sum32_3$1(this.h[1], C, Dh);\n\t  this.h[1] = sum32_3$1(this.h[2], D, Eh);\n\t  this.h[2] = sum32_3$1(this.h[3], E, Ah);\n\t  this.h[3] = sum32_3$1(this.h[4], A, Bh);\n\t  this.h[4] = sum32_3$1(this.h[0], B, Ch);\n\t  this.h[0] = T;\n\t};\n\n\tRIPEMD160.prototype._digest = function digest(enc) {\n\t  if (enc === 'hex')\n\t    return utils.toHex32(this.h, 'little');\n\t  else\n\t    return utils.split32(this.h, 'little');\n\t};\n\n\tfunction f(j, x, y, z) {\n\t  if (j <= 15)\n\t    return x ^ y ^ z;\n\t  else if (j <= 31)\n\t    return (x & y) | ((~x) & z);\n\t  else if (j <= 47)\n\t    return (x | (~y)) ^ z;\n\t  else if (j <= 63)\n\t    return (x & z) | (y & (~z));\n\t  else\n\t    return x ^ (y | (~z));\n\t}\n\n\tfunction K(j) {\n\t  if (j <= 15)\n\t    return 0x00000000;\n\t  else if (j <= 31)\n\t    return 0x5a827999;\n\t  else if (j <= 47)\n\t    return 0x6ed9eba1;\n\t  else if (j <= 63)\n\t    return 0x8f1bbcdc;\n\t  else\n\t    return 0xa953fd4e;\n\t}\n\n\tfunction Kh(j) {\n\t  if (j <= 15)\n\t    return 0x50a28be6;\n\t  else if (j <= 31)\n\t    return 0x5c4dd124;\n\t  else if (j <= 47)\n\t    return 0x6d703ef3;\n\t  else if (j <= 63)\n\t    return 0x7a6d76e9;\n\t  else\n\t    return 0x00000000;\n\t}\n\n\tvar r = [\n\t  0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15,\n\t  7, 4, 13, 1, 10, 6, 15, 3, 12, 0, 9, 5, 2, 14, 11, 8,\n\t  3, 10, 14, 4, 9, 15, 8, 1, 2, 7, 0, 6, 13, 11, 5, 12,\n\t  1, 9, 11, 10, 0, 8, 12, 4, 13, 3, 7, 15, 14, 5, 6, 2,\n\t  4, 0, 5, 9, 7, 12, 2, 10, 14, 1, 3, 8, 11, 6, 15, 13\n\t];\n\n\tvar rh = [\n\t  5, 14, 7, 0, 9, 2, 11, 4, 13, 6, 15, 8, 1, 10, 3, 12,\n\t  6, 11, 3, 7, 0, 13, 5, 10, 14, 15, 8, 12, 4, 9, 1, 2,\n\t  15, 5, 1, 3, 7, 14, 6, 9, 11, 8, 12, 2, 10, 0, 4, 13,\n\t  8, 6, 4, 1, 3, 11, 15, 0, 5, 12, 2, 13, 9, 7, 10, 14,\n\t  12, 15, 10, 4, 1, 5, 8, 7, 6, 2, 13, 14, 0, 3, 9, 11\n\t];\n\n\tvar s = [\n\t  11, 14, 15, 12, 5, 8, 7, 9, 11, 13, 14, 15, 6, 7, 9, 8,\n\t  7, 6, 8, 13, 11, 9, 7, 15, 7, 12, 15, 9, 11, 7, 13, 12,\n\t  11, 13, 6, 7, 14, 9, 13, 15, 14, 8, 13, 6, 5, 12, 7, 5,\n\t  11, 12, 14, 15, 14, 15, 9, 8, 9, 14, 5, 6, 8, 6, 5, 12,\n\t  9, 15, 5, 11, 6, 8, 13, 12, 5, 12, 13, 14, 11, 8, 5, 6\n\t];\n\n\tvar sh = [\n\t  8, 9, 9, 11, 13, 15, 15, 5, 7, 7, 8, 11, 14, 14, 12, 6,\n\t  9, 13, 15, 7, 12, 8, 9, 11, 7, 7, 12, 7, 6, 15, 13, 11,\n\t  9, 7, 15, 11, 8, 6, 6, 14, 12, 13, 5, 14, 13, 13, 7, 5,\n\t  15, 5, 8, 11, 14, 14, 6, 14, 6, 9, 12, 9, 12, 5, 15, 8,\n\t  8, 5, 12, 9, 12, 5, 14, 6, 8, 13, 6, 5, 15, 13, 11, 11\n\t];\n\n\tvar ripemd = {\n\t\tripemd160: ripemd160\n\t};\n\n\t'use strict';\n\n\n\n\n\tfunction Hmac(hash, key, enc) {\n\t  if (!(this instanceof Hmac))\n\t    return new Hmac(hash, key, enc);\n\t  this.Hash = hash;\n\t  this.blockSize = hash.blockSize / 8;\n\t  this.outSize = hash.outSize / 8;\n\t  this.inner = null;\n\t  this.outer = null;\n\n\t  this._init(utils.toArray(key, enc));\n\t}\n\tvar hmac = Hmac;\n\n\tHmac.prototype._init = function init(key) {\n\t  // Shorten key, if needed\n\t  if (key.length > this.blockSize)\n\t    key = new this.Hash().update(key).digest();\n\t  minimalisticAssert(key.length <= this.blockSize);\n\n\t  // Add padding to key\n\t  for (var i = key.length; i < this.blockSize; i++)\n\t    key.push(0);\n\n\t  for (i = 0; i < key.length; i++)\n\t    key[i] ^= 0x36;\n\t  this.inner = new this.Hash().update(key);\n\n\t  // 0x36 ^ 0x5c = 0x6a\n\t  for (i = 0; i < key.length; i++)\n\t    key[i] ^= 0x6a;\n\t  this.outer = new this.Hash().update(key);\n\t};\n\n\tHmac.prototype.update = function update(msg, enc) {\n\t  this.inner.update(msg, enc);\n\t  return this;\n\t};\n\n\tHmac.prototype.digest = function digest(enc) {\n\t  this.outer.update(this.inner.digest());\n\t  return this.outer.digest(enc);\n\t};\n\n\tvar hash_1 = createCommonjsModule(function (module, exports) {\n\tvar hash = exports;\n\n\thash.utils = utils;\n\thash.common = common;\n\thash.sha = sha;\n\thash.ripemd = ripemd;\n\thash.hmac = hmac;\n\n\t// Proxy hash functions to the main object\n\thash.sha1 = hash.sha.sha1;\n\thash.sha256 = hash.sha.sha256;\n\thash.sha224 = hash.sha.sha224;\n\thash.sha384 = hash.sha.sha384;\n\thash.sha512 = hash.sha.sha512;\n\thash.ripemd160 = hash.ripemd.ripemd160;\n\t});\n\n\tvar curves_1 = createCommonjsModule(function (module, exports) {\n\t'use strict';\n\n\tvar curves = exports;\n\n\n\n\n\n\tvar assert = utils_1$1.assert;\n\n\tfunction PresetCurve(options) {\n\t  if (options.type === 'short')\n\t    this.curve = new curve_1.short(options);\n\t  else if (options.type === 'edwards')\n\t    this.curve = new curve_1.edwards(options);\n\t  else\n\t    this.curve = new curve_1.mont(options);\n\t  this.g = this.curve.g;\n\t  this.n = this.curve.n;\n\t  this.hash = options.hash;\n\n\t  assert(this.g.validate(), 'Invalid curve');\n\t  assert(this.g.mul(this.n).isInfinity(), 'Invalid curve, G*N != O');\n\t}\n\tcurves.PresetCurve = PresetCurve;\n\n\tfunction defineCurve(name, options) {\n\t  Object.defineProperty(curves, name, {\n\t    configurable: true,\n\t    enumerable: true,\n\t    get: function() {\n\t      var curve = new PresetCurve(options);\n\t      Object.defineProperty(curves, name, {\n\t        configurable: true,\n\t        enumerable: true,\n\t        value: curve,\n\t      });\n\t      return curve;\n\t    },\n\t  });\n\t}\n\n\tdefineCurve('p192', {\n\t  type: 'short',\n\t  prime: 'p192',\n\t  p: 'ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff',\n\t  a: 'ffffffff ffffffff ffffffff fffffffe ffffffff fffffffc',\n\t  b: '64210519 e59c80e7 0fa7e9ab 72243049 feb8deec c146b9b1',\n\t  n: 'ffffffff ffffffff ffffffff 99def836 146bc9b1 b4d22831',\n\t  hash: hash_1.sha256,\n\t  gRed: false,\n\t  g: [\n\t    '188da80e b03090f6 7cbf20eb 43a18800 f4ff0afd 82ff1012',\n\t    '07192b95 ffc8da78 631011ed 6b24cdd5 73f977a1 1e794811',\n\t  ],\n\t});\n\n\tdefineCurve('p224', {\n\t  type: 'short',\n\t  prime: 'p224',\n\t  p: 'ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001',\n\t  a: 'ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff fffffffe',\n\t  b: 'b4050a85 0c04b3ab f5413256 5044b0b7 d7bfd8ba 270b3943 2355ffb4',\n\t  n: 'ffffffff ffffffff ffffffff ffff16a2 e0b8f03e 13dd2945 5c5c2a3d',\n\t  hash: hash_1.sha256,\n\t  gRed: false,\n\t  g: [\n\t    'b70e0cbd 6bb4bf7f 321390b9 4a03c1d3 56c21122 343280d6 115c1d21',\n\t    'bd376388 b5f723fb 4c22dfe6 cd4375a0 5a074764 44d58199 85007e34',\n\t  ],\n\t});\n\n\tdefineCurve('p256', {\n\t  type: 'short',\n\t  prime: null,\n\t  p: 'ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff ffffffff',\n\t  a: 'ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff fffffffc',\n\t  b: '5ac635d8 aa3a93e7 b3ebbd55 769886bc 651d06b0 cc53b0f6 3bce3c3e 27d2604b',\n\t  n: 'ffffffff 00000000 ffffffff ffffffff bce6faad a7179e84 f3b9cac2 fc632551',\n\t  hash: hash_1.sha256,\n\t  gRed: false,\n\t  g: [\n\t    '6b17d1f2 e12c4247 f8bce6e5 63a440f2 77037d81 2deb33a0 f4a13945 d898c296',\n\t    '4fe342e2 fe1a7f9b 8ee7eb4a 7c0f9e16 2bce3357 6b315ece cbb64068 37bf51f5',\n\t  ],\n\t});\n\n\tdefineCurve('p384', {\n\t  type: 'short',\n\t  prime: null,\n\t  p: 'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ' +\n\t     'fffffffe ffffffff 00000000 00000000 ffffffff',\n\t  a: 'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ' +\n\t     'fffffffe ffffffff 00000000 00000000 fffffffc',\n\t  b: 'b3312fa7 e23ee7e4 988e056b e3f82d19 181d9c6e fe814112 0314088f ' +\n\t     '5013875a c656398d 8a2ed19d 2a85c8ed d3ec2aef',\n\t  n: 'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff c7634d81 ' +\n\t     'f4372ddf 581a0db2 48b0a77a ecec196a ccc52973',\n\t  hash: hash_1.sha384,\n\t  gRed: false,\n\t  g: [\n\t    'aa87ca22 be8b0537 8eb1c71e f320ad74 6e1d3b62 8ba79b98 59f741e0 82542a38 ' +\n\t    '5502f25d bf55296c 3a545e38 72760ab7',\n\t    '3617de4a 96262c6f 5d9e98bf 9292dc29 f8f41dbd 289a147c e9da3113 b5f0b8c0 ' +\n\t    '0a60b1ce 1d7e819d 7a431d7c 90ea0e5f',\n\t  ],\n\t});\n\n\tdefineCurve('p521', {\n\t  type: 'short',\n\t  prime: null,\n\t  p: '000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ' +\n\t     'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ' +\n\t     'ffffffff ffffffff ffffffff ffffffff ffffffff',\n\t  a: '000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ' +\n\t     'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ' +\n\t     'ffffffff ffffffff ffffffff ffffffff fffffffc',\n\t  b: '00000051 953eb961 8e1c9a1f 929a21a0 b68540ee a2da725b ' +\n\t     '99b315f3 b8b48991 8ef109e1 56193951 ec7e937b 1652c0bd ' +\n\t     '3bb1bf07 3573df88 3d2c34f1 ef451fd4 6b503f00',\n\t  n: '000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ' +\n\t     'ffffffff ffffffff fffffffa 51868783 bf2f966b 7fcc0148 ' +\n\t     'f709a5d0 3bb5c9b8 899c47ae bb6fb71e 91386409',\n\t  hash: hash_1.sha512,\n\t  gRed: false,\n\t  g: [\n\t    '000000c6 858e06b7 0404e9cd 9e3ecb66 2395b442 9c648139 ' +\n\t    '053fb521 f828af60 6b4d3dba a14b5e77 efe75928 fe1dc127 ' +\n\t    'a2ffa8de 3348b3c1 856a429b f97e7e31 c2e5bd66',\n\t    '00000118 39296a78 9a3bc004 5c8a5fb4 2c7d1bd9 98f54449 ' +\n\t    '579b4468 17afbd17 273e662c 97ee7299 5ef42640 c550b901 ' +\n\t    '3fad0761 353c7086 a272c240 88be9476 9fd16650',\n\t  ],\n\t});\n\n\tdefineCurve('curve25519', {\n\t  type: 'mont',\n\t  prime: 'p25519',\n\t  p: '7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed',\n\t  a: '76d06',\n\t  b: '1',\n\t  n: '1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed',\n\t  hash: hash_1.sha256,\n\t  gRed: false,\n\t  g: [\n\t    '9',\n\t  ],\n\t});\n\n\tdefineCurve('ed25519', {\n\t  type: 'edwards',\n\t  prime: 'p25519',\n\t  p: '7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed',\n\t  a: '-1',\n\t  c: '1',\n\t  // -121665 * (121666^(-1)) (mod P)\n\t  d: '52036cee2b6ffe73 8cc740797779e898 00700a4d4141d8ab 75eb4dca135978a3',\n\t  n: '1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed',\n\t  hash: hash_1.sha256,\n\t  gRed: false,\n\t  g: [\n\t    '216936d3cd6e53fec0a4e231fdd6dc5c692cc7609525a7b2c9562d608f25d51a',\n\n\t    // 4/5\n\t    '6666666666666666666666666666666666666666666666666666666666666658',\n\t  ],\n\t});\n\n\tvar pre;\n\ttry {\n\t  pre = /*RicMoo:ethers:require(./precomputed/secp256k1)*/(null).crash();\n\t} catch (e) {\n\t  pre = undefined;\n\t}\n\n\tdefineCurve('secp256k1', {\n\t  type: 'short',\n\t  prime: 'k256',\n\t  p: 'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f',\n\t  a: '0',\n\t  b: '7',\n\t  n: 'ffffffff ffffffff ffffffff fffffffe baaedce6 af48a03b bfd25e8c d0364141',\n\t  h: '1',\n\t  hash: hash_1.sha256,\n\n\t  // Precomputed endomorphism\n\t  beta: '7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee',\n\t  lambda: '5363ad4cc05c30e0a5261c028812645a122e22ea20816678df02967c1b23bd72',\n\t  basis: [\n\t    {\n\t      a: '3086d221a7d46bcde86c90e49284eb15',\n\t      b: '-e4437ed6010e88286f547fa90abfe4c3',\n\t    },\n\t    {\n\t      a: '114ca50f7a8e2f3f657c1108d9d44cfd8',\n\t      b: '3086d221a7d46bcde86c90e49284eb15',\n\t    },\n\t  ],\n\n\t  gRed: false,\n\t  g: [\n\t    '79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798',\n\t    '483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8',\n\t    pre,\n\t  ],\n\t});\n\t});\n\n\t'use strict';\n\n\n\n\n\n\tfunction HmacDRBG(options) {\n\t  if (!(this instanceof HmacDRBG))\n\t    return new HmacDRBG(options);\n\t  this.hash = options.hash;\n\t  this.predResist = !!options.predResist;\n\n\t  this.outLen = this.hash.outSize;\n\t  this.minEntropy = options.minEntropy || this.hash.hmacStrength;\n\n\t  this._reseed = null;\n\t  this.reseedInterval = null;\n\t  this.K = null;\n\t  this.V = null;\n\n\t  var entropy = utils_1.toArray(options.entropy, options.entropyEnc || 'hex');\n\t  var nonce = utils_1.toArray(options.nonce, options.nonceEnc || 'hex');\n\t  var pers = utils_1.toArray(options.pers, options.persEnc || 'hex');\n\t  minimalisticAssert(entropy.length >= (this.minEntropy / 8),\n\t         'Not enough entropy. Minimum is: ' + this.minEntropy + ' bits');\n\t  this._init(entropy, nonce, pers);\n\t}\n\tvar hmacDrbg = HmacDRBG;\n\n\tHmacDRBG.prototype._init = function init(entropy, nonce, pers) {\n\t  var seed = entropy.concat(nonce).concat(pers);\n\n\t  this.K = new Array(this.outLen / 8);\n\t  this.V = new Array(this.outLen / 8);\n\t  for (var i = 0; i < this.V.length; i++) {\n\t    this.K[i] = 0x00;\n\t    this.V[i] = 0x01;\n\t  }\n\n\t  this._update(seed);\n\t  this._reseed = 1;\n\t  this.reseedInterval = 0x1000000000000;  // 2^48\n\t};\n\n\tHmacDRBG.prototype._hmac = function hmac() {\n\t  return new hash_1.hmac(this.hash, this.K);\n\t};\n\n\tHmacDRBG.prototype._update = function update(seed) {\n\t  var kmac = this._hmac()\n\t                 .update(this.V)\n\t                 .update([ 0x00 ]);\n\t  if (seed)\n\t    kmac = kmac.update(seed);\n\t  this.K = kmac.digest();\n\t  this.V = this._hmac().update(this.V).digest();\n\t  if (!seed)\n\t    return;\n\n\t  this.K = this._hmac()\n\t               .update(this.V)\n\t               .update([ 0x01 ])\n\t               .update(seed)\n\t               .digest();\n\t  this.V = this._hmac().update(this.V).digest();\n\t};\n\n\tHmacDRBG.prototype.reseed = function reseed(entropy, entropyEnc, add, addEnc) {\n\t  // Optional entropy enc\n\t  if (typeof entropyEnc !== 'string') {\n\t    addEnc = add;\n\t    add = entropyEnc;\n\t    entropyEnc = null;\n\t  }\n\n\t  entropy = utils_1.toArray(entropy, entropyEnc);\n\t  add = utils_1.toArray(add, addEnc);\n\n\t  minimalisticAssert(entropy.length >= (this.minEntropy / 8),\n\t         'Not enough entropy. Minimum is: ' + this.minEntropy + ' bits');\n\n\t  this._update(entropy.concat(add || []));\n\t  this._reseed = 1;\n\t};\n\n\tHmacDRBG.prototype.generate = function generate(len, enc, add, addEnc) {\n\t  if (this._reseed > this.reseedInterval)\n\t    throw new Error('Reseed is required');\n\n\t  // Optional encoding\n\t  if (typeof enc !== 'string') {\n\t    addEnc = add;\n\t    add = enc;\n\t    enc = null;\n\t  }\n\n\t  // Optional additional data\n\t  if (add) {\n\t    add = utils_1.toArray(add, addEnc || 'hex');\n\t    this._update(add);\n\t  }\n\n\t  var temp = [];\n\t  while (temp.length < len) {\n\t    this.V = this._hmac().update(this.V).digest();\n\t    temp = temp.concat(this.V);\n\t  }\n\n\t  var res = temp.slice(0, len);\n\t  this._update(add);\n\t  this._reseed++;\n\t  return utils_1.encode(res, enc);\n\t};\n\n\t'use strict';\n\n\n\n\tvar assert$3 = utils_1$1.assert;\n\n\tfunction KeyPair(ec, options) {\n\t  this.ec = ec;\n\t  this.priv = null;\n\t  this.pub = null;\n\n\t  // KeyPair(ec, { priv: ..., pub: ... })\n\t  if (options.priv)\n\t    this._importPrivate(options.priv, options.privEnc);\n\t  if (options.pub)\n\t    this._importPublic(options.pub, options.pubEnc);\n\t}\n\tvar key = KeyPair;\n\n\tKeyPair.fromPublic = function fromPublic(ec, pub, enc) {\n\t  if (pub instanceof KeyPair)\n\t    return pub;\n\n\t  return new KeyPair(ec, {\n\t    pub: pub,\n\t    pubEnc: enc,\n\t  });\n\t};\n\n\tKeyPair.fromPrivate = function fromPrivate(ec, priv, enc) {\n\t  if (priv instanceof KeyPair)\n\t    return priv;\n\n\t  return new KeyPair(ec, {\n\t    priv: priv,\n\t    privEnc: enc,\n\t  });\n\t};\n\n\tKeyPair.prototype.validate = function validate() {\n\t  var pub = this.getPublic();\n\n\t  if (pub.isInfinity())\n\t    return { result: false, reason: 'Invalid public key' };\n\t  if (!pub.validate())\n\t    return { result: false, reason: 'Public key is not a point' };\n\t  if (!pub.mul(this.ec.curve.n).isInfinity())\n\t    return { result: false, reason: 'Public key * N != O' };\n\n\t  return { result: true, reason: null };\n\t};\n\n\tKeyPair.prototype.getPublic = function getPublic(compact, enc) {\n\t  // compact is optional argument\n\t  if (typeof compact === 'string') {\n\t    enc = compact;\n\t    compact = null;\n\t  }\n\n\t  if (!this.pub)\n\t    this.pub = this.ec.g.mul(this.priv);\n\n\t  if (!enc)\n\t    return this.pub;\n\n\t  return this.pub.encode(enc, compact);\n\t};\n\n\tKeyPair.prototype.getPrivate = function getPrivate(enc) {\n\t  if (enc === 'hex')\n\t    return this.priv.toString(16, 2);\n\t  else\n\t    return this.priv;\n\t};\n\n\tKeyPair.prototype._importPrivate = function _importPrivate(key, enc) {\n\t  this.priv = new bn(key, enc || 16);\n\n\t  // Ensure that the priv won't be bigger than n, otherwise we may fail\n\t  // in fixed multiplication method\n\t  this.priv = this.priv.umod(this.ec.curve.n);\n\t};\n\n\tKeyPair.prototype._importPublic = function _importPublic(key, enc) {\n\t  if (key.x || key.y) {\n\t    // Montgomery points only have an `x` coordinate.\n\t    // Weierstrass/Edwards points on the other hand have both `x` and\n\t    // `y` coordinates.\n\t    if (this.ec.curve.type === 'mont') {\n\t      assert$3(key.x, 'Need x coordinate');\n\t    } else if (this.ec.curve.type === 'short' ||\n\t               this.ec.curve.type === 'edwards') {\n\t      assert$3(key.x && key.y, 'Need both x and y coordinate');\n\t    }\n\t    this.pub = this.ec.curve.point(key.x, key.y);\n\t    return;\n\t  }\n\t  this.pub = this.ec.curve.decodePoint(key, enc);\n\t};\n\n\t// ECDH\n\tKeyPair.prototype.derive = function derive(pub) {\n\t  if(!pub.validate()) {\n\t    assert$3(pub.validate(), 'public point not validated');\n\t  }\n\t  return pub.mul(this.priv).getX();\n\t};\n\n\t// ECDSA\n\tKeyPair.prototype.sign = function sign(msg, enc, options) {\n\t  return this.ec.sign(msg, this, enc, options);\n\t};\n\n\tKeyPair.prototype.verify = function verify(msg, signature) {\n\t  return this.ec.verify(msg, signature, this);\n\t};\n\n\tKeyPair.prototype.inspect = function inspect() {\n\t  return '<Key priv: ' + (this.priv && this.priv.toString(16, 2)) +\n\t         ' pub: ' + (this.pub && this.pub.inspect()) + ' >';\n\t};\n\n\t'use strict';\n\n\n\n\n\tvar assert$4 = utils_1$1.assert;\n\n\tfunction Signature(options, enc) {\n\t  if (options instanceof Signature)\n\t    return options;\n\n\t  if (this._importDER(options, enc))\n\t    return;\n\n\t  assert$4(options.r && options.s, 'Signature without r or s');\n\t  this.r = new bn(options.r, 16);\n\t  this.s = new bn(options.s, 16);\n\t  if (options.recoveryParam === undefined)\n\t    this.recoveryParam = null;\n\t  else\n\t    this.recoveryParam = options.recoveryParam;\n\t}\n\tvar signature = Signature;\n\n\tfunction Position() {\n\t  this.place = 0;\n\t}\n\n\tfunction getLength(buf, p) {\n\t  var initial = buf[p.place++];\n\t  if (!(initial & 0x80)) {\n\t    return initial;\n\t  }\n\t  var octetLen = initial & 0xf;\n\n\t  // Indefinite length or overflow\n\t  if (octetLen === 0 || octetLen > 4) {\n\t    return false;\n\t  }\n\n\t  var val = 0;\n\t  for (var i = 0, off = p.place; i < octetLen; i++, off++) {\n\t    val <<= 8;\n\t    val |= buf[off];\n\t    val >>>= 0;\n\t  }\n\n\t  // Leading zeroes\n\t  if (val <= 0x7f) {\n\t    return false;\n\t  }\n\n\t  p.place = off;\n\t  return val;\n\t}\n\n\tfunction rmPadding(buf) {\n\t  var i = 0;\n\t  var len = buf.length - 1;\n\t  while (!buf[i] && !(buf[i + 1] & 0x80) && i < len) {\n\t    i++;\n\t  }\n\t  if (i === 0) {\n\t    return buf;\n\t  }\n\t  return buf.slice(i);\n\t}\n\n\tSignature.prototype._importDER = function _importDER(data, enc) {\n\t  data = utils_1$1.toArray(data, enc);\n\t  var p = new Position();\n\t  if (data[p.place++] !== 0x30) {\n\t    return false;\n\t  }\n\t  var len = getLength(data, p);\n\t  if (len === false) {\n\t    return false;\n\t  }\n\t  if ((len + p.place) !== data.length) {\n\t    return false;\n\t  }\n\t  if (data[p.place++] !== 0x02) {\n\t    return false;\n\t  }\n\t  var rlen = getLength(data, p);\n\t  if (rlen === false) {\n\t    return false;\n\t  }\n\t  var r = data.slice(p.place, rlen + p.place);\n\t  p.place += rlen;\n\t  if (data[p.place++] !== 0x02) {\n\t    return false;\n\t  }\n\t  var slen = getLength(data, p);\n\t  if (slen === false) {\n\t    return false;\n\t  }\n\t  if (data.length !== slen + p.place) {\n\t    return false;\n\t  }\n\t  var s = data.slice(p.place, slen + p.place);\n\t  if (r[0] === 0) {\n\t    if (r[1] & 0x80) {\n\t      r = r.slice(1);\n\t    } else {\n\t      // Leading zeroes\n\t      return false;\n\t    }\n\t  }\n\t  if (s[0] === 0) {\n\t    if (s[1] & 0x80) {\n\t      s = s.slice(1);\n\t    } else {\n\t      // Leading zeroes\n\t      return false;\n\t    }\n\t  }\n\n\t  this.r = new bn(r);\n\t  this.s = new bn(s);\n\t  this.recoveryParam = null;\n\n\t  return true;\n\t};\n\n\tfunction constructLength(arr, len) {\n\t  if (len < 0x80) {\n\t    arr.push(len);\n\t    return;\n\t  }\n\t  var octets = 1 + (Math.log(len) / Math.LN2 >>> 3);\n\t  arr.push(octets | 0x80);\n\t  while (--octets) {\n\t    arr.push((len >>> (octets << 3)) & 0xff);\n\t  }\n\t  arr.push(len);\n\t}\n\n\tSignature.prototype.toDER = function toDER(enc) {\n\t  var r = this.r.toArray();\n\t  var s = this.s.toArray();\n\n\t  // Pad values\n\t  if (r[0] & 0x80)\n\t    r = [ 0 ].concat(r);\n\t  // Pad values\n\t  if (s[0] & 0x80)\n\t    s = [ 0 ].concat(s);\n\n\t  r = rmPadding(r);\n\t  s = rmPadding(s);\n\n\t  while (!s[0] && !(s[1] & 0x80)) {\n\t    s = s.slice(1);\n\t  }\n\t  var arr = [ 0x02 ];\n\t  constructLength(arr, r.length);\n\t  arr = arr.concat(r);\n\t  arr.push(0x02);\n\t  constructLength(arr, s.length);\n\t  var backHalf = arr.concat(s);\n\t  var res = [ 0x30 ];\n\t  constructLength(res, backHalf.length);\n\t  res = res.concat(backHalf);\n\t  return utils_1$1.encode(res, enc);\n\t};\n\n\t'use strict';\n\n\n\n\n\n\tvar rand = /*RicMoo:ethers:require(brorand)*/(function() { throw new Error('unsupported'); });\n\tvar assert$5 = utils_1$1.assert;\n\n\n\n\n\tfunction EC(options) {\n\t  if (!(this instanceof EC))\n\t    return new EC(options);\n\n\t  // Shortcut `elliptic.ec(curve-name)`\n\t  if (typeof options === 'string') {\n\t    assert$5(Object.prototype.hasOwnProperty.call(curves_1, options),\n\t      'Unknown curve ' + options);\n\n\t    options = curves_1[options];\n\t  }\n\n\t  // Shortcut for `elliptic.ec(elliptic.curves.curveName)`\n\t  if (options instanceof curves_1.PresetCurve)\n\t    options = { curve: options };\n\n\t  this.curve = options.curve.curve;\n\t  this.n = this.curve.n;\n\t  this.nh = this.n.ushrn(1);\n\t  this.g = this.curve.g;\n\n\t  // Point on curve\n\t  this.g = options.curve.g;\n\t  this.g.precompute(options.curve.n.bitLength() + 1);\n\n\t  // Hash for function for DRBG\n\t  this.hash = options.hash || options.curve.hash;\n\t}\n\tvar ec = EC;\n\n\tEC.prototype.keyPair = function keyPair(options) {\n\t  return new key(this, options);\n\t};\n\n\tEC.prototype.keyFromPrivate = function keyFromPrivate(priv, enc) {\n\t  return key.fromPrivate(this, priv, enc);\n\t};\n\n\tEC.prototype.keyFromPublic = function keyFromPublic(pub, enc) {\n\t  return key.fromPublic(this, pub, enc);\n\t};\n\n\tEC.prototype.genKeyPair = function genKeyPair(options) {\n\t  if (!options)\n\t    options = {};\n\n\t  // Instantiate Hmac_DRBG\n\t  var drbg = new hmacDrbg({\n\t    hash: this.hash,\n\t    pers: options.pers,\n\t    persEnc: options.persEnc || 'utf8',\n\t    entropy: options.entropy || rand(this.hash.hmacStrength),\n\t    entropyEnc: options.entropy && options.entropyEnc || 'utf8',\n\t    nonce: this.n.toArray(),\n\t  });\n\n\t  var bytes = this.n.byteLength();\n\t  var ns2 = this.n.sub(new bn(2));\n\t  for (;;) {\n\t    var priv = new bn(drbg.generate(bytes));\n\t    if (priv.cmp(ns2) > 0)\n\t      continue;\n\n\t    priv.iaddn(1);\n\t    return this.keyFromPrivate(priv);\n\t  }\n\t};\n\n\tEC.prototype._truncateToN = function _truncateToN(msg, truncOnly) {\n\t  var delta = msg.byteLength() * 8 - this.n.bitLength();\n\t  if (delta > 0)\n\t    msg = msg.ushrn(delta);\n\t  if (!truncOnly && msg.cmp(this.n) >= 0)\n\t    return msg.sub(this.n);\n\t  else\n\t    return msg;\n\t};\n\n\tEC.prototype.sign = function sign(msg, key, enc, options) {\n\t  if (typeof enc === 'object') {\n\t    options = enc;\n\t    enc = null;\n\t  }\n\t  if (!options)\n\t    options = {};\n\n\t  key = this.keyFromPrivate(key, enc);\n\t  msg = this._truncateToN(new bn(msg, 16));\n\n\t  // Zero-extend key to provide enough entropy\n\t  var bytes = this.n.byteLength();\n\t  var bkey = key.getPrivate().toArray('be', bytes);\n\n\t  // Zero-extend nonce to have the same byte size as N\n\t  var nonce = msg.toArray('be', bytes);\n\n\t  // Instantiate Hmac_DRBG\n\t  var drbg = new hmacDrbg({\n\t    hash: this.hash,\n\t    entropy: bkey,\n\t    nonce: nonce,\n\t    pers: options.pers,\n\t    persEnc: options.persEnc || 'utf8',\n\t  });\n\n\t  // Number of bytes to generate\n\t  var ns1 = this.n.sub(new bn(1));\n\n\t  for (var iter = 0; ; iter++) {\n\t    var k = options.k ?\n\t      options.k(iter) :\n\t      new bn(drbg.generate(this.n.byteLength()));\n\t    k = this._truncateToN(k, true);\n\t    if (k.cmpn(1) <= 0 || k.cmp(ns1) >= 0)\n\t      continue;\n\n\t    var kp = this.g.mul(k);\n\t    if (kp.isInfinity())\n\t      continue;\n\n\t    var kpX = kp.getX();\n\t    var r = kpX.umod(this.n);\n\t    if (r.cmpn(0) === 0)\n\t      continue;\n\n\t    var s = k.invm(this.n).mul(r.mul(key.getPrivate()).iadd(msg));\n\t    s = s.umod(this.n);\n\t    if (s.cmpn(0) === 0)\n\t      continue;\n\n\t    var recoveryParam = (kp.getY().isOdd() ? 1 : 0) |\n\t                        (kpX.cmp(r) !== 0 ? 2 : 0);\n\n\t    // Use complement of `s`, if it is > `n / 2`\n\t    if (options.canonical && s.cmp(this.nh) > 0) {\n\t      s = this.n.sub(s);\n\t      recoveryParam ^= 1;\n\t    }\n\n\t    return new signature({ r: r, s: s, recoveryParam: recoveryParam });\n\t  }\n\t};\n\n\tEC.prototype.verify = function verify(msg, signature$1, key, enc) {\n\t  msg = this._truncateToN(new bn(msg, 16));\n\t  key = this.keyFromPublic(key, enc);\n\t  signature$1 = new signature(signature$1, 'hex');\n\n\t  // Perform primitive values validation\n\t  var r = signature$1.r;\n\t  var s = signature$1.s;\n\t  if (r.cmpn(1) < 0 || r.cmp(this.n) >= 0)\n\t    return false;\n\t  if (s.cmpn(1) < 0 || s.cmp(this.n) >= 0)\n\t    return false;\n\n\t  // Validate signature\n\t  var sinv = s.invm(this.n);\n\t  var u1 = sinv.mul(msg).umod(this.n);\n\t  var u2 = sinv.mul(r).umod(this.n);\n\t  var p;\n\n\t  if (!this.curve._maxwellTrick) {\n\t    p = this.g.mulAdd(u1, key.getPublic(), u2);\n\t    if (p.isInfinity())\n\t      return false;\n\n\t    return p.getX().umod(this.n).cmp(r) === 0;\n\t  }\n\n\t  // NOTE: Greg Maxwell's trick, inspired by:\n\t  // https://git.io/vad3K\n\n\t  p = this.g.jmulAdd(u1, key.getPublic(), u2);\n\t  if (p.isInfinity())\n\t    return false;\n\n\t  // Compare `p.x` of Jacobian point with `r`,\n\t  // this will do `p.x == r * p.z^2` instead of multiplying `p.x` by the\n\t  // inverse of `p.z^2`\n\t  return p.eqXToP(r);\n\t};\n\n\tEC.prototype.recoverPubKey = function(msg, signature$1, j, enc) {\n\t  assert$5((3 & j) === j, 'The recovery param is more than two bits');\n\t  signature$1 = new signature(signature$1, enc);\n\n\t  var n = this.n;\n\t  var e = new bn(msg);\n\t  var r = signature$1.r;\n\t  var s = signature$1.s;\n\n\t  // A set LSB signifies that the y-coordinate is odd\n\t  var isYOdd = j & 1;\n\t  var isSecondKey = j >> 1;\n\t  if (r.cmp(this.curve.p.umod(this.curve.n)) >= 0 && isSecondKey)\n\t    throw new Error('Unable to find sencond key candinate');\n\n\t  // 1.1. Let x = r + jn.\n\t  if (isSecondKey)\n\t    r = this.curve.pointFromX(r.add(this.curve.n), isYOdd);\n\t  else\n\t    r = this.curve.pointFromX(r, isYOdd);\n\n\t  var rInv = signature$1.r.invm(n);\n\t  var s1 = n.sub(e).mul(rInv).umod(n);\n\t  var s2 = s.mul(rInv).umod(n);\n\n\t  // 1.6.1 Compute Q = r^-1 (sR -  eG)\n\t  //               Q = r^-1 (sR + -eG)\n\t  return this.g.mulAdd(s1, r, s2);\n\t};\n\n\tEC.prototype.getKeyRecoveryParam = function(e, signature$1, Q, enc) {\n\t  signature$1 = new signature(signature$1, enc);\n\t  if (signature$1.recoveryParam !== null)\n\t    return signature$1.recoveryParam;\n\n\t  for (var i = 0; i < 4; i++) {\n\t    var Qprime;\n\t    try {\n\t      Qprime = this.recoverPubKey(e, signature$1, i);\n\t    } catch (e) {\n\t      continue;\n\t    }\n\n\t    if (Qprime.eq(Q))\n\t      return i;\n\t  }\n\t  throw new Error('Unable to find valid recovery factor');\n\t};\n\n\tvar elliptic_1 = createCommonjsModule(function (module, exports) {\n\t'use strict';\n\n\tvar elliptic = exports;\n\n\telliptic.version = /*RicMoo:ethers*/{ version: \"6.5.4\" }.version;\n\telliptic.utils = utils_1$1;\n\telliptic.rand = /*RicMoo:ethers:require(brorand)*/(function() { throw new Error('unsupported'); });\n\telliptic.curve = curve_1;\n\telliptic.curves = curves_1;\n\n\t// Protocols\n\telliptic.ec = ec;\n\telliptic.eddsa = /*RicMoo:ethers:require(./elliptic/eddsa)*/(null);\n\t});\n\n\tvar elliptic = createCommonjsModule(function (module, exports) {\n\t\"use strict\";\n\tvar __importDefault = (commonjsGlobal && commonjsGlobal.__importDefault) || function (mod) {\n\t    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n\t};\n\tObject.defineProperty(exports, \"__esModule\", { value: true });\n\texports.EC = void 0;\n\tvar elliptic_1$1 = __importDefault(elliptic_1);\n\tvar EC = elliptic_1$1.default.ec;\n\texports.EC = EC;\n\n\t});\n\n\tvar elliptic$1 = /*@__PURE__*/getDefaultExportFromCjs(elliptic);\n\n\tvar _version$m = createCommonjsModule(function (module, exports) {\n\t\"use strict\";\n\tObject.defineProperty(exports, \"__esModule\", { value: true });\n\texports.version = void 0;\n\texports.version = \"signing-key/5.5.0\";\n\n\t});\n\n\tvar _version$n = /*@__PURE__*/getDefaultExportFromCjs(_version$m);\n\n\tvar lib$d = createCommonjsModule(function (module, exports) {\n\t\"use strict\";\n\tObject.defineProperty(exports, \"__esModule\", { value: true });\n\texports.computePublicKey = exports.recoverPublicKey = exports.SigningKey = void 0;\n\n\n\n\n\n\tvar logger = new lib.Logger(_version$m.version);\n\tvar _curve = null;\n\tfunction getCurve() {\n\t    if (!_curve) {\n\t        _curve = new elliptic.EC(\"secp256k1\");\n\t    }\n\t    return _curve;\n\t}\n\tvar SigningKey = /** @class */ (function () {\n\t    function SigningKey(privateKey) {\n\t        (0, lib$3.defineReadOnly)(this, \"curve\", \"secp256k1\");\n\t        (0, lib$3.defineReadOnly)(this, \"privateKey\", (0, lib$1.hexlify)(privateKey));\n\t        var keyPair = getCurve().keyFromPrivate((0, lib$1.arrayify)(this.privateKey));\n\t        (0, lib$3.defineReadOnly)(this, \"publicKey\", \"0x\" + keyPair.getPublic(false, \"hex\"));\n\t        (0, lib$3.defineReadOnly)(this, \"compressedPublicKey\", \"0x\" + keyPair.getPublic(true, \"hex\"));\n\t        (0, lib$3.defineReadOnly)(this, \"_isSigningKey\", true);\n\t    }\n\t    SigningKey.prototype._addPoint = function (other) {\n\t        var p0 = getCurve().keyFromPublic((0, lib$1.arrayify)(this.publicKey));\n\t        var p1 = getCurve().keyFromPublic((0, lib$1.arrayify)(other));\n\t        return \"0x\" + p0.pub.add(p1.pub).encodeCompressed(\"hex\");\n\t    };\n\t    SigningKey.prototype.signDigest = function (digest) {\n\t        var keyPair = getCurve().keyFromPrivate((0, lib$1.arrayify)(this.privateKey));\n\t        var digestBytes = (0, lib$1.arrayify)(digest);\n\t        if (digestBytes.length !== 32) {\n\t            logger.throwArgumentError(\"bad digest length\", \"digest\", digest);\n\t        }\n\t        var signature = keyPair.sign(digestBytes, { canonical: true });\n\t        return (0, lib$1.splitSignature)({\n\t            recoveryParam: signature.recoveryParam,\n\t            r: (0, lib$1.hexZeroPad)(\"0x\" + signature.r.toString(16), 32),\n\t            s: (0, lib$1.hexZeroPad)(\"0x\" + signature.s.toString(16), 32),\n\t        });\n\t    };\n\t    SigningKey.prototype.computeSharedSecret = function (otherKey) {\n\t        var keyPair = getCurve().keyFromPrivate((0, lib$1.arrayify)(this.privateKey));\n\t        var otherKeyPair = getCurve().keyFromPublic((0, lib$1.arrayify)(computePublicKey(otherKey)));\n\t        return (0, lib$1.hexZeroPad)(\"0x\" + keyPair.derive(otherKeyPair.getPublic()).toString(16), 32);\n\t    };\n\t    SigningKey.isSigningKey = function (value) {\n\t        return !!(value && value._isSigningKey);\n\t    };\n\t    return SigningKey;\n\t}());\n\texports.SigningKey = SigningKey;\n\tfunction recoverPublicKey(digest, signature) {\n\t    var sig = (0, lib$1.splitSignature)(signature);\n\t    var rs = { r: (0, lib$1.arrayify)(sig.r), s: (0, lib$1.arrayify)(sig.s) };\n\t    return \"0x\" + getCurve().recoverPubKey((0, lib$1.arrayify)(digest), rs, sig.recoveryParam).encode(\"hex\", false);\n\t}\n\texports.recoverPublicKey = recoverPublicKey;\n\tfunction computePublicKey(key, compressed) {\n\t    var bytes = (0, lib$1.arrayify)(key);\n\t    if (bytes.length === 32) {\n\t        var signingKey = new SigningKey(bytes);\n\t        if (compressed) {\n\t            return \"0x\" + getCurve().keyFromPrivate(bytes).getPublic(true, \"hex\");\n\t        }\n\t        return signingKey.publicKey;\n\t    }\n\t    else if (bytes.length === 33) {\n\t        if (compressed) {\n\t            return (0, lib$1.hexlify)(bytes);\n\t        }\n\t        return \"0x\" + getCurve().keyFromPublic(bytes).getPublic(false, \"hex\");\n\t    }\n\t    else if (bytes.length === 65) {\n\t        if (!compressed) {\n\t            return (0, lib$1.hexlify)(bytes);\n\t        }\n\t        return \"0x\" + getCurve().keyFromPublic(bytes).getPublic(true, \"hex\");\n\t    }\n\t    return logger.throwArgumentError(\"invalid public or private key\", \"key\", \"[REDACTED]\");\n\t}\n\texports.computePublicKey = computePublicKey;\n\n\t});\n\n\tvar index$d = /*@__PURE__*/getDefaultExportFromCjs(lib$d);\n\n\tvar _version$o = createCommonjsModule(function (module, exports) {\n\t\"use strict\";\n\tObject.defineProperty(exports, \"__esModule\", { value: true });\n\texports.version = void 0;\n\texports.version = \"transactions/5.5.0\";\n\n\t});\n\n\tvar _version$p = /*@__PURE__*/getDefaultExportFromCjs(_version$o);\n\n\tvar lib$e = createCommonjsModule(function (module, exports) {\n\t\"use strict\";\n\tvar __createBinding = (commonjsGlobal && commonjsGlobal.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n\t    if (k2 === undefined) k2 = k;\n\t    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\n\t}) : (function(o, m, k, k2) {\n\t    if (k2 === undefined) k2 = k;\n\t    o[k2] = m[k];\n\t}));\n\tvar __setModuleDefault = (commonjsGlobal && commonjsGlobal.__setModuleDefault) || (Object.create ? (function(o, v) {\n\t    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n\t}) : function(o, v) {\n\t    o[\"default\"] = v;\n\t});\n\tvar __importStar = (commonjsGlobal && commonjsGlobal.__importStar) || function (mod) {\n\t    if (mod && mod.__esModule) return mod;\n\t    var result = {};\n\t    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n\t    __setModuleDefault(result, mod);\n\t    return result;\n\t};\n\tObject.defineProperty(exports, \"__esModule\", { value: true });\n\texports.parse = exports.serialize = exports.accessListify = exports.recoverAddress = exports.computeAddress = exports.TransactionTypes = void 0;\n\n\n\n\n\n\n\tvar RLP = __importStar(lib$5);\n\n\n\n\tvar logger = new lib.Logger(_version$o.version);\n\tvar TransactionTypes;\n\t(function (TransactionTypes) {\n\t    TransactionTypes[TransactionTypes[\"legacy\"] = 0] = \"legacy\";\n\t    TransactionTypes[TransactionTypes[\"eip2930\"] = 1] = \"eip2930\";\n\t    TransactionTypes[TransactionTypes[\"eip1559\"] = 2] = \"eip1559\";\n\t})(TransactionTypes = exports.TransactionTypes || (exports.TransactionTypes = {}));\n\t;\n\t///////////////////////////////\n\tfunction handleAddress(value) {\n\t    if (value === \"0x\") {\n\t        return null;\n\t    }\n\t    return (0, lib$6.getAddress)(value);\n\t}\n\tfunction handleNumber(value) {\n\t    if (value === \"0x\") {\n\t        return lib$7.Zero;\n\t    }\n\t    return lib$2.BigNumber.from(value);\n\t}\n\t// Legacy Transaction Fields\n\tvar transactionFields = [\n\t    { name: \"nonce\", maxLength: 32, numeric: true },\n\t    { name: \"gasPrice\", maxLength: 32, numeric: true },\n\t    { name: \"gasLimit\", maxLength: 32, numeric: true },\n\t    { name: \"to\", length: 20 },\n\t    { name: \"value\", maxLength: 32, numeric: true },\n\t    { name: \"data\" },\n\t];\n\tvar allowedTransactionKeys = {\n\t    chainId: true, data: true, gasLimit: true, gasPrice: true, nonce: true, to: true, type: true, value: true\n\t};\n\tfunction computeAddress(key) {\n\t    var publicKey = (0, lib$d.computePublicKey)(key);\n\t    return (0, lib$6.getAddress)((0, lib$1.hexDataSlice)((0, lib$4.keccak256)((0, lib$1.hexDataSlice)(publicKey, 1)), 12));\n\t}\n\texports.computeAddress = computeAddress;\n\tfunction recoverAddress(digest, signature) {\n\t    return computeAddress((0, lib$d.recoverPublicKey)((0, lib$1.arrayify)(digest), signature));\n\t}\n\texports.recoverAddress = recoverAddress;\n\tfunction formatNumber(value, name) {\n\t    var result = (0, lib$1.stripZeros)(lib$2.BigNumber.from(value).toHexString());\n\t    if (result.length > 32) {\n\t        logger.throwArgumentError(\"invalid length for \" + name, (\"transaction:\" + name), value);\n\t    }\n\t    return result;\n\t}\n\tfunction accessSetify(addr, storageKeys) {\n\t    return {\n\t        address: (0, lib$6.getAddress)(addr),\n\t        storageKeys: (storageKeys || []).map(function (storageKey, index) {\n\t            if ((0, lib$1.hexDataLength)(storageKey) !== 32) {\n\t                logger.throwArgumentError(\"invalid access list storageKey\", \"accessList[\" + addr + \":\" + index + \"]\", storageKey);\n\t            }\n\t            return storageKey.toLowerCase();\n\t        })\n\t    };\n\t}\n\tfunction accessListify(value) {\n\t    if (Array.isArray(value)) {\n\t        return value.map(function (set, index) {\n\t            if (Array.isArray(set)) {\n\t                if (set.length > 2) {\n\t                    logger.throwArgumentError(\"access list expected to be [ address, storageKeys[] ]\", \"value[\" + index + \"]\", set);\n\t                }\n\t                return accessSetify(set[0], set[1]);\n\t            }\n\t            return accessSetify(set.address, set.storageKeys);\n\t        });\n\t    }\n\t    var result = Object.keys(value).map(function (addr) {\n\t        var storageKeys = value[addr].reduce(function (accum, storageKey) {\n\t            accum[storageKey] = true;\n\t            return accum;\n\t        }, {});\n\t        return accessSetify(addr, Object.keys(storageKeys).sort());\n\t    });\n\t    result.sort(function (a, b) { return (a.address.localeCompare(b.address)); });\n\t    return result;\n\t}\n\texports.accessListify = accessListify;\n\tfunction formatAccessList(value) {\n\t    return accessListify(value).map(function (set) { return [set.address, set.storageKeys]; });\n\t}\n\tfunction _serializeEip1559(transaction, signature) {\n\t    // If there is an explicit gasPrice, make sure it matches the\n\t    // EIP-1559 fees; otherwise they may not understand what they\n\t    // think they are setting in terms of fee.\n\t    if (transaction.gasPrice != null) {\n\t        var gasPrice = lib$2.BigNumber.from(transaction.gasPrice);\n\t        var maxFeePerGas = lib$2.BigNumber.from(transaction.maxFeePerGas || 0);\n\t        if (!gasPrice.eq(maxFeePerGas)) {\n\t            logger.throwArgumentError(\"mismatch EIP-1559 gasPrice != maxFeePerGas\", \"tx\", {\n\t                gasPrice: gasPrice,\n\t                maxFeePerGas: maxFeePerGas\n\t            });\n\t        }\n\t    }\n\t    var fields = [\n\t        formatNumber(transaction.chainId || 0, \"chainId\"),\n\t        formatNumber(transaction.nonce || 0, \"nonce\"),\n\t        formatNumber(transaction.maxPriorityFeePerGas || 0, \"maxPriorityFeePerGas\"),\n\t        formatNumber(transaction.maxFeePerGas || 0, \"maxFeePerGas\"),\n\t        formatNumber(transaction.gasLimit || 0, \"gasLimit\"),\n\t        ((transaction.to != null) ? (0, lib$6.getAddress)(transaction.to) : \"0x\"),\n\t        formatNumber(transaction.value || 0, \"value\"),\n\t        (transaction.data || \"0x\"),\n\t        (formatAccessList(transaction.accessList || []))\n\t    ];\n\t    if (signature) {\n\t        var sig = (0, lib$1.splitSignature)(signature);\n\t        fields.push(formatNumber(sig.recoveryParam, \"recoveryParam\"));\n\t        fields.push((0, lib$1.stripZeros)(sig.r));\n\t        fields.push((0, lib$1.stripZeros)(sig.s));\n\t    }\n\t    return (0, lib$1.hexConcat)([\"0x02\", RLP.encode(fields)]);\n\t}\n\tfunction _serializeEip2930(transaction, signature) {\n\t    var fields = [\n\t        formatNumber(transaction.chainId || 0, \"chainId\"),\n\t        formatNumber(transaction.nonce || 0, \"nonce\"),\n\t        formatNumber(transaction.gasPrice || 0, \"gasPrice\"),\n\t        formatNumber(transaction.gasLimit || 0, \"gasLimit\"),\n\t        ((transaction.to != null) ? (0, lib$6.getAddress)(transaction.to) : \"0x\"),\n\t        formatNumber(transaction.value || 0, \"value\"),\n\t        (transaction.data || \"0x\"),\n\t        (formatAccessList(transaction.accessList || []))\n\t    ];\n\t    if (signature) {\n\t        var sig = (0, lib$1.splitSignature)(signature);\n\t        fields.push(formatNumber(sig.recoveryParam, \"recoveryParam\"));\n\t        fields.push((0, lib$1.stripZeros)(sig.r));\n\t        fields.push((0, lib$1.stripZeros)(sig.s));\n\t    }\n\t    return (0, lib$1.hexConcat)([\"0x01\", RLP.encode(fields)]);\n\t}\n\t// Legacy Transactions and EIP-155\n\tfunction _serialize(transaction, signature) {\n\t    (0, lib$3.checkProperties)(transaction, allowedTransactionKeys);\n\t    var raw = [];\n\t    transactionFields.forEach(function (fieldInfo) {\n\t        var value = transaction[fieldInfo.name] || ([]);\n\t        var options = {};\n\t        if (fieldInfo.numeric) {\n\t            options.hexPad = \"left\";\n\t        }\n\t        value = (0, lib$1.arrayify)((0, lib$1.hexlify)(value, options));\n\t        // Fixed-width field\n\t        if (fieldInfo.length && value.length !== fieldInfo.length && value.length > 0) {\n\t            logger.throwArgumentError(\"invalid length for \" + fieldInfo.name, (\"transaction:\" + fieldInfo.name), value);\n\t        }\n\t        // Variable-width (with a maximum)\n\t        if (fieldInfo.maxLength) {\n\t            value = (0, lib$1.stripZeros)(value);\n\t            if (value.length > fieldInfo.maxLength) {\n\t                logger.throwArgumentError(\"invalid length for \" + fieldInfo.name, (\"transaction:\" + fieldInfo.name), value);\n\t            }\n\t        }\n\t        raw.push((0, lib$1.hexlify)(value));\n\t    });\n\t    var chainId = 0;\n\t    if (transaction.chainId != null) {\n\t        // A chainId was provided; if non-zero we'll use EIP-155\n\t        chainId = transaction.chainId;\n\t        if (typeof (chainId) !== \"number\") {\n\t            logger.throwArgumentError(\"invalid transaction.chainId\", \"transaction\", transaction);\n\t        }\n\t    }\n\t    else if (signature && !(0, lib$1.isBytesLike)(signature) && signature.v > 28) {\n\t        // No chainId provided, but the signature is signing with EIP-155; derive chainId\n\t        chainId = Math.floor((signature.v - 35) / 2);\n\t    }\n\t    // We have an EIP-155 transaction (chainId was specified and non-zero)\n\t    if (chainId !== 0) {\n\t        raw.push((0, lib$1.hexlify)(chainId)); // @TODO: hexValue?\n\t        raw.push(\"0x\");\n\t        raw.push(\"0x\");\n\t    }\n\t    // Requesting an unsigned transaction\n\t    if (!signature) {\n\t        return RLP.encode(raw);\n\t    }\n\t    // The splitSignature will ensure the transaction has a recoveryParam in the\n\t    // case that the signTransaction function only adds a v.\n\t    var sig = (0, lib$1.splitSignature)(signature);\n\t    // We pushed a chainId and null r, s on for hashing only; remove those\n\t    var v = 27 + sig.recoveryParam;\n\t    if (chainId !== 0) {\n\t        raw.pop();\n\t        raw.pop();\n\t        raw.pop();\n\t        v += chainId * 2 + 8;\n\t        // If an EIP-155 v (directly or indirectly; maybe _vs) was provided, check it!\n\t        if (sig.v > 28 && sig.v !== v) {\n\t            logger.throwArgumentError(\"transaction.chainId/signature.v mismatch\", \"signature\", signature);\n\t        }\n\t    }\n\t    else if (sig.v !== v) {\n\t        logger.throwArgumentError(\"transaction.chainId/signature.v mismatch\", \"signature\", signature);\n\t    }\n\t    raw.push((0, lib$1.hexlify)(v));\n\t    raw.push((0, lib$1.stripZeros)((0, lib$1.arrayify)(sig.r)));\n\t    raw.push((0, lib$1.stripZeros)((0, lib$1.arrayify)(sig.s)));\n\t    return RLP.encode(raw);\n\t}\n\tfunction serialize(transaction, signature) {\n\t    // Legacy and EIP-155 Transactions\n\t    if (transaction.type == null || transaction.type === 0) {\n\t        if (transaction.accessList != null) {\n\t            logger.throwArgumentError(\"untyped transactions do not support accessList; include type: 1\", \"transaction\", transaction);\n\t        }\n\t        return _serialize(transaction, signature);\n\t    }\n\t    // Typed Transactions (EIP-2718)\n\t    switch (transaction.type) {\n\t        case 1:\n\t            return _serializeEip2930(transaction, signature);\n\t        case 2:\n\t            return _serializeEip1559(transaction, signature);\n\t        default:\n\t            break;\n\t    }\n\t    return logger.throwError(\"unsupported transaction type: \" + transaction.type, lib.Logger.errors.UNSUPPORTED_OPERATION, {\n\t        operation: \"serializeTransaction\",\n\t        transactionType: transaction.type\n\t    });\n\t}\n\texports.serialize = serialize;\n\tfunction _parseEipSignature(tx, fields, serialize) {\n\t    try {\n\t        var recid = handleNumber(fields[0]).toNumber();\n\t        if (recid !== 0 && recid !== 1) {\n\t            throw new Error(\"bad recid\");\n\t        }\n\t        tx.v = recid;\n\t    }\n\t    catch (error) {\n\t        logger.throwArgumentError(\"invalid v for transaction type: 1\", \"v\", fields[0]);\n\t    }\n\t    tx.r = (0, lib$1.hexZeroPad)(fields[1], 32);\n\t    tx.s = (0, lib$1.hexZeroPad)(fields[2], 32);\n\t    try {\n\t        var digest = (0, lib$4.keccak256)(serialize(tx));\n\t        tx.from = recoverAddress(digest, { r: tx.r, s: tx.s, recoveryParam: tx.v });\n\t    }\n\t    catch (error) {\n\t        console.log(error);\n\t    }\n\t}\n\tfunction _parseEip1559(payload) {\n\t    var transaction = RLP.decode(payload.slice(1));\n\t    if (transaction.length !== 9 && transaction.length !== 12) {\n\t        logger.throwArgumentError(\"invalid component count for transaction type: 2\", \"payload\", (0, lib$1.hexlify)(payload));\n\t    }\n\t    var maxPriorityFeePerGas = handleNumber(transaction[2]);\n\t    var maxFeePerGas = handleNumber(transaction[3]);\n\t    var tx = {\n\t        type: 2,\n\t        chainId: handleNumber(transaction[0]).toNumber(),\n\t        nonce: handleNumber(transaction[1]).toNumber(),\n\t        maxPriorityFeePerGas: maxPriorityFeePerGas,\n\t        maxFeePerGas: maxFeePerGas,\n\t        gasPrice: null,\n\t        gasLimit: handleNumber(transaction[4]),\n\t        to: handleAddress(transaction[5]),\n\t        value: handleNumber(transaction[6]),\n\t        data: transaction[7],\n\t        accessList: accessListify(transaction[8]),\n\t    };\n\t    // Unsigned EIP-1559 Transaction\n\t    if (transaction.length === 9) {\n\t        return tx;\n\t    }\n\t    tx.hash = (0, lib$4.keccak256)(payload);\n\t    _parseEipSignature(tx, transaction.slice(9), _serializeEip1559);\n\t    return tx;\n\t}\n\tfunction _parseEip2930(payload) {\n\t    var transaction = RLP.decode(payload.slice(1));\n\t    if (transaction.length !== 8 && transaction.length !== 11) {\n\t        logger.throwArgumentError(\"invalid component count for transaction type: 1\", \"payload\", (0, lib$1.hexlify)(payload));\n\t    }\n\t    var tx = {\n\t        type: 1,\n\t        chainId: handleNumber(transaction[0]).toNumber(),\n\t        nonce: handleNumber(transaction[1]).toNumber(),\n\t        gasPrice: handleNumber(transaction[2]),\n\t        gasLimit: handleNumber(transaction[3]),\n\t        to: handleAddress(transaction[4]),\n\t        value: handleNumber(transaction[5]),\n\t        data: transaction[6],\n\t        accessList: accessListify(transaction[7])\n\t    };\n\t    // Unsigned EIP-2930 Transaction\n\t    if (transaction.length === 8) {\n\t        return tx;\n\t    }\n\t    tx.hash = (0, lib$4.keccak256)(payload);\n\t    _parseEipSignature(tx, transaction.slice(8), _serializeEip2930);\n\t    return tx;\n\t}\n\t// Legacy Transactions and EIP-155\n\tfunction _parse(rawTransaction) {\n\t    var transaction = RLP.decode(rawTransaction);\n\t    if (transaction.length !== 9 && transaction.length !== 6) {\n\t        logger.throwArgumentError(\"invalid raw transaction\", \"rawTransaction\", rawTransaction);\n\t    }\n\t    var tx = {\n\t        nonce: handleNumber(transaction[0]).toNumber(),\n\t        gasPrice: handleNumber(transaction[1]),\n\t        gasLimit: handleNumber(transaction[2]),\n\t        to: handleAddress(transaction[3]),\n\t        value: handleNumber(transaction[4]),\n\t        data: transaction[5],\n\t        chainId: 0\n\t    };\n\t    // Legacy unsigned transaction\n\t    if (transaction.length === 6) {\n\t        return tx;\n\t    }\n\t    try {\n\t        tx.v = lib$2.BigNumber.from(transaction[6]).toNumber();\n\t    }\n\t    catch (error) {\n\t        console.log(error);\n\t        return tx;\n\t    }\n\t    tx.r = (0, lib$1.hexZeroPad)(transaction[7], 32);\n\t    tx.s = (0, lib$1.hexZeroPad)(transaction[8], 32);\n\t    if (lib$2.BigNumber.from(tx.r).isZero() && lib$2.BigNumber.from(tx.s).isZero()) {\n\t        // EIP-155 unsigned transaction\n\t        tx.chainId = tx.v;\n\t        tx.v = 0;\n\t    }\n\t    else {\n\t        // Signed Transaction\n\t        tx.chainId = Math.floor((tx.v - 35) / 2);\n\t        if (tx.chainId < 0) {\n\t            tx.chainId = 0;\n\t        }\n\t        var recoveryParam = tx.v - 27;\n\t        var raw = transaction.slice(0, 6);\n\t        if (tx.chainId !== 0) {\n\t            raw.push((0, lib$1.hexlify)(tx.chainId));\n\t            raw.push(\"0x\");\n\t            raw.push(\"0x\");\n\t            recoveryParam -= tx.chainId * 2 + 8;\n\t        }\n\t        var digest = (0, lib$4.keccak256)(RLP.encode(raw));\n\t        try {\n\t            tx.from = recoverAddress(digest, { r: (0, lib$1.hexlify)(tx.r), s: (0, lib$1.hexlify)(tx.s), recoveryParam: recoveryParam });\n\t        }\n\t        catch (error) {\n\t            console.log(error);\n\t        }\n\t        tx.hash = (0, lib$4.keccak256)(rawTransaction);\n\t    }\n\t    tx.type = null;\n\t    return tx;\n\t}\n\tfunction parse(rawTransaction) {\n\t    var payload = (0, lib$1.arrayify)(rawTransaction);\n\t    // Legacy and EIP-155 Transactions\n\t    if (payload[0] > 0x7f) {\n\t        return _parse(payload);\n\t    }\n\t    // Typed Transaction (EIP-2718)\n\t    switch (payload[0]) {\n\t        case 1:\n\t            return _parseEip2930(payload);\n\t        case 2:\n\t            return _parseEip1559(payload);\n\t        default:\n\t            break;\n\t    }\n\t    return logger.throwError(\"unsupported transaction type: \" + payload[0], lib.Logger.errors.UNSUPPORTED_OPERATION, {\n\t        operation: \"parseTransaction\",\n\t        transactionType: payload[0]\n\t    });\n\t}\n\texports.parse = parse;\n\n\t});\n\n\tvar index$e = /*@__PURE__*/getDefaultExportFromCjs(lib$e);\n\n\tvar _version$q = createCommonjsModule(function (module, exports) {\n\t\"use strict\";\n\tObject.defineProperty(exports, \"__esModule\", { value: true });\n\texports.version = void 0;\n\texports.version = \"contracts/5.5.0\";\n\n\t});\n\n\tvar _version$r = /*@__PURE__*/getDefaultExportFromCjs(_version$q);\n\n\tvar lib$f = createCommonjsModule(function (module, exports) {\n\t\"use strict\";\n\tvar __extends = (commonjsGlobal && commonjsGlobal.__extends) || (function () {\n\t    var extendStatics = function (d, b) {\n\t        extendStatics = Object.setPrototypeOf ||\n\t            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n\t            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n\t        return extendStatics(d, b);\n\t    };\n\t    return function (d, b) {\n\t        if (typeof b !== \"function\" && b !== null)\n\t            throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n\t        extendStatics(d, b);\n\t        function __() { this.constructor = d; }\n\t        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n\t    };\n\t})();\n\tvar __awaiter = (commonjsGlobal && commonjsGlobal.__awaiter) || function (thisArg, _arguments, P, generator) {\n\t    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n\t    return new (P || (P = Promise))(function (resolve, reject) {\n\t        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n\t        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n\t        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n\t        step((generator = generator.apply(thisArg, _arguments || [])).next());\n\t    });\n\t};\n\tvar __generator = (commonjsGlobal && commonjsGlobal.__generator) || function (thisArg, body) {\n\t    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\n\t    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\n\t    function verb(n) { return function (v) { return step([n, v]); }; }\n\t    function step(op) {\n\t        if (f) throw new TypeError(\"Generator is already executing.\");\n\t        while (_) try {\n\t            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n\t            if (y = 0, t) op = [op[0] & 2, t.value];\n\t            switch (op[0]) {\n\t                case 0: case 1: t = op; break;\n\t                case 4: _.label++; return { value: op[1], done: false };\n\t                case 5: _.label++; y = op[1]; op = [0]; continue;\n\t                case 7: op = _.ops.pop(); _.trys.pop(); continue;\n\t                default:\n\t                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\n\t                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\n\t                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\n\t                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\n\t                    if (t[2]) _.ops.pop();\n\t                    _.trys.pop(); continue;\n\t            }\n\t            op = body.call(thisArg, _);\n\t        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\n\t        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\n\t    }\n\t};\n\tvar __spreadArray = (commonjsGlobal && commonjsGlobal.__spreadArray) || function (to, from, pack) {\n\t    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\n\t        if (ar || !(i in from)) {\n\t            if (!ar) ar = Array.prototype.slice.call(from, 0, i);\n\t            ar[i] = from[i];\n\t        }\n\t    }\n\t    return to.concat(ar || Array.prototype.slice.call(from));\n\t};\n\tObject.defineProperty(exports, \"__esModule\", { value: true });\n\texports.ContractFactory = exports.Contract = exports.BaseContract = void 0;\n\n\n\n\n\n\n\n\n\n\n\tvar logger = new lib.Logger(_version$q.version);\n\t;\n\t;\n\t///////////////////////////////\n\tvar allowedTransactionKeys = {\n\t    chainId: true, data: true, from: true, gasLimit: true, gasPrice: true, nonce: true, to: true, value: true,\n\t    type: true, accessList: true,\n\t    maxFeePerGas: true, maxPriorityFeePerGas: true,\n\t    customData: true\n\t};\n\tfunction resolveName(resolver, nameOrPromise) {\n\t    return __awaiter(this, void 0, void 0, function () {\n\t        var name, address;\n\t        return __generator(this, function (_a) {\n\t            switch (_a.label) {\n\t                case 0: return [4 /*yield*/, nameOrPromise];\n\t                case 1:\n\t                    name = _a.sent();\n\t                    if (typeof (name) !== \"string\") {\n\t                        logger.throwArgumentError(\"invalid address or ENS name\", \"name\", name);\n\t                    }\n\t                    // If it is already an address, just use it (after adding checksum)\n\t                    try {\n\t                        return [2 /*return*/, (0, lib$6.getAddress)(name)];\n\t                    }\n\t                    catch (error) { }\n\t                    if (!resolver) {\n\t                        logger.throwError(\"a provider or signer is needed to resolve ENS names\", lib.Logger.errors.UNSUPPORTED_OPERATION, {\n\t                            operation: \"resolveName\"\n\t                        });\n\t                    }\n\t                    return [4 /*yield*/, resolver.resolveName(name)];\n\t                case 2:\n\t                    address = _a.sent();\n\t                    if (address == null) {\n\t                        logger.throwArgumentError(\"resolver or addr is not configured for ENS name\", \"name\", name);\n\t                    }\n\t                    return [2 /*return*/, address];\n\t            }\n\t        });\n\t    });\n\t}\n\t// Recursively replaces ENS names with promises to resolve the name and resolves all properties\n\tfunction resolveAddresses(resolver, value, paramType) {\n\t    return __awaiter(this, void 0, void 0, function () {\n\t        return __generator(this, function (_a) {\n\t            switch (_a.label) {\n\t                case 0:\n\t                    if (!Array.isArray(paramType)) return [3 /*break*/, 2];\n\t                    return [4 /*yield*/, Promise.all(paramType.map(function (paramType, index) {\n\t                            return resolveAddresses(resolver, ((Array.isArray(value)) ? value[index] : value[paramType.name]), paramType);\n\t                        }))];\n\t                case 1: return [2 /*return*/, _a.sent()];\n\t                case 2:\n\t                    if (!(paramType.type === \"address\")) return [3 /*break*/, 4];\n\t                    return [4 /*yield*/, resolveName(resolver, value)];\n\t                case 3: return [2 /*return*/, _a.sent()];\n\t                case 4:\n\t                    if (!(paramType.type === \"tuple\")) return [3 /*break*/, 6];\n\t                    return [4 /*yield*/, resolveAddresses(resolver, value, paramType.components)];\n\t                case 5: return [2 /*return*/, _a.sent()];\n\t                case 6:\n\t                    if (!(paramType.baseType === \"array\")) return [3 /*break*/, 8];\n\t                    if (!Array.isArray(value)) {\n\t                        return [2 /*return*/, Promise.reject(logger.makeError(\"invalid value for array\", lib.Logger.errors.INVALID_ARGUMENT, {\n\t                                argument: \"value\",\n\t                                value: value\n\t                            }))];\n\t                    }\n\t                    return [4 /*yield*/, Promise.all(value.map(function (v) { return resolveAddresses(resolver, v, paramType.arrayChildren); }))];\n\t                case 7: return [2 /*return*/, _a.sent()];\n\t                case 8: return [2 /*return*/, value];\n\t            }\n\t        });\n\t    });\n\t}\n\tfunction populateTransaction(contract, fragment, args) {\n\t    return __awaiter(this, void 0, void 0, function () {\n\t        var overrides, resolved, data, tx, ro, intrinsic, bytes, i, roValue, leftovers;\n\t        var _this = this;\n\t        return __generator(this, function (_a) {\n\t            switch (_a.label) {\n\t                case 0:\n\t                    overrides = {};\n\t                    if (args.length === fragment.inputs.length + 1 && typeof (args[args.length - 1]) === \"object\") {\n\t                        overrides = (0, lib$3.shallowCopy)(args.pop());\n\t                    }\n\t                    // Make sure the parameter count matches\n\t                    logger.checkArgumentCount(args.length, fragment.inputs.length, \"passed to contract\");\n\t                    // Populate \"from\" override (allow promises)\n\t                    if (contract.signer) {\n\t                        if (overrides.from) {\n\t                            // Contracts with a Signer are from the Signer's frame-of-reference;\n\t                            // but we allow overriding \"from\" if it matches the signer\n\t                            overrides.from = (0, lib$3.resolveProperties)({\n\t                                override: resolveName(contract.signer, overrides.from),\n\t                                signer: contract.signer.getAddress()\n\t                            }).then(function (check) { return __awaiter(_this, void 0, void 0, function () {\n\t                                return __generator(this, function (_a) {\n\t                                    if ((0, lib$6.getAddress)(check.signer) !== check.override) {\n\t                                        logger.throwError(\"Contract with a Signer cannot override from\", lib.Logger.errors.UNSUPPORTED_OPERATION, {\n\t                                            operation: \"overrides.from\"\n\t                                        });\n\t                                    }\n\t                                    return [2 /*return*/, check.override];\n\t                                });\n\t                            }); });\n\t                        }\n\t                        else {\n\t                            overrides.from = contract.signer.getAddress();\n\t                        }\n\t                    }\n\t                    else if (overrides.from) {\n\t                        overrides.from = resolveName(contract.provider, overrides.from);\n\t                        //} else {\n\t                        // Contracts without a signer can override \"from\", and if\n\t                        // unspecified the zero address is used\n\t                        //overrides.from = AddressZero;\n\t                    }\n\t                    return [4 /*yield*/, (0, lib$3.resolveProperties)({\n\t                            args: resolveAddresses(contract.signer || contract.provider, args, fragment.inputs),\n\t                            address: contract.resolvedAddress,\n\t                            overrides: ((0, lib$3.resolveProperties)(overrides) || {})\n\t                        })];\n\t                case 1:\n\t                    resolved = _a.sent();\n\t                    data = contract.interface.encodeFunctionData(fragment, resolved.args);\n\t                    tx = {\n\t                        data: data,\n\t                        to: resolved.address\n\t                    };\n\t                    ro = resolved.overrides;\n\t                    // Populate simple overrides\n\t                    if (ro.nonce != null) {\n\t                        tx.nonce = lib$2.BigNumber.from(ro.nonce).toNumber();\n\t                    }\n\t                    if (ro.gasLimit != null) {\n\t                        tx.gasLimit = lib$2.BigNumber.from(ro.gasLimit);\n\t                    }\n\t                    if (ro.gasPrice != null) {\n\t                        tx.gasPrice = lib$2.BigNumber.from(ro.gasPrice);\n\t                    }\n\t                    if (ro.maxFeePerGas != null) {\n\t                        tx.maxFeePerGas = lib$2.BigNumber.from(ro.maxFeePerGas);\n\t                    }\n\t                    if (ro.maxPriorityFeePerGas != null) {\n\t                        tx.maxPriorityFeePerGas = lib$2.BigNumber.from(ro.maxPriorityFeePerGas);\n\t                    }\n\t                    if (ro.from != null) {\n\t                        tx.from = ro.from;\n\t                    }\n\t                    if (ro.type != null) {\n\t                        tx.type = ro.type;\n\t                    }\n\t                    if (ro.accessList != null) {\n\t                        tx.accessList = (0, lib$e.accessListify)(ro.accessList);\n\t                    }\n\t                    // If there was no \"gasLimit\" override, but the ABI specifies a default, use it\n\t                    if (tx.gasLimit == null && fragment.gas != null) {\n\t                        intrinsic = 21000;\n\t                        bytes = (0, lib$1.arrayify)(data);\n\t                        for (i = 0; i < bytes.length; i++) {\n\t                            intrinsic += 4;\n\t                            if (bytes[i]) {\n\t                                intrinsic += 64;\n\t                            }\n\t                        }\n\t                        tx.gasLimit = lib$2.BigNumber.from(fragment.gas).add(intrinsic);\n\t                    }\n\t                    // Populate \"value\" override\n\t                    if (ro.value) {\n\t                        roValue = lib$2.BigNumber.from(ro.value);\n\t                        if (!roValue.isZero() && !fragment.payable) {\n\t                            logger.throwError(\"non-payable method cannot override value\", lib.Logger.errors.UNSUPPORTED_OPERATION, {\n\t                                operation: \"overrides.value\",\n\t                                value: overrides.value\n\t                            });\n\t                        }\n\t                        tx.value = roValue;\n\t                    }\n\t                    if (ro.customData) {\n\t                        tx.customData = (0, lib$3.shallowCopy)(ro.customData);\n\t                    }\n\t                    // Remove the overrides\n\t                    delete overrides.nonce;\n\t                    delete overrides.gasLimit;\n\t                    delete overrides.gasPrice;\n\t                    delete overrides.from;\n\t                    delete overrides.value;\n\t                    delete overrides.type;\n\t                    delete overrides.accessList;\n\t                    delete overrides.maxFeePerGas;\n\t                    delete overrides.maxPriorityFeePerGas;\n\t                    delete overrides.customData;\n\t                    leftovers = Object.keys(overrides).filter(function (key) { return (overrides[key] != null); });\n\t                    if (leftovers.length) {\n\t                        logger.throwError(\"cannot override \" + leftovers.map(function (l) { return JSON.stringify(l); }).join(\",\"), lib.Logger.errors.UNSUPPORTED_OPERATION, {\n\t                            operation: \"overrides\",\n\t                            overrides: leftovers\n\t                        });\n\t                    }\n\t                    return [2 /*return*/, tx];\n\t            }\n\t        });\n\t    });\n\t}\n\tfunction buildPopulate(contract, fragment) {\n\t    return function () {\n\t        var args = [];\n\t        for (var _i = 0; _i < arguments.length; _i++) {\n\t            args[_i] = arguments[_i];\n\t        }\n\t        return populateTransaction(contract, fragment, args);\n\t    };\n\t}\n\tfunction buildEstimate(contract, fragment) {\n\t    var signerOrProvider = (contract.signer || contract.provider);\n\t    return function () {\n\t        var args = [];\n\t        for (var _i = 0; _i < arguments.length; _i++) {\n\t            args[_i] = arguments[_i];\n\t        }\n\t        return __awaiter(this, void 0, void 0, function () {\n\t            var tx;\n\t            return __generator(this, function (_a) {\n\t                switch (_a.label) {\n\t                    case 0:\n\t                        if (!signerOrProvider) {\n\t                            logger.throwError(\"estimate require a provider or signer\", lib.Logger.errors.UNSUPPORTED_OPERATION, {\n\t                                operation: \"estimateGas\"\n\t                            });\n\t                        }\n\t                        return [4 /*yield*/, populateTransaction(contract, fragment, args)];\n\t                    case 1:\n\t                        tx = _a.sent();\n\t                        return [4 /*yield*/, signerOrProvider.estimateGas(tx)];\n\t                    case 2: return [2 /*return*/, _a.sent()];\n\t                }\n\t            });\n\t        });\n\t    };\n\t}\n\tfunction addContractWait(contract, tx) {\n\t    var wait = tx.wait.bind(tx);\n\t    tx.wait = function (confirmations) {\n\t        return wait(confirmations).then(function (receipt) {\n\t            receipt.events = receipt.logs.map(function (log) {\n\t                var event = (0, lib$3.deepCopy)(log);\n\t                var parsed = null;\n\t                try {\n\t                    parsed = contract.interface.parseLog(log);\n\t                }\n\t                catch (e) { }\n\t                // Successfully parsed the event log; include it\n\t                if (parsed) {\n\t                    event.args = parsed.args;\n\t                    event.decode = function (data, topics) {\n\t                        return contract.interface.decodeEventLog(parsed.eventFragment, data, topics);\n\t                    };\n\t                    event.event = parsed.name;\n\t                    event.eventSignature = parsed.signature;\n\t                }\n\t                // Useful operations\n\t                event.removeListener = function () { return contract.provider; };\n\t                event.getBlock = function () {\n\t                    return contract.provider.getBlock(receipt.blockHash);\n\t                };\n\t                event.getTransaction = function () {\n\t                    return contract.provider.getTransaction(receipt.transactionHash);\n\t                };\n\t                event.getTransactionReceipt = function () {\n\t                    return Promise.resolve(receipt);\n\t                };\n\t                return event;\n\t            });\n\t            return receipt;\n\t        });\n\t    };\n\t}\n\tfunction buildCall(contract, fragment, collapseSimple) {\n\t    var signerOrProvider = (contract.signer || contract.provider);\n\t    return function () {\n\t        var args = [];\n\t        for (var _i = 0; _i < arguments.length; _i++) {\n\t            args[_i] = arguments[_i];\n\t        }\n\t        return __awaiter(this, void 0, void 0, function () {\n\t            var blockTag, overrides, tx, result, value;\n\t            return __generator(this, function (_a) {\n\t                switch (_a.label) {\n\t                    case 0:\n\t                        blockTag = undefined;\n\t                        if (!(args.length === fragment.inputs.length + 1 && typeof (args[args.length - 1]) === \"object\")) return [3 /*break*/, 3];\n\t                        overrides = (0, lib$3.shallowCopy)(args.pop());\n\t                        if (!(overrides.blockTag != null)) return [3 /*break*/, 2];\n\t                        return [4 /*yield*/, overrides.blockTag];\n\t                    case 1:\n\t                        blockTag = _a.sent();\n\t                        _a.label = 2;\n\t                    case 2:\n\t                        delete overrides.blockTag;\n\t                        args.push(overrides);\n\t                        _a.label = 3;\n\t                    case 3:\n\t                        if (!(contract.deployTransaction != null)) return [3 /*break*/, 5];\n\t                        return [4 /*yield*/, contract._deployed(blockTag)];\n\t                    case 4:\n\t                        _a.sent();\n\t                        _a.label = 5;\n\t                    case 5: return [4 /*yield*/, populateTransaction(contract, fragment, args)];\n\t                    case 6:\n\t                        tx = _a.sent();\n\t                        return [4 /*yield*/, signerOrProvider.call(tx, blockTag)];\n\t                    case 7:\n\t                        result = _a.sent();\n\t                        try {\n\t                            value = contract.interface.decodeFunctionResult(fragment, result);\n\t                            if (collapseSimple && fragment.outputs.length === 1) {\n\t                                value = value[0];\n\t                            }\n\t                            return [2 /*return*/, value];\n\t                        }\n\t                        catch (error) {\n\t                            if (error.code === lib.Logger.errors.CALL_EXCEPTION) {\n\t                                error.address = contract.address;\n\t                                error.args = args;\n\t                                error.transaction = tx;\n\t                            }\n\t                            throw error;\n\t                        }\n\t                        return [2 /*return*/];\n\t                }\n\t            });\n\t        });\n\t    };\n\t}\n\tfunction buildSend(contract, fragment) {\n\t    return function () {\n\t        var args = [];\n\t        for (var _i = 0; _i < arguments.length; _i++) {\n\t            args[_i] = arguments[_i];\n\t        }\n\t        return __awaiter(this, void 0, void 0, function () {\n\t            var txRequest, tx;\n\t            return __generator(this, function (_a) {\n\t                switch (_a.label) {\n\t                    case 0:\n\t                        if (!contract.signer) {\n\t                            logger.throwError(\"sending a transaction requires a signer\", lib.Logger.errors.UNSUPPORTED_OPERATION, {\n\t                                operation: \"sendTransaction\"\n\t                            });\n\t                        }\n\t                        if (!(contract.deployTransaction != null)) return [3 /*break*/, 2];\n\t                        return [4 /*yield*/, contract._deployed()];\n\t                    case 1:\n\t                        _a.sent();\n\t                        _a.label = 2;\n\t                    case 2: return [4 /*yield*/, populateTransaction(contract, fragment, args)];\n\t                    case 3:\n\t                        txRequest = _a.sent();\n\t                        return [4 /*yield*/, contract.signer.sendTransaction(txRequest)];\n\t                    case 4:\n\t                        tx = _a.sent();\n\t                        // Tweak the tx.wait so the receipt has extra properties\n\t                        addContractWait(contract, tx);\n\t                        return [2 /*return*/, tx];\n\t                }\n\t            });\n\t        });\n\t    };\n\t}\n\tfunction buildDefault(contract, fragment, collapseSimple) {\n\t    if (fragment.constant) {\n\t        return buildCall(contract, fragment, collapseSimple);\n\t    }\n\t    return buildSend(contract, fragment);\n\t}\n\tfunction getEventTag(filter) {\n\t    if (filter.address && (filter.topics == null || filter.topics.length === 0)) {\n\t        return \"*\";\n\t    }\n\t    return (filter.address || \"*\") + \"@\" + (filter.topics ? filter.topics.map(function (topic) {\n\t        if (Array.isArray(topic)) {\n\t            return topic.join(\"|\");\n\t        }\n\t        return topic;\n\t    }).join(\":\") : \"\");\n\t}\n\tvar RunningEvent = /** @class */ (function () {\n\t    function RunningEvent(tag, filter) {\n\t        (0, lib$3.defineReadOnly)(this, \"tag\", tag);\n\t        (0, lib$3.defineReadOnly)(this, \"filter\", filter);\n\t        this._listeners = [];\n\t    }\n\t    RunningEvent.prototype.addListener = function (listener, once) {\n\t        this._listeners.push({ listener: listener, once: once });\n\t    };\n\t    RunningEvent.prototype.removeListener = function (listener) {\n\t        var done = false;\n\t        this._listeners = this._listeners.filter(function (item) {\n\t            if (done || item.listener !== listener) {\n\t                return true;\n\t            }\n\t            done = true;\n\t            return false;\n\t        });\n\t    };\n\t    RunningEvent.prototype.removeAllListeners = function () {\n\t        this._listeners = [];\n\t    };\n\t    RunningEvent.prototype.listeners = function () {\n\t        return this._listeners.map(function (i) { return i.listener; });\n\t    };\n\t    RunningEvent.prototype.listenerCount = function () {\n\t        return this._listeners.length;\n\t    };\n\t    RunningEvent.prototype.run = function (args) {\n\t        var _this = this;\n\t        var listenerCount = this.listenerCount();\n\t        this._listeners = this._listeners.filter(function (item) {\n\t            var argsCopy = args.slice();\n\t            // Call the callback in the next event loop\n\t            setTimeout(function () {\n\t                item.listener.apply(_this, argsCopy);\n\t            }, 0);\n\t            // Reschedule it if it not \"once\"\n\t            return !(item.once);\n\t        });\n\t        return listenerCount;\n\t    };\n\t    RunningEvent.prototype.prepareEvent = function (event) {\n\t    };\n\t    // Returns the array that will be applied to an emit\n\t    RunningEvent.prototype.getEmit = function (event) {\n\t        return [event];\n\t    };\n\t    return RunningEvent;\n\t}());\n\tvar ErrorRunningEvent = /** @class */ (function (_super) {\n\t    __extends(ErrorRunningEvent, _super);\n\t    function ErrorRunningEvent() {\n\t        return _super.call(this, \"error\", null) || this;\n\t    }\n\t    return ErrorRunningEvent;\n\t}(RunningEvent));\n\t// @TODO Fragment should inherit Wildcard? and just override getEmit?\n\t//       or have a common abstract super class, with enough constructor\n\t//       options to configure both.\n\t// A Fragment Event will populate all the properties that Wildcard\n\t// will, and additionally dereference the arguments when emitting\n\tvar FragmentRunningEvent = /** @class */ (function (_super) {\n\t    __extends(FragmentRunningEvent, _super);\n\t    function FragmentRunningEvent(address, contractInterface, fragment, topics) {\n\t        var _this = this;\n\t        var filter = {\n\t            address: address\n\t        };\n\t        var topic = contractInterface.getEventTopic(fragment);\n\t        if (topics) {\n\t            if (topic !== topics[0]) {\n\t                logger.throwArgumentError(\"topic mismatch\", \"topics\", topics);\n\t            }\n\t            filter.topics = topics.slice();\n\t        }\n\t        else {\n\t            filter.topics = [topic];\n\t        }\n\t        _this = _super.call(this, getEventTag(filter), filter) || this;\n\t        (0, lib$3.defineReadOnly)(_this, \"address\", address);\n\t        (0, lib$3.defineReadOnly)(_this, \"interface\", contractInterface);\n\t        (0, lib$3.defineReadOnly)(_this, \"fragment\", fragment);\n\t        return _this;\n\t    }\n\t    FragmentRunningEvent.prototype.prepareEvent = function (event) {\n\t        var _this = this;\n\t        _super.prototype.prepareEvent.call(this, event);\n\t        event.event = this.fragment.name;\n\t        event.eventSignature = this.fragment.format();\n\t        event.decode = function (data, topics) {\n\t            return _this.interface.decodeEventLog(_this.fragment, data, topics);\n\t        };\n\t        try {\n\t            event.args = this.interface.decodeEventLog(this.fragment, event.data, event.topics);\n\t        }\n\t        catch (error) {\n\t            event.args = null;\n\t            event.decodeError = error;\n\t        }\n\t    };\n\t    FragmentRunningEvent.prototype.getEmit = function (event) {\n\t        var errors = (0, lib$a.checkResultErrors)(event.args);\n\t        if (errors.length) {\n\t            throw errors[0].error;\n\t        }\n\t        var args = (event.args || []).slice();\n\t        args.push(event);\n\t        return args;\n\t    };\n\t    return FragmentRunningEvent;\n\t}(RunningEvent));\n\t// A Wildcard Event will attempt to populate:\n\t//  - event            The name of the event name\n\t//  - eventSignature   The full signature of the event\n\t//  - decode           A function to decode data and topics\n\t//  - args             The decoded data and topics\n\tvar WildcardRunningEvent = /** @class */ (function (_super) {\n\t    __extends(WildcardRunningEvent, _super);\n\t    function WildcardRunningEvent(address, contractInterface) {\n\t        var _this = _super.call(this, \"*\", { address: address }) || this;\n\t        (0, lib$3.defineReadOnly)(_this, \"address\", address);\n\t        (0, lib$3.defineReadOnly)(_this, \"interface\", contractInterface);\n\t        return _this;\n\t    }\n\t    WildcardRunningEvent.prototype.prepareEvent = function (event) {\n\t        var _this = this;\n\t        _super.prototype.prepareEvent.call(this, event);\n\t        try {\n\t            var parsed_1 = this.interface.parseLog(event);\n\t            event.event = parsed_1.name;\n\t            event.eventSignature = parsed_1.signature;\n\t            event.decode = function (data, topics) {\n\t                return _this.interface.decodeEventLog(parsed_1.eventFragment, data, topics);\n\t            };\n\t            event.args = parsed_1.args;\n\t        }\n\t        catch (error) {\n\t            // No matching event\n\t        }\n\t    };\n\t    return WildcardRunningEvent;\n\t}(RunningEvent));\n\tvar BaseContract = /** @class */ (function () {\n\t    function BaseContract(addressOrName, contractInterface, signerOrProvider) {\n\t        var _newTarget = this.constructor;\n\t        var _this = this;\n\t        logger.checkNew(_newTarget, Contract);\n\t        // @TODO: Maybe still check the addressOrName looks like a valid address or name?\n\t        //address = getAddress(address);\n\t        (0, lib$3.defineReadOnly)(this, \"interface\", (0, lib$3.getStatic)(_newTarget, \"getInterface\")(contractInterface));\n\t        if (signerOrProvider == null) {\n\t            (0, lib$3.defineReadOnly)(this, \"provider\", null);\n\t            (0, lib$3.defineReadOnly)(this, \"signer\", null);\n\t        }\n\t        else if (lib$c.Signer.isSigner(signerOrProvider)) {\n\t            (0, lib$3.defineReadOnly)(this, \"provider\", signerOrProvider.provider || null);\n\t            (0, lib$3.defineReadOnly)(this, \"signer\", signerOrProvider);\n\t        }\n\t        else if (lib$b.Provider.isProvider(signerOrProvider)) {\n\t            (0, lib$3.defineReadOnly)(this, \"provider\", signerOrProvider);\n\t            (0, lib$3.defineReadOnly)(this, \"signer\", null);\n\t        }\n\t        else {\n\t            logger.throwArgumentError(\"invalid signer or provider\", \"signerOrProvider\", signerOrProvider);\n\t        }\n\t        (0, lib$3.defineReadOnly)(this, \"callStatic\", {});\n\t        (0, lib$3.defineReadOnly)(this, \"estimateGas\", {});\n\t        (0, lib$3.defineReadOnly)(this, \"functions\", {});\n\t        (0, lib$3.defineReadOnly)(this, \"populateTransaction\", {});\n\t        (0, lib$3.defineReadOnly)(this, \"filters\", {});\n\t        {\n\t            var uniqueFilters_1 = {};\n\t            Object.keys(this.interface.events).forEach(function (eventSignature) {\n\t                var event = _this.interface.events[eventSignature];\n\t                (0, lib$3.defineReadOnly)(_this.filters, eventSignature, function () {\n\t                    var args = [];\n\t                    for (var _i = 0; _i < arguments.length; _i++) {\n\t                        args[_i] = arguments[_i];\n\t                    }\n\t                    return {\n\t                        address: _this.address,\n\t                        topics: _this.interface.encodeFilterTopics(event, args)\n\t                    };\n\t                });\n\t                if (!uniqueFilters_1[event.name]) {\n\t                    uniqueFilters_1[event.name] = [];\n\t                }\n\t                uniqueFilters_1[event.name].push(eventSignature);\n\t            });\n\t            Object.keys(uniqueFilters_1).forEach(function (name) {\n\t                var filters = uniqueFilters_1[name];\n\t                if (filters.length === 1) {\n\t                    (0, lib$3.defineReadOnly)(_this.filters, name, _this.filters[filters[0]]);\n\t                }\n\t                else {\n\t                    logger.warn(\"Duplicate definition of \" + name + \" (\" + filters.join(\", \") + \")\");\n\t                }\n\t            });\n\t        }\n\t        (0, lib$3.defineReadOnly)(this, \"_runningEvents\", {});\n\t        (0, lib$3.defineReadOnly)(this, \"_wrappedEmits\", {});\n\t        if (addressOrName == null) {\n\t            logger.throwArgumentError(\"invalid contract address or ENS name\", \"addressOrName\", addressOrName);\n\t        }\n\t        (0, lib$3.defineReadOnly)(this, \"address\", addressOrName);\n\t        if (this.provider) {\n\t            (0, lib$3.defineReadOnly)(this, \"resolvedAddress\", resolveName(this.provider, addressOrName));\n\t        }\n\t        else {\n\t            try {\n\t                (0, lib$3.defineReadOnly)(this, \"resolvedAddress\", Promise.resolve((0, lib$6.getAddress)(addressOrName)));\n\t            }\n\t            catch (error) {\n\t                // Without a provider, we cannot use ENS names\n\t                logger.throwError(\"provider is required to use ENS name as contract address\", lib.Logger.errors.UNSUPPORTED_OPERATION, {\n\t                    operation: \"new Contract\"\n\t                });\n\t            }\n\t        }\n\t        var uniqueNames = {};\n\t        var uniqueSignatures = {};\n\t        Object.keys(this.interface.functions).forEach(function (signature) {\n\t            var fragment = _this.interface.functions[signature];\n\t            // Check that the signature is unique; if not the ABI generation has\n\t            // not been cleaned or may be incorrectly generated\n\t            if (uniqueSignatures[signature]) {\n\t                logger.warn(\"Duplicate ABI entry for \" + JSON.stringify(signature));\n\t                return;\n\t            }\n\t            uniqueSignatures[signature] = true;\n\t            // Track unique names; we only expose bare named functions if they\n\t            // are ambiguous\n\t            {\n\t                var name_1 = fragment.name;\n\t                if (!uniqueNames[\"%\" + name_1]) {\n\t                    uniqueNames[\"%\" + name_1] = [];\n\t                }\n\t                uniqueNames[\"%\" + name_1].push(signature);\n\t            }\n\t            if (_this[signature] == null) {\n\t                (0, lib$3.defineReadOnly)(_this, signature, buildDefault(_this, fragment, true));\n\t            }\n\t            // We do not collapse simple calls on this bucket, which allows\n\t            // frameworks to safely use this without introspection as well as\n\t            // allows decoding error recovery.\n\t            if (_this.functions[signature] == null) {\n\t                (0, lib$3.defineReadOnly)(_this.functions, signature, buildDefault(_this, fragment, false));\n\t            }\n\t            if (_this.callStatic[signature] == null) {\n\t                (0, lib$3.defineReadOnly)(_this.callStatic, signature, buildCall(_this, fragment, true));\n\t            }\n\t            if (_this.populateTransaction[signature] == null) {\n\t                (0, lib$3.defineReadOnly)(_this.populateTransaction, signature, buildPopulate(_this, fragment));\n\t            }\n\t            if (_this.estimateGas[signature] == null) {\n\t                (0, lib$3.defineReadOnly)(_this.estimateGas, signature, buildEstimate(_this, fragment));\n\t            }\n\t        });\n\t        Object.keys(uniqueNames).forEach(function (name) {\n\t            // Ambiguous names to not get attached as bare names\n\t            var signatures = uniqueNames[name];\n\t            if (signatures.length > 1) {\n\t                return;\n\t            }\n\t            // Strip off the leading \"%\" used for prototype protection\n\t            name = name.substring(1);\n\t            var signature = signatures[0];\n\t            // If overwriting a member property that is null, swallow the error\n\t            try {\n\t                if (_this[name] == null) {\n\t                    (0, lib$3.defineReadOnly)(_this, name, _this[signature]);\n\t                }\n\t            }\n\t            catch (e) { }\n\t            if (_this.functions[name] == null) {\n\t                (0, lib$3.defineReadOnly)(_this.functions, name, _this.functions[signature]);\n\t            }\n\t            if (_this.callStatic[name] == null) {\n\t                (0, lib$3.defineReadOnly)(_this.callStatic, name, _this.callStatic[signature]);\n\t            }\n\t            if (_this.populateTransaction[name] == null) {\n\t                (0, lib$3.defineReadOnly)(_this.populateTransaction, name, _this.populateTransaction[signature]);\n\t            }\n\t            if (_this.estimateGas[name] == null) {\n\t                (0, lib$3.defineReadOnly)(_this.estimateGas, name, _this.estimateGas[signature]);\n\t            }\n\t        });\n\t    }\n\t    BaseContract.getContractAddress = function (transaction) {\n\t        return (0, lib$6.getContractAddress)(transaction);\n\t    };\n\t    BaseContract.getInterface = function (contractInterface) {\n\t        if (lib$a.Interface.isInterface(contractInterface)) {\n\t            return contractInterface;\n\t        }\n\t        return new lib$a.Interface(contractInterface);\n\t    };\n\t    // @TODO: Allow timeout?\n\t    BaseContract.prototype.deployed = function () {\n\t        return this._deployed();\n\t    };\n\t    BaseContract.prototype._deployed = function (blockTag) {\n\t        var _this = this;\n\t        if (!this._deployedPromise) {\n\t            // If we were just deployed, we know the transaction we should occur in\n\t            if (this.deployTransaction) {\n\t                this._deployedPromise = this.deployTransaction.wait().then(function () {\n\t                    return _this;\n\t                });\n\t            }\n\t            else {\n\t                // @TODO: Once we allow a timeout to be passed in, we will wait\n\t                // up to that many blocks for getCode\n\t                // Otherwise, poll for our code to be deployed\n\t                this._deployedPromise = this.provider.getCode(this.address, blockTag).then(function (code) {\n\t                    if (code === \"0x\") {\n\t                        logger.throwError(\"contract not deployed\", lib.Logger.errors.UNSUPPORTED_OPERATION, {\n\t                            contractAddress: _this.address,\n\t                            operation: \"getDeployed\"\n\t                        });\n\t                    }\n\t                    return _this;\n\t                });\n\t            }\n\t        }\n\t        return this._deployedPromise;\n\t    };\n\t    // @TODO:\n\t    // estimateFallback(overrides?: TransactionRequest): Promise<BigNumber>\n\t    // @TODO:\n\t    // estimateDeploy(bytecode: string, ...args): Promise<BigNumber>\n\t    BaseContract.prototype.fallback = function (overrides) {\n\t        var _this = this;\n\t        if (!this.signer) {\n\t            logger.throwError(\"sending a transactions require a signer\", lib.Logger.errors.UNSUPPORTED_OPERATION, { operation: \"sendTransaction(fallback)\" });\n\t        }\n\t        var tx = (0, lib$3.shallowCopy)(overrides || {});\n\t        [\"from\", \"to\"].forEach(function (key) {\n\t            if (tx[key] == null) {\n\t                return;\n\t            }\n\t            logger.throwError(\"cannot override \" + key, lib.Logger.errors.UNSUPPORTED_OPERATION, { operation: key });\n\t        });\n\t        tx.to = this.resolvedAddress;\n\t        return this.deployed().then(function () {\n\t            return _this.signer.sendTransaction(tx);\n\t        });\n\t    };\n\t    // Reconnect to a different signer or provider\n\t    BaseContract.prototype.connect = function (signerOrProvider) {\n\t        if (typeof (signerOrProvider) === \"string\") {\n\t            signerOrProvider = new lib$c.VoidSigner(signerOrProvider, this.provider);\n\t        }\n\t        var contract = new (this.constructor)(this.address, this.interface, signerOrProvider);\n\t        if (this.deployTransaction) {\n\t            (0, lib$3.defineReadOnly)(contract, \"deployTransaction\", this.deployTransaction);\n\t        }\n\t        return contract;\n\t    };\n\t    // Re-attach to a different on-chain instance of this contract\n\t    BaseContract.prototype.attach = function (addressOrName) {\n\t        return new (this.constructor)(addressOrName, this.interface, this.signer || this.provider);\n\t    };\n\t    BaseContract.isIndexed = function (value) {\n\t        return lib$a.Indexed.isIndexed(value);\n\t    };\n\t    BaseContract.prototype._normalizeRunningEvent = function (runningEvent) {\n\t        // Already have an instance of this event running; we can re-use it\n\t        if (this._runningEvents[runningEvent.tag]) {\n\t            return this._runningEvents[runningEvent.tag];\n\t        }\n\t        return runningEvent;\n\t    };\n\t    BaseContract.prototype._getRunningEvent = function (eventName) {\n\t        if (typeof (eventName) === \"string\") {\n\t            // Listen for \"error\" events (if your contract has an error event, include\n\t            // the full signature to bypass this special event keyword)\n\t            if (eventName === \"error\") {\n\t                return this._normalizeRunningEvent(new ErrorRunningEvent());\n\t            }\n\t            // Listen for any event that is registered\n\t            if (eventName === \"event\") {\n\t                return this._normalizeRunningEvent(new RunningEvent(\"event\", null));\n\t            }\n\t            // Listen for any event\n\t            if (eventName === \"*\") {\n\t                return this._normalizeRunningEvent(new WildcardRunningEvent(this.address, this.interface));\n\t            }\n\t            // Get the event Fragment (throws if ambiguous/unknown event)\n\t            var fragment = this.interface.getEvent(eventName);\n\t            return this._normalizeRunningEvent(new FragmentRunningEvent(this.address, this.interface, fragment));\n\t        }\n\t        // We have topics to filter by...\n\t        if (eventName.topics && eventName.topics.length > 0) {\n\t            // Is it a known topichash? (throws if no matching topichash)\n\t            try {\n\t                var topic = eventName.topics[0];\n\t                if (typeof (topic) !== \"string\") {\n\t                    throw new Error(\"invalid topic\"); // @TODO: May happen for anonymous events\n\t                }\n\t                var fragment = this.interface.getEvent(topic);\n\t                return this._normalizeRunningEvent(new FragmentRunningEvent(this.address, this.interface, fragment, eventName.topics));\n\t            }\n\t            catch (error) { }\n\t            // Filter by the unknown topichash\n\t            var filter = {\n\t                address: this.address,\n\t                topics: eventName.topics\n\t            };\n\t            return this._normalizeRunningEvent(new RunningEvent(getEventTag(filter), filter));\n\t        }\n\t        return this._normalizeRunningEvent(new WildcardRunningEvent(this.address, this.interface));\n\t    };\n\t    BaseContract.prototype._checkRunningEvents = function (runningEvent) {\n\t        if (runningEvent.listenerCount() === 0) {\n\t            delete this._runningEvents[runningEvent.tag];\n\t            // If we have a poller for this, remove it\n\t            var emit = this._wrappedEmits[runningEvent.tag];\n\t            if (emit && runningEvent.filter) {\n\t                this.provider.off(runningEvent.filter, emit);\n\t                delete this._wrappedEmits[runningEvent.tag];\n\t            }\n\t        }\n\t    };\n\t    // Subclasses can override this to gracefully recover\n\t    // from parse errors if they wish\n\t    BaseContract.prototype._wrapEvent = function (runningEvent, log, listener) {\n\t        var _this = this;\n\t        var event = (0, lib$3.deepCopy)(log);\n\t        event.removeListener = function () {\n\t            if (!listener) {\n\t                return;\n\t            }\n\t            runningEvent.removeListener(listener);\n\t            _this._checkRunningEvents(runningEvent);\n\t        };\n\t        event.getBlock = function () { return _this.provider.getBlock(log.blockHash); };\n\t        event.getTransaction = function () { return _this.provider.getTransaction(log.transactionHash); };\n\t        event.getTransactionReceipt = function () { return _this.provider.getTransactionReceipt(log.transactionHash); };\n\t        // This may throw if the topics and data mismatch the signature\n\t        runningEvent.prepareEvent(event);\n\t        return event;\n\t    };\n\t    BaseContract.prototype._addEventListener = function (runningEvent, listener, once) {\n\t        var _this = this;\n\t        if (!this.provider) {\n\t            logger.throwError(\"events require a provider or a signer with a provider\", lib.Logger.errors.UNSUPPORTED_OPERATION, { operation: \"once\" });\n\t        }\n\t        runningEvent.addListener(listener, once);\n\t        // Track this running event and its listeners (may already be there; but no hard in updating)\n\t        this._runningEvents[runningEvent.tag] = runningEvent;\n\t        // If we are not polling the provider, start polling\n\t        if (!this._wrappedEmits[runningEvent.tag]) {\n\t            var wrappedEmit = function (log) {\n\t                var event = _this._wrapEvent(runningEvent, log, listener);\n\t                // Try to emit the result for the parameterized event...\n\t                if (event.decodeError == null) {\n\t                    try {\n\t                        var args = runningEvent.getEmit(event);\n\t                        _this.emit.apply(_this, __spreadArray([runningEvent.filter], args, false));\n\t                    }\n\t                    catch (error) {\n\t                        event.decodeError = error.error;\n\t                    }\n\t                }\n\t                // Always emit \"event\" for fragment-base events\n\t                if (runningEvent.filter != null) {\n\t                    _this.emit(\"event\", event);\n\t                }\n\t                // Emit \"error\" if there was an error\n\t                if (event.decodeError != null) {\n\t                    _this.emit(\"error\", event.decodeError, event);\n\t                }\n\t            };\n\t            this._wrappedEmits[runningEvent.tag] = wrappedEmit;\n\t            // Special events, like \"error\" do not have a filter\n\t            if (runningEvent.filter != null) {\n\t                this.provider.on(runningEvent.filter, wrappedEmit);\n\t            }\n\t        }\n\t    };\n\t    BaseContract.prototype.queryFilter = function (event, fromBlockOrBlockhash, toBlock) {\n\t        var _this = this;\n\t        var runningEvent = this._getRunningEvent(event);\n\t        var filter = (0, lib$3.shallowCopy)(runningEvent.filter);\n\t        if (typeof (fromBlockOrBlockhash) === \"string\" && (0, lib$1.isHexString)(fromBlockOrBlockhash, 32)) {\n\t            if (toBlock != null) {\n\t                logger.throwArgumentError(\"cannot specify toBlock with blockhash\", \"toBlock\", toBlock);\n\t            }\n\t            filter.blockHash = fromBlockOrBlockhash;\n\t        }\n\t        else {\n\t            filter.fromBlock = ((fromBlockOrBlockhash != null) ? fromBlockOrBlockhash : 0);\n\t            filter.toBlock = ((toBlock != null) ? toBlock : \"latest\");\n\t        }\n\t        return this.provider.getLogs(filter).then(function (logs) {\n\t            return logs.map(function (log) { return _this._wrapEvent(runningEvent, log, null); });\n\t        });\n\t    };\n\t    BaseContract.prototype.on = function (event, listener) {\n\t        this._addEventListener(this._getRunningEvent(event), listener, false);\n\t        return this;\n\t    };\n\t    BaseContract.prototype.once = function (event, listener) {\n\t        this._addEventListener(this._getRunningEvent(event), listener, true);\n\t        return this;\n\t    };\n\t    BaseContract.prototype.emit = function (eventName) {\n\t        var args = [];\n\t        for (var _i = 1; _i < arguments.length; _i++) {\n\t            args[_i - 1] = arguments[_i];\n\t        }\n\t        if (!this.provider) {\n\t            return false;\n\t        }\n\t        var runningEvent = this._getRunningEvent(eventName);\n\t        var result = (runningEvent.run(args) > 0);\n\t        // May have drained all the \"once\" events; check for living events\n\t        this._checkRunningEvents(runningEvent);\n\t        return result;\n\t    };\n\t    BaseContract.prototype.listenerCount = function (eventName) {\n\t        var _this = this;\n\t        if (!this.provider) {\n\t            return 0;\n\t        }\n\t        if (eventName == null) {\n\t            return Object.keys(this._runningEvents).reduce(function (accum, key) {\n\t                return accum + _this._runningEvents[key].listenerCount();\n\t            }, 0);\n\t        }\n\t        return this._getRunningEvent(eventName).listenerCount();\n\t    };\n\t    BaseContract.prototype.listeners = function (eventName) {\n\t        if (!this.provider) {\n\t            return [];\n\t        }\n\t        if (eventName == null) {\n\t            var result_1 = [];\n\t            for (var tag in this._runningEvents) {\n\t                this._runningEvents[tag].listeners().forEach(function (listener) {\n\t                    result_1.push(listener);\n\t                });\n\t            }\n\t            return result_1;\n\t        }\n\t        return this._getRunningEvent(eventName).listeners();\n\t    };\n\t    BaseContract.prototype.removeAllListeners = function (eventName) {\n\t        if (!this.provider) {\n\t            return this;\n\t        }\n\t        if (eventName == null) {\n\t            for (var tag in this._runningEvents) {\n\t                var runningEvent_1 = this._runningEvents[tag];\n\t                runningEvent_1.removeAllListeners();\n\t                this._checkRunningEvents(runningEvent_1);\n\t            }\n\t            return this;\n\t        }\n\t        // Delete any listeners\n\t        var runningEvent = this._getRunningEvent(eventName);\n\t        runningEvent.removeAllListeners();\n\t        this._checkRunningEvents(runningEvent);\n\t        return this;\n\t    };\n\t    BaseContract.prototype.off = function (eventName, listener) {\n\t        if (!this.provider) {\n\t            return this;\n\t        }\n\t        var runningEvent = this._getRunningEvent(eventName);\n\t        runningEvent.removeListener(listener);\n\t        this._checkRunningEvents(runningEvent);\n\t        return this;\n\t    };\n\t    BaseContract.prototype.removeListener = function (eventName, listener) {\n\t        return this.off(eventName, listener);\n\t    };\n\t    return BaseContract;\n\t}());\n\texports.BaseContract = BaseContract;\n\tvar Contract = /** @class */ (function (_super) {\n\t    __extends(Contract, _super);\n\t    function Contract() {\n\t        return _super !== null && _super.apply(this, arguments) || this;\n\t    }\n\t    return Contract;\n\t}(BaseContract));\n\texports.Contract = Contract;\n\tvar ContractFactory = /** @class */ (function () {\n\t    function ContractFactory(contractInterface, bytecode, signer) {\n\t        var _newTarget = this.constructor;\n\t        var bytecodeHex = null;\n\t        if (typeof (bytecode) === \"string\") {\n\t            bytecodeHex = bytecode;\n\t        }\n\t        else if ((0, lib$1.isBytes)(bytecode)) {\n\t            bytecodeHex = (0, lib$1.hexlify)(bytecode);\n\t        }\n\t        else if (bytecode && typeof (bytecode.object) === \"string\") {\n\t            // Allow the bytecode object from the Solidity compiler\n\t            bytecodeHex = bytecode.object;\n\t        }\n\t        else {\n\t            // Crash in the next verification step\n\t            bytecodeHex = \"!\";\n\t        }\n\t        // Make sure it is 0x prefixed\n\t        if (bytecodeHex.substring(0, 2) !== \"0x\") {\n\t            bytecodeHex = \"0x\" + bytecodeHex;\n\t        }\n\t        // Make sure the final result is valid bytecode\n\t        if (!(0, lib$1.isHexString)(bytecodeHex) || (bytecodeHex.length % 2)) {\n\t            logger.throwArgumentError(\"invalid bytecode\", \"bytecode\", bytecode);\n\t        }\n\t        // If we have a signer, make sure it is valid\n\t        if (signer && !lib$c.Signer.isSigner(signer)) {\n\t            logger.throwArgumentError(\"invalid signer\", \"signer\", signer);\n\t        }\n\t        (0, lib$3.defineReadOnly)(this, \"bytecode\", bytecodeHex);\n\t        (0, lib$3.defineReadOnly)(this, \"interface\", (0, lib$3.getStatic)(_newTarget, \"getInterface\")(contractInterface));\n\t        (0, lib$3.defineReadOnly)(this, \"signer\", signer || null);\n\t    }\n\t    // @TODO: Future; rename to populateTransaction?\n\t    ContractFactory.prototype.getDeployTransaction = function () {\n\t        var args = [];\n\t        for (var _i = 0; _i < arguments.length; _i++) {\n\t            args[_i] = arguments[_i];\n\t        }\n\t        var tx = {};\n\t        // If we have 1 additional argument, we allow transaction overrides\n\t        if (args.length === this.interface.deploy.inputs.length + 1 && typeof (args[args.length - 1]) === \"object\") {\n\t            tx = (0, lib$3.shallowCopy)(args.pop());\n\t            for (var key in tx) {\n\t                if (!allowedTransactionKeys[key]) {\n\t                    throw new Error(\"unknown transaction override \" + key);\n\t                }\n\t            }\n\t        }\n\t        // Do not allow these to be overridden in a deployment transaction\n\t        [\"data\", \"from\", \"to\"].forEach(function (key) {\n\t            if (tx[key] == null) {\n\t                return;\n\t            }\n\t            logger.throwError(\"cannot override \" + key, lib.Logger.errors.UNSUPPORTED_OPERATION, { operation: key });\n\t        });\n\t        if (tx.value) {\n\t            var value = lib$2.BigNumber.from(tx.value);\n\t            if (!value.isZero() && !this.interface.deploy.payable) {\n\t                logger.throwError(\"non-payable constructor cannot override value\", lib.Logger.errors.UNSUPPORTED_OPERATION, {\n\t                    operation: \"overrides.value\",\n\t                    value: tx.value\n\t                });\n\t            }\n\t        }\n\t        // Make sure the call matches the constructor signature\n\t        logger.checkArgumentCount(args.length, this.interface.deploy.inputs.length, \" in Contract constructor\");\n\t        // Set the data to the bytecode + the encoded constructor arguments\n\t        tx.data = (0, lib$1.hexlify)((0, lib$1.concat)([\n\t            this.bytecode,\n\t            this.interface.encodeDeploy(args)\n\t        ]));\n\t        return tx;\n\t    };\n\t    ContractFactory.prototype.deploy = function () {\n\t        var args = [];\n\t        for (var _i = 0; _i < arguments.length; _i++) {\n\t            args[_i] = arguments[_i];\n\t        }\n\t        return __awaiter(this, void 0, void 0, function () {\n\t            var overrides, params, unsignedTx, tx, address, contract;\n\t            return __generator(this, function (_a) {\n\t                switch (_a.label) {\n\t                    case 0:\n\t                        overrides = {};\n\t                        // If 1 extra parameter was passed in, it contains overrides\n\t                        if (args.length === this.interface.deploy.inputs.length + 1) {\n\t                            overrides = args.pop();\n\t                        }\n\t                        // Make sure the call matches the constructor signature\n\t                        logger.checkArgumentCount(args.length, this.interface.deploy.inputs.length, \" in Contract constructor\");\n\t                        return [4 /*yield*/, resolveAddresses(this.signer, args, this.interface.deploy.inputs)];\n\t                    case 1:\n\t                        params = _a.sent();\n\t                        params.push(overrides);\n\t                        unsignedTx = this.getDeployTransaction.apply(this, params);\n\t                        return [4 /*yield*/, this.signer.sendTransaction(unsignedTx)];\n\t                    case 2:\n\t                        tx = _a.sent();\n\t                        address = (0, lib$3.getStatic)(this.constructor, \"getContractAddress\")(tx);\n\t                        contract = (0, lib$3.getStatic)(this.constructor, \"getContract\")(address, this.interface, this.signer);\n\t                        // Add the modified wait that wraps events\n\t                        addContractWait(contract, tx);\n\t                        (0, lib$3.defineReadOnly)(contract, \"deployTransaction\", tx);\n\t                        return [2 /*return*/, contract];\n\t                }\n\t            });\n\t        });\n\t    };\n\t    ContractFactory.prototype.attach = function (address) {\n\t        return (this.constructor).getContract(address, this.interface, this.signer);\n\t    };\n\t    ContractFactory.prototype.connect = function (signer) {\n\t        return new (this.constructor)(this.interface, this.bytecode, signer);\n\t    };\n\t    ContractFactory.fromSolidity = function (compilerOutput, signer) {\n\t        if (compilerOutput == null) {\n\t            logger.throwError(\"missing compiler output\", lib.Logger.errors.MISSING_ARGUMENT, { argument: \"compilerOutput\" });\n\t        }\n\t        if (typeof (compilerOutput) === \"string\") {\n\t            compilerOutput = JSON.parse(compilerOutput);\n\t        }\n\t        var abi = compilerOutput.abi;\n\t        var bytecode = null;\n\t        if (compilerOutput.bytecode) {\n\t            bytecode = compilerOutput.bytecode;\n\t        }\n\t        else if (compilerOutput.evm && compilerOutput.evm.bytecode) {\n\t            bytecode = compilerOutput.evm.bytecode;\n\t        }\n\t        return new this(abi, bytecode, signer);\n\t    };\n\t    ContractFactory.getInterface = function (contractInterface) {\n\t        return Contract.getInterface(contractInterface);\n\t    };\n\t    ContractFactory.getContractAddress = function (tx) {\n\t        return (0, lib$6.getContractAddress)(tx);\n\t    };\n\t    ContractFactory.getContract = function (address, contractInterface, signer) {\n\t        return new Contract(address, contractInterface, signer);\n\t    };\n\t    return ContractFactory;\n\t}());\n\texports.ContractFactory = ContractFactory;\n\n\t});\n\n\tvar index$f = /*@__PURE__*/getDefaultExportFromCjs(lib$f);\n\n\tvar lib$g = createCommonjsModule(function (module, exports) {\n\t\"use strict\";\n\t/**\n\t * var basex = require(\"base-x\");\n\t *\n\t * This implementation is heavily based on base-x. The main reason to\n\t * deviate was to prevent the dependency of Buffer.\n\t *\n\t * Contributors:\n\t *\n\t * base-x encoding\n\t * Forked from https://github.com/cryptocoinjs/bs58\n\t * Originally written by Mike Hearn for BitcoinJ\n\t * Copyright (c) 2011 Google Inc\n\t * Ported to JavaScript by Stefan Thomas\n\t * Merged Buffer refactorings from base58-native by Stephen Pair\n\t * Copyright (c) 2013 BitPay Inc\n\t *\n\t * The MIT License (MIT)\n\t *\n\t * Copyright base-x contributors (c) 2016\n\t *\n\t * Permission is hereby granted, free of charge, to any person obtaining a\n\t * copy of this software and associated documentation files (the \"Software\"),\n\t * to deal in the Software without restriction, including without limitation\n\t * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n\t * and/or sell copies of the Software, and to permit persons to whom the\n\t * Software is furnished to do so, subject to the following conditions:\n\t *\n\t * The above copyright notice and this permission notice shall be included in\n\t * all copies or substantial portions of the Software.\n\n\t * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n\t * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n\t * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n\t * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n\t * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n\t * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS\n\t * IN THE SOFTWARE.\n\t *\n\t */\n\tObject.defineProperty(exports, \"__esModule\", { value: true });\n\texports.Base58 = exports.Base32 = exports.BaseX = void 0;\n\n\n\tvar BaseX = /** @class */ (function () {\n\t    function BaseX(alphabet) {\n\t        (0, lib$3.defineReadOnly)(this, \"alphabet\", alphabet);\n\t        (0, lib$3.defineReadOnly)(this, \"base\", alphabet.length);\n\t        (0, lib$3.defineReadOnly)(this, \"_alphabetMap\", {});\n\t        (0, lib$3.defineReadOnly)(this, \"_leader\", alphabet.charAt(0));\n\t        // pre-compute lookup table\n\t        for (var i = 0; i < alphabet.length; i++) {\n\t            this._alphabetMap[alphabet.charAt(i)] = i;\n\t        }\n\t    }\n\t    BaseX.prototype.encode = function (value) {\n\t        var source = (0, lib$1.arrayify)(value);\n\t        if (source.length === 0) {\n\t            return \"\";\n\t        }\n\t        var digits = [0];\n\t        for (var i = 0; i < source.length; ++i) {\n\t            var carry = source[i];\n\t            for (var j = 0; j < digits.length; ++j) {\n\t                carry += digits[j] << 8;\n\t                digits[j] = carry % this.base;\n\t                carry = (carry / this.base) | 0;\n\t            }\n\t            while (carry > 0) {\n\t                digits.push(carry % this.base);\n\t                carry = (carry / this.base) | 0;\n\t            }\n\t        }\n\t        var string = \"\";\n\t        // deal with leading zeros\n\t        for (var k = 0; source[k] === 0 && k < source.length - 1; ++k) {\n\t            string += this._leader;\n\t        }\n\t        // convert digits to a string\n\t        for (var q = digits.length - 1; q >= 0; --q) {\n\t            string += this.alphabet[digits[q]];\n\t        }\n\t        return string;\n\t    };\n\t    BaseX.prototype.decode = function (value) {\n\t        if (typeof (value) !== \"string\") {\n\t            throw new TypeError(\"Expected String\");\n\t        }\n\t        var bytes = [];\n\t        if (value.length === 0) {\n\t            return new Uint8Array(bytes);\n\t        }\n\t        bytes.push(0);\n\t        for (var i = 0; i < value.length; i++) {\n\t            var byte = this._alphabetMap[value[i]];\n\t            if (byte === undefined) {\n\t                throw new Error(\"Non-base\" + this.base + \" character\");\n\t            }\n\t            var carry = byte;\n\t            for (var j = 0; j < bytes.length; ++j) {\n\t                carry += bytes[j] * this.base;\n\t                bytes[j] = carry & 0xff;\n\t                carry >>= 8;\n\t            }\n\t            while (carry > 0) {\n\t                bytes.push(carry & 0xff);\n\t                carry >>= 8;\n\t            }\n\t        }\n\t        // deal with leading zeros\n\t        for (var k = 0; value[k] === this._leader && k < value.length - 1; ++k) {\n\t            bytes.push(0);\n\t        }\n\t        return (0, lib$1.arrayify)(new Uint8Array(bytes.reverse()));\n\t    };\n\t    return BaseX;\n\t}());\n\texports.BaseX = BaseX;\n\tvar Base32 = new BaseX(\"abcdefghijklmnopqrstuvwxyz234567\");\n\texports.Base32 = Base32;\n\tvar Base58 = new BaseX(\"123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz\");\n\texports.Base58 = Base58;\n\t//console.log(Base58.decode(\"Qmd2V777o5XvJbYMeMb8k2nU5f8d3ciUQ5YpYuWhzv8iDj\"))\n\t//console.log(Base58.encode(Base58.decode(\"Qmd2V777o5XvJbYMeMb8k2nU5f8d3ciUQ5YpYuWhzv8iDj\")))\n\n\t});\n\n\tvar index$g = /*@__PURE__*/getDefaultExportFromCjs(lib$g);\n\n\tvar types = createCommonjsModule(function (module, exports) {\n\t\"use strict\";\n\tObject.defineProperty(exports, \"__esModule\", { value: true });\n\texports.SupportedAlgorithm = void 0;\n\tvar SupportedAlgorithm;\n\t(function (SupportedAlgorithm) {\n\t    SupportedAlgorithm[\"sha256\"] = \"sha256\";\n\t    SupportedAlgorithm[\"sha512\"] = \"sha512\";\n\t})(SupportedAlgorithm = exports.SupportedAlgorithm || (exports.SupportedAlgorithm = {}));\n\t;\n\n\t});\n\n\tvar types$1 = /*@__PURE__*/getDefaultExportFromCjs(types);\n\n\tvar _version$s = createCommonjsModule(function (module, exports) {\n\t\"use strict\";\n\tObject.defineProperty(exports, \"__esModule\", { value: true });\n\texports.version = void 0;\n\texports.version = \"sha2/5.5.0\";\n\n\t});\n\n\tvar _version$t = /*@__PURE__*/getDefaultExportFromCjs(_version$s);\n\n\tvar browserSha2 = createCommonjsModule(function (module, exports) {\n\t\"use strict\";\n\tvar __importDefault = (commonjsGlobal && commonjsGlobal.__importDefault) || function (mod) {\n\t    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n\t};\n\tObject.defineProperty(exports, \"__esModule\", { value: true });\n\texports.computeHmac = exports.sha512 = exports.sha256 = exports.ripemd160 = void 0;\n\tvar hash_js_1 = __importDefault(hash_1);\n\t//const _ripemd160 = _hash.ripemd160;\n\n\n\n\n\tvar logger = new lib.Logger(_version$s.version);\n\tfunction ripemd160(data) {\n\t    return \"0x\" + (hash_js_1.default.ripemd160().update((0, lib$1.arrayify)(data)).digest(\"hex\"));\n\t}\n\texports.ripemd160 = ripemd160;\n\tfunction sha256(data) {\n\t    return \"0x\" + (hash_js_1.default.sha256().update((0, lib$1.arrayify)(data)).digest(\"hex\"));\n\t}\n\texports.sha256 = sha256;\n\tfunction sha512(data) {\n\t    return \"0x\" + (hash_js_1.default.sha512().update((0, lib$1.arrayify)(data)).digest(\"hex\"));\n\t}\n\texports.sha512 = sha512;\n\tfunction computeHmac(algorithm, key, data) {\n\t    if (!types.SupportedAlgorithm[algorithm]) {\n\t        logger.throwError(\"unsupported algorithm \" + algorithm, lib.Logger.errors.UNSUPPORTED_OPERATION, {\n\t            operation: \"hmac\",\n\t            algorithm: algorithm\n\t        });\n\t    }\n\t    return \"0x\" + hash_js_1.default.hmac(hash_js_1.default[algorithm], (0, lib$1.arrayify)(key)).update((0, lib$1.arrayify)(data)).digest(\"hex\");\n\t}\n\texports.computeHmac = computeHmac;\n\n\t});\n\n\tvar browserSha2$1 = /*@__PURE__*/getDefaultExportFromCjs(browserSha2);\n\n\tvar lib$h = createCommonjsModule(function (module, exports) {\n\t\"use strict\";\n\tObject.defineProperty(exports, \"__esModule\", { value: true });\n\texports.SupportedAlgorithm = exports.sha512 = exports.sha256 = exports.ripemd160 = exports.computeHmac = void 0;\n\n\tObject.defineProperty(exports, \"computeHmac\", { enumerable: true, get: function () { return browserSha2.computeHmac; } });\n\tObject.defineProperty(exports, \"ripemd160\", { enumerable: true, get: function () { return browserSha2.ripemd160; } });\n\tObject.defineProperty(exports, \"sha256\", { enumerable: true, get: function () { return browserSha2.sha256; } });\n\tObject.defineProperty(exports, \"sha512\", { enumerable: true, get: function () { return browserSha2.sha512; } });\n\n\tObject.defineProperty(exports, \"SupportedAlgorithm\", { enumerable: true, get: function () { return types.SupportedAlgorithm; } });\n\n\t});\n\n\tvar index$h = /*@__PURE__*/getDefaultExportFromCjs(lib$h);\n\n\tvar browserPbkdf2 = createCommonjsModule(function (module, exports) {\n\t\"use strict\";\n\tObject.defineProperty(exports, \"__esModule\", { value: true });\n\texports.pbkdf2 = void 0;\n\n\n\tfunction pbkdf2(password, salt, iterations, keylen, hashAlgorithm) {\n\t    password = (0, lib$1.arrayify)(password);\n\t    salt = (0, lib$1.arrayify)(salt);\n\t    var hLen;\n\t    var l = 1;\n\t    var DK = new Uint8Array(keylen);\n\t    var block1 = new Uint8Array(salt.length + 4);\n\t    block1.set(salt);\n\t    //salt.copy(block1, 0, 0, salt.length)\n\t    var r;\n\t    var T;\n\t    for (var i = 1; i <= l; i++) {\n\t        //block1.writeUInt32BE(i, salt.length)\n\t        block1[salt.length] = (i >> 24) & 0xff;\n\t        block1[salt.length + 1] = (i >> 16) & 0xff;\n\t        block1[salt.length + 2] = (i >> 8) & 0xff;\n\t        block1[salt.length + 3] = i & 0xff;\n\t        //let U = createHmac(password).update(block1).digest();\n\t        var U = (0, lib$1.arrayify)((0, lib$h.computeHmac)(hashAlgorithm, password, block1));\n\t        if (!hLen) {\n\t            hLen = U.length;\n\t            T = new Uint8Array(hLen);\n\t            l = Math.ceil(keylen / hLen);\n\t            r = keylen - (l - 1) * hLen;\n\t        }\n\t        //U.copy(T, 0, 0, hLen)\n\t        T.set(U);\n\t        for (var j = 1; j < iterations; j++) {\n\t            //U = createHmac(password).update(U).digest();\n\t            U = (0, lib$1.arrayify)((0, lib$h.computeHmac)(hashAlgorithm, password, U));\n\t            for (var k = 0; k < hLen; k++)\n\t                T[k] ^= U[k];\n\t        }\n\t        var destPos = (i - 1) * hLen;\n\t        var len = (i === l ? r : hLen);\n\t        //T.copy(DK, destPos, 0, len)\n\t        DK.set((0, lib$1.arrayify)(T).slice(0, len), destPos);\n\t    }\n\t    return (0, lib$1.hexlify)(DK);\n\t}\n\texports.pbkdf2 = pbkdf2;\n\n\t});\n\n\tvar browserPbkdf2$1 = /*@__PURE__*/getDefaultExportFromCjs(browserPbkdf2);\n\n\tvar lib$i = createCommonjsModule(function (module, exports) {\n\t\"use strict\";\n\tObject.defineProperty(exports, \"__esModule\", { value: true });\n\texports.pbkdf2 = void 0;\n\n\tObject.defineProperty(exports, \"pbkdf2\", { enumerable: true, get: function () { return browserPbkdf2.pbkdf2; } });\n\n\t});\n\n\tvar index$i = /*@__PURE__*/getDefaultExportFromCjs(lib$i);\n\n\tvar _version$u = createCommonjsModule(function (module, exports) {\n\t\"use strict\";\n\tObject.defineProperty(exports, \"__esModule\", { value: true });\n\texports.version = void 0;\n\texports.version = \"wordlists/5.5.0\";\n\n\t});\n\n\tvar _version$v = /*@__PURE__*/getDefaultExportFromCjs(_version$u);\n\n\tvar wordlist = createCommonjsModule(function (module, exports) {\n\t\"use strict\";\n\tObject.defineProperty(exports, \"__esModule\", { value: true });\n\texports.Wordlist = exports.logger = void 0;\n\t// This gets overridden by rollup\n\tvar exportWordlist = false;\n\n\n\n\n\texports.logger = new lib.Logger(_version$u.version);\n\tvar Wordlist = /** @class */ (function () {\n\t    function Wordlist(locale) {\n\t        var _newTarget = this.constructor;\n\t        exports.logger.checkAbstract(_newTarget, Wordlist);\n\t        (0, lib$3.defineReadOnly)(this, \"locale\", locale);\n\t    }\n\t    // Subclasses may override this\n\t    Wordlist.prototype.split = function (mnemonic) {\n\t        return mnemonic.toLowerCase().split(/ +/g);\n\t    };\n\t    // Subclasses may override this\n\t    Wordlist.prototype.join = function (words) {\n\t        return words.join(\" \");\n\t    };\n\t    Wordlist.check = function (wordlist) {\n\t        var words = [];\n\t        for (var i = 0; i < 2048; i++) {\n\t            var word = wordlist.getWord(i);\n\t            /* istanbul ignore if */\n\t            if (i !== wordlist.getWordIndex(word)) {\n\t                return \"0x\";\n\t            }\n\t            words.push(word);\n\t        }\n\t        return (0, lib$9.id)(words.join(\"\\n\") + \"\\n\");\n\t    };\n\t    Wordlist.register = function (lang, name) {\n\t        if (!name) {\n\t            name = lang.locale;\n\t        }\n\t        /* istanbul ignore if */\n\t        if (exportWordlist) {\n\t            try {\n\t                var anyGlobal = window;\n\t                if (anyGlobal._ethers && anyGlobal._ethers.wordlists) {\n\t                    if (!anyGlobal._ethers.wordlists[name]) {\n\t                        (0, lib$3.defineReadOnly)(anyGlobal._ethers.wordlists, name, lang);\n\t                    }\n\t                }\n\t            }\n\t            catch (error) { }\n\t        }\n\t    };\n\t    return Wordlist;\n\t}());\n\texports.Wordlist = Wordlist;\n\n\t});\n\n\tvar wordlist$1 = /*@__PURE__*/getDefaultExportFromCjs(wordlist);\n\n\tvar langEn_1 = createCommonjsModule(function (module, exports) {\n\t\"use strict\";\n\tvar __extends = (commonjsGlobal && commonjsGlobal.__extends) || (function () {\n\t    var extendStatics = function (d, b) {\n\t        extendStatics = Object.setPrototypeOf ||\n\t            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n\t            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n\t        return extendStatics(d, b);\n\t    };\n\t    return function (d, b) {\n\t        if (typeof b !== \"function\" && b !== null)\n\t            throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n\t        extendStatics(d, b);\n\t        function __() { this.constructor = d; }\n\t        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n\t    };\n\t})();\n\tObject.defineProperty(exports, \"__esModule\", { value: true });\n\texports.langEn = void 0;\n\n\tvar words = \"AbandonAbilityAbleAboutAboveAbsentAbsorbAbstractAbsurdAbuseAccessAccidentAccountAccuseAchieveAcidAcousticAcquireAcrossActActionActorActressActualAdaptAddAddictAddressAdjustAdmitAdultAdvanceAdviceAerobicAffairAffordAfraidAgainAgeAgentAgreeAheadAimAirAirportAisleAlarmAlbumAlcoholAlertAlienAllAlleyAllowAlmostAloneAlphaAlreadyAlsoAlterAlwaysAmateurAmazingAmongAmountAmusedAnalystAnchorAncientAngerAngleAngryAnimalAnkleAnnounceAnnualAnotherAnswerAntennaAntiqueAnxietyAnyApartApologyAppearAppleApproveAprilArchArcticAreaArenaArgueArmArmedArmorArmyAroundArrangeArrestArriveArrowArtArtefactArtistArtworkAskAspectAssaultAssetAssistAssumeAsthmaAthleteAtomAttackAttendAttitudeAttractAuctionAuditAugustAuntAuthorAutoAutumnAverageAvocadoAvoidAwakeAwareAwayAwesomeAwfulAwkwardAxisBabyBachelorBaconBadgeBagBalanceBalconyBallBambooBananaBannerBarBarelyBargainBarrelBaseBasicBasketBattleBeachBeanBeautyBecauseBecomeBeefBeforeBeginBehaveBehindBelieveBelowBeltBenchBenefitBestBetrayBetterBetweenBeyondBicycleBidBikeBindBiologyBirdBirthBitterBlackBladeBlameBlanketBlastBleakBlessBlindBloodBlossomBlouseBlueBlurBlushBoardBoatBodyBoilBombBoneBonusBookBoostBorderBoringBorrowBossBottomBounceBoxBoyBracketBrainBrandBrassBraveBreadBreezeBrickBridgeBriefBrightBringBriskBroccoliBrokenBronzeBroomBrotherBrownBrushBubbleBuddyBudgetBuffaloBuildBulbBulkBulletBundleBunkerBurdenBurgerBurstBusBusinessBusyButterBuyerBuzzCabbageCabinCableCactusCageCakeCallCalmCameraCampCanCanalCancelCandyCannonCanoeCanvasCanyonCapableCapitalCaptainCarCarbonCardCargoCarpetCarryCartCaseCashCasinoCastleCasualCatCatalogCatchCategoryCattleCaughtCauseCautionCaveCeilingCeleryCementCensusCenturyCerealCertainChairChalkChampionChangeChaosChapterChargeChaseChatCheapCheckCheeseChefCherryChestChickenChiefChildChimneyChoiceChooseChronicChuckleChunkChurnCigarCinnamonCircleCitizenCityCivilClaimClapClarifyClawClayCleanClerkCleverClickClientCliffClimbClinicClipClockClogCloseClothCloudClownClubClumpClusterClutchCoachCoastCoconutCodeCoffeeCoilCoinCollectColorColumnCombineComeComfortComicCommonCompanyConcertConductConfirmCongressConnectConsiderControlConvinceCookCoolCopperCopyCoralCoreCornCorrectCostCottonCouchCountryCoupleCourseCousinCoverCoyoteCrackCradleCraftCramCraneCrashCraterCrawlCrazyCreamCreditCreekCrewCricketCrimeCrispCriticCropCrossCrouchCrowdCrucialCruelCruiseCrumbleCrunchCrushCryCrystalCubeCultureCupCupboardCuriousCurrentCurtainCurveCushionCustomCuteCycleDadDamageDampDanceDangerDaringDashDaughterDawnDayDealDebateDebrisDecadeDecemberDecideDeclineDecorateDecreaseDeerDefenseDefineDefyDegreeDelayDeliverDemandDemiseDenialDentistDenyDepartDependDepositDepthDeputyDeriveDescribeDesertDesignDeskDespairDestroyDetailDetectDevelopDeviceDevoteDiagramDialDiamondDiaryDiceDieselDietDifferDigitalDignityDilemmaDinnerDinosaurDirectDirtDisagreeDiscoverDiseaseDishDismissDisorderDisplayDistanceDivertDivideDivorceDizzyDoctorDocumentDogDollDolphinDomainDonateDonkeyDonorDoorDoseDoubleDoveDraftDragonDramaDrasticDrawDreamDressDriftDrillDrinkDripDriveDropDrumDryDuckDumbDuneDuringDustDutchDutyDwarfDynamicEagerEagleEarlyEarnEarthEasilyEastEasyEchoEcologyEconomyEdgeEditEducateEffortEggEightEitherElbowElderElectricElegantElementElephantElevatorEliteElseEmbarkEmbodyEmbraceEmergeEmotionEmployEmpowerEmptyEnableEnactEndEndlessEndorseEnemyEnergyEnforceEngageEngineEnhanceEnjoyEnlistEnoughEnrichEnrollEnsureEnterEntireEntryEnvelopeEpisodeEqualEquipEraEraseErodeErosionErrorEruptEscapeEssayEssenceEstateEternalEthicsEvidenceEvilEvokeEvolveExactExampleExcessExchangeExciteExcludeExcuseExecuteExerciseExhaustExhibitExileExistExitExoticExpandExpectExpireExplainExposeExpressExtendExtraEyeEyebrowFabricFaceFacultyFadeFaintFaithFallFalseFameFamilyFamousFanFancyFantasyFarmFashionFatFatalFatherFatigueFaultFavoriteFeatureFebruaryFederalFeeFeedFeelFemaleFenceFestivalFetchFeverFewFiberFictionFieldFigureFileFilmFilterFinalFindFineFingerFinishFireFirmFirstFiscalFishFitFitnessFixFlagFlameFlashFlatFlavorFleeFlightFlipFloatFlockFloorFlowerFluidFlushFlyFoamFocusFogFoilFoldFollowFoodFootForceForestForgetForkFortuneForumForwardFossilFosterFoundFoxFragileFrameFrequentFreshFriendFringeFrogFrontFrostFrownFrozenFruitFuelFunFunnyFurnaceFuryFutureGadgetGainGalaxyGalleryGameGapGarageGarbageGardenGarlicGarmentGasGaspGateGatherGaugeGazeGeneralGeniusGenreGentleGenuineGestureGhostGiantGiftGiggleGingerGiraffeGirlGiveGladGlanceGlareGlassGlideGlimpseGlobeGloomGloryGloveGlowGlueGoatGoddessGoldGoodGooseGorillaGospelGossipGovernGownGrabGraceGrainGrantGrapeGrassGravityGreatGreenGridGriefGritGroceryGroupGrowGruntGuardGuessGuideGuiltGuitarGunGymHabitHairHalfHammerHamsterHandHappyHarborHardHarshHarvestHatHaveHawkHazardHeadHealthHeartHeavyHedgehogHeightHelloHelmetHelpHenHeroHiddenHighHillHintHipHireHistoryHobbyHockeyHoldHoleHolidayHollowHomeHoneyHoodHopeHornHorrorHorseHospitalHostHotelHourHoverHubHugeHumanHumbleHumorHundredHungryHuntHurdleHurryHurtHusbandHybridIceIconIdeaIdentifyIdleIgnoreIllIllegalIllnessImageImitateImmenseImmuneImpactImposeImproveImpulseInchIncludeIncomeIncreaseIndexIndicateIndoorIndustryInfantInflictInformInhaleInheritInitialInjectInjuryInmateInnerInnocentInputInquiryInsaneInsectInsideInspireInstallIntactInterestIntoInvestInviteInvolveIronIslandIsolateIssueItemIvoryJacketJaguarJarJazzJealousJeansJellyJewelJobJoinJokeJourneyJoyJudgeJuiceJumpJungleJuniorJunkJustKangarooKeenKeepKetchupKeyKickKidKidneyKindKingdomKissKitKitchenKiteKittenKiwiKneeKnifeKnockKnowLabLabelLaborLadderLadyLakeLampLanguageLaptopLargeLaterLatinLaughLaundryLavaLawLawnLawsuitLayerLazyLeaderLeafLearnLeaveLectureLeftLegLegalLegendLeisureLemonLendLengthLensLeopardLessonLetterLevelLiarLibertyLibraryLicenseLifeLiftLightLikeLimbLimitLinkLionLiquidListLittleLiveLizardLoadLoanLobsterLocalLockLogicLonelyLongLoopLotteryLoudLoungeLoveLoyalLuckyLuggageLumberLunarLunchLuxuryLyricsMachineMadMagicMagnetMaidMailMainMajorMakeMammalManManageMandateMangoMansionManualMapleMarbleMarchMarginMarineMarketMarriageMaskMassMasterMatchMaterialMathMatrixMatterMaximumMazeMeadowMeanMeasureMeatMechanicMedalMediaMelodyMeltMemberMemoryMentionMenuMercyMergeMeritMerryMeshMessageMetalMethodMiddleMidnightMilkMillionMimicMindMinimumMinorMinuteMiracleMirrorMiseryMissMistakeMixMixedMixtureMobileModelModifyMomMomentMonitorMonkeyMonsterMonthMoonMoralMoreMorningMosquitoMotherMotionMotorMountainMouseMoveMovieMuchMuffinMuleMultiplyMuscleMuseumMushroomMusicMustMutualMyselfMysteryMythNaiveNameNapkinNarrowNastyNationNatureNearNeckNeedNegativeNeglectNeitherNephewNerveNestNetNetworkNeutralNeverNewsNextNiceNightNobleNoiseNomineeNoodleNormalNorthNoseNotableNoteNothingNoticeNovelNowNuclearNumberNurseNutOakObeyObjectObligeObscureObserveObtainObviousOccurOceanOctoberOdorOffOfferOfficeOftenOilOkayOldOliveOlympicOmitOnceOneOnionOnlineOnlyOpenOperaOpinionOpposeOptionOrangeOrbitOrchardOrderOrdinaryOrganOrientOriginalOrphanOstrichOtherOutdoorOuterOutputOutsideOvalOvenOverOwnOwnerOxygenOysterOzonePactPaddlePagePairPalacePalmPandaPanelPanicPantherPaperParadeParentParkParrotPartyPassPatchPathPatientPatrolPatternPausePavePaymentPeacePeanutPearPeasantPelicanPenPenaltyPencilPeoplePepperPerfectPermitPersonPetPhonePhotoPhrasePhysicalPianoPicnicPicturePiecePigPigeonPillPilotPinkPioneerPipePistolPitchPizzaPlacePlanetPlasticPlatePlayPleasePledgePluckPlugPlungePoemPoetPointPolarPolePolicePondPonyPoolPopularPortionPositionPossiblePostPotatoPotteryPovertyPowderPowerPracticePraisePredictPreferPreparePresentPrettyPreventPricePridePrimaryPrintPriorityPrisonPrivatePrizeProblemProcessProduceProfitProgramProjectPromoteProofPropertyProsperProtectProudProvidePublicPuddingPullPulpPulsePumpkinPunchPupilPuppyPurchasePurityPurposePursePushPutPuzzlePyramidQualityQuantumQuarterQuestionQuickQuitQuizQuoteRabbitRaccoonRaceRackRadarRadioRailRainRaiseRallyRampRanchRandomRangeRapidRareRateRatherRavenRawRazorReadyRealReasonRebelRebuildRecallReceiveRecipeRecordRecycleReduceReflectReformRefuseRegionRegretRegularRejectRelaxReleaseReliefRelyRemainRememberRemindRemoveRenderRenewRentReopenRepairRepeatReplaceReportRequireRescueResembleResistResourceResponseResultRetireRetreatReturnReunionRevealReviewRewardRhythmRibRibbonRiceRichRideRidgeRifleRightRigidRingRiotRippleRiskRitualRivalRiverRoadRoastRobotRobustRocketRomanceRoofRookieRoomRoseRotateRoughRoundRouteRoyalRubberRudeRugRuleRunRunwayRuralSadSaddleSadnessSafeSailSaladSalmonSalonSaltSaluteSameSampleSandSatisfySatoshiSauceSausageSaveSayScaleScanScareScatterSceneSchemeSchoolScienceScissorsScorpionScoutScrapScreenScriptScrubSeaSearchSeasonSeatSecondSecretSectionSecuritySeedSeekSegmentSelectSellSeminarSeniorSenseSentenceSeriesServiceSessionSettleSetupSevenShadowShaftShallowShareShedShellSheriffShieldShiftShineShipShiverShockShoeShootShopShortShoulderShoveShrimpShrugShuffleShySiblingSickSideSiegeSightSignSilentSilkSillySilverSimilarSimpleSinceSingSirenSisterSituateSixSizeSkateSketchSkiSkillSkinSkirtSkullSlabSlamSleepSlenderSliceSlideSlightSlimSloganSlotSlowSlushSmallSmartSmileSmokeSmoothSnackSnakeSnapSniffSnowSoapSoccerSocialSockSodaSoftSolarSoldierSolidSolutionSolveSomeoneSongSoonSorrySortSoulSoundSoupSourceSouthSpaceSpareSpatialSpawnSpeakSpecialSpeedSpellSpendSphereSpiceSpiderSpikeSpinSpiritSplitSpoilSponsorSpoonSportSpotSpraySpreadSpringSpySquareSqueezeSquirrelStableStadiumStaffStageStairsStampStandStartStateStaySteakSteelStemStepStereoStickStillStingStockStomachStoneStoolStoryStoveStrategyStreetStrikeStrongStruggleStudentStuffStumbleStyleSubjectSubmitSubwaySuccessSuchSuddenSufferSugarSuggestSuitSummerSunSunnySunsetSuperSupplySupremeSureSurfaceSurgeSurpriseSurroundSurveySuspectSustainSwallowSwampSwapSwarmSwearSweetSwiftSwimSwingSwitchSwordSymbolSymptomSyrupSystemTableTackleTagTailTalentTalkTankTapeTargetTaskTasteTattooTaxiTeachTeamTellTenTenantTennisTentTermTestTextThankThatThemeThenTheoryThereTheyThingThisThoughtThreeThriveThrowThumbThunderTicketTideTigerTiltTimberTimeTinyTipTiredTissueTitleToastTobaccoTodayToddlerToeTogetherToiletTokenTomatoTomorrowToneTongueTonightToolToothTopTopicToppleTorchTornadoTortoiseTossTotalTouristTowardTowerTownToyTrackTradeTrafficTragicTrainTransferTrapTrashTravelTrayTreatTreeTrendTrialTribeTrickTriggerTrimTripTrophyTroubleTruckTrueTrulyTrumpetTrustTruthTryTubeTuitionTumbleTunaTunnelTurkeyTurnTurtleTwelveTwentyTwiceTwinTwistTwoTypeTypicalUglyUmbrellaUnableUnawareUncleUncoverUnderUndoUnfairUnfoldUnhappyUniformUniqueUnitUniverseUnknownUnlockUntilUnusualUnveilUpdateUpgradeUpholdUponUpperUpsetUrbanUrgeUsageUseUsedUsefulUselessUsualUtilityVacantVacuumVagueValidValleyValveVanVanishVaporVariousVastVaultVehicleVelvetVendorVentureVenueVerbVerifyVersionVeryVesselVeteranViableVibrantViciousVictoryVideoViewVillageVintageViolinVirtualVirusVisaVisitVisualVitalVividVocalVoiceVoidVolcanoVolumeVoteVoyageWageWagonWaitWalkWallWalnutWantWarfareWarmWarriorWashWaspWasteWaterWaveWayWealthWeaponWearWeaselWeatherWebWeddingWeekendWeirdWelcomeWestWetWhaleWhatWheatWheelWhenWhereWhipWhisperWideWidthWifeWildWillWinWindowWineWingWinkWinnerWinterWireWisdomWiseWishWitnessWolfWomanWonderWoodWoolWordWorkWorldWorryWorthWrapWreckWrestleWristWriteWrongYardYearYellowYouYoungYouthZebraZeroZoneZoo\";\n\tvar wordlist$1 = null;\n\tfunction loadWords(lang) {\n\t    if (wordlist$1 != null) {\n\t        return;\n\t    }\n\t    wordlist$1 = words.replace(/([A-Z])/g, \" $1\").toLowerCase().substring(1).split(\" \");\n\t    // Verify the computed list matches the official list\n\t    /* istanbul ignore if */\n\t    if (wordlist.Wordlist.check(lang) !== \"0x3c8acc1e7b08d8e76f9fda015ef48dc8c710a73cb7e0f77b2c18a9b5a7adde60\") {\n\t        wordlist$1 = null;\n\t        throw new Error(\"BIP39 Wordlist for en (English) FAILED\");\n\t    }\n\t}\n\tvar LangEn = /** @class */ (function (_super) {\n\t    __extends(LangEn, _super);\n\t    function LangEn() {\n\t        return _super.call(this, \"en\") || this;\n\t    }\n\t    LangEn.prototype.getWord = function (index) {\n\t        loadWords(this);\n\t        return wordlist$1[index];\n\t    };\n\t    LangEn.prototype.getWordIndex = function (word) {\n\t        loadWords(this);\n\t        return wordlist$1.indexOf(word);\n\t    };\n\t    return LangEn;\n\t}(wordlist.Wordlist));\n\tvar langEn = new LangEn();\n\texports.langEn = langEn;\n\twordlist.Wordlist.register(langEn);\n\n\t});\n\n\tvar langEn = /*@__PURE__*/getDefaultExportFromCjs(langEn_1);\n\n\tvar browserWordlists = createCommonjsModule(function (module, exports) {\n\t\"use strict\";\n\tObject.defineProperty(exports, \"__esModule\", { value: true });\n\texports.wordlists = void 0;\n\n\texports.wordlists = {\n\t    en: langEn_1.langEn\n\t};\n\n\t});\n\n\tvar browserWordlists$1 = /*@__PURE__*/getDefaultExportFromCjs(browserWordlists);\n\n\tvar lib$j = createCommonjsModule(function (module, exports) {\n\t\"use strict\";\n\tObject.defineProperty(exports, \"__esModule\", { value: true });\n\texports.wordlists = exports.Wordlist = exports.logger = void 0;\n\t// Wordlists\n\t// See: https://github.com/bitcoin/bips/blob/master/bip-0039/bip-0039-wordlists.md\n\n\tObject.defineProperty(exports, \"logger\", { enumerable: true, get: function () { return wordlist.logger; } });\n\tObject.defineProperty(exports, \"Wordlist\", { enumerable: true, get: function () { return wordlist.Wordlist; } });\n\n\tObject.defineProperty(exports, \"wordlists\", { enumerable: true, get: function () { return browserWordlists.wordlists; } });\n\n\t});\n\n\tvar index$j = /*@__PURE__*/getDefaultExportFromCjs(lib$j);\n\n\tvar _version$w = createCommonjsModule(function (module, exports) {\n\t\"use strict\";\n\tObject.defineProperty(exports, \"__esModule\", { value: true });\n\texports.version = void 0;\n\texports.version = \"hdnode/5.5.0\";\n\n\t});\n\n\tvar _version$x = /*@__PURE__*/getDefaultExportFromCjs(_version$w);\n\n\tvar lib$k = createCommonjsModule(function (module, exports) {\n\t\"use strict\";\n\tObject.defineProperty(exports, \"__esModule\", { value: true });\n\texports.getAccountPath = exports.isValidMnemonic = exports.entropyToMnemonic = exports.mnemonicToEntropy = exports.mnemonicToSeed = exports.HDNode = exports.defaultPath = void 0;\n\n\n\n\n\n\n\n\n\n\n\n\n\tvar logger = new lib.Logger(_version$w.version);\n\tvar N = lib$2.BigNumber.from(\"0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141\");\n\t// \"Bitcoin seed\"\n\tvar MasterSecret = (0, lib$8.toUtf8Bytes)(\"Bitcoin seed\");\n\tvar HardenedBit = 0x80000000;\n\t// Returns a byte with the MSB bits set\n\tfunction getUpperMask(bits) {\n\t    return ((1 << bits) - 1) << (8 - bits);\n\t}\n\t// Returns a byte with the LSB bits set\n\tfunction getLowerMask(bits) {\n\t    return (1 << bits) - 1;\n\t}\n\tfunction bytes32(value) {\n\t    return (0, lib$1.hexZeroPad)((0, lib$1.hexlify)(value), 32);\n\t}\n\tfunction base58check(data) {\n\t    return lib$g.Base58.encode((0, lib$1.concat)([data, (0, lib$1.hexDataSlice)((0, lib$h.sha256)((0, lib$h.sha256)(data)), 0, 4)]));\n\t}\n\tfunction getWordlist(wordlist) {\n\t    if (wordlist == null) {\n\t        return lib$j.wordlists[\"en\"];\n\t    }\n\t    if (typeof (wordlist) === \"string\") {\n\t        var words = lib$j.wordlists[wordlist];\n\t        if (words == null) {\n\t            logger.throwArgumentError(\"unknown locale\", \"wordlist\", wordlist);\n\t        }\n\t        return words;\n\t    }\n\t    return wordlist;\n\t}\n\tvar _constructorGuard = {};\n\texports.defaultPath = \"m/44'/60'/0'/0/0\";\n\t;\n\tvar HDNode = /** @class */ (function () {\n\t    /**\n\t     *  This constructor should not be called directly.\n\t     *\n\t     *  Please use:\n\t     *   - fromMnemonic\n\t     *   - fromSeed\n\t     */\n\t    function HDNode(constructorGuard, privateKey, publicKey, parentFingerprint, chainCode, index, depth, mnemonicOrPath) {\n\t        var _newTarget = this.constructor;\n\t        logger.checkNew(_newTarget, HDNode);\n\t        /* istanbul ignore if */\n\t        if (constructorGuard !== _constructorGuard) {\n\t            throw new Error(\"HDNode constructor cannot be called directly\");\n\t        }\n\t        if (privateKey) {\n\t            var signingKey = new lib$d.SigningKey(privateKey);\n\t            (0, lib$3.defineReadOnly)(this, \"privateKey\", signingKey.privateKey);\n\t            (0, lib$3.defineReadOnly)(this, \"publicKey\", signingKey.compressedPublicKey);\n\t        }\n\t        else {\n\t            (0, lib$3.defineReadOnly)(this, \"privateKey\", null);\n\t            (0, lib$3.defineReadOnly)(this, \"publicKey\", (0, lib$1.hexlify)(publicKey));\n\t        }\n\t        (0, lib$3.defineReadOnly)(this, \"parentFingerprint\", parentFingerprint);\n\t        (0, lib$3.defineReadOnly)(this, \"fingerprint\", (0, lib$1.hexDataSlice)((0, lib$h.ripemd160)((0, lib$h.sha256)(this.publicKey)), 0, 4));\n\t        (0, lib$3.defineReadOnly)(this, \"address\", (0, lib$e.computeAddress)(this.publicKey));\n\t        (0, lib$3.defineReadOnly)(this, \"chainCode\", chainCode);\n\t        (0, lib$3.defineReadOnly)(this, \"index\", index);\n\t        (0, lib$3.defineReadOnly)(this, \"depth\", depth);\n\t        if (mnemonicOrPath == null) {\n\t            // From a source that does not preserve the path (e.g. extended keys)\n\t            (0, lib$3.defineReadOnly)(this, \"mnemonic\", null);\n\t            (0, lib$3.defineReadOnly)(this, \"path\", null);\n\t        }\n\t        else if (typeof (mnemonicOrPath) === \"string\") {\n\t            // From a source that does not preserve the mnemonic (e.g. neutered)\n\t            (0, lib$3.defineReadOnly)(this, \"mnemonic\", null);\n\t            (0, lib$3.defineReadOnly)(this, \"path\", mnemonicOrPath);\n\t        }\n\t        else {\n\t            // From a fully qualified source\n\t            (0, lib$3.defineReadOnly)(this, \"mnemonic\", mnemonicOrPath);\n\t            (0, lib$3.defineReadOnly)(this, \"path\", mnemonicOrPath.path);\n\t        }\n\t    }\n\t    Object.defineProperty(HDNode.prototype, \"extendedKey\", {\n\t        get: function () {\n\t            // We only support the mainnet values for now, but if anyone needs\n\t            // testnet values, let me know. I believe current sentiment is that\n\t            // we should always use mainnet, and use BIP-44 to derive the network\n\t            //   - Mainnet: public=0x0488B21E, private=0x0488ADE4\n\t            //   - Testnet: public=0x043587CF, private=0x04358394\n\t            if (this.depth >= 256) {\n\t                throw new Error(\"Depth too large!\");\n\t            }\n\t            return base58check((0, lib$1.concat)([\n\t                ((this.privateKey != null) ? \"0x0488ADE4\" : \"0x0488B21E\"),\n\t                (0, lib$1.hexlify)(this.depth),\n\t                this.parentFingerprint,\n\t                (0, lib$1.hexZeroPad)((0, lib$1.hexlify)(this.index), 4),\n\t                this.chainCode,\n\t                ((this.privateKey != null) ? (0, lib$1.concat)([\"0x00\", this.privateKey]) : this.publicKey),\n\t            ]));\n\t        },\n\t        enumerable: false,\n\t        configurable: true\n\t    });\n\t    HDNode.prototype.neuter = function () {\n\t        return new HDNode(_constructorGuard, null, this.publicKey, this.parentFingerprint, this.chainCode, this.index, this.depth, this.path);\n\t    };\n\t    HDNode.prototype._derive = function (index) {\n\t        if (index > 0xffffffff) {\n\t            throw new Error(\"invalid index - \" + String(index));\n\t        }\n\t        // Base path\n\t        var path = this.path;\n\t        if (path) {\n\t            path += \"/\" + (index & ~HardenedBit);\n\t        }\n\t        var data = new Uint8Array(37);\n\t        if (index & HardenedBit) {\n\t            if (!this.privateKey) {\n\t                throw new Error(\"cannot derive child of neutered node\");\n\t            }\n\t            // Data = 0x00 || ser_256(k_par)\n\t            data.set((0, lib$1.arrayify)(this.privateKey), 1);\n\t            // Hardened path\n\t            if (path) {\n\t                path += \"'\";\n\t            }\n\t        }\n\t        else {\n\t            // Data = ser_p(point(k_par))\n\t            data.set((0, lib$1.arrayify)(this.publicKey));\n\t        }\n\t        // Data += ser_32(i)\n\t        for (var i = 24; i >= 0; i -= 8) {\n\t            data[33 + (i >> 3)] = ((index >> (24 - i)) & 0xff);\n\t        }\n\t        var I = (0, lib$1.arrayify)((0, lib$h.computeHmac)(lib$h.SupportedAlgorithm.sha512, this.chainCode, data));\n\t        var IL = I.slice(0, 32);\n\t        var IR = I.slice(32);\n\t        // The private key\n\t        var ki = null;\n\t        // The public key\n\t        var Ki = null;\n\t        if (this.privateKey) {\n\t            ki = bytes32(lib$2.BigNumber.from(IL).add(this.privateKey).mod(N));\n\t        }\n\t        else {\n\t            var ek = new lib$d.SigningKey((0, lib$1.hexlify)(IL));\n\t            Ki = ek._addPoint(this.publicKey);\n\t        }\n\t        var mnemonicOrPath = path;\n\t        var srcMnemonic = this.mnemonic;\n\t        if (srcMnemonic) {\n\t            mnemonicOrPath = Object.freeze({\n\t                phrase: srcMnemonic.phrase,\n\t                path: path,\n\t                locale: (srcMnemonic.locale || \"en\")\n\t            });\n\t        }\n\t        return new HDNode(_constructorGuard, ki, Ki, this.fingerprint, bytes32(IR), index, this.depth + 1, mnemonicOrPath);\n\t    };\n\t    HDNode.prototype.derivePath = function (path) {\n\t        var components = path.split(\"/\");\n\t        if (components.length === 0 || (components[0] === \"m\" && this.depth !== 0)) {\n\t            throw new Error(\"invalid path - \" + path);\n\t        }\n\t        if (components[0] === \"m\") {\n\t            components.shift();\n\t        }\n\t        var result = this;\n\t        for (var i = 0; i < components.length; i++) {\n\t            var component = components[i];\n\t            if (component.match(/^[0-9]+'$/)) {\n\t                var index = parseInt(component.substring(0, component.length - 1));\n\t                if (index >= HardenedBit) {\n\t                    throw new Error(\"invalid path index - \" + component);\n\t                }\n\t                result = result._derive(HardenedBit + index);\n\t            }\n\t            else if (component.match(/^[0-9]+$/)) {\n\t                var index = parseInt(component);\n\t                if (index >= HardenedBit) {\n\t                    throw new Error(\"invalid path index - \" + component);\n\t                }\n\t                result = result._derive(index);\n\t            }\n\t            else {\n\t                throw new Error(\"invalid path component - \" + component);\n\t            }\n\t        }\n\t        return result;\n\t    };\n\t    HDNode._fromSeed = function (seed, mnemonic) {\n\t        var seedArray = (0, lib$1.arrayify)(seed);\n\t        if (seedArray.length < 16 || seedArray.length > 64) {\n\t            throw new Error(\"invalid seed\");\n\t        }\n\t        var I = (0, lib$1.arrayify)((0, lib$h.computeHmac)(lib$h.SupportedAlgorithm.sha512, MasterSecret, seedArray));\n\t        return new HDNode(_constructorGuard, bytes32(I.slice(0, 32)), null, \"0x00000000\", bytes32(I.slice(32)), 0, 0, mnemonic);\n\t    };\n\t    HDNode.fromMnemonic = function (mnemonic, password, wordlist) {\n\t        // If a locale name was passed in, find the associated wordlist\n\t        wordlist = getWordlist(wordlist);\n\t        // Normalize the case and spacing in the mnemonic (throws if the mnemonic is invalid)\n\t        mnemonic = entropyToMnemonic(mnemonicToEntropy(mnemonic, wordlist), wordlist);\n\t        return HDNode._fromSeed(mnemonicToSeed(mnemonic, password), {\n\t            phrase: mnemonic,\n\t            path: \"m\",\n\t            locale: wordlist.locale\n\t        });\n\t    };\n\t    HDNode.fromSeed = function (seed) {\n\t        return HDNode._fromSeed(seed, null);\n\t    };\n\t    HDNode.fromExtendedKey = function (extendedKey) {\n\t        var bytes = lib$g.Base58.decode(extendedKey);\n\t        if (bytes.length !== 82 || base58check(bytes.slice(0, 78)) !== extendedKey) {\n\t            logger.throwArgumentError(\"invalid extended key\", \"extendedKey\", \"[REDACTED]\");\n\t        }\n\t        var depth = bytes[4];\n\t        var parentFingerprint = (0, lib$1.hexlify)(bytes.slice(5, 9));\n\t        var index = parseInt((0, lib$1.hexlify)(bytes.slice(9, 13)).substring(2), 16);\n\t        var chainCode = (0, lib$1.hexlify)(bytes.slice(13, 45));\n\t        var key = bytes.slice(45, 78);\n\t        switch ((0, lib$1.hexlify)(bytes.slice(0, 4))) {\n\t            // Public Key\n\t            case \"0x0488b21e\":\n\t            case \"0x043587cf\":\n\t                return new HDNode(_constructorGuard, null, (0, lib$1.hexlify)(key), parentFingerprint, chainCode, index, depth, null);\n\t            // Private Key\n\t            case \"0x0488ade4\":\n\t            case \"0x04358394 \":\n\t                if (key[0] !== 0) {\n\t                    break;\n\t                }\n\t                return new HDNode(_constructorGuard, (0, lib$1.hexlify)(key.slice(1)), null, parentFingerprint, chainCode, index, depth, null);\n\t        }\n\t        return logger.throwArgumentError(\"invalid extended key\", \"extendedKey\", \"[REDACTED]\");\n\t    };\n\t    return HDNode;\n\t}());\n\texports.HDNode = HDNode;\n\tfunction mnemonicToSeed(mnemonic, password) {\n\t    if (!password) {\n\t        password = \"\";\n\t    }\n\t    var salt = (0, lib$8.toUtf8Bytes)(\"mnemonic\" + password, lib$8.UnicodeNormalizationForm.NFKD);\n\t    return (0, lib$i.pbkdf2)((0, lib$8.toUtf8Bytes)(mnemonic, lib$8.UnicodeNormalizationForm.NFKD), salt, 2048, 64, \"sha512\");\n\t}\n\texports.mnemonicToSeed = mnemonicToSeed;\n\tfunction mnemonicToEntropy(mnemonic, wordlist) {\n\t    wordlist = getWordlist(wordlist);\n\t    logger.checkNormalize();\n\t    var words = wordlist.split(mnemonic);\n\t    if ((words.length % 3) !== 0) {\n\t        throw new Error(\"invalid mnemonic\");\n\t    }\n\t    var entropy = (0, lib$1.arrayify)(new Uint8Array(Math.ceil(11 * words.length / 8)));\n\t    var offset = 0;\n\t    for (var i = 0; i < words.length; i++) {\n\t        var index = wordlist.getWordIndex(words[i].normalize(\"NFKD\"));\n\t        if (index === -1) {\n\t            throw new Error(\"invalid mnemonic\");\n\t        }\n\t        for (var bit = 0; bit < 11; bit++) {\n\t            if (index & (1 << (10 - bit))) {\n\t                entropy[offset >> 3] |= (1 << (7 - (offset % 8)));\n\t            }\n\t            offset++;\n\t        }\n\t    }\n\t    var entropyBits = 32 * words.length / 3;\n\t    var checksumBits = words.length / 3;\n\t    var checksumMask = getUpperMask(checksumBits);\n\t    var checksum = (0, lib$1.arrayify)((0, lib$h.sha256)(entropy.slice(0, entropyBits / 8)))[0] & checksumMask;\n\t    if (checksum !== (entropy[entropy.length - 1] & checksumMask)) {\n\t        throw new Error(\"invalid checksum\");\n\t    }\n\t    return (0, lib$1.hexlify)(entropy.slice(0, entropyBits / 8));\n\t}\n\texports.mnemonicToEntropy = mnemonicToEntropy;\n\tfunction entropyToMnemonic(entropy, wordlist) {\n\t    wordlist = getWordlist(wordlist);\n\t    entropy = (0, lib$1.arrayify)(entropy);\n\t    if ((entropy.length % 4) !== 0 || entropy.length < 16 || entropy.length > 32) {\n\t        throw new Error(\"invalid entropy\");\n\t    }\n\t    var indices = [0];\n\t    var remainingBits = 11;\n\t    for (var i = 0; i < entropy.length; i++) {\n\t        // Consume the whole byte (with still more to go)\n\t        if (remainingBits > 8) {\n\t            indices[indices.length - 1] <<= 8;\n\t            indices[indices.length - 1] |= entropy[i];\n\t            remainingBits -= 8;\n\t            // This byte will complete an 11-bit index\n\t        }\n\t        else {\n\t            indices[indices.length - 1] <<= remainingBits;\n\t            indices[indices.length - 1] |= entropy[i] >> (8 - remainingBits);\n\t            // Start the next word\n\t            indices.push(entropy[i] & getLowerMask(8 - remainingBits));\n\t            remainingBits += 3;\n\t        }\n\t    }\n\t    // Compute the checksum bits\n\t    var checksumBits = entropy.length / 4;\n\t    var checksum = (0, lib$1.arrayify)((0, lib$h.sha256)(entropy))[0] & getUpperMask(checksumBits);\n\t    // Shift the checksum into the word indices\n\t    indices[indices.length - 1] <<= checksumBits;\n\t    indices[indices.length - 1] |= (checksum >> (8 - checksumBits));\n\t    return wordlist.join(indices.map(function (index) { return wordlist.getWord(index); }));\n\t}\n\texports.entropyToMnemonic = entropyToMnemonic;\n\tfunction isValidMnemonic(mnemonic, wordlist) {\n\t    try {\n\t        mnemonicToEntropy(mnemonic, wordlist);\n\t        return true;\n\t    }\n\t    catch (error) { }\n\t    return false;\n\t}\n\texports.isValidMnemonic = isValidMnemonic;\n\tfunction getAccountPath(index) {\n\t    if (typeof (index) !== \"number\" || index < 0 || index >= HardenedBit || index % 1) {\n\t        logger.throwArgumentError(\"invalid account index\", \"index\", index);\n\t    }\n\t    return \"m/44'/60'/\" + index + \"'/0/0\";\n\t}\n\texports.getAccountPath = getAccountPath;\n\n\t});\n\n\tvar index$k = /*@__PURE__*/getDefaultExportFromCjs(lib$k);\n\n\tvar _version$y = createCommonjsModule(function (module, exports) {\n\t\"use strict\";\n\tObject.defineProperty(exports, \"__esModule\", { value: true });\n\texports.version = void 0;\n\texports.version = \"random/5.5.0\";\n\n\t});\n\n\tvar _version$z = /*@__PURE__*/getDefaultExportFromCjs(_version$y);\n\n\tvar browserRandom = createCommonjsModule(function (module, exports) {\n\t\"use strict\";\n\tObject.defineProperty(exports, \"__esModule\", { value: true });\n\texports.randomBytes = void 0;\n\n\n\n\tvar logger = new lib.Logger(_version$y.version);\n\t// Debugging line for testing browser lib in node\n\t//const window = { crypto: { getRandomValues: () => { } } };\n\tvar anyGlobal = null;\n\ttry {\n\t    anyGlobal = window;\n\t    if (anyGlobal == null) {\n\t        throw new Error(\"try next\");\n\t    }\n\t}\n\tcatch (error) {\n\t    try {\n\t        anyGlobal = commonjsGlobal;\n\t        if (anyGlobal == null) {\n\t            throw new Error(\"try next\");\n\t        }\n\t    }\n\t    catch (error) {\n\t        anyGlobal = {};\n\t    }\n\t}\n\tvar crypto = anyGlobal.crypto || anyGlobal.msCrypto;\n\tif (!crypto || !crypto.getRandomValues) {\n\t    logger.warn(\"WARNING: Missing strong random number source\");\n\t    crypto = {\n\t        getRandomValues: function (buffer) {\n\t            return logger.throwError(\"no secure random source avaialble\", lib.Logger.errors.UNSUPPORTED_OPERATION, {\n\t                operation: \"crypto.getRandomValues\"\n\t            });\n\t        }\n\t    };\n\t}\n\tfunction randomBytes(length) {\n\t    if (length <= 0 || length > 1024 || (length % 1) || length != length) {\n\t        logger.throwArgumentError(\"invalid length\", \"length\", length);\n\t    }\n\t    var result = new Uint8Array(length);\n\t    crypto.getRandomValues(result);\n\t    return (0, lib$1.arrayify)(result);\n\t}\n\texports.randomBytes = randomBytes;\n\t;\n\n\t});\n\n\tvar browserRandom$1 = /*@__PURE__*/getDefaultExportFromCjs(browserRandom);\n\n\tvar shuffle = createCommonjsModule(function (module, exports) {\n\t\"use strict\";\n\tObject.defineProperty(exports, \"__esModule\", { value: true });\n\texports.shuffled = void 0;\n\tfunction shuffled(array) {\n\t    array = array.slice();\n\t    for (var i = array.length - 1; i > 0; i--) {\n\t        var j = Math.floor(Math.random() * (i + 1));\n\t        var tmp = array[i];\n\t        array[i] = array[j];\n\t        array[j] = tmp;\n\t    }\n\t    return array;\n\t}\n\texports.shuffled = shuffled;\n\n\t});\n\n\tvar shuffle$1 = /*@__PURE__*/getDefaultExportFromCjs(shuffle);\n\n\tvar lib$l = createCommonjsModule(function (module, exports) {\n\t\"use strict\";\n\tObject.defineProperty(exports, \"__esModule\", { value: true });\n\texports.shuffled = exports.randomBytes = void 0;\n\n\tObject.defineProperty(exports, \"randomBytes\", { enumerable: true, get: function () { return browserRandom.randomBytes; } });\n\n\tObject.defineProperty(exports, \"shuffled\", { enumerable: true, get: function () { return shuffle.shuffled; } });\n\n\t});\n\n\tvar index$l = /*@__PURE__*/getDefaultExportFromCjs(lib$l);\n\n\tvar aesJs = createCommonjsModule(function (module, exports) {\n\t\"use strict\";\n\n\t(function(root) {\n\n\t    function checkInt(value) {\n\t        return (parseInt(value) === value);\n\t    }\n\n\t    function checkInts(arrayish) {\n\t        if (!checkInt(arrayish.length)) { return false; }\n\n\t        for (var i = 0; i < arrayish.length; i++) {\n\t            if (!checkInt(arrayish[i]) || arrayish[i] < 0 || arrayish[i] > 255) {\n\t                return false;\n\t            }\n\t        }\n\n\t        return true;\n\t    }\n\n\t    function coerceArray(arg, copy) {\n\n\t        // ArrayBuffer view\n\t        if (arg.buffer && ArrayBuffer.isView(arg) && arg.name === 'Uint8Array') {\n\n\t            if (copy) {\n\t                if (arg.slice) {\n\t                    arg = arg.slice();\n\t                } else {\n\t                    arg = Array.prototype.slice.call(arg);\n\t                }\n\t            }\n\n\t            return arg;\n\t        }\n\n\t        // It's an array; check it is a valid representation of a byte\n\t        if (Array.isArray(arg)) {\n\t            if (!checkInts(arg)) {\n\t                throw new Error('Array contains invalid value: ' + arg);\n\t            }\n\n\t            return new Uint8Array(arg);\n\t        }\n\n\t        // Something else, but behaves like an array (maybe a Buffer? Arguments?)\n\t        if (checkInt(arg.length) && checkInts(arg)) {\n\t            return new Uint8Array(arg);\n\t        }\n\n\t        throw new Error('unsupported array-like object');\n\t    }\n\n\t    function createArray(length) {\n\t        return new Uint8Array(length);\n\t    }\n\n\t    function copyArray(sourceArray, targetArray, targetStart, sourceStart, sourceEnd) {\n\t        if (sourceStart != null || sourceEnd != null) {\n\t            if (sourceArray.slice) {\n\t                sourceArray = sourceArray.slice(sourceStart, sourceEnd);\n\t            } else {\n\t                sourceArray = Array.prototype.slice.call(sourceArray, sourceStart, sourceEnd);\n\t            }\n\t        }\n\t        targetArray.set(sourceArray, targetStart);\n\t    }\n\n\n\n\t    var convertUtf8 = (function() {\n\t        function toBytes(text) {\n\t            var result = [], i = 0;\n\t            text = encodeURI(text);\n\t            while (i < text.length) {\n\t                var c = text.charCodeAt(i++);\n\n\t                // if it is a % sign, encode the following 2 bytes as a hex value\n\t                if (c === 37) {\n\t                    result.push(parseInt(text.substr(i, 2), 16));\n\t                    i += 2;\n\n\t                // otherwise, just the actual byte\n\t                } else {\n\t                    result.push(c);\n\t                }\n\t            }\n\n\t            return coerceArray(result);\n\t        }\n\n\t        function fromBytes(bytes) {\n\t            var result = [], i = 0;\n\n\t            while (i < bytes.length) {\n\t                var c = bytes[i];\n\n\t                if (c < 128) {\n\t                    result.push(String.fromCharCode(c));\n\t                    i++;\n\t                } else if (c > 191 && c < 224) {\n\t                    result.push(String.fromCharCode(((c & 0x1f) << 6) | (bytes[i + 1] & 0x3f)));\n\t                    i += 2;\n\t                } else {\n\t                    result.push(String.fromCharCode(((c & 0x0f) << 12) | ((bytes[i + 1] & 0x3f) << 6) | (bytes[i + 2] & 0x3f)));\n\t                    i += 3;\n\t                }\n\t            }\n\n\t            return result.join('');\n\t        }\n\n\t        return {\n\t            toBytes: toBytes,\n\t            fromBytes: fromBytes,\n\t        }\n\t    })();\n\n\t    var convertHex = (function() {\n\t        function toBytes(text) {\n\t            var result = [];\n\t            for (var i = 0; i < text.length; i += 2) {\n\t                result.push(parseInt(text.substr(i, 2), 16));\n\t            }\n\n\t            return result;\n\t        }\n\n\t        // http://ixti.net/development/javascript/2011/11/11/base64-encodedecode-of-utf8-in-browser-with-js.html\n\t        var Hex = '0123456789abcdef';\n\n\t        function fromBytes(bytes) {\n\t                var result = [];\n\t                for (var i = 0; i < bytes.length; i++) {\n\t                    var v = bytes[i];\n\t                    result.push(Hex[(v & 0xf0) >> 4] + Hex[v & 0x0f]);\n\t                }\n\t                return result.join('');\n\t        }\n\n\t        return {\n\t            toBytes: toBytes,\n\t            fromBytes: fromBytes,\n\t        }\n\t    })();\n\n\n\t    // Number of rounds by keysize\n\t    var numberOfRounds = {16: 10, 24: 12, 32: 14};\n\n\t    // Round constant words\n\t    var rcon = [0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36, 0x6c, 0xd8, 0xab, 0x4d, 0x9a, 0x2f, 0x5e, 0xbc, 0x63, 0xc6, 0x97, 0x35, 0x6a, 0xd4, 0xb3, 0x7d, 0xfa, 0xef, 0xc5, 0x91];\n\n\t    // S-box and Inverse S-box (S is for Substitution)\n\t    var S = [0x63, 0x7c, 0x77, 0x7b, 0xf2, 0x6b, 0x6f, 0xc5, 0x30, 0x01, 0x67, 0x2b, 0xfe, 0xd7, 0xab, 0x76, 0xca, 0x82, 0xc9, 0x7d, 0xfa, 0x59, 0x47, 0xf0, 0xad, 0xd4, 0xa2, 0xaf, 0x9c, 0xa4, 0x72, 0xc0, 0xb7, 0xfd, 0x93, 0x26, 0x36, 0x3f, 0xf7, 0xcc, 0x34, 0xa5, 0xe5, 0xf1, 0x71, 0xd8, 0x31, 0x15, 0x04, 0xc7, 0x23, 0xc3, 0x18, 0x96, 0x05, 0x9a, 0x07, 0x12, 0x80, 0xe2, 0xeb, 0x27, 0xb2, 0x75, 0x09, 0x83, 0x2c, 0x1a, 0x1b, 0x6e, 0x5a, 0xa0, 0x52, 0x3b, 0xd6, 0xb3, 0x29, 0xe3, 0x2f, 0x84, 0x53, 0xd1, 0x00, 0xed, 0x20, 0xfc, 0xb1, 0x5b, 0x6a, 0xcb, 0xbe, 0x39, 0x4a, 0x4c, 0x58, 0xcf, 0xd0, 0xef, 0xaa, 0xfb, 0x43, 0x4d, 0x33, 0x85, 0x45, 0xf9, 0x02, 0x7f, 0x50, 0x3c, 0x9f, 0xa8, 0x51, 0xa3, 0x40, 0x8f, 0x92, 0x9d, 0x38, 0xf5, 0xbc, 0xb6, 0xda, 0x21, 0x10, 0xff, 0xf3, 0xd2, 0xcd, 0x0c, 0x13, 0xec, 0x5f, 0x97, 0x44, 0x17, 0xc4, 0xa7, 0x7e, 0x3d, 0x64, 0x5d, 0x19, 0x73, 0x60, 0x81, 0x4f, 0xdc, 0x22, 0x2a, 0x90, 0x88, 0x46, 0xee, 0xb8, 0x14, 0xde, 0x5e, 0x0b, 0xdb, 0xe0, 0x32, 0x3a, 0x0a, 0x49, 0x06, 0x24, 0x5c, 0xc2, 0xd3, 0xac, 0x62, 0x91, 0x95, 0xe4, 0x79, 0xe7, 0xc8, 0x37, 0x6d, 0x8d, 0xd5, 0x4e, 0xa9, 0x6c, 0x56, 0xf4, 0xea, 0x65, 0x7a, 0xae, 0x08, 0xba, 0x78, 0x25, 0x2e, 0x1c, 0xa6, 0xb4, 0xc6, 0xe8, 0xdd, 0x74, 0x1f, 0x4b, 0xbd, 0x8b, 0x8a, 0x70, 0x3e, 0xb5, 0x66, 0x48, 0x03, 0xf6, 0x0e, 0x61, 0x35, 0x57, 0xb9, 0x86, 0xc1, 0x1d, 0x9e, 0xe1, 0xf8, 0x98, 0x11, 0x69, 0xd9, 0x8e, 0x94, 0x9b, 0x1e, 0x87, 0xe9, 0xce, 0x55, 0x28, 0xdf, 0x8c, 0xa1, 0x89, 0x0d, 0xbf, 0xe6, 0x42, 0x68, 0x41, 0x99, 0x2d, 0x0f, 0xb0, 0x54, 0xbb, 0x16];\n\t    var Si =[0x52, 0x09, 0x6a, 0xd5, 0x30, 0x36, 0xa5, 0x38, 0xbf, 0x40, 0xa3, 0x9e, 0x81, 0xf3, 0xd7, 0xfb, 0x7c, 0xe3, 0x39, 0x82, 0x9b, 0x2f, 0xff, 0x87, 0x34, 0x8e, 0x43, 0x44, 0xc4, 0xde, 0xe9, 0xcb, 0x54, 0x7b, 0x94, 0x32, 0xa6, 0xc2, 0x23, 0x3d, 0xee, 0x4c, 0x95, 0x0b, 0x42, 0xfa, 0xc3, 0x4e, 0x08, 0x2e, 0xa1, 0x66, 0x28, 0xd9, 0x24, 0xb2, 0x76, 0x5b, 0xa2, 0x49, 0x6d, 0x8b, 0xd1, 0x25, 0x72, 0xf8, 0xf6, 0x64, 0x86, 0x68, 0x98, 0x16, 0xd4, 0xa4, 0x5c, 0xcc, 0x5d, 0x65, 0xb6, 0x92, 0x6c, 0x70, 0x48, 0x50, 0xfd, 0xed, 0xb9, 0xda, 0x5e, 0x15, 0x46, 0x57, 0xa7, 0x8d, 0x9d, 0x84, 0x90, 0xd8, 0xab, 0x00, 0x8c, 0xbc, 0xd3, 0x0a, 0xf7, 0xe4, 0x58, 0x05, 0xb8, 0xb3, 0x45, 0x06, 0xd0, 0x2c, 0x1e, 0x8f, 0xca, 0x3f, 0x0f, 0x02, 0xc1, 0xaf, 0xbd, 0x03, 0x01, 0x13, 0x8a, 0x6b, 0x3a, 0x91, 0x11, 0x41, 0x4f, 0x67, 0xdc, 0xea, 0x97, 0xf2, 0xcf, 0xce, 0xf0, 0xb4, 0xe6, 0x73, 0x96, 0xac, 0x74, 0x22, 0xe7, 0xad, 0x35, 0x85, 0xe2, 0xf9, 0x37, 0xe8, 0x1c, 0x75, 0xdf, 0x6e, 0x47, 0xf1, 0x1a, 0x71, 0x1d, 0x29, 0xc5, 0x89, 0x6f, 0xb7, 0x62, 0x0e, 0xaa, 0x18, 0xbe, 0x1b, 0xfc, 0x56, 0x3e, 0x4b, 0xc6, 0xd2, 0x79, 0x20, 0x9a, 0xdb, 0xc0, 0xfe, 0x78, 0xcd, 0x5a, 0xf4, 0x1f, 0xdd, 0xa8, 0x33, 0x88, 0x07, 0xc7, 0x31, 0xb1, 0x12, 0x10, 0x59, 0x27, 0x80, 0xec, 0x5f, 0x60, 0x51, 0x7f, 0xa9, 0x19, 0xb5, 0x4a, 0x0d, 0x2d, 0xe5, 0x7a, 0x9f, 0x93, 0xc9, 0x9c, 0xef, 0xa0, 0xe0, 0x3b, 0x4d, 0xae, 0x2a, 0xf5, 0xb0, 0xc8, 0xeb, 0xbb, 0x3c, 0x83, 0x53, 0x99, 0x61, 0x17, 0x2b, 0x04, 0x7e, 0xba, 0x77, 0xd6, 0x26, 0xe1, 0x69, 0x14, 0x63, 0x55, 0x21, 0x0c, 0x7d];\n\n\t    // Transformations for encryption\n\t    var T1 = [0xc66363a5, 0xf87c7c84, 0xee777799, 0xf67b7b8d, 0xfff2f20d, 0xd66b6bbd, 0xde6f6fb1, 0x91c5c554, 0x60303050, 0x02010103, 0xce6767a9, 0x562b2b7d, 0xe7fefe19, 0xb5d7d762, 0x4dababe6, 0xec76769a, 0x8fcaca45, 0x1f82829d, 0x89c9c940, 0xfa7d7d87, 0xeffafa15, 0xb25959eb, 0x8e4747c9, 0xfbf0f00b, 0x41adadec, 0xb3d4d467, 0x5fa2a2fd, 0x45afafea, 0x239c9cbf, 0x53a4a4f7, 0xe4727296, 0x9bc0c05b, 0x75b7b7c2, 0xe1fdfd1c, 0x3d9393ae, 0x4c26266a, 0x6c36365a, 0x7e3f3f41, 0xf5f7f702, 0x83cccc4f, 0x6834345c, 0x51a5a5f4, 0xd1e5e534, 0xf9f1f108, 0xe2717193, 0xabd8d873, 0x62313153, 0x2a15153f, 0x0804040c, 0x95c7c752, 0x46232365, 0x9dc3c35e, 0x30181828, 0x379696a1, 0x0a05050f, 0x2f9a9ab5, 0x0e070709, 0x24121236, 0x1b80809b, 0xdfe2e23d, 0xcdebeb26, 0x4e272769, 0x7fb2b2cd, 0xea75759f, 0x1209091b, 0x1d83839e, 0x582c2c74, 0x341a1a2e, 0x361b1b2d, 0xdc6e6eb2, 0xb45a5aee, 0x5ba0a0fb, 0xa45252f6, 0x763b3b4d, 0xb7d6d661, 0x7db3b3ce, 0x5229297b, 0xdde3e33e, 0x5e2f2f71, 0x13848497, 0xa65353f5, 0xb9d1d168, 0x00000000, 0xc1eded2c, 0x40202060, 0xe3fcfc1f, 0x79b1b1c8, 0xb65b5bed, 0xd46a6abe, 0x8dcbcb46, 0x67bebed9, 0x7239394b, 0x944a4ade, 0x984c4cd4, 0xb05858e8, 0x85cfcf4a, 0xbbd0d06b, 0xc5efef2a, 0x4faaaae5, 0xedfbfb16, 0x864343c5, 0x9a4d4dd7, 0x66333355, 0x11858594, 0x8a4545cf, 0xe9f9f910, 0x04020206, 0xfe7f7f81, 0xa05050f0, 0x783c3c44, 0x259f9fba, 0x4ba8a8e3, 0xa25151f3, 0x5da3a3fe, 0x804040c0, 0x058f8f8a, 0x3f9292ad, 0x219d9dbc, 0x70383848, 0xf1f5f504, 0x63bcbcdf, 0x77b6b6c1, 0xafdada75, 0x42212163, 0x20101030, 0xe5ffff1a, 0xfdf3f30e, 0xbfd2d26d, 0x81cdcd4c, 0x180c0c14, 0x26131335, 0xc3ecec2f, 0xbe5f5fe1, 0x359797a2, 0x884444cc, 0x2e171739, 0x93c4c457, 0x55a7a7f2, 0xfc7e7e82, 0x7a3d3d47, 0xc86464ac, 0xba5d5de7, 0x3219192b, 0xe6737395, 0xc06060a0, 0x19818198, 0x9e4f4fd1, 0xa3dcdc7f, 0x44222266, 0x542a2a7e, 0x3b9090ab, 0x0b888883, 0x8c4646ca, 0xc7eeee29, 0x6bb8b8d3, 0x2814143c, 0xa7dede79, 0xbc5e5ee2, 0x160b0b1d, 0xaddbdb76, 0xdbe0e03b, 0x64323256, 0x743a3a4e, 0x140a0a1e, 0x924949db, 0x0c06060a, 0x4824246c, 0xb85c5ce4, 0x9fc2c25d, 0xbdd3d36e, 0x43acacef, 0xc46262a6, 0x399191a8, 0x319595a4, 0xd3e4e437, 0xf279798b, 0xd5e7e732, 0x8bc8c843, 0x6e373759, 0xda6d6db7, 0x018d8d8c, 0xb1d5d564, 0x9c4e4ed2, 0x49a9a9e0, 0xd86c6cb4, 0xac5656fa, 0xf3f4f407, 0xcfeaea25, 0xca6565af, 0xf47a7a8e, 0x47aeaee9, 0x10080818, 0x6fbabad5, 0xf0787888, 0x4a25256f, 0x5c2e2e72, 0x381c1c24, 0x57a6a6f1, 0x73b4b4c7, 0x97c6c651, 0xcbe8e823, 0xa1dddd7c, 0xe874749c, 0x3e1f1f21, 0x964b4bdd, 0x61bdbddc, 0x0d8b8b86, 0x0f8a8a85, 0xe0707090, 0x7c3e3e42, 0x71b5b5c4, 0xcc6666aa, 0x904848d8, 0x06030305, 0xf7f6f601, 0x1c0e0e12, 0xc26161a3, 0x6a35355f, 0xae5757f9, 0x69b9b9d0, 0x17868691, 0x99c1c158, 0x3a1d1d27, 0x279e9eb9, 0xd9e1e138, 0xebf8f813, 0x2b9898b3, 0x22111133, 0xd26969bb, 0xa9d9d970, 0x078e8e89, 0x339494a7, 0x2d9b9bb6, 0x3c1e1e22, 0x15878792, 0xc9e9e920, 0x87cece49, 0xaa5555ff, 0x50282878, 0xa5dfdf7a, 0x038c8c8f, 0x59a1a1f8, 0x09898980, 0x1a0d0d17, 0x65bfbfda, 0xd7e6e631, 0x844242c6, 0xd06868b8, 0x824141c3, 0x299999b0, 0x5a2d2d77, 0x1e0f0f11, 0x7bb0b0cb, 0xa85454fc, 0x6dbbbbd6, 0x2c16163a];\n\t    var T2 = [0xa5c66363, 0x84f87c7c, 0x99ee7777, 0x8df67b7b, 0x0dfff2f2, 0xbdd66b6b, 0xb1de6f6f, 0x5491c5c5, 0x50603030, 0x03020101, 0xa9ce6767, 0x7d562b2b, 0x19e7fefe, 0x62b5d7d7, 0xe64dabab, 0x9aec7676, 0x458fcaca, 0x9d1f8282, 0x4089c9c9, 0x87fa7d7d, 0x15effafa, 0xebb25959, 0xc98e4747, 0x0bfbf0f0, 0xec41adad, 0x67b3d4d4, 0xfd5fa2a2, 0xea45afaf, 0xbf239c9c, 0xf753a4a4, 0x96e47272, 0x5b9bc0c0, 0xc275b7b7, 0x1ce1fdfd, 0xae3d9393, 0x6a4c2626, 0x5a6c3636, 0x417e3f3f, 0x02f5f7f7, 0x4f83cccc, 0x5c683434, 0xf451a5a5, 0x34d1e5e5, 0x08f9f1f1, 0x93e27171, 0x73abd8d8, 0x53623131, 0x3f2a1515, 0x0c080404, 0x5295c7c7, 0x65462323, 0x5e9dc3c3, 0x28301818, 0xa1379696, 0x0f0a0505, 0xb52f9a9a, 0x090e0707, 0x36241212, 0x9b1b8080, 0x3ddfe2e2, 0x26cdebeb, 0x694e2727, 0xcd7fb2b2, 0x9fea7575, 0x1b120909, 0x9e1d8383, 0x74582c2c, 0x2e341a1a, 0x2d361b1b, 0xb2dc6e6e, 0xeeb45a5a, 0xfb5ba0a0, 0xf6a45252, 0x4d763b3b, 0x61b7d6d6, 0xce7db3b3, 0x7b522929, 0x3edde3e3, 0x715e2f2f, 0x97138484, 0xf5a65353, 0x68b9d1d1, 0x00000000, 0x2cc1eded, 0x60402020, 0x1fe3fcfc, 0xc879b1b1, 0xedb65b5b, 0xbed46a6a, 0x468dcbcb, 0xd967bebe, 0x4b723939, 0xde944a4a, 0xd4984c4c, 0xe8b05858, 0x4a85cfcf, 0x6bbbd0d0, 0x2ac5efef, 0xe54faaaa, 0x16edfbfb, 0xc5864343, 0xd79a4d4d, 0x55663333, 0x94118585, 0xcf8a4545, 0x10e9f9f9, 0x06040202, 0x81fe7f7f, 0xf0a05050, 0x44783c3c, 0xba259f9f, 0xe34ba8a8, 0xf3a25151, 0xfe5da3a3, 0xc0804040, 0x8a058f8f, 0xad3f9292, 0xbc219d9d, 0x48703838, 0x04f1f5f5, 0xdf63bcbc, 0xc177b6b6, 0x75afdada, 0x63422121, 0x30201010, 0x1ae5ffff, 0x0efdf3f3, 0x6dbfd2d2, 0x4c81cdcd, 0x14180c0c, 0x35261313, 0x2fc3ecec, 0xe1be5f5f, 0xa2359797, 0xcc884444, 0x392e1717, 0x5793c4c4, 0xf255a7a7, 0x82fc7e7e, 0x477a3d3d, 0xacc86464, 0xe7ba5d5d, 0x2b321919, 0x95e67373, 0xa0c06060, 0x98198181, 0xd19e4f4f, 0x7fa3dcdc, 0x66442222, 0x7e542a2a, 0xab3b9090, 0x830b8888, 0xca8c4646, 0x29c7eeee, 0xd36bb8b8, 0x3c281414, 0x79a7dede, 0xe2bc5e5e, 0x1d160b0b, 0x76addbdb, 0x3bdbe0e0, 0x56643232, 0x4e743a3a, 0x1e140a0a, 0xdb924949, 0x0a0c0606, 0x6c482424, 0xe4b85c5c, 0x5d9fc2c2, 0x6ebdd3d3, 0xef43acac, 0xa6c46262, 0xa8399191, 0xa4319595, 0x37d3e4e4, 0x8bf27979, 0x32d5e7e7, 0x438bc8c8, 0x596e3737, 0xb7da6d6d, 0x8c018d8d, 0x64b1d5d5, 0xd29c4e4e, 0xe049a9a9, 0xb4d86c6c, 0xfaac5656, 0x07f3f4f4, 0x25cfeaea, 0xafca6565, 0x8ef47a7a, 0xe947aeae, 0x18100808, 0xd56fbaba, 0x88f07878, 0x6f4a2525, 0x725c2e2e, 0x24381c1c, 0xf157a6a6, 0xc773b4b4, 0x5197c6c6, 0x23cbe8e8, 0x7ca1dddd, 0x9ce87474, 0x213e1f1f, 0xdd964b4b, 0xdc61bdbd, 0x860d8b8b, 0x850f8a8a, 0x90e07070, 0x427c3e3e, 0xc471b5b5, 0xaacc6666, 0xd8904848, 0x05060303, 0x01f7f6f6, 0x121c0e0e, 0xa3c26161, 0x5f6a3535, 0xf9ae5757, 0xd069b9b9, 0x91178686, 0x5899c1c1, 0x273a1d1d, 0xb9279e9e, 0x38d9e1e1, 0x13ebf8f8, 0xb32b9898, 0x33221111, 0xbbd26969, 0x70a9d9d9, 0x89078e8e, 0xa7339494, 0xb62d9b9b, 0x223c1e1e, 0x92158787, 0x20c9e9e9, 0x4987cece, 0xffaa5555, 0x78502828, 0x7aa5dfdf, 0x8f038c8c, 0xf859a1a1, 0x80098989, 0x171a0d0d, 0xda65bfbf, 0x31d7e6e6, 0xc6844242, 0xb8d06868, 0xc3824141, 0xb0299999, 0x775a2d2d, 0x111e0f0f, 0xcb7bb0b0, 0xfca85454, 0xd66dbbbb, 0x3a2c1616];\n\t    var T3 = [0x63a5c663, 0x7c84f87c, 0x7799ee77, 0x7b8df67b, 0xf20dfff2, 0x6bbdd66b, 0x6fb1de6f, 0xc55491c5, 0x30506030, 0x01030201, 0x67a9ce67, 0x2b7d562b, 0xfe19e7fe, 0xd762b5d7, 0xabe64dab, 0x769aec76, 0xca458fca, 0x829d1f82, 0xc94089c9, 0x7d87fa7d, 0xfa15effa, 0x59ebb259, 0x47c98e47, 0xf00bfbf0, 0xadec41ad, 0xd467b3d4, 0xa2fd5fa2, 0xafea45af, 0x9cbf239c, 0xa4f753a4, 0x7296e472, 0xc05b9bc0, 0xb7c275b7, 0xfd1ce1fd, 0x93ae3d93, 0x266a4c26, 0x365a6c36, 0x3f417e3f, 0xf702f5f7, 0xcc4f83cc, 0x345c6834, 0xa5f451a5, 0xe534d1e5, 0xf108f9f1, 0x7193e271, 0xd873abd8, 0x31536231, 0x153f2a15, 0x040c0804, 0xc75295c7, 0x23654623, 0xc35e9dc3, 0x18283018, 0x96a13796, 0x050f0a05, 0x9ab52f9a, 0x07090e07, 0x12362412, 0x809b1b80, 0xe23ddfe2, 0xeb26cdeb, 0x27694e27, 0xb2cd7fb2, 0x759fea75, 0x091b1209, 0x839e1d83, 0x2c74582c, 0x1a2e341a, 0x1b2d361b, 0x6eb2dc6e, 0x5aeeb45a, 0xa0fb5ba0, 0x52f6a452, 0x3b4d763b, 0xd661b7d6, 0xb3ce7db3, 0x297b5229, 0xe33edde3, 0x2f715e2f, 0x84971384, 0x53f5a653, 0xd168b9d1, 0x00000000, 0xed2cc1ed, 0x20604020, 0xfc1fe3fc, 0xb1c879b1, 0x5bedb65b, 0x6abed46a, 0xcb468dcb, 0xbed967be, 0x394b7239, 0x4ade944a, 0x4cd4984c, 0x58e8b058, 0xcf4a85cf, 0xd06bbbd0, 0xef2ac5ef, 0xaae54faa, 0xfb16edfb, 0x43c58643, 0x4dd79a4d, 0x33556633, 0x85941185, 0x45cf8a45, 0xf910e9f9, 0x02060402, 0x7f81fe7f, 0x50f0a050, 0x3c44783c, 0x9fba259f, 0xa8e34ba8, 0x51f3a251, 0xa3fe5da3, 0x40c08040, 0x8f8a058f, 0x92ad3f92, 0x9dbc219d, 0x38487038, 0xf504f1f5, 0xbcdf63bc, 0xb6c177b6, 0xda75afda, 0x21634221, 0x10302010, 0xff1ae5ff, 0xf30efdf3, 0xd26dbfd2, 0xcd4c81cd, 0x0c14180c, 0x13352613, 0xec2fc3ec, 0x5fe1be5f, 0x97a23597, 0x44cc8844, 0x17392e17, 0xc45793c4, 0xa7f255a7, 0x7e82fc7e, 0x3d477a3d, 0x64acc864, 0x5de7ba5d, 0x192b3219, 0x7395e673, 0x60a0c060, 0x81981981, 0x4fd19e4f, 0xdc7fa3dc, 0x22664422, 0x2a7e542a, 0x90ab3b90, 0x88830b88, 0x46ca8c46, 0xee29c7ee, 0xb8d36bb8, 0x143c2814, 0xde79a7de, 0x5ee2bc5e, 0x0b1d160b, 0xdb76addb, 0xe03bdbe0, 0x32566432, 0x3a4e743a, 0x0a1e140a, 0x49db9249, 0x060a0c06, 0x246c4824, 0x5ce4b85c, 0xc25d9fc2, 0xd36ebdd3, 0xacef43ac, 0x62a6c462, 0x91a83991, 0x95a43195, 0xe437d3e4, 0x798bf279, 0xe732d5e7, 0xc8438bc8, 0x37596e37, 0x6db7da6d, 0x8d8c018d, 0xd564b1d5, 0x4ed29c4e, 0xa9e049a9, 0x6cb4d86c, 0x56faac56, 0xf407f3f4, 0xea25cfea, 0x65afca65, 0x7a8ef47a, 0xaee947ae, 0x08181008, 0xbad56fba, 0x7888f078, 0x256f4a25, 0x2e725c2e, 0x1c24381c, 0xa6f157a6, 0xb4c773b4, 0xc65197c6, 0xe823cbe8, 0xdd7ca1dd, 0x749ce874, 0x1f213e1f, 0x4bdd964b, 0xbddc61bd, 0x8b860d8b, 0x8a850f8a, 0x7090e070, 0x3e427c3e, 0xb5c471b5, 0x66aacc66, 0x48d89048, 0x03050603, 0xf601f7f6, 0x0e121c0e, 0x61a3c261, 0x355f6a35, 0x57f9ae57, 0xb9d069b9, 0x86911786, 0xc15899c1, 0x1d273a1d, 0x9eb9279e, 0xe138d9e1, 0xf813ebf8, 0x98b32b98, 0x11332211, 0x69bbd269, 0xd970a9d9, 0x8e89078e, 0x94a73394, 0x9bb62d9b, 0x1e223c1e, 0x87921587, 0xe920c9e9, 0xce4987ce, 0x55ffaa55, 0x28785028, 0xdf7aa5df, 0x8c8f038c, 0xa1f859a1, 0x89800989, 0x0d171a0d, 0xbfda65bf, 0xe631d7e6, 0x42c68442, 0x68b8d068, 0x41c38241, 0x99b02999, 0x2d775a2d, 0x0f111e0f, 0xb0cb7bb0, 0x54fca854, 0xbbd66dbb, 0x163a2c16];\n\t    var T4 = [0x6363a5c6, 0x7c7c84f8, 0x777799ee, 0x7b7b8df6, 0xf2f20dff, 0x6b6bbdd6, 0x6f6fb1de, 0xc5c55491, 0x30305060, 0x01010302, 0x6767a9ce, 0x2b2b7d56, 0xfefe19e7, 0xd7d762b5, 0xababe64d, 0x76769aec, 0xcaca458f, 0x82829d1f, 0xc9c94089, 0x7d7d87fa, 0xfafa15ef, 0x5959ebb2, 0x4747c98e, 0xf0f00bfb, 0xadadec41, 0xd4d467b3, 0xa2a2fd5f, 0xafafea45, 0x9c9cbf23, 0xa4a4f753, 0x727296e4, 0xc0c05b9b, 0xb7b7c275, 0xfdfd1ce1, 0x9393ae3d, 0x26266a4c, 0x36365a6c, 0x3f3f417e, 0xf7f702f5, 0xcccc4f83, 0x34345c68, 0xa5a5f451, 0xe5e534d1, 0xf1f108f9, 0x717193e2, 0xd8d873ab, 0x31315362, 0x15153f2a, 0x04040c08, 0xc7c75295, 0x23236546, 0xc3c35e9d, 0x18182830, 0x9696a137, 0x05050f0a, 0x9a9ab52f, 0x0707090e, 0x12123624, 0x80809b1b, 0xe2e23ddf, 0xebeb26cd, 0x2727694e, 0xb2b2cd7f, 0x75759fea, 0x09091b12, 0x83839e1d, 0x2c2c7458, 0x1a1a2e34, 0x1b1b2d36, 0x6e6eb2dc, 0x5a5aeeb4, 0xa0a0fb5b, 0x5252f6a4, 0x3b3b4d76, 0xd6d661b7, 0xb3b3ce7d, 0x29297b52, 0xe3e33edd, 0x2f2f715e, 0x84849713, 0x5353f5a6, 0xd1d168b9, 0x00000000, 0xeded2cc1, 0x20206040, 0xfcfc1fe3, 0xb1b1c879, 0x5b5bedb6, 0x6a6abed4, 0xcbcb468d, 0xbebed967, 0x39394b72, 0x4a4ade94, 0x4c4cd498, 0x5858e8b0, 0xcfcf4a85, 0xd0d06bbb, 0xefef2ac5, 0xaaaae54f, 0xfbfb16ed, 0x4343c586, 0x4d4dd79a, 0x33335566, 0x85859411, 0x4545cf8a, 0xf9f910e9, 0x02020604, 0x7f7f81fe, 0x5050f0a0, 0x3c3c4478, 0x9f9fba25, 0xa8a8e34b, 0x5151f3a2, 0xa3a3fe5d, 0x4040c080, 0x8f8f8a05, 0x9292ad3f, 0x9d9dbc21, 0x38384870, 0xf5f504f1, 0xbcbcdf63, 0xb6b6c177, 0xdada75af, 0x21216342, 0x10103020, 0xffff1ae5, 0xf3f30efd, 0xd2d26dbf, 0xcdcd4c81, 0x0c0c1418, 0x13133526, 0xecec2fc3, 0x5f5fe1be, 0x9797a235, 0x4444cc88, 0x1717392e, 0xc4c45793, 0xa7a7f255, 0x7e7e82fc, 0x3d3d477a, 0x6464acc8, 0x5d5de7ba, 0x19192b32, 0x737395e6, 0x6060a0c0, 0x81819819, 0x4f4fd19e, 0xdcdc7fa3, 0x22226644, 0x2a2a7e54, 0x9090ab3b, 0x8888830b, 0x4646ca8c, 0xeeee29c7, 0xb8b8d36b, 0x14143c28, 0xdede79a7, 0x5e5ee2bc, 0x0b0b1d16, 0xdbdb76ad, 0xe0e03bdb, 0x32325664, 0x3a3a4e74, 0x0a0a1e14, 0x4949db92, 0x06060a0c, 0x24246c48, 0x5c5ce4b8, 0xc2c25d9f, 0xd3d36ebd, 0xacacef43, 0x6262a6c4, 0x9191a839, 0x9595a431, 0xe4e437d3, 0x79798bf2, 0xe7e732d5, 0xc8c8438b, 0x3737596e, 0x6d6db7da, 0x8d8d8c01, 0xd5d564b1, 0x4e4ed29c, 0xa9a9e049, 0x6c6cb4d8, 0x5656faac, 0xf4f407f3, 0xeaea25cf, 0x6565afca, 0x7a7a8ef4, 0xaeaee947, 0x08081810, 0xbabad56f, 0x787888f0, 0x25256f4a, 0x2e2e725c, 0x1c1c2438, 0xa6a6f157, 0xb4b4c773, 0xc6c65197, 0xe8e823cb, 0xdddd7ca1, 0x74749ce8, 0x1f1f213e, 0x4b4bdd96, 0xbdbddc61, 0x8b8b860d, 0x8a8a850f, 0x707090e0, 0x3e3e427c, 0xb5b5c471, 0x6666aacc, 0x4848d890, 0x03030506, 0xf6f601f7, 0x0e0e121c, 0x6161a3c2, 0x35355f6a, 0x5757f9ae, 0xb9b9d069, 0x86869117, 0xc1c15899, 0x1d1d273a, 0x9e9eb927, 0xe1e138d9, 0xf8f813eb, 0x9898b32b, 0x11113322, 0x6969bbd2, 0xd9d970a9, 0x8e8e8907, 0x9494a733, 0x9b9bb62d, 0x1e1e223c, 0x87879215, 0xe9e920c9, 0xcece4987, 0x5555ffaa, 0x28287850, 0xdfdf7aa5, 0x8c8c8f03, 0xa1a1f859, 0x89898009, 0x0d0d171a, 0xbfbfda65, 0xe6e631d7, 0x4242c684, 0x6868b8d0, 0x4141c382, 0x9999b029, 0x2d2d775a, 0x0f0f111e, 0xb0b0cb7b, 0x5454fca8, 0xbbbbd66d, 0x16163a2c];\n\n\t    // Transformations for decryption\n\t    var T5 = [0x51f4a750, 0x7e416553, 0x1a17a4c3, 0x3a275e96, 0x3bab6bcb, 0x1f9d45f1, 0xacfa58ab, 0x4be30393, 0x2030fa55, 0xad766df6, 0x88cc7691, 0xf5024c25, 0x4fe5d7fc, 0xc52acbd7, 0x26354480, 0xb562a38f, 0xdeb15a49, 0x25ba1b67, 0x45ea0e98, 0x5dfec0e1, 0xc32f7502, 0x814cf012, 0x8d4697a3, 0x6bd3f9c6, 0x038f5fe7, 0x15929c95, 0xbf6d7aeb, 0x955259da, 0xd4be832d, 0x587421d3, 0x49e06929, 0x8ec9c844, 0x75c2896a, 0xf48e7978, 0x99583e6b, 0x27b971dd, 0xbee14fb6, 0xf088ad17, 0xc920ac66, 0x7dce3ab4, 0x63df4a18, 0xe51a3182, 0x97513360, 0x62537f45, 0xb16477e0, 0xbb6bae84, 0xfe81a01c, 0xf9082b94, 0x70486858, 0x8f45fd19, 0x94de6c87, 0x527bf8b7, 0xab73d323, 0x724b02e2, 0xe31f8f57, 0x6655ab2a, 0xb2eb2807, 0x2fb5c203, 0x86c57b9a, 0xd33708a5, 0x302887f2, 0x23bfa5b2, 0x02036aba, 0xed16825c, 0x8acf1c2b, 0xa779b492, 0xf307f2f0, 0x4e69e2a1, 0x65daf4cd, 0x0605bed5, 0xd134621f, 0xc4a6fe8a, 0x342e539d, 0xa2f355a0, 0x058ae132, 0xa4f6eb75, 0x0b83ec39, 0x4060efaa, 0x5e719f06, 0xbd6e1051, 0x3e218af9, 0x96dd063d, 0xdd3e05ae, 0x4de6bd46, 0x91548db5, 0x71c45d05, 0x0406d46f, 0x605015ff, 0x1998fb24, 0xd6bde997, 0x894043cc, 0x67d99e77, 0xb0e842bd, 0x07898b88, 0xe7195b38, 0x79c8eedb, 0xa17c0a47, 0x7c420fe9, 0xf8841ec9, 0x00000000, 0x09808683, 0x322bed48, 0x1e1170ac, 0x6c5a724e, 0xfd0efffb, 0x0f853856, 0x3daed51e, 0x362d3927, 0x0a0fd964, 0x685ca621, 0x9b5b54d1, 0x24362e3a, 0x0c0a67b1, 0x9357e70f, 0xb4ee96d2, 0x1b9b919e, 0x80c0c54f, 0x61dc20a2, 0x5a774b69, 0x1c121a16, 0xe293ba0a, 0xc0a02ae5, 0x3c22e043, 0x121b171d, 0x0e090d0b, 0xf28bc7ad, 0x2db6a8b9, 0x141ea9c8, 0x57f11985, 0xaf75074c, 0xee99ddbb, 0xa37f60fd, 0xf701269f, 0x5c72f5bc, 0x44663bc5, 0x5bfb7e34, 0x8b432976, 0xcb23c6dc, 0xb6edfc68, 0xb8e4f163, 0xd731dcca, 0x42638510, 0x13972240, 0x84c61120, 0x854a247d, 0xd2bb3df8, 0xaef93211, 0xc729a16d, 0x1d9e2f4b, 0xdcb230f3, 0x0d8652ec, 0x77c1e3d0, 0x2bb3166c, 0xa970b999, 0x119448fa, 0x47e96422, 0xa8fc8cc4, 0xa0f03f1a, 0x567d2cd8, 0x223390ef, 0x87494ec7, 0xd938d1c1, 0x8ccaa2fe, 0x98d40b36, 0xa6f581cf, 0xa57ade28, 0xdab78e26, 0x3fadbfa4, 0x2c3a9de4, 0x5078920d, 0x6a5fcc9b, 0x547e4662, 0xf68d13c2, 0x90d8b8e8, 0x2e39f75e, 0x82c3aff5, 0x9f5d80be, 0x69d0937c, 0x6fd52da9, 0xcf2512b3, 0xc8ac993b, 0x10187da7, 0xe89c636e, 0xdb3bbb7b, 0xcd267809, 0x6e5918f4, 0xec9ab701, 0x834f9aa8, 0xe6956e65, 0xaaffe67e, 0x21bccf08, 0xef15e8e6, 0xbae79bd9, 0x4a6f36ce, 0xea9f09d4, 0x29b07cd6, 0x31a4b2af, 0x2a3f2331, 0xc6a59430, 0x35a266c0, 0x744ebc37, 0xfc82caa6, 0xe090d0b0, 0x33a7d815, 0xf104984a, 0x41ecdaf7, 0x7fcd500e, 0x1791f62f, 0x764dd68d, 0x43efb04d, 0xccaa4d54, 0xe49604df, 0x9ed1b5e3, 0x4c6a881b, 0xc12c1fb8, 0x4665517f, 0x9d5eea04, 0x018c355d, 0xfa877473, 0xfb0b412e, 0xb3671d5a, 0x92dbd252, 0xe9105633, 0x6dd64713, 0x9ad7618c, 0x37a10c7a, 0x59f8148e, 0xeb133c89, 0xcea927ee, 0xb761c935, 0xe11ce5ed, 0x7a47b13c, 0x9cd2df59, 0x55f2733f, 0x1814ce79, 0x73c737bf, 0x53f7cdea, 0x5ffdaa5b, 0xdf3d6f14, 0x7844db86, 0xcaaff381, 0xb968c43e, 0x3824342c, 0xc2a3405f, 0x161dc372, 0xbce2250c, 0x283c498b, 0xff0d9541, 0x39a80171, 0x080cb3de, 0xd8b4e49c, 0x6456c190, 0x7bcb8461, 0xd532b670, 0x486c5c74, 0xd0b85742];\n\t    var T6 = [0x5051f4a7, 0x537e4165, 0xc31a17a4, 0x963a275e, 0xcb3bab6b, 0xf11f9d45, 0xabacfa58, 0x934be303, 0x552030fa, 0xf6ad766d, 0x9188cc76, 0x25f5024c, 0xfc4fe5d7, 0xd7c52acb, 0x80263544, 0x8fb562a3, 0x49deb15a, 0x6725ba1b, 0x9845ea0e, 0xe15dfec0, 0x02c32f75, 0x12814cf0, 0xa38d4697, 0xc66bd3f9, 0xe7038f5f, 0x9515929c, 0xebbf6d7a, 0xda955259, 0x2dd4be83, 0xd3587421, 0x2949e069, 0x448ec9c8, 0x6a75c289, 0x78f48e79, 0x6b99583e, 0xdd27b971, 0xb6bee14f, 0x17f088ad, 0x66c920ac, 0xb47dce3a, 0x1863df4a, 0x82e51a31, 0x60975133, 0x4562537f, 0xe0b16477, 0x84bb6bae, 0x1cfe81a0, 0x94f9082b, 0x58704868, 0x198f45fd, 0x8794de6c, 0xb7527bf8, 0x23ab73d3, 0xe2724b02, 0x57e31f8f, 0x2a6655ab, 0x07b2eb28, 0x032fb5c2, 0x9a86c57b, 0xa5d33708, 0xf2302887, 0xb223bfa5, 0xba02036a, 0x5ced1682, 0x2b8acf1c, 0x92a779b4, 0xf0f307f2, 0xa14e69e2, 0xcd65daf4, 0xd50605be, 0x1fd13462, 0x8ac4a6fe, 0x9d342e53, 0xa0a2f355, 0x32058ae1, 0x75a4f6eb, 0x390b83ec, 0xaa4060ef, 0x065e719f, 0x51bd6e10, 0xf93e218a, 0x3d96dd06, 0xaedd3e05, 0x464de6bd, 0xb591548d, 0x0571c45d, 0x6f0406d4, 0xff605015, 0x241998fb, 0x97d6bde9, 0xcc894043, 0x7767d99e, 0xbdb0e842, 0x8807898b, 0x38e7195b, 0xdb79c8ee, 0x47a17c0a, 0xe97c420f, 0xc9f8841e, 0x00000000, 0x83098086, 0x48322bed, 0xac1e1170, 0x4e6c5a72, 0xfbfd0eff, 0x560f8538, 0x1e3daed5, 0x27362d39, 0x640a0fd9, 0x21685ca6, 0xd19b5b54, 0x3a24362e, 0xb10c0a67, 0x0f9357e7, 0xd2b4ee96, 0x9e1b9b91, 0x4f80c0c5, 0xa261dc20, 0x695a774b, 0x161c121a, 0x0ae293ba, 0xe5c0a02a, 0x433c22e0, 0x1d121b17, 0x0b0e090d, 0xadf28bc7, 0xb92db6a8, 0xc8141ea9, 0x8557f119, 0x4caf7507, 0xbbee99dd, 0xfda37f60, 0x9ff70126, 0xbc5c72f5, 0xc544663b, 0x345bfb7e, 0x768b4329, 0xdccb23c6, 0x68b6edfc, 0x63b8e4f1, 0xcad731dc, 0x10426385, 0x40139722, 0x2084c611, 0x7d854a24, 0xf8d2bb3d, 0x11aef932, 0x6dc729a1, 0x4b1d9e2f, 0xf3dcb230, 0xec0d8652, 0xd077c1e3, 0x6c2bb316, 0x99a970b9, 0xfa119448, 0x2247e964, 0xc4a8fc8c, 0x1aa0f03f, 0xd8567d2c, 0xef223390, 0xc787494e, 0xc1d938d1, 0xfe8ccaa2, 0x3698d40b, 0xcfa6f581, 0x28a57ade, 0x26dab78e, 0xa43fadbf, 0xe42c3a9d, 0x0d507892, 0x9b6a5fcc, 0x62547e46, 0xc2f68d13, 0xe890d8b8, 0x5e2e39f7, 0xf582c3af, 0xbe9f5d80, 0x7c69d093, 0xa96fd52d, 0xb3cf2512, 0x3bc8ac99, 0xa710187d, 0x6ee89c63, 0x7bdb3bbb, 0x09cd2678, 0xf46e5918, 0x01ec9ab7, 0xa8834f9a, 0x65e6956e, 0x7eaaffe6, 0x0821bccf, 0xe6ef15e8, 0xd9bae79b, 0xce4a6f36, 0xd4ea9f09, 0xd629b07c, 0xaf31a4b2, 0x312a3f23, 0x30c6a594, 0xc035a266, 0x37744ebc, 0xa6fc82ca, 0xb0e090d0, 0x1533a7d8, 0x4af10498, 0xf741ecda, 0x0e7fcd50, 0x2f1791f6, 0x8d764dd6, 0x4d43efb0, 0x54ccaa4d, 0xdfe49604, 0xe39ed1b5, 0x1b4c6a88, 0xb8c12c1f, 0x7f466551, 0x049d5eea, 0x5d018c35, 0x73fa8774, 0x2efb0b41, 0x5ab3671d, 0x5292dbd2, 0x33e91056, 0x136dd647, 0x8c9ad761, 0x7a37a10c, 0x8e59f814, 0x89eb133c, 0xeecea927, 0x35b761c9, 0xede11ce5, 0x3c7a47b1, 0x599cd2df, 0x3f55f273, 0x791814ce, 0xbf73c737, 0xea53f7cd, 0x5b5ffdaa, 0x14df3d6f, 0x867844db, 0x81caaff3, 0x3eb968c4, 0x2c382434, 0x5fc2a340, 0x72161dc3, 0x0cbce225, 0x8b283c49, 0x41ff0d95, 0x7139a801, 0xde080cb3, 0x9cd8b4e4, 0x906456c1, 0x617bcb84, 0x70d532b6, 0x74486c5c, 0x42d0b857];\n\t    var T7 = [0xa75051f4, 0x65537e41, 0xa4c31a17, 0x5e963a27, 0x6bcb3bab, 0x45f11f9d, 0x58abacfa, 0x03934be3, 0xfa552030, 0x6df6ad76, 0x769188cc, 0x4c25f502, 0xd7fc4fe5, 0xcbd7c52a, 0x44802635, 0xa38fb562, 0x5a49deb1, 0x1b6725ba, 0x0e9845ea, 0xc0e15dfe, 0x7502c32f, 0xf012814c, 0x97a38d46, 0xf9c66bd3, 0x5fe7038f, 0x9c951592, 0x7aebbf6d, 0x59da9552, 0x832dd4be, 0x21d35874, 0x692949e0, 0xc8448ec9, 0x896a75c2, 0x7978f48e, 0x3e6b9958, 0x71dd27b9, 0x4fb6bee1, 0xad17f088, 0xac66c920, 0x3ab47dce, 0x4a1863df, 0x3182e51a, 0x33609751, 0x7f456253, 0x77e0b164, 0xae84bb6b, 0xa01cfe81, 0x2b94f908, 0x68587048, 0xfd198f45, 0x6c8794de, 0xf8b7527b, 0xd323ab73, 0x02e2724b, 0x8f57e31f, 0xab2a6655, 0x2807b2eb, 0xc2032fb5, 0x7b9a86c5, 0x08a5d337, 0x87f23028, 0xa5b223bf, 0x6aba0203, 0x825ced16, 0x1c2b8acf, 0xb492a779, 0xf2f0f307, 0xe2a14e69, 0xf4cd65da, 0xbed50605, 0x621fd134, 0xfe8ac4a6, 0x539d342e, 0x55a0a2f3, 0xe132058a, 0xeb75a4f6, 0xec390b83, 0xefaa4060, 0x9f065e71, 0x1051bd6e, 0x8af93e21, 0x063d96dd, 0x05aedd3e, 0xbd464de6, 0x8db59154, 0x5d0571c4, 0xd46f0406, 0x15ff6050, 0xfb241998, 0xe997d6bd, 0x43cc8940, 0x9e7767d9, 0x42bdb0e8, 0x8b880789, 0x5b38e719, 0xeedb79c8, 0x0a47a17c, 0x0fe97c42, 0x1ec9f884, 0x00000000, 0x86830980, 0xed48322b, 0x70ac1e11, 0x724e6c5a, 0xfffbfd0e, 0x38560f85, 0xd51e3dae, 0x3927362d, 0xd9640a0f, 0xa621685c, 0x54d19b5b, 0x2e3a2436, 0x67b10c0a, 0xe70f9357, 0x96d2b4ee, 0x919e1b9b, 0xc54f80c0, 0x20a261dc, 0x4b695a77, 0x1a161c12, 0xba0ae293, 0x2ae5c0a0, 0xe0433c22, 0x171d121b, 0x0d0b0e09, 0xc7adf28b, 0xa8b92db6, 0xa9c8141e, 0x198557f1, 0x074caf75, 0xddbbee99, 0x60fda37f, 0x269ff701, 0xf5bc5c72, 0x3bc54466, 0x7e345bfb, 0x29768b43, 0xc6dccb23, 0xfc68b6ed, 0xf163b8e4, 0xdccad731, 0x85104263, 0x22401397, 0x112084c6, 0x247d854a, 0x3df8d2bb, 0x3211aef9, 0xa16dc729, 0x2f4b1d9e, 0x30f3dcb2, 0x52ec0d86, 0xe3d077c1, 0x166c2bb3, 0xb999a970, 0x48fa1194, 0x642247e9, 0x8cc4a8fc, 0x3f1aa0f0, 0x2cd8567d, 0x90ef2233, 0x4ec78749, 0xd1c1d938, 0xa2fe8cca, 0x0b3698d4, 0x81cfa6f5, 0xde28a57a, 0x8e26dab7, 0xbfa43fad, 0x9de42c3a, 0x920d5078, 0xcc9b6a5f, 0x4662547e, 0x13c2f68d, 0xb8e890d8, 0xf75e2e39, 0xaff582c3, 0x80be9f5d, 0x937c69d0, 0x2da96fd5, 0x12b3cf25, 0x993bc8ac, 0x7da71018, 0x636ee89c, 0xbb7bdb3b, 0x7809cd26, 0x18f46e59, 0xb701ec9a, 0x9aa8834f, 0x6e65e695, 0xe67eaaff, 0xcf0821bc, 0xe8e6ef15, 0x9bd9bae7, 0x36ce4a6f, 0x09d4ea9f, 0x7cd629b0, 0xb2af31a4, 0x23312a3f, 0x9430c6a5, 0x66c035a2, 0xbc37744e, 0xcaa6fc82, 0xd0b0e090, 0xd81533a7, 0x984af104, 0xdaf741ec, 0x500e7fcd, 0xf62f1791, 0xd68d764d, 0xb04d43ef, 0x4d54ccaa, 0x04dfe496, 0xb5e39ed1, 0x881b4c6a, 0x1fb8c12c, 0x517f4665, 0xea049d5e, 0x355d018c, 0x7473fa87, 0x412efb0b, 0x1d5ab367, 0xd25292db, 0x5633e910, 0x47136dd6, 0x618c9ad7, 0x0c7a37a1, 0x148e59f8, 0x3c89eb13, 0x27eecea9, 0xc935b761, 0xe5ede11c, 0xb13c7a47, 0xdf599cd2, 0x733f55f2, 0xce791814, 0x37bf73c7, 0xcdea53f7, 0xaa5b5ffd, 0x6f14df3d, 0xdb867844, 0xf381caaf, 0xc43eb968, 0x342c3824, 0x405fc2a3, 0xc372161d, 0x250cbce2, 0x498b283c, 0x9541ff0d, 0x017139a8, 0xb3de080c, 0xe49cd8b4, 0xc1906456, 0x84617bcb, 0xb670d532, 0x5c74486c, 0x5742d0b8];\n\t    var T8 = [0xf4a75051, 0x4165537e, 0x17a4c31a, 0x275e963a, 0xab6bcb3b, 0x9d45f11f, 0xfa58abac, 0xe303934b, 0x30fa5520, 0x766df6ad, 0xcc769188, 0x024c25f5, 0xe5d7fc4f, 0x2acbd7c5, 0x35448026, 0x62a38fb5, 0xb15a49de, 0xba1b6725, 0xea0e9845, 0xfec0e15d, 0x2f7502c3, 0x4cf01281, 0x4697a38d, 0xd3f9c66b, 0x8f5fe703, 0x929c9515, 0x6d7aebbf, 0x5259da95, 0xbe832dd4, 0x7421d358, 0xe0692949, 0xc9c8448e, 0xc2896a75, 0x8e7978f4, 0x583e6b99, 0xb971dd27, 0xe14fb6be, 0x88ad17f0, 0x20ac66c9, 0xce3ab47d, 0xdf4a1863, 0x1a3182e5, 0x51336097, 0x537f4562, 0x6477e0b1, 0x6bae84bb, 0x81a01cfe, 0x082b94f9, 0x48685870, 0x45fd198f, 0xde6c8794, 0x7bf8b752, 0x73d323ab, 0x4b02e272, 0x1f8f57e3, 0x55ab2a66, 0xeb2807b2, 0xb5c2032f, 0xc57b9a86, 0x3708a5d3, 0x2887f230, 0xbfa5b223, 0x036aba02, 0x16825ced, 0xcf1c2b8a, 0x79b492a7, 0x07f2f0f3, 0x69e2a14e, 0xdaf4cd65, 0x05bed506, 0x34621fd1, 0xa6fe8ac4, 0x2e539d34, 0xf355a0a2, 0x8ae13205, 0xf6eb75a4, 0x83ec390b, 0x60efaa40, 0x719f065e, 0x6e1051bd, 0x218af93e, 0xdd063d96, 0x3e05aedd, 0xe6bd464d, 0x548db591, 0xc45d0571, 0x06d46f04, 0x5015ff60, 0x98fb2419, 0xbde997d6, 0x4043cc89, 0xd99e7767, 0xe842bdb0, 0x898b8807, 0x195b38e7, 0xc8eedb79, 0x7c0a47a1, 0x420fe97c, 0x841ec9f8, 0x00000000, 0x80868309, 0x2bed4832, 0x1170ac1e, 0x5a724e6c, 0x0efffbfd, 0x8538560f, 0xaed51e3d, 0x2d392736, 0x0fd9640a, 0x5ca62168, 0x5b54d19b, 0x362e3a24, 0x0a67b10c, 0x57e70f93, 0xee96d2b4, 0x9b919e1b, 0xc0c54f80, 0xdc20a261, 0x774b695a, 0x121a161c, 0x93ba0ae2, 0xa02ae5c0, 0x22e0433c, 0x1b171d12, 0x090d0b0e, 0x8bc7adf2, 0xb6a8b92d, 0x1ea9c814, 0xf1198557, 0x75074caf, 0x99ddbbee, 0x7f60fda3, 0x01269ff7, 0x72f5bc5c, 0x663bc544, 0xfb7e345b, 0x4329768b, 0x23c6dccb, 0xedfc68b6, 0xe4f163b8, 0x31dccad7, 0x63851042, 0x97224013, 0xc6112084, 0x4a247d85, 0xbb3df8d2, 0xf93211ae, 0x29a16dc7, 0x9e2f4b1d, 0xb230f3dc, 0x8652ec0d, 0xc1e3d077, 0xb3166c2b, 0x70b999a9, 0x9448fa11, 0xe9642247, 0xfc8cc4a8, 0xf03f1aa0, 0x7d2cd856, 0x3390ef22, 0x494ec787, 0x38d1c1d9, 0xcaa2fe8c, 0xd40b3698, 0xf581cfa6, 0x7ade28a5, 0xb78e26da, 0xadbfa43f, 0x3a9de42c, 0x78920d50, 0x5fcc9b6a, 0x7e466254, 0x8d13c2f6, 0xd8b8e890, 0x39f75e2e, 0xc3aff582, 0x5d80be9f, 0xd0937c69, 0xd52da96f, 0x2512b3cf, 0xac993bc8, 0x187da710, 0x9c636ee8, 0x3bbb7bdb, 0x267809cd, 0x5918f46e, 0x9ab701ec, 0x4f9aa883, 0x956e65e6, 0xffe67eaa, 0xbccf0821, 0x15e8e6ef, 0xe79bd9ba, 0x6f36ce4a, 0x9f09d4ea, 0xb07cd629, 0xa4b2af31, 0x3f23312a, 0xa59430c6, 0xa266c035, 0x4ebc3774, 0x82caa6fc, 0x90d0b0e0, 0xa7d81533, 0x04984af1, 0xecdaf741, 0xcd500e7f, 0x91f62f17, 0x4dd68d76, 0xefb04d43, 0xaa4d54cc, 0x9604dfe4, 0xd1b5e39e, 0x6a881b4c, 0x2c1fb8c1, 0x65517f46, 0x5eea049d, 0x8c355d01, 0x877473fa, 0x0b412efb, 0x671d5ab3, 0xdbd25292, 0x105633e9, 0xd647136d, 0xd7618c9a, 0xa10c7a37, 0xf8148e59, 0x133c89eb, 0xa927eece, 0x61c935b7, 0x1ce5ede1, 0x47b13c7a, 0xd2df599c, 0xf2733f55, 0x14ce7918, 0xc737bf73, 0xf7cdea53, 0xfdaa5b5f, 0x3d6f14df, 0x44db8678, 0xaff381ca, 0x68c43eb9, 0x24342c38, 0xa3405fc2, 0x1dc37216, 0xe2250cbc, 0x3c498b28, 0x0d9541ff, 0xa8017139, 0x0cb3de08, 0xb4e49cd8, 0x56c19064, 0xcb84617b, 0x32b670d5, 0x6c5c7448, 0xb85742d0];\n\n\t    // Transformations for decryption key expansion\n\t    var U1 = [0x00000000, 0x0e090d0b, 0x1c121a16, 0x121b171d, 0x3824342c, 0x362d3927, 0x24362e3a, 0x2a3f2331, 0x70486858, 0x7e416553, 0x6c5a724e, 0x62537f45, 0x486c5c74, 0x4665517f, 0x547e4662, 0x5a774b69, 0xe090d0b0, 0xee99ddbb, 0xfc82caa6, 0xf28bc7ad, 0xd8b4e49c, 0xd6bde997, 0xc4a6fe8a, 0xcaaff381, 0x90d8b8e8, 0x9ed1b5e3, 0x8ccaa2fe, 0x82c3aff5, 0xa8fc8cc4, 0xa6f581cf, 0xb4ee96d2, 0xbae79bd9, 0xdb3bbb7b, 0xd532b670, 0xc729a16d, 0xc920ac66, 0xe31f8f57, 0xed16825c, 0xff0d9541, 0xf104984a, 0xab73d323, 0xa57ade28, 0xb761c935, 0xb968c43e, 0x9357e70f, 0x9d5eea04, 0x8f45fd19, 0x814cf012, 0x3bab6bcb, 0x35a266c0, 0x27b971dd, 0x29b07cd6, 0x038f5fe7, 0x0d8652ec, 0x1f9d45f1, 0x119448fa, 0x4be30393, 0x45ea0e98, 0x57f11985, 0x59f8148e, 0x73c737bf, 0x7dce3ab4, 0x6fd52da9, 0x61dc20a2, 0xad766df6, 0xa37f60fd, 0xb16477e0, 0xbf6d7aeb, 0x955259da, 0x9b5b54d1, 0x894043cc, 0x87494ec7, 0xdd3e05ae, 0xd33708a5, 0xc12c1fb8, 0xcf2512b3, 0xe51a3182, 0xeb133c89, 0xf9082b94, 0xf701269f, 0x4de6bd46, 0x43efb04d, 0x51f4a750, 0x5ffdaa5b, 0x75c2896a, 0x7bcb8461, 0x69d0937c, 0x67d99e77, 0x3daed51e, 0x33a7d815, 0x21bccf08, 0x2fb5c203, 0x058ae132, 0x0b83ec39, 0x1998fb24, 0x1791f62f, 0x764dd68d, 0x7844db86, 0x6a5fcc9b, 0x6456c190, 0x4e69e2a1, 0x4060efaa, 0x527bf8b7, 0x5c72f5bc, 0x0605bed5, 0x080cb3de, 0x1a17a4c3, 0x141ea9c8, 0x3e218af9, 0x302887f2, 0x223390ef, 0x2c3a9de4, 0x96dd063d, 0x98d40b36, 0x8acf1c2b, 0x84c61120, 0xaef93211, 0xa0f03f1a, 0xb2eb2807, 0xbce2250c, 0xe6956e65, 0xe89c636e, 0xfa877473, 0xf48e7978, 0xdeb15a49, 0xd0b85742, 0xc2a3405f, 0xccaa4d54, 0x41ecdaf7, 0x4fe5d7fc, 0x5dfec0e1, 0x53f7cdea, 0x79c8eedb, 0x77c1e3d0, 0x65daf4cd, 0x6bd3f9c6, 0x31a4b2af, 0x3fadbfa4, 0x2db6a8b9, 0x23bfa5b2, 0x09808683, 0x07898b88, 0x15929c95, 0x1b9b919e, 0xa17c0a47, 0xaf75074c, 0xbd6e1051, 0xb3671d5a, 0x99583e6b, 0x97513360, 0x854a247d, 0x8b432976, 0xd134621f, 0xdf3d6f14, 0xcd267809, 0xc32f7502, 0xe9105633, 0xe7195b38, 0xf5024c25, 0xfb0b412e, 0x9ad7618c, 0x94de6c87, 0x86c57b9a, 0x88cc7691, 0xa2f355a0, 0xacfa58ab, 0xbee14fb6, 0xb0e842bd, 0xea9f09d4, 0xe49604df, 0xf68d13c2, 0xf8841ec9, 0xd2bb3df8, 0xdcb230f3, 0xcea927ee, 0xc0a02ae5, 0x7a47b13c, 0x744ebc37, 0x6655ab2a, 0x685ca621, 0x42638510, 0x4c6a881b, 0x5e719f06, 0x5078920d, 0x0a0fd964, 0x0406d46f, 0x161dc372, 0x1814ce79, 0x322bed48, 0x3c22e043, 0x2e39f75e, 0x2030fa55, 0xec9ab701, 0xe293ba0a, 0xf088ad17, 0xfe81a01c, 0xd4be832d, 0xdab78e26, 0xc8ac993b, 0xc6a59430, 0x9cd2df59, 0x92dbd252, 0x80c0c54f, 0x8ec9c844, 0xa4f6eb75, 0xaaffe67e, 0xb8e4f163, 0xb6edfc68, 0x0c0a67b1, 0x02036aba, 0x10187da7, 0x1e1170ac, 0x342e539d, 0x3a275e96, 0x283c498b, 0x26354480, 0x7c420fe9, 0x724b02e2, 0x605015ff, 0x6e5918f4, 0x44663bc5, 0x4a6f36ce, 0x587421d3, 0x567d2cd8, 0x37a10c7a, 0x39a80171, 0x2bb3166c, 0x25ba1b67, 0x0f853856, 0x018c355d, 0x13972240, 0x1d9e2f4b, 0x47e96422, 0x49e06929, 0x5bfb7e34, 0x55f2733f, 0x7fcd500e, 0x71c45d05, 0x63df4a18, 0x6dd64713, 0xd731dcca, 0xd938d1c1, 0xcb23c6dc, 0xc52acbd7, 0xef15e8e6, 0xe11ce5ed, 0xf307f2f0, 0xfd0efffb, 0xa779b492, 0xa970b999, 0xbb6bae84, 0xb562a38f, 0x9f5d80be, 0x91548db5, 0x834f9aa8, 0x8d4697a3];\n\t    var U2 = [0x00000000, 0x0b0e090d, 0x161c121a, 0x1d121b17, 0x2c382434, 0x27362d39, 0x3a24362e, 0x312a3f23, 0x58704868, 0x537e4165, 0x4e6c5a72, 0x4562537f, 0x74486c5c, 0x7f466551, 0x62547e46, 0x695a774b, 0xb0e090d0, 0xbbee99dd, 0xa6fc82ca, 0xadf28bc7, 0x9cd8b4e4, 0x97d6bde9, 0x8ac4a6fe, 0x81caaff3, 0xe890d8b8, 0xe39ed1b5, 0xfe8ccaa2, 0xf582c3af, 0xc4a8fc8c, 0xcfa6f581, 0xd2b4ee96, 0xd9bae79b, 0x7bdb3bbb, 0x70d532b6, 0x6dc729a1, 0x66c920ac, 0x57e31f8f, 0x5ced1682, 0x41ff0d95, 0x4af10498, 0x23ab73d3, 0x28a57ade, 0x35b761c9, 0x3eb968c4, 0x0f9357e7, 0x049d5eea, 0x198f45fd, 0x12814cf0, 0xcb3bab6b, 0xc035a266, 0xdd27b971, 0xd629b07c, 0xe7038f5f, 0xec0d8652, 0xf11f9d45, 0xfa119448, 0x934be303, 0x9845ea0e, 0x8557f119, 0x8e59f814, 0xbf73c737, 0xb47dce3a, 0xa96fd52d, 0xa261dc20, 0xf6ad766d, 0xfda37f60, 0xe0b16477, 0xebbf6d7a, 0xda955259, 0xd19b5b54, 0xcc894043, 0xc787494e, 0xaedd3e05, 0xa5d33708, 0xb8c12c1f, 0xb3cf2512, 0x82e51a31, 0x89eb133c, 0x94f9082b, 0x9ff70126, 0x464de6bd, 0x4d43efb0, 0x5051f4a7, 0x5b5ffdaa, 0x6a75c289, 0x617bcb84, 0x7c69d093, 0x7767d99e, 0x1e3daed5, 0x1533a7d8, 0x0821bccf, 0x032fb5c2, 0x32058ae1, 0x390b83ec, 0x241998fb, 0x2f1791f6, 0x8d764dd6, 0x867844db, 0x9b6a5fcc, 0x906456c1, 0xa14e69e2, 0xaa4060ef, 0xb7527bf8, 0xbc5c72f5, 0xd50605be, 0xde080cb3, 0xc31a17a4, 0xc8141ea9, 0xf93e218a, 0xf2302887, 0xef223390, 0xe42c3a9d, 0x3d96dd06, 0x3698d40b, 0x2b8acf1c, 0x2084c611, 0x11aef932, 0x1aa0f03f, 0x07b2eb28, 0x0cbce225, 0x65e6956e, 0x6ee89c63, 0x73fa8774, 0x78f48e79, 0x49deb15a, 0x42d0b857, 0x5fc2a340, 0x54ccaa4d, 0xf741ecda, 0xfc4fe5d7, 0xe15dfec0, 0xea53f7cd, 0xdb79c8ee, 0xd077c1e3, 0xcd65daf4, 0xc66bd3f9, 0xaf31a4b2, 0xa43fadbf, 0xb92db6a8, 0xb223bfa5, 0x83098086, 0x8807898b, 0x9515929c, 0x9e1b9b91, 0x47a17c0a, 0x4caf7507, 0x51bd6e10, 0x5ab3671d, 0x6b99583e, 0x60975133, 0x7d854a24, 0x768b4329, 0x1fd13462, 0x14df3d6f, 0x09cd2678, 0x02c32f75, 0x33e91056, 0x38e7195b, 0x25f5024c, 0x2efb0b41, 0x8c9ad761, 0x8794de6c, 0x9a86c57b, 0x9188cc76, 0xa0a2f355, 0xabacfa58, 0xb6bee14f, 0xbdb0e842, 0xd4ea9f09, 0xdfe49604, 0xc2f68d13, 0xc9f8841e, 0xf8d2bb3d, 0xf3dcb230, 0xeecea927, 0xe5c0a02a, 0x3c7a47b1, 0x37744ebc, 0x2a6655ab, 0x21685ca6, 0x10426385, 0x1b4c6a88, 0x065e719f, 0x0d507892, 0x640a0fd9, 0x6f0406d4, 0x72161dc3, 0x791814ce, 0x48322bed, 0x433c22e0, 0x5e2e39f7, 0x552030fa, 0x01ec9ab7, 0x0ae293ba, 0x17f088ad, 0x1cfe81a0, 0x2dd4be83, 0x26dab78e, 0x3bc8ac99, 0x30c6a594, 0x599cd2df, 0x5292dbd2, 0x4f80c0c5, 0x448ec9c8, 0x75a4f6eb, 0x7eaaffe6, 0x63b8e4f1, 0x68b6edfc, 0xb10c0a67, 0xba02036a, 0xa710187d, 0xac1e1170, 0x9d342e53, 0x963a275e, 0x8b283c49, 0x80263544, 0xe97c420f, 0xe2724b02, 0xff605015, 0xf46e5918, 0xc544663b, 0xce4a6f36, 0xd3587421, 0xd8567d2c, 0x7a37a10c, 0x7139a801, 0x6c2bb316, 0x6725ba1b, 0x560f8538, 0x5d018c35, 0x40139722, 0x4b1d9e2f, 0x2247e964, 0x2949e069, 0x345bfb7e, 0x3f55f273, 0x0e7fcd50, 0x0571c45d, 0x1863df4a, 0x136dd647, 0xcad731dc, 0xc1d938d1, 0xdccb23c6, 0xd7c52acb, 0xe6ef15e8, 0xede11ce5, 0xf0f307f2, 0xfbfd0eff, 0x92a779b4, 0x99a970b9, 0x84bb6bae, 0x8fb562a3, 0xbe9f5d80, 0xb591548d, 0xa8834f9a, 0xa38d4697];\n\t    var U3 = [0x00000000, 0x0d0b0e09, 0x1a161c12, 0x171d121b, 0x342c3824, 0x3927362d, 0x2e3a2436, 0x23312a3f, 0x68587048, 0x65537e41, 0x724e6c5a, 0x7f456253, 0x5c74486c, 0x517f4665, 0x4662547e, 0x4b695a77, 0xd0b0e090, 0xddbbee99, 0xcaa6fc82, 0xc7adf28b, 0xe49cd8b4, 0xe997d6bd, 0xfe8ac4a6, 0xf381caaf, 0xb8e890d8, 0xb5e39ed1, 0xa2fe8cca, 0xaff582c3, 0x8cc4a8fc, 0x81cfa6f5, 0x96d2b4ee, 0x9bd9bae7, 0xbb7bdb3b, 0xb670d532, 0xa16dc729, 0xac66c920, 0x8f57e31f, 0x825ced16, 0x9541ff0d, 0x984af104, 0xd323ab73, 0xde28a57a, 0xc935b761, 0xc43eb968, 0xe70f9357, 0xea049d5e, 0xfd198f45, 0xf012814c, 0x6bcb3bab, 0x66c035a2, 0x71dd27b9, 0x7cd629b0, 0x5fe7038f, 0x52ec0d86, 0x45f11f9d, 0x48fa1194, 0x03934be3, 0x0e9845ea, 0x198557f1, 0x148e59f8, 0x37bf73c7, 0x3ab47dce, 0x2da96fd5, 0x20a261dc, 0x6df6ad76, 0x60fda37f, 0x77e0b164, 0x7aebbf6d, 0x59da9552, 0x54d19b5b, 0x43cc8940, 0x4ec78749, 0x05aedd3e, 0x08a5d337, 0x1fb8c12c, 0x12b3cf25, 0x3182e51a, 0x3c89eb13, 0x2b94f908, 0x269ff701, 0xbd464de6, 0xb04d43ef, 0xa75051f4, 0xaa5b5ffd, 0x896a75c2, 0x84617bcb, 0x937c69d0, 0x9e7767d9, 0xd51e3dae, 0xd81533a7, 0xcf0821bc, 0xc2032fb5, 0xe132058a, 0xec390b83, 0xfb241998, 0xf62f1791, 0xd68d764d, 0xdb867844, 0xcc9b6a5f, 0xc1906456, 0xe2a14e69, 0xefaa4060, 0xf8b7527b, 0xf5bc5c72, 0xbed50605, 0xb3de080c, 0xa4c31a17, 0xa9c8141e, 0x8af93e21, 0x87f23028, 0x90ef2233, 0x9de42c3a, 0x063d96dd, 0x0b3698d4, 0x1c2b8acf, 0x112084c6, 0x3211aef9, 0x3f1aa0f0, 0x2807b2eb, 0x250cbce2, 0x6e65e695, 0x636ee89c, 0x7473fa87, 0x7978f48e, 0x5a49deb1, 0x5742d0b8, 0x405fc2a3, 0x4d54ccaa, 0xdaf741ec, 0xd7fc4fe5, 0xc0e15dfe, 0xcdea53f7, 0xeedb79c8, 0xe3d077c1, 0xf4cd65da, 0xf9c66bd3, 0xb2af31a4, 0xbfa43fad, 0xa8b92db6, 0xa5b223bf, 0x86830980, 0x8b880789, 0x9c951592, 0x919e1b9b, 0x0a47a17c, 0x074caf75, 0x1051bd6e, 0x1d5ab367, 0x3e6b9958, 0x33609751, 0x247d854a, 0x29768b43, 0x621fd134, 0x6f14df3d, 0x7809cd26, 0x7502c32f, 0x5633e910, 0x5b38e719, 0x4c25f502, 0x412efb0b, 0x618c9ad7, 0x6c8794de, 0x7b9a86c5, 0x769188cc, 0x55a0a2f3, 0x58abacfa, 0x4fb6bee1, 0x42bdb0e8, 0x09d4ea9f, 0x04dfe496, 0x13c2f68d, 0x1ec9f884, 0x3df8d2bb, 0x30f3dcb2, 0x27eecea9, 0x2ae5c0a0, 0xb13c7a47, 0xbc37744e, 0xab2a6655, 0xa621685c, 0x85104263, 0x881b4c6a, 0x9f065e71, 0x920d5078, 0xd9640a0f, 0xd46f0406, 0xc372161d, 0xce791814, 0xed48322b, 0xe0433c22, 0xf75e2e39, 0xfa552030, 0xb701ec9a, 0xba0ae293, 0xad17f088, 0xa01cfe81, 0x832dd4be, 0x8e26dab7, 0x993bc8ac, 0x9430c6a5, 0xdf599cd2, 0xd25292db, 0xc54f80c0, 0xc8448ec9, 0xeb75a4f6, 0xe67eaaff, 0xf163b8e4, 0xfc68b6ed, 0x67b10c0a, 0x6aba0203, 0x7da71018, 0x70ac1e11, 0x539d342e, 0x5e963a27, 0x498b283c, 0x44802635, 0x0fe97c42, 0x02e2724b, 0x15ff6050, 0x18f46e59, 0x3bc54466, 0x36ce4a6f, 0x21d35874, 0x2cd8567d, 0x0c7a37a1, 0x017139a8, 0x166c2bb3, 0x1b6725ba, 0x38560f85, 0x355d018c, 0x22401397, 0x2f4b1d9e, 0x642247e9, 0x692949e0, 0x7e345bfb, 0x733f55f2, 0x500e7fcd, 0x5d0571c4, 0x4a1863df, 0x47136dd6, 0xdccad731, 0xd1c1d938, 0xc6dccb23, 0xcbd7c52a, 0xe8e6ef15, 0xe5ede11c, 0xf2f0f307, 0xfffbfd0e, 0xb492a779, 0xb999a970, 0xae84bb6b, 0xa38fb562, 0x80be9f5d, 0x8db59154, 0x9aa8834f, 0x97a38d46];\n\t    var U4 = [0x00000000, 0x090d0b0e, 0x121a161c, 0x1b171d12, 0x24342c38, 0x2d392736, 0x362e3a24, 0x3f23312a, 0x48685870, 0x4165537e, 0x5a724e6c, 0x537f4562, 0x6c5c7448, 0x65517f46, 0x7e466254, 0x774b695a, 0x90d0b0e0, 0x99ddbbee, 0x82caa6fc, 0x8bc7adf2, 0xb4e49cd8, 0xbde997d6, 0xa6fe8ac4, 0xaff381ca, 0xd8b8e890, 0xd1b5e39e, 0xcaa2fe8c, 0xc3aff582, 0xfc8cc4a8, 0xf581cfa6, 0xee96d2b4, 0xe79bd9ba, 0x3bbb7bdb, 0x32b670d5, 0x29a16dc7, 0x20ac66c9, 0x1f8f57e3, 0x16825ced, 0x0d9541ff, 0x04984af1, 0x73d323ab, 0x7ade28a5, 0x61c935b7, 0x68c43eb9, 0x57e70f93, 0x5eea049d, 0x45fd198f, 0x4cf01281, 0xab6bcb3b, 0xa266c035, 0xb971dd27, 0xb07cd629, 0x8f5fe703, 0x8652ec0d, 0x9d45f11f, 0x9448fa11, 0xe303934b, 0xea0e9845, 0xf1198557, 0xf8148e59, 0xc737bf73, 0xce3ab47d, 0xd52da96f, 0xdc20a261, 0x766df6ad, 0x7f60fda3, 0x6477e0b1, 0x6d7aebbf, 0x5259da95, 0x5b54d19b, 0x4043cc89, 0x494ec787, 0x3e05aedd, 0x3708a5d3, 0x2c1fb8c1, 0x2512b3cf, 0x1a3182e5, 0x133c89eb, 0x082b94f9, 0x01269ff7, 0xe6bd464d, 0xefb04d43, 0xf4a75051, 0xfdaa5b5f, 0xc2896a75, 0xcb84617b, 0xd0937c69, 0xd99e7767, 0xaed51e3d, 0xa7d81533, 0xbccf0821, 0xb5c2032f, 0x8ae13205, 0x83ec390b, 0x98fb2419, 0x91f62f17, 0x4dd68d76, 0x44db8678, 0x5fcc9b6a, 0x56c19064, 0x69e2a14e, 0x60efaa40, 0x7bf8b752, 0x72f5bc5c, 0x05bed506, 0x0cb3de08, 0x17a4c31a, 0x1ea9c814, 0x218af93e, 0x2887f230, 0x3390ef22, 0x3a9de42c, 0xdd063d96, 0xd40b3698, 0xcf1c2b8a, 0xc6112084, 0xf93211ae, 0xf03f1aa0, 0xeb2807b2, 0xe2250cbc, 0x956e65e6, 0x9c636ee8, 0x877473fa, 0x8e7978f4, 0xb15a49de, 0xb85742d0, 0xa3405fc2, 0xaa4d54cc, 0xecdaf741, 0xe5d7fc4f, 0xfec0e15d, 0xf7cdea53, 0xc8eedb79, 0xc1e3d077, 0xdaf4cd65, 0xd3f9c66b, 0xa4b2af31, 0xadbfa43f, 0xb6a8b92d, 0xbfa5b223, 0x80868309, 0x898b8807, 0x929c9515, 0x9b919e1b, 0x7c0a47a1, 0x75074caf, 0x6e1051bd, 0x671d5ab3, 0x583e6b99, 0x51336097, 0x4a247d85, 0x4329768b, 0x34621fd1, 0x3d6f14df, 0x267809cd, 0x2f7502c3, 0x105633e9, 0x195b38e7, 0x024c25f5, 0x0b412efb, 0xd7618c9a, 0xde6c8794, 0xc57b9a86, 0xcc769188, 0xf355a0a2, 0xfa58abac, 0xe14fb6be, 0xe842bdb0, 0x9f09d4ea, 0x9604dfe4, 0x8d13c2f6, 0x841ec9f8, 0xbb3df8d2, 0xb230f3dc, 0xa927eece, 0xa02ae5c0, 0x47b13c7a, 0x4ebc3774, 0x55ab2a66, 0x5ca62168, 0x63851042, 0x6a881b4c, 0x719f065e, 0x78920d50, 0x0fd9640a, 0x06d46f04, 0x1dc37216, 0x14ce7918, 0x2bed4832, 0x22e0433c, 0x39f75e2e, 0x30fa5520, 0x9ab701ec, 0x93ba0ae2, 0x88ad17f0, 0x81a01cfe, 0xbe832dd4, 0xb78e26da, 0xac993bc8, 0xa59430c6, 0xd2df599c, 0xdbd25292, 0xc0c54f80, 0xc9c8448e, 0xf6eb75a4, 0xffe67eaa, 0xe4f163b8, 0xedfc68b6, 0x0a67b10c, 0x036aba02, 0x187da710, 0x1170ac1e, 0x2e539d34, 0x275e963a, 0x3c498b28, 0x35448026, 0x420fe97c, 0x4b02e272, 0x5015ff60, 0x5918f46e, 0x663bc544, 0x6f36ce4a, 0x7421d358, 0x7d2cd856, 0xa10c7a37, 0xa8017139, 0xb3166c2b, 0xba1b6725, 0x8538560f, 0x8c355d01, 0x97224013, 0x9e2f4b1d, 0xe9642247, 0xe0692949, 0xfb7e345b, 0xf2733f55, 0xcd500e7f, 0xc45d0571, 0xdf4a1863, 0xd647136d, 0x31dccad7, 0x38d1c1d9, 0x23c6dccb, 0x2acbd7c5, 0x15e8e6ef, 0x1ce5ede1, 0x07f2f0f3, 0x0efffbfd, 0x79b492a7, 0x70b999a9, 0x6bae84bb, 0x62a38fb5, 0x5d80be9f, 0x548db591, 0x4f9aa883, 0x4697a38d];\n\n\t    function convertToInt32(bytes) {\n\t        var result = [];\n\t        for (var i = 0; i < bytes.length; i += 4) {\n\t            result.push(\n\t                (bytes[i    ] << 24) |\n\t                (bytes[i + 1] << 16) |\n\t                (bytes[i + 2] <<  8) |\n\t                 bytes[i + 3]\n\t            );\n\t        }\n\t        return result;\n\t    }\n\n\t    var AES = function(key) {\n\t        if (!(this instanceof AES)) {\n\t            throw Error('AES must be instanitated with `new`');\n\t        }\n\n\t        Object.defineProperty(this, 'key', {\n\t            value: coerceArray(key, true)\n\t        });\n\n\t        this._prepare();\n\t    };\n\n\n\t    AES.prototype._prepare = function() {\n\n\t        var rounds = numberOfRounds[this.key.length];\n\t        if (rounds == null) {\n\t            throw new Error('invalid key size (must be 16, 24 or 32 bytes)');\n\t        }\n\n\t        // encryption round keys\n\t        this._Ke = [];\n\n\t        // decryption round keys\n\t        this._Kd = [];\n\n\t        for (var i = 0; i <= rounds; i++) {\n\t            this._Ke.push([0, 0, 0, 0]);\n\t            this._Kd.push([0, 0, 0, 0]);\n\t        }\n\n\t        var roundKeyCount = (rounds + 1) * 4;\n\t        var KC = this.key.length / 4;\n\n\t        // convert the key into ints\n\t        var tk = convertToInt32(this.key);\n\n\t        // copy values into round key arrays\n\t        var index;\n\t        for (var i = 0; i < KC; i++) {\n\t            index = i >> 2;\n\t            this._Ke[index][i % 4] = tk[i];\n\t            this._Kd[rounds - index][i % 4] = tk[i];\n\t        }\n\n\t        // key expansion (fips-197 section 5.2)\n\t        var rconpointer = 0;\n\t        var t = KC, tt;\n\t        while (t < roundKeyCount) {\n\t            tt = tk[KC - 1];\n\t            tk[0] ^= ((S[(tt >> 16) & 0xFF] << 24) ^\n\t                      (S[(tt >>  8) & 0xFF] << 16) ^\n\t                      (S[ tt        & 0xFF] <<  8) ^\n\t                       S[(tt >> 24) & 0xFF]        ^\n\t                      (rcon[rconpointer] << 24));\n\t            rconpointer += 1;\n\n\t            // key expansion (for non-256 bit)\n\t            if (KC != 8) {\n\t                for (var i = 1; i < KC; i++) {\n\t                    tk[i] ^= tk[i - 1];\n\t                }\n\n\t            // key expansion for 256-bit keys is \"slightly different\" (fips-197)\n\t            } else {\n\t                for (var i = 1; i < (KC / 2); i++) {\n\t                    tk[i] ^= tk[i - 1];\n\t                }\n\t                tt = tk[(KC / 2) - 1];\n\n\t                tk[KC / 2] ^= (S[ tt        & 0xFF]        ^\n\t                              (S[(tt >>  8) & 0xFF] <<  8) ^\n\t                              (S[(tt >> 16) & 0xFF] << 16) ^\n\t                              (S[(tt >> 24) & 0xFF] << 24));\n\n\t                for (var i = (KC / 2) + 1; i < KC; i++) {\n\t                    tk[i] ^= tk[i - 1];\n\t                }\n\t            }\n\n\t            // copy values into round key arrays\n\t            var i = 0, r, c;\n\t            while (i < KC && t < roundKeyCount) {\n\t                r = t >> 2;\n\t                c = t % 4;\n\t                this._Ke[r][c] = tk[i];\n\t                this._Kd[rounds - r][c] = tk[i++];\n\t                t++;\n\t            }\n\t        }\n\n\t        // inverse-cipher-ify the decryption round key (fips-197 section 5.3)\n\t        for (var r = 1; r < rounds; r++) {\n\t            for (var c = 0; c < 4; c++) {\n\t                tt = this._Kd[r][c];\n\t                this._Kd[r][c] = (U1[(tt >> 24) & 0xFF] ^\n\t                                  U2[(tt >> 16) & 0xFF] ^\n\t                                  U3[(tt >>  8) & 0xFF] ^\n\t                                  U4[ tt        & 0xFF]);\n\t            }\n\t        }\n\t    };\n\n\t    AES.prototype.encrypt = function(plaintext) {\n\t        if (plaintext.length != 16) {\n\t            throw new Error('invalid plaintext size (must be 16 bytes)');\n\t        }\n\n\t        var rounds = this._Ke.length - 1;\n\t        var a = [0, 0, 0, 0];\n\n\t        // convert plaintext to (ints ^ key)\n\t        var t = convertToInt32(plaintext);\n\t        for (var i = 0; i < 4; i++) {\n\t            t[i] ^= this._Ke[0][i];\n\t        }\n\n\t        // apply round transforms\n\t        for (var r = 1; r < rounds; r++) {\n\t            for (var i = 0; i < 4; i++) {\n\t                a[i] = (T1[(t[ i         ] >> 24) & 0xff] ^\n\t                        T2[(t[(i + 1) % 4] >> 16) & 0xff] ^\n\t                        T3[(t[(i + 2) % 4] >>  8) & 0xff] ^\n\t                        T4[ t[(i + 3) % 4]        & 0xff] ^\n\t                        this._Ke[r][i]);\n\t            }\n\t            t = a.slice();\n\t        }\n\n\t        // the last round is special\n\t        var result = createArray(16), tt;\n\t        for (var i = 0; i < 4; i++) {\n\t            tt = this._Ke[rounds][i];\n\t            result[4 * i    ] = (S[(t[ i         ] >> 24) & 0xff] ^ (tt >> 24)) & 0xff;\n\t            result[4 * i + 1] = (S[(t[(i + 1) % 4] >> 16) & 0xff] ^ (tt >> 16)) & 0xff;\n\t            result[4 * i + 2] = (S[(t[(i + 2) % 4] >>  8) & 0xff] ^ (tt >>  8)) & 0xff;\n\t            result[4 * i + 3] = (S[ t[(i + 3) % 4]        & 0xff] ^  tt       ) & 0xff;\n\t        }\n\n\t        return result;\n\t    };\n\n\t    AES.prototype.decrypt = function(ciphertext) {\n\t        if (ciphertext.length != 16) {\n\t            throw new Error('invalid ciphertext size (must be 16 bytes)');\n\t        }\n\n\t        var rounds = this._Kd.length - 1;\n\t        var a = [0, 0, 0, 0];\n\n\t        // convert plaintext to (ints ^ key)\n\t        var t = convertToInt32(ciphertext);\n\t        for (var i = 0; i < 4; i++) {\n\t            t[i] ^= this._Kd[0][i];\n\t        }\n\n\t        // apply round transforms\n\t        for (var r = 1; r < rounds; r++) {\n\t            for (var i = 0; i < 4; i++) {\n\t                a[i] = (T5[(t[ i          ] >> 24) & 0xff] ^\n\t                        T6[(t[(i + 3) % 4] >> 16) & 0xff] ^\n\t                        T7[(t[(i + 2) % 4] >>  8) & 0xff] ^\n\t                        T8[ t[(i + 1) % 4]        & 0xff] ^\n\t                        this._Kd[r][i]);\n\t            }\n\t            t = a.slice();\n\t        }\n\n\t        // the last round is special\n\t        var result = createArray(16), tt;\n\t        for (var i = 0; i < 4; i++) {\n\t            tt = this._Kd[rounds][i];\n\t            result[4 * i    ] = (Si[(t[ i         ] >> 24) & 0xff] ^ (tt >> 24)) & 0xff;\n\t            result[4 * i + 1] = (Si[(t[(i + 3) % 4] >> 16) & 0xff] ^ (tt >> 16)) & 0xff;\n\t            result[4 * i + 2] = (Si[(t[(i + 2) % 4] >>  8) & 0xff] ^ (tt >>  8)) & 0xff;\n\t            result[4 * i + 3] = (Si[ t[(i + 1) % 4]        & 0xff] ^  tt       ) & 0xff;\n\t        }\n\n\t        return result;\n\t    };\n\n\n\t    /**\n\t     *  Mode Of Operation - Electonic Codebook (ECB)\n\t     */\n\t    var ModeOfOperationECB = function(key) {\n\t        if (!(this instanceof ModeOfOperationECB)) {\n\t            throw Error('AES must be instanitated with `new`');\n\t        }\n\n\t        this.description = \"Electronic Code Block\";\n\t        this.name = \"ecb\";\n\n\t        this._aes = new AES(key);\n\t    };\n\n\t    ModeOfOperationECB.prototype.encrypt = function(plaintext) {\n\t        plaintext = coerceArray(plaintext);\n\n\t        if ((plaintext.length % 16) !== 0) {\n\t            throw new Error('invalid plaintext size (must be multiple of 16 bytes)');\n\t        }\n\n\t        var ciphertext = createArray(plaintext.length);\n\t        var block = createArray(16);\n\n\t        for (var i = 0; i < plaintext.length; i += 16) {\n\t            copyArray(plaintext, block, 0, i, i + 16);\n\t            block = this._aes.encrypt(block);\n\t            copyArray(block, ciphertext, i);\n\t        }\n\n\t        return ciphertext;\n\t    };\n\n\t    ModeOfOperationECB.prototype.decrypt = function(ciphertext) {\n\t        ciphertext = coerceArray(ciphertext);\n\n\t        if ((ciphertext.length % 16) !== 0) {\n\t            throw new Error('invalid ciphertext size (must be multiple of 16 bytes)');\n\t        }\n\n\t        var plaintext = createArray(ciphertext.length);\n\t        var block = createArray(16);\n\n\t        for (var i = 0; i < ciphertext.length; i += 16) {\n\t            copyArray(ciphertext, block, 0, i, i + 16);\n\t            block = this._aes.decrypt(block);\n\t            copyArray(block, plaintext, i);\n\t        }\n\n\t        return plaintext;\n\t    };\n\n\n\t    /**\n\t     *  Mode Of Operation - Cipher Block Chaining (CBC)\n\t     */\n\t    var ModeOfOperationCBC = function(key, iv) {\n\t        if (!(this instanceof ModeOfOperationCBC)) {\n\t            throw Error('AES must be instanitated with `new`');\n\t        }\n\n\t        this.description = \"Cipher Block Chaining\";\n\t        this.name = \"cbc\";\n\n\t        if (!iv) {\n\t            iv = createArray(16);\n\n\t        } else if (iv.length != 16) {\n\t            throw new Error('invalid initialation vector size (must be 16 bytes)');\n\t        }\n\n\t        this._lastCipherblock = coerceArray(iv, true);\n\n\t        this._aes = new AES(key);\n\t    };\n\n\t    ModeOfOperationCBC.prototype.encrypt = function(plaintext) {\n\t        plaintext = coerceArray(plaintext);\n\n\t        if ((plaintext.length % 16) !== 0) {\n\t            throw new Error('invalid plaintext size (must be multiple of 16 bytes)');\n\t        }\n\n\t        var ciphertext = createArray(plaintext.length);\n\t        var block = createArray(16);\n\n\t        for (var i = 0; i < plaintext.length; i += 16) {\n\t            copyArray(plaintext, block, 0, i, i + 16);\n\n\t            for (var j = 0; j < 16; j++) {\n\t                block[j] ^= this._lastCipherblock[j];\n\t            }\n\n\t            this._lastCipherblock = this._aes.encrypt(block);\n\t            copyArray(this._lastCipherblock, ciphertext, i);\n\t        }\n\n\t        return ciphertext;\n\t    };\n\n\t    ModeOfOperationCBC.prototype.decrypt = function(ciphertext) {\n\t        ciphertext = coerceArray(ciphertext);\n\n\t        if ((ciphertext.length % 16) !== 0) {\n\t            throw new Error('invalid ciphertext size (must be multiple of 16 bytes)');\n\t        }\n\n\t        var plaintext = createArray(ciphertext.length);\n\t        var block = createArray(16);\n\n\t        for (var i = 0; i < ciphertext.length; i += 16) {\n\t            copyArray(ciphertext, block, 0, i, i + 16);\n\t            block = this._aes.decrypt(block);\n\n\t            for (var j = 0; j < 16; j++) {\n\t                plaintext[i + j] = block[j] ^ this._lastCipherblock[j];\n\t            }\n\n\t            copyArray(ciphertext, this._lastCipherblock, 0, i, i + 16);\n\t        }\n\n\t        return plaintext;\n\t    };\n\n\n\t    /**\n\t     *  Mode Of Operation - Cipher Feedback (CFB)\n\t     */\n\t    var ModeOfOperationCFB = function(key, iv, segmentSize) {\n\t        if (!(this instanceof ModeOfOperationCFB)) {\n\t            throw Error('AES must be instanitated with `new`');\n\t        }\n\n\t        this.description = \"Cipher Feedback\";\n\t        this.name = \"cfb\";\n\n\t        if (!iv) {\n\t            iv = createArray(16);\n\n\t        } else if (iv.length != 16) {\n\t            throw new Error('invalid initialation vector size (must be 16 size)');\n\t        }\n\n\t        if (!segmentSize) { segmentSize = 1; }\n\n\t        this.segmentSize = segmentSize;\n\n\t        this._shiftRegister = coerceArray(iv, true);\n\n\t        this._aes = new AES(key);\n\t    };\n\n\t    ModeOfOperationCFB.prototype.encrypt = function(plaintext) {\n\t        if ((plaintext.length % this.segmentSize) != 0) {\n\t            throw new Error('invalid plaintext size (must be segmentSize bytes)');\n\t        }\n\n\t        var encrypted = coerceArray(plaintext, true);\n\n\t        var xorSegment;\n\t        for (var i = 0; i < encrypted.length; i += this.segmentSize) {\n\t            xorSegment = this._aes.encrypt(this._shiftRegister);\n\t            for (var j = 0; j < this.segmentSize; j++) {\n\t                encrypted[i + j] ^= xorSegment[j];\n\t            }\n\n\t            // Shift the register\n\t            copyArray(this._shiftRegister, this._shiftRegister, 0, this.segmentSize);\n\t            copyArray(encrypted, this._shiftRegister, 16 - this.segmentSize, i, i + this.segmentSize);\n\t        }\n\n\t        return encrypted;\n\t    };\n\n\t    ModeOfOperationCFB.prototype.decrypt = function(ciphertext) {\n\t        if ((ciphertext.length % this.segmentSize) != 0) {\n\t            throw new Error('invalid ciphertext size (must be segmentSize bytes)');\n\t        }\n\n\t        var plaintext = coerceArray(ciphertext, true);\n\n\t        var xorSegment;\n\t        for (var i = 0; i < plaintext.length; i += this.segmentSize) {\n\t            xorSegment = this._aes.encrypt(this._shiftRegister);\n\n\t            for (var j = 0; j < this.segmentSize; j++) {\n\t                plaintext[i + j] ^= xorSegment[j];\n\t            }\n\n\t            // Shift the register\n\t            copyArray(this._shiftRegister, this._shiftRegister, 0, this.segmentSize);\n\t            copyArray(ciphertext, this._shiftRegister, 16 - this.segmentSize, i, i + this.segmentSize);\n\t        }\n\n\t        return plaintext;\n\t    };\n\n\t    /**\n\t     *  Mode Of Operation - Output Feedback (OFB)\n\t     */\n\t    var ModeOfOperationOFB = function(key, iv) {\n\t        if (!(this instanceof ModeOfOperationOFB)) {\n\t            throw Error('AES must be instanitated with `new`');\n\t        }\n\n\t        this.description = \"Output Feedback\";\n\t        this.name = \"ofb\";\n\n\t        if (!iv) {\n\t            iv = createArray(16);\n\n\t        } else if (iv.length != 16) {\n\t            throw new Error('invalid initialation vector size (must be 16 bytes)');\n\t        }\n\n\t        this._lastPrecipher = coerceArray(iv, true);\n\t        this._lastPrecipherIndex = 16;\n\n\t        this._aes = new AES(key);\n\t    };\n\n\t    ModeOfOperationOFB.prototype.encrypt = function(plaintext) {\n\t        var encrypted = coerceArray(plaintext, true);\n\n\t        for (var i = 0; i < encrypted.length; i++) {\n\t            if (this._lastPrecipherIndex === 16) {\n\t                this._lastPrecipher = this._aes.encrypt(this._lastPrecipher);\n\t                this._lastPrecipherIndex = 0;\n\t            }\n\t            encrypted[i] ^= this._lastPrecipher[this._lastPrecipherIndex++];\n\t        }\n\n\t        return encrypted;\n\t    };\n\n\t    // Decryption is symetric\n\t    ModeOfOperationOFB.prototype.decrypt = ModeOfOperationOFB.prototype.encrypt;\n\n\n\t    /**\n\t     *  Counter object for CTR common mode of operation\n\t     */\n\t    var Counter = function(initialValue) {\n\t        if (!(this instanceof Counter)) {\n\t            throw Error('Counter must be instanitated with `new`');\n\t        }\n\n\t        // We allow 0, but anything false-ish uses the default 1\n\t        if (initialValue !== 0 && !initialValue) { initialValue = 1; }\n\n\t        if (typeof(initialValue) === 'number') {\n\t            this._counter = createArray(16);\n\t            this.setValue(initialValue);\n\n\t        } else {\n\t            this.setBytes(initialValue);\n\t        }\n\t    };\n\n\t    Counter.prototype.setValue = function(value) {\n\t        if (typeof(value) !== 'number' || parseInt(value) != value) {\n\t            throw new Error('invalid counter value (must be an integer)');\n\t        }\n\n\t        for (var index = 15; index >= 0; --index) {\n\t            this._counter[index] = value % 256;\n\t            value = value >> 8;\n\t        }\n\t    };\n\n\t    Counter.prototype.setBytes = function(bytes) {\n\t        bytes = coerceArray(bytes, true);\n\n\t        if (bytes.length != 16) {\n\t            throw new Error('invalid counter bytes size (must be 16 bytes)');\n\t        }\n\n\t        this._counter = bytes;\n\t    };\n\n\t    Counter.prototype.increment = function() {\n\t        for (var i = 15; i >= 0; i--) {\n\t            if (this._counter[i] === 255) {\n\t                this._counter[i] = 0;\n\t            } else {\n\t                this._counter[i]++;\n\t                break;\n\t            }\n\t        }\n\t    };\n\n\n\t    /**\n\t     *  Mode Of Operation - Counter (CTR)\n\t     */\n\t    var ModeOfOperationCTR = function(key, counter) {\n\t        if (!(this instanceof ModeOfOperationCTR)) {\n\t            throw Error('AES must be instanitated with `new`');\n\t        }\n\n\t        this.description = \"Counter\";\n\t        this.name = \"ctr\";\n\n\t        if (!(counter instanceof Counter)) {\n\t            counter = new Counter(counter);\n\t        }\n\n\t        this._counter = counter;\n\n\t        this._remainingCounter = null;\n\t        this._remainingCounterIndex = 16;\n\n\t        this._aes = new AES(key);\n\t    };\n\n\t    ModeOfOperationCTR.prototype.encrypt = function(plaintext) {\n\t        var encrypted = coerceArray(plaintext, true);\n\n\t        for (var i = 0; i < encrypted.length; i++) {\n\t            if (this._remainingCounterIndex === 16) {\n\t                this._remainingCounter = this._aes.encrypt(this._counter._counter);\n\t                this._remainingCounterIndex = 0;\n\t                this._counter.increment();\n\t            }\n\t            encrypted[i] ^= this._remainingCounter[this._remainingCounterIndex++];\n\t        }\n\n\t        return encrypted;\n\t    };\n\n\t    // Decryption is symetric\n\t    ModeOfOperationCTR.prototype.decrypt = ModeOfOperationCTR.prototype.encrypt;\n\n\n\t    ///////////////////////\n\t    // Padding\n\n\t    // See:https://tools.ietf.org/html/rfc2315\n\t    function pkcs7pad(data) {\n\t        data = coerceArray(data, true);\n\t        var padder = 16 - (data.length % 16);\n\t        var result = createArray(data.length + padder);\n\t        copyArray(data, result);\n\t        for (var i = data.length; i < result.length; i++) {\n\t            result[i] = padder;\n\t        }\n\t        return result;\n\t    }\n\n\t    function pkcs7strip(data) {\n\t        data = coerceArray(data, true);\n\t        if (data.length < 16) { throw new Error('PKCS#7 invalid length'); }\n\n\t        var padder = data[data.length - 1];\n\t        if (padder > 16) { throw new Error('PKCS#7 padding byte out of range'); }\n\n\t        var length = data.length - padder;\n\t        for (var i = 0; i < padder; i++) {\n\t            if (data[length + i] !== padder) {\n\t                throw new Error('PKCS#7 invalid padding byte');\n\t            }\n\t        }\n\n\t        var result = createArray(length);\n\t        copyArray(data, result, 0, 0, length);\n\t        return result;\n\t    }\n\n\t    ///////////////////////\n\t    // Exporting\n\n\n\t    // The block cipher\n\t    var aesjs = {\n\t        AES: AES,\n\t        Counter: Counter,\n\n\t        ModeOfOperation: {\n\t            ecb: ModeOfOperationECB,\n\t            cbc: ModeOfOperationCBC,\n\t            cfb: ModeOfOperationCFB,\n\t            ofb: ModeOfOperationOFB,\n\t            ctr: ModeOfOperationCTR\n\t        },\n\n\t        utils: {\n\t            hex: convertHex,\n\t            utf8: convertUtf8\n\t        },\n\n\t        padding: {\n\t            pkcs7: {\n\t                pad: pkcs7pad,\n\t                strip: pkcs7strip\n\t            }\n\t        },\n\n\t        _arrayTest: {\n\t            coerceArray: coerceArray,\n\t            createArray: createArray,\n\t            copyArray: copyArray,\n\t        }\n\t    };\n\n\n\t    // node.js\n\t    if (true) {\n\t        module.exports = aesjs;\n\n\t    // RequireJS/AMD\n\t    // http://www.requirejs.org/docs/api.html\n\t    // https://github.com/amdjs/amdjs-api/wiki/AMD\n\t    } else {}\n\n\n\t})(commonjsGlobal);\n\t});\n\n\tvar _version$A = createCommonjsModule(function (module, exports) {\n\t\"use strict\";\n\tObject.defineProperty(exports, \"__esModule\", { value: true });\n\texports.version = void 0;\n\texports.version = \"json-wallets/5.5.0\";\n\n\t});\n\n\tvar _version$B = /*@__PURE__*/getDefaultExportFromCjs(_version$A);\n\n\tvar utils$1 = createCommonjsModule(function (module, exports) {\n\t\"use strict\";\n\tObject.defineProperty(exports, \"__esModule\", { value: true });\n\texports.uuidV4 = exports.searchPath = exports.getPassword = exports.zpad = exports.looseArrayify = void 0;\n\n\n\tfunction looseArrayify(hexString) {\n\t    if (typeof (hexString) === 'string' && hexString.substring(0, 2) !== '0x') {\n\t        hexString = '0x' + hexString;\n\t    }\n\t    return (0, lib$1.arrayify)(hexString);\n\t}\n\texports.looseArrayify = looseArrayify;\n\tfunction zpad(value, length) {\n\t    value = String(value);\n\t    while (value.length < length) {\n\t        value = '0' + value;\n\t    }\n\t    return value;\n\t}\n\texports.zpad = zpad;\n\tfunction getPassword(password) {\n\t    if (typeof (password) === 'string') {\n\t        return (0, lib$8.toUtf8Bytes)(password, lib$8.UnicodeNormalizationForm.NFKC);\n\t    }\n\t    return (0, lib$1.arrayify)(password);\n\t}\n\texports.getPassword = getPassword;\n\tfunction searchPath(object, path) {\n\t    var currentChild = object;\n\t    var comps = path.toLowerCase().split('/');\n\t    for (var i = 0; i < comps.length; i++) {\n\t        // Search for a child object with a case-insensitive matching key\n\t        var matchingChild = null;\n\t        for (var key in currentChild) {\n\t            if (key.toLowerCase() === comps[i]) {\n\t                matchingChild = currentChild[key];\n\t                break;\n\t            }\n\t        }\n\t        // Didn't find one. :'(\n\t        if (matchingChild === null) {\n\t            return null;\n\t        }\n\t        // Now check this child...\n\t        currentChild = matchingChild;\n\t    }\n\t    return currentChild;\n\t}\n\texports.searchPath = searchPath;\n\t// See: https://www.ietf.org/rfc/rfc4122.txt (Section 4.4)\n\tfunction uuidV4(randomBytes) {\n\t    var bytes = (0, lib$1.arrayify)(randomBytes);\n\t    // Section: 4.1.3:\n\t    // - time_hi_and_version[12:16] = 0b0100\n\t    bytes[6] = (bytes[6] & 0x0f) | 0x40;\n\t    // Section 4.4\n\t    // - clock_seq_hi_and_reserved[6] = 0b0\n\t    // - clock_seq_hi_and_reserved[7] = 0b1\n\t    bytes[8] = (bytes[8] & 0x3f) | 0x80;\n\t    var value = (0, lib$1.hexlify)(bytes);\n\t    return [\n\t        value.substring(2, 10),\n\t        value.substring(10, 14),\n\t        value.substring(14, 18),\n\t        value.substring(18, 22),\n\t        value.substring(22, 34),\n\t    ].join(\"-\");\n\t}\n\texports.uuidV4 = uuidV4;\n\n\t});\n\n\tvar utils$2 = /*@__PURE__*/getDefaultExportFromCjs(utils$1);\n\n\tvar crowdsale = createCommonjsModule(function (module, exports) {\n\t\"use strict\";\n\tvar __extends = (commonjsGlobal && commonjsGlobal.__extends) || (function () {\n\t    var extendStatics = function (d, b) {\n\t        extendStatics = Object.setPrototypeOf ||\n\t            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n\t            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n\t        return extendStatics(d, b);\n\t    };\n\t    return function (d, b) {\n\t        if (typeof b !== \"function\" && b !== null)\n\t            throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n\t        extendStatics(d, b);\n\t        function __() { this.constructor = d; }\n\t        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n\t    };\n\t})();\n\tvar __importDefault = (commonjsGlobal && commonjsGlobal.__importDefault) || function (mod) {\n\t    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n\t};\n\tObject.defineProperty(exports, \"__esModule\", { value: true });\n\texports.decrypt = exports.CrowdsaleAccount = void 0;\n\tvar aes_js_1 = __importDefault(aesJs);\n\n\n\n\n\n\n\n\n\tvar logger = new lib.Logger(_version$A.version);\n\n\tvar CrowdsaleAccount = /** @class */ (function (_super) {\n\t    __extends(CrowdsaleAccount, _super);\n\t    function CrowdsaleAccount() {\n\t        return _super !== null && _super.apply(this, arguments) || this;\n\t    }\n\t    CrowdsaleAccount.prototype.isCrowdsaleAccount = function (value) {\n\t        return !!(value && value._isCrowdsaleAccount);\n\t    };\n\t    return CrowdsaleAccount;\n\t}(lib$3.Description));\n\texports.CrowdsaleAccount = CrowdsaleAccount;\n\t// See: https://github.com/ethereum/pyethsaletool\n\tfunction decrypt(json, password) {\n\t    var data = JSON.parse(json);\n\t    password = (0, utils$1.getPassword)(password);\n\t    // Ethereum Address\n\t    var ethaddr = (0, lib$6.getAddress)((0, utils$1.searchPath)(data, \"ethaddr\"));\n\t    // Encrypted Seed\n\t    var encseed = (0, utils$1.looseArrayify)((0, utils$1.searchPath)(data, \"encseed\"));\n\t    if (!encseed || (encseed.length % 16) !== 0) {\n\t        logger.throwArgumentError(\"invalid encseed\", \"json\", json);\n\t    }\n\t    var key = (0, lib$1.arrayify)((0, lib$i.pbkdf2)(password, password, 2000, 32, \"sha256\")).slice(0, 16);\n\t    var iv = encseed.slice(0, 16);\n\t    var encryptedSeed = encseed.slice(16);\n\t    // Decrypt the seed\n\t    var aesCbc = new aes_js_1.default.ModeOfOperation.cbc(key, iv);\n\t    var seed = aes_js_1.default.padding.pkcs7.strip((0, lib$1.arrayify)(aesCbc.decrypt(encryptedSeed)));\n\t    // This wallet format is weird... Convert the binary encoded hex to a string.\n\t    var seedHex = \"\";\n\t    for (var i = 0; i < seed.length; i++) {\n\t        seedHex += String.fromCharCode(seed[i]);\n\t    }\n\t    var seedHexBytes = (0, lib$8.toUtf8Bytes)(seedHex);\n\t    var privateKey = (0, lib$4.keccak256)(seedHexBytes);\n\t    return new CrowdsaleAccount({\n\t        _isCrowdsaleAccount: true,\n\t        address: ethaddr,\n\t        privateKey: privateKey\n\t    });\n\t}\n\texports.decrypt = decrypt;\n\n\t});\n\n\tvar crowdsale$1 = /*@__PURE__*/getDefaultExportFromCjs(crowdsale);\n\n\tvar inspect = createCommonjsModule(function (module, exports) {\n\t\"use strict\";\n\tObject.defineProperty(exports, \"__esModule\", { value: true });\n\texports.getJsonWalletAddress = exports.isKeystoreWallet = exports.isCrowdsaleWallet = void 0;\n\n\tfunction isCrowdsaleWallet(json) {\n\t    var data = null;\n\t    try {\n\t        data = JSON.parse(json);\n\t    }\n\t    catch (error) {\n\t        return false;\n\t    }\n\t    return (data.encseed && data.ethaddr);\n\t}\n\texports.isCrowdsaleWallet = isCrowdsaleWallet;\n\tfunction isKeystoreWallet(json) {\n\t    var data = null;\n\t    try {\n\t        data = JSON.parse(json);\n\t    }\n\t    catch (error) {\n\t        return false;\n\t    }\n\t    if (!data.version || parseInt(data.version) !== data.version || parseInt(data.version) !== 3) {\n\t        return false;\n\t    }\n\t    // @TODO: Put more checks to make sure it has kdf, iv and all that good stuff\n\t    return true;\n\t}\n\texports.isKeystoreWallet = isKeystoreWallet;\n\t//export function isJsonWallet(json: string): boolean {\n\t//    return (isSecretStorageWallet(json) || isCrowdsaleWallet(json));\n\t//}\n\tfunction getJsonWalletAddress(json) {\n\t    if (isCrowdsaleWallet(json)) {\n\t        try {\n\t            return (0, lib$6.getAddress)(JSON.parse(json).ethaddr);\n\t        }\n\t        catch (error) {\n\t            return null;\n\t        }\n\t    }\n\t    if (isKeystoreWallet(json)) {\n\t        try {\n\t            return (0, lib$6.getAddress)(JSON.parse(json).address);\n\t        }\n\t        catch (error) {\n\t            return null;\n\t        }\n\t    }\n\t    return null;\n\t}\n\texports.getJsonWalletAddress = getJsonWalletAddress;\n\n\t});\n\n\tvar inspect$1 = /*@__PURE__*/getDefaultExportFromCjs(inspect);\n\n\tvar scrypt = createCommonjsModule(function (module, exports) {\n\t\"use strict\";\n\n\t(function(root) {\n\t    const MAX_VALUE = 0x7fffffff;\n\n\t    // The SHA256 and PBKDF2 implementation are from scrypt-async-js:\n\t    // See: https://github.com/dchest/scrypt-async-js\n\t    function SHA256(m) {\n\t        const K = new Uint32Array([\n\t           0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b,\n\t           0x59f111f1, 0x923f82a4, 0xab1c5ed5, 0xd807aa98, 0x12835b01,\n\t           0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7,\n\t           0xc19bf174, 0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc,\n\t           0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da, 0x983e5152,\n\t           0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147,\n\t           0x06ca6351, 0x14292967, 0x27b70a85, 0x2e1b2138, 0x4d2c6dfc,\n\t           0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,\n\t           0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819,\n\t           0xd6990624, 0xf40e3585, 0x106aa070, 0x19a4c116, 0x1e376c08,\n\t           0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f,\n\t           0x682e6ff3, 0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208,\n\t           0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2\n\t       ]);\n\n\t        let h0 = 0x6a09e667, h1 = 0xbb67ae85, h2 = 0x3c6ef372, h3 = 0xa54ff53a;\n\t        let h4 = 0x510e527f, h5 = 0x9b05688c, h6 = 0x1f83d9ab, h7 = 0x5be0cd19;\n\t        const w = new Uint32Array(64);\n\n\t        function blocks(p) {\n\t            let off = 0, len = p.length;\n\t            while (len >= 64) {\n\t                let a = h0, b = h1, c = h2, d = h3, e = h4, f = h5, g = h6, h = h7, u, i, j, t1, t2;\n\n\t                for (i = 0; i < 16; i++) {\n\t                    j = off + i*4;\n\t                    w[i] = ((p[j] & 0xff)<<24) | ((p[j+1] & 0xff)<<16) |\n\t                    ((p[j+2] & 0xff)<<8) | (p[j+3] & 0xff);\n\t                }\n\n\t                for (i = 16; i < 64; i++) {\n\t                    u = w[i-2];\n\t                    t1 = ((u>>>17) | (u<<(32-17))) ^ ((u>>>19) | (u<<(32-19))) ^ (u>>>10);\n\n\t                    u = w[i-15];\n\t                    t2 = ((u>>>7) | (u<<(32-7))) ^ ((u>>>18) | (u<<(32-18))) ^ (u>>>3);\n\n\t                    w[i] = (((t1 + w[i-7]) | 0) + ((t2 + w[i-16]) | 0)) | 0;\n\t                }\n\n\t                for (i = 0; i < 64; i++) {\n\t                    t1 = ((((((e>>>6) | (e<<(32-6))) ^ ((e>>>11) | (e<<(32-11))) ^\n\t                             ((e>>>25) | (e<<(32-25)))) + ((e & f) ^ (~e & g))) | 0) +\n\t                          ((h + ((K[i] + w[i]) | 0)) | 0)) | 0;\n\n\t                    t2 = ((((a>>>2) | (a<<(32-2))) ^ ((a>>>13) | (a<<(32-13))) ^\n\t                           ((a>>>22) | (a<<(32-22)))) + ((a & b) ^ (a & c) ^ (b & c))) | 0;\n\n\t                    h = g;\n\t                    g = f;\n\t                    f = e;\n\t                    e = (d + t1) | 0;\n\t                    d = c;\n\t                    c = b;\n\t                    b = a;\n\t                    a = (t1 + t2) | 0;\n\t                }\n\n\t                h0 = (h0 + a) | 0;\n\t                h1 = (h1 + b) | 0;\n\t                h2 = (h2 + c) | 0;\n\t                h3 = (h3 + d) | 0;\n\t                h4 = (h4 + e) | 0;\n\t                h5 = (h5 + f) | 0;\n\t                h6 = (h6 + g) | 0;\n\t                h7 = (h7 + h) | 0;\n\n\t                off += 64;\n\t                len -= 64;\n\t            }\n\t        }\n\n\t        blocks(m);\n\n\t        let i, bytesLeft = m.length % 64,\n\t        bitLenHi = (m.length / 0x20000000) | 0,\n\t        bitLenLo = m.length << 3,\n\t        numZeros = (bytesLeft < 56) ? 56 : 120,\n\t        p = m.slice(m.length - bytesLeft, m.length);\n\n\t        p.push(0x80);\n\t        for (i = bytesLeft + 1; i < numZeros; i++) { p.push(0); }\n\t        p.push((bitLenHi >>> 24) & 0xff);\n\t        p.push((bitLenHi >>> 16) & 0xff);\n\t        p.push((bitLenHi >>> 8)  & 0xff);\n\t        p.push((bitLenHi >>> 0)  & 0xff);\n\t        p.push((bitLenLo >>> 24) & 0xff);\n\t        p.push((bitLenLo >>> 16) & 0xff);\n\t        p.push((bitLenLo >>> 8)  & 0xff);\n\t        p.push((bitLenLo >>> 0)  & 0xff);\n\n\t        blocks(p);\n\n\t        return [\n\t            (h0 >>> 24) & 0xff, (h0 >>> 16) & 0xff, (h0 >>> 8) & 0xff, (h0 >>> 0) & 0xff,\n\t            (h1 >>> 24) & 0xff, (h1 >>> 16) & 0xff, (h1 >>> 8) & 0xff, (h1 >>> 0) & 0xff,\n\t            (h2 >>> 24) & 0xff, (h2 >>> 16) & 0xff, (h2 >>> 8) & 0xff, (h2 >>> 0) & 0xff,\n\t            (h3 >>> 24) & 0xff, (h3 >>> 16) & 0xff, (h3 >>> 8) & 0xff, (h3 >>> 0) & 0xff,\n\t            (h4 >>> 24) & 0xff, (h4 >>> 16) & 0xff, (h4 >>> 8) & 0xff, (h4 >>> 0) & 0xff,\n\t            (h5 >>> 24) & 0xff, (h5 >>> 16) & 0xff, (h5 >>> 8) & 0xff, (h5 >>> 0) & 0xff,\n\t            (h6 >>> 24) & 0xff, (h6 >>> 16) & 0xff, (h6 >>> 8) & 0xff, (h6 >>> 0) & 0xff,\n\t            (h7 >>> 24) & 0xff, (h7 >>> 16) & 0xff, (h7 >>> 8) & 0xff, (h7 >>> 0) & 0xff\n\t        ];\n\t    }\n\n\t    function PBKDF2_HMAC_SHA256_OneIter(password, salt, dkLen) {\n\t        // compress password if it's longer than hash block length\n\t        password = (password.length <= 64) ? password : SHA256(password);\n\n\t        const innerLen = 64 + salt.length + 4;\n\t        const inner = new Array(innerLen);\n\t        const outerKey = new Array(64);\n\n\t        let i;\n\t        let dk = [];\n\n\t        // inner = (password ^ ipad) || salt || counter\n\t        for (i = 0; i < 64; i++) { inner[i] = 0x36; }\n\t        for (i = 0; i < password.length; i++) { inner[i] ^= password[i]; }\n\t        for (i = 0; i < salt.length; i++) { inner[64 + i] = salt[i]; }\n\t        for (i = innerLen - 4; i < innerLen; i++) { inner[i] = 0; }\n\n\t        // outerKey = password ^ opad\n\t        for (i = 0; i < 64; i++) outerKey[i] = 0x5c;\n\t        for (i = 0; i < password.length; i++) outerKey[i] ^= password[i];\n\n\t        // increments counter inside inner\n\t        function incrementCounter() {\n\t            for (let i = innerLen - 1; i >= innerLen - 4; i--) {\n\t                inner[i]++;\n\t                if (inner[i] <= 0xff) return;\n\t                inner[i] = 0;\n\t            }\n\t        }\n\n\t        // output blocks = SHA256(outerKey || SHA256(inner)) ...\n\t        while (dkLen >= 32) {\n\t            incrementCounter();\n\t            dk = dk.concat(SHA256(outerKey.concat(SHA256(inner))));\n\t            dkLen -= 32;\n\t        }\n\t        if (dkLen > 0) {\n\t            incrementCounter();\n\t            dk = dk.concat(SHA256(outerKey.concat(SHA256(inner))).slice(0, dkLen));\n\t        }\n\n\t        return dk;\n\t    }\n\n\t    // The following is an adaptation of scryptsy\n\t    // See: https://www.npmjs.com/package/scryptsy\n\t    function blockmix_salsa8(BY, Yi, r, x, _X) {\n\t        let i;\n\n\t        arraycopy(BY, (2 * r - 1) * 16, _X, 0, 16);\n\t        for (i = 0; i < 2 * r; i++) {\n\t            blockxor(BY, i * 16, _X, 16);\n\t            salsa20_8(_X, x);\n\t            arraycopy(_X, 0, BY, Yi + (i * 16), 16);\n\t        }\n\n\t        for (i = 0; i < r; i++) {\n\t            arraycopy(BY, Yi + (i * 2) * 16, BY, (i * 16), 16);\n\t        }\n\n\t        for (i = 0; i < r; i++) {\n\t            arraycopy(BY, Yi + (i * 2 + 1) * 16, BY, (i + r) * 16, 16);\n\t        }\n\t    }\n\n\t    function R(a, b) {\n\t        return (a << b) | (a >>> (32 - b));\n\t    }\n\n\t    function salsa20_8(B, x) {\n\t        arraycopy(B, 0, x, 0, 16);\n\n\t        for (let i = 8; i > 0; i -= 2) {\n\t            x[ 4] ^= R(x[ 0] + x[12], 7);\n\t            x[ 8] ^= R(x[ 4] + x[ 0], 9);\n\t            x[12] ^= R(x[ 8] + x[ 4], 13);\n\t            x[ 0] ^= R(x[12] + x[ 8], 18);\n\t            x[ 9] ^= R(x[ 5] + x[ 1], 7);\n\t            x[13] ^= R(x[ 9] + x[ 5], 9);\n\t            x[ 1] ^= R(x[13] + x[ 9], 13);\n\t            x[ 5] ^= R(x[ 1] + x[13], 18);\n\t            x[14] ^= R(x[10] + x[ 6], 7);\n\t            x[ 2] ^= R(x[14] + x[10], 9);\n\t            x[ 6] ^= R(x[ 2] + x[14], 13);\n\t            x[10] ^= R(x[ 6] + x[ 2], 18);\n\t            x[ 3] ^= R(x[15] + x[11], 7);\n\t            x[ 7] ^= R(x[ 3] + x[15], 9);\n\t            x[11] ^= R(x[ 7] + x[ 3], 13);\n\t            x[15] ^= R(x[11] + x[ 7], 18);\n\t            x[ 1] ^= R(x[ 0] + x[ 3], 7);\n\t            x[ 2] ^= R(x[ 1] + x[ 0], 9);\n\t            x[ 3] ^= R(x[ 2] + x[ 1], 13);\n\t            x[ 0] ^= R(x[ 3] + x[ 2], 18);\n\t            x[ 6] ^= R(x[ 5] + x[ 4], 7);\n\t            x[ 7] ^= R(x[ 6] + x[ 5], 9);\n\t            x[ 4] ^= R(x[ 7] + x[ 6], 13);\n\t            x[ 5] ^= R(x[ 4] + x[ 7], 18);\n\t            x[11] ^= R(x[10] + x[ 9], 7);\n\t            x[ 8] ^= R(x[11] + x[10], 9);\n\t            x[ 9] ^= R(x[ 8] + x[11], 13);\n\t            x[10] ^= R(x[ 9] + x[ 8], 18);\n\t            x[12] ^= R(x[15] + x[14], 7);\n\t            x[13] ^= R(x[12] + x[15], 9);\n\t            x[14] ^= R(x[13] + x[12], 13);\n\t            x[15] ^= R(x[14] + x[13], 18);\n\t        }\n\n\t        for (let i = 0; i < 16; ++i) {\n\t            B[i] += x[i];\n\t        }\n\t    }\n\n\t    // naive approach... going back to loop unrolling may yield additional performance\n\t    function blockxor(S, Si, D, len) {\n\t        for (let i = 0; i < len; i++) {\n\t            D[i] ^= S[Si + i];\n\t        }\n\t    }\n\n\t    function arraycopy(src, srcPos, dest, destPos, length) {\n\t        while (length--) {\n\t            dest[destPos++] = src[srcPos++];\n\t        }\n\t    }\n\n\t    function checkBufferish(o) {\n\t        if (!o || typeof(o.length) !== 'number') { return false; }\n\n\t        for (let i = 0; i < o.length; i++) {\n\t            const v = o[i];\n\t            if (typeof(v) !== 'number' || v % 1 || v < 0 || v >= 256) {\n\t                return false;\n\t            }\n\t        }\n\n\t        return true;\n\t    }\n\n\t    function ensureInteger(value, name) {\n\t        if (typeof(value) !== \"number\" || (value % 1)) { throw new Error('invalid ' + name); }\n\t        return value;\n\t    }\n\n\t    // N = Cpu cost, r = Memory cost, p = parallelization cost\n\t    // callback(error, progress, key)\n\t    function _scrypt(password, salt, N, r, p, dkLen, callback) {\n\n\t        N = ensureInteger(N, 'N');\n\t        r = ensureInteger(r, 'r');\n\t        p = ensureInteger(p, 'p');\n\n\t        dkLen = ensureInteger(dkLen, 'dkLen');\n\n\t        if (N === 0 || (N & (N - 1)) !== 0) { throw new Error('N must be power of 2'); }\n\n\t        if (N > MAX_VALUE / 128 / r) { throw new Error('N too large'); }\n\t        if (r > MAX_VALUE / 128 / p) { throw new Error('r too large'); }\n\n\t        if (!checkBufferish(password)) {\n\t            throw new Error('password must be an array or buffer');\n\t        }\n\t        password = Array.prototype.slice.call(password);\n\n\t        if (!checkBufferish(salt)) {\n\t            throw new Error('salt must be an array or buffer');\n\t        }\n\t        salt = Array.prototype.slice.call(salt);\n\n\t        let b = PBKDF2_HMAC_SHA256_OneIter(password, salt, p * 128 * r);\n\t        const B = new Uint32Array(p * 32 * r);\n\t        for (let i = 0; i < B.length; i++) {\n\t            const j = i * 4;\n\t            B[i] = ((b[j + 3] & 0xff) << 24) |\n\t                   ((b[j + 2] & 0xff) << 16) |\n\t                   ((b[j + 1] & 0xff) << 8) |\n\t                   ((b[j + 0] & 0xff) << 0);\n\t        }\n\n\t        const XY = new Uint32Array(64 * r);\n\t        const V = new Uint32Array(32 * r * N);\n\n\t        const Yi = 32 * r;\n\n\t        // scratch space\n\t        const x = new Uint32Array(16);       // salsa20_8\n\t        const _X = new Uint32Array(16);      // blockmix_salsa8\n\n\t        const totalOps = p * N * 2;\n\t        let currentOp = 0;\n\t        let lastPercent10 = null;\n\n\t        // Set this to true to abandon the scrypt on the next step\n\t        let stop = false;\n\n\t        // State information\n\t        let state = 0;\n\t        let i0 = 0, i1;\n\t        let Bi;\n\n\t        // How many blockmix_salsa8 can we do per step?\n\t        const limit = callback ? parseInt(1000 / r): 0xffffffff;\n\n\t        // Trick from scrypt-async; if there is a setImmediate shim in place, use it\n\t        const nextTick = (typeof(setImmediate) !== 'undefined') ? setImmediate : setTimeout;\n\n\t        // This is really all I changed; making scryptsy a state machine so we occasionally\n\t        // stop and give other evnts on the evnt loop a chance to run. ~RicMoo\n\t        const incrementalSMix = function() {\n\t            if (stop) {\n\t                return callback(new Error('cancelled'), currentOp / totalOps);\n\t            }\n\n\t            let steps;\n\n\t            switch (state) {\n\t                case 0:\n\t                    // for (var i = 0; i < p; i++)...\n\t                    Bi = i0 * 32 * r;\n\n\t                    arraycopy(B, Bi, XY, 0, Yi);                       // ROMix - 1\n\n\t                    state = 1;                                         // Move to ROMix 2\n\t                    i1 = 0;\n\n\t                    // Fall through\n\n\t                case 1:\n\n\t                    // Run up to 1000 steps of the first inner smix loop\n\t                    steps = N - i1;\n\t                    if (steps > limit) { steps = limit; }\n\t                    for (let i = 0; i < steps; i++) {                  // ROMix - 2\n\t                        arraycopy(XY, 0, V, (i1 + i) * Yi, Yi);         // ROMix - 3\n\t                        blockmix_salsa8(XY, Yi, r, x, _X);             // ROMix - 4\n\t                    }\n\n\t                    // for (var i = 0; i < N; i++)\n\t                    i1 += steps;\n\t                    currentOp += steps;\n\n\t                    if (callback) {\n\t                        // Call the callback with the progress (optionally stopping us)\n\t                        const percent10 = parseInt(1000 * currentOp / totalOps);\n\t                        if (percent10 !== lastPercent10) {\n\t                            stop = callback(null, currentOp / totalOps);\n\t                            if (stop) { break; }\n\t                            lastPercent10 = percent10;\n\t                        }\n\t                    }\n\n\t                    if (i1 < N) { break; }\n\n\t                    i1 = 0;                                          // Move to ROMix 6\n\t                    state = 2;\n\n\t                    // Fall through\n\n\t                case 2:\n\n\t                    // Run up to 1000 steps of the second inner smix loop\n\t                    steps = N - i1;\n\t                    if (steps > limit) { steps = limit; }\n\t                    for (let i = 0; i < steps; i++) {                // ROMix - 6\n\t                        const offset = (2 * r - 1) * 16;             // ROMix - 7\n\t                        const j = XY[offset] & (N - 1);\n\t                        blockxor(V, j * Yi, XY, Yi);                 // ROMix - 8 (inner)\n\t                        blockmix_salsa8(XY, Yi, r, x, _X);           // ROMix - 9 (outer)\n\t                    }\n\n\t                    // for (var i = 0; i < N; i++)...\n\t                    i1 += steps;\n\t                    currentOp += steps;\n\n\t                    // Call the callback with the progress (optionally stopping us)\n\t                    if (callback) {\n\t                        const percent10 = parseInt(1000 * currentOp / totalOps);\n\t                        if (percent10 !== lastPercent10) {\n\t                            stop = callback(null, currentOp / totalOps);\n\t                            if (stop) { break; }\n\t                            lastPercent10 = percent10;\n\t                        }\n\t                    }\n\n\t                    if (i1 < N) { break; }\n\n\t                    arraycopy(XY, 0, B, Bi, Yi);                     // ROMix - 10\n\n\t                    // for (var i = 0; i < p; i++)...\n\t                    i0++;\n\t                    if (i0 < p) {\n\t                        state = 0;\n\t                        break;\n\t                    }\n\n\t                    b = [];\n\t                    for (let i = 0; i < B.length; i++) {\n\t                        b.push((B[i] >>  0) & 0xff);\n\t                        b.push((B[i] >>  8) & 0xff);\n\t                        b.push((B[i] >> 16) & 0xff);\n\t                        b.push((B[i] >> 24) & 0xff);\n\t                    }\n\n\t                    const derivedKey = PBKDF2_HMAC_SHA256_OneIter(password, b, dkLen);\n\n\t                    // Send the result to the callback\n\t                    if (callback) { callback(null, 1.0, derivedKey); }\n\n\t                    // Done; don't break (which would reschedule)\n\t                    return derivedKey;\n\t            }\n\n\t            // Schedule the next steps\n\t            if (callback) { nextTick(incrementalSMix); }\n\t        };\n\n\t        // Run the smix state machine until completion\n\t        if (!callback) {\n\t            while (true) {\n\t                const derivedKey = incrementalSMix();\n\t                if (derivedKey != undefined) { return derivedKey; }\n\t            }\n\t        }\n\n\t        // Bootstrap the async incremental smix\n\t        incrementalSMix();\n\t    }\n\n\t    const lib = {\n\t        scrypt: function(password, salt, N, r, p, dkLen, progressCallback) {\n\t            return new Promise(function(resolve, reject) {\n\t                let lastProgress = 0;\n\t                if (progressCallback) { progressCallback(0); }\n\t                _scrypt(password, salt, N, r, p, dkLen, function(error, progress, key) {\n\t                    if (error) {\n\t                        reject(error);\n\t                    } else if (key) {\n\t                        if (progressCallback && lastProgress !== 1) {\n\t                            progressCallback(1);\n\t                        }\n\t                        resolve(new Uint8Array(key));\n\t                    } else if (progressCallback && progress !== lastProgress) {\n\t                        lastProgress = progress;\n\t                        return progressCallback(progress);\n\t                    }\n\t                });\n\t            });\n\t        },\n\t        syncScrypt: function(password, salt, N, r, p, dkLen) {\n\t            return new Uint8Array(_scrypt(password, salt, N, r, p, dkLen));\n\t        }\n\t    };\n\n\t    // node.js\n\t    if (true) {\n\t       module.exports = lib;\n\n\t    // RequireJS/AMD\n\t    // http://www.requirejs.org/docs/api.html\n\t    // https://github.com/amdjs/amdjs-api/wiki/AMD\n\t    } else {}\n\n\t})(commonjsGlobal);\n\t});\n\n\tvar keystore = createCommonjsModule(function (module, exports) {\n\t\"use strict\";\n\tvar __extends = (commonjsGlobal && commonjsGlobal.__extends) || (function () {\n\t    var extendStatics = function (d, b) {\n\t        extendStatics = Object.setPrototypeOf ||\n\t            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n\t            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n\t        return extendStatics(d, b);\n\t    };\n\t    return function (d, b) {\n\t        if (typeof b !== \"function\" && b !== null)\n\t            throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n\t        extendStatics(d, b);\n\t        function __() { this.constructor = d; }\n\t        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n\t    };\n\t})();\n\tvar __awaiter = (commonjsGlobal && commonjsGlobal.__awaiter) || function (thisArg, _arguments, P, generator) {\n\t    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n\t    return new (P || (P = Promise))(function (resolve, reject) {\n\t        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n\t        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n\t        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n\t        step((generator = generator.apply(thisArg, _arguments || [])).next());\n\t    });\n\t};\n\tvar __generator = (commonjsGlobal && commonjsGlobal.__generator) || function (thisArg, body) {\n\t    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\n\t    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\n\t    function verb(n) { return function (v) { return step([n, v]); }; }\n\t    function step(op) {\n\t        if (f) throw new TypeError(\"Generator is already executing.\");\n\t        while (_) try {\n\t            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n\t            if (y = 0, t) op = [op[0] & 2, t.value];\n\t            switch (op[0]) {\n\t                case 0: case 1: t = op; break;\n\t                case 4: _.label++; return { value: op[1], done: false };\n\t                case 5: _.label++; y = op[1]; op = [0]; continue;\n\t                case 7: op = _.ops.pop(); _.trys.pop(); continue;\n\t                default:\n\t                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\n\t                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\n\t                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\n\t                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\n\t                    if (t[2]) _.ops.pop();\n\t                    _.trys.pop(); continue;\n\t            }\n\t            op = body.call(thisArg, _);\n\t        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\n\t        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\n\t    }\n\t};\n\tvar __importDefault = (commonjsGlobal && commonjsGlobal.__importDefault) || function (mod) {\n\t    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n\t};\n\tObject.defineProperty(exports, \"__esModule\", { value: true });\n\texports.encrypt = exports.decrypt = exports.decryptSync = exports.KeystoreAccount = void 0;\n\tvar aes_js_1 = __importDefault(aesJs);\n\tvar scrypt_js_1 = __importDefault(scrypt);\n\n\n\n\n\n\n\n\n\n\n\n\tvar logger = new lib.Logger(_version$A.version);\n\t// Exported Types\n\tfunction hasMnemonic(value) {\n\t    return (value != null && value.mnemonic && value.mnemonic.phrase);\n\t}\n\tvar KeystoreAccount = /** @class */ (function (_super) {\n\t    __extends(KeystoreAccount, _super);\n\t    function KeystoreAccount() {\n\t        return _super !== null && _super.apply(this, arguments) || this;\n\t    }\n\t    KeystoreAccount.prototype.isKeystoreAccount = function (value) {\n\t        return !!(value && value._isKeystoreAccount);\n\t    };\n\t    return KeystoreAccount;\n\t}(lib$3.Description));\n\texports.KeystoreAccount = KeystoreAccount;\n\tfunction _decrypt(data, key, ciphertext) {\n\t    var cipher = (0, utils$1.searchPath)(data, \"crypto/cipher\");\n\t    if (cipher === \"aes-128-ctr\") {\n\t        var iv = (0, utils$1.looseArrayify)((0, utils$1.searchPath)(data, \"crypto/cipherparams/iv\"));\n\t        var counter = new aes_js_1.default.Counter(iv);\n\t        var aesCtr = new aes_js_1.default.ModeOfOperation.ctr(key, counter);\n\t        return (0, lib$1.arrayify)(aesCtr.decrypt(ciphertext));\n\t    }\n\t    return null;\n\t}\n\tfunction _getAccount(data, key) {\n\t    var ciphertext = (0, utils$1.looseArrayify)((0, utils$1.searchPath)(data, \"crypto/ciphertext\"));\n\t    var computedMAC = (0, lib$1.hexlify)((0, lib$4.keccak256)((0, lib$1.concat)([key.slice(16, 32), ciphertext]))).substring(2);\n\t    if (computedMAC !== (0, utils$1.searchPath)(data, \"crypto/mac\").toLowerCase()) {\n\t        throw new Error(\"invalid password\");\n\t    }\n\t    var privateKey = _decrypt(data, key.slice(0, 16), ciphertext);\n\t    if (!privateKey) {\n\t        logger.throwError(\"unsupported cipher\", lib.Logger.errors.UNSUPPORTED_OPERATION, {\n\t            operation: \"decrypt\"\n\t        });\n\t    }\n\t    var mnemonicKey = key.slice(32, 64);\n\t    var address = (0, lib$e.computeAddress)(privateKey);\n\t    if (data.address) {\n\t        var check = data.address.toLowerCase();\n\t        if (check.substring(0, 2) !== \"0x\") {\n\t            check = \"0x\" + check;\n\t        }\n\t        if ((0, lib$6.getAddress)(check) !== address) {\n\t            throw new Error(\"address mismatch\");\n\t        }\n\t    }\n\t    var account = {\n\t        _isKeystoreAccount: true,\n\t        address: address,\n\t        privateKey: (0, lib$1.hexlify)(privateKey)\n\t    };\n\t    // Version 0.1 x-ethers metadata must contain an encrypted mnemonic phrase\n\t    if ((0, utils$1.searchPath)(data, \"x-ethers/version\") === \"0.1\") {\n\t        var mnemonicCiphertext = (0, utils$1.looseArrayify)((0, utils$1.searchPath)(data, \"x-ethers/mnemonicCiphertext\"));\n\t        var mnemonicIv = (0, utils$1.looseArrayify)((0, utils$1.searchPath)(data, \"x-ethers/mnemonicCounter\"));\n\t        var mnemonicCounter = new aes_js_1.default.Counter(mnemonicIv);\n\t        var mnemonicAesCtr = new aes_js_1.default.ModeOfOperation.ctr(mnemonicKey, mnemonicCounter);\n\t        var path = (0, utils$1.searchPath)(data, \"x-ethers/path\") || lib$k.defaultPath;\n\t        var locale = (0, utils$1.searchPath)(data, \"x-ethers/locale\") || \"en\";\n\t        var entropy = (0, lib$1.arrayify)(mnemonicAesCtr.decrypt(mnemonicCiphertext));\n\t        try {\n\t            var mnemonic = (0, lib$k.entropyToMnemonic)(entropy, locale);\n\t            var node = lib$k.HDNode.fromMnemonic(mnemonic, null, locale).derivePath(path);\n\t            if (node.privateKey != account.privateKey) {\n\t                throw new Error(\"mnemonic mismatch\");\n\t            }\n\t            account.mnemonic = node.mnemonic;\n\t        }\n\t        catch (error) {\n\t            // If we don't have the locale wordlist installed to\n\t            // read this mnemonic, just bail and don't set the\n\t            // mnemonic\n\t            if (error.code !== lib.Logger.errors.INVALID_ARGUMENT || error.argument !== \"wordlist\") {\n\t                throw error;\n\t            }\n\t        }\n\t    }\n\t    return new KeystoreAccount(account);\n\t}\n\tfunction pbkdf2Sync(passwordBytes, salt, count, dkLen, prfFunc) {\n\t    return (0, lib$1.arrayify)((0, lib$i.pbkdf2)(passwordBytes, salt, count, dkLen, prfFunc));\n\t}\n\tfunction pbkdf2(passwordBytes, salt, count, dkLen, prfFunc) {\n\t    return Promise.resolve(pbkdf2Sync(passwordBytes, salt, count, dkLen, prfFunc));\n\t}\n\tfunction _computeKdfKey(data, password, pbkdf2Func, scryptFunc, progressCallback) {\n\t    var passwordBytes = (0, utils$1.getPassword)(password);\n\t    var kdf = (0, utils$1.searchPath)(data, \"crypto/kdf\");\n\t    if (kdf && typeof (kdf) === \"string\") {\n\t        var throwError = function (name, value) {\n\t            return logger.throwArgumentError(\"invalid key-derivation function parameters\", name, value);\n\t        };\n\t        if (kdf.toLowerCase() === \"scrypt\") {\n\t            var salt = (0, utils$1.looseArrayify)((0, utils$1.searchPath)(data, \"crypto/kdfparams/salt\"));\n\t            var N = parseInt((0, utils$1.searchPath)(data, \"crypto/kdfparams/n\"));\n\t            var r = parseInt((0, utils$1.searchPath)(data, \"crypto/kdfparams/r\"));\n\t            var p = parseInt((0, utils$1.searchPath)(data, \"crypto/kdfparams/p\"));\n\t            // Check for all required parameters\n\t            if (!N || !r || !p) {\n\t                throwError(\"kdf\", kdf);\n\t            }\n\t            // Make sure N is a power of 2\n\t            if ((N & (N - 1)) !== 0) {\n\t                throwError(\"N\", N);\n\t            }\n\t            var dkLen = parseInt((0, utils$1.searchPath)(data, \"crypto/kdfparams/dklen\"));\n\t            if (dkLen !== 32) {\n\t                throwError(\"dklen\", dkLen);\n\t            }\n\t            return scryptFunc(passwordBytes, salt, N, r, p, 64, progressCallback);\n\t        }\n\t        else if (kdf.toLowerCase() === \"pbkdf2\") {\n\t            var salt = (0, utils$1.looseArrayify)((0, utils$1.searchPath)(data, \"crypto/kdfparams/salt\"));\n\t            var prfFunc = null;\n\t            var prf = (0, utils$1.searchPath)(data, \"crypto/kdfparams/prf\");\n\t            if (prf === \"hmac-sha256\") {\n\t                prfFunc = \"sha256\";\n\t            }\n\t            else if (prf === \"hmac-sha512\") {\n\t                prfFunc = \"sha512\";\n\t            }\n\t            else {\n\t                throwError(\"prf\", prf);\n\t            }\n\t            var count = parseInt((0, utils$1.searchPath)(data, \"crypto/kdfparams/c\"));\n\t            var dkLen = parseInt((0, utils$1.searchPath)(data, \"crypto/kdfparams/dklen\"));\n\t            if (dkLen !== 32) {\n\t                throwError(\"dklen\", dkLen);\n\t            }\n\t            return pbkdf2Func(passwordBytes, salt, count, dkLen, prfFunc);\n\t        }\n\t    }\n\t    return logger.throwArgumentError(\"unsupported key-derivation function\", \"kdf\", kdf);\n\t}\n\tfunction decryptSync(json, password) {\n\t    var data = JSON.parse(json);\n\t    var key = _computeKdfKey(data, password, pbkdf2Sync, scrypt_js_1.default.syncScrypt);\n\t    return _getAccount(data, key);\n\t}\n\texports.decryptSync = decryptSync;\n\tfunction decrypt(json, password, progressCallback) {\n\t    return __awaiter(this, void 0, void 0, function () {\n\t        var data, key;\n\t        return __generator(this, function (_a) {\n\t            switch (_a.label) {\n\t                case 0:\n\t                    data = JSON.parse(json);\n\t                    return [4 /*yield*/, _computeKdfKey(data, password, pbkdf2, scrypt_js_1.default.scrypt, progressCallback)];\n\t                case 1:\n\t                    key = _a.sent();\n\t                    return [2 /*return*/, _getAccount(data, key)];\n\t            }\n\t        });\n\t    });\n\t}\n\texports.decrypt = decrypt;\n\tfunction encrypt(account, password, options, progressCallback) {\n\t    try {\n\t        // Check the address matches the private key\n\t        if ((0, lib$6.getAddress)(account.address) !== (0, lib$e.computeAddress)(account.privateKey)) {\n\t            throw new Error(\"address/privateKey mismatch\");\n\t        }\n\t        // Check the mnemonic (if any) matches the private key\n\t        if (hasMnemonic(account)) {\n\t            var mnemonic = account.mnemonic;\n\t            var node = lib$k.HDNode.fromMnemonic(mnemonic.phrase, null, mnemonic.locale).derivePath(mnemonic.path || lib$k.defaultPath);\n\t            if (node.privateKey != account.privateKey) {\n\t                throw new Error(\"mnemonic mismatch\");\n\t            }\n\t        }\n\t    }\n\t    catch (e) {\n\t        return Promise.reject(e);\n\t    }\n\t    // The options are optional, so adjust the call as needed\n\t    if (typeof (options) === \"function\" && !progressCallback) {\n\t        progressCallback = options;\n\t        options = {};\n\t    }\n\t    if (!options) {\n\t        options = {};\n\t    }\n\t    var privateKey = (0, lib$1.arrayify)(account.privateKey);\n\t    var passwordBytes = (0, utils$1.getPassword)(password);\n\t    var entropy = null;\n\t    var path = null;\n\t    var locale = null;\n\t    if (hasMnemonic(account)) {\n\t        var srcMnemonic = account.mnemonic;\n\t        entropy = (0, lib$1.arrayify)((0, lib$k.mnemonicToEntropy)(srcMnemonic.phrase, srcMnemonic.locale || \"en\"));\n\t        path = srcMnemonic.path || lib$k.defaultPath;\n\t        locale = srcMnemonic.locale || \"en\";\n\t    }\n\t    var client = options.client;\n\t    if (!client) {\n\t        client = \"ethers.js\";\n\t    }\n\t    // Check/generate the salt\n\t    var salt = null;\n\t    if (options.salt) {\n\t        salt = (0, lib$1.arrayify)(options.salt);\n\t    }\n\t    else {\n\t        salt = (0, lib$l.randomBytes)(32);\n\t        ;\n\t    }\n\t    // Override initialization vector\n\t    var iv = null;\n\t    if (options.iv) {\n\t        iv = (0, lib$1.arrayify)(options.iv);\n\t        if (iv.length !== 16) {\n\t            throw new Error(\"invalid iv\");\n\t        }\n\t    }\n\t    else {\n\t        iv = (0, lib$l.randomBytes)(16);\n\t    }\n\t    // Override the uuid\n\t    var uuidRandom = null;\n\t    if (options.uuid) {\n\t        uuidRandom = (0, lib$1.arrayify)(options.uuid);\n\t        if (uuidRandom.length !== 16) {\n\t            throw new Error(\"invalid uuid\");\n\t        }\n\t    }\n\t    else {\n\t        uuidRandom = (0, lib$l.randomBytes)(16);\n\t    }\n\t    // Override the scrypt password-based key derivation function parameters\n\t    var N = (1 << 17), r = 8, p = 1;\n\t    if (options.scrypt) {\n\t        if (options.scrypt.N) {\n\t            N = options.scrypt.N;\n\t        }\n\t        if (options.scrypt.r) {\n\t            r = options.scrypt.r;\n\t        }\n\t        if (options.scrypt.p) {\n\t            p = options.scrypt.p;\n\t        }\n\t    }\n\t    // We take 64 bytes:\n\t    //   - 32 bytes   As normal for the Web3 secret storage (derivedKey, macPrefix)\n\t    //   - 32 bytes   AES key to encrypt mnemonic with (required here to be Ethers Wallet)\n\t    return scrypt_js_1.default.scrypt(passwordBytes, salt, N, r, p, 64, progressCallback).then(function (key) {\n\t        key = (0, lib$1.arrayify)(key);\n\t        // This will be used to encrypt the wallet (as per Web3 secret storage)\n\t        var derivedKey = key.slice(0, 16);\n\t        var macPrefix = key.slice(16, 32);\n\t        // This will be used to encrypt the mnemonic phrase (if any)\n\t        var mnemonicKey = key.slice(32, 64);\n\t        // Encrypt the private key\n\t        var counter = new aes_js_1.default.Counter(iv);\n\t        var aesCtr = new aes_js_1.default.ModeOfOperation.ctr(derivedKey, counter);\n\t        var ciphertext = (0, lib$1.arrayify)(aesCtr.encrypt(privateKey));\n\t        // Compute the message authentication code, used to check the password\n\t        var mac = (0, lib$4.keccak256)((0, lib$1.concat)([macPrefix, ciphertext]));\n\t        // See: https://github.com/ethereum/wiki/wiki/Web3-Secret-Storage-Definition\n\t        var data = {\n\t            address: account.address.substring(2).toLowerCase(),\n\t            id: (0, utils$1.uuidV4)(uuidRandom),\n\t            version: 3,\n\t            Crypto: {\n\t                cipher: \"aes-128-ctr\",\n\t                cipherparams: {\n\t                    iv: (0, lib$1.hexlify)(iv).substring(2),\n\t                },\n\t                ciphertext: (0, lib$1.hexlify)(ciphertext).substring(2),\n\t                kdf: \"scrypt\",\n\t                kdfparams: {\n\t                    salt: (0, lib$1.hexlify)(salt).substring(2),\n\t                    n: N,\n\t                    dklen: 32,\n\t                    p: p,\n\t                    r: r\n\t                },\n\t                mac: mac.substring(2)\n\t            }\n\t        };\n\t        // If we have a mnemonic, encrypt it into the JSON wallet\n\t        if (entropy) {\n\t            var mnemonicIv = (0, lib$l.randomBytes)(16);\n\t            var mnemonicCounter = new aes_js_1.default.Counter(mnemonicIv);\n\t            var mnemonicAesCtr = new aes_js_1.default.ModeOfOperation.ctr(mnemonicKey, mnemonicCounter);\n\t            var mnemonicCiphertext = (0, lib$1.arrayify)(mnemonicAesCtr.encrypt(entropy));\n\t            var now = new Date();\n\t            var timestamp = (now.getUTCFullYear() + \"-\" +\n\t                (0, utils$1.zpad)(now.getUTCMonth() + 1, 2) + \"-\" +\n\t                (0, utils$1.zpad)(now.getUTCDate(), 2) + \"T\" +\n\t                (0, utils$1.zpad)(now.getUTCHours(), 2) + \"-\" +\n\t                (0, utils$1.zpad)(now.getUTCMinutes(), 2) + \"-\" +\n\t                (0, utils$1.zpad)(now.getUTCSeconds(), 2) + \".0Z\");\n\t            data[\"x-ethers\"] = {\n\t                client: client,\n\t                gethFilename: (\"UTC--\" + timestamp + \"--\" + data.address),\n\t                mnemonicCounter: (0, lib$1.hexlify)(mnemonicIv).substring(2),\n\t                mnemonicCiphertext: (0, lib$1.hexlify)(mnemonicCiphertext).substring(2),\n\t                path: path,\n\t                locale: locale,\n\t                version: \"0.1\"\n\t            };\n\t        }\n\t        return JSON.stringify(data);\n\t    });\n\t}\n\texports.encrypt = encrypt;\n\n\t});\n\n\tvar keystore$1 = /*@__PURE__*/getDefaultExportFromCjs(keystore);\n\n\tvar lib$m = createCommonjsModule(function (module, exports) {\n\t\"use strict\";\n\tObject.defineProperty(exports, \"__esModule\", { value: true });\n\texports.decryptJsonWalletSync = exports.decryptJsonWallet = exports.getJsonWalletAddress = exports.isKeystoreWallet = exports.isCrowdsaleWallet = exports.encryptKeystore = exports.decryptKeystoreSync = exports.decryptKeystore = exports.decryptCrowdsale = void 0;\n\n\tObject.defineProperty(exports, \"decryptCrowdsale\", { enumerable: true, get: function () { return crowdsale.decrypt; } });\n\n\tObject.defineProperty(exports, \"getJsonWalletAddress\", { enumerable: true, get: function () { return inspect.getJsonWalletAddress; } });\n\tObject.defineProperty(exports, \"isCrowdsaleWallet\", { enumerable: true, get: function () { return inspect.isCrowdsaleWallet; } });\n\tObject.defineProperty(exports, \"isKeystoreWallet\", { enumerable: true, get: function () { return inspect.isKeystoreWallet; } });\n\n\tObject.defineProperty(exports, \"decryptKeystore\", { enumerable: true, get: function () { return keystore.decrypt; } });\n\tObject.defineProperty(exports, \"decryptKeystoreSync\", { enumerable: true, get: function () { return keystore.decryptSync; } });\n\tObject.defineProperty(exports, \"encryptKeystore\", { enumerable: true, get: function () { return keystore.encrypt; } });\n\tfunction decryptJsonWallet(json, password, progressCallback) {\n\t    if ((0, inspect.isCrowdsaleWallet)(json)) {\n\t        if (progressCallback) {\n\t            progressCallback(0);\n\t        }\n\t        var account = (0, crowdsale.decrypt)(json, password);\n\t        if (progressCallback) {\n\t            progressCallback(1);\n\t        }\n\t        return Promise.resolve(account);\n\t    }\n\t    if ((0, inspect.isKeystoreWallet)(json)) {\n\t        return (0, keystore.decrypt)(json, password, progressCallback);\n\t    }\n\t    return Promise.reject(new Error(\"invalid JSON wallet\"));\n\t}\n\texports.decryptJsonWallet = decryptJsonWallet;\n\tfunction decryptJsonWalletSync(json, password) {\n\t    if ((0, inspect.isCrowdsaleWallet)(json)) {\n\t        return (0, crowdsale.decrypt)(json, password);\n\t    }\n\t    if ((0, inspect.isKeystoreWallet)(json)) {\n\t        return (0, keystore.decryptSync)(json, password);\n\t    }\n\t    throw new Error(\"invalid JSON wallet\");\n\t}\n\texports.decryptJsonWalletSync = decryptJsonWalletSync;\n\n\t});\n\n\tvar index$m = /*@__PURE__*/getDefaultExportFromCjs(lib$m);\n\n\tvar _version$C = createCommonjsModule(function (module, exports) {\n\t\"use strict\";\n\tObject.defineProperty(exports, \"__esModule\", { value: true });\n\texports.version = void 0;\n\texports.version = \"wallet/5.5.0\";\n\n\t});\n\n\tvar _version$D = /*@__PURE__*/getDefaultExportFromCjs(_version$C);\n\n\tvar lib$n = createCommonjsModule(function (module, exports) {\n\t\"use strict\";\n\tvar __extends = (commonjsGlobal && commonjsGlobal.__extends) || (function () {\n\t    var extendStatics = function (d, b) {\n\t        extendStatics = Object.setPrototypeOf ||\n\t            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n\t            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n\t        return extendStatics(d, b);\n\t    };\n\t    return function (d, b) {\n\t        if (typeof b !== \"function\" && b !== null)\n\t            throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n\t        extendStatics(d, b);\n\t        function __() { this.constructor = d; }\n\t        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n\t    };\n\t})();\n\tvar __awaiter = (commonjsGlobal && commonjsGlobal.__awaiter) || function (thisArg, _arguments, P, generator) {\n\t    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n\t    return new (P || (P = Promise))(function (resolve, reject) {\n\t        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n\t        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n\t        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n\t        step((generator = generator.apply(thisArg, _arguments || [])).next());\n\t    });\n\t};\n\tvar __generator = (commonjsGlobal && commonjsGlobal.__generator) || function (thisArg, body) {\n\t    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\n\t    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\n\t    function verb(n) { return function (v) { return step([n, v]); }; }\n\t    function step(op) {\n\t        if (f) throw new TypeError(\"Generator is already executing.\");\n\t        while (_) try {\n\t            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n\t            if (y = 0, t) op = [op[0] & 2, t.value];\n\t            switch (op[0]) {\n\t                case 0: case 1: t = op; break;\n\t                case 4: _.label++; return { value: op[1], done: false };\n\t                case 5: _.label++; y = op[1]; op = [0]; continue;\n\t                case 7: op = _.ops.pop(); _.trys.pop(); continue;\n\t                default:\n\t                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\n\t                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\n\t                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\n\t                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\n\t                    if (t[2]) _.ops.pop();\n\t                    _.trys.pop(); continue;\n\t            }\n\t            op = body.call(thisArg, _);\n\t        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\n\t        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\n\t    }\n\t};\n\tObject.defineProperty(exports, \"__esModule\", { value: true });\n\texports.verifyTypedData = exports.verifyMessage = exports.Wallet = void 0;\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\tvar logger = new lib.Logger(_version$C.version);\n\tfunction isAccount(value) {\n\t    return (value != null && (0, lib$1.isHexString)(value.privateKey, 32) && value.address != null);\n\t}\n\tfunction hasMnemonic(value) {\n\t    var mnemonic = value.mnemonic;\n\t    return (mnemonic && mnemonic.phrase);\n\t}\n\tvar Wallet = /** @class */ (function (_super) {\n\t    __extends(Wallet, _super);\n\t    function Wallet(privateKey, provider) {\n\t        var _newTarget = this.constructor;\n\t        var _this = this;\n\t        logger.checkNew(_newTarget, Wallet);\n\t        _this = _super.call(this) || this;\n\t        if (isAccount(privateKey)) {\n\t            var signingKey_1 = new lib$d.SigningKey(privateKey.privateKey);\n\t            (0, lib$3.defineReadOnly)(_this, \"_signingKey\", function () { return signingKey_1; });\n\t            (0, lib$3.defineReadOnly)(_this, \"address\", (0, lib$e.computeAddress)(_this.publicKey));\n\t            if (_this.address !== (0, lib$6.getAddress)(privateKey.address)) {\n\t                logger.throwArgumentError(\"privateKey/address mismatch\", \"privateKey\", \"[REDACTED]\");\n\t            }\n\t            if (hasMnemonic(privateKey)) {\n\t                var srcMnemonic_1 = privateKey.mnemonic;\n\t                (0, lib$3.defineReadOnly)(_this, \"_mnemonic\", function () { return ({\n\t                    phrase: srcMnemonic_1.phrase,\n\t                    path: srcMnemonic_1.path || lib$k.defaultPath,\n\t                    locale: srcMnemonic_1.locale || \"en\"\n\t                }); });\n\t                var mnemonic = _this.mnemonic;\n\t                var node = lib$k.HDNode.fromMnemonic(mnemonic.phrase, null, mnemonic.locale).derivePath(mnemonic.path);\n\t                if ((0, lib$e.computeAddress)(node.privateKey) !== _this.address) {\n\t                    logger.throwArgumentError(\"mnemonic/address mismatch\", \"privateKey\", \"[REDACTED]\");\n\t                }\n\t            }\n\t            else {\n\t                (0, lib$3.defineReadOnly)(_this, \"_mnemonic\", function () { return null; });\n\t            }\n\t        }\n\t        else {\n\t            if (lib$d.SigningKey.isSigningKey(privateKey)) {\n\t                /* istanbul ignore if */\n\t                if (privateKey.curve !== \"secp256k1\") {\n\t                    logger.throwArgumentError(\"unsupported curve; must be secp256k1\", \"privateKey\", \"[REDACTED]\");\n\t                }\n\t                (0, lib$3.defineReadOnly)(_this, \"_signingKey\", function () { return privateKey; });\n\t            }\n\t            else {\n\t                // A lot of common tools do not prefix private keys with a 0x (see: #1166)\n\t                if (typeof (privateKey) === \"string\") {\n\t                    if (privateKey.match(/^[0-9a-f]*$/i) && privateKey.length === 64) {\n\t                        privateKey = \"0x\" + privateKey;\n\t                    }\n\t                }\n\t                var signingKey_2 = new lib$d.SigningKey(privateKey);\n\t                (0, lib$3.defineReadOnly)(_this, \"_signingKey\", function () { return signingKey_2; });\n\t            }\n\t            (0, lib$3.defineReadOnly)(_this, \"_mnemonic\", function () { return null; });\n\t            (0, lib$3.defineReadOnly)(_this, \"address\", (0, lib$e.computeAddress)(_this.publicKey));\n\t        }\n\t        /* istanbul ignore if */\n\t        if (provider && !lib$b.Provider.isProvider(provider)) {\n\t            logger.throwArgumentError(\"invalid provider\", \"provider\", provider);\n\t        }\n\t        (0, lib$3.defineReadOnly)(_this, \"provider\", provider || null);\n\t        return _this;\n\t    }\n\t    Object.defineProperty(Wallet.prototype, \"mnemonic\", {\n\t        get: function () { return this._mnemonic(); },\n\t        enumerable: false,\n\t        configurable: true\n\t    });\n\t    Object.defineProperty(Wallet.prototype, \"privateKey\", {\n\t        get: function () { return this._signingKey().privateKey; },\n\t        enumerable: false,\n\t        configurable: true\n\t    });\n\t    Object.defineProperty(Wallet.prototype, \"publicKey\", {\n\t        get: function () { return this._signingKey().publicKey; },\n\t        enumerable: false,\n\t        configurable: true\n\t    });\n\t    Wallet.prototype.getAddress = function () {\n\t        return Promise.resolve(this.address);\n\t    };\n\t    Wallet.prototype.connect = function (provider) {\n\t        return new Wallet(this, provider);\n\t    };\n\t    Wallet.prototype.signTransaction = function (transaction) {\n\t        var _this = this;\n\t        return (0, lib$3.resolveProperties)(transaction).then(function (tx) {\n\t            if (tx.from != null) {\n\t                if ((0, lib$6.getAddress)(tx.from) !== _this.address) {\n\t                    logger.throwArgumentError(\"transaction from address mismatch\", \"transaction.from\", transaction.from);\n\t                }\n\t                delete tx.from;\n\t            }\n\t            var signature = _this._signingKey().signDigest((0, lib$4.keccak256)((0, lib$e.serialize)(tx)));\n\t            return (0, lib$e.serialize)(tx, signature);\n\t        });\n\t    };\n\t    Wallet.prototype.signMessage = function (message) {\n\t        return __awaiter(this, void 0, void 0, function () {\n\t            return __generator(this, function (_a) {\n\t                return [2 /*return*/, (0, lib$1.joinSignature)(this._signingKey().signDigest((0, lib$9.hashMessage)(message)))];\n\t            });\n\t        });\n\t    };\n\t    Wallet.prototype._signTypedData = function (domain, types, value) {\n\t        return __awaiter(this, void 0, void 0, function () {\n\t            var populated;\n\t            var _this = this;\n\t            return __generator(this, function (_a) {\n\t                switch (_a.label) {\n\t                    case 0: return [4 /*yield*/, lib$9._TypedDataEncoder.resolveNames(domain, types, value, function (name) {\n\t                            if (_this.provider == null) {\n\t                                logger.throwError(\"cannot resolve ENS names without a provider\", lib.Logger.errors.UNSUPPORTED_OPERATION, {\n\t                                    operation: \"resolveName\",\n\t                                    value: name\n\t                                });\n\t                            }\n\t                            return _this.provider.resolveName(name);\n\t                        })];\n\t                    case 1:\n\t                        populated = _a.sent();\n\t                        return [2 /*return*/, (0, lib$1.joinSignature)(this._signingKey().signDigest(lib$9._TypedDataEncoder.hash(populated.domain, types, populated.value)))];\n\t                }\n\t            });\n\t        });\n\t    };\n\t    Wallet.prototype.encrypt = function (password, options, progressCallback) {\n\t        if (typeof (options) === \"function\" && !progressCallback) {\n\t            progressCallback = options;\n\t            options = {};\n\t        }\n\t        if (progressCallback && typeof (progressCallback) !== \"function\") {\n\t            throw new Error(\"invalid callback\");\n\t        }\n\t        if (!options) {\n\t            options = {};\n\t        }\n\t        return (0, lib$m.encryptKeystore)(this, password, options, progressCallback);\n\t    };\n\t    /**\n\t     *  Static methods to create Wallet instances.\n\t     */\n\t    Wallet.createRandom = function (options) {\n\t        var entropy = (0, lib$l.randomBytes)(16);\n\t        if (!options) {\n\t            options = {};\n\t        }\n\t        if (options.extraEntropy) {\n\t            entropy = (0, lib$1.arrayify)((0, lib$1.hexDataSlice)((0, lib$4.keccak256)((0, lib$1.concat)([entropy, options.extraEntropy])), 0, 16));\n\t        }\n\t        var mnemonic = (0, lib$k.entropyToMnemonic)(entropy, options.locale);\n\t        return Wallet.fromMnemonic(mnemonic, options.path, options.locale);\n\t    };\n\t    Wallet.fromEncryptedJson = function (json, password, progressCallback) {\n\t        return (0, lib$m.decryptJsonWallet)(json, password, progressCallback).then(function (account) {\n\t            return new Wallet(account);\n\t        });\n\t    };\n\t    Wallet.fromEncryptedJsonSync = function (json, password) {\n\t        return new Wallet((0, lib$m.decryptJsonWalletSync)(json, password));\n\t    };\n\t    Wallet.fromMnemonic = function (mnemonic, path, wordlist) {\n\t        if (!path) {\n\t            path = lib$k.defaultPath;\n\t        }\n\t        return new Wallet(lib$k.HDNode.fromMnemonic(mnemonic, null, wordlist).derivePath(path));\n\t    };\n\t    return Wallet;\n\t}(lib$c.Signer));\n\texports.Wallet = Wallet;\n\tfunction verifyMessage(message, signature) {\n\t    return (0, lib$e.recoverAddress)((0, lib$9.hashMessage)(message), signature);\n\t}\n\texports.verifyMessage = verifyMessage;\n\tfunction verifyTypedData(domain, types, value, signature) {\n\t    return (0, lib$e.recoverAddress)(lib$9._TypedDataEncoder.hash(domain, types, value), signature);\n\t}\n\texports.verifyTypedData = verifyTypedData;\n\n\t});\n\n\tvar index$n = /*@__PURE__*/getDefaultExportFromCjs(lib$n);\n\n\tvar _version$E = createCommonjsModule(function (module, exports) {\n\t\"use strict\";\n\tObject.defineProperty(exports, \"__esModule\", { value: true });\n\texports.version = void 0;\n\texports.version = \"networks/5.5.0\";\n\n\t});\n\n\tvar _version$F = /*@__PURE__*/getDefaultExportFromCjs(_version$E);\n\n\tvar lib$o = createCommonjsModule(function (module, exports) {\n\t\"use strict\";\n\tObject.defineProperty(exports, \"__esModule\", { value: true });\n\texports.getNetwork = void 0;\n\n\n\tvar logger = new lib.Logger(_version$E.version);\n\t;\n\tfunction isRenetworkable(value) {\n\t    return (value && typeof (value.renetwork) === \"function\");\n\t}\n\tfunction ethDefaultProvider(network) {\n\t    var func = function (providers, options) {\n\t        if (options == null) {\n\t            options = {};\n\t        }\n\t        var providerList = [];\n\t        if (providers.InfuraProvider) {\n\t            try {\n\t                providerList.push(new providers.InfuraProvider(network, options.infura));\n\t            }\n\t            catch (error) { }\n\t        }\n\t        if (providers.EtherscanProvider) {\n\t            try {\n\t                providerList.push(new providers.EtherscanProvider(network, options.etherscan));\n\t            }\n\t            catch (error) { }\n\t        }\n\t        if (providers.AlchemyProvider) {\n\t            try {\n\t                providerList.push(new providers.AlchemyProvider(network, options.alchemy));\n\t            }\n\t            catch (error) { }\n\t        }\n\t        if (providers.PocketProvider) {\n\t            // These networks are currently faulty on Pocket as their\n\t            // network does not handle the Berlin hardfork, which is\n\t            // live on these ones.\n\t            // @TODO: This goes away once Pocket has upgraded their nodes\n\t            var skip = [\"goerli\", \"ropsten\", \"rinkeby\"];\n\t            try {\n\t                var provider = new providers.PocketProvider(network);\n\t                if (provider.network && skip.indexOf(provider.network.name) === -1) {\n\t                    providerList.push(provider);\n\t                }\n\t            }\n\t            catch (error) { }\n\t        }\n\t        if (providers.CloudflareProvider) {\n\t            try {\n\t                providerList.push(new providers.CloudflareProvider(network));\n\t            }\n\t            catch (error) { }\n\t        }\n\t        if (providerList.length === 0) {\n\t            return null;\n\t        }\n\t        if (providers.FallbackProvider) {\n\t            var quorum = 1;\n\t            if (options.quorum != null) {\n\t                quorum = options.quorum;\n\t            }\n\t            else if (network === \"homestead\") {\n\t                quorum = 2;\n\t            }\n\t            return new providers.FallbackProvider(providerList, quorum);\n\t        }\n\t        return providerList[0];\n\t    };\n\t    func.renetwork = function (network) {\n\t        return ethDefaultProvider(network);\n\t    };\n\t    return func;\n\t}\n\tfunction etcDefaultProvider(url, network) {\n\t    var func = function (providers, options) {\n\t        if (providers.JsonRpcProvider) {\n\t            return new providers.JsonRpcProvider(url, network);\n\t        }\n\t        return null;\n\t    };\n\t    func.renetwork = function (network) {\n\t        return etcDefaultProvider(url, network);\n\t    };\n\t    return func;\n\t}\n\tvar homestead = {\n\t    chainId: 1,\n\t    ensAddress: \"0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e\",\n\t    name: \"homestead\",\n\t    _defaultProvider: ethDefaultProvider(\"homestead\")\n\t};\n\tvar ropsten = {\n\t    chainId: 3,\n\t    ensAddress: \"0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e\",\n\t    name: \"ropsten\",\n\t    _defaultProvider: ethDefaultProvider(\"ropsten\")\n\t};\n\tvar classicMordor = {\n\t    chainId: 63,\n\t    name: \"classicMordor\",\n\t    _defaultProvider: etcDefaultProvider(\"https://www.ethercluster.com/mordor\", \"classicMordor\")\n\t};\n\tvar networks = {\n\t    unspecified: { chainId: 0, name: \"unspecified\" },\n\t    homestead: homestead,\n\t    mainnet: homestead,\n\t    morden: { chainId: 2, name: \"morden\" },\n\t    ropsten: ropsten,\n\t    testnet: ropsten,\n\t    rinkeby: {\n\t        chainId: 4,\n\t        ensAddress: \"0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e\",\n\t        name: \"rinkeby\",\n\t        _defaultProvider: ethDefaultProvider(\"rinkeby\")\n\t    },\n\t    kovan: {\n\t        chainId: 42,\n\t        name: \"kovan\",\n\t        _defaultProvider: ethDefaultProvider(\"kovan\")\n\t    },\n\t    goerli: {\n\t        chainId: 5,\n\t        ensAddress: \"0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e\",\n\t        name: \"goerli\",\n\t        _defaultProvider: ethDefaultProvider(\"goerli\")\n\t    },\n\t    // ETC (See: #351)\n\t    classic: {\n\t        chainId: 61,\n\t        name: \"classic\",\n\t        _defaultProvider: etcDefaultProvider(\"https:/\\/www.ethercluster.com/etc\", \"classic\")\n\t    },\n\t    classicMorden: { chainId: 62, name: \"classicMorden\" },\n\t    classicMordor: classicMordor,\n\t    classicTestnet: classicMordor,\n\t    classicKotti: {\n\t        chainId: 6,\n\t        name: \"classicKotti\",\n\t        _defaultProvider: etcDefaultProvider(\"https:/\\/www.ethercluster.com/kotti\", \"classicKotti\")\n\t    },\n\t    xdai: { chainId: 100, name: \"xdai\" },\n\t    matic: { chainId: 137, name: \"matic\" },\n\t    maticmum: { chainId: 80001, name: \"maticmum\" },\n\t    bnb: { chainId: 56, name: \"bnb\" },\n\t    bnbt: { chainId: 97, name: \"bnbt\" },\n\t};\n\t/**\n\t *  getNetwork\n\t *\n\t *  Converts a named common networks or chain ID (network ID) to a Network\n\t *  and verifies a network is a valid Network..\n\t */\n\tfunction getNetwork(network) {\n\t    // No network (null)\n\t    if (network == null) {\n\t        return null;\n\t    }\n\t    if (typeof (network) === \"number\") {\n\t        for (var name_1 in networks) {\n\t            var standard_1 = networks[name_1];\n\t            if (standard_1.chainId === network) {\n\t                return {\n\t                    name: standard_1.name,\n\t                    chainId: standard_1.chainId,\n\t                    ensAddress: (standard_1.ensAddress || null),\n\t                    _defaultProvider: (standard_1._defaultProvider || null)\n\t                };\n\t            }\n\t        }\n\t        return {\n\t            chainId: network,\n\t            name: \"unknown\"\n\t        };\n\t    }\n\t    if (typeof (network) === \"string\") {\n\t        var standard_2 = networks[network];\n\t        if (standard_2 == null) {\n\t            return null;\n\t        }\n\t        return {\n\t            name: standard_2.name,\n\t            chainId: standard_2.chainId,\n\t            ensAddress: standard_2.ensAddress,\n\t            _defaultProvider: (standard_2._defaultProvider || null)\n\t        };\n\t    }\n\t    var standard = networks[network.name];\n\t    // Not a standard network; check that it is a valid network in general\n\t    if (!standard) {\n\t        if (typeof (network.chainId) !== \"number\") {\n\t            logger.throwArgumentError(\"invalid network chainId\", \"network\", network);\n\t        }\n\t        return network;\n\t    }\n\t    // Make sure the chainId matches the expected network chainId (or is 0; disable EIP-155)\n\t    if (network.chainId !== 0 && network.chainId !== standard.chainId) {\n\t        logger.throwArgumentError(\"network chainId mismatch\", \"network\", network);\n\t    }\n\t    // @TODO: In the next major version add an attach function to a defaultProvider\n\t    // class and move the _defaultProvider internal to this file (extend Network)\n\t    var defaultProvider = network._defaultProvider || null;\n\t    if (defaultProvider == null && standard._defaultProvider) {\n\t        if (isRenetworkable(standard._defaultProvider)) {\n\t            defaultProvider = standard._defaultProvider.renetwork(network);\n\t        }\n\t        else {\n\t            defaultProvider = standard._defaultProvider;\n\t        }\n\t    }\n\t    // Standard Network (allow overriding the ENS address)\n\t    return {\n\t        name: network.name,\n\t        chainId: standard.chainId,\n\t        ensAddress: (network.ensAddress || standard.ensAddress || null),\n\t        _defaultProvider: defaultProvider\n\t    };\n\t}\n\texports.getNetwork = getNetwork;\n\n\t});\n\n\tvar index$o = /*@__PURE__*/getDefaultExportFromCjs(lib$o);\n\n\tvar browserBase64 = createCommonjsModule(function (module, exports) {\n\t\"use strict\";\n\tObject.defineProperty(exports, \"__esModule\", { value: true });\n\texports.encode = exports.decode = void 0;\n\n\tfunction decode(textData) {\n\t    textData = atob(textData);\n\t    var data = [];\n\t    for (var i = 0; i < textData.length; i++) {\n\t        data.push(textData.charCodeAt(i));\n\t    }\n\t    return (0, lib$1.arrayify)(data);\n\t}\n\texports.decode = decode;\n\tfunction encode(data) {\n\t    data = (0, lib$1.arrayify)(data);\n\t    var textData = \"\";\n\t    for (var i = 0; i < data.length; i++) {\n\t        textData += String.fromCharCode(data[i]);\n\t    }\n\t    return btoa(textData);\n\t}\n\texports.encode = encode;\n\n\t});\n\n\tvar browserBase64$1 = /*@__PURE__*/getDefaultExportFromCjs(browserBase64);\n\n\tvar lib$p = createCommonjsModule(function (module, exports) {\n\t\"use strict\";\n\tObject.defineProperty(exports, \"__esModule\", { value: true });\n\texports.encode = exports.decode = void 0;\n\n\tObject.defineProperty(exports, \"decode\", { enumerable: true, get: function () { return browserBase64.decode; } });\n\tObject.defineProperty(exports, \"encode\", { enumerable: true, get: function () { return browserBase64.encode; } });\n\n\t});\n\n\tvar index$p = /*@__PURE__*/getDefaultExportFromCjs(lib$p);\n\n\tvar _version$G = createCommonjsModule(function (module, exports) {\n\t\"use strict\";\n\tObject.defineProperty(exports, \"__esModule\", { value: true });\n\texports.version = void 0;\n\texports.version = \"web/5.5.0\";\n\n\t});\n\n\tvar _version$H = /*@__PURE__*/getDefaultExportFromCjs(_version$G);\n\n\tvar browserGeturl = createCommonjsModule(function (module, exports) {\n\t\"use strict\";\n\tvar __awaiter = (commonjsGlobal && commonjsGlobal.__awaiter) || function (thisArg, _arguments, P, generator) {\n\t    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n\t    return new (P || (P = Promise))(function (resolve, reject) {\n\t        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n\t        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n\t        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n\t        step((generator = generator.apply(thisArg, _arguments || [])).next());\n\t    });\n\t};\n\tvar __generator = (commonjsGlobal && commonjsGlobal.__generator) || function (thisArg, body) {\n\t    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\n\t    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\n\t    function verb(n) { return function (v) { return step([n, v]); }; }\n\t    function step(op) {\n\t        if (f) throw new TypeError(\"Generator is already executing.\");\n\t        while (_) try {\n\t            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n\t            if (y = 0, t) op = [op[0] & 2, t.value];\n\t            switch (op[0]) {\n\t                case 0: case 1: t = op; break;\n\t                case 4: _.label++; return { value: op[1], done: false };\n\t                case 5: _.label++; y = op[1]; op = [0]; continue;\n\t                case 7: op = _.ops.pop(); _.trys.pop(); continue;\n\t                default:\n\t                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\n\t                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\n\t                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\n\t                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\n\t                    if (t[2]) _.ops.pop();\n\t                    _.trys.pop(); continue;\n\t            }\n\t            op = body.call(thisArg, _);\n\t        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\n\t        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\n\t    }\n\t};\n\tObject.defineProperty(exports, \"__esModule\", { value: true });\n\texports.getUrl = void 0;\n\n\tfunction getUrl(href, options) {\n\t    return __awaiter(this, void 0, void 0, function () {\n\t        var request, response, body, headers;\n\t        return __generator(this, function (_a) {\n\t            switch (_a.label) {\n\t                case 0:\n\t                    if (options == null) {\n\t                        options = {};\n\t                    }\n\t                    request = {\n\t                        method: (options.method || \"GET\"),\n\t                        headers: (options.headers || {}),\n\t                        body: (options.body || undefined),\n\t                    };\n\t                    if (options.skipFetchSetup !== true) {\n\t                        request.mode = \"cors\"; // no-cors, cors, *same-origin\n\t                        request.cache = \"no-cache\"; // *default, no-cache, reload, force-cache, only-if-cached\n\t                        request.credentials = \"same-origin\"; // include, *same-origin, omit\n\t                        request.redirect = \"follow\"; // manual, *follow, error\n\t                        request.referrer = \"client\"; // no-referrer, *client\n\t                    }\n\t                    ;\n\t                    return [4 /*yield*/, fetch(href, request)];\n\t                case 1:\n\t                    response = _a.sent();\n\t                    return [4 /*yield*/, response.arrayBuffer()];\n\t                case 2:\n\t                    body = _a.sent();\n\t                    headers = {};\n\t                    if (response.headers.forEach) {\n\t                        response.headers.forEach(function (value, key) {\n\t                            headers[key.toLowerCase()] = value;\n\t                        });\n\t                    }\n\t                    else {\n\t                        ((response.headers).keys)().forEach(function (key) {\n\t                            headers[key.toLowerCase()] = response.headers.get(key);\n\t                        });\n\t                    }\n\t                    return [2 /*return*/, {\n\t                            headers: headers,\n\t                            statusCode: response.status,\n\t                            statusMessage: response.statusText,\n\t                            body: (0, lib$1.arrayify)(new Uint8Array(body)),\n\t                        }];\n\t            }\n\t        });\n\t    });\n\t}\n\texports.getUrl = getUrl;\n\n\t});\n\n\tvar browserGeturl$1 = /*@__PURE__*/getDefaultExportFromCjs(browserGeturl);\n\n\tvar lib$q = createCommonjsModule(function (module, exports) {\n\t\"use strict\";\n\tvar __awaiter = (commonjsGlobal && commonjsGlobal.__awaiter) || function (thisArg, _arguments, P, generator) {\n\t    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n\t    return new (P || (P = Promise))(function (resolve, reject) {\n\t        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n\t        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n\t        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n\t        step((generator = generator.apply(thisArg, _arguments || [])).next());\n\t    });\n\t};\n\tvar __generator = (commonjsGlobal && commonjsGlobal.__generator) || function (thisArg, body) {\n\t    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\n\t    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\n\t    function verb(n) { return function (v) { return step([n, v]); }; }\n\t    function step(op) {\n\t        if (f) throw new TypeError(\"Generator is already executing.\");\n\t        while (_) try {\n\t            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n\t            if (y = 0, t) op = [op[0] & 2, t.value];\n\t            switch (op[0]) {\n\t                case 0: case 1: t = op; break;\n\t                case 4: _.label++; return { value: op[1], done: false };\n\t                case 5: _.label++; y = op[1]; op = [0]; continue;\n\t                case 7: op = _.ops.pop(); _.trys.pop(); continue;\n\t                default:\n\t                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\n\t                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\n\t                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\n\t                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\n\t                    if (t[2]) _.ops.pop();\n\t                    _.trys.pop(); continue;\n\t            }\n\t            op = body.call(thisArg, _);\n\t        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\n\t        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\n\t    }\n\t};\n\tObject.defineProperty(exports, \"__esModule\", { value: true });\n\texports.poll = exports.fetchJson = exports._fetchData = void 0;\n\n\n\n\n\n\n\tvar logger = new lib.Logger(_version$G.version);\n\n\tfunction staller(duration) {\n\t    return new Promise(function (resolve) {\n\t        setTimeout(resolve, duration);\n\t    });\n\t}\n\tfunction bodyify(value, type) {\n\t    if (value == null) {\n\t        return null;\n\t    }\n\t    if (typeof (value) === \"string\") {\n\t        return value;\n\t    }\n\t    if ((0, lib$1.isBytesLike)(value)) {\n\t        if (type && (type.split(\"/\")[0] === \"text\" || type.split(\";\")[0].trim() === \"application/json\")) {\n\t            try {\n\t                return (0, lib$8.toUtf8String)(value);\n\t            }\n\t            catch (error) { }\n\t            ;\n\t        }\n\t        return (0, lib$1.hexlify)(value);\n\t    }\n\t    return value;\n\t}\n\t// This API is still a work in progress; the future changes will likely be:\n\t// - ConnectionInfo => FetchDataRequest<T = any>\n\t// - FetchDataRequest.body? = string | Uint8Array | { contentType: string, data: string | Uint8Array }\n\t//   - If string => text/plain, Uint8Array => application/octet-stream (if content-type unspecified)\n\t// - FetchDataRequest.processFunc = (body: Uint8Array, response: FetchDataResponse) => T\n\t// For this reason, it should be considered internal until the API is finalized\n\tfunction _fetchData(connection, body, processFunc) {\n\t    // How many times to retry in the event of a throttle\n\t    var attemptLimit = (typeof (connection) === \"object\" && connection.throttleLimit != null) ? connection.throttleLimit : 12;\n\t    logger.assertArgument((attemptLimit > 0 && (attemptLimit % 1) === 0), \"invalid connection throttle limit\", \"connection.throttleLimit\", attemptLimit);\n\t    var throttleCallback = ((typeof (connection) === \"object\") ? connection.throttleCallback : null);\n\t    var throttleSlotInterval = ((typeof (connection) === \"object\" && typeof (connection.throttleSlotInterval) === \"number\") ? connection.throttleSlotInterval : 100);\n\t    logger.assertArgument((throttleSlotInterval > 0 && (throttleSlotInterval % 1) === 0), \"invalid connection throttle slot interval\", \"connection.throttleSlotInterval\", throttleSlotInterval);\n\t    var headers = {};\n\t    var url = null;\n\t    // @TODO: Allow ConnectionInfo to override some of these values\n\t    var options = {\n\t        method: \"GET\",\n\t    };\n\t    var allow304 = false;\n\t    var timeout = 2 * 60 * 1000;\n\t    if (typeof (connection) === \"string\") {\n\t        url = connection;\n\t    }\n\t    else if (typeof (connection) === \"object\") {\n\t        if (connection == null || connection.url == null) {\n\t            logger.throwArgumentError(\"missing URL\", \"connection.url\", connection);\n\t        }\n\t        url = connection.url;\n\t        if (typeof (connection.timeout) === \"number\" && connection.timeout > 0) {\n\t            timeout = connection.timeout;\n\t        }\n\t        if (connection.headers) {\n\t            for (var key in connection.headers) {\n\t                headers[key.toLowerCase()] = { key: key, value: String(connection.headers[key]) };\n\t                if ([\"if-none-match\", \"if-modified-since\"].indexOf(key.toLowerCase()) >= 0) {\n\t                    allow304 = true;\n\t                }\n\t            }\n\t        }\n\t        options.allowGzip = !!connection.allowGzip;\n\t        if (connection.user != null && connection.password != null) {\n\t            if (url.substring(0, 6) !== \"https:\" && connection.allowInsecureAuthentication !== true) {\n\t                logger.throwError(\"basic authentication requires a secure https url\", lib.Logger.errors.INVALID_ARGUMENT, { argument: \"url\", url: url, user: connection.user, password: \"[REDACTED]\" });\n\t            }\n\t            var authorization = connection.user + \":\" + connection.password;\n\t            headers[\"authorization\"] = {\n\t                key: \"Authorization\",\n\t                value: \"Basic \" + (0, lib$p.encode)((0, lib$8.toUtf8Bytes)(authorization))\n\t            };\n\t        }\n\t    }\n\t    if (body) {\n\t        options.method = \"POST\";\n\t        options.body = body;\n\t        if (headers[\"content-type\"] == null) {\n\t            headers[\"content-type\"] = { key: \"Content-Type\", value: \"application/octet-stream\" };\n\t        }\n\t        if (headers[\"content-length\"] == null) {\n\t            headers[\"content-length\"] = { key: \"Content-Length\", value: String(body.length) };\n\t        }\n\t    }\n\t    var flatHeaders = {};\n\t    Object.keys(headers).forEach(function (key) {\n\t        var header = headers[key];\n\t        flatHeaders[header.key] = header.value;\n\t    });\n\t    options.headers = flatHeaders;\n\t    var runningTimeout = (function () {\n\t        var timer = null;\n\t        var promise = new Promise(function (resolve, reject) {\n\t            if (timeout) {\n\t                timer = setTimeout(function () {\n\t                    if (timer == null) {\n\t                        return;\n\t                    }\n\t                    timer = null;\n\t                    reject(logger.makeError(\"timeout\", lib.Logger.errors.TIMEOUT, {\n\t                        requestBody: bodyify(options.body, flatHeaders[\"content-type\"]),\n\t                        requestMethod: options.method,\n\t                        timeout: timeout,\n\t                        url: url\n\t                    }));\n\t                }, timeout);\n\t            }\n\t        });\n\t        var cancel = function () {\n\t            if (timer == null) {\n\t                return;\n\t            }\n\t            clearTimeout(timer);\n\t            timer = null;\n\t        };\n\t        return { promise: promise, cancel: cancel };\n\t    })();\n\t    var runningFetch = (function () {\n\t        return __awaiter(this, void 0, void 0, function () {\n\t            var attempt, response, tryAgain, stall, retryAfter, error_1, body_1, result, error_2, tryAgain, timeout_1;\n\t            return __generator(this, function (_a) {\n\t                switch (_a.label) {\n\t                    case 0:\n\t                        attempt = 0;\n\t                        _a.label = 1;\n\t                    case 1:\n\t                        if (!(attempt < attemptLimit)) return [3 /*break*/, 19];\n\t                        response = null;\n\t                        _a.label = 2;\n\t                    case 2:\n\t                        _a.trys.push([2, 8, , 9]);\n\t                        return [4 /*yield*/, (0, browserGeturl.getUrl)(url, options)];\n\t                    case 3:\n\t                        response = _a.sent();\n\t                        if (!(response.statusCode === 429 && attempt < attemptLimit)) return [3 /*break*/, 7];\n\t                        tryAgain = true;\n\t                        if (!throttleCallback) return [3 /*break*/, 5];\n\t                        return [4 /*yield*/, throttleCallback(attempt, url)];\n\t                    case 4:\n\t                        tryAgain = _a.sent();\n\t                        _a.label = 5;\n\t                    case 5:\n\t                        if (!tryAgain) return [3 /*break*/, 7];\n\t                        stall = 0;\n\t                        retryAfter = response.headers[\"retry-after\"];\n\t                        if (typeof (retryAfter) === \"string\" && retryAfter.match(/^[1-9][0-9]*$/)) {\n\t                            stall = parseInt(retryAfter) * 1000;\n\t                        }\n\t                        else {\n\t                            stall = throttleSlotInterval * parseInt(String(Math.random() * Math.pow(2, attempt)));\n\t                        }\n\t                        //console.log(\"Stalling 429\");\n\t                        return [4 /*yield*/, staller(stall)];\n\t                    case 6:\n\t                        //console.log(\"Stalling 429\");\n\t                        _a.sent();\n\t                        return [3 /*break*/, 18];\n\t                    case 7: return [3 /*break*/, 9];\n\t                    case 8:\n\t                        error_1 = _a.sent();\n\t                        response = error_1.response;\n\t                        if (response == null) {\n\t                            runningTimeout.cancel();\n\t                            logger.throwError(\"missing response\", lib.Logger.errors.SERVER_ERROR, {\n\t                                requestBody: bodyify(options.body, flatHeaders[\"content-type\"]),\n\t                                requestMethod: options.method,\n\t                                serverError: error_1,\n\t                                url: url\n\t                            });\n\t                        }\n\t                        return [3 /*break*/, 9];\n\t                    case 9:\n\t                        body_1 = response.body;\n\t                        if (allow304 && response.statusCode === 304) {\n\t                            body_1 = null;\n\t                        }\n\t                        else if (response.statusCode < 200 || response.statusCode >= 300) {\n\t                            runningTimeout.cancel();\n\t                            logger.throwError(\"bad response\", lib.Logger.errors.SERVER_ERROR, {\n\t                                status: response.statusCode,\n\t                                headers: response.headers,\n\t                                body: bodyify(body_1, ((response.headers) ? response.headers[\"content-type\"] : null)),\n\t                                requestBody: bodyify(options.body, flatHeaders[\"content-type\"]),\n\t                                requestMethod: options.method,\n\t                                url: url\n\t                            });\n\t                        }\n\t                        if (!processFunc) return [3 /*break*/, 17];\n\t                        _a.label = 10;\n\t                    case 10:\n\t                        _a.trys.push([10, 12, , 17]);\n\t                        return [4 /*yield*/, processFunc(body_1, response)];\n\t                    case 11:\n\t                        result = _a.sent();\n\t                        runningTimeout.cancel();\n\t                        return [2 /*return*/, result];\n\t                    case 12:\n\t                        error_2 = _a.sent();\n\t                        if (!(error_2.throttleRetry && attempt < attemptLimit)) return [3 /*break*/, 16];\n\t                        tryAgain = true;\n\t                        if (!throttleCallback) return [3 /*break*/, 14];\n\t                        return [4 /*yield*/, throttleCallback(attempt, url)];\n\t                    case 13:\n\t                        tryAgain = _a.sent();\n\t                        _a.label = 14;\n\t                    case 14:\n\t                        if (!tryAgain) return [3 /*break*/, 16];\n\t                        timeout_1 = throttleSlotInterval * parseInt(String(Math.random() * Math.pow(2, attempt)));\n\t                        //console.log(\"Stalling callback\");\n\t                        return [4 /*yield*/, staller(timeout_1)];\n\t                    case 15:\n\t                        //console.log(\"Stalling callback\");\n\t                        _a.sent();\n\t                        return [3 /*break*/, 18];\n\t                    case 16:\n\t                        runningTimeout.cancel();\n\t                        logger.throwError(\"processing response error\", lib.Logger.errors.SERVER_ERROR, {\n\t                            body: bodyify(body_1, ((response.headers) ? response.headers[\"content-type\"] : null)),\n\t                            error: error_2,\n\t                            requestBody: bodyify(options.body, flatHeaders[\"content-type\"]),\n\t                            requestMethod: options.method,\n\t                            url: url\n\t                        });\n\t                        return [3 /*break*/, 17];\n\t                    case 17:\n\t                        runningTimeout.cancel();\n\t                        // If we had a processFunc, it either returned a T or threw above.\n\t                        // The \"body\" is now a Uint8Array.\n\t                        return [2 /*return*/, body_1];\n\t                    case 18:\n\t                        attempt++;\n\t                        return [3 /*break*/, 1];\n\t                    case 19: return [2 /*return*/, logger.throwError(\"failed response\", lib.Logger.errors.SERVER_ERROR, {\n\t                            requestBody: bodyify(options.body, flatHeaders[\"content-type\"]),\n\t                            requestMethod: options.method,\n\t                            url: url\n\t                        })];\n\t                }\n\t            });\n\t        });\n\t    })();\n\t    return Promise.race([runningTimeout.promise, runningFetch]);\n\t}\n\texports._fetchData = _fetchData;\n\tfunction fetchJson(connection, json, processFunc) {\n\t    var processJsonFunc = function (value, response) {\n\t        var result = null;\n\t        if (value != null) {\n\t            try {\n\t                result = JSON.parse((0, lib$8.toUtf8String)(value));\n\t            }\n\t            catch (error) {\n\t                logger.throwError(\"invalid JSON\", lib.Logger.errors.SERVER_ERROR, {\n\t                    body: value,\n\t                    error: error\n\t                });\n\t            }\n\t        }\n\t        if (processFunc) {\n\t            result = processFunc(result, response);\n\t        }\n\t        return result;\n\t    };\n\t    // If we have json to send, we must\n\t    // - add content-type of application/json (unless already overridden)\n\t    // - convert the json to bytes\n\t    var body = null;\n\t    if (json != null) {\n\t        body = (0, lib$8.toUtf8Bytes)(json);\n\t        // Create a connection with the content-type set for JSON\n\t        var updated = (typeof (connection) === \"string\") ? ({ url: connection }) : (0, lib$3.shallowCopy)(connection);\n\t        if (updated.headers) {\n\t            var hasContentType = (Object.keys(updated.headers).filter(function (k) { return (k.toLowerCase() === \"content-type\"); }).length) !== 0;\n\t            if (!hasContentType) {\n\t                updated.headers = (0, lib$3.shallowCopy)(updated.headers);\n\t                updated.headers[\"content-type\"] = \"application/json\";\n\t            }\n\t        }\n\t        else {\n\t            updated.headers = { \"content-type\": \"application/json\" };\n\t        }\n\t        connection = updated;\n\t    }\n\t    return _fetchData(connection, body, processJsonFunc);\n\t}\n\texports.fetchJson = fetchJson;\n\tfunction poll(func, options) {\n\t    if (!options) {\n\t        options = {};\n\t    }\n\t    options = (0, lib$3.shallowCopy)(options);\n\t    if (options.floor == null) {\n\t        options.floor = 0;\n\t    }\n\t    if (options.ceiling == null) {\n\t        options.ceiling = 10000;\n\t    }\n\t    if (options.interval == null) {\n\t        options.interval = 250;\n\t    }\n\t    return new Promise(function (resolve, reject) {\n\t        var timer = null;\n\t        var done = false;\n\t        // Returns true if cancel was successful. Unsuccessful cancel means we're already done.\n\t        var cancel = function () {\n\t            if (done) {\n\t                return false;\n\t            }\n\t            done = true;\n\t            if (timer) {\n\t                clearTimeout(timer);\n\t            }\n\t            return true;\n\t        };\n\t        if (options.timeout) {\n\t            timer = setTimeout(function () {\n\t                if (cancel()) {\n\t                    reject(new Error(\"timeout\"));\n\t                }\n\t            }, options.timeout);\n\t        }\n\t        var retryLimit = options.retryLimit;\n\t        var attempt = 0;\n\t        function check() {\n\t            return func().then(function (result) {\n\t                // If we have a result, or are allowed null then we're done\n\t                if (result !== undefined) {\n\t                    if (cancel()) {\n\t                        resolve(result);\n\t                    }\n\t                }\n\t                else if (options.oncePoll) {\n\t                    options.oncePoll.once(\"poll\", check);\n\t                }\n\t                else if (options.onceBlock) {\n\t                    options.onceBlock.once(\"block\", check);\n\t                    // Otherwise, exponential back-off (up to 10s) our next request\n\t                }\n\t                else if (!done) {\n\t                    attempt++;\n\t                    if (attempt > retryLimit) {\n\t                        if (cancel()) {\n\t                            reject(new Error(\"retry limit reached\"));\n\t                        }\n\t                        return;\n\t                    }\n\t                    var timeout = options.interval * parseInt(String(Math.random() * Math.pow(2, attempt)));\n\t                    if (timeout < options.floor) {\n\t                        timeout = options.floor;\n\t                    }\n\t                    if (timeout > options.ceiling) {\n\t                        timeout = options.ceiling;\n\t                    }\n\t                    setTimeout(check, timeout);\n\t                }\n\t                return null;\n\t            }, function (error) {\n\t                if (cancel()) {\n\t                    reject(error);\n\t                }\n\t            });\n\t        }\n\t        check();\n\t    });\n\t}\n\texports.poll = poll;\n\n\t});\n\n\tvar index$q = /*@__PURE__*/getDefaultExportFromCjs(lib$q);\n\n\t'use strict';\n\tvar ALPHABET = 'qpzry9x8gf2tvdw0s3jn54khce6mua7l';\n\n\t// pre-compute lookup table\n\tvar ALPHABET_MAP = {};\n\tfor (var z = 0; z < ALPHABET.length; z++) {\n\t  var x = ALPHABET.charAt(z);\n\n\t  if (ALPHABET_MAP[x] !== undefined) throw new TypeError(x + ' is ambiguous')\n\t  ALPHABET_MAP[x] = z;\n\t}\n\n\tfunction polymodStep (pre) {\n\t  var b = pre >> 25;\n\t  return ((pre & 0x1FFFFFF) << 5) ^\n\t    (-((b >> 0) & 1) & 0x3b6a57b2) ^\n\t    (-((b >> 1) & 1) & 0x26508e6d) ^\n\t    (-((b >> 2) & 1) & 0x1ea119fa) ^\n\t    (-((b >> 3) & 1) & 0x3d4233dd) ^\n\t    (-((b >> 4) & 1) & 0x2a1462b3)\n\t}\n\n\tfunction prefixChk (prefix) {\n\t  var chk = 1;\n\t  for (var i = 0; i < prefix.length; ++i) {\n\t    var c = prefix.charCodeAt(i);\n\t    if (c < 33 || c > 126) return 'Invalid prefix (' + prefix + ')'\n\n\t    chk = polymodStep(chk) ^ (c >> 5);\n\t  }\n\t  chk = polymodStep(chk);\n\n\t  for (i = 0; i < prefix.length; ++i) {\n\t    var v = prefix.charCodeAt(i);\n\t    chk = polymodStep(chk) ^ (v & 0x1f);\n\t  }\n\t  return chk\n\t}\n\n\tfunction encode (prefix, words, LIMIT) {\n\t  LIMIT = LIMIT || 90;\n\t  if ((prefix.length + 7 + words.length) > LIMIT) throw new TypeError('Exceeds length limit')\n\n\t  prefix = prefix.toLowerCase();\n\n\t  // determine chk mod\n\t  var chk = prefixChk(prefix);\n\t  if (typeof chk === 'string') throw new Error(chk)\n\n\t  var result = prefix + '1';\n\t  for (var i = 0; i < words.length; ++i) {\n\t    var x = words[i];\n\t    if ((x >> 5) !== 0) throw new Error('Non 5-bit word')\n\n\t    chk = polymodStep(chk) ^ x;\n\t    result += ALPHABET.charAt(x);\n\t  }\n\n\t  for (i = 0; i < 6; ++i) {\n\t    chk = polymodStep(chk);\n\t  }\n\t  chk ^= 1;\n\n\t  for (i = 0; i < 6; ++i) {\n\t    var v = (chk >> ((5 - i) * 5)) & 0x1f;\n\t    result += ALPHABET.charAt(v);\n\t  }\n\n\t  return result\n\t}\n\n\tfunction __decode (str, LIMIT) {\n\t  LIMIT = LIMIT || 90;\n\t  if (str.length < 8) return str + ' too short'\n\t  if (str.length > LIMIT) return 'Exceeds length limit'\n\n\t  // don't allow mixed case\n\t  var lowered = str.toLowerCase();\n\t  var uppered = str.toUpperCase();\n\t  if (str !== lowered && str !== uppered) return 'Mixed-case string ' + str\n\t  str = lowered;\n\n\t  var split = str.lastIndexOf('1');\n\t  if (split === -1) return 'No separator character for ' + str\n\t  if (split === 0) return 'Missing prefix for ' + str\n\n\t  var prefix = str.slice(0, split);\n\t  var wordChars = str.slice(split + 1);\n\t  if (wordChars.length < 6) return 'Data too short'\n\n\t  var chk = prefixChk(prefix);\n\t  if (typeof chk === 'string') return chk\n\n\t  var words = [];\n\t  for (var i = 0; i < wordChars.length; ++i) {\n\t    var c = wordChars.charAt(i);\n\t    var v = ALPHABET_MAP[c];\n\t    if (v === undefined) return 'Unknown character ' + c\n\t    chk = polymodStep(chk) ^ v;\n\n\t    // not in the checksum?\n\t    if (i + 6 >= wordChars.length) continue\n\t    words.push(v);\n\t  }\n\n\t  if (chk !== 1) return 'Invalid checksum for ' + str\n\t  return { prefix: prefix, words: words }\n\t}\n\n\tfunction decodeUnsafe () {\n\t  var res = __decode.apply(null, arguments);\n\t  if (typeof res === 'object') return res\n\t}\n\n\tfunction decode (str) {\n\t  var res = __decode.apply(null, arguments);\n\t  if (typeof res === 'object') return res\n\n\t  throw new Error(res)\n\t}\n\n\tfunction convert (data, inBits, outBits, pad) {\n\t  var value = 0;\n\t  var bits = 0;\n\t  var maxV = (1 << outBits) - 1;\n\n\t  var result = [];\n\t  for (var i = 0; i < data.length; ++i) {\n\t    value = (value << inBits) | data[i];\n\t    bits += inBits;\n\n\t    while (bits >= outBits) {\n\t      bits -= outBits;\n\t      result.push((value >> bits) & maxV);\n\t    }\n\t  }\n\n\t  if (pad) {\n\t    if (bits > 0) {\n\t      result.push((value << (outBits - bits)) & maxV);\n\t    }\n\t  } else {\n\t    if (bits >= inBits) return 'Excess padding'\n\t    if ((value << (outBits - bits)) & maxV) return 'Non-zero padding'\n\t  }\n\n\t  return result\n\t}\n\n\tfunction toWordsUnsafe (bytes) {\n\t  var res = convert(bytes, 8, 5, true);\n\t  if (Array.isArray(res)) return res\n\t}\n\n\tfunction toWords (bytes) {\n\t  var res = convert(bytes, 8, 5, true);\n\t  if (Array.isArray(res)) return res\n\n\t  throw new Error(res)\n\t}\n\n\tfunction fromWordsUnsafe (words) {\n\t  var res = convert(words, 5, 8, false);\n\t  if (Array.isArray(res)) return res\n\t}\n\n\tfunction fromWords (words) {\n\t  var res = convert(words, 5, 8, false);\n\t  if (Array.isArray(res)) return res\n\n\t  throw new Error(res)\n\t}\n\n\tvar bech32 = {\n\t  decodeUnsafe: decodeUnsafe,\n\t  decode: decode,\n\t  encode: encode,\n\t  toWordsUnsafe: toWordsUnsafe,\n\t  toWords: toWords,\n\t  fromWordsUnsafe: fromWordsUnsafe,\n\t  fromWords: fromWords\n\t};\n\n\tvar _version$I = createCommonjsModule(function (module, exports) {\n\t\"use strict\";\n\tObject.defineProperty(exports, \"__esModule\", { value: true });\n\texports.version = void 0;\n\texports.version = \"providers/5.5.0\";\n\n\t});\n\n\tvar _version$J = /*@__PURE__*/getDefaultExportFromCjs(_version$I);\n\n\tvar formatter = createCommonjsModule(function (module, exports) {\n\t\"use strict\";\n\tObject.defineProperty(exports, \"__esModule\", { value: true });\n\texports.showThrottleMessage = exports.isCommunityResource = exports.isCommunityResourcable = exports.Formatter = void 0;\n\n\n\n\n\n\n\n\n\tvar logger = new lib.Logger(_version$I.version);\n\tvar Formatter = /** @class */ (function () {\n\t    function Formatter() {\n\t        var _newTarget = this.constructor;\n\t        logger.checkNew(_newTarget, Formatter);\n\t        this.formats = this.getDefaultFormats();\n\t    }\n\t    Formatter.prototype.getDefaultFormats = function () {\n\t        var _this = this;\n\t        var formats = ({});\n\t        var address = this.address.bind(this);\n\t        var bigNumber = this.bigNumber.bind(this);\n\t        var blockTag = this.blockTag.bind(this);\n\t        var data = this.data.bind(this);\n\t        var hash = this.hash.bind(this);\n\t        var hex = this.hex.bind(this);\n\t        var number = this.number.bind(this);\n\t        var type = this.type.bind(this);\n\t        var strictData = function (v) { return _this.data(v, true); };\n\t        formats.transaction = {\n\t            hash: hash,\n\t            type: type,\n\t            accessList: Formatter.allowNull(this.accessList.bind(this), null),\n\t            blockHash: Formatter.allowNull(hash, null),\n\t            blockNumber: Formatter.allowNull(number, null),\n\t            transactionIndex: Formatter.allowNull(number, null),\n\t            confirmations: Formatter.allowNull(number, null),\n\t            from: address,\n\t            // either (gasPrice) or (maxPriorityFeePerGas + maxFeePerGas)\n\t            // must be set\n\t            gasPrice: Formatter.allowNull(bigNumber),\n\t            maxPriorityFeePerGas: Formatter.allowNull(bigNumber),\n\t            maxFeePerGas: Formatter.allowNull(bigNumber),\n\t            gasLimit: bigNumber,\n\t            to: Formatter.allowNull(address, null),\n\t            value: bigNumber,\n\t            nonce: number,\n\t            data: data,\n\t            r: Formatter.allowNull(this.uint256),\n\t            s: Formatter.allowNull(this.uint256),\n\t            v: Formatter.allowNull(number),\n\t            creates: Formatter.allowNull(address, null),\n\t            raw: Formatter.allowNull(data),\n\t        };\n\t        formats.transactionRequest = {\n\t            from: Formatter.allowNull(address),\n\t            nonce: Formatter.allowNull(number),\n\t            gasLimit: Formatter.allowNull(bigNumber),\n\t            gasPrice: Formatter.allowNull(bigNumber),\n\t            maxPriorityFeePerGas: Formatter.allowNull(bigNumber),\n\t            maxFeePerGas: Formatter.allowNull(bigNumber),\n\t            to: Formatter.allowNull(address),\n\t            value: Formatter.allowNull(bigNumber),\n\t            data: Formatter.allowNull(strictData),\n\t            type: Formatter.allowNull(number),\n\t            accessList: Formatter.allowNull(this.accessList.bind(this), null),\n\t        };\n\t        formats.receiptLog = {\n\t            transactionIndex: number,\n\t            blockNumber: number,\n\t            transactionHash: hash,\n\t            address: address,\n\t            topics: Formatter.arrayOf(hash),\n\t            data: data,\n\t            logIndex: number,\n\t            blockHash: hash,\n\t        };\n\t        formats.receipt = {\n\t            to: Formatter.allowNull(this.address, null),\n\t            from: Formatter.allowNull(this.address, null),\n\t            contractAddress: Formatter.allowNull(address, null),\n\t            transactionIndex: number,\n\t            // should be allowNull(hash), but broken-EIP-658 support is handled in receipt\n\t            root: Formatter.allowNull(hex),\n\t            gasUsed: bigNumber,\n\t            logsBloom: Formatter.allowNull(data),\n\t            blockHash: hash,\n\t            transactionHash: hash,\n\t            logs: Formatter.arrayOf(this.receiptLog.bind(this)),\n\t            blockNumber: number,\n\t            confirmations: Formatter.allowNull(number, null),\n\t            cumulativeGasUsed: bigNumber,\n\t            effectiveGasPrice: Formatter.allowNull(bigNumber),\n\t            status: Formatter.allowNull(number),\n\t            type: type\n\t        };\n\t        formats.block = {\n\t            hash: hash,\n\t            parentHash: hash,\n\t            number: number,\n\t            timestamp: number,\n\t            nonce: Formatter.allowNull(hex),\n\t            difficulty: this.difficulty.bind(this),\n\t            gasLimit: bigNumber,\n\t            gasUsed: bigNumber,\n\t            miner: address,\n\t            extraData: data,\n\t            transactions: Formatter.allowNull(Formatter.arrayOf(hash)),\n\t            baseFeePerGas: Formatter.allowNull(bigNumber)\n\t        };\n\t        formats.blockWithTransactions = (0, lib$3.shallowCopy)(formats.block);\n\t        formats.blockWithTransactions.transactions = Formatter.allowNull(Formatter.arrayOf(this.transactionResponse.bind(this)));\n\t        formats.filter = {\n\t            fromBlock: Formatter.allowNull(blockTag, undefined),\n\t            toBlock: Formatter.allowNull(blockTag, undefined),\n\t            blockHash: Formatter.allowNull(hash, undefined),\n\t            address: Formatter.allowNull(address, undefined),\n\t            topics: Formatter.allowNull(this.topics.bind(this), undefined),\n\t        };\n\t        formats.filterLog = {\n\t            blockNumber: Formatter.allowNull(number),\n\t            blockHash: Formatter.allowNull(hash),\n\t            transactionIndex: number,\n\t            removed: Formatter.allowNull(this.boolean.bind(this)),\n\t            address: address,\n\t            data: Formatter.allowFalsish(data, \"0x\"),\n\t            topics: Formatter.arrayOf(hash),\n\t            transactionHash: hash,\n\t            logIndex: number,\n\t        };\n\t        return formats;\n\t    };\n\t    Formatter.prototype.accessList = function (accessList) {\n\t        return (0, lib$e.accessListify)(accessList || []);\n\t    };\n\t    // Requires a BigNumberish that is within the IEEE754 safe integer range; returns a number\n\t    // Strict! Used on input.\n\t    Formatter.prototype.number = function (number) {\n\t        if (number === \"0x\") {\n\t            return 0;\n\t        }\n\t        return lib$2.BigNumber.from(number).toNumber();\n\t    };\n\t    Formatter.prototype.type = function (number) {\n\t        if (number === \"0x\" || number == null) {\n\t            return 0;\n\t        }\n\t        return lib$2.BigNumber.from(number).toNumber();\n\t    };\n\t    // Strict! Used on input.\n\t    Formatter.prototype.bigNumber = function (value) {\n\t        return lib$2.BigNumber.from(value);\n\t    };\n\t    // Requires a boolean, \"true\" or  \"false\"; returns a boolean\n\t    Formatter.prototype.boolean = function (value) {\n\t        if (typeof (value) === \"boolean\") {\n\t            return value;\n\t        }\n\t        if (typeof (value) === \"string\") {\n\t            value = value.toLowerCase();\n\t            if (value === \"true\") {\n\t                return true;\n\t            }\n\t            if (value === \"false\") {\n\t                return false;\n\t            }\n\t        }\n\t        throw new Error(\"invalid boolean - \" + value);\n\t    };\n\t    Formatter.prototype.hex = function (value, strict) {\n\t        if (typeof (value) === \"string\") {\n\t            if (!strict && value.substring(0, 2) !== \"0x\") {\n\t                value = \"0x\" + value;\n\t            }\n\t            if ((0, lib$1.isHexString)(value)) {\n\t                return value.toLowerCase();\n\t            }\n\t        }\n\t        return logger.throwArgumentError(\"invalid hash\", \"value\", value);\n\t    };\n\t    Formatter.prototype.data = function (value, strict) {\n\t        var result = this.hex(value, strict);\n\t        if ((result.length % 2) !== 0) {\n\t            throw new Error(\"invalid data; odd-length - \" + value);\n\t        }\n\t        return result;\n\t    };\n\t    // Requires an address\n\t    // Strict! Used on input.\n\t    Formatter.prototype.address = function (value) {\n\t        return (0, lib$6.getAddress)(value);\n\t    };\n\t    Formatter.prototype.callAddress = function (value) {\n\t        if (!(0, lib$1.isHexString)(value, 32)) {\n\t            return null;\n\t        }\n\t        var address = (0, lib$6.getAddress)((0, lib$1.hexDataSlice)(value, 12));\n\t        return (address === lib$7.AddressZero) ? null : address;\n\t    };\n\t    Formatter.prototype.contractAddress = function (value) {\n\t        return (0, lib$6.getContractAddress)(value);\n\t    };\n\t    // Strict! Used on input.\n\t    Formatter.prototype.blockTag = function (blockTag) {\n\t        if (blockTag == null) {\n\t            return \"latest\";\n\t        }\n\t        if (blockTag === \"earliest\") {\n\t            return \"0x0\";\n\t        }\n\t        if (blockTag === \"latest\" || blockTag === \"pending\") {\n\t            return blockTag;\n\t        }\n\t        if (typeof (blockTag) === \"number\" || (0, lib$1.isHexString)(blockTag)) {\n\t            return (0, lib$1.hexValue)(blockTag);\n\t        }\n\t        throw new Error(\"invalid blockTag\");\n\t    };\n\t    // Requires a hash, optionally requires 0x prefix; returns prefixed lowercase hash.\n\t    Formatter.prototype.hash = function (value, strict) {\n\t        var result = this.hex(value, strict);\n\t        if ((0, lib$1.hexDataLength)(result) !== 32) {\n\t            return logger.throwArgumentError(\"invalid hash\", \"value\", value);\n\t        }\n\t        return result;\n\t    };\n\t    // Returns the difficulty as a number, or if too large (i.e. PoA network) null\n\t    Formatter.prototype.difficulty = function (value) {\n\t        if (value == null) {\n\t            return null;\n\t        }\n\t        var v = lib$2.BigNumber.from(value);\n\t        try {\n\t            return v.toNumber();\n\t        }\n\t        catch (error) { }\n\t        return null;\n\t    };\n\t    Formatter.prototype.uint256 = function (value) {\n\t        if (!(0, lib$1.isHexString)(value)) {\n\t            throw new Error(\"invalid uint256\");\n\t        }\n\t        return (0, lib$1.hexZeroPad)(value, 32);\n\t    };\n\t    Formatter.prototype._block = function (value, format) {\n\t        if (value.author != null && value.miner == null) {\n\t            value.miner = value.author;\n\t        }\n\t        // The difficulty may need to come from _difficulty in recursed blocks\n\t        var difficulty = (value._difficulty != null) ? value._difficulty : value.difficulty;\n\t        var result = Formatter.check(format, value);\n\t        result._difficulty = ((difficulty == null) ? null : lib$2.BigNumber.from(difficulty));\n\t        return result;\n\t    };\n\t    Formatter.prototype.block = function (value) {\n\t        return this._block(value, this.formats.block);\n\t    };\n\t    Formatter.prototype.blockWithTransactions = function (value) {\n\t        return this._block(value, this.formats.blockWithTransactions);\n\t    };\n\t    // Strict! Used on input.\n\t    Formatter.prototype.transactionRequest = function (value) {\n\t        return Formatter.check(this.formats.transactionRequest, value);\n\t    };\n\t    Formatter.prototype.transactionResponse = function (transaction) {\n\t        // Rename gas to gasLimit\n\t        if (transaction.gas != null && transaction.gasLimit == null) {\n\t            transaction.gasLimit = transaction.gas;\n\t        }\n\t        // Some clients (TestRPC) do strange things like return 0x0 for the\n\t        // 0 address; correct this to be a real address\n\t        if (transaction.to && lib$2.BigNumber.from(transaction.to).isZero()) {\n\t            transaction.to = \"0x0000000000000000000000000000000000000000\";\n\t        }\n\t        // Rename input to data\n\t        if (transaction.input != null && transaction.data == null) {\n\t            transaction.data = transaction.input;\n\t        }\n\t        // If to and creates are empty, populate the creates from the transaction\n\t        if (transaction.to == null && transaction.creates == null) {\n\t            transaction.creates = this.contractAddress(transaction);\n\t        }\n\t        if ((transaction.type === 1 || transaction.type === 2) && transaction.accessList == null) {\n\t            transaction.accessList = [];\n\t        }\n\t        var result = Formatter.check(this.formats.transaction, transaction);\n\t        if (transaction.chainId != null) {\n\t            var chainId = transaction.chainId;\n\t            if ((0, lib$1.isHexString)(chainId)) {\n\t                chainId = lib$2.BigNumber.from(chainId).toNumber();\n\t            }\n\t            result.chainId = chainId;\n\t        }\n\t        else {\n\t            var chainId = transaction.networkId;\n\t            // geth-etc returns chainId\n\t            if (chainId == null && result.v == null) {\n\t                chainId = transaction.chainId;\n\t            }\n\t            if ((0, lib$1.isHexString)(chainId)) {\n\t                chainId = lib$2.BigNumber.from(chainId).toNumber();\n\t            }\n\t            if (typeof (chainId) !== \"number\" && result.v != null) {\n\t                chainId = (result.v - 35) / 2;\n\t                if (chainId < 0) {\n\t                    chainId = 0;\n\t                }\n\t                chainId = parseInt(chainId);\n\t            }\n\t            if (typeof (chainId) !== \"number\") {\n\t                chainId = 0;\n\t            }\n\t            result.chainId = chainId;\n\t        }\n\t        // 0x0000... should actually be null\n\t        if (result.blockHash && result.blockHash.replace(/0/g, \"\") === \"x\") {\n\t            result.blockHash = null;\n\t        }\n\t        return result;\n\t    };\n\t    Formatter.prototype.transaction = function (value) {\n\t        return (0, lib$e.parse)(value);\n\t    };\n\t    Formatter.prototype.receiptLog = function (value) {\n\t        return Formatter.check(this.formats.receiptLog, value);\n\t    };\n\t    Formatter.prototype.receipt = function (value) {\n\t        var result = Formatter.check(this.formats.receipt, value);\n\t        // RSK incorrectly implemented EIP-658, so we munge things a bit here for it\n\t        if (result.root != null) {\n\t            if (result.root.length <= 4) {\n\t                // Could be 0x00, 0x0, 0x01 or 0x1\n\t                var value_1 = lib$2.BigNumber.from(result.root).toNumber();\n\t                if (value_1 === 0 || value_1 === 1) {\n\t                    // Make sure if both are specified, they match\n\t                    if (result.status != null && (result.status !== value_1)) {\n\t                        logger.throwArgumentError(\"alt-root-status/status mismatch\", \"value\", { root: result.root, status: result.status });\n\t                    }\n\t                    result.status = value_1;\n\t                    delete result.root;\n\t                }\n\t                else {\n\t                    logger.throwArgumentError(\"invalid alt-root-status\", \"value.root\", result.root);\n\t                }\n\t            }\n\t            else if (result.root.length !== 66) {\n\t                // Must be a valid bytes32\n\t                logger.throwArgumentError(\"invalid root hash\", \"value.root\", result.root);\n\t            }\n\t        }\n\t        if (result.status != null) {\n\t            result.byzantium = true;\n\t        }\n\t        return result;\n\t    };\n\t    Formatter.prototype.topics = function (value) {\n\t        var _this = this;\n\t        if (Array.isArray(value)) {\n\t            return value.map(function (v) { return _this.topics(v); });\n\t        }\n\t        else if (value != null) {\n\t            return this.hash(value, true);\n\t        }\n\t        return null;\n\t    };\n\t    Formatter.prototype.filter = function (value) {\n\t        return Formatter.check(this.formats.filter, value);\n\t    };\n\t    Formatter.prototype.filterLog = function (value) {\n\t        return Formatter.check(this.formats.filterLog, value);\n\t    };\n\t    Formatter.check = function (format, object) {\n\t        var result = {};\n\t        for (var key in format) {\n\t            try {\n\t                var value = format[key](object[key]);\n\t                if (value !== undefined) {\n\t                    result[key] = value;\n\t                }\n\t            }\n\t            catch (error) {\n\t                error.checkKey = key;\n\t                error.checkValue = object[key];\n\t                throw error;\n\t            }\n\t        }\n\t        return result;\n\t    };\n\t    // if value is null-ish, nullValue is returned\n\t    Formatter.allowNull = function (format, nullValue) {\n\t        return (function (value) {\n\t            if (value == null) {\n\t                return nullValue;\n\t            }\n\t            return format(value);\n\t        });\n\t    };\n\t    // If value is false-ish, replaceValue is returned\n\t    Formatter.allowFalsish = function (format, replaceValue) {\n\t        return (function (value) {\n\t            if (!value) {\n\t                return replaceValue;\n\t            }\n\t            return format(value);\n\t        });\n\t    };\n\t    // Requires an Array satisfying check\n\t    Formatter.arrayOf = function (format) {\n\t        return (function (array) {\n\t            if (!Array.isArray(array)) {\n\t                throw new Error(\"not an array\");\n\t            }\n\t            var result = [];\n\t            array.forEach(function (value) {\n\t                result.push(format(value));\n\t            });\n\t            return result;\n\t        });\n\t    };\n\t    return Formatter;\n\t}());\n\texports.Formatter = Formatter;\n\tfunction isCommunityResourcable(value) {\n\t    return (value && typeof (value.isCommunityResource) === \"function\");\n\t}\n\texports.isCommunityResourcable = isCommunityResourcable;\n\tfunction isCommunityResource(value) {\n\t    return (isCommunityResourcable(value) && value.isCommunityResource());\n\t}\n\texports.isCommunityResource = isCommunityResource;\n\t// Show the throttle message only once\n\tvar throttleMessage = false;\n\tfunction showThrottleMessage() {\n\t    if (throttleMessage) {\n\t        return;\n\t    }\n\t    throttleMessage = true;\n\t    console.log(\"========= NOTICE =========\");\n\t    console.log(\"Request-Rate Exceeded  (this message will not be repeated)\");\n\t    console.log(\"\");\n\t    console.log(\"The default API keys for each service are provided as a highly-throttled,\");\n\t    console.log(\"community resource for low-traffic projects and early prototyping.\");\n\t    console.log(\"\");\n\t    console.log(\"While your application will continue to function, we highly recommended\");\n\t    console.log(\"signing up for your own API keys to improve performance, increase your\");\n\t    console.log(\"request rate/limit and enable other perks, such as metrics and advanced APIs.\");\n\t    console.log(\"\");\n\t    console.log(\"For more details: https:/\\/docs.ethers.io/api-keys/\");\n\t    console.log(\"==========================\");\n\t}\n\texports.showThrottleMessage = showThrottleMessage;\n\n\t});\n\n\tvar formatter$1 = /*@__PURE__*/getDefaultExportFromCjs(formatter);\n\n\tvar baseProvider = createCommonjsModule(function (module, exports) {\n\t\"use strict\";\n\tvar __extends = (commonjsGlobal && commonjsGlobal.__extends) || (function () {\n\t    var extendStatics = function (d, b) {\n\t        extendStatics = Object.setPrototypeOf ||\n\t            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n\t            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n\t        return extendStatics(d, b);\n\t    };\n\t    return function (d, b) {\n\t        if (typeof b !== \"function\" && b !== null)\n\t            throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n\t        extendStatics(d, b);\n\t        function __() { this.constructor = d; }\n\t        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n\t    };\n\t})();\n\tvar __awaiter = (commonjsGlobal && commonjsGlobal.__awaiter) || function (thisArg, _arguments, P, generator) {\n\t    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n\t    return new (P || (P = Promise))(function (resolve, reject) {\n\t        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n\t        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n\t        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n\t        step((generator = generator.apply(thisArg, _arguments || [])).next());\n\t    });\n\t};\n\tvar __generator = (commonjsGlobal && commonjsGlobal.__generator) || function (thisArg, body) {\n\t    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\n\t    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\n\t    function verb(n) { return function (v) { return step([n, v]); }; }\n\t    function step(op) {\n\t        if (f) throw new TypeError(\"Generator is already executing.\");\n\t        while (_) try {\n\t            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n\t            if (y = 0, t) op = [op[0] & 2, t.value];\n\t            switch (op[0]) {\n\t                case 0: case 1: t = op; break;\n\t                case 4: _.label++; return { value: op[1], done: false };\n\t                case 5: _.label++; y = op[1]; op = [0]; continue;\n\t                case 7: op = _.ops.pop(); _.trys.pop(); continue;\n\t                default:\n\t                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\n\t                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\n\t                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\n\t                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\n\t                    if (t[2]) _.ops.pop();\n\t                    _.trys.pop(); continue;\n\t            }\n\t            op = body.call(thisArg, _);\n\t        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\n\t        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\n\t    }\n\t};\n\tvar __importDefault = (commonjsGlobal && commonjsGlobal.__importDefault) || function (mod) {\n\t    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n\t};\n\tObject.defineProperty(exports, \"__esModule\", { value: true });\n\texports.BaseProvider = exports.Resolver = exports.Event = void 0;\n\n\n\n\n\n\n\n\n\n\n\n\tvar bech32_1 = __importDefault(bech32);\n\n\n\tvar logger = new lib.Logger(_version$I.version);\n\n\t//////////////////////////////\n\t// Event Serializeing\n\tfunction checkTopic(topic) {\n\t    if (topic == null) {\n\t        return \"null\";\n\t    }\n\t    if ((0, lib$1.hexDataLength)(topic) !== 32) {\n\t        logger.throwArgumentError(\"invalid topic\", \"topic\", topic);\n\t    }\n\t    return topic.toLowerCase();\n\t}\n\tfunction serializeTopics(topics) {\n\t    // Remove trailing null AND-topics; they are redundant\n\t    topics = topics.slice();\n\t    while (topics.length > 0 && topics[topics.length - 1] == null) {\n\t        topics.pop();\n\t    }\n\t    return topics.map(function (topic) {\n\t        if (Array.isArray(topic)) {\n\t            // Only track unique OR-topics\n\t            var unique_1 = {};\n\t            topic.forEach(function (topic) {\n\t                unique_1[checkTopic(topic)] = true;\n\t            });\n\t            // The order of OR-topics does not matter\n\t            var sorted = Object.keys(unique_1);\n\t            sorted.sort();\n\t            return sorted.join(\"|\");\n\t        }\n\t        else {\n\t            return checkTopic(topic);\n\t        }\n\t    }).join(\"&\");\n\t}\n\tfunction deserializeTopics(data) {\n\t    if (data === \"\") {\n\t        return [];\n\t    }\n\t    return data.split(/&/g).map(function (topic) {\n\t        if (topic === \"\") {\n\t            return [];\n\t        }\n\t        var comps = topic.split(\"|\").map(function (topic) {\n\t            return ((topic === \"null\") ? null : topic);\n\t        });\n\t        return ((comps.length === 1) ? comps[0] : comps);\n\t    });\n\t}\n\tfunction getEventTag(eventName) {\n\t    if (typeof (eventName) === \"string\") {\n\t        eventName = eventName.toLowerCase();\n\t        if ((0, lib$1.hexDataLength)(eventName) === 32) {\n\t            return \"tx:\" + eventName;\n\t        }\n\t        if (eventName.indexOf(\":\") === -1) {\n\t            return eventName;\n\t        }\n\t    }\n\t    else if (Array.isArray(eventName)) {\n\t        return \"filter:*:\" + serializeTopics(eventName);\n\t    }\n\t    else if (lib$b.ForkEvent.isForkEvent(eventName)) {\n\t        logger.warn(\"not implemented\");\n\t        throw new Error(\"not implemented\");\n\t    }\n\t    else if (eventName && typeof (eventName) === \"object\") {\n\t        return \"filter:\" + (eventName.address || \"*\") + \":\" + serializeTopics(eventName.topics || []);\n\t    }\n\t    throw new Error(\"invalid event - \" + eventName);\n\t}\n\t//////////////////////////////\n\t// Helper Object\n\tfunction getTime() {\n\t    return (new Date()).getTime();\n\t}\n\tfunction stall(duration) {\n\t    return new Promise(function (resolve) {\n\t        setTimeout(resolve, duration);\n\t    });\n\t}\n\t//////////////////////////////\n\t// Provider Object\n\t/**\n\t *  EventType\n\t *   - \"block\"\n\t *   - \"poll\"\n\t *   - \"didPoll\"\n\t *   - \"pending\"\n\t *   - \"error\"\n\t *   - \"network\"\n\t *   - filter\n\t *   - topics array\n\t *   - transaction hash\n\t */\n\tvar PollableEvents = [\"block\", \"network\", \"pending\", \"poll\"];\n\tvar Event = /** @class */ (function () {\n\t    function Event(tag, listener, once) {\n\t        (0, lib$3.defineReadOnly)(this, \"tag\", tag);\n\t        (0, lib$3.defineReadOnly)(this, \"listener\", listener);\n\t        (0, lib$3.defineReadOnly)(this, \"once\", once);\n\t    }\n\t    Object.defineProperty(Event.prototype, \"event\", {\n\t        get: function () {\n\t            switch (this.type) {\n\t                case \"tx\":\n\t                    return this.hash;\n\t                case \"filter\":\n\t                    return this.filter;\n\t            }\n\t            return this.tag;\n\t        },\n\t        enumerable: false,\n\t        configurable: true\n\t    });\n\t    Object.defineProperty(Event.prototype, \"type\", {\n\t        get: function () {\n\t            return this.tag.split(\":\")[0];\n\t        },\n\t        enumerable: false,\n\t        configurable: true\n\t    });\n\t    Object.defineProperty(Event.prototype, \"hash\", {\n\t        get: function () {\n\t            var comps = this.tag.split(\":\");\n\t            if (comps[0] !== \"tx\") {\n\t                return null;\n\t            }\n\t            return comps[1];\n\t        },\n\t        enumerable: false,\n\t        configurable: true\n\t    });\n\t    Object.defineProperty(Event.prototype, \"filter\", {\n\t        get: function () {\n\t            var comps = this.tag.split(\":\");\n\t            if (comps[0] !== \"filter\") {\n\t                return null;\n\t            }\n\t            var address = comps[1];\n\t            var topics = deserializeTopics(comps[2]);\n\t            var filter = {};\n\t            if (topics.length > 0) {\n\t                filter.topics = topics;\n\t            }\n\t            if (address && address !== \"*\") {\n\t                filter.address = address;\n\t            }\n\t            return filter;\n\t        },\n\t        enumerable: false,\n\t        configurable: true\n\t    });\n\t    Event.prototype.pollable = function () {\n\t        return (this.tag.indexOf(\":\") >= 0 || PollableEvents.indexOf(this.tag) >= 0);\n\t    };\n\t    return Event;\n\t}());\n\texports.Event = Event;\n\t;\n\t// https://github.com/satoshilabs/slips/blob/master/slip-0044.md\n\tvar coinInfos = {\n\t    \"0\": { symbol: \"btc\", p2pkh: 0x00, p2sh: 0x05, prefix: \"bc\" },\n\t    \"2\": { symbol: \"ltc\", p2pkh: 0x30, p2sh: 0x32, prefix: \"ltc\" },\n\t    \"3\": { symbol: \"doge\", p2pkh: 0x1e, p2sh: 0x16 },\n\t    \"60\": { symbol: \"eth\", ilk: \"eth\" },\n\t    \"61\": { symbol: \"etc\", ilk: \"eth\" },\n\t    \"700\": { symbol: \"xdai\", ilk: \"eth\" },\n\t};\n\tfunction bytes32ify(value) {\n\t    return (0, lib$1.hexZeroPad)(lib$2.BigNumber.from(value).toHexString(), 32);\n\t}\n\t// Compute the Base58Check encoded data (checksum is first 4 bytes of sha256d)\n\tfunction base58Encode(data) {\n\t    return lib$g.Base58.encode((0, lib$1.concat)([data, (0, lib$1.hexDataSlice)((0, lib$h.sha256)((0, lib$h.sha256)(data)), 0, 4)]));\n\t}\n\tvar matchers = [\n\t    new RegExp(\"^(https):/\\/(.*)$\", \"i\"),\n\t    new RegExp(\"^(data):(.*)$\", \"i\"),\n\t    new RegExp(\"^(ipfs):/\\/(.*)$\", \"i\"),\n\t    new RegExp(\"^eip155:[0-9]+/(erc[0-9]+):(.*)$\", \"i\"),\n\t];\n\tfunction _parseString(result) {\n\t    try {\n\t        return (0, lib$8.toUtf8String)(_parseBytes(result));\n\t    }\n\t    catch (error) { }\n\t    return null;\n\t}\n\tfunction _parseBytes(result) {\n\t    if (result === \"0x\") {\n\t        return null;\n\t    }\n\t    var offset = lib$2.BigNumber.from((0, lib$1.hexDataSlice)(result, 0, 32)).toNumber();\n\t    var length = lib$2.BigNumber.from((0, lib$1.hexDataSlice)(result, offset, offset + 32)).toNumber();\n\t    return (0, lib$1.hexDataSlice)(result, offset + 32, offset + 32 + length);\n\t}\n\tvar Resolver = /** @class */ (function () {\n\t    // The resolvedAddress is only for creating a ReverseLookup resolver\n\t    function Resolver(provider, address, name, resolvedAddress) {\n\t        (0, lib$3.defineReadOnly)(this, \"provider\", provider);\n\t        (0, lib$3.defineReadOnly)(this, \"name\", name);\n\t        (0, lib$3.defineReadOnly)(this, \"address\", provider.formatter.address(address));\n\t        (0, lib$3.defineReadOnly)(this, \"_resolvedAddress\", resolvedAddress);\n\t    }\n\t    Resolver.prototype._fetchBytes = function (selector, parameters) {\n\t        return __awaiter(this, void 0, void 0, function () {\n\t            var tx, _a, error_1;\n\t            return __generator(this, function (_b) {\n\t                switch (_b.label) {\n\t                    case 0:\n\t                        tx = {\n\t                            to: this.address,\n\t                            data: (0, lib$1.hexConcat)([selector, (0, lib$9.namehash)(this.name), (parameters || \"0x\")])\n\t                        };\n\t                        _b.label = 1;\n\t                    case 1:\n\t                        _b.trys.push([1, 3, , 4]);\n\t                        _a = _parseBytes;\n\t                        return [4 /*yield*/, this.provider.call(tx)];\n\t                    case 2: return [2 /*return*/, _a.apply(void 0, [_b.sent()])];\n\t                    case 3:\n\t                        error_1 = _b.sent();\n\t                        if (error_1.code === lib.Logger.errors.CALL_EXCEPTION) {\n\t                            return [2 /*return*/, null];\n\t                        }\n\t                        return [2 /*return*/, null];\n\t                    case 4: return [2 /*return*/];\n\t                }\n\t            });\n\t        });\n\t    };\n\t    Resolver.prototype._getAddress = function (coinType, hexBytes) {\n\t        var coinInfo = coinInfos[String(coinType)];\n\t        if (coinInfo == null) {\n\t            logger.throwError(\"unsupported coin type: \" + coinType, lib.Logger.errors.UNSUPPORTED_OPERATION, {\n\t                operation: \"getAddress(\" + coinType + \")\"\n\t            });\n\t        }\n\t        if (coinInfo.ilk === \"eth\") {\n\t            return this.provider.formatter.address(hexBytes);\n\t        }\n\t        var bytes = (0, lib$1.arrayify)(hexBytes);\n\t        // P2PKH: OP_DUP OP_HASH160 <pubKeyHash> OP_EQUALVERIFY OP_CHECKSIG\n\t        if (coinInfo.p2pkh != null) {\n\t            var p2pkh = hexBytes.match(/^0x76a9([0-9a-f][0-9a-f])([0-9a-f]*)88ac$/);\n\t            if (p2pkh) {\n\t                var length_1 = parseInt(p2pkh[1], 16);\n\t                if (p2pkh[2].length === length_1 * 2 && length_1 >= 1 && length_1 <= 75) {\n\t                    return base58Encode((0, lib$1.concat)([[coinInfo.p2pkh], (\"0x\" + p2pkh[2])]));\n\t                }\n\t            }\n\t        }\n\t        // P2SH: OP_HASH160 <scriptHash> OP_EQUAL\n\t        if (coinInfo.p2sh != null) {\n\t            var p2sh = hexBytes.match(/^0xa9([0-9a-f][0-9a-f])([0-9a-f]*)87$/);\n\t            if (p2sh) {\n\t                var length_2 = parseInt(p2sh[1], 16);\n\t                if (p2sh[2].length === length_2 * 2 && length_2 >= 1 && length_2 <= 75) {\n\t                    return base58Encode((0, lib$1.concat)([[coinInfo.p2sh], (\"0x\" + p2sh[2])]));\n\t                }\n\t            }\n\t        }\n\t        // Bech32\n\t        if (coinInfo.prefix != null) {\n\t            var length_3 = bytes[1];\n\t            // https://github.com/bitcoin/bips/blob/master/bip-0141.mediawiki#witness-program\n\t            var version_1 = bytes[0];\n\t            if (version_1 === 0x00) {\n\t                if (length_3 !== 20 && length_3 !== 32) {\n\t                    version_1 = -1;\n\t                }\n\t            }\n\t            else {\n\t                version_1 = -1;\n\t            }\n\t            if (version_1 >= 0 && bytes.length === 2 + length_3 && length_3 >= 1 && length_3 <= 75) {\n\t                var words = bech32_1.default.toWords(bytes.slice(2));\n\t                words.unshift(version_1);\n\t                return bech32_1.default.encode(coinInfo.prefix, words);\n\t            }\n\t        }\n\t        return null;\n\t    };\n\t    Resolver.prototype.getAddress = function (coinType) {\n\t        return __awaiter(this, void 0, void 0, function () {\n\t            var transaction, hexBytes_1, error_2, hexBytes, address;\n\t            return __generator(this, function (_a) {\n\t                switch (_a.label) {\n\t                    case 0:\n\t                        if (coinType == null) {\n\t                            coinType = 60;\n\t                        }\n\t                        if (!(coinType === 60)) return [3 /*break*/, 4];\n\t                        _a.label = 1;\n\t                    case 1:\n\t                        _a.trys.push([1, 3, , 4]);\n\t                        transaction = {\n\t                            to: this.address,\n\t                            data: (\"0x3b3b57de\" + (0, lib$9.namehash)(this.name).substring(2))\n\t                        };\n\t                        return [4 /*yield*/, this.provider.call(transaction)];\n\t                    case 2:\n\t                        hexBytes_1 = _a.sent();\n\t                        // No address\n\t                        if (hexBytes_1 === \"0x\" || hexBytes_1 === lib$7.HashZero) {\n\t                            return [2 /*return*/, null];\n\t                        }\n\t                        return [2 /*return*/, this.provider.formatter.callAddress(hexBytes_1)];\n\t                    case 3:\n\t                        error_2 = _a.sent();\n\t                        if (error_2.code === lib.Logger.errors.CALL_EXCEPTION) {\n\t                            return [2 /*return*/, null];\n\t                        }\n\t                        throw error_2;\n\t                    case 4: return [4 /*yield*/, this._fetchBytes(\"0xf1cb7e06\", bytes32ify(coinType))];\n\t                    case 5:\n\t                        hexBytes = _a.sent();\n\t                        // No address\n\t                        if (hexBytes == null || hexBytes === \"0x\") {\n\t                            return [2 /*return*/, null];\n\t                        }\n\t                        address = this._getAddress(coinType, hexBytes);\n\t                        if (address == null) {\n\t                            logger.throwError(\"invalid or unsupported coin data\", lib.Logger.errors.UNSUPPORTED_OPERATION, {\n\t                                operation: \"getAddress(\" + coinType + \")\",\n\t                                coinType: coinType,\n\t                                data: hexBytes\n\t                            });\n\t                        }\n\t                        return [2 /*return*/, address];\n\t                }\n\t            });\n\t        });\n\t    };\n\t    Resolver.prototype.getAvatar = function () {\n\t        return __awaiter(this, void 0, void 0, function () {\n\t            var linkage, avatar, i, match, _a, selector, owner, _b, comps, addr, tokenId, tokenOwner, _c, _d, balance, _e, _f, tx, metadataUrl, _g, metadata, error_3;\n\t            return __generator(this, function (_h) {\n\t                switch (_h.label) {\n\t                    case 0:\n\t                        linkage = [];\n\t                        _h.label = 1;\n\t                    case 1:\n\t                        _h.trys.push([1, 19, , 20]);\n\t                        return [4 /*yield*/, this.getText(\"avatar\")];\n\t                    case 2:\n\t                        avatar = _h.sent();\n\t                        if (avatar == null) {\n\t                            return [2 /*return*/, null];\n\t                        }\n\t                        i = 0;\n\t                        _h.label = 3;\n\t                    case 3:\n\t                        if (!(i < matchers.length)) return [3 /*break*/, 18];\n\t                        match = avatar.match(matchers[i]);\n\t                        if (match == null) {\n\t                            return [3 /*break*/, 17];\n\t                        }\n\t                        _a = match[1];\n\t                        switch (_a) {\n\t                            case \"https\": return [3 /*break*/, 4];\n\t                            case \"data\": return [3 /*break*/, 5];\n\t                            case \"ipfs\": return [3 /*break*/, 6];\n\t                            case \"erc721\": return [3 /*break*/, 7];\n\t                            case \"erc1155\": return [3 /*break*/, 7];\n\t                        }\n\t                        return [3 /*break*/, 17];\n\t                    case 4:\n\t                        linkage.push({ type: \"url\", content: avatar });\n\t                        return [2 /*return*/, { linkage: linkage, url: avatar }];\n\t                    case 5:\n\t                        linkage.push({ type: \"data\", content: avatar });\n\t                        return [2 /*return*/, { linkage: linkage, url: avatar }];\n\t                    case 6:\n\t                        linkage.push({ type: \"ipfs\", content: avatar });\n\t                        return [2 /*return*/, { linkage: linkage, url: \"https://gateway.ipfs.io/ipfs/\" + avatar.substring(7) }];\n\t                    case 7:\n\t                        selector = (match[1] === \"erc721\") ? \"0xc87b56dd\" : \"0x0e89341c\";\n\t                        linkage.push({ type: match[1], content: avatar });\n\t                        _b = this._resolvedAddress;\n\t                        if (_b) return [3 /*break*/, 9];\n\t                        return [4 /*yield*/, this.getAddress()];\n\t                    case 8:\n\t                        _b = (_h.sent());\n\t                        _h.label = 9;\n\t                    case 9:\n\t                        owner = (_b);\n\t                        comps = (match[2] || \"\").split(\"/\");\n\t                        if (comps.length !== 2) {\n\t                            return [2 /*return*/, null];\n\t                        }\n\t                        return [4 /*yield*/, this.provider.formatter.address(comps[0])];\n\t                    case 10:\n\t                        addr = _h.sent();\n\t                        tokenId = (0, lib$1.hexZeroPad)(lib$2.BigNumber.from(comps[1]).toHexString(), 32);\n\t                        if (!(match[1] === \"erc721\")) return [3 /*break*/, 12];\n\t                        _d = (_c = this.provider.formatter).callAddress;\n\t                        return [4 /*yield*/, this.provider.call({\n\t                                to: addr, data: (0, lib$1.hexConcat)([\"0x6352211e\", tokenId])\n\t                            })];\n\t                    case 11:\n\t                        tokenOwner = _d.apply(_c, [_h.sent()]);\n\t                        if (owner !== tokenOwner) {\n\t                            return [2 /*return*/, null];\n\t                        }\n\t                        linkage.push({ type: \"owner\", content: tokenOwner });\n\t                        return [3 /*break*/, 14];\n\t                    case 12:\n\t                        if (!(match[1] === \"erc1155\")) return [3 /*break*/, 14];\n\t                        _f = (_e = lib$2.BigNumber).from;\n\t                        return [4 /*yield*/, this.provider.call({\n\t                                to: addr, data: (0, lib$1.hexConcat)([\"0x00fdd58e\", (0, lib$1.hexZeroPad)(owner, 32), tokenId])\n\t                            })];\n\t                    case 13:\n\t                        balance = _f.apply(_e, [_h.sent()]);\n\t                        if (balance.isZero()) {\n\t                            return [2 /*return*/, null];\n\t                        }\n\t                        linkage.push({ type: \"balance\", content: balance.toString() });\n\t                        _h.label = 14;\n\t                    case 14:\n\t                        tx = {\n\t                            to: this.provider.formatter.address(comps[0]),\n\t                            data: (0, lib$1.hexConcat)([selector, tokenId])\n\t                        };\n\t                        _g = _parseString;\n\t                        return [4 /*yield*/, this.provider.call(tx)];\n\t                    case 15:\n\t                        metadataUrl = _g.apply(void 0, [_h.sent()]);\n\t                        if (metadataUrl == null) {\n\t                            return [2 /*return*/, null];\n\t                        }\n\t                        linkage.push({ type: \"metadata-url\", content: metadataUrl });\n\t                        // ERC-1155 allows a generic {id} in the URL\n\t                        if (match[1] === \"erc1155\") {\n\t                            metadataUrl = metadataUrl.replace(\"{id}\", tokenId.substring(2));\n\t                        }\n\t                        return [4 /*yield*/, (0, lib$q.fetchJson)(metadataUrl)];\n\t                    case 16:\n\t                        metadata = _h.sent();\n\t                        // Pull the image URL out\n\t                        if (!metadata || typeof (metadata.image) !== \"string\" || !metadata.image.match(/^https:\\/\\//i)) {\n\t                            return [2 /*return*/, null];\n\t                        }\n\t                        linkage.push({ type: \"metadata\", content: JSON.stringify(metadata) });\n\t                        linkage.push({ type: \"url\", content: metadata.image });\n\t                        return [2 /*return*/, { linkage: linkage, url: metadata.image }];\n\t                    case 17:\n\t                        i++;\n\t                        return [3 /*break*/, 3];\n\t                    case 18: return [3 /*break*/, 20];\n\t                    case 19:\n\t                        error_3 = _h.sent();\n\t                        return [3 /*break*/, 20];\n\t                    case 20: return [2 /*return*/, null];\n\t                }\n\t            });\n\t        });\n\t    };\n\t    Resolver.prototype.getContentHash = function () {\n\t        return __awaiter(this, void 0, void 0, function () {\n\t            var hexBytes, ipfs, length_4, swarm;\n\t            return __generator(this, function (_a) {\n\t                switch (_a.label) {\n\t                    case 0: return [4 /*yield*/, this._fetchBytes(\"0xbc1c58d1\")];\n\t                    case 1:\n\t                        hexBytes = _a.sent();\n\t                        // No contenthash\n\t                        if (hexBytes == null || hexBytes === \"0x\") {\n\t                            return [2 /*return*/, null];\n\t                        }\n\t                        ipfs = hexBytes.match(/^0xe3010170(([0-9a-f][0-9a-f])([0-9a-f][0-9a-f])([0-9a-f]*))$/);\n\t                        if (ipfs) {\n\t                            length_4 = parseInt(ipfs[3], 16);\n\t                            if (ipfs[4].length === length_4 * 2) {\n\t                                return [2 /*return*/, \"ipfs:/\\/\" + lib$g.Base58.encode(\"0x\" + ipfs[1])];\n\t                            }\n\t                        }\n\t                        swarm = hexBytes.match(/^0xe40101fa011b20([0-9a-f]*)$/);\n\t                        if (swarm) {\n\t                            if (swarm[1].length === (32 * 2)) {\n\t                                return [2 /*return*/, \"bzz:/\\/\" + swarm[1]];\n\t                            }\n\t                        }\n\t                        return [2 /*return*/, logger.throwError(\"invalid or unsupported content hash data\", lib.Logger.errors.UNSUPPORTED_OPERATION, {\n\t                                operation: \"getContentHash()\",\n\t                                data: hexBytes\n\t                            })];\n\t                }\n\t            });\n\t        });\n\t    };\n\t    Resolver.prototype.getText = function (key) {\n\t        return __awaiter(this, void 0, void 0, function () {\n\t            var keyBytes, hexBytes;\n\t            return __generator(this, function (_a) {\n\t                switch (_a.label) {\n\t                    case 0:\n\t                        keyBytes = (0, lib$8.toUtf8Bytes)(key);\n\t                        // The nodehash consumes the first slot, so the string pointer targets\n\t                        // offset 64, with the length at offset 64 and data starting at offset 96\n\t                        keyBytes = (0, lib$1.concat)([bytes32ify(64), bytes32ify(keyBytes.length), keyBytes]);\n\t                        // Pad to word-size (32 bytes)\n\t                        if ((keyBytes.length % 32) !== 0) {\n\t                            keyBytes = (0, lib$1.concat)([keyBytes, (0, lib$1.hexZeroPad)(\"0x\", 32 - (key.length % 32))]);\n\t                        }\n\t                        return [4 /*yield*/, this._fetchBytes(\"0x59d1d43c\", (0, lib$1.hexlify)(keyBytes))];\n\t                    case 1:\n\t                        hexBytes = _a.sent();\n\t                        if (hexBytes == null || hexBytes === \"0x\") {\n\t                            return [2 /*return*/, null];\n\t                        }\n\t                        return [2 /*return*/, (0, lib$8.toUtf8String)(hexBytes)];\n\t                }\n\t            });\n\t        });\n\t    };\n\t    return Resolver;\n\t}());\n\texports.Resolver = Resolver;\n\tvar defaultFormatter = null;\n\tvar nextPollId = 1;\n\tvar BaseProvider = /** @class */ (function (_super) {\n\t    __extends(BaseProvider, _super);\n\t    /**\n\t     *  ready\n\t     *\n\t     *  A Promise<Network> that resolves only once the provider is ready.\n\t     *\n\t     *  Sub-classes that call the super with a network without a chainId\n\t     *  MUST set this. Standard named networks have a known chainId.\n\t     *\n\t     */\n\t    function BaseProvider(network) {\n\t        var _newTarget = this.constructor;\n\t        var _this = this;\n\t        logger.checkNew(_newTarget, lib$b.Provider);\n\t        _this = _super.call(this) || this;\n\t        // Events being listened to\n\t        _this._events = [];\n\t        _this._emitted = { block: -2 };\n\t        _this.formatter = _newTarget.getFormatter();\n\t        // If network is any, this Provider allows the underlying\n\t        // network to change dynamically, and we auto-detect the\n\t        // current network\n\t        (0, lib$3.defineReadOnly)(_this, \"anyNetwork\", (network === \"any\"));\n\t        if (_this.anyNetwork) {\n\t            network = _this.detectNetwork();\n\t        }\n\t        if (network instanceof Promise) {\n\t            _this._networkPromise = network;\n\t            // Squash any \"unhandled promise\" errors; that do not need to be handled\n\t            network.catch(function (error) { });\n\t            // Trigger initial network setting (async)\n\t            _this._ready().catch(function (error) { });\n\t        }\n\t        else {\n\t            var knownNetwork = (0, lib$3.getStatic)(_newTarget, \"getNetwork\")(network);\n\t            if (knownNetwork) {\n\t                (0, lib$3.defineReadOnly)(_this, \"_network\", knownNetwork);\n\t                _this.emit(\"network\", knownNetwork, null);\n\t            }\n\t            else {\n\t                logger.throwArgumentError(\"invalid network\", \"network\", network);\n\t            }\n\t        }\n\t        _this._maxInternalBlockNumber = -1024;\n\t        _this._lastBlockNumber = -2;\n\t        _this._pollingInterval = 4000;\n\t        _this._fastQueryDate = 0;\n\t        return _this;\n\t    }\n\t    BaseProvider.prototype._ready = function () {\n\t        return __awaiter(this, void 0, void 0, function () {\n\t            var network, error_4;\n\t            return __generator(this, function (_a) {\n\t                switch (_a.label) {\n\t                    case 0:\n\t                        if (!(this._network == null)) return [3 /*break*/, 7];\n\t                        network = null;\n\t                        if (!this._networkPromise) return [3 /*break*/, 4];\n\t                        _a.label = 1;\n\t                    case 1:\n\t                        _a.trys.push([1, 3, , 4]);\n\t                        return [4 /*yield*/, this._networkPromise];\n\t                    case 2:\n\t                        network = _a.sent();\n\t                        return [3 /*break*/, 4];\n\t                    case 3:\n\t                        error_4 = _a.sent();\n\t                        return [3 /*break*/, 4];\n\t                    case 4:\n\t                        if (!(network == null)) return [3 /*break*/, 6];\n\t                        return [4 /*yield*/, this.detectNetwork()];\n\t                    case 5:\n\t                        network = _a.sent();\n\t                        _a.label = 6;\n\t                    case 6:\n\t                        // This should never happen; every Provider sub-class should have\n\t                        // suggested a network by here (or have thrown).\n\t                        if (!network) {\n\t                            logger.throwError(\"no network detected\", lib.Logger.errors.UNKNOWN_ERROR, {});\n\t                        }\n\t                        // Possible this call stacked so do not call defineReadOnly again\n\t                        if (this._network == null) {\n\t                            if (this.anyNetwork) {\n\t                                this._network = network;\n\t                            }\n\t                            else {\n\t                                (0, lib$3.defineReadOnly)(this, \"_network\", network);\n\t                            }\n\t                            this.emit(\"network\", network, null);\n\t                        }\n\t                        _a.label = 7;\n\t                    case 7: return [2 /*return*/, this._network];\n\t                }\n\t            });\n\t        });\n\t    };\n\t    Object.defineProperty(BaseProvider.prototype, \"ready\", {\n\t        // This will always return the most recently established network.\n\t        // For \"any\", this can change (a \"network\" event is emitted before\n\t        // any change is reflected); otherwise this cannot change\n\t        get: function () {\n\t            var _this = this;\n\t            return (0, lib$q.poll)(function () {\n\t                return _this._ready().then(function (network) {\n\t                    return network;\n\t                }, function (error) {\n\t                    // If the network isn't running yet, we will wait\n\t                    if (error.code === lib.Logger.errors.NETWORK_ERROR && error.event === \"noNetwork\") {\n\t                        return undefined;\n\t                    }\n\t                    throw error;\n\t                });\n\t            });\n\t        },\n\t        enumerable: false,\n\t        configurable: true\n\t    });\n\t    // @TODO: Remove this and just create a singleton formatter\n\t    BaseProvider.getFormatter = function () {\n\t        if (defaultFormatter == null) {\n\t            defaultFormatter = new formatter.Formatter();\n\t        }\n\t        return defaultFormatter;\n\t    };\n\t    // @TODO: Remove this and just use getNetwork\n\t    BaseProvider.getNetwork = function (network) {\n\t        return (0, lib$o.getNetwork)((network == null) ? \"homestead\" : network);\n\t    };\n\t    // Fetches the blockNumber, but will reuse any result that is less\n\t    // than maxAge old or has been requested since the last request\n\t    BaseProvider.prototype._getInternalBlockNumber = function (maxAge) {\n\t        return __awaiter(this, void 0, void 0, function () {\n\t            var internalBlockNumber, result, error_5, reqTime, checkInternalBlockNumber;\n\t            var _this = this;\n\t            return __generator(this, function (_a) {\n\t                switch (_a.label) {\n\t                    case 0: return [4 /*yield*/, this._ready()];\n\t                    case 1:\n\t                        _a.sent();\n\t                        if (!(maxAge > 0)) return [3 /*break*/, 7];\n\t                        _a.label = 2;\n\t                    case 2:\n\t                        if (!this._internalBlockNumber) return [3 /*break*/, 7];\n\t                        internalBlockNumber = this._internalBlockNumber;\n\t                        _a.label = 3;\n\t                    case 3:\n\t                        _a.trys.push([3, 5, , 6]);\n\t                        return [4 /*yield*/, internalBlockNumber];\n\t                    case 4:\n\t                        result = _a.sent();\n\t                        if ((getTime() - result.respTime) <= maxAge) {\n\t                            return [2 /*return*/, result.blockNumber];\n\t                        }\n\t                        // Too old; fetch a new value\n\t                        return [3 /*break*/, 7];\n\t                    case 5:\n\t                        error_5 = _a.sent();\n\t                        // The fetch rejected; if we are the first to get the\n\t                        // rejection, drop through so we replace it with a new\n\t                        // fetch; all others blocked will then get that fetch\n\t                        // which won't match the one they \"remembered\" and loop\n\t                        if (this._internalBlockNumber === internalBlockNumber) {\n\t                            return [3 /*break*/, 7];\n\t                        }\n\t                        return [3 /*break*/, 6];\n\t                    case 6: return [3 /*break*/, 2];\n\t                    case 7:\n\t                        reqTime = getTime();\n\t                        checkInternalBlockNumber = (0, lib$3.resolveProperties)({\n\t                            blockNumber: this.perform(\"getBlockNumber\", {}),\n\t                            networkError: this.getNetwork().then(function (network) { return (null); }, function (error) { return (error); })\n\t                        }).then(function (_a) {\n\t                            var blockNumber = _a.blockNumber, networkError = _a.networkError;\n\t                            if (networkError) {\n\t                                // Unremember this bad internal block number\n\t                                if (_this._internalBlockNumber === checkInternalBlockNumber) {\n\t                                    _this._internalBlockNumber = null;\n\t                                }\n\t                                throw networkError;\n\t                            }\n\t                            var respTime = getTime();\n\t                            blockNumber = lib$2.BigNumber.from(blockNumber).toNumber();\n\t                            if (blockNumber < _this._maxInternalBlockNumber) {\n\t                                blockNumber = _this._maxInternalBlockNumber;\n\t                            }\n\t                            _this._maxInternalBlockNumber = blockNumber;\n\t                            _this._setFastBlockNumber(blockNumber); // @TODO: Still need this?\n\t                            return { blockNumber: blockNumber, reqTime: reqTime, respTime: respTime };\n\t                        });\n\t                        this._internalBlockNumber = checkInternalBlockNumber;\n\t                        // Swallow unhandled exceptions; if needed they are handled else where\n\t                        checkInternalBlockNumber.catch(function (error) {\n\t                            // Don't null the dead (rejected) fetch, if it has already been updated\n\t                            if (_this._internalBlockNumber === checkInternalBlockNumber) {\n\t                                _this._internalBlockNumber = null;\n\t                            }\n\t                        });\n\t                        return [4 /*yield*/, checkInternalBlockNumber];\n\t                    case 8: return [2 /*return*/, (_a.sent()).blockNumber];\n\t                }\n\t            });\n\t        });\n\t    };\n\t    BaseProvider.prototype.poll = function () {\n\t        return __awaiter(this, void 0, void 0, function () {\n\t            var pollId, runners, blockNumber, error_6, i;\n\t            var _this = this;\n\t            return __generator(this, function (_a) {\n\t                switch (_a.label) {\n\t                    case 0:\n\t                        pollId = nextPollId++;\n\t                        runners = [];\n\t                        blockNumber = null;\n\t                        _a.label = 1;\n\t                    case 1:\n\t                        _a.trys.push([1, 3, , 4]);\n\t                        return [4 /*yield*/, this._getInternalBlockNumber(100 + this.pollingInterval / 2)];\n\t                    case 2:\n\t                        blockNumber = _a.sent();\n\t                        return [3 /*break*/, 4];\n\t                    case 3:\n\t                        error_6 = _a.sent();\n\t                        this.emit(\"error\", error_6);\n\t                        return [2 /*return*/];\n\t                    case 4:\n\t                        this._setFastBlockNumber(blockNumber);\n\t                        // Emit a poll event after we have the latest (fast) block number\n\t                        this.emit(\"poll\", pollId, blockNumber);\n\t                        // If the block has not changed, meh.\n\t                        if (blockNumber === this._lastBlockNumber) {\n\t                            this.emit(\"didPoll\", pollId);\n\t                            return [2 /*return*/];\n\t                        }\n\t                        // First polling cycle, trigger a \"block\" events\n\t                        if (this._emitted.block === -2) {\n\t                            this._emitted.block = blockNumber - 1;\n\t                        }\n\t                        if (Math.abs((this._emitted.block) - blockNumber) > 1000) {\n\t                            logger.warn(\"network block skew detected; skipping block events (emitted=\" + this._emitted.block + \" blockNumber\" + blockNumber + \")\");\n\t                            this.emit(\"error\", logger.makeError(\"network block skew detected\", lib.Logger.errors.NETWORK_ERROR, {\n\t                                blockNumber: blockNumber,\n\t                                event: \"blockSkew\",\n\t                                previousBlockNumber: this._emitted.block\n\t                            }));\n\t                            this.emit(\"block\", blockNumber);\n\t                        }\n\t                        else {\n\t                            // Notify all listener for each block that has passed\n\t                            for (i = this._emitted.block + 1; i <= blockNumber; i++) {\n\t                                this.emit(\"block\", i);\n\t                            }\n\t                        }\n\t                        // The emitted block was updated, check for obsolete events\n\t                        if (this._emitted.block !== blockNumber) {\n\t                            this._emitted.block = blockNumber;\n\t                            Object.keys(this._emitted).forEach(function (key) {\n\t                                // The block event does not expire\n\t                                if (key === \"block\") {\n\t                                    return;\n\t                                }\n\t                                // The block we were at when we emitted this event\n\t                                var eventBlockNumber = _this._emitted[key];\n\t                                // We cannot garbage collect pending transactions or blocks here\n\t                                // They should be garbage collected by the Provider when setting\n\t                                // \"pending\" events\n\t                                if (eventBlockNumber === \"pending\") {\n\t                                    return;\n\t                                }\n\t                                // Evict any transaction hashes or block hashes over 12 blocks\n\t                                // old, since they should not return null anyways\n\t                                if (blockNumber - eventBlockNumber > 12) {\n\t                                    delete _this._emitted[key];\n\t                                }\n\t                            });\n\t                        }\n\t                        // First polling cycle\n\t                        if (this._lastBlockNumber === -2) {\n\t                            this._lastBlockNumber = blockNumber - 1;\n\t                        }\n\t                        // Find all transaction hashes we are waiting on\n\t                        this._events.forEach(function (event) {\n\t                            switch (event.type) {\n\t                                case \"tx\": {\n\t                                    var hash_2 = event.hash;\n\t                                    var runner = _this.getTransactionReceipt(hash_2).then(function (receipt) {\n\t                                        if (!receipt || receipt.blockNumber == null) {\n\t                                            return null;\n\t                                        }\n\t                                        _this._emitted[\"t:\" + hash_2] = receipt.blockNumber;\n\t                                        _this.emit(hash_2, receipt);\n\t                                        return null;\n\t                                    }).catch(function (error) { _this.emit(\"error\", error); });\n\t                                    runners.push(runner);\n\t                                    break;\n\t                                }\n\t                                case \"filter\": {\n\t                                    var filter_1 = event.filter;\n\t                                    filter_1.fromBlock = _this._lastBlockNumber + 1;\n\t                                    filter_1.toBlock = blockNumber;\n\t                                    var runner = _this.getLogs(filter_1).then(function (logs) {\n\t                                        if (logs.length === 0) {\n\t                                            return;\n\t                                        }\n\t                                        logs.forEach(function (log) {\n\t                                            _this._emitted[\"b:\" + log.blockHash] = log.blockNumber;\n\t                                            _this._emitted[\"t:\" + log.transactionHash] = log.blockNumber;\n\t                                            _this.emit(filter_1, log);\n\t                                        });\n\t                                    }).catch(function (error) { _this.emit(\"error\", error); });\n\t                                    runners.push(runner);\n\t                                    break;\n\t                                }\n\t                            }\n\t                        });\n\t                        this._lastBlockNumber = blockNumber;\n\t                        // Once all events for this loop have been processed, emit \"didPoll\"\n\t                        Promise.all(runners).then(function () {\n\t                            _this.emit(\"didPoll\", pollId);\n\t                        }).catch(function (error) { _this.emit(\"error\", error); });\n\t                        return [2 /*return*/];\n\t                }\n\t            });\n\t        });\n\t    };\n\t    // Deprecated; do not use this\n\t    BaseProvider.prototype.resetEventsBlock = function (blockNumber) {\n\t        this._lastBlockNumber = blockNumber - 1;\n\t        if (this.polling) {\n\t            this.poll();\n\t        }\n\t    };\n\t    Object.defineProperty(BaseProvider.prototype, \"network\", {\n\t        get: function () {\n\t            return this._network;\n\t        },\n\t        enumerable: false,\n\t        configurable: true\n\t    });\n\t    // This method should query the network if the underlying network\n\t    // can change, such as when connected to a JSON-RPC backend\n\t    BaseProvider.prototype.detectNetwork = function () {\n\t        return __awaiter(this, void 0, void 0, function () {\n\t            return __generator(this, function (_a) {\n\t                return [2 /*return*/, logger.throwError(\"provider does not support network detection\", lib.Logger.errors.UNSUPPORTED_OPERATION, {\n\t                        operation: \"provider.detectNetwork\"\n\t                    })];\n\t            });\n\t        });\n\t    };\n\t    BaseProvider.prototype.getNetwork = function () {\n\t        return __awaiter(this, void 0, void 0, function () {\n\t            var network, currentNetwork, error;\n\t            return __generator(this, function (_a) {\n\t                switch (_a.label) {\n\t                    case 0: return [4 /*yield*/, this._ready()];\n\t                    case 1:\n\t                        network = _a.sent();\n\t                        return [4 /*yield*/, this.detectNetwork()];\n\t                    case 2:\n\t                        currentNetwork = _a.sent();\n\t                        if (!(network.chainId !== currentNetwork.chainId)) return [3 /*break*/, 5];\n\t                        if (!this.anyNetwork) return [3 /*break*/, 4];\n\t                        this._network = currentNetwork;\n\t                        // Reset all internal block number guards and caches\n\t                        this._lastBlockNumber = -2;\n\t                        this._fastBlockNumber = null;\n\t                        this._fastBlockNumberPromise = null;\n\t                        this._fastQueryDate = 0;\n\t                        this._emitted.block = -2;\n\t                        this._maxInternalBlockNumber = -1024;\n\t                        this._internalBlockNumber = null;\n\t                        // The \"network\" event MUST happen before this method resolves\n\t                        // so any events have a chance to unregister, so we stall an\n\t                        // additional event loop before returning from /this/ call\n\t                        this.emit(\"network\", currentNetwork, network);\n\t                        return [4 /*yield*/, stall(0)];\n\t                    case 3:\n\t                        _a.sent();\n\t                        return [2 /*return*/, this._network];\n\t                    case 4:\n\t                        error = logger.makeError(\"underlying network changed\", lib.Logger.errors.NETWORK_ERROR, {\n\t                            event: \"changed\",\n\t                            network: network,\n\t                            detectedNetwork: currentNetwork\n\t                        });\n\t                        this.emit(\"error\", error);\n\t                        throw error;\n\t                    case 5: return [2 /*return*/, network];\n\t                }\n\t            });\n\t        });\n\t    };\n\t    Object.defineProperty(BaseProvider.prototype, \"blockNumber\", {\n\t        get: function () {\n\t            var _this = this;\n\t            this._getInternalBlockNumber(100 + this.pollingInterval / 2).then(function (blockNumber) {\n\t                _this._setFastBlockNumber(blockNumber);\n\t            }, function (error) { });\n\t            return (this._fastBlockNumber != null) ? this._fastBlockNumber : -1;\n\t        },\n\t        enumerable: false,\n\t        configurable: true\n\t    });\n\t    Object.defineProperty(BaseProvider.prototype, \"polling\", {\n\t        get: function () {\n\t            return (this._poller != null);\n\t        },\n\t        set: function (value) {\n\t            var _this = this;\n\t            if (value && !this._poller) {\n\t                this._poller = setInterval(function () { _this.poll(); }, this.pollingInterval);\n\t                if (!this._bootstrapPoll) {\n\t                    this._bootstrapPoll = setTimeout(function () {\n\t                        _this.poll();\n\t                        // We block additional polls until the polling interval\n\t                        // is done, to prevent overwhelming the poll function\n\t                        _this._bootstrapPoll = setTimeout(function () {\n\t                            // If polling was disabled, something may require a poke\n\t                            // since starting the bootstrap poll and it was disabled\n\t                            if (!_this._poller) {\n\t                                _this.poll();\n\t                            }\n\t                            // Clear out the bootstrap so we can do another\n\t                            _this._bootstrapPoll = null;\n\t                        }, _this.pollingInterval);\n\t                    }, 0);\n\t                }\n\t            }\n\t            else if (!value && this._poller) {\n\t                clearInterval(this._poller);\n\t                this._poller = null;\n\t            }\n\t        },\n\t        enumerable: false,\n\t        configurable: true\n\t    });\n\t    Object.defineProperty(BaseProvider.prototype, \"pollingInterval\", {\n\t        get: function () {\n\t            return this._pollingInterval;\n\t        },\n\t        set: function (value) {\n\t            var _this = this;\n\t            if (typeof (value) !== \"number\" || value <= 0 || parseInt(String(value)) != value) {\n\t                throw new Error(\"invalid polling interval\");\n\t            }\n\t            this._pollingInterval = value;\n\t            if (this._poller) {\n\t                clearInterval(this._poller);\n\t                this._poller = setInterval(function () { _this.poll(); }, this._pollingInterval);\n\t            }\n\t        },\n\t        enumerable: false,\n\t        configurable: true\n\t    });\n\t    BaseProvider.prototype._getFastBlockNumber = function () {\n\t        var _this = this;\n\t        var now = getTime();\n\t        // Stale block number, request a newer value\n\t        if ((now - this._fastQueryDate) > 2 * this._pollingInterval) {\n\t            this._fastQueryDate = now;\n\t            this._fastBlockNumberPromise = this.getBlockNumber().then(function (blockNumber) {\n\t                if (_this._fastBlockNumber == null || blockNumber > _this._fastBlockNumber) {\n\t                    _this._fastBlockNumber = blockNumber;\n\t                }\n\t                return _this._fastBlockNumber;\n\t            });\n\t        }\n\t        return this._fastBlockNumberPromise;\n\t    };\n\t    BaseProvider.prototype._setFastBlockNumber = function (blockNumber) {\n\t        // Older block, maybe a stale request\n\t        if (this._fastBlockNumber != null && blockNumber < this._fastBlockNumber) {\n\t            return;\n\t        }\n\t        // Update the time we updated the blocknumber\n\t        this._fastQueryDate = getTime();\n\t        // Newer block number, use  it\n\t        if (this._fastBlockNumber == null || blockNumber > this._fastBlockNumber) {\n\t            this._fastBlockNumber = blockNumber;\n\t            this._fastBlockNumberPromise = Promise.resolve(blockNumber);\n\t        }\n\t    };\n\t    BaseProvider.prototype.waitForTransaction = function (transactionHash, confirmations, timeout) {\n\t        return __awaiter(this, void 0, void 0, function () {\n\t            return __generator(this, function (_a) {\n\t                return [2 /*return*/, this._waitForTransaction(transactionHash, (confirmations == null) ? 1 : confirmations, timeout || 0, null)];\n\t            });\n\t        });\n\t    };\n\t    BaseProvider.prototype._waitForTransaction = function (transactionHash, confirmations, timeout, replaceable) {\n\t        return __awaiter(this, void 0, void 0, function () {\n\t            var receipt;\n\t            var _this = this;\n\t            return __generator(this, function (_a) {\n\t                switch (_a.label) {\n\t                    case 0: return [4 /*yield*/, this.getTransactionReceipt(transactionHash)];\n\t                    case 1:\n\t                        receipt = _a.sent();\n\t                        // Receipt is already good\n\t                        if ((receipt ? receipt.confirmations : 0) >= confirmations) {\n\t                            return [2 /*return*/, receipt];\n\t                        }\n\t                        // Poll until the receipt is good...\n\t                        return [2 /*return*/, new Promise(function (resolve, reject) {\n\t                                var cancelFuncs = [];\n\t                                var done = false;\n\t                                var alreadyDone = function () {\n\t                                    if (done) {\n\t                                        return true;\n\t                                    }\n\t                                    done = true;\n\t                                    cancelFuncs.forEach(function (func) { func(); });\n\t                                    return false;\n\t                                };\n\t                                var minedHandler = function (receipt) {\n\t                                    if (receipt.confirmations < confirmations) {\n\t                                        return;\n\t                                    }\n\t                                    if (alreadyDone()) {\n\t                                        return;\n\t                                    }\n\t                                    resolve(receipt);\n\t                                };\n\t                                _this.on(transactionHash, minedHandler);\n\t                                cancelFuncs.push(function () { _this.removeListener(transactionHash, minedHandler); });\n\t                                if (replaceable) {\n\t                                    var lastBlockNumber_1 = replaceable.startBlock;\n\t                                    var scannedBlock_1 = null;\n\t                                    var replaceHandler_1 = function (blockNumber) { return __awaiter(_this, void 0, void 0, function () {\n\t                                        var _this = this;\n\t                                        return __generator(this, function (_a) {\n\t                                            switch (_a.label) {\n\t                                                case 0:\n\t                                                    if (done) {\n\t                                                        return [2 /*return*/];\n\t                                                    }\n\t                                                    // Wait 1 second; this is only used in the case of a fault, so\n\t                                                    // we will trade off a little bit of latency for more consistent\n\t                                                    // results and fewer JSON-RPC calls\n\t                                                    return [4 /*yield*/, stall(1000)];\n\t                                                case 1:\n\t                                                    // Wait 1 second; this is only used in the case of a fault, so\n\t                                                    // we will trade off a little bit of latency for more consistent\n\t                                                    // results and fewer JSON-RPC calls\n\t                                                    _a.sent();\n\t                                                    this.getTransactionCount(replaceable.from).then(function (nonce) { return __awaiter(_this, void 0, void 0, function () {\n\t                                                        var mined, block, ti, tx, receipt_1, reason;\n\t                                                        return __generator(this, function (_a) {\n\t                                                            switch (_a.label) {\n\t                                                                case 0:\n\t                                                                    if (done) {\n\t                                                                        return [2 /*return*/];\n\t                                                                    }\n\t                                                                    if (!(nonce <= replaceable.nonce)) return [3 /*break*/, 1];\n\t                                                                    lastBlockNumber_1 = blockNumber;\n\t                                                                    return [3 /*break*/, 9];\n\t                                                                case 1: return [4 /*yield*/, this.getTransaction(transactionHash)];\n\t                                                                case 2:\n\t                                                                    mined = _a.sent();\n\t                                                                    if (mined && mined.blockNumber != null) {\n\t                                                                        return [2 /*return*/];\n\t                                                                    }\n\t                                                                    // First time scanning. We start a little earlier for some\n\t                                                                    // wiggle room here to handle the eventually consistent nature\n\t                                                                    // of blockchain (e.g. the getTransactionCount was for a\n\t                                                                    // different block)\n\t                                                                    if (scannedBlock_1 == null) {\n\t                                                                        scannedBlock_1 = lastBlockNumber_1 - 3;\n\t                                                                        if (scannedBlock_1 < replaceable.startBlock) {\n\t                                                                            scannedBlock_1 = replaceable.startBlock;\n\t                                                                        }\n\t                                                                    }\n\t                                                                    _a.label = 3;\n\t                                                                case 3:\n\t                                                                    if (!(scannedBlock_1 <= blockNumber)) return [3 /*break*/, 9];\n\t                                                                    if (done) {\n\t                                                                        return [2 /*return*/];\n\t                                                                    }\n\t                                                                    return [4 /*yield*/, this.getBlockWithTransactions(scannedBlock_1)];\n\t                                                                case 4:\n\t                                                                    block = _a.sent();\n\t                                                                    ti = 0;\n\t                                                                    _a.label = 5;\n\t                                                                case 5:\n\t                                                                    if (!(ti < block.transactions.length)) return [3 /*break*/, 8];\n\t                                                                    tx = block.transactions[ti];\n\t                                                                    // Successfully mined!\n\t                                                                    if (tx.hash === transactionHash) {\n\t                                                                        return [2 /*return*/];\n\t                                                                    }\n\t                                                                    if (!(tx.from === replaceable.from && tx.nonce === replaceable.nonce)) return [3 /*break*/, 7];\n\t                                                                    if (done) {\n\t                                                                        return [2 /*return*/];\n\t                                                                    }\n\t                                                                    return [4 /*yield*/, this.waitForTransaction(tx.hash, confirmations)];\n\t                                                                case 6:\n\t                                                                    receipt_1 = _a.sent();\n\t                                                                    // Already resolved or rejected (prolly a timeout)\n\t                                                                    if (alreadyDone()) {\n\t                                                                        return [2 /*return*/];\n\t                                                                    }\n\t                                                                    reason = \"replaced\";\n\t                                                                    if (tx.data === replaceable.data && tx.to === replaceable.to && tx.value.eq(replaceable.value)) {\n\t                                                                        reason = \"repriced\";\n\t                                                                    }\n\t                                                                    else if (tx.data === \"0x\" && tx.from === tx.to && tx.value.isZero()) {\n\t                                                                        reason = \"cancelled\";\n\t                                                                    }\n\t                                                                    // Explain why we were replaced\n\t                                                                    reject(logger.makeError(\"transaction was replaced\", lib.Logger.errors.TRANSACTION_REPLACED, {\n\t                                                                        cancelled: (reason === \"replaced\" || reason === \"cancelled\"),\n\t                                                                        reason: reason,\n\t                                                                        replacement: this._wrapTransaction(tx),\n\t                                                                        hash: transactionHash,\n\t                                                                        receipt: receipt_1\n\t                                                                    }));\n\t                                                                    return [2 /*return*/];\n\t                                                                case 7:\n\t                                                                    ti++;\n\t                                                                    return [3 /*break*/, 5];\n\t                                                                case 8:\n\t                                                                    scannedBlock_1++;\n\t                                                                    return [3 /*break*/, 3];\n\t                                                                case 9:\n\t                                                                    if (done) {\n\t                                                                        return [2 /*return*/];\n\t                                                                    }\n\t                                                                    this.once(\"block\", replaceHandler_1);\n\t                                                                    return [2 /*return*/];\n\t                                                            }\n\t                                                        });\n\t                                                    }); }, function (error) {\n\t                                                        if (done) {\n\t                                                            return;\n\t                                                        }\n\t                                                        _this.once(\"block\", replaceHandler_1);\n\t                                                    });\n\t                                                    return [2 /*return*/];\n\t                                            }\n\t                                        });\n\t                                    }); };\n\t                                    if (done) {\n\t                                        return;\n\t                                    }\n\t                                    _this.once(\"block\", replaceHandler_1);\n\t                                    cancelFuncs.push(function () {\n\t                                        _this.removeListener(\"block\", replaceHandler_1);\n\t                                    });\n\t                                }\n\t                                if (typeof (timeout) === \"number\" && timeout > 0) {\n\t                                    var timer_1 = setTimeout(function () {\n\t                                        if (alreadyDone()) {\n\t                                            return;\n\t                                        }\n\t                                        reject(logger.makeError(\"timeout exceeded\", lib.Logger.errors.TIMEOUT, { timeout: timeout }));\n\t                                    }, timeout);\n\t                                    if (timer_1.unref) {\n\t                                        timer_1.unref();\n\t                                    }\n\t                                    cancelFuncs.push(function () { clearTimeout(timer_1); });\n\t                                }\n\t                            })];\n\t                }\n\t            });\n\t        });\n\t    };\n\t    BaseProvider.prototype.getBlockNumber = function () {\n\t        return __awaiter(this, void 0, void 0, function () {\n\t            return __generator(this, function (_a) {\n\t                return [2 /*return*/, this._getInternalBlockNumber(0)];\n\t            });\n\t        });\n\t    };\n\t    BaseProvider.prototype.getGasPrice = function () {\n\t        return __awaiter(this, void 0, void 0, function () {\n\t            var result;\n\t            return __generator(this, function (_a) {\n\t                switch (_a.label) {\n\t                    case 0: return [4 /*yield*/, this.getNetwork()];\n\t                    case 1:\n\t                        _a.sent();\n\t                        return [4 /*yield*/, this.perform(\"getGasPrice\", {})];\n\t                    case 2:\n\t                        result = _a.sent();\n\t                        try {\n\t                            return [2 /*return*/, lib$2.BigNumber.from(result)];\n\t                        }\n\t                        catch (error) {\n\t                            return [2 /*return*/, logger.throwError(\"bad result from backend\", lib.Logger.errors.SERVER_ERROR, {\n\t                                    method: \"getGasPrice\",\n\t                                    result: result,\n\t                                    error: error\n\t                                })];\n\t                        }\n\t                        return [2 /*return*/];\n\t                }\n\t            });\n\t        });\n\t    };\n\t    BaseProvider.prototype.getBalance = function (addressOrName, blockTag) {\n\t        return __awaiter(this, void 0, void 0, function () {\n\t            var params, result;\n\t            return __generator(this, function (_a) {\n\t                switch (_a.label) {\n\t                    case 0: return [4 /*yield*/, this.getNetwork()];\n\t                    case 1:\n\t                        _a.sent();\n\t                        return [4 /*yield*/, (0, lib$3.resolveProperties)({\n\t                                address: this._getAddress(addressOrName),\n\t                                blockTag: this._getBlockTag(blockTag)\n\t                            })];\n\t                    case 2:\n\t                        params = _a.sent();\n\t                        return [4 /*yield*/, this.perform(\"getBalance\", params)];\n\t                    case 3:\n\t                        result = _a.sent();\n\t                        try {\n\t                            return [2 /*return*/, lib$2.BigNumber.from(result)];\n\t                        }\n\t                        catch (error) {\n\t                            return [2 /*return*/, logger.throwError(\"bad result from backend\", lib.Logger.errors.SERVER_ERROR, {\n\t                                    method: \"getBalance\",\n\t                                    params: params,\n\t                                    result: result,\n\t                                    error: error\n\t                                })];\n\t                        }\n\t                        return [2 /*return*/];\n\t                }\n\t            });\n\t        });\n\t    };\n\t    BaseProvider.prototype.getTransactionCount = function (addressOrName, blockTag) {\n\t        return __awaiter(this, void 0, void 0, function () {\n\t            var params, result;\n\t            return __generator(this, function (_a) {\n\t                switch (_a.label) {\n\t                    case 0: return [4 /*yield*/, this.getNetwork()];\n\t                    case 1:\n\t                        _a.sent();\n\t                        return [4 /*yield*/, (0, lib$3.resolveProperties)({\n\t                                address: this._getAddress(addressOrName),\n\t                                blockTag: this._getBlockTag(blockTag)\n\t                            })];\n\t                    case 2:\n\t                        params = _a.sent();\n\t                        return [4 /*yield*/, this.perform(\"getTransactionCount\", params)];\n\t                    case 3:\n\t                        result = _a.sent();\n\t                        try {\n\t                            return [2 /*return*/, lib$2.BigNumber.from(result).toNumber()];\n\t                        }\n\t                        catch (error) {\n\t                            return [2 /*return*/, logger.throwError(\"bad result from backend\", lib.Logger.errors.SERVER_ERROR, {\n\t                                    method: \"getTransactionCount\",\n\t                                    params: params,\n\t                                    result: result,\n\t                                    error: error\n\t                                })];\n\t                        }\n\t                        return [2 /*return*/];\n\t                }\n\t            });\n\t        });\n\t    };\n\t    BaseProvider.prototype.getCode = function (addressOrName, blockTag) {\n\t        return __awaiter(this, void 0, void 0, function () {\n\t            var params, result;\n\t            return __generator(this, function (_a) {\n\t                switch (_a.label) {\n\t                    case 0: return [4 /*yield*/, this.getNetwork()];\n\t                    case 1:\n\t                        _a.sent();\n\t                        return [4 /*yield*/, (0, lib$3.resolveProperties)({\n\t                                address: this._getAddress(addressOrName),\n\t                                blockTag: this._getBlockTag(blockTag)\n\t                            })];\n\t                    case 2:\n\t                        params = _a.sent();\n\t                        return [4 /*yield*/, this.perform(\"getCode\", params)];\n\t                    case 3:\n\t                        result = _a.sent();\n\t                        try {\n\t                            return [2 /*return*/, (0, lib$1.hexlify)(result)];\n\t                        }\n\t                        catch (error) {\n\t                            return [2 /*return*/, logger.throwError(\"bad result from backend\", lib.Logger.errors.SERVER_ERROR, {\n\t                                    method: \"getCode\",\n\t                                    params: params,\n\t                                    result: result,\n\t                                    error: error\n\t                                })];\n\t                        }\n\t                        return [2 /*return*/];\n\t                }\n\t            });\n\t        });\n\t    };\n\t    BaseProvider.prototype.getStorageAt = function (addressOrName, position, blockTag) {\n\t        return __awaiter(this, void 0, void 0, function () {\n\t            var params, result;\n\t            return __generator(this, function (_a) {\n\t                switch (_a.label) {\n\t                    case 0: return [4 /*yield*/, this.getNetwork()];\n\t                    case 1:\n\t                        _a.sent();\n\t                        return [4 /*yield*/, (0, lib$3.resolveProperties)({\n\t                                address: this._getAddress(addressOrName),\n\t                                blockTag: this._getBlockTag(blockTag),\n\t                                position: Promise.resolve(position).then(function (p) { return (0, lib$1.hexValue)(p); })\n\t                            })];\n\t                    case 2:\n\t                        params = _a.sent();\n\t                        return [4 /*yield*/, this.perform(\"getStorageAt\", params)];\n\t                    case 3:\n\t                        result = _a.sent();\n\t                        try {\n\t                            return [2 /*return*/, (0, lib$1.hexlify)(result)];\n\t                        }\n\t                        catch (error) {\n\t                            return [2 /*return*/, logger.throwError(\"bad result from backend\", lib.Logger.errors.SERVER_ERROR, {\n\t                                    method: \"getStorageAt\",\n\t                                    params: params,\n\t                                    result: result,\n\t                                    error: error\n\t                                })];\n\t                        }\n\t                        return [2 /*return*/];\n\t                }\n\t            });\n\t        });\n\t    };\n\t    // This should be called by any subclass wrapping a TransactionResponse\n\t    BaseProvider.prototype._wrapTransaction = function (tx, hash, startBlock) {\n\t        var _this = this;\n\t        if (hash != null && (0, lib$1.hexDataLength)(hash) !== 32) {\n\t            throw new Error(\"invalid response - sendTransaction\");\n\t        }\n\t        var result = tx;\n\t        // Check the hash we expect is the same as the hash the server reported\n\t        if (hash != null && tx.hash !== hash) {\n\t            logger.throwError(\"Transaction hash mismatch from Provider.sendTransaction.\", lib.Logger.errors.UNKNOWN_ERROR, { expectedHash: tx.hash, returnedHash: hash });\n\t        }\n\t        result.wait = function (confirms, timeout) { return __awaiter(_this, void 0, void 0, function () {\n\t            var replacement, receipt;\n\t            return __generator(this, function (_a) {\n\t                switch (_a.label) {\n\t                    case 0:\n\t                        if (confirms == null) {\n\t                            confirms = 1;\n\t                        }\n\t                        if (timeout == null) {\n\t                            timeout = 0;\n\t                        }\n\t                        replacement = undefined;\n\t                        if (confirms !== 0 && startBlock != null) {\n\t                            replacement = {\n\t                                data: tx.data,\n\t                                from: tx.from,\n\t                                nonce: tx.nonce,\n\t                                to: tx.to,\n\t                                value: tx.value,\n\t                                startBlock: startBlock\n\t                            };\n\t                        }\n\t                        return [4 /*yield*/, this._waitForTransaction(tx.hash, confirms, timeout, replacement)];\n\t                    case 1:\n\t                        receipt = _a.sent();\n\t                        if (receipt == null && confirms === 0) {\n\t                            return [2 /*return*/, null];\n\t                        }\n\t                        // No longer pending, allow the polling loop to garbage collect this\n\t                        this._emitted[\"t:\" + tx.hash] = receipt.blockNumber;\n\t                        if (receipt.status === 0) {\n\t                            logger.throwError(\"transaction failed\", lib.Logger.errors.CALL_EXCEPTION, {\n\t                                transactionHash: tx.hash,\n\t                                transaction: tx,\n\t                                receipt: receipt\n\t                            });\n\t                        }\n\t                        return [2 /*return*/, receipt];\n\t                }\n\t            });\n\t        }); };\n\t        return result;\n\t    };\n\t    BaseProvider.prototype.sendTransaction = function (signedTransaction) {\n\t        return __awaiter(this, void 0, void 0, function () {\n\t            var hexTx, tx, blockNumber, hash, error_7;\n\t            return __generator(this, function (_a) {\n\t                switch (_a.label) {\n\t                    case 0: return [4 /*yield*/, this.getNetwork()];\n\t                    case 1:\n\t                        _a.sent();\n\t                        return [4 /*yield*/, Promise.resolve(signedTransaction).then(function (t) { return (0, lib$1.hexlify)(t); })];\n\t                    case 2:\n\t                        hexTx = _a.sent();\n\t                        tx = this.formatter.transaction(signedTransaction);\n\t                        if (tx.confirmations == null) {\n\t                            tx.confirmations = 0;\n\t                        }\n\t                        return [4 /*yield*/, this._getInternalBlockNumber(100 + 2 * this.pollingInterval)];\n\t                    case 3:\n\t                        blockNumber = _a.sent();\n\t                        _a.label = 4;\n\t                    case 4:\n\t                        _a.trys.push([4, 6, , 7]);\n\t                        return [4 /*yield*/, this.perform(\"sendTransaction\", { signedTransaction: hexTx })];\n\t                    case 5:\n\t                        hash = _a.sent();\n\t                        return [2 /*return*/, this._wrapTransaction(tx, hash, blockNumber)];\n\t                    case 6:\n\t                        error_7 = _a.sent();\n\t                        error_7.transaction = tx;\n\t                        error_7.transactionHash = tx.hash;\n\t                        throw error_7;\n\t                    case 7: return [2 /*return*/];\n\t                }\n\t            });\n\t        });\n\t    };\n\t    BaseProvider.prototype._getTransactionRequest = function (transaction) {\n\t        return __awaiter(this, void 0, void 0, function () {\n\t            var values, tx, _a, _b;\n\t            var _this = this;\n\t            return __generator(this, function (_c) {\n\t                switch (_c.label) {\n\t                    case 0: return [4 /*yield*/, transaction];\n\t                    case 1:\n\t                        values = _c.sent();\n\t                        tx = {};\n\t                        [\"from\", \"to\"].forEach(function (key) {\n\t                            if (values[key] == null) {\n\t                                return;\n\t                            }\n\t                            tx[key] = Promise.resolve(values[key]).then(function (v) { return (v ? _this._getAddress(v) : null); });\n\t                        });\n\t                        [\"gasLimit\", \"gasPrice\", \"maxFeePerGas\", \"maxPriorityFeePerGas\", \"value\"].forEach(function (key) {\n\t                            if (values[key] == null) {\n\t                                return;\n\t                            }\n\t                            tx[key] = Promise.resolve(values[key]).then(function (v) { return (v ? lib$2.BigNumber.from(v) : null); });\n\t                        });\n\t                        [\"type\"].forEach(function (key) {\n\t                            if (values[key] == null) {\n\t                                return;\n\t                            }\n\t                            tx[key] = Promise.resolve(values[key]).then(function (v) { return ((v != null) ? v : null); });\n\t                        });\n\t                        if (values.accessList) {\n\t                            tx.accessList = this.formatter.accessList(values.accessList);\n\t                        }\n\t                        [\"data\"].forEach(function (key) {\n\t                            if (values[key] == null) {\n\t                                return;\n\t                            }\n\t                            tx[key] = Promise.resolve(values[key]).then(function (v) { return (v ? (0, lib$1.hexlify)(v) : null); });\n\t                        });\n\t                        _b = (_a = this.formatter).transactionRequest;\n\t                        return [4 /*yield*/, (0, lib$3.resolveProperties)(tx)];\n\t                    case 2: return [2 /*return*/, _b.apply(_a, [_c.sent()])];\n\t                }\n\t            });\n\t        });\n\t    };\n\t    BaseProvider.prototype._getFilter = function (filter) {\n\t        return __awaiter(this, void 0, void 0, function () {\n\t            var result, _a, _b;\n\t            var _this = this;\n\t            return __generator(this, function (_c) {\n\t                switch (_c.label) {\n\t                    case 0: return [4 /*yield*/, filter];\n\t                    case 1:\n\t                        filter = _c.sent();\n\t                        result = {};\n\t                        if (filter.address != null) {\n\t                            result.address = this._getAddress(filter.address);\n\t                        }\n\t                        [\"blockHash\", \"topics\"].forEach(function (key) {\n\t                            if (filter[key] == null) {\n\t                                return;\n\t                            }\n\t                            result[key] = filter[key];\n\t                        });\n\t                        [\"fromBlock\", \"toBlock\"].forEach(function (key) {\n\t                            if (filter[key] == null) {\n\t                                return;\n\t                            }\n\t                            result[key] = _this._getBlockTag(filter[key]);\n\t                        });\n\t                        _b = (_a = this.formatter).filter;\n\t                        return [4 /*yield*/, (0, lib$3.resolveProperties)(result)];\n\t                    case 2: return [2 /*return*/, _b.apply(_a, [_c.sent()])];\n\t                }\n\t            });\n\t        });\n\t    };\n\t    BaseProvider.prototype.call = function (transaction, blockTag) {\n\t        return __awaiter(this, void 0, void 0, function () {\n\t            var params, result;\n\t            return __generator(this, function (_a) {\n\t                switch (_a.label) {\n\t                    case 0: return [4 /*yield*/, this.getNetwork()];\n\t                    case 1:\n\t                        _a.sent();\n\t                        return [4 /*yield*/, (0, lib$3.resolveProperties)({\n\t                                transaction: this._getTransactionRequest(transaction),\n\t                                blockTag: this._getBlockTag(blockTag)\n\t                            })];\n\t                    case 2:\n\t                        params = _a.sent();\n\t                        return [4 /*yield*/, this.perform(\"call\", params)];\n\t                    case 3:\n\t                        result = _a.sent();\n\t                        try {\n\t                            return [2 /*return*/, (0, lib$1.hexlify)(result)];\n\t                        }\n\t                        catch (error) {\n\t                            return [2 /*return*/, logger.throwError(\"bad result from backend\", lib.Logger.errors.SERVER_ERROR, {\n\t                                    method: \"call\",\n\t                                    params: params,\n\t                                    result: result,\n\t                                    error: error\n\t                                })];\n\t                        }\n\t                        return [2 /*return*/];\n\t                }\n\t            });\n\t        });\n\t    };\n\t    BaseProvider.prototype.estimateGas = function (transaction) {\n\t        return __awaiter(this, void 0, void 0, function () {\n\t            var params, result;\n\t            return __generator(this, function (_a) {\n\t                switch (_a.label) {\n\t                    case 0: return [4 /*yield*/, this.getNetwork()];\n\t                    case 1:\n\t                        _a.sent();\n\t                        return [4 /*yield*/, (0, lib$3.resolveProperties)({\n\t                                transaction: this._getTransactionRequest(transaction)\n\t                            })];\n\t                    case 2:\n\t                        params = _a.sent();\n\t                        return [4 /*yield*/, this.perform(\"estimateGas\", params)];\n\t                    case 3:\n\t                        result = _a.sent();\n\t                        try {\n\t                            return [2 /*return*/, lib$2.BigNumber.from(result)];\n\t                        }\n\t                        catch (error) {\n\t                            return [2 /*return*/, logger.throwError(\"bad result from backend\", lib.Logger.errors.SERVER_ERROR, {\n\t                                    method: \"estimateGas\",\n\t                                    params: params,\n\t                                    result: result,\n\t                                    error: error\n\t                                })];\n\t                        }\n\t                        return [2 /*return*/];\n\t                }\n\t            });\n\t        });\n\t    };\n\t    BaseProvider.prototype._getAddress = function (addressOrName) {\n\t        return __awaiter(this, void 0, void 0, function () {\n\t            var address;\n\t            return __generator(this, function (_a) {\n\t                switch (_a.label) {\n\t                    case 0: return [4 /*yield*/, addressOrName];\n\t                    case 1:\n\t                        addressOrName = _a.sent();\n\t                        if (typeof (addressOrName) !== \"string\") {\n\t                            logger.throwArgumentError(\"invalid address or ENS name\", \"name\", addressOrName);\n\t                        }\n\t                        return [4 /*yield*/, this.resolveName(addressOrName)];\n\t                    case 2:\n\t                        address = _a.sent();\n\t                        if (address == null) {\n\t                            logger.throwError(\"ENS name not configured\", lib.Logger.errors.UNSUPPORTED_OPERATION, {\n\t                                operation: \"resolveName(\" + JSON.stringify(addressOrName) + \")\"\n\t                            });\n\t                        }\n\t                        return [2 /*return*/, address];\n\t                }\n\t            });\n\t        });\n\t    };\n\t    BaseProvider.prototype._getBlock = function (blockHashOrBlockTag, includeTransactions) {\n\t        return __awaiter(this, void 0, void 0, function () {\n\t            var blockNumber, params, _a, error_8;\n\t            var _this = this;\n\t            return __generator(this, function (_b) {\n\t                switch (_b.label) {\n\t                    case 0: return [4 /*yield*/, this.getNetwork()];\n\t                    case 1:\n\t                        _b.sent();\n\t                        return [4 /*yield*/, blockHashOrBlockTag];\n\t                    case 2:\n\t                        blockHashOrBlockTag = _b.sent();\n\t                        blockNumber = -128;\n\t                        params = {\n\t                            includeTransactions: !!includeTransactions\n\t                        };\n\t                        if (!(0, lib$1.isHexString)(blockHashOrBlockTag, 32)) return [3 /*break*/, 3];\n\t                        params.blockHash = blockHashOrBlockTag;\n\t                        return [3 /*break*/, 6];\n\t                    case 3:\n\t                        _b.trys.push([3, 5, , 6]);\n\t                        _a = params;\n\t                        return [4 /*yield*/, this._getBlockTag(blockHashOrBlockTag)];\n\t                    case 4:\n\t                        _a.blockTag = _b.sent();\n\t                        if ((0, lib$1.isHexString)(params.blockTag)) {\n\t                            blockNumber = parseInt(params.blockTag.substring(2), 16);\n\t                        }\n\t                        return [3 /*break*/, 6];\n\t                    case 5:\n\t                        error_8 = _b.sent();\n\t                        logger.throwArgumentError(\"invalid block hash or block tag\", \"blockHashOrBlockTag\", blockHashOrBlockTag);\n\t                        return [3 /*break*/, 6];\n\t                    case 6: return [2 /*return*/, (0, lib$q.poll)(function () { return __awaiter(_this, void 0, void 0, function () {\n\t                            var block, blockNumber_1, i, tx, confirmations, blockWithTxs;\n\t                            var _this = this;\n\t                            return __generator(this, function (_a) {\n\t                                switch (_a.label) {\n\t                                    case 0: return [4 /*yield*/, this.perform(\"getBlock\", params)];\n\t                                    case 1:\n\t                                        block = _a.sent();\n\t                                        // Block was not found\n\t                                        if (block == null) {\n\t                                            // For blockhashes, if we didn't say it existed, that blockhash may\n\t                                            // not exist. If we did see it though, perhaps from a log, we know\n\t                                            // it exists, and this node is just not caught up yet.\n\t                                            if (params.blockHash != null) {\n\t                                                if (this._emitted[\"b:\" + params.blockHash] == null) {\n\t                                                    return [2 /*return*/, null];\n\t                                                }\n\t                                            }\n\t                                            // For block tags, if we are asking for a future block, we return null\n\t                                            if (params.blockTag != null) {\n\t                                                if (blockNumber > this._emitted.block) {\n\t                                                    return [2 /*return*/, null];\n\t                                                }\n\t                                            }\n\t                                            // Retry on the next block\n\t                                            return [2 /*return*/, undefined];\n\t                                        }\n\t                                        if (!includeTransactions) return [3 /*break*/, 8];\n\t                                        blockNumber_1 = null;\n\t                                        i = 0;\n\t                                        _a.label = 2;\n\t                                    case 2:\n\t                                        if (!(i < block.transactions.length)) return [3 /*break*/, 7];\n\t                                        tx = block.transactions[i];\n\t                                        if (!(tx.blockNumber == null)) return [3 /*break*/, 3];\n\t                                        tx.confirmations = 0;\n\t                                        return [3 /*break*/, 6];\n\t                                    case 3:\n\t                                        if (!(tx.confirmations == null)) return [3 /*break*/, 6];\n\t                                        if (!(blockNumber_1 == null)) return [3 /*break*/, 5];\n\t                                        return [4 /*yield*/, this._getInternalBlockNumber(100 + 2 * this.pollingInterval)];\n\t                                    case 4:\n\t                                        blockNumber_1 = _a.sent();\n\t                                        _a.label = 5;\n\t                                    case 5:\n\t                                        confirmations = (blockNumber_1 - tx.blockNumber) + 1;\n\t                                        if (confirmations <= 0) {\n\t                                            confirmations = 1;\n\t                                        }\n\t                                        tx.confirmations = confirmations;\n\t                                        _a.label = 6;\n\t                                    case 6:\n\t                                        i++;\n\t                                        return [3 /*break*/, 2];\n\t                                    case 7:\n\t                                        blockWithTxs = this.formatter.blockWithTransactions(block);\n\t                                        blockWithTxs.transactions = blockWithTxs.transactions.map(function (tx) { return _this._wrapTransaction(tx); });\n\t                                        return [2 /*return*/, blockWithTxs];\n\t                                    case 8: return [2 /*return*/, this.formatter.block(block)];\n\t                                }\n\t                            });\n\t                        }); }, { oncePoll: this })];\n\t                }\n\t            });\n\t        });\n\t    };\n\t    BaseProvider.prototype.getBlock = function (blockHashOrBlockTag) {\n\t        return (this._getBlock(blockHashOrBlockTag, false));\n\t    };\n\t    BaseProvider.prototype.getBlockWithTransactions = function (blockHashOrBlockTag) {\n\t        return (this._getBlock(blockHashOrBlockTag, true));\n\t    };\n\t    BaseProvider.prototype.getTransaction = function (transactionHash) {\n\t        return __awaiter(this, void 0, void 0, function () {\n\t            var params;\n\t            var _this = this;\n\t            return __generator(this, function (_a) {\n\t                switch (_a.label) {\n\t                    case 0: return [4 /*yield*/, this.getNetwork()];\n\t                    case 1:\n\t                        _a.sent();\n\t                        return [4 /*yield*/, transactionHash];\n\t                    case 2:\n\t                        transactionHash = _a.sent();\n\t                        params = { transactionHash: this.formatter.hash(transactionHash, true) };\n\t                        return [2 /*return*/, (0, lib$q.poll)(function () { return __awaiter(_this, void 0, void 0, function () {\n\t                                var result, tx, blockNumber, confirmations;\n\t                                return __generator(this, function (_a) {\n\t                                    switch (_a.label) {\n\t                                        case 0: return [4 /*yield*/, this.perform(\"getTransaction\", params)];\n\t                                        case 1:\n\t                                            result = _a.sent();\n\t                                            if (result == null) {\n\t                                                if (this._emitted[\"t:\" + transactionHash] == null) {\n\t                                                    return [2 /*return*/, null];\n\t                                                }\n\t                                                return [2 /*return*/, undefined];\n\t                                            }\n\t                                            tx = this.formatter.transactionResponse(result);\n\t                                            if (!(tx.blockNumber == null)) return [3 /*break*/, 2];\n\t                                            tx.confirmations = 0;\n\t                                            return [3 /*break*/, 4];\n\t                                        case 2:\n\t                                            if (!(tx.confirmations == null)) return [3 /*break*/, 4];\n\t                                            return [4 /*yield*/, this._getInternalBlockNumber(100 + 2 * this.pollingInterval)];\n\t                                        case 3:\n\t                                            blockNumber = _a.sent();\n\t                                            confirmations = (blockNumber - tx.blockNumber) + 1;\n\t                                            if (confirmations <= 0) {\n\t                                                confirmations = 1;\n\t                                            }\n\t                                            tx.confirmations = confirmations;\n\t                                            _a.label = 4;\n\t                                        case 4: return [2 /*return*/, this._wrapTransaction(tx)];\n\t                                    }\n\t                                });\n\t                            }); }, { oncePoll: this })];\n\t                }\n\t            });\n\t        });\n\t    };\n\t    BaseProvider.prototype.getTransactionReceipt = function (transactionHash) {\n\t        return __awaiter(this, void 0, void 0, function () {\n\t            var params;\n\t            var _this = this;\n\t            return __generator(this, function (_a) {\n\t                switch (_a.label) {\n\t                    case 0: return [4 /*yield*/, this.getNetwork()];\n\t                    case 1:\n\t                        _a.sent();\n\t                        return [4 /*yield*/, transactionHash];\n\t                    case 2:\n\t                        transactionHash = _a.sent();\n\t                        params = { transactionHash: this.formatter.hash(transactionHash, true) };\n\t                        return [2 /*return*/, (0, lib$q.poll)(function () { return __awaiter(_this, void 0, void 0, function () {\n\t                                var result, receipt, blockNumber, confirmations;\n\t                                return __generator(this, function (_a) {\n\t                                    switch (_a.label) {\n\t                                        case 0: return [4 /*yield*/, this.perform(\"getTransactionReceipt\", params)];\n\t                                        case 1:\n\t                                            result = _a.sent();\n\t                                            if (result == null) {\n\t                                                if (this._emitted[\"t:\" + transactionHash] == null) {\n\t                                                    return [2 /*return*/, null];\n\t                                                }\n\t                                                return [2 /*return*/, undefined];\n\t                                            }\n\t                                            // \"geth-etc\" returns receipts before they are ready\n\t                                            if (result.blockHash == null) {\n\t                                                return [2 /*return*/, undefined];\n\t                                            }\n\t                                            receipt = this.formatter.receipt(result);\n\t                                            if (!(receipt.blockNumber == null)) return [3 /*break*/, 2];\n\t                                            receipt.confirmations = 0;\n\t                                            return [3 /*break*/, 4];\n\t                                        case 2:\n\t                                            if (!(receipt.confirmations == null)) return [3 /*break*/, 4];\n\t                                            return [4 /*yield*/, this._getInternalBlockNumber(100 + 2 * this.pollingInterval)];\n\t                                        case 3:\n\t                                            blockNumber = _a.sent();\n\t                                            confirmations = (blockNumber - receipt.blockNumber) + 1;\n\t                                            if (confirmations <= 0) {\n\t                                                confirmations = 1;\n\t                                            }\n\t                                            receipt.confirmations = confirmations;\n\t                                            _a.label = 4;\n\t                                        case 4: return [2 /*return*/, receipt];\n\t                                    }\n\t                                });\n\t                            }); }, { oncePoll: this })];\n\t                }\n\t            });\n\t        });\n\t    };\n\t    BaseProvider.prototype.getLogs = function (filter) {\n\t        return __awaiter(this, void 0, void 0, function () {\n\t            var params, logs;\n\t            return __generator(this, function (_a) {\n\t                switch (_a.label) {\n\t                    case 0: return [4 /*yield*/, this.getNetwork()];\n\t                    case 1:\n\t                        _a.sent();\n\t                        return [4 /*yield*/, (0, lib$3.resolveProperties)({ filter: this._getFilter(filter) })];\n\t                    case 2:\n\t                        params = _a.sent();\n\t                        return [4 /*yield*/, this.perform(\"getLogs\", params)];\n\t                    case 3:\n\t                        logs = _a.sent();\n\t                        logs.forEach(function (log) {\n\t                            if (log.removed == null) {\n\t                                log.removed = false;\n\t                            }\n\t                        });\n\t                        return [2 /*return*/, formatter.Formatter.arrayOf(this.formatter.filterLog.bind(this.formatter))(logs)];\n\t                }\n\t            });\n\t        });\n\t    };\n\t    BaseProvider.prototype.getEtherPrice = function () {\n\t        return __awaiter(this, void 0, void 0, function () {\n\t            return __generator(this, function (_a) {\n\t                switch (_a.label) {\n\t                    case 0: return [4 /*yield*/, this.getNetwork()];\n\t                    case 1:\n\t                        _a.sent();\n\t                        return [2 /*return*/, this.perform(\"getEtherPrice\", {})];\n\t                }\n\t            });\n\t        });\n\t    };\n\t    BaseProvider.prototype._getBlockTag = function (blockTag) {\n\t        return __awaiter(this, void 0, void 0, function () {\n\t            var blockNumber;\n\t            return __generator(this, function (_a) {\n\t                switch (_a.label) {\n\t                    case 0: return [4 /*yield*/, blockTag];\n\t                    case 1:\n\t                        blockTag = _a.sent();\n\t                        if (!(typeof (blockTag) === \"number\" && blockTag < 0)) return [3 /*break*/, 3];\n\t                        if (blockTag % 1) {\n\t                            logger.throwArgumentError(\"invalid BlockTag\", \"blockTag\", blockTag);\n\t                        }\n\t                        return [4 /*yield*/, this._getInternalBlockNumber(100 + 2 * this.pollingInterval)];\n\t                    case 2:\n\t                        blockNumber = _a.sent();\n\t                        blockNumber += blockTag;\n\t                        if (blockNumber < 0) {\n\t                            blockNumber = 0;\n\t                        }\n\t                        return [2 /*return*/, this.formatter.blockTag(blockNumber)];\n\t                    case 3: return [2 /*return*/, this.formatter.blockTag(blockTag)];\n\t                }\n\t            });\n\t        });\n\t    };\n\t    BaseProvider.prototype.getResolver = function (name) {\n\t        return __awaiter(this, void 0, void 0, function () {\n\t            var address, error_9;\n\t            return __generator(this, function (_a) {\n\t                switch (_a.label) {\n\t                    case 0:\n\t                        _a.trys.push([0, 2, , 3]);\n\t                        return [4 /*yield*/, this._getResolver(name)];\n\t                    case 1:\n\t                        address = _a.sent();\n\t                        if (address == null) {\n\t                            return [2 /*return*/, null];\n\t                        }\n\t                        return [2 /*return*/, new Resolver(this, address, name)];\n\t                    case 2:\n\t                        error_9 = _a.sent();\n\t                        if (error_9.code === lib.Logger.errors.CALL_EXCEPTION) {\n\t                            return [2 /*return*/, null];\n\t                        }\n\t                        return [2 /*return*/, null];\n\t                    case 3: return [2 /*return*/];\n\t                }\n\t            });\n\t        });\n\t    };\n\t    BaseProvider.prototype._getResolver = function (name) {\n\t        return __awaiter(this, void 0, void 0, function () {\n\t            var network, transaction, _a, _b, error_10;\n\t            return __generator(this, function (_c) {\n\t                switch (_c.label) {\n\t                    case 0: return [4 /*yield*/, this.getNetwork()];\n\t                    case 1:\n\t                        network = _c.sent();\n\t                        // No ENS...\n\t                        if (!network.ensAddress) {\n\t                            logger.throwError(\"network does not support ENS\", lib.Logger.errors.UNSUPPORTED_OPERATION, { operation: \"ENS\", network: network.name });\n\t                        }\n\t                        transaction = {\n\t                            to: network.ensAddress,\n\t                            data: (\"0x0178b8bf\" + (0, lib$9.namehash)(name).substring(2))\n\t                        };\n\t                        _c.label = 2;\n\t                    case 2:\n\t                        _c.trys.push([2, 4, , 5]);\n\t                        _b = (_a = this.formatter).callAddress;\n\t                        return [4 /*yield*/, this.call(transaction)];\n\t                    case 3: return [2 /*return*/, _b.apply(_a, [_c.sent()])];\n\t                    case 4:\n\t                        error_10 = _c.sent();\n\t                        if (error_10.code === lib.Logger.errors.CALL_EXCEPTION) {\n\t                            return [2 /*return*/, null];\n\t                        }\n\t                        throw error_10;\n\t                    case 5: return [2 /*return*/];\n\t                }\n\t            });\n\t        });\n\t    };\n\t    BaseProvider.prototype.resolveName = function (name) {\n\t        return __awaiter(this, void 0, void 0, function () {\n\t            var resolver;\n\t            return __generator(this, function (_a) {\n\t                switch (_a.label) {\n\t                    case 0: return [4 /*yield*/, name];\n\t                    case 1:\n\t                        name = _a.sent();\n\t                        // If it is already an address, nothing to resolve\n\t                        try {\n\t                            return [2 /*return*/, Promise.resolve(this.formatter.address(name))];\n\t                        }\n\t                        catch (error) {\n\t                            // If is is a hexstring, the address is bad (See #694)\n\t                            if ((0, lib$1.isHexString)(name)) {\n\t                                throw error;\n\t                            }\n\t                        }\n\t                        if (typeof (name) !== \"string\") {\n\t                            logger.throwArgumentError(\"invalid ENS name\", \"name\", name);\n\t                        }\n\t                        return [4 /*yield*/, this.getResolver(name)];\n\t                    case 2:\n\t                        resolver = _a.sent();\n\t                        if (!resolver) {\n\t                            return [2 /*return*/, null];\n\t                        }\n\t                        return [4 /*yield*/, resolver.getAddress()];\n\t                    case 3: return [2 /*return*/, _a.sent()];\n\t                }\n\t            });\n\t        });\n\t    };\n\t    BaseProvider.prototype.lookupAddress = function (address) {\n\t        return __awaiter(this, void 0, void 0, function () {\n\t            var reverseName, resolverAddress, bytes, _a, length, name, addr;\n\t            return __generator(this, function (_b) {\n\t                switch (_b.label) {\n\t                    case 0: return [4 /*yield*/, address];\n\t                    case 1:\n\t                        address = _b.sent();\n\t                        address = this.formatter.address(address);\n\t                        reverseName = address.substring(2).toLowerCase() + \".addr.reverse\";\n\t                        return [4 /*yield*/, this._getResolver(reverseName)];\n\t                    case 2:\n\t                        resolverAddress = _b.sent();\n\t                        if (!resolverAddress) {\n\t                            return [2 /*return*/, null];\n\t                        }\n\t                        _a = lib$1.arrayify;\n\t                        return [4 /*yield*/, this.call({\n\t                                to: resolverAddress,\n\t                                data: (\"0x691f3431\" + (0, lib$9.namehash)(reverseName).substring(2))\n\t                            })];\n\t                    case 3:\n\t                        bytes = _a.apply(void 0, [_b.sent()]);\n\t                        // Strip off the dynamic string pointer (0x20)\n\t                        if (bytes.length < 32 || !lib$2.BigNumber.from(bytes.slice(0, 32)).eq(32)) {\n\t                            return [2 /*return*/, null];\n\t                        }\n\t                        bytes = bytes.slice(32);\n\t                        // Not a length-prefixed string\n\t                        if (bytes.length < 32) {\n\t                            return [2 /*return*/, null];\n\t                        }\n\t                        length = lib$2.BigNumber.from(bytes.slice(0, 32)).toNumber();\n\t                        bytes = bytes.slice(32);\n\t                        // Length longer than available data\n\t                        if (length > bytes.length) {\n\t                            return [2 /*return*/, null];\n\t                        }\n\t                        name = (0, lib$8.toUtf8String)(bytes.slice(0, length));\n\t                        return [4 /*yield*/, this.resolveName(name)];\n\t                    case 4:\n\t                        addr = _b.sent();\n\t                        if (addr != address) {\n\t                            return [2 /*return*/, null];\n\t                        }\n\t                        return [2 /*return*/, name];\n\t                }\n\t            });\n\t        });\n\t    };\n\t    BaseProvider.prototype.getAvatar = function (nameOrAddress) {\n\t        return __awaiter(this, void 0, void 0, function () {\n\t            var resolver, address, reverseName, resolverAddress, avatar;\n\t            return __generator(this, function (_a) {\n\t                switch (_a.label) {\n\t                    case 0:\n\t                        resolver = null;\n\t                        if (!(0, lib$1.isHexString)(nameOrAddress)) return [3 /*break*/, 2];\n\t                        address = this.formatter.address(nameOrAddress);\n\t                        reverseName = address.substring(2).toLowerCase() + \".addr.reverse\";\n\t                        return [4 /*yield*/, this._getResolver(reverseName)];\n\t                    case 1:\n\t                        resolverAddress = _a.sent();\n\t                        if (!resolverAddress) {\n\t                            return [2 /*return*/, null];\n\t                        }\n\t                        resolver = new Resolver(this, resolverAddress, \"_\", address);\n\t                        return [3 /*break*/, 4];\n\t                    case 2: return [4 /*yield*/, this.getResolver(nameOrAddress)];\n\t                    case 3:\n\t                        // ENS name; forward lookup\n\t                        resolver = _a.sent();\n\t                        _a.label = 4;\n\t                    case 4: return [4 /*yield*/, resolver.getAvatar()];\n\t                    case 5:\n\t                        avatar = _a.sent();\n\t                        if (avatar == null) {\n\t                            return [2 /*return*/, null];\n\t                        }\n\t                        return [2 /*return*/, avatar.url];\n\t                }\n\t            });\n\t        });\n\t    };\n\t    BaseProvider.prototype.perform = function (method, params) {\n\t        return logger.throwError(method + \" not implemented\", lib.Logger.errors.NOT_IMPLEMENTED, { operation: method });\n\t    };\n\t    BaseProvider.prototype._startEvent = function (event) {\n\t        this.polling = (this._events.filter(function (e) { return e.pollable(); }).length > 0);\n\t    };\n\t    BaseProvider.prototype._stopEvent = function (event) {\n\t        this.polling = (this._events.filter(function (e) { return e.pollable(); }).length > 0);\n\t    };\n\t    BaseProvider.prototype._addEventListener = function (eventName, listener, once) {\n\t        var event = new Event(getEventTag(eventName), listener, once);\n\t        this._events.push(event);\n\t        this._startEvent(event);\n\t        return this;\n\t    };\n\t    BaseProvider.prototype.on = function (eventName, listener) {\n\t        return this._addEventListener(eventName, listener, false);\n\t    };\n\t    BaseProvider.prototype.once = function (eventName, listener) {\n\t        return this._addEventListener(eventName, listener, true);\n\t    };\n\t    BaseProvider.prototype.emit = function (eventName) {\n\t        var _this = this;\n\t        var args = [];\n\t        for (var _i = 1; _i < arguments.length; _i++) {\n\t            args[_i - 1] = arguments[_i];\n\t        }\n\t        var result = false;\n\t        var stopped = [];\n\t        var eventTag = getEventTag(eventName);\n\t        this._events = this._events.filter(function (event) {\n\t            if (event.tag !== eventTag) {\n\t                return true;\n\t            }\n\t            setTimeout(function () {\n\t                event.listener.apply(_this, args);\n\t            }, 0);\n\t            result = true;\n\t            if (event.once) {\n\t                stopped.push(event);\n\t                return false;\n\t            }\n\t            return true;\n\t        });\n\t        stopped.forEach(function (event) { _this._stopEvent(event); });\n\t        return result;\n\t    };\n\t    BaseProvider.prototype.listenerCount = function (eventName) {\n\t        if (!eventName) {\n\t            return this._events.length;\n\t        }\n\t        var eventTag = getEventTag(eventName);\n\t        return this._events.filter(function (event) {\n\t            return (event.tag === eventTag);\n\t        }).length;\n\t    };\n\t    BaseProvider.prototype.listeners = function (eventName) {\n\t        if (eventName == null) {\n\t            return this._events.map(function (event) { return event.listener; });\n\t        }\n\t        var eventTag = getEventTag(eventName);\n\t        return this._events\n\t            .filter(function (event) { return (event.tag === eventTag); })\n\t            .map(function (event) { return event.listener; });\n\t    };\n\t    BaseProvider.prototype.off = function (eventName, listener) {\n\t        var _this = this;\n\t        if (listener == null) {\n\t            return this.removeAllListeners(eventName);\n\t        }\n\t        var stopped = [];\n\t        var found = false;\n\t        var eventTag = getEventTag(eventName);\n\t        this._events = this._events.filter(function (event) {\n\t            if (event.tag !== eventTag || event.listener != listener) {\n\t                return true;\n\t            }\n\t            if (found) {\n\t                return true;\n\t            }\n\t            found = true;\n\t            stopped.push(event);\n\t            return false;\n\t        });\n\t        stopped.forEach(function (event) { _this._stopEvent(event); });\n\t        return this;\n\t    };\n\t    BaseProvider.prototype.removeAllListeners = function (eventName) {\n\t        var _this = this;\n\t        var stopped = [];\n\t        if (eventName == null) {\n\t            stopped = this._events;\n\t            this._events = [];\n\t        }\n\t        else {\n\t            var eventTag_1 = getEventTag(eventName);\n\t            this._events = this._events.filter(function (event) {\n\t                if (event.tag !== eventTag_1) {\n\t                    return true;\n\t                }\n\t                stopped.push(event);\n\t                return false;\n\t            });\n\t        }\n\t        stopped.forEach(function (event) { _this._stopEvent(event); });\n\t        return this;\n\t    };\n\t    return BaseProvider;\n\t}(lib$b.Provider));\n\texports.BaseProvider = BaseProvider;\n\n\t});\n\n\tvar baseProvider$1 = /*@__PURE__*/getDefaultExportFromCjs(baseProvider);\n\n\tvar jsonRpcProvider = createCommonjsModule(function (module, exports) {\n\t\"use strict\";\n\tvar __extends = (commonjsGlobal && commonjsGlobal.__extends) || (function () {\n\t    var extendStatics = function (d, b) {\n\t        extendStatics = Object.setPrototypeOf ||\n\t            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n\t            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n\t        return extendStatics(d, b);\n\t    };\n\t    return function (d, b) {\n\t        if (typeof b !== \"function\" && b !== null)\n\t            throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n\t        extendStatics(d, b);\n\t        function __() { this.constructor = d; }\n\t        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n\t    };\n\t})();\n\tvar __awaiter = (commonjsGlobal && commonjsGlobal.__awaiter) || function (thisArg, _arguments, P, generator) {\n\t    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n\t    return new (P || (P = Promise))(function (resolve, reject) {\n\t        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n\t        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n\t        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n\t        step((generator = generator.apply(thisArg, _arguments || [])).next());\n\t    });\n\t};\n\tvar __generator = (commonjsGlobal && commonjsGlobal.__generator) || function (thisArg, body) {\n\t    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\n\t    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\n\t    function verb(n) { return function (v) { return step([n, v]); }; }\n\t    function step(op) {\n\t        if (f) throw new TypeError(\"Generator is already executing.\");\n\t        while (_) try {\n\t            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n\t            if (y = 0, t) op = [op[0] & 2, t.value];\n\t            switch (op[0]) {\n\t                case 0: case 1: t = op; break;\n\t                case 4: _.label++; return { value: op[1], done: false };\n\t                case 5: _.label++; y = op[1]; op = [0]; continue;\n\t                case 7: op = _.ops.pop(); _.trys.pop(); continue;\n\t                default:\n\t                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\n\t                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\n\t                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\n\t                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\n\t                    if (t[2]) _.ops.pop();\n\t                    _.trys.pop(); continue;\n\t            }\n\t            op = body.call(thisArg, _);\n\t        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\n\t        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\n\t    }\n\t};\n\tObject.defineProperty(exports, \"__esModule\", { value: true });\n\texports.JsonRpcProvider = exports.JsonRpcSigner = void 0;\n\n\n\n\n\n\n\n\n\n\n\tvar logger = new lib.Logger(_version$I.version);\n\n\tvar errorGas = [\"call\", \"estimateGas\"];\n\tfunction checkError(method, error, params) {\n\t    // Undo the \"convenience\" some nodes are attempting to prevent backwards\n\t    // incompatibility; maybe for v6 consider forwarding reverts as errors\n\t    if (method === \"call\" && error.code === lib.Logger.errors.SERVER_ERROR) {\n\t        var e = error.error;\n\t        if (e && e.message.match(\"reverted\") && (0, lib$1.isHexString)(e.data)) {\n\t            return e.data;\n\t        }\n\t        logger.throwError(\"missing revert data in call exception\", lib.Logger.errors.CALL_EXCEPTION, {\n\t            error: error,\n\t            data: \"0x\"\n\t        });\n\t    }\n\t    var message = error.message;\n\t    if (error.code === lib.Logger.errors.SERVER_ERROR && error.error && typeof (error.error.message) === \"string\") {\n\t        message = error.error.message;\n\t    }\n\t    else if (typeof (error.body) === \"string\") {\n\t        message = error.body;\n\t    }\n\t    else if (typeof (error.responseText) === \"string\") {\n\t        message = error.responseText;\n\t    }\n\t    message = (message || \"\").toLowerCase();\n\t    var transaction = params.transaction || params.signedTransaction;\n\t    // \"insufficient funds for gas * price + value + cost(data)\"\n\t    if (message.match(/insufficient funds|base fee exceeds gas limit/)) {\n\t        logger.throwError(\"insufficient funds for intrinsic transaction cost\", lib.Logger.errors.INSUFFICIENT_FUNDS, {\n\t            error: error,\n\t            method: method,\n\t            transaction: transaction\n\t        });\n\t    }\n\t    // \"nonce too low\"\n\t    if (message.match(/nonce too low/)) {\n\t        logger.throwError(\"nonce has already been used\", lib.Logger.errors.NONCE_EXPIRED, {\n\t            error: error,\n\t            method: method,\n\t            transaction: transaction\n\t        });\n\t    }\n\t    // \"replacement transaction underpriced\"\n\t    if (message.match(/replacement transaction underpriced/)) {\n\t        logger.throwError(\"replacement fee too low\", lib.Logger.errors.REPLACEMENT_UNDERPRICED, {\n\t            error: error,\n\t            method: method,\n\t            transaction: transaction\n\t        });\n\t    }\n\t    // \"replacement transaction underpriced\"\n\t    if (message.match(/only replay-protected/)) {\n\t        logger.throwError(\"legacy pre-eip-155 transactions not supported\", lib.Logger.errors.UNSUPPORTED_OPERATION, {\n\t            error: error,\n\t            method: method,\n\t            transaction: transaction\n\t        });\n\t    }\n\t    if (errorGas.indexOf(method) >= 0 && message.match(/gas required exceeds allowance|always failing transaction|execution reverted/)) {\n\t        logger.throwError(\"cannot estimate gas; transaction may fail or may require manual gas limit\", lib.Logger.errors.UNPREDICTABLE_GAS_LIMIT, {\n\t            error: error,\n\t            method: method,\n\t            transaction: transaction\n\t        });\n\t    }\n\t    throw error;\n\t}\n\tfunction timer(timeout) {\n\t    return new Promise(function (resolve) {\n\t        setTimeout(resolve, timeout);\n\t    });\n\t}\n\tfunction getResult(payload) {\n\t    if (payload.error) {\n\t        // @TODO: not any\n\t        var error = new Error(payload.error.message);\n\t        error.code = payload.error.code;\n\t        error.data = payload.error.data;\n\t        throw error;\n\t    }\n\t    return payload.result;\n\t}\n\tfunction getLowerCase(value) {\n\t    if (value) {\n\t        return value.toLowerCase();\n\t    }\n\t    return value;\n\t}\n\tvar _constructorGuard = {};\n\tvar JsonRpcSigner = /** @class */ (function (_super) {\n\t    __extends(JsonRpcSigner, _super);\n\t    function JsonRpcSigner(constructorGuard, provider, addressOrIndex) {\n\t        var _newTarget = this.constructor;\n\t        var _this = this;\n\t        logger.checkNew(_newTarget, JsonRpcSigner);\n\t        _this = _super.call(this) || this;\n\t        if (constructorGuard !== _constructorGuard) {\n\t            throw new Error(\"do not call the JsonRpcSigner constructor directly; use provider.getSigner\");\n\t        }\n\t        (0, lib$3.defineReadOnly)(_this, \"provider\", provider);\n\t        if (addressOrIndex == null) {\n\t            addressOrIndex = 0;\n\t        }\n\t        if (typeof (addressOrIndex) === \"string\") {\n\t            (0, lib$3.defineReadOnly)(_this, \"_address\", _this.provider.formatter.address(addressOrIndex));\n\t            (0, lib$3.defineReadOnly)(_this, \"_index\", null);\n\t        }\n\t        else if (typeof (addressOrIndex) === \"number\") {\n\t            (0, lib$3.defineReadOnly)(_this, \"_index\", addressOrIndex);\n\t            (0, lib$3.defineReadOnly)(_this, \"_address\", null);\n\t        }\n\t        else {\n\t            logger.throwArgumentError(\"invalid address or index\", \"addressOrIndex\", addressOrIndex);\n\t        }\n\t        return _this;\n\t    }\n\t    JsonRpcSigner.prototype.connect = function (provider) {\n\t        return logger.throwError(\"cannot alter JSON-RPC Signer connection\", lib.Logger.errors.UNSUPPORTED_OPERATION, {\n\t            operation: \"connect\"\n\t        });\n\t    };\n\t    JsonRpcSigner.prototype.connectUnchecked = function () {\n\t        return new UncheckedJsonRpcSigner(_constructorGuard, this.provider, this._address || this._index);\n\t    };\n\t    JsonRpcSigner.prototype.getAddress = function () {\n\t        var _this = this;\n\t        if (this._address) {\n\t            return Promise.resolve(this._address);\n\t        }\n\t        return this.provider.send(\"eth_accounts\", []).then(function (accounts) {\n\t            if (accounts.length <= _this._index) {\n\t                logger.throwError(\"unknown account #\" + _this._index, lib.Logger.errors.UNSUPPORTED_OPERATION, {\n\t                    operation: \"getAddress\"\n\t                });\n\t            }\n\t            return _this.provider.formatter.address(accounts[_this._index]);\n\t        });\n\t    };\n\t    JsonRpcSigner.prototype.sendUncheckedTransaction = function (transaction) {\n\t        var _this = this;\n\t        transaction = (0, lib$3.shallowCopy)(transaction);\n\t        var fromAddress = this.getAddress().then(function (address) {\n\t            if (address) {\n\t                address = address.toLowerCase();\n\t            }\n\t            return address;\n\t        });\n\t        // The JSON-RPC for eth_sendTransaction uses 90000 gas; if the user\n\t        // wishes to use this, it is easy to specify explicitly, otherwise\n\t        // we look it up for them.\n\t        if (transaction.gasLimit == null) {\n\t            var estimate = (0, lib$3.shallowCopy)(transaction);\n\t            estimate.from = fromAddress;\n\t            transaction.gasLimit = this.provider.estimateGas(estimate);\n\t        }\n\t        if (transaction.to != null) {\n\t            transaction.to = Promise.resolve(transaction.to).then(function (to) { return __awaiter(_this, void 0, void 0, function () {\n\t                var address;\n\t                return __generator(this, function (_a) {\n\t                    switch (_a.label) {\n\t                        case 0:\n\t                            if (to == null) {\n\t                                return [2 /*return*/, null];\n\t                            }\n\t                            return [4 /*yield*/, this.provider.resolveName(to)];\n\t                        case 1:\n\t                            address = _a.sent();\n\t                            if (address == null) {\n\t                                logger.throwArgumentError(\"provided ENS name resolves to null\", \"tx.to\", to);\n\t                            }\n\t                            return [2 /*return*/, address];\n\t                    }\n\t                });\n\t            }); });\n\t        }\n\t        return (0, lib$3.resolveProperties)({\n\t            tx: (0, lib$3.resolveProperties)(transaction),\n\t            sender: fromAddress\n\t        }).then(function (_a) {\n\t            var tx = _a.tx, sender = _a.sender;\n\t            if (tx.from != null) {\n\t                if (tx.from.toLowerCase() !== sender) {\n\t                    logger.throwArgumentError(\"from address mismatch\", \"transaction\", transaction);\n\t                }\n\t            }\n\t            else {\n\t                tx.from = sender;\n\t            }\n\t            var hexTx = _this.provider.constructor.hexlifyTransaction(tx, { from: true });\n\t            return _this.provider.send(\"eth_sendTransaction\", [hexTx]).then(function (hash) {\n\t                return hash;\n\t            }, function (error) {\n\t                return checkError(\"sendTransaction\", error, hexTx);\n\t            });\n\t        });\n\t    };\n\t    JsonRpcSigner.prototype.signTransaction = function (transaction) {\n\t        return logger.throwError(\"signing transactions is unsupported\", lib.Logger.errors.UNSUPPORTED_OPERATION, {\n\t            operation: \"signTransaction\"\n\t        });\n\t    };\n\t    JsonRpcSigner.prototype.sendTransaction = function (transaction) {\n\t        return __awaiter(this, void 0, void 0, function () {\n\t            var blockNumber, hash, error_1;\n\t            var _this = this;\n\t            return __generator(this, function (_a) {\n\t                switch (_a.label) {\n\t                    case 0: return [4 /*yield*/, this.provider._getInternalBlockNumber(100 + 2 * this.provider.pollingInterval)];\n\t                    case 1:\n\t                        blockNumber = _a.sent();\n\t                        return [4 /*yield*/, this.sendUncheckedTransaction(transaction)];\n\t                    case 2:\n\t                        hash = _a.sent();\n\t                        _a.label = 3;\n\t                    case 3:\n\t                        _a.trys.push([3, 5, , 6]);\n\t                        return [4 /*yield*/, (0, lib$q.poll)(function () { return __awaiter(_this, void 0, void 0, function () {\n\t                                var tx;\n\t                                return __generator(this, function (_a) {\n\t                                    switch (_a.label) {\n\t                                        case 0: return [4 /*yield*/, this.provider.getTransaction(hash)];\n\t                                        case 1:\n\t                                            tx = _a.sent();\n\t                                            if (tx === null) {\n\t                                                return [2 /*return*/, undefined];\n\t                                            }\n\t                                            return [2 /*return*/, this.provider._wrapTransaction(tx, hash, blockNumber)];\n\t                                    }\n\t                                });\n\t                            }); }, { oncePoll: this.provider })];\n\t                    case 4: \n\t                    // Unfortunately, JSON-RPC only provides and opaque transaction hash\n\t                    // for a response, and we need the actual transaction, so we poll\n\t                    // for it; it should show up very quickly\n\t                    return [2 /*return*/, _a.sent()];\n\t                    case 5:\n\t                        error_1 = _a.sent();\n\t                        error_1.transactionHash = hash;\n\t                        throw error_1;\n\t                    case 6: return [2 /*return*/];\n\t                }\n\t            });\n\t        });\n\t    };\n\t    JsonRpcSigner.prototype.signMessage = function (message) {\n\t        return __awaiter(this, void 0, void 0, function () {\n\t            var data, address;\n\t            return __generator(this, function (_a) {\n\t                switch (_a.label) {\n\t                    case 0:\n\t                        data = ((typeof (message) === \"string\") ? (0, lib$8.toUtf8Bytes)(message) : message);\n\t                        return [4 /*yield*/, this.getAddress()];\n\t                    case 1:\n\t                        address = _a.sent();\n\t                        return [4 /*yield*/, this.provider.send(\"personal_sign\", [(0, lib$1.hexlify)(data), address.toLowerCase()])];\n\t                    case 2: return [2 /*return*/, _a.sent()];\n\t                }\n\t            });\n\t        });\n\t    };\n\t    JsonRpcSigner.prototype._legacySignMessage = function (message) {\n\t        return __awaiter(this, void 0, void 0, function () {\n\t            var data, address;\n\t            return __generator(this, function (_a) {\n\t                switch (_a.label) {\n\t                    case 0:\n\t                        data = ((typeof (message) === \"string\") ? (0, lib$8.toUtf8Bytes)(message) : message);\n\t                        return [4 /*yield*/, this.getAddress()];\n\t                    case 1:\n\t                        address = _a.sent();\n\t                        return [4 /*yield*/, this.provider.send(\"eth_sign\", [address.toLowerCase(), (0, lib$1.hexlify)(data)])];\n\t                    case 2: \n\t                    // https://github.com/ethereum/wiki/wiki/JSON-RPC#eth_sign\n\t                    return [2 /*return*/, _a.sent()];\n\t                }\n\t            });\n\t        });\n\t    };\n\t    JsonRpcSigner.prototype._signTypedData = function (domain, types, value) {\n\t        return __awaiter(this, void 0, void 0, function () {\n\t            var populated, address;\n\t            var _this = this;\n\t            return __generator(this, function (_a) {\n\t                switch (_a.label) {\n\t                    case 0: return [4 /*yield*/, lib$9._TypedDataEncoder.resolveNames(domain, types, value, function (name) {\n\t                            return _this.provider.resolveName(name);\n\t                        })];\n\t                    case 1:\n\t                        populated = _a.sent();\n\t                        return [4 /*yield*/, this.getAddress()];\n\t                    case 2:\n\t                        address = _a.sent();\n\t                        return [4 /*yield*/, this.provider.send(\"eth_signTypedData_v4\", [\n\t                                address.toLowerCase(),\n\t                                JSON.stringify(lib$9._TypedDataEncoder.getPayload(populated.domain, types, populated.value))\n\t                            ])];\n\t                    case 3: return [2 /*return*/, _a.sent()];\n\t                }\n\t            });\n\t        });\n\t    };\n\t    JsonRpcSigner.prototype.unlock = function (password) {\n\t        return __awaiter(this, void 0, void 0, function () {\n\t            var provider, address;\n\t            return __generator(this, function (_a) {\n\t                switch (_a.label) {\n\t                    case 0:\n\t                        provider = this.provider;\n\t                        return [4 /*yield*/, this.getAddress()];\n\t                    case 1:\n\t                        address = _a.sent();\n\t                        return [2 /*return*/, provider.send(\"personal_unlockAccount\", [address.toLowerCase(), password, null])];\n\t                }\n\t            });\n\t        });\n\t    };\n\t    return JsonRpcSigner;\n\t}(lib$c.Signer));\n\texports.JsonRpcSigner = JsonRpcSigner;\n\tvar UncheckedJsonRpcSigner = /** @class */ (function (_super) {\n\t    __extends(UncheckedJsonRpcSigner, _super);\n\t    function UncheckedJsonRpcSigner() {\n\t        return _super !== null && _super.apply(this, arguments) || this;\n\t    }\n\t    UncheckedJsonRpcSigner.prototype.sendTransaction = function (transaction) {\n\t        var _this = this;\n\t        return this.sendUncheckedTransaction(transaction).then(function (hash) {\n\t            return {\n\t                hash: hash,\n\t                nonce: null,\n\t                gasLimit: null,\n\t                gasPrice: null,\n\t                data: null,\n\t                value: null,\n\t                chainId: null,\n\t                confirmations: 0,\n\t                from: null,\n\t                wait: function (confirmations) { return _this.provider.waitForTransaction(hash, confirmations); }\n\t            };\n\t        });\n\t    };\n\t    return UncheckedJsonRpcSigner;\n\t}(JsonRpcSigner));\n\tvar allowedTransactionKeys = {\n\t    chainId: true, data: true, gasLimit: true, gasPrice: true, nonce: true, to: true, value: true,\n\t    type: true, accessList: true,\n\t    maxFeePerGas: true, maxPriorityFeePerGas: true\n\t};\n\tvar JsonRpcProvider = /** @class */ (function (_super) {\n\t    __extends(JsonRpcProvider, _super);\n\t    function JsonRpcProvider(url, network) {\n\t        var _newTarget = this.constructor;\n\t        var _this = this;\n\t        logger.checkNew(_newTarget, JsonRpcProvider);\n\t        var networkOrReady = network;\n\t        // The network is unknown, query the JSON-RPC for it\n\t        if (networkOrReady == null) {\n\t            networkOrReady = new Promise(function (resolve, reject) {\n\t                setTimeout(function () {\n\t                    _this.detectNetwork().then(function (network) {\n\t                        resolve(network);\n\t                    }, function (error) {\n\t                        reject(error);\n\t                    });\n\t                }, 0);\n\t            });\n\t        }\n\t        _this = _super.call(this, networkOrReady) || this;\n\t        // Default URL\n\t        if (!url) {\n\t            url = (0, lib$3.getStatic)(_this.constructor, \"defaultUrl\")();\n\t        }\n\t        if (typeof (url) === \"string\") {\n\t            (0, lib$3.defineReadOnly)(_this, \"connection\", Object.freeze({\n\t                url: url\n\t            }));\n\t        }\n\t        else {\n\t            (0, lib$3.defineReadOnly)(_this, \"connection\", Object.freeze((0, lib$3.shallowCopy)(url)));\n\t        }\n\t        _this._nextId = 42;\n\t        return _this;\n\t    }\n\t    Object.defineProperty(JsonRpcProvider.prototype, \"_cache\", {\n\t        get: function () {\n\t            if (this._eventLoopCache == null) {\n\t                this._eventLoopCache = {};\n\t            }\n\t            return this._eventLoopCache;\n\t        },\n\t        enumerable: false,\n\t        configurable: true\n\t    });\n\t    JsonRpcProvider.defaultUrl = function () {\n\t        return \"http:/\\/localhost:8545\";\n\t    };\n\t    JsonRpcProvider.prototype.detectNetwork = function () {\n\t        var _this = this;\n\t        if (!this._cache[\"detectNetwork\"]) {\n\t            this._cache[\"detectNetwork\"] = this._uncachedDetectNetwork();\n\t            // Clear this cache at the beginning of the next event loop\n\t            setTimeout(function () {\n\t                _this._cache[\"detectNetwork\"] = null;\n\t            }, 0);\n\t        }\n\t        return this._cache[\"detectNetwork\"];\n\t    };\n\t    JsonRpcProvider.prototype._uncachedDetectNetwork = function () {\n\t        return __awaiter(this, void 0, void 0, function () {\n\t            var chainId, error_2, error_3, getNetwork;\n\t            return __generator(this, function (_a) {\n\t                switch (_a.label) {\n\t                    case 0: return [4 /*yield*/, timer(0)];\n\t                    case 1:\n\t                        _a.sent();\n\t                        chainId = null;\n\t                        _a.label = 2;\n\t                    case 2:\n\t                        _a.trys.push([2, 4, , 9]);\n\t                        return [4 /*yield*/, this.send(\"eth_chainId\", [])];\n\t                    case 3:\n\t                        chainId = _a.sent();\n\t                        return [3 /*break*/, 9];\n\t                    case 4:\n\t                        error_2 = _a.sent();\n\t                        _a.label = 5;\n\t                    case 5:\n\t                        _a.trys.push([5, 7, , 8]);\n\t                        return [4 /*yield*/, this.send(\"net_version\", [])];\n\t                    case 6:\n\t                        chainId = _a.sent();\n\t                        return [3 /*break*/, 8];\n\t                    case 7:\n\t                        error_3 = _a.sent();\n\t                        return [3 /*break*/, 8];\n\t                    case 8: return [3 /*break*/, 9];\n\t                    case 9:\n\t                        if (chainId != null) {\n\t                            getNetwork = (0, lib$3.getStatic)(this.constructor, \"getNetwork\");\n\t                            try {\n\t                                return [2 /*return*/, getNetwork(lib$2.BigNumber.from(chainId).toNumber())];\n\t                            }\n\t                            catch (error) {\n\t                                return [2 /*return*/, logger.throwError(\"could not detect network\", lib.Logger.errors.NETWORK_ERROR, {\n\t                                        chainId: chainId,\n\t                                        event: \"invalidNetwork\",\n\t                                        serverError: error\n\t                                    })];\n\t                            }\n\t                        }\n\t                        return [2 /*return*/, logger.throwError(\"could not detect network\", lib.Logger.errors.NETWORK_ERROR, {\n\t                                event: \"noNetwork\"\n\t                            })];\n\t                }\n\t            });\n\t        });\n\t    };\n\t    JsonRpcProvider.prototype.getSigner = function (addressOrIndex) {\n\t        return new JsonRpcSigner(_constructorGuard, this, addressOrIndex);\n\t    };\n\t    JsonRpcProvider.prototype.getUncheckedSigner = function (addressOrIndex) {\n\t        return this.getSigner(addressOrIndex).connectUnchecked();\n\t    };\n\t    JsonRpcProvider.prototype.listAccounts = function () {\n\t        var _this = this;\n\t        return this.send(\"eth_accounts\", []).then(function (accounts) {\n\t            return accounts.map(function (a) { return _this.formatter.address(a); });\n\t        });\n\t    };\n\t    JsonRpcProvider.prototype.send = function (method, params) {\n\t        var _this = this;\n\t        var request = {\n\t            method: method,\n\t            params: params,\n\t            id: (this._nextId++),\n\t            jsonrpc: \"2.0\"\n\t        };\n\t        this.emit(\"debug\", {\n\t            action: \"request\",\n\t            request: (0, lib$3.deepCopy)(request),\n\t            provider: this\n\t        });\n\t        // We can expand this in the future to any call, but for now these\n\t        // are the biggest wins and do not require any serializing parameters.\n\t        var cache = ([\"eth_chainId\", \"eth_blockNumber\"].indexOf(method) >= 0);\n\t        if (cache && this._cache[method]) {\n\t            return this._cache[method];\n\t        }\n\t        var result = (0, lib$q.fetchJson)(this.connection, JSON.stringify(request), getResult).then(function (result) {\n\t            _this.emit(\"debug\", {\n\t                action: \"response\",\n\t                request: request,\n\t                response: result,\n\t                provider: _this\n\t            });\n\t            return result;\n\t        }, function (error) {\n\t            _this.emit(\"debug\", {\n\t                action: \"response\",\n\t                error: error,\n\t                request: request,\n\t                provider: _this\n\t            });\n\t            throw error;\n\t        });\n\t        // Cache the fetch, but clear it on the next event loop\n\t        if (cache) {\n\t            this._cache[method] = result;\n\t            setTimeout(function () {\n\t                _this._cache[method] = null;\n\t            }, 0);\n\t        }\n\t        return result;\n\t    };\n\t    JsonRpcProvider.prototype.prepareRequest = function (method, params) {\n\t        switch (method) {\n\t            case \"getBlockNumber\":\n\t                return [\"eth_blockNumber\", []];\n\t            case \"getGasPrice\":\n\t                return [\"eth_gasPrice\", []];\n\t            case \"getBalance\":\n\t                return [\"eth_getBalance\", [getLowerCase(params.address), params.blockTag]];\n\t            case \"getTransactionCount\":\n\t                return [\"eth_getTransactionCount\", [getLowerCase(params.address), params.blockTag]];\n\t            case \"getCode\":\n\t                return [\"eth_getCode\", [getLowerCase(params.address), params.blockTag]];\n\t            case \"getStorageAt\":\n\t                return [\"eth_getStorageAt\", [getLowerCase(params.address), params.position, params.blockTag]];\n\t            case \"sendTransaction\":\n\t                return [\"eth_sendRawTransaction\", [params.signedTransaction]];\n\t            case \"getBlock\":\n\t                if (params.blockTag) {\n\t                    return [\"eth_getBlockByNumber\", [params.blockTag, !!params.includeTransactions]];\n\t                }\n\t                else if (params.blockHash) {\n\t                    return [\"eth_getBlockByHash\", [params.blockHash, !!params.includeTransactions]];\n\t                }\n\t                return null;\n\t            case \"getTransaction\":\n\t                return [\"eth_getTransactionByHash\", [params.transactionHash]];\n\t            case \"getTransactionReceipt\":\n\t                return [\"eth_getTransactionReceipt\", [params.transactionHash]];\n\t            case \"call\": {\n\t                var hexlifyTransaction = (0, lib$3.getStatic)(this.constructor, \"hexlifyTransaction\");\n\t                return [\"eth_call\", [hexlifyTransaction(params.transaction, { from: true }), params.blockTag]];\n\t            }\n\t            case \"estimateGas\": {\n\t                var hexlifyTransaction = (0, lib$3.getStatic)(this.constructor, \"hexlifyTransaction\");\n\t                return [\"eth_estimateGas\", [hexlifyTransaction(params.transaction, { from: true })]];\n\t            }\n\t            case \"getLogs\":\n\t                if (params.filter && params.filter.address != null) {\n\t                    params.filter.address = getLowerCase(params.filter.address);\n\t                }\n\t                return [\"eth_getLogs\", [params.filter]];\n\t            default:\n\t                break;\n\t        }\n\t        return null;\n\t    };\n\t    JsonRpcProvider.prototype.perform = function (method, params) {\n\t        return __awaiter(this, void 0, void 0, function () {\n\t            var tx, feeData, args, error_4;\n\t            return __generator(this, function (_a) {\n\t                switch (_a.label) {\n\t                    case 0:\n\t                        if (!(method === \"call\" || method === \"estimateGas\")) return [3 /*break*/, 2];\n\t                        tx = params.transaction;\n\t                        if (!(tx && tx.type != null && lib$2.BigNumber.from(tx.type).isZero())) return [3 /*break*/, 2];\n\t                        if (!(tx.maxFeePerGas == null && tx.maxPriorityFeePerGas == null)) return [3 /*break*/, 2];\n\t                        return [4 /*yield*/, this.getFeeData()];\n\t                    case 1:\n\t                        feeData = _a.sent();\n\t                        if (feeData.maxFeePerGas == null && feeData.maxPriorityFeePerGas == null) {\n\t                            // Network doesn't know about EIP-1559 (and hence type)\n\t                            params = (0, lib$3.shallowCopy)(params);\n\t                            params.transaction = (0, lib$3.shallowCopy)(tx);\n\t                            delete params.transaction.type;\n\t                        }\n\t                        _a.label = 2;\n\t                    case 2:\n\t                        args = this.prepareRequest(method, params);\n\t                        if (args == null) {\n\t                            logger.throwError(method + \" not implemented\", lib.Logger.errors.NOT_IMPLEMENTED, { operation: method });\n\t                        }\n\t                        _a.label = 3;\n\t                    case 3:\n\t                        _a.trys.push([3, 5, , 6]);\n\t                        return [4 /*yield*/, this.send(args[0], args[1])];\n\t                    case 4: return [2 /*return*/, _a.sent()];\n\t                    case 5:\n\t                        error_4 = _a.sent();\n\t                        return [2 /*return*/, checkError(method, error_4, params)];\n\t                    case 6: return [2 /*return*/];\n\t                }\n\t            });\n\t        });\n\t    };\n\t    JsonRpcProvider.prototype._startEvent = function (event) {\n\t        if (event.tag === \"pending\") {\n\t            this._startPending();\n\t        }\n\t        _super.prototype._startEvent.call(this, event);\n\t    };\n\t    JsonRpcProvider.prototype._startPending = function () {\n\t        if (this._pendingFilter != null) {\n\t            return;\n\t        }\n\t        var self = this;\n\t        var pendingFilter = this.send(\"eth_newPendingTransactionFilter\", []);\n\t        this._pendingFilter = pendingFilter;\n\t        pendingFilter.then(function (filterId) {\n\t            function poll() {\n\t                self.send(\"eth_getFilterChanges\", [filterId]).then(function (hashes) {\n\t                    if (self._pendingFilter != pendingFilter) {\n\t                        return null;\n\t                    }\n\t                    var seq = Promise.resolve();\n\t                    hashes.forEach(function (hash) {\n\t                        // @TODO: This should be garbage collected at some point... How? When?\n\t                        self._emitted[\"t:\" + hash.toLowerCase()] = \"pending\";\n\t                        seq = seq.then(function () {\n\t                            return self.getTransaction(hash).then(function (tx) {\n\t                                self.emit(\"pending\", tx);\n\t                                return null;\n\t                            });\n\t                        });\n\t                    });\n\t                    return seq.then(function () {\n\t                        return timer(1000);\n\t                    });\n\t                }).then(function () {\n\t                    if (self._pendingFilter != pendingFilter) {\n\t                        self.send(\"eth_uninstallFilter\", [filterId]);\n\t                        return;\n\t                    }\n\t                    setTimeout(function () { poll(); }, 0);\n\t                    return null;\n\t                }).catch(function (error) { });\n\t            }\n\t            poll();\n\t            return filterId;\n\t        }).catch(function (error) { });\n\t    };\n\t    JsonRpcProvider.prototype._stopEvent = function (event) {\n\t        if (event.tag === \"pending\" && this.listenerCount(\"pending\") === 0) {\n\t            this._pendingFilter = null;\n\t        }\n\t        _super.prototype._stopEvent.call(this, event);\n\t    };\n\t    // Convert an ethers.js transaction into a JSON-RPC transaction\n\t    //  - gasLimit => gas\n\t    //  - All values hexlified\n\t    //  - All numeric values zero-striped\n\t    //  - All addresses are lowercased\n\t    // NOTE: This allows a TransactionRequest, but all values should be resolved\n\t    //       before this is called\n\t    // @TODO: This will likely be removed in future versions and prepareRequest\n\t    //        will be the preferred method for this.\n\t    JsonRpcProvider.hexlifyTransaction = function (transaction, allowExtra) {\n\t        // Check only allowed properties are given\n\t        var allowed = (0, lib$3.shallowCopy)(allowedTransactionKeys);\n\t        if (allowExtra) {\n\t            for (var key in allowExtra) {\n\t                if (allowExtra[key]) {\n\t                    allowed[key] = true;\n\t                }\n\t            }\n\t        }\n\t        (0, lib$3.checkProperties)(transaction, allowed);\n\t        var result = {};\n\t        // Some nodes (INFURA ropsten; INFURA mainnet is fine) do not like leading zeros.\n\t        [\"gasLimit\", \"gasPrice\", \"type\", \"maxFeePerGas\", \"maxPriorityFeePerGas\", \"nonce\", \"value\"].forEach(function (key) {\n\t            if (transaction[key] == null) {\n\t                return;\n\t            }\n\t            var value = (0, lib$1.hexValue)(transaction[key]);\n\t            if (key === \"gasLimit\") {\n\t                key = \"gas\";\n\t            }\n\t            result[key] = value;\n\t        });\n\t        [\"from\", \"to\", \"data\"].forEach(function (key) {\n\t            if (transaction[key] == null) {\n\t                return;\n\t            }\n\t            result[key] = (0, lib$1.hexlify)(transaction[key]);\n\t        });\n\t        if (transaction.accessList) {\n\t            result[\"accessList\"] = (0, lib$e.accessListify)(transaction.accessList);\n\t        }\n\t        return result;\n\t    };\n\t    return JsonRpcProvider;\n\t}(baseProvider.BaseProvider));\n\texports.JsonRpcProvider = JsonRpcProvider;\n\n\t});\n\n\tvar jsonRpcProvider$1 = /*@__PURE__*/getDefaultExportFromCjs(jsonRpcProvider);\n\n\tvar browserWs = createCommonjsModule(function (module, exports) {\n\t\"use strict\";\n\tObject.defineProperty(exports, \"__esModule\", { value: true });\n\texports.WebSocket = void 0;\n\n\n\tvar WS = null;\n\texports.WebSocket = WS;\n\ttry {\n\t    exports.WebSocket = WS = WebSocket;\n\t    if (WS == null) {\n\t        throw new Error(\"inject please\");\n\t    }\n\t}\n\tcatch (error) {\n\t    var logger_2 = new lib.Logger(_version$I.version);\n\t    exports.WebSocket = WS = function () {\n\t        logger_2.throwError(\"WebSockets not supported in this environment\", lib.Logger.errors.UNSUPPORTED_OPERATION, {\n\t            operation: \"new WebSocket()\"\n\t        });\n\t    };\n\t}\n\n\t});\n\n\tvar browserWs$1 = /*@__PURE__*/getDefaultExportFromCjs(browserWs);\n\n\tvar websocketProvider = createCommonjsModule(function (module, exports) {\n\t\"use strict\";\n\tvar __extends = (commonjsGlobal && commonjsGlobal.__extends) || (function () {\n\t    var extendStatics = function (d, b) {\n\t        extendStatics = Object.setPrototypeOf ||\n\t            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n\t            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n\t        return extendStatics(d, b);\n\t    };\n\t    return function (d, b) {\n\t        if (typeof b !== \"function\" && b !== null)\n\t            throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n\t        extendStatics(d, b);\n\t        function __() { this.constructor = d; }\n\t        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n\t    };\n\t})();\n\tvar __awaiter = (commonjsGlobal && commonjsGlobal.__awaiter) || function (thisArg, _arguments, P, generator) {\n\t    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n\t    return new (P || (P = Promise))(function (resolve, reject) {\n\t        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n\t        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n\t        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n\t        step((generator = generator.apply(thisArg, _arguments || [])).next());\n\t    });\n\t};\n\tvar __generator = (commonjsGlobal && commonjsGlobal.__generator) || function (thisArg, body) {\n\t    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\n\t    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\n\t    function verb(n) { return function (v) { return step([n, v]); }; }\n\t    function step(op) {\n\t        if (f) throw new TypeError(\"Generator is already executing.\");\n\t        while (_) try {\n\t            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n\t            if (y = 0, t) op = [op[0] & 2, t.value];\n\t            switch (op[0]) {\n\t                case 0: case 1: t = op; break;\n\t                case 4: _.label++; return { value: op[1], done: false };\n\t                case 5: _.label++; y = op[1]; op = [0]; continue;\n\t                case 7: op = _.ops.pop(); _.trys.pop(); continue;\n\t                default:\n\t                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\n\t                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\n\t                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\n\t                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\n\t                    if (t[2]) _.ops.pop();\n\t                    _.trys.pop(); continue;\n\t            }\n\t            op = body.call(thisArg, _);\n\t        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\n\t        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\n\t    }\n\t};\n\tObject.defineProperty(exports, \"__esModule\", { value: true });\n\texports.WebSocketProvider = void 0;\n\n\n\n\n\n\n\tvar logger = new lib.Logger(_version$I.version);\n\t/**\n\t *  Notes:\n\t *\n\t *  This provider differs a bit from the polling providers. One main\n\t *  difference is how it handles consistency. The polling providers\n\t *  will stall responses to ensure a consistent state, while this\n\t *  WebSocket provider assumes the connected backend will manage this.\n\t *\n\t *  For example, if a polling provider emits an event which indicates\n\t *  the event occurred in blockhash XXX, a call to fetch that block by\n\t *  its hash XXX, if not present will retry until it is present. This\n\t *  can occur when querying a pool of nodes that are mildly out of sync\n\t *  with each other.\n\t */\n\tvar NextId = 1;\n\t// For more info about the Real-time Event API see:\n\t//   https://geth.ethereum.org/docs/rpc/pubsub\n\tvar WebSocketProvider = /** @class */ (function (_super) {\n\t    __extends(WebSocketProvider, _super);\n\t    function WebSocketProvider(url, network) {\n\t        var _this = this;\n\t        // This will be added in the future; please open an issue to expedite\n\t        if (network === \"any\") {\n\t            logger.throwError(\"WebSocketProvider does not support 'any' network yet\", lib.Logger.errors.UNSUPPORTED_OPERATION, {\n\t                operation: \"network:any\"\n\t            });\n\t        }\n\t        _this = _super.call(this, url, network) || this;\n\t        _this._pollingInterval = -1;\n\t        _this._wsReady = false;\n\t        (0, lib$3.defineReadOnly)(_this, \"_websocket\", new browserWs.WebSocket(_this.connection.url));\n\t        (0, lib$3.defineReadOnly)(_this, \"_requests\", {});\n\t        (0, lib$3.defineReadOnly)(_this, \"_subs\", {});\n\t        (0, lib$3.defineReadOnly)(_this, \"_subIds\", {});\n\t        (0, lib$3.defineReadOnly)(_this, \"_detectNetwork\", _super.prototype.detectNetwork.call(_this));\n\t        // Stall sending requests until the socket is open...\n\t        _this._websocket.onopen = function () {\n\t            _this._wsReady = true;\n\t            Object.keys(_this._requests).forEach(function (id) {\n\t                _this._websocket.send(_this._requests[id].payload);\n\t            });\n\t        };\n\t        _this._websocket.onmessage = function (messageEvent) {\n\t            var data = messageEvent.data;\n\t            var result = JSON.parse(data);\n\t            if (result.id != null) {\n\t                var id = String(result.id);\n\t                var request = _this._requests[id];\n\t                delete _this._requests[id];\n\t                if (result.result !== undefined) {\n\t                    request.callback(null, result.result);\n\t                    _this.emit(\"debug\", {\n\t                        action: \"response\",\n\t                        request: JSON.parse(request.payload),\n\t                        response: result.result,\n\t                        provider: _this\n\t                    });\n\t                }\n\t                else {\n\t                    var error = null;\n\t                    if (result.error) {\n\t                        error = new Error(result.error.message || \"unknown error\");\n\t                        (0, lib$3.defineReadOnly)(error, \"code\", result.error.code || null);\n\t                        (0, lib$3.defineReadOnly)(error, \"response\", data);\n\t                    }\n\t                    else {\n\t                        error = new Error(\"unknown error\");\n\t                    }\n\t                    request.callback(error, undefined);\n\t                    _this.emit(\"debug\", {\n\t                        action: \"response\",\n\t                        error: error,\n\t                        request: JSON.parse(request.payload),\n\t                        provider: _this\n\t                    });\n\t                }\n\t            }\n\t            else if (result.method === \"eth_subscription\") {\n\t                // Subscription...\n\t                var sub = _this._subs[result.params.subscription];\n\t                if (sub) {\n\t                    //this.emit.apply(this,                  );\n\t                    sub.processFunc(result.params.result);\n\t                }\n\t            }\n\t            else {\n\t                console.warn(\"this should not happen\");\n\t            }\n\t        };\n\t        // This Provider does not actually poll, but we want to trigger\n\t        // poll events for things that depend on them (like stalling for\n\t        // block and transaction lookups)\n\t        var fauxPoll = setInterval(function () {\n\t            _this.emit(\"poll\");\n\t        }, 1000);\n\t        if (fauxPoll.unref) {\n\t            fauxPoll.unref();\n\t        }\n\t        return _this;\n\t    }\n\t    WebSocketProvider.prototype.detectNetwork = function () {\n\t        return this._detectNetwork;\n\t    };\n\t    Object.defineProperty(WebSocketProvider.prototype, \"pollingInterval\", {\n\t        get: function () {\n\t            return 0;\n\t        },\n\t        set: function (value) {\n\t            logger.throwError(\"cannot set polling interval on WebSocketProvider\", lib.Logger.errors.UNSUPPORTED_OPERATION, {\n\t                operation: \"setPollingInterval\"\n\t            });\n\t        },\n\t        enumerable: false,\n\t        configurable: true\n\t    });\n\t    WebSocketProvider.prototype.resetEventsBlock = function (blockNumber) {\n\t        logger.throwError(\"cannot reset events block on WebSocketProvider\", lib.Logger.errors.UNSUPPORTED_OPERATION, {\n\t            operation: \"resetEventBlock\"\n\t        });\n\t    };\n\t    WebSocketProvider.prototype.poll = function () {\n\t        return __awaiter(this, void 0, void 0, function () {\n\t            return __generator(this, function (_a) {\n\t                return [2 /*return*/, null];\n\t            });\n\t        });\n\t    };\n\t    Object.defineProperty(WebSocketProvider.prototype, \"polling\", {\n\t        set: function (value) {\n\t            if (!value) {\n\t                return;\n\t            }\n\t            logger.throwError(\"cannot set polling on WebSocketProvider\", lib.Logger.errors.UNSUPPORTED_OPERATION, {\n\t                operation: \"setPolling\"\n\t            });\n\t        },\n\t        enumerable: false,\n\t        configurable: true\n\t    });\n\t    WebSocketProvider.prototype.send = function (method, params) {\n\t        var _this = this;\n\t        var rid = NextId++;\n\t        return new Promise(function (resolve, reject) {\n\t            function callback(error, result) {\n\t                if (error) {\n\t                    return reject(error);\n\t                }\n\t                return resolve(result);\n\t            }\n\t            var payload = JSON.stringify({\n\t                method: method,\n\t                params: params,\n\t                id: rid,\n\t                jsonrpc: \"2.0\"\n\t            });\n\t            _this.emit(\"debug\", {\n\t                action: \"request\",\n\t                request: JSON.parse(payload),\n\t                provider: _this\n\t            });\n\t            _this._requests[String(rid)] = { callback: callback, payload: payload };\n\t            if (_this._wsReady) {\n\t                _this._websocket.send(payload);\n\t            }\n\t        });\n\t    };\n\t    WebSocketProvider.defaultUrl = function () {\n\t        return \"ws:/\\/localhost:8546\";\n\t    };\n\t    WebSocketProvider.prototype._subscribe = function (tag, param, processFunc) {\n\t        return __awaiter(this, void 0, void 0, function () {\n\t            var subIdPromise, subId;\n\t            var _this = this;\n\t            return __generator(this, function (_a) {\n\t                switch (_a.label) {\n\t                    case 0:\n\t                        subIdPromise = this._subIds[tag];\n\t                        if (subIdPromise == null) {\n\t                            subIdPromise = Promise.all(param).then(function (param) {\n\t                                return _this.send(\"eth_subscribe\", param);\n\t                            });\n\t                            this._subIds[tag] = subIdPromise;\n\t                        }\n\t                        return [4 /*yield*/, subIdPromise];\n\t                    case 1:\n\t                        subId = _a.sent();\n\t                        this._subs[subId] = { tag: tag, processFunc: processFunc };\n\t                        return [2 /*return*/];\n\t                }\n\t            });\n\t        });\n\t    };\n\t    WebSocketProvider.prototype._startEvent = function (event) {\n\t        var _this = this;\n\t        switch (event.type) {\n\t            case \"block\":\n\t                this._subscribe(\"block\", [\"newHeads\"], function (result) {\n\t                    var blockNumber = lib$2.BigNumber.from(result.number).toNumber();\n\t                    _this._emitted.block = blockNumber;\n\t                    _this.emit(\"block\", blockNumber);\n\t                });\n\t                break;\n\t            case \"pending\":\n\t                this._subscribe(\"pending\", [\"newPendingTransactions\"], function (result) {\n\t                    _this.emit(\"pending\", result);\n\t                });\n\t                break;\n\t            case \"filter\":\n\t                this._subscribe(event.tag, [\"logs\", this._getFilter(event.filter)], function (result) {\n\t                    if (result.removed == null) {\n\t                        result.removed = false;\n\t                    }\n\t                    _this.emit(event.filter, _this.formatter.filterLog(result));\n\t                });\n\t                break;\n\t            case \"tx\": {\n\t                var emitReceipt_1 = function (event) {\n\t                    var hash = event.hash;\n\t                    _this.getTransactionReceipt(hash).then(function (receipt) {\n\t                        if (!receipt) {\n\t                            return;\n\t                        }\n\t                        _this.emit(hash, receipt);\n\t                    });\n\t                };\n\t                // In case it is already mined\n\t                emitReceipt_1(event);\n\t                // To keep things simple, we start up a single newHeads subscription\n\t                // to keep an eye out for transactions we are watching for.\n\t                // Starting a subscription for an event (i.e. \"tx\") that is already\n\t                // running is (basically) a nop.\n\t                this._subscribe(\"tx\", [\"newHeads\"], function (result) {\n\t                    _this._events.filter(function (e) { return (e.type === \"tx\"); }).forEach(emitReceipt_1);\n\t                });\n\t                break;\n\t            }\n\t            // Nothing is needed\n\t            case \"debug\":\n\t            case \"poll\":\n\t            case \"willPoll\":\n\t            case \"didPoll\":\n\t            case \"error\":\n\t                break;\n\t            default:\n\t                console.log(\"unhandled:\", event);\n\t                break;\n\t        }\n\t    };\n\t    WebSocketProvider.prototype._stopEvent = function (event) {\n\t        var _this = this;\n\t        var tag = event.tag;\n\t        if (event.type === \"tx\") {\n\t            // There are remaining transaction event listeners\n\t            if (this._events.filter(function (e) { return (e.type === \"tx\"); }).length) {\n\t                return;\n\t            }\n\t            tag = \"tx\";\n\t        }\n\t        else if (this.listenerCount(event.event)) {\n\t            // There are remaining event listeners\n\t            return;\n\t        }\n\t        var subId = this._subIds[tag];\n\t        if (!subId) {\n\t            return;\n\t        }\n\t        delete this._subIds[tag];\n\t        subId.then(function (subId) {\n\t            if (!_this._subs[subId]) {\n\t                return;\n\t            }\n\t            delete _this._subs[subId];\n\t            _this.send(\"eth_unsubscribe\", [subId]);\n\t        });\n\t    };\n\t    WebSocketProvider.prototype.destroy = function () {\n\t        return __awaiter(this, void 0, void 0, function () {\n\t            var _this = this;\n\t            return __generator(this, function (_a) {\n\t                switch (_a.label) {\n\t                    case 0:\n\t                        if (!(this._websocket.readyState === browserWs.WebSocket.CONNECTING)) return [3 /*break*/, 2];\n\t                        return [4 /*yield*/, (new Promise(function (resolve) {\n\t                                _this._websocket.onopen = function () {\n\t                                    resolve(true);\n\t                                };\n\t                                _this._websocket.onerror = function () {\n\t                                    resolve(false);\n\t                                };\n\t                            }))];\n\t                    case 1:\n\t                        _a.sent();\n\t                        _a.label = 2;\n\t                    case 2:\n\t                        // Hangup\n\t                        // See: https://developer.mozilla.org/en-US/docs/Web/API/CloseEvent#Status_codes\n\t                        this._websocket.close(1000);\n\t                        return [2 /*return*/];\n\t                }\n\t            });\n\t        });\n\t    };\n\t    return WebSocketProvider;\n\t}(jsonRpcProvider.JsonRpcProvider));\n\texports.WebSocketProvider = WebSocketProvider;\n\n\t});\n\n\tvar websocketProvider$1 = /*@__PURE__*/getDefaultExportFromCjs(websocketProvider);\n\n\tvar urlJsonRpcProvider = createCommonjsModule(function (module, exports) {\n\t\"use strict\";\n\tvar __extends = (commonjsGlobal && commonjsGlobal.__extends) || (function () {\n\t    var extendStatics = function (d, b) {\n\t        extendStatics = Object.setPrototypeOf ||\n\t            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n\t            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n\t        return extendStatics(d, b);\n\t    };\n\t    return function (d, b) {\n\t        if (typeof b !== \"function\" && b !== null)\n\t            throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n\t        extendStatics(d, b);\n\t        function __() { this.constructor = d; }\n\t        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n\t    };\n\t})();\n\tvar __awaiter = (commonjsGlobal && commonjsGlobal.__awaiter) || function (thisArg, _arguments, P, generator) {\n\t    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n\t    return new (P || (P = Promise))(function (resolve, reject) {\n\t        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n\t        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n\t        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n\t        step((generator = generator.apply(thisArg, _arguments || [])).next());\n\t    });\n\t};\n\tvar __generator = (commonjsGlobal && commonjsGlobal.__generator) || function (thisArg, body) {\n\t    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\n\t    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\n\t    function verb(n) { return function (v) { return step([n, v]); }; }\n\t    function step(op) {\n\t        if (f) throw new TypeError(\"Generator is already executing.\");\n\t        while (_) try {\n\t            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n\t            if (y = 0, t) op = [op[0] & 2, t.value];\n\t            switch (op[0]) {\n\t                case 0: case 1: t = op; break;\n\t                case 4: _.label++; return { value: op[1], done: false };\n\t                case 5: _.label++; y = op[1]; op = [0]; continue;\n\t                case 7: op = _.ops.pop(); _.trys.pop(); continue;\n\t                default:\n\t                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\n\t                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\n\t                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\n\t                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\n\t                    if (t[2]) _.ops.pop();\n\t                    _.trys.pop(); continue;\n\t            }\n\t            op = body.call(thisArg, _);\n\t        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\n\t        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\n\t    }\n\t};\n\tObject.defineProperty(exports, \"__esModule\", { value: true });\n\texports.UrlJsonRpcProvider = exports.StaticJsonRpcProvider = void 0;\n\n\n\n\tvar logger = new lib.Logger(_version$I.version);\n\n\t// A StaticJsonRpcProvider is useful when you *know* for certain that\n\t// the backend will never change, as it never calls eth_chainId to\n\t// verify its backend. However, if the backend does change, the effects\n\t// are undefined and may include:\n\t// - inconsistent results\n\t// - locking up the UI\n\t// - block skew warnings\n\t// - wrong results\n\t// If the network is not explicit (i.e. auto-detection is expected), the\n\t// node MUST be running and available to respond to requests BEFORE this\n\t// is instantiated.\n\tvar StaticJsonRpcProvider = /** @class */ (function (_super) {\n\t    __extends(StaticJsonRpcProvider, _super);\n\t    function StaticJsonRpcProvider() {\n\t        return _super !== null && _super.apply(this, arguments) || this;\n\t    }\n\t    StaticJsonRpcProvider.prototype.detectNetwork = function () {\n\t        return __awaiter(this, void 0, void 0, function () {\n\t            var network;\n\t            return __generator(this, function (_a) {\n\t                switch (_a.label) {\n\t                    case 0:\n\t                        network = this.network;\n\t                        if (!(network == null)) return [3 /*break*/, 2];\n\t                        return [4 /*yield*/, _super.prototype.detectNetwork.call(this)];\n\t                    case 1:\n\t                        network = _a.sent();\n\t                        if (!network) {\n\t                            logger.throwError(\"no network detected\", lib.Logger.errors.UNKNOWN_ERROR, {});\n\t                        }\n\t                        // If still not set, set it\n\t                        if (this._network == null) {\n\t                            // A static network does not support \"any\"\n\t                            (0, lib$3.defineReadOnly)(this, \"_network\", network);\n\t                            this.emit(\"network\", network, null);\n\t                        }\n\t                        _a.label = 2;\n\t                    case 2: return [2 /*return*/, network];\n\t                }\n\t            });\n\t        });\n\t    };\n\t    return StaticJsonRpcProvider;\n\t}(jsonRpcProvider.JsonRpcProvider));\n\texports.StaticJsonRpcProvider = StaticJsonRpcProvider;\n\tvar UrlJsonRpcProvider = /** @class */ (function (_super) {\n\t    __extends(UrlJsonRpcProvider, _super);\n\t    function UrlJsonRpcProvider(network, apiKey) {\n\t        var _newTarget = this.constructor;\n\t        var _this = this;\n\t        logger.checkAbstract(_newTarget, UrlJsonRpcProvider);\n\t        // Normalize the Network and API Key\n\t        network = (0, lib$3.getStatic)(_newTarget, \"getNetwork\")(network);\n\t        apiKey = (0, lib$3.getStatic)(_newTarget, \"getApiKey\")(apiKey);\n\t        var connection = (0, lib$3.getStatic)(_newTarget, \"getUrl\")(network, apiKey);\n\t        _this = _super.call(this, connection, network) || this;\n\t        if (typeof (apiKey) === \"string\") {\n\t            (0, lib$3.defineReadOnly)(_this, \"apiKey\", apiKey);\n\t        }\n\t        else if (apiKey != null) {\n\t            Object.keys(apiKey).forEach(function (key) {\n\t                (0, lib$3.defineReadOnly)(_this, key, apiKey[key]);\n\t            });\n\t        }\n\t        return _this;\n\t    }\n\t    UrlJsonRpcProvider.prototype._startPending = function () {\n\t        logger.warn(\"WARNING: API provider does not support pending filters\");\n\t    };\n\t    UrlJsonRpcProvider.prototype.isCommunityResource = function () {\n\t        return false;\n\t    };\n\t    UrlJsonRpcProvider.prototype.getSigner = function (address) {\n\t        return logger.throwError(\"API provider does not support signing\", lib.Logger.errors.UNSUPPORTED_OPERATION, { operation: \"getSigner\" });\n\t    };\n\t    UrlJsonRpcProvider.prototype.listAccounts = function () {\n\t        return Promise.resolve([]);\n\t    };\n\t    // Return a defaultApiKey if null, otherwise validate the API key\n\t    UrlJsonRpcProvider.getApiKey = function (apiKey) {\n\t        return apiKey;\n\t    };\n\t    // Returns the url or connection for the given network and API key. The\n\t    // API key will have been sanitized by the getApiKey first, so any validation\n\t    // or transformations can be done there.\n\t    UrlJsonRpcProvider.getUrl = function (network, apiKey) {\n\t        return logger.throwError(\"not implemented; sub-classes must override getUrl\", lib.Logger.errors.NOT_IMPLEMENTED, {\n\t            operation: \"getUrl\"\n\t        });\n\t    };\n\t    return UrlJsonRpcProvider;\n\t}(StaticJsonRpcProvider));\n\texports.UrlJsonRpcProvider = UrlJsonRpcProvider;\n\n\t});\n\n\tvar urlJsonRpcProvider$1 = /*@__PURE__*/getDefaultExportFromCjs(urlJsonRpcProvider);\n\n\tvar alchemyProvider = createCommonjsModule(function (module, exports) {\n\t\"use strict\";\n\tvar __extends = (commonjsGlobal && commonjsGlobal.__extends) || (function () {\n\t    var extendStatics = function (d, b) {\n\t        extendStatics = Object.setPrototypeOf ||\n\t            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n\t            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n\t        return extendStatics(d, b);\n\t    };\n\t    return function (d, b) {\n\t        if (typeof b !== \"function\" && b !== null)\n\t            throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n\t        extendStatics(d, b);\n\t        function __() { this.constructor = d; }\n\t        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n\t    };\n\t})();\n\tObject.defineProperty(exports, \"__esModule\", { value: true });\n\texports.AlchemyProvider = exports.AlchemyWebSocketProvider = void 0;\n\n\n\n\n\n\tvar logger = new lib.Logger(_version$I.version);\n\n\t// This key was provided to ethers.js by Alchemy to be used by the\n\t// default provider, but it is recommended that for your own\n\t// production environments, that you acquire your own API key at:\n\t//   https://dashboard.alchemyapi.io\n\tvar defaultApiKey = \"_gg7wSSi0KMBsdKnGVfHDueq6xMB9EkC\";\n\tvar AlchemyWebSocketProvider = /** @class */ (function (_super) {\n\t    __extends(AlchemyWebSocketProvider, _super);\n\t    function AlchemyWebSocketProvider(network, apiKey) {\n\t        var _this = this;\n\t        var provider = new AlchemyProvider(network, apiKey);\n\t        var url = provider.connection.url.replace(/^http/i, \"ws\")\n\t            .replace(\".alchemyapi.\", \".ws.alchemyapi.\");\n\t        _this = _super.call(this, url, provider.network) || this;\n\t        (0, lib$3.defineReadOnly)(_this, \"apiKey\", provider.apiKey);\n\t        return _this;\n\t    }\n\t    AlchemyWebSocketProvider.prototype.isCommunityResource = function () {\n\t        return (this.apiKey === defaultApiKey);\n\t    };\n\t    return AlchemyWebSocketProvider;\n\t}(websocketProvider.WebSocketProvider));\n\texports.AlchemyWebSocketProvider = AlchemyWebSocketProvider;\n\tvar AlchemyProvider = /** @class */ (function (_super) {\n\t    __extends(AlchemyProvider, _super);\n\t    function AlchemyProvider() {\n\t        return _super !== null && _super.apply(this, arguments) || this;\n\t    }\n\t    AlchemyProvider.getWebSocketProvider = function (network, apiKey) {\n\t        return new AlchemyWebSocketProvider(network, apiKey);\n\t    };\n\t    AlchemyProvider.getApiKey = function (apiKey) {\n\t        if (apiKey == null) {\n\t            return defaultApiKey;\n\t        }\n\t        if (apiKey && typeof (apiKey) !== \"string\") {\n\t            logger.throwArgumentError(\"invalid apiKey\", \"apiKey\", apiKey);\n\t        }\n\t        return apiKey;\n\t    };\n\t    AlchemyProvider.getUrl = function (network, apiKey) {\n\t        var host = null;\n\t        switch (network.name) {\n\t            case \"homestead\":\n\t                host = \"eth-mainnet.alchemyapi.io/v2/\";\n\t                break;\n\t            case \"ropsten\":\n\t                host = \"eth-ropsten.alchemyapi.io/v2/\";\n\t                break;\n\t            case \"rinkeby\":\n\t                host = \"eth-rinkeby.alchemyapi.io/v2/\";\n\t                break;\n\t            case \"goerli\":\n\t                host = \"eth-goerli.alchemyapi.io/v2/\";\n\t                break;\n\t            case \"kovan\":\n\t                host = \"eth-kovan.alchemyapi.io/v2/\";\n\t                break;\n\t            case \"matic\":\n\t                host = \"polygon-mainnet.g.alchemy.com/v2/\";\n\t                break;\n\t            case \"maticmum\":\n\t                host = \"polygon-mumbai.g.alchemy.com/v2/\";\n\t                break;\n\t            default:\n\t                logger.throwArgumentError(\"unsupported network\", \"network\", arguments[0]);\n\t        }\n\t        return {\n\t            allowGzip: true,\n\t            url: (\"https:/\" + \"/\" + host + apiKey),\n\t            throttleCallback: function (attempt, url) {\n\t                if (apiKey === defaultApiKey) {\n\t                    (0, formatter.showThrottleMessage)();\n\t                }\n\t                return Promise.resolve(true);\n\t            }\n\t        };\n\t    };\n\t    AlchemyProvider.prototype.isCommunityResource = function () {\n\t        return (this.apiKey === defaultApiKey);\n\t    };\n\t    return AlchemyProvider;\n\t}(urlJsonRpcProvider.UrlJsonRpcProvider));\n\texports.AlchemyProvider = AlchemyProvider;\n\n\t});\n\n\tvar alchemyProvider$1 = /*@__PURE__*/getDefaultExportFromCjs(alchemyProvider);\n\n\tvar cloudflareProvider = createCommonjsModule(function (module, exports) {\n\t\"use strict\";\n\tvar __extends = (commonjsGlobal && commonjsGlobal.__extends) || (function () {\n\t    var extendStatics = function (d, b) {\n\t        extendStatics = Object.setPrototypeOf ||\n\t            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n\t            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n\t        return extendStatics(d, b);\n\t    };\n\t    return function (d, b) {\n\t        if (typeof b !== \"function\" && b !== null)\n\t            throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n\t        extendStatics(d, b);\n\t        function __() { this.constructor = d; }\n\t        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n\t    };\n\t})();\n\tvar __awaiter = (commonjsGlobal && commonjsGlobal.__awaiter) || function (thisArg, _arguments, P, generator) {\n\t    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n\t    return new (P || (P = Promise))(function (resolve, reject) {\n\t        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n\t        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n\t        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n\t        step((generator = generator.apply(thisArg, _arguments || [])).next());\n\t    });\n\t};\n\tvar __generator = (commonjsGlobal && commonjsGlobal.__generator) || function (thisArg, body) {\n\t    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\n\t    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\n\t    function verb(n) { return function (v) { return step([n, v]); }; }\n\t    function step(op) {\n\t        if (f) throw new TypeError(\"Generator is already executing.\");\n\t        while (_) try {\n\t            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n\t            if (y = 0, t) op = [op[0] & 2, t.value];\n\t            switch (op[0]) {\n\t                case 0: case 1: t = op; break;\n\t                case 4: _.label++; return { value: op[1], done: false };\n\t                case 5: _.label++; y = op[1]; op = [0]; continue;\n\t                case 7: op = _.ops.pop(); _.trys.pop(); continue;\n\t                default:\n\t                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\n\t                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\n\t                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\n\t                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\n\t                    if (t[2]) _.ops.pop();\n\t                    _.trys.pop(); continue;\n\t            }\n\t            op = body.call(thisArg, _);\n\t        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\n\t        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\n\t    }\n\t};\n\tObject.defineProperty(exports, \"__esModule\", { value: true });\n\texports.CloudflareProvider = void 0;\n\n\n\n\tvar logger = new lib.Logger(_version$I.version);\n\tvar CloudflareProvider = /** @class */ (function (_super) {\n\t    __extends(CloudflareProvider, _super);\n\t    function CloudflareProvider() {\n\t        return _super !== null && _super.apply(this, arguments) || this;\n\t    }\n\t    CloudflareProvider.getApiKey = function (apiKey) {\n\t        if (apiKey != null) {\n\t            logger.throwArgumentError(\"apiKey not supported for cloudflare\", \"apiKey\", apiKey);\n\t        }\n\t        return null;\n\t    };\n\t    CloudflareProvider.getUrl = function (network, apiKey) {\n\t        var host = null;\n\t        switch (network.name) {\n\t            case \"homestead\":\n\t                host = \"https://cloudflare-eth.com/\";\n\t                break;\n\t            default:\n\t                logger.throwArgumentError(\"unsupported network\", \"network\", arguments[0]);\n\t        }\n\t        return host;\n\t    };\n\t    CloudflareProvider.prototype.perform = function (method, params) {\n\t        return __awaiter(this, void 0, void 0, function () {\n\t            var block;\n\t            return __generator(this, function (_a) {\n\t                switch (_a.label) {\n\t                    case 0:\n\t                        if (!(method === \"getBlockNumber\")) return [3 /*break*/, 2];\n\t                        return [4 /*yield*/, _super.prototype.perform.call(this, \"getBlock\", { blockTag: \"latest\" })];\n\t                    case 1:\n\t                        block = _a.sent();\n\t                        return [2 /*return*/, block.number];\n\t                    case 2: return [2 /*return*/, _super.prototype.perform.call(this, method, params)];\n\t                }\n\t            });\n\t        });\n\t    };\n\t    return CloudflareProvider;\n\t}(urlJsonRpcProvider.UrlJsonRpcProvider));\n\texports.CloudflareProvider = CloudflareProvider;\n\n\t});\n\n\tvar cloudflareProvider$1 = /*@__PURE__*/getDefaultExportFromCjs(cloudflareProvider);\n\n\tvar etherscanProvider = createCommonjsModule(function (module, exports) {\n\t\"use strict\";\n\tvar __extends = (commonjsGlobal && commonjsGlobal.__extends) || (function () {\n\t    var extendStatics = function (d, b) {\n\t        extendStatics = Object.setPrototypeOf ||\n\t            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n\t            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n\t        return extendStatics(d, b);\n\t    };\n\t    return function (d, b) {\n\t        if (typeof b !== \"function\" && b !== null)\n\t            throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n\t        extendStatics(d, b);\n\t        function __() { this.constructor = d; }\n\t        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n\t    };\n\t})();\n\tvar __awaiter = (commonjsGlobal && commonjsGlobal.__awaiter) || function (thisArg, _arguments, P, generator) {\n\t    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n\t    return new (P || (P = Promise))(function (resolve, reject) {\n\t        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n\t        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n\t        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n\t        step((generator = generator.apply(thisArg, _arguments || [])).next());\n\t    });\n\t};\n\tvar __generator = (commonjsGlobal && commonjsGlobal.__generator) || function (thisArg, body) {\n\t    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\n\t    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\n\t    function verb(n) { return function (v) { return step([n, v]); }; }\n\t    function step(op) {\n\t        if (f) throw new TypeError(\"Generator is already executing.\");\n\t        while (_) try {\n\t            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n\t            if (y = 0, t) op = [op[0] & 2, t.value];\n\t            switch (op[0]) {\n\t                case 0: case 1: t = op; break;\n\t                case 4: _.label++; return { value: op[1], done: false };\n\t                case 5: _.label++; y = op[1]; op = [0]; continue;\n\t                case 7: op = _.ops.pop(); _.trys.pop(); continue;\n\t                default:\n\t                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\n\t                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\n\t                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\n\t                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\n\t                    if (t[2]) _.ops.pop();\n\t                    _.trys.pop(); continue;\n\t            }\n\t            op = body.call(thisArg, _);\n\t        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\n\t        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\n\t    }\n\t};\n\tObject.defineProperty(exports, \"__esModule\", { value: true });\n\texports.EtherscanProvider = void 0;\n\n\n\n\n\n\n\n\tvar logger = new lib.Logger(_version$I.version);\n\n\t// The transaction has already been sanitized by the calls in Provider\n\tfunction getTransactionPostData(transaction) {\n\t    var result = {};\n\t    for (var key in transaction) {\n\t        if (transaction[key] == null) {\n\t            continue;\n\t        }\n\t        var value = transaction[key];\n\t        if (key === \"type\" && value === 0) {\n\t            continue;\n\t        }\n\t        // Quantity-types require no leading zero, unless 0\n\t        if ({ type: true, gasLimit: true, gasPrice: true, maxFeePerGs: true, maxPriorityFeePerGas: true, nonce: true, value: true }[key]) {\n\t            value = (0, lib$1.hexValue)((0, lib$1.hexlify)(value));\n\t        }\n\t        else if (key === \"accessList\") {\n\t            value = \"[\" + (0, lib$e.accessListify)(value).map(function (set) {\n\t                return \"{address:\\\"\" + set.address + \"\\\",storageKeys:[\\\"\" + set.storageKeys.join('\",\"') + \"\\\"]}\";\n\t            }).join(\",\") + \"]\";\n\t        }\n\t        else {\n\t            value = (0, lib$1.hexlify)(value);\n\t        }\n\t        result[key] = value;\n\t    }\n\t    return result;\n\t}\n\tfunction getResult(result) {\n\t    // getLogs, getHistory have weird success responses\n\t    if (result.status == 0 && (result.message === \"No records found\" || result.message === \"No transactions found\")) {\n\t        return result.result;\n\t    }\n\t    if (result.status != 1 || result.message != \"OK\") {\n\t        var error = new Error(\"invalid response\");\n\t        error.result = JSON.stringify(result);\n\t        if ((result.result || \"\").toLowerCase().indexOf(\"rate limit\") >= 0) {\n\t            error.throttleRetry = true;\n\t        }\n\t        throw error;\n\t    }\n\t    return result.result;\n\t}\n\tfunction getJsonResult(result) {\n\t    // This response indicates we are being throttled\n\t    if (result && result.status == 0 && result.message == \"NOTOK\" && (result.result || \"\").toLowerCase().indexOf(\"rate limit\") >= 0) {\n\t        var error = new Error(\"throttled response\");\n\t        error.result = JSON.stringify(result);\n\t        error.throttleRetry = true;\n\t        throw error;\n\t    }\n\t    if (result.jsonrpc != \"2.0\") {\n\t        // @TODO: not any\n\t        var error = new Error(\"invalid response\");\n\t        error.result = JSON.stringify(result);\n\t        throw error;\n\t    }\n\t    if (result.error) {\n\t        // @TODO: not any\n\t        var error = new Error(result.error.message || \"unknown error\");\n\t        if (result.error.code) {\n\t            error.code = result.error.code;\n\t        }\n\t        if (result.error.data) {\n\t            error.data = result.error.data;\n\t        }\n\t        throw error;\n\t    }\n\t    return result.result;\n\t}\n\t// The blockTag was normalized as a string by the Provider pre-perform operations\n\tfunction checkLogTag(blockTag) {\n\t    if (blockTag === \"pending\") {\n\t        throw new Error(\"pending not supported\");\n\t    }\n\t    if (blockTag === \"latest\") {\n\t        return blockTag;\n\t    }\n\t    return parseInt(blockTag.substring(2), 16);\n\t}\n\tvar defaultApiKey = \"9D13ZE7XSBTJ94N9BNJ2MA33VMAY2YPIRB\";\n\tfunction checkError(method, error, transaction) {\n\t    // Undo the \"convenience\" some nodes are attempting to prevent backwards\n\t    // incompatibility; maybe for v6 consider forwarding reverts as errors\n\t    if (method === \"call\" && error.code === lib.Logger.errors.SERVER_ERROR) {\n\t        var e = error.error;\n\t        // Etherscan keeps changing their string\n\t        if (e && (e.message.match(/reverted/i) || e.message.match(/VM execution error/i))) {\n\t            // Etherscan prefixes the data like \"Reverted 0x1234\"\n\t            var data = e.data;\n\t            if (data) {\n\t                data = \"0x\" + data.replace(/^.*0x/i, \"\");\n\t            }\n\t            if ((0, lib$1.isHexString)(data)) {\n\t                return data;\n\t            }\n\t            logger.throwError(\"missing revert data in call exception\", lib.Logger.errors.CALL_EXCEPTION, {\n\t                error: error,\n\t                data: \"0x\"\n\t            });\n\t        }\n\t    }\n\t    // Get the message from any nested error structure\n\t    var message = error.message;\n\t    if (error.code === lib.Logger.errors.SERVER_ERROR) {\n\t        if (error.error && typeof (error.error.message) === \"string\") {\n\t            message = error.error.message;\n\t        }\n\t        else if (typeof (error.body) === \"string\") {\n\t            message = error.body;\n\t        }\n\t        else if (typeof (error.responseText) === \"string\") {\n\t            message = error.responseText;\n\t        }\n\t    }\n\t    message = (message || \"\").toLowerCase();\n\t    // \"Insufficient funds. The account you tried to send transaction from does not have enough funds. Required 21464000000000 and got: 0\"\n\t    if (message.match(/insufficient funds/)) {\n\t        logger.throwError(\"insufficient funds for intrinsic transaction cost\", lib.Logger.errors.INSUFFICIENT_FUNDS, {\n\t            error: error,\n\t            method: method,\n\t            transaction: transaction\n\t        });\n\t    }\n\t    // \"Transaction with the same hash was already imported.\"\n\t    if (message.match(/same hash was already imported|transaction nonce is too low|nonce too low/)) {\n\t        logger.throwError(\"nonce has already been used\", lib.Logger.errors.NONCE_EXPIRED, {\n\t            error: error,\n\t            method: method,\n\t            transaction: transaction\n\t        });\n\t    }\n\t    // \"Transaction gas price is too low. There is another transaction with same nonce in the queue. Try increasing the gas price or incrementing the nonce.\"\n\t    if (message.match(/another transaction with same nonce/)) {\n\t        logger.throwError(\"replacement fee too low\", lib.Logger.errors.REPLACEMENT_UNDERPRICED, {\n\t            error: error,\n\t            method: method,\n\t            transaction: transaction\n\t        });\n\t    }\n\t    if (message.match(/execution failed due to an exception|execution reverted/)) {\n\t        logger.throwError(\"cannot estimate gas; transaction may fail or may require manual gas limit\", lib.Logger.errors.UNPREDICTABLE_GAS_LIMIT, {\n\t            error: error,\n\t            method: method,\n\t            transaction: transaction\n\t        });\n\t    }\n\t    throw error;\n\t}\n\tvar EtherscanProvider = /** @class */ (function (_super) {\n\t    __extends(EtherscanProvider, _super);\n\t    function EtherscanProvider(network, apiKey) {\n\t        var _newTarget = this.constructor;\n\t        var _this = this;\n\t        logger.checkNew(_newTarget, EtherscanProvider);\n\t        _this = _super.call(this, network) || this;\n\t        (0, lib$3.defineReadOnly)(_this, \"baseUrl\", _this.getBaseUrl());\n\t        (0, lib$3.defineReadOnly)(_this, \"apiKey\", apiKey || defaultApiKey);\n\t        return _this;\n\t    }\n\t    EtherscanProvider.prototype.getBaseUrl = function () {\n\t        switch (this.network ? this.network.name : \"invalid\") {\n\t            case \"homestead\":\n\t                return \"https:/\\/api.etherscan.io\";\n\t            case \"ropsten\":\n\t                return \"https:/\\/api-ropsten.etherscan.io\";\n\t            case \"rinkeby\":\n\t                return \"https:/\\/api-rinkeby.etherscan.io\";\n\t            case \"kovan\":\n\t                return \"https:/\\/api-kovan.etherscan.io\";\n\t            case \"goerli\":\n\t                return \"https:/\\/api-goerli.etherscan.io\";\n\t            default:\n\t        }\n\t        return logger.throwArgumentError(\"unsupported network\", \"network\", name);\n\t    };\n\t    EtherscanProvider.prototype.getUrl = function (module, params) {\n\t        var query = Object.keys(params).reduce(function (accum, key) {\n\t            var value = params[key];\n\t            if (value != null) {\n\t                accum += \"&\" + key + \"=\" + value;\n\t            }\n\t            return accum;\n\t        }, \"\");\n\t        var apiKey = ((this.apiKey) ? \"&apikey=\" + this.apiKey : \"\");\n\t        return this.baseUrl + \"/api?module=\" + module + query + apiKey;\n\t    };\n\t    EtherscanProvider.prototype.getPostUrl = function () {\n\t        return this.baseUrl + \"/api\";\n\t    };\n\t    EtherscanProvider.prototype.getPostData = function (module, params) {\n\t        params.module = module;\n\t        params.apikey = this.apiKey;\n\t        return params;\n\t    };\n\t    EtherscanProvider.prototype.fetch = function (module, params, post) {\n\t        return __awaiter(this, void 0, void 0, function () {\n\t            var url, payload, procFunc, connection, payloadStr, result;\n\t            var _this = this;\n\t            return __generator(this, function (_a) {\n\t                switch (_a.label) {\n\t                    case 0:\n\t                        url = (post ? this.getPostUrl() : this.getUrl(module, params));\n\t                        payload = (post ? this.getPostData(module, params) : null);\n\t                        procFunc = (module === \"proxy\") ? getJsonResult : getResult;\n\t                        this.emit(\"debug\", {\n\t                            action: \"request\",\n\t                            request: url,\n\t                            provider: this\n\t                        });\n\t                        connection = {\n\t                            url: url,\n\t                            throttleSlotInterval: 1000,\n\t                            throttleCallback: function (attempt, url) {\n\t                                if (_this.isCommunityResource()) {\n\t                                    (0, formatter.showThrottleMessage)();\n\t                                }\n\t                                return Promise.resolve(true);\n\t                            }\n\t                        };\n\t                        payloadStr = null;\n\t                        if (payload) {\n\t                            connection.headers = { \"content-type\": \"application/x-www-form-urlencoded; charset=UTF-8\" };\n\t                            payloadStr = Object.keys(payload).map(function (key) {\n\t                                return key + \"=\" + payload[key];\n\t                            }).join(\"&\");\n\t                        }\n\t                        return [4 /*yield*/, (0, lib$q.fetchJson)(connection, payloadStr, procFunc || getJsonResult)];\n\t                    case 1:\n\t                        result = _a.sent();\n\t                        this.emit(\"debug\", {\n\t                            action: \"response\",\n\t                            request: url,\n\t                            response: (0, lib$3.deepCopy)(result),\n\t                            provider: this\n\t                        });\n\t                        return [2 /*return*/, result];\n\t                }\n\t            });\n\t        });\n\t    };\n\t    EtherscanProvider.prototype.detectNetwork = function () {\n\t        return __awaiter(this, void 0, void 0, function () {\n\t            return __generator(this, function (_a) {\n\t                return [2 /*return*/, this.network];\n\t            });\n\t        });\n\t    };\n\t    EtherscanProvider.prototype.perform = function (method, params) {\n\t        return __awaiter(this, void 0, void 0, function () {\n\t            var _a, postData, error_1, postData, error_2, args, topic0, logs, blocks, i, log, block, _b;\n\t            return __generator(this, function (_c) {\n\t                switch (_c.label) {\n\t                    case 0:\n\t                        _a = method;\n\t                        switch (_a) {\n\t                            case \"getBlockNumber\": return [3 /*break*/, 1];\n\t                            case \"getGasPrice\": return [3 /*break*/, 2];\n\t                            case \"getBalance\": return [3 /*break*/, 3];\n\t                            case \"getTransactionCount\": return [3 /*break*/, 4];\n\t                            case \"getCode\": return [3 /*break*/, 5];\n\t                            case \"getStorageAt\": return [3 /*break*/, 6];\n\t                            case \"sendTransaction\": return [3 /*break*/, 7];\n\t                            case \"getBlock\": return [3 /*break*/, 8];\n\t                            case \"getTransaction\": return [3 /*break*/, 9];\n\t                            case \"getTransactionReceipt\": return [3 /*break*/, 10];\n\t                            case \"call\": return [3 /*break*/, 11];\n\t                            case \"estimateGas\": return [3 /*break*/, 15];\n\t                            case \"getLogs\": return [3 /*break*/, 19];\n\t                            case \"getEtherPrice\": return [3 /*break*/, 26];\n\t                        }\n\t                        return [3 /*break*/, 28];\n\t                    case 1: return [2 /*return*/, this.fetch(\"proxy\", { action: \"eth_blockNumber\" })];\n\t                    case 2: return [2 /*return*/, this.fetch(\"proxy\", { action: \"eth_gasPrice\" })];\n\t                    case 3: \n\t                    // Returns base-10 result\n\t                    return [2 /*return*/, this.fetch(\"account\", {\n\t                            action: \"balance\",\n\t                            address: params.address,\n\t                            tag: params.blockTag\n\t                        })];\n\t                    case 4: return [2 /*return*/, this.fetch(\"proxy\", {\n\t                            action: \"eth_getTransactionCount\",\n\t                            address: params.address,\n\t                            tag: params.blockTag\n\t                        })];\n\t                    case 5: return [2 /*return*/, this.fetch(\"proxy\", {\n\t                            action: \"eth_getCode\",\n\t                            address: params.address,\n\t                            tag: params.blockTag\n\t                        })];\n\t                    case 6: return [2 /*return*/, this.fetch(\"proxy\", {\n\t                            action: \"eth_getStorageAt\",\n\t                            address: params.address,\n\t                            position: params.position,\n\t                            tag: params.blockTag\n\t                        })];\n\t                    case 7: return [2 /*return*/, this.fetch(\"proxy\", {\n\t                            action: \"eth_sendRawTransaction\",\n\t                            hex: params.signedTransaction\n\t                        }, true).catch(function (error) {\n\t                            return checkError(\"sendTransaction\", error, params.signedTransaction);\n\t                        })];\n\t                    case 8:\n\t                        if (params.blockTag) {\n\t                            return [2 /*return*/, this.fetch(\"proxy\", {\n\t                                    action: \"eth_getBlockByNumber\",\n\t                                    tag: params.blockTag,\n\t                                    boolean: (params.includeTransactions ? \"true\" : \"false\")\n\t                                })];\n\t                        }\n\t                        throw new Error(\"getBlock by blockHash not implemented\");\n\t                    case 9: return [2 /*return*/, this.fetch(\"proxy\", {\n\t                            action: \"eth_getTransactionByHash\",\n\t                            txhash: params.transactionHash\n\t                        })];\n\t                    case 10: return [2 /*return*/, this.fetch(\"proxy\", {\n\t                            action: \"eth_getTransactionReceipt\",\n\t                            txhash: params.transactionHash\n\t                        })];\n\t                    case 11:\n\t                        if (params.blockTag !== \"latest\") {\n\t                            throw new Error(\"EtherscanProvider does not support blockTag for call\");\n\t                        }\n\t                        postData = getTransactionPostData(params.transaction);\n\t                        postData.module = \"proxy\";\n\t                        postData.action = \"eth_call\";\n\t                        _c.label = 12;\n\t                    case 12:\n\t                        _c.trys.push([12, 14, , 15]);\n\t                        return [4 /*yield*/, this.fetch(\"proxy\", postData, true)];\n\t                    case 13: return [2 /*return*/, _c.sent()];\n\t                    case 14:\n\t                        error_1 = _c.sent();\n\t                        return [2 /*return*/, checkError(\"call\", error_1, params.transaction)];\n\t                    case 15:\n\t                        postData = getTransactionPostData(params.transaction);\n\t                        postData.module = \"proxy\";\n\t                        postData.action = \"eth_estimateGas\";\n\t                        _c.label = 16;\n\t                    case 16:\n\t                        _c.trys.push([16, 18, , 19]);\n\t                        return [4 /*yield*/, this.fetch(\"proxy\", postData, true)];\n\t                    case 17: return [2 /*return*/, _c.sent()];\n\t                    case 18:\n\t                        error_2 = _c.sent();\n\t                        return [2 /*return*/, checkError(\"estimateGas\", error_2, params.transaction)];\n\t                    case 19:\n\t                        args = { action: \"getLogs\" };\n\t                        if (params.filter.fromBlock) {\n\t                            args.fromBlock = checkLogTag(params.filter.fromBlock);\n\t                        }\n\t                        if (params.filter.toBlock) {\n\t                            args.toBlock = checkLogTag(params.filter.toBlock);\n\t                        }\n\t                        if (params.filter.address) {\n\t                            args.address = params.filter.address;\n\t                        }\n\t                        // @TODO: We can handle slightly more complicated logs using the logs API\n\t                        if (params.filter.topics && params.filter.topics.length > 0) {\n\t                            if (params.filter.topics.length > 1) {\n\t                                logger.throwError(\"unsupported topic count\", lib.Logger.errors.UNSUPPORTED_OPERATION, { topics: params.filter.topics });\n\t                            }\n\t                            if (params.filter.topics.length === 1) {\n\t                                topic0 = params.filter.topics[0];\n\t                                if (typeof (topic0) !== \"string\" || topic0.length !== 66) {\n\t                                    logger.throwError(\"unsupported topic format\", lib.Logger.errors.UNSUPPORTED_OPERATION, { topic0: topic0 });\n\t                                }\n\t                                args.topic0 = topic0;\n\t                            }\n\t                        }\n\t                        return [4 /*yield*/, this.fetch(\"logs\", args)];\n\t                    case 20:\n\t                        logs = _c.sent();\n\t                        blocks = {};\n\t                        i = 0;\n\t                        _c.label = 21;\n\t                    case 21:\n\t                        if (!(i < logs.length)) return [3 /*break*/, 25];\n\t                        log = logs[i];\n\t                        if (log.blockHash != null) {\n\t                            return [3 /*break*/, 24];\n\t                        }\n\t                        if (!(blocks[log.blockNumber] == null)) return [3 /*break*/, 23];\n\t                        return [4 /*yield*/, this.getBlock(log.blockNumber)];\n\t                    case 22:\n\t                        block = _c.sent();\n\t                        if (block) {\n\t                            blocks[log.blockNumber] = block.hash;\n\t                        }\n\t                        _c.label = 23;\n\t                    case 23:\n\t                        log.blockHash = blocks[log.blockNumber];\n\t                        _c.label = 24;\n\t                    case 24:\n\t                        i++;\n\t                        return [3 /*break*/, 21];\n\t                    case 25: return [2 /*return*/, logs];\n\t                    case 26:\n\t                        if (this.network.name !== \"homestead\") {\n\t                            return [2 /*return*/, 0.0];\n\t                        }\n\t                        _b = parseFloat;\n\t                        return [4 /*yield*/, this.fetch(\"stats\", { action: \"ethprice\" })];\n\t                    case 27: return [2 /*return*/, _b.apply(void 0, [(_c.sent()).ethusd])];\n\t                    case 28: return [3 /*break*/, 29];\n\t                    case 29: return [2 /*return*/, _super.prototype.perform.call(this, method, params)];\n\t                }\n\t            });\n\t        });\n\t    };\n\t    // Note: The `page` page parameter only allows pagination within the\n\t    //       10,000 window available without a page and offset parameter\n\t    //       Error: Result window is too large, PageNo x Offset size must\n\t    //              be less than or equal to 10000\n\t    EtherscanProvider.prototype.getHistory = function (addressOrName, startBlock, endBlock) {\n\t        return __awaiter(this, void 0, void 0, function () {\n\t            var params, result;\n\t            var _a;\n\t            var _this = this;\n\t            return __generator(this, function (_b) {\n\t                switch (_b.label) {\n\t                    case 0:\n\t                        _a = {\n\t                            action: \"txlist\"\n\t                        };\n\t                        return [4 /*yield*/, this.resolveName(addressOrName)];\n\t                    case 1:\n\t                        params = (_a.address = (_b.sent()),\n\t                            _a.startblock = ((startBlock == null) ? 0 : startBlock),\n\t                            _a.endblock = ((endBlock == null) ? 99999999 : endBlock),\n\t                            _a.sort = \"asc\",\n\t                            _a);\n\t                        return [4 /*yield*/, this.fetch(\"account\", params)];\n\t                    case 2:\n\t                        result = _b.sent();\n\t                        return [2 /*return*/, result.map(function (tx) {\n\t                                [\"contractAddress\", \"to\"].forEach(function (key) {\n\t                                    if (tx[key] == \"\") {\n\t                                        delete tx[key];\n\t                                    }\n\t                                });\n\t                                if (tx.creates == null && tx.contractAddress != null) {\n\t                                    tx.creates = tx.contractAddress;\n\t                                }\n\t                                var item = _this.formatter.transactionResponse(tx);\n\t                                if (tx.timeStamp) {\n\t                                    item.timestamp = parseInt(tx.timeStamp);\n\t                                }\n\t                                return item;\n\t                            })];\n\t                }\n\t            });\n\t        });\n\t    };\n\t    EtherscanProvider.prototype.isCommunityResource = function () {\n\t        return (this.apiKey === defaultApiKey);\n\t    };\n\t    return EtherscanProvider;\n\t}(baseProvider.BaseProvider));\n\texports.EtherscanProvider = EtherscanProvider;\n\n\t});\n\n\tvar etherscanProvider$1 = /*@__PURE__*/getDefaultExportFromCjs(etherscanProvider);\n\n\tvar fallbackProvider = createCommonjsModule(function (module, exports) {\n\t\"use strict\";\n\tvar __extends = (commonjsGlobal && commonjsGlobal.__extends) || (function () {\n\t    var extendStatics = function (d, b) {\n\t        extendStatics = Object.setPrototypeOf ||\n\t            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n\t            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n\t        return extendStatics(d, b);\n\t    };\n\t    return function (d, b) {\n\t        if (typeof b !== \"function\" && b !== null)\n\t            throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n\t        extendStatics(d, b);\n\t        function __() { this.constructor = d; }\n\t        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n\t    };\n\t})();\n\tvar __awaiter = (commonjsGlobal && commonjsGlobal.__awaiter) || function (thisArg, _arguments, P, generator) {\n\t    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n\t    return new (P || (P = Promise))(function (resolve, reject) {\n\t        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n\t        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n\t        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n\t        step((generator = generator.apply(thisArg, _arguments || [])).next());\n\t    });\n\t};\n\tvar __generator = (commonjsGlobal && commonjsGlobal.__generator) || function (thisArg, body) {\n\t    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\n\t    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\n\t    function verb(n) { return function (v) { return step([n, v]); }; }\n\t    function step(op) {\n\t        if (f) throw new TypeError(\"Generator is already executing.\");\n\t        while (_) try {\n\t            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n\t            if (y = 0, t) op = [op[0] & 2, t.value];\n\t            switch (op[0]) {\n\t                case 0: case 1: t = op; break;\n\t                case 4: _.label++; return { value: op[1], done: false };\n\t                case 5: _.label++; y = op[1]; op = [0]; continue;\n\t                case 7: op = _.ops.pop(); _.trys.pop(); continue;\n\t                default:\n\t                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\n\t                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\n\t                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\n\t                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\n\t                    if (t[2]) _.ops.pop();\n\t                    _.trys.pop(); continue;\n\t            }\n\t            op = body.call(thisArg, _);\n\t        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\n\t        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\n\t    }\n\t};\n\tObject.defineProperty(exports, \"__esModule\", { value: true });\n\texports.FallbackProvider = void 0;\n\n\n\n\n\n\n\n\n\n\n\tvar logger = new lib.Logger(_version$I.version);\n\tfunction now() { return (new Date()).getTime(); }\n\t// Returns to network as long as all agree, or null if any is null.\n\t// Throws an error if any two networks do not match.\n\tfunction checkNetworks(networks) {\n\t    var result = null;\n\t    for (var i = 0; i < networks.length; i++) {\n\t        var network = networks[i];\n\t        // Null! We do not know our network; bail.\n\t        if (network == null) {\n\t            return null;\n\t        }\n\t        if (result) {\n\t            // Make sure the network matches the previous networks\n\t            if (!(result.name === network.name && result.chainId === network.chainId &&\n\t                ((result.ensAddress === network.ensAddress) || (result.ensAddress == null && network.ensAddress == null)))) {\n\t                logger.throwArgumentError(\"provider mismatch\", \"networks\", networks);\n\t            }\n\t        }\n\t        else {\n\t            result = network;\n\t        }\n\t    }\n\t    return result;\n\t}\n\tfunction median(values, maxDelta) {\n\t    values = values.slice().sort();\n\t    var middle = Math.floor(values.length / 2);\n\t    // Odd length; take the middle\n\t    if (values.length % 2) {\n\t        return values[middle];\n\t    }\n\t    // Even length; take the average of the two middle\n\t    var a = values[middle - 1], b = values[middle];\n\t    if (maxDelta != null && Math.abs(a - b) > maxDelta) {\n\t        return null;\n\t    }\n\t    return (a + b) / 2;\n\t}\n\tfunction serialize(value) {\n\t    if (value === null) {\n\t        return \"null\";\n\t    }\n\t    else if (typeof (value) === \"number\" || typeof (value) === \"boolean\") {\n\t        return JSON.stringify(value);\n\t    }\n\t    else if (typeof (value) === \"string\") {\n\t        return value;\n\t    }\n\t    else if (lib$2.BigNumber.isBigNumber(value)) {\n\t        return value.toString();\n\t    }\n\t    else if (Array.isArray(value)) {\n\t        return JSON.stringify(value.map(function (i) { return serialize(i); }));\n\t    }\n\t    else if (typeof (value) === \"object\") {\n\t        var keys = Object.keys(value);\n\t        keys.sort();\n\t        return \"{\" + keys.map(function (key) {\n\t            var v = value[key];\n\t            if (typeof (v) === \"function\") {\n\t                v = \"[function]\";\n\t            }\n\t            else {\n\t                v = serialize(v);\n\t            }\n\t            return JSON.stringify(key) + \":\" + v;\n\t        }).join(\",\") + \"}\";\n\t    }\n\t    throw new Error(\"unknown value type: \" + typeof (value));\n\t}\n\t// Next request ID to use for emitting debug info\n\tvar nextRid = 1;\n\t;\n\tfunction stall(duration) {\n\t    var cancel = null;\n\t    var timer = null;\n\t    var promise = (new Promise(function (resolve) {\n\t        cancel = function () {\n\t            if (timer) {\n\t                clearTimeout(timer);\n\t                timer = null;\n\t            }\n\t            resolve();\n\t        };\n\t        timer = setTimeout(cancel, duration);\n\t    }));\n\t    var wait = function (func) {\n\t        promise = promise.then(func);\n\t        return promise;\n\t    };\n\t    function getPromise() {\n\t        return promise;\n\t    }\n\t    return { cancel: cancel, getPromise: getPromise, wait: wait };\n\t}\n\tvar ForwardErrors = [\n\t    lib.Logger.errors.CALL_EXCEPTION,\n\t    lib.Logger.errors.INSUFFICIENT_FUNDS,\n\t    lib.Logger.errors.NONCE_EXPIRED,\n\t    lib.Logger.errors.REPLACEMENT_UNDERPRICED,\n\t    lib.Logger.errors.UNPREDICTABLE_GAS_LIMIT\n\t];\n\tvar ForwardProperties = [\n\t    \"address\",\n\t    \"args\",\n\t    \"errorArgs\",\n\t    \"errorSignature\",\n\t    \"method\",\n\t    \"transaction\",\n\t];\n\t;\n\tfunction exposeDebugConfig(config, now) {\n\t    var result = {\n\t        weight: config.weight\n\t    };\n\t    Object.defineProperty(result, \"provider\", { get: function () { return config.provider; } });\n\t    if (config.start) {\n\t        result.start = config.start;\n\t    }\n\t    if (now) {\n\t        result.duration = (now - config.start);\n\t    }\n\t    if (config.done) {\n\t        if (config.error) {\n\t            result.error = config.error;\n\t        }\n\t        else {\n\t            result.result = config.result || null;\n\t        }\n\t    }\n\t    return result;\n\t}\n\tfunction normalizedTally(normalize, quorum) {\n\t    return function (configs) {\n\t        // Count the votes for each result\n\t        var tally = {};\n\t        configs.forEach(function (c) {\n\t            var value = normalize(c.result);\n\t            if (!tally[value]) {\n\t                tally[value] = { count: 0, result: c.result };\n\t            }\n\t            tally[value].count++;\n\t        });\n\t        // Check for a quorum on any given result\n\t        var keys = Object.keys(tally);\n\t        for (var i = 0; i < keys.length; i++) {\n\t            var check = tally[keys[i]];\n\t            if (check.count >= quorum) {\n\t                return check.result;\n\t            }\n\t        }\n\t        // No quroum\n\t        return undefined;\n\t    };\n\t}\n\tfunction getProcessFunc(provider, method, params) {\n\t    var normalize = serialize;\n\t    switch (method) {\n\t        case \"getBlockNumber\":\n\t            // Return the median value, unless there is (median + 1) is also\n\t            // present, in which case that is probably true and the median\n\t            // is going to be stale soon. In the event of a malicious node,\n\t            // the lie will be true soon enough.\n\t            return function (configs) {\n\t                var values = configs.map(function (c) { return c.result; });\n\t                // Get the median block number\n\t                var blockNumber = median(configs.map(function (c) { return c.result; }), 2);\n\t                if (blockNumber == null) {\n\t                    return undefined;\n\t                }\n\t                blockNumber = Math.ceil(blockNumber);\n\t                // If the next block height is present, its prolly safe to use\n\t                if (values.indexOf(blockNumber + 1) >= 0) {\n\t                    blockNumber++;\n\t                }\n\t                // Don't ever roll back the blockNumber\n\t                if (blockNumber >= provider._highestBlockNumber) {\n\t                    provider._highestBlockNumber = blockNumber;\n\t                }\n\t                return provider._highestBlockNumber;\n\t            };\n\t        case \"getGasPrice\":\n\t            // Return the middle (round index up) value, similar to median\n\t            // but do not average even entries and choose the higher.\n\t            // Malicious actors must compromise 50% of the nodes to lie.\n\t            return function (configs) {\n\t                var values = configs.map(function (c) { return c.result; });\n\t                values.sort();\n\t                return values[Math.floor(values.length / 2)];\n\t            };\n\t        case \"getEtherPrice\":\n\t            // Returns the median price. Malicious actors must compromise at\n\t            // least 50% of the nodes to lie (in a meaningful way).\n\t            return function (configs) {\n\t                return median(configs.map(function (c) { return c.result; }));\n\t            };\n\t        // No additional normalizing required; serialize is enough\n\t        case \"getBalance\":\n\t        case \"getTransactionCount\":\n\t        case \"getCode\":\n\t        case \"getStorageAt\":\n\t        case \"call\":\n\t        case \"estimateGas\":\n\t        case \"getLogs\":\n\t            break;\n\t        // We drop the confirmations from transactions as it is approximate\n\t        case \"getTransaction\":\n\t        case \"getTransactionReceipt\":\n\t            normalize = function (tx) {\n\t                if (tx == null) {\n\t                    return null;\n\t                }\n\t                tx = (0, lib$3.shallowCopy)(tx);\n\t                tx.confirmations = -1;\n\t                return serialize(tx);\n\t            };\n\t            break;\n\t        // We drop the confirmations from transactions as it is approximate\n\t        case \"getBlock\":\n\t            // We drop the confirmations from transactions as it is approximate\n\t            if (params.includeTransactions) {\n\t                normalize = function (block) {\n\t                    if (block == null) {\n\t                        return null;\n\t                    }\n\t                    block = (0, lib$3.shallowCopy)(block);\n\t                    block.transactions = block.transactions.map(function (tx) {\n\t                        tx = (0, lib$3.shallowCopy)(tx);\n\t                        tx.confirmations = -1;\n\t                        return tx;\n\t                    });\n\t                    return serialize(block);\n\t                };\n\t            }\n\t            else {\n\t                normalize = function (block) {\n\t                    if (block == null) {\n\t                        return null;\n\t                    }\n\t                    return serialize(block);\n\t                };\n\t            }\n\t            break;\n\t        default:\n\t            throw new Error(\"unknown method: \" + method);\n\t    }\n\t    // Return the result if and only if the expected quorum is\n\t    // satisfied and agreed upon for the final result.\n\t    return normalizedTally(normalize, provider.quorum);\n\t}\n\t// If we are doing a blockTag query, we need to make sure the backend is\n\t// caught up to the FallbackProvider, before sending a request to it.\n\tfunction waitForSync(config, blockNumber) {\n\t    return __awaiter(this, void 0, void 0, function () {\n\t        var provider;\n\t        return __generator(this, function (_a) {\n\t            provider = (config.provider);\n\t            if ((provider.blockNumber != null && provider.blockNumber >= blockNumber) || blockNumber === -1) {\n\t                return [2 /*return*/, provider];\n\t            }\n\t            return [2 /*return*/, (0, lib$q.poll)(function () {\n\t                    return new Promise(function (resolve, reject) {\n\t                        setTimeout(function () {\n\t                            // We are synced\n\t                            if (provider.blockNumber >= blockNumber) {\n\t                                return resolve(provider);\n\t                            }\n\t                            // We're done; just quit\n\t                            if (config.cancelled) {\n\t                                return resolve(null);\n\t                            }\n\t                            // Try again, next block\n\t                            return resolve(undefined);\n\t                        }, 0);\n\t                    });\n\t                }, { oncePoll: provider })];\n\t        });\n\t    });\n\t}\n\tfunction getRunner(config, currentBlockNumber, method, params) {\n\t    return __awaiter(this, void 0, void 0, function () {\n\t        var provider, _a, filter;\n\t        return __generator(this, function (_b) {\n\t            switch (_b.label) {\n\t                case 0:\n\t                    provider = config.provider;\n\t                    _a = method;\n\t                    switch (_a) {\n\t                        case \"getBlockNumber\": return [3 /*break*/, 1];\n\t                        case \"getGasPrice\": return [3 /*break*/, 1];\n\t                        case \"getEtherPrice\": return [3 /*break*/, 2];\n\t                        case \"getBalance\": return [3 /*break*/, 3];\n\t                        case \"getTransactionCount\": return [3 /*break*/, 3];\n\t                        case \"getCode\": return [3 /*break*/, 3];\n\t                        case \"getStorageAt\": return [3 /*break*/, 6];\n\t                        case \"getBlock\": return [3 /*break*/, 9];\n\t                        case \"call\": return [3 /*break*/, 12];\n\t                        case \"estimateGas\": return [3 /*break*/, 12];\n\t                        case \"getTransaction\": return [3 /*break*/, 15];\n\t                        case \"getTransactionReceipt\": return [3 /*break*/, 15];\n\t                        case \"getLogs\": return [3 /*break*/, 16];\n\t                    }\n\t                    return [3 /*break*/, 19];\n\t                case 1: return [2 /*return*/, provider[method]()];\n\t                case 2:\n\t                    if (provider.getEtherPrice) {\n\t                        return [2 /*return*/, provider.getEtherPrice()];\n\t                    }\n\t                    return [3 /*break*/, 19];\n\t                case 3:\n\t                    if (!(params.blockTag && (0, lib$1.isHexString)(params.blockTag))) return [3 /*break*/, 5];\n\t                    return [4 /*yield*/, waitForSync(config, currentBlockNumber)];\n\t                case 4:\n\t                    provider = _b.sent();\n\t                    _b.label = 5;\n\t                case 5: return [2 /*return*/, provider[method](params.address, params.blockTag || \"latest\")];\n\t                case 6:\n\t                    if (!(params.blockTag && (0, lib$1.isHexString)(params.blockTag))) return [3 /*break*/, 8];\n\t                    return [4 /*yield*/, waitForSync(config, currentBlockNumber)];\n\t                case 7:\n\t                    provider = _b.sent();\n\t                    _b.label = 8;\n\t                case 8: return [2 /*return*/, provider.getStorageAt(params.address, params.position, params.blockTag || \"latest\")];\n\t                case 9:\n\t                    if (!(params.blockTag && (0, lib$1.isHexString)(params.blockTag))) return [3 /*break*/, 11];\n\t                    return [4 /*yield*/, waitForSync(config, currentBlockNumber)];\n\t                case 10:\n\t                    provider = _b.sent();\n\t                    _b.label = 11;\n\t                case 11: return [2 /*return*/, provider[(params.includeTransactions ? \"getBlockWithTransactions\" : \"getBlock\")](params.blockTag || params.blockHash)];\n\t                case 12:\n\t                    if (!(params.blockTag && (0, lib$1.isHexString)(params.blockTag))) return [3 /*break*/, 14];\n\t                    return [4 /*yield*/, waitForSync(config, currentBlockNumber)];\n\t                case 13:\n\t                    provider = _b.sent();\n\t                    _b.label = 14;\n\t                case 14: return [2 /*return*/, provider[method](params.transaction)];\n\t                case 15: return [2 /*return*/, provider[method](params.transactionHash)];\n\t                case 16:\n\t                    filter = params.filter;\n\t                    if (!((filter.fromBlock && (0, lib$1.isHexString)(filter.fromBlock)) || (filter.toBlock && (0, lib$1.isHexString)(filter.toBlock)))) return [3 /*break*/, 18];\n\t                    return [4 /*yield*/, waitForSync(config, currentBlockNumber)];\n\t                case 17:\n\t                    provider = _b.sent();\n\t                    _b.label = 18;\n\t                case 18: return [2 /*return*/, provider.getLogs(filter)];\n\t                case 19: return [2 /*return*/, logger.throwError(\"unknown method error\", lib.Logger.errors.UNKNOWN_ERROR, {\n\t                        method: method,\n\t                        params: params\n\t                    })];\n\t            }\n\t        });\n\t    });\n\t}\n\tvar FallbackProvider = /** @class */ (function (_super) {\n\t    __extends(FallbackProvider, _super);\n\t    function FallbackProvider(providers, quorum) {\n\t        var _newTarget = this.constructor;\n\t        var _this = this;\n\t        logger.checkNew(_newTarget, FallbackProvider);\n\t        if (providers.length === 0) {\n\t            logger.throwArgumentError(\"missing providers\", \"providers\", providers);\n\t        }\n\t        var providerConfigs = providers.map(function (configOrProvider, index) {\n\t            if (lib$b.Provider.isProvider(configOrProvider)) {\n\t                var stallTimeout = (0, formatter.isCommunityResource)(configOrProvider) ? 2000 : 750;\n\t                var priority = 1;\n\t                return Object.freeze({ provider: configOrProvider, weight: 1, stallTimeout: stallTimeout, priority: priority });\n\t            }\n\t            var config = (0, lib$3.shallowCopy)(configOrProvider);\n\t            if (config.priority == null) {\n\t                config.priority = 1;\n\t            }\n\t            if (config.stallTimeout == null) {\n\t                config.stallTimeout = (0, formatter.isCommunityResource)(configOrProvider) ? 2000 : 750;\n\t            }\n\t            if (config.weight == null) {\n\t                config.weight = 1;\n\t            }\n\t            var weight = config.weight;\n\t            if (weight % 1 || weight > 512 || weight < 1) {\n\t                logger.throwArgumentError(\"invalid weight; must be integer in [1, 512]\", \"providers[\" + index + \"].weight\", weight);\n\t            }\n\t            return Object.freeze(config);\n\t        });\n\t        var total = providerConfigs.reduce(function (accum, c) { return (accum + c.weight); }, 0);\n\t        if (quorum == null) {\n\t            quorum = total / 2;\n\t        }\n\t        else if (quorum > total) {\n\t            logger.throwArgumentError(\"quorum will always fail; larger than total weight\", \"quorum\", quorum);\n\t        }\n\t        // Are all providers' networks are known\n\t        var networkOrReady = checkNetworks(providerConfigs.map(function (c) { return (c.provider).network; }));\n\t        // Not all networks are known; we must stall\n\t        if (networkOrReady == null) {\n\t            networkOrReady = new Promise(function (resolve, reject) {\n\t                setTimeout(function () {\n\t                    _this.detectNetwork().then(resolve, reject);\n\t                }, 0);\n\t            });\n\t        }\n\t        _this = _super.call(this, networkOrReady) || this;\n\t        // Preserve a copy, so we do not get mutated\n\t        (0, lib$3.defineReadOnly)(_this, \"providerConfigs\", Object.freeze(providerConfigs));\n\t        (0, lib$3.defineReadOnly)(_this, \"quorum\", quorum);\n\t        _this._highestBlockNumber = -1;\n\t        return _this;\n\t    }\n\t    FallbackProvider.prototype.detectNetwork = function () {\n\t        return __awaiter(this, void 0, void 0, function () {\n\t            var networks;\n\t            return __generator(this, function (_a) {\n\t                switch (_a.label) {\n\t                    case 0: return [4 /*yield*/, Promise.all(this.providerConfigs.map(function (c) { return c.provider.getNetwork(); }))];\n\t                    case 1:\n\t                        networks = _a.sent();\n\t                        return [2 /*return*/, checkNetworks(networks)];\n\t                }\n\t            });\n\t        });\n\t    };\n\t    FallbackProvider.prototype.perform = function (method, params) {\n\t        return __awaiter(this, void 0, void 0, function () {\n\t            var results, i_1, result, processFunc, configs, currentBlockNumber, i, first, _loop_1, this_1, state_1;\n\t            var _this = this;\n\t            return __generator(this, function (_a) {\n\t                switch (_a.label) {\n\t                    case 0:\n\t                        if (!(method === \"sendTransaction\")) return [3 /*break*/, 2];\n\t                        return [4 /*yield*/, Promise.all(this.providerConfigs.map(function (c) {\n\t                                return c.provider.sendTransaction(params.signedTransaction).then(function (result) {\n\t                                    return result.hash;\n\t                                }, function (error) {\n\t                                    return error;\n\t                                });\n\t                            }))];\n\t                    case 1:\n\t                        results = _a.sent();\n\t                        // Any success is good enough (other errors are likely \"already seen\" errors\n\t                        for (i_1 = 0; i_1 < results.length; i_1++) {\n\t                            result = results[i_1];\n\t                            if (typeof (result) === \"string\") {\n\t                                return [2 /*return*/, result];\n\t                            }\n\t                        }\n\t                        // They were all an error; pick the first error\n\t                        throw results[0];\n\t                    case 2:\n\t                        if (!(this._highestBlockNumber === -1 && method !== \"getBlockNumber\")) return [3 /*break*/, 4];\n\t                        return [4 /*yield*/, this.getBlockNumber()];\n\t                    case 3:\n\t                        _a.sent();\n\t                        _a.label = 4;\n\t                    case 4:\n\t                        processFunc = getProcessFunc(this, method, params);\n\t                        configs = (0, lib$l.shuffled)(this.providerConfigs.map(lib$3.shallowCopy));\n\t                        configs.sort(function (a, b) { return (a.priority - b.priority); });\n\t                        currentBlockNumber = this._highestBlockNumber;\n\t                        i = 0;\n\t                        first = true;\n\t                        _loop_1 = function () {\n\t                            var t0, inflightWeight, _loop_2, waiting, results, result, errors;\n\t                            return __generator(this, function (_b) {\n\t                                switch (_b.label) {\n\t                                    case 0:\n\t                                        t0 = now();\n\t                                        inflightWeight = configs.filter(function (c) { return (c.runner && ((t0 - c.start) < c.stallTimeout)); })\n\t                                            .reduce(function (accum, c) { return (accum + c.weight); }, 0);\n\t                                        _loop_2 = function () {\n\t                                            var config = configs[i++];\n\t                                            var rid = nextRid++;\n\t                                            config.start = now();\n\t                                            config.staller = stall(config.stallTimeout);\n\t                                            config.staller.wait(function () { config.staller = null; });\n\t                                            config.runner = getRunner(config, currentBlockNumber, method, params).then(function (result) {\n\t                                                config.done = true;\n\t                                                config.result = result;\n\t                                                if (_this.listenerCount(\"debug\")) {\n\t                                                    _this.emit(\"debug\", {\n\t                                                        action: \"request\",\n\t                                                        rid: rid,\n\t                                                        backend: exposeDebugConfig(config, now()),\n\t                                                        request: { method: method, params: (0, lib$3.deepCopy)(params) },\n\t                                                        provider: _this\n\t                                                    });\n\t                                                }\n\t                                            }, function (error) {\n\t                                                config.done = true;\n\t                                                config.error = error;\n\t                                                if (_this.listenerCount(\"debug\")) {\n\t                                                    _this.emit(\"debug\", {\n\t                                                        action: \"request\",\n\t                                                        rid: rid,\n\t                                                        backend: exposeDebugConfig(config, now()),\n\t                                                        request: { method: method, params: (0, lib$3.deepCopy)(params) },\n\t                                                        provider: _this\n\t                                                    });\n\t                                                }\n\t                                            });\n\t                                            if (this_1.listenerCount(\"debug\")) {\n\t                                                this_1.emit(\"debug\", {\n\t                                                    action: \"request\",\n\t                                                    rid: rid,\n\t                                                    backend: exposeDebugConfig(config, null),\n\t                                                    request: { method: method, params: (0, lib$3.deepCopy)(params) },\n\t                                                    provider: this_1\n\t                                                });\n\t                                            }\n\t                                            inflightWeight += config.weight;\n\t                                        };\n\t                                        // Start running enough to meet quorum\n\t                                        while (inflightWeight < this_1.quorum && i < configs.length) {\n\t                                            _loop_2();\n\t                                        }\n\t                                        waiting = [];\n\t                                        configs.forEach(function (c) {\n\t                                            if (c.done || !c.runner) {\n\t                                                return;\n\t                                            }\n\t                                            waiting.push(c.runner);\n\t                                            if (c.staller) {\n\t                                                waiting.push(c.staller.getPromise());\n\t                                            }\n\t                                        });\n\t                                        if (!waiting.length) return [3 /*break*/, 2];\n\t                                        return [4 /*yield*/, Promise.race(waiting)];\n\t                                    case 1:\n\t                                        _b.sent();\n\t                                        _b.label = 2;\n\t                                    case 2:\n\t                                        results = configs.filter(function (c) { return (c.done && c.error == null); });\n\t                                        if (!(results.length >= this_1.quorum)) return [3 /*break*/, 5];\n\t                                        result = processFunc(results);\n\t                                        if (result !== undefined) {\n\t                                            // Shut down any stallers\n\t                                            configs.forEach(function (c) {\n\t                                                if (c.staller) {\n\t                                                    c.staller.cancel();\n\t                                                }\n\t                                                c.cancelled = true;\n\t                                            });\n\t                                            return [2 /*return*/, { value: result }];\n\t                                        }\n\t                                        if (!!first) return [3 /*break*/, 4];\n\t                                        return [4 /*yield*/, stall(100).getPromise()];\n\t                                    case 3:\n\t                                        _b.sent();\n\t                                        _b.label = 4;\n\t                                    case 4:\n\t                                        first = false;\n\t                                        _b.label = 5;\n\t                                    case 5:\n\t                                        errors = configs.reduce(function (accum, c) {\n\t                                            if (!c.done || c.error == null) {\n\t                                                return accum;\n\t                                            }\n\t                                            var code = (c.error).code;\n\t                                            if (ForwardErrors.indexOf(code) >= 0) {\n\t                                                if (!accum[code]) {\n\t                                                    accum[code] = { error: c.error, weight: 0 };\n\t                                                }\n\t                                                accum[code].weight += c.weight;\n\t                                            }\n\t                                            return accum;\n\t                                        }, ({}));\n\t                                        Object.keys(errors).forEach(function (errorCode) {\n\t                                            var tally = errors[errorCode];\n\t                                            if (tally.weight < _this.quorum) {\n\t                                                return;\n\t                                            }\n\t                                            // Shut down any stallers\n\t                                            configs.forEach(function (c) {\n\t                                                if (c.staller) {\n\t                                                    c.staller.cancel();\n\t                                                }\n\t                                                c.cancelled = true;\n\t                                            });\n\t                                            var e = (tally.error);\n\t                                            var props = {};\n\t                                            ForwardProperties.forEach(function (name) {\n\t                                                if (e[name] == null) {\n\t                                                    return;\n\t                                                }\n\t                                                props[name] = e[name];\n\t                                            });\n\t                                            logger.throwError(e.reason || e.message, errorCode, props);\n\t                                        });\n\t                                        // All configs have run to completion; we will never get more data\n\t                                        if (configs.filter(function (c) { return !c.done; }).length === 0) {\n\t                                            return [2 /*return*/, \"break\"];\n\t                                        }\n\t                                        return [2 /*return*/];\n\t                                }\n\t                            });\n\t                        };\n\t                        this_1 = this;\n\t                        _a.label = 5;\n\t                    case 5:\n\t                        if (false) {}\n\t                        return [5 /*yield**/, _loop_1()];\n\t                    case 6:\n\t                        state_1 = _a.sent();\n\t                        if (typeof state_1 === \"object\")\n\t                            return [2 /*return*/, state_1.value];\n\t                        if (state_1 === \"break\")\n\t                            return [3 /*break*/, 7];\n\t                        return [3 /*break*/, 5];\n\t                    case 7:\n\t                        // Shut down any stallers; shouldn't be any\n\t                        configs.forEach(function (c) {\n\t                            if (c.staller) {\n\t                                c.staller.cancel();\n\t                            }\n\t                            c.cancelled = true;\n\t                        });\n\t                        return [2 /*return*/, logger.throwError(\"failed to meet quorum\", lib.Logger.errors.SERVER_ERROR, {\n\t                                method: method,\n\t                                params: params,\n\t                                //results: configs.map((c) => c.result),\n\t                                //errors: configs.map((c) => c.error),\n\t                                results: configs.map(function (c) { return exposeDebugConfig(c); }),\n\t                                provider: this\n\t                            })];\n\t                }\n\t            });\n\t        });\n\t    };\n\t    return FallbackProvider;\n\t}(baseProvider.BaseProvider));\n\texports.FallbackProvider = FallbackProvider;\n\n\t});\n\n\tvar fallbackProvider$1 = /*@__PURE__*/getDefaultExportFromCjs(fallbackProvider);\n\n\tvar browserIpcProvider = createCommonjsModule(function (module, exports) {\n\t\"use strict\";\n\tObject.defineProperty(exports, \"__esModule\", { value: true });\n\texports.IpcProvider = void 0;\n\tvar IpcProvider = null;\n\texports.IpcProvider = IpcProvider;\n\n\t});\n\n\tvar browserIpcProvider$1 = /*@__PURE__*/getDefaultExportFromCjs(browserIpcProvider);\n\n\tvar infuraProvider = createCommonjsModule(function (module, exports) {\n\t\"use strict\";\n\tvar __extends = (commonjsGlobal && commonjsGlobal.__extends) || (function () {\n\t    var extendStatics = function (d, b) {\n\t        extendStatics = Object.setPrototypeOf ||\n\t            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n\t            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n\t        return extendStatics(d, b);\n\t    };\n\t    return function (d, b) {\n\t        if (typeof b !== \"function\" && b !== null)\n\t            throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n\t        extendStatics(d, b);\n\t        function __() { this.constructor = d; }\n\t        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n\t    };\n\t})();\n\tObject.defineProperty(exports, \"__esModule\", { value: true });\n\texports.InfuraProvider = exports.InfuraWebSocketProvider = void 0;\n\n\n\n\n\n\tvar logger = new lib.Logger(_version$I.version);\n\n\tvar defaultProjectId = \"84842078b09946638c03157f83405213\";\n\tvar InfuraWebSocketProvider = /** @class */ (function (_super) {\n\t    __extends(InfuraWebSocketProvider, _super);\n\t    function InfuraWebSocketProvider(network, apiKey) {\n\t        var _this = this;\n\t        var provider = new InfuraProvider(network, apiKey);\n\t        var connection = provider.connection;\n\t        if (connection.password) {\n\t            logger.throwError(\"INFURA WebSocket project secrets unsupported\", lib.Logger.errors.UNSUPPORTED_OPERATION, {\n\t                operation: \"InfuraProvider.getWebSocketProvider()\"\n\t            });\n\t        }\n\t        var url = connection.url.replace(/^http/i, \"ws\").replace(\"/v3/\", \"/ws/v3/\");\n\t        _this = _super.call(this, url, network) || this;\n\t        (0, lib$3.defineReadOnly)(_this, \"apiKey\", provider.projectId);\n\t        (0, lib$3.defineReadOnly)(_this, \"projectId\", provider.projectId);\n\t        (0, lib$3.defineReadOnly)(_this, \"projectSecret\", provider.projectSecret);\n\t        return _this;\n\t    }\n\t    InfuraWebSocketProvider.prototype.isCommunityResource = function () {\n\t        return (this.projectId === defaultProjectId);\n\t    };\n\t    return InfuraWebSocketProvider;\n\t}(websocketProvider.WebSocketProvider));\n\texports.InfuraWebSocketProvider = InfuraWebSocketProvider;\n\tvar InfuraProvider = /** @class */ (function (_super) {\n\t    __extends(InfuraProvider, _super);\n\t    function InfuraProvider() {\n\t        return _super !== null && _super.apply(this, arguments) || this;\n\t    }\n\t    InfuraProvider.getWebSocketProvider = function (network, apiKey) {\n\t        return new InfuraWebSocketProvider(network, apiKey);\n\t    };\n\t    InfuraProvider.getApiKey = function (apiKey) {\n\t        var apiKeyObj = {\n\t            apiKey: defaultProjectId,\n\t            projectId: defaultProjectId,\n\t            projectSecret: null\n\t        };\n\t        if (apiKey == null) {\n\t            return apiKeyObj;\n\t        }\n\t        if (typeof (apiKey) === \"string\") {\n\t            apiKeyObj.projectId = apiKey;\n\t        }\n\t        else if (apiKey.projectSecret != null) {\n\t            logger.assertArgument((typeof (apiKey.projectId) === \"string\"), \"projectSecret requires a projectId\", \"projectId\", apiKey.projectId);\n\t            logger.assertArgument((typeof (apiKey.projectSecret) === \"string\"), \"invalid projectSecret\", \"projectSecret\", \"[REDACTED]\");\n\t            apiKeyObj.projectId = apiKey.projectId;\n\t            apiKeyObj.projectSecret = apiKey.projectSecret;\n\t        }\n\t        else if (apiKey.projectId) {\n\t            apiKeyObj.projectId = apiKey.projectId;\n\t        }\n\t        apiKeyObj.apiKey = apiKeyObj.projectId;\n\t        return apiKeyObj;\n\t    };\n\t    InfuraProvider.getUrl = function (network, apiKey) {\n\t        var host = null;\n\t        switch (network ? network.name : \"unknown\") {\n\t            case \"homestead\":\n\t                host = \"mainnet.infura.io\";\n\t                break;\n\t            case \"ropsten\":\n\t                host = \"ropsten.infura.io\";\n\t                break;\n\t            case \"rinkeby\":\n\t                host = \"rinkeby.infura.io\";\n\t                break;\n\t            case \"kovan\":\n\t                host = \"kovan.infura.io\";\n\t                break;\n\t            case \"goerli\":\n\t                host = \"goerli.infura.io\";\n\t                break;\n\t            case \"matic\":\n\t                host = \"polygon-mainnet.infura.io\";\n\t                break;\n\t            case \"maticmum\":\n\t                host = \"polygon-mumbai.infura.io\";\n\t                break;\n\t            default:\n\t                logger.throwError(\"unsupported network\", lib.Logger.errors.INVALID_ARGUMENT, {\n\t                    argument: \"network\",\n\t                    value: network\n\t                });\n\t        }\n\t        var connection = {\n\t            allowGzip: true,\n\t            url: (\"https:/\" + \"/\" + host + \"/v3/\" + apiKey.projectId),\n\t            throttleCallback: function (attempt, url) {\n\t                if (apiKey.projectId === defaultProjectId) {\n\t                    (0, formatter.showThrottleMessage)();\n\t                }\n\t                return Promise.resolve(true);\n\t            }\n\t        };\n\t        if (apiKey.projectSecret != null) {\n\t            connection.user = \"\";\n\t            connection.password = apiKey.projectSecret;\n\t        }\n\t        return connection;\n\t    };\n\t    InfuraProvider.prototype.isCommunityResource = function () {\n\t        return (this.projectId === defaultProjectId);\n\t    };\n\t    return InfuraProvider;\n\t}(urlJsonRpcProvider.UrlJsonRpcProvider));\n\texports.InfuraProvider = InfuraProvider;\n\n\t});\n\n\tvar infuraProvider$1 = /*@__PURE__*/getDefaultExportFromCjs(infuraProvider);\n\n\tvar jsonRpcBatchProvider = createCommonjsModule(function (module, exports) {\n\t\"use strict\";\n\tvar __extends = (commonjsGlobal && commonjsGlobal.__extends) || (function () {\n\t    var extendStatics = function (d, b) {\n\t        extendStatics = Object.setPrototypeOf ||\n\t            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n\t            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n\t        return extendStatics(d, b);\n\t    };\n\t    return function (d, b) {\n\t        if (typeof b !== \"function\" && b !== null)\n\t            throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n\t        extendStatics(d, b);\n\t        function __() { this.constructor = d; }\n\t        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n\t    };\n\t})();\n\tObject.defineProperty(exports, \"__esModule\", { value: true });\n\texports.JsonRpcBatchProvider = void 0;\n\n\n\n\t// Experimental\n\tvar JsonRpcBatchProvider = /** @class */ (function (_super) {\n\t    __extends(JsonRpcBatchProvider, _super);\n\t    function JsonRpcBatchProvider() {\n\t        return _super !== null && _super.apply(this, arguments) || this;\n\t    }\n\t    JsonRpcBatchProvider.prototype.send = function (method, params) {\n\t        var _this = this;\n\t        var request = {\n\t            method: method,\n\t            params: params,\n\t            id: (this._nextId++),\n\t            jsonrpc: \"2.0\"\n\t        };\n\t        if (this._pendingBatch == null) {\n\t            this._pendingBatch = [];\n\t        }\n\t        var inflightRequest = { request: request, resolve: null, reject: null };\n\t        var promise = new Promise(function (resolve, reject) {\n\t            inflightRequest.resolve = resolve;\n\t            inflightRequest.reject = reject;\n\t        });\n\t        this._pendingBatch.push(inflightRequest);\n\t        if (!this._pendingBatchAggregator) {\n\t            // Schedule batch for next event loop + short duration\n\t            this._pendingBatchAggregator = setTimeout(function () {\n\t                // Get teh current batch and clear it, so new requests\n\t                // go into the next batch\n\t                var batch = _this._pendingBatch;\n\t                _this._pendingBatch = null;\n\t                _this._pendingBatchAggregator = null;\n\t                // Get the request as an array of requests\n\t                var request = batch.map(function (inflight) { return inflight.request; });\n\t                _this.emit(\"debug\", {\n\t                    action: \"requestBatch\",\n\t                    request: (0, lib$3.deepCopy)(request),\n\t                    provider: _this\n\t                });\n\t                return (0, lib$q.fetchJson)(_this.connection, JSON.stringify(request)).then(function (result) {\n\t                    _this.emit(\"debug\", {\n\t                        action: \"response\",\n\t                        request: request,\n\t                        response: result,\n\t                        provider: _this\n\t                    });\n\t                    // For each result, feed it to the correct Promise, depending\n\t                    // on whether it was a success or error\n\t                    batch.forEach(function (inflightRequest, index) {\n\t                        var payload = result[index];\n\t                        if (payload.error) {\n\t                            var error = new Error(payload.error.message);\n\t                            error.code = payload.error.code;\n\t                            error.data = payload.error.data;\n\t                            inflightRequest.reject(error);\n\t                        }\n\t                        else {\n\t                            inflightRequest.resolve(payload.result);\n\t                        }\n\t                    });\n\t                }, function (error) {\n\t                    _this.emit(\"debug\", {\n\t                        action: \"response\",\n\t                        error: error,\n\t                        request: request,\n\t                        provider: _this\n\t                    });\n\t                    batch.forEach(function (inflightRequest) {\n\t                        inflightRequest.reject(error);\n\t                    });\n\t                });\n\t            }, 10);\n\t        }\n\t        return promise;\n\t    };\n\t    return JsonRpcBatchProvider;\n\t}(jsonRpcProvider.JsonRpcProvider));\n\texports.JsonRpcBatchProvider = JsonRpcBatchProvider;\n\n\t});\n\n\tvar jsonRpcBatchProvider$1 = /*@__PURE__*/getDefaultExportFromCjs(jsonRpcBatchProvider);\n\n\tvar nodesmithProvider = createCommonjsModule(function (module, exports) {\n\t/* istanbul ignore file */\n\t\"use strict\";\n\tvar __extends = (commonjsGlobal && commonjsGlobal.__extends) || (function () {\n\t    var extendStatics = function (d, b) {\n\t        extendStatics = Object.setPrototypeOf ||\n\t            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n\t            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n\t        return extendStatics(d, b);\n\t    };\n\t    return function (d, b) {\n\t        if (typeof b !== \"function\" && b !== null)\n\t            throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n\t        extendStatics(d, b);\n\t        function __() { this.constructor = d; }\n\t        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n\t    };\n\t})();\n\tObject.defineProperty(exports, \"__esModule\", { value: true });\n\texports.NodesmithProvider = void 0;\n\n\n\n\tvar logger = new lib.Logger(_version$I.version);\n\t// Special API key provided by Nodesmith for ethers.js\n\tvar defaultApiKey = \"ETHERS_JS_SHARED\";\n\tvar NodesmithProvider = /** @class */ (function (_super) {\n\t    __extends(NodesmithProvider, _super);\n\t    function NodesmithProvider() {\n\t        return _super !== null && _super.apply(this, arguments) || this;\n\t    }\n\t    NodesmithProvider.getApiKey = function (apiKey) {\n\t        if (apiKey && typeof (apiKey) !== \"string\") {\n\t            logger.throwArgumentError(\"invalid apiKey\", \"apiKey\", apiKey);\n\t        }\n\t        return apiKey || defaultApiKey;\n\t    };\n\t    NodesmithProvider.getUrl = function (network, apiKey) {\n\t        logger.warn(\"NodeSmith will be discontinued on 2019-12-20; please migrate to another platform.\");\n\t        var host = null;\n\t        switch (network.name) {\n\t            case \"homestead\":\n\t                host = \"https://ethereum.api.nodesmith.io/v1/mainnet/jsonrpc\";\n\t                break;\n\t            case \"ropsten\":\n\t                host = \"https://ethereum.api.nodesmith.io/v1/ropsten/jsonrpc\";\n\t                break;\n\t            case \"rinkeby\":\n\t                host = \"https://ethereum.api.nodesmith.io/v1/rinkeby/jsonrpc\";\n\t                break;\n\t            case \"goerli\":\n\t                host = \"https://ethereum.api.nodesmith.io/v1/goerli/jsonrpc\";\n\t                break;\n\t            case \"kovan\":\n\t                host = \"https://ethereum.api.nodesmith.io/v1/kovan/jsonrpc\";\n\t                break;\n\t            default:\n\t                logger.throwArgumentError(\"unsupported network\", \"network\", arguments[0]);\n\t        }\n\t        return (host + \"?apiKey=\" + apiKey);\n\t    };\n\t    return NodesmithProvider;\n\t}(urlJsonRpcProvider.UrlJsonRpcProvider));\n\texports.NodesmithProvider = NodesmithProvider;\n\n\t});\n\n\tvar nodesmithProvider$1 = /*@__PURE__*/getDefaultExportFromCjs(nodesmithProvider);\n\n\tvar pocketProvider = createCommonjsModule(function (module, exports) {\n\t\"use strict\";\n\tvar __extends = (commonjsGlobal && commonjsGlobal.__extends) || (function () {\n\t    var extendStatics = function (d, b) {\n\t        extendStatics = Object.setPrototypeOf ||\n\t            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n\t            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n\t        return extendStatics(d, b);\n\t    };\n\t    return function (d, b) {\n\t        if (typeof b !== \"function\" && b !== null)\n\t            throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n\t        extendStatics(d, b);\n\t        function __() { this.constructor = d; }\n\t        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n\t    };\n\t})();\n\tObject.defineProperty(exports, \"__esModule\", { value: true });\n\texports.PocketProvider = void 0;\n\n\n\n\tvar logger = new lib.Logger(_version$I.version);\n\n\t// These are load-balancer-based application IDs\n\tvar defaultApplicationIds = {\n\t    homestead: \"6004bcd10040261633ade990\",\n\t    ropsten: \"6004bd4d0040261633ade991\",\n\t    rinkeby: \"6004bda20040261633ade994\",\n\t    goerli: \"6004bd860040261633ade992\",\n\t};\n\tvar PocketProvider = /** @class */ (function (_super) {\n\t    __extends(PocketProvider, _super);\n\t    function PocketProvider(network, apiKey) {\n\t        // We need a bit of creativity in the constructor because\n\t        // Pocket uses different default API keys based on the network\n\t        var _newTarget = this.constructor;\n\t        var _this = this;\n\t        if (apiKey == null) {\n\t            var n = (0, lib$3.getStatic)(_newTarget, \"getNetwork\")(network);\n\t            if (n) {\n\t                var applicationId = defaultApplicationIds[n.name];\n\t                if (applicationId) {\n\t                    apiKey = {\n\t                        applicationId: applicationId,\n\t                        loadBalancer: true\n\t                    };\n\t                }\n\t            }\n\t            // If there was any issue above, we don't know this network\n\t            if (apiKey == null) {\n\t                logger.throwError(\"unsupported network\", lib.Logger.errors.INVALID_ARGUMENT, {\n\t                    argument: \"network\",\n\t                    value: network\n\t                });\n\t            }\n\t        }\n\t        _this = _super.call(this, network, apiKey) || this;\n\t        return _this;\n\t    }\n\t    PocketProvider.getApiKey = function (apiKey) {\n\t        // Most API Providers allow null to get the default configuration, but\n\t        // Pocket requires the network to decide the default provider, so we\n\t        // rely on hijacking the constructor to add a sensible default for us\n\t        if (apiKey == null) {\n\t            logger.throwArgumentError(\"PocketProvider.getApiKey does not support null apiKey\", \"apiKey\", apiKey);\n\t        }\n\t        var apiKeyObj = {\n\t            applicationId: null,\n\t            loadBalancer: false,\n\t            applicationSecretKey: null\n\t        };\n\t        // Parse applicationId and applicationSecretKey\n\t        if (typeof (apiKey) === \"string\") {\n\t            apiKeyObj.applicationId = apiKey;\n\t        }\n\t        else if (apiKey.applicationSecretKey != null) {\n\t            logger.assertArgument((typeof (apiKey.applicationId) === \"string\"), \"applicationSecretKey requires an applicationId\", \"applicationId\", apiKey.applicationId);\n\t            logger.assertArgument((typeof (apiKey.applicationSecretKey) === \"string\"), \"invalid applicationSecretKey\", \"applicationSecretKey\", \"[REDACTED]\");\n\t            apiKeyObj.applicationId = apiKey.applicationId;\n\t            apiKeyObj.applicationSecretKey = apiKey.applicationSecretKey;\n\t            apiKeyObj.loadBalancer = !!apiKey.loadBalancer;\n\t        }\n\t        else if (apiKey.applicationId) {\n\t            logger.assertArgument((typeof (apiKey.applicationId) === \"string\"), \"apiKey.applicationId must be a string\", \"apiKey.applicationId\", apiKey.applicationId);\n\t            apiKeyObj.applicationId = apiKey.applicationId;\n\t            apiKeyObj.loadBalancer = !!apiKey.loadBalancer;\n\t        }\n\t        else {\n\t            logger.throwArgumentError(\"unsupported PocketProvider apiKey\", \"apiKey\", apiKey);\n\t        }\n\t        return apiKeyObj;\n\t    };\n\t    PocketProvider.getUrl = function (network, apiKey) {\n\t        var host = null;\n\t        switch (network ? network.name : \"unknown\") {\n\t            case \"homestead\":\n\t                host = \"eth-mainnet.gateway.pokt.network\";\n\t                break;\n\t            case \"ropsten\":\n\t                host = \"eth-ropsten.gateway.pokt.network\";\n\t                break;\n\t            case \"rinkeby\":\n\t                host = \"eth-rinkeby.gateway.pokt.network\";\n\t                break;\n\t            case \"goerli\":\n\t                host = \"eth-goerli.gateway.pokt.network\";\n\t                break;\n\t            default:\n\t                logger.throwError(\"unsupported network\", lib.Logger.errors.INVALID_ARGUMENT, {\n\t                    argument: \"network\",\n\t                    value: network\n\t                });\n\t        }\n\t        var url = null;\n\t        if (apiKey.loadBalancer) {\n\t            url = \"https://\" + host + \"/v1/lb/\" + apiKey.applicationId;\n\t        }\n\t        else {\n\t            url = \"https://\" + host + \"/v1/\" + apiKey.applicationId;\n\t        }\n\t        var connection = { url: url };\n\t        // Initialize empty headers\n\t        connection.headers = {};\n\t        // Apply application secret key\n\t        if (apiKey.applicationSecretKey != null) {\n\t            connection.user = \"\";\n\t            connection.password = apiKey.applicationSecretKey;\n\t        }\n\t        return connection;\n\t    };\n\t    PocketProvider.prototype.isCommunityResource = function () {\n\t        return (this.applicationId === defaultApplicationIds[this.network.name]);\n\t    };\n\t    return PocketProvider;\n\t}(urlJsonRpcProvider.UrlJsonRpcProvider));\n\texports.PocketProvider = PocketProvider;\n\n\t});\n\n\tvar pocketProvider$1 = /*@__PURE__*/getDefaultExportFromCjs(pocketProvider);\n\n\tvar web3Provider = createCommonjsModule(function (module, exports) {\n\t\"use strict\";\n\tvar __extends = (commonjsGlobal && commonjsGlobal.__extends) || (function () {\n\t    var extendStatics = function (d, b) {\n\t        extendStatics = Object.setPrototypeOf ||\n\t            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n\t            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n\t        return extendStatics(d, b);\n\t    };\n\t    return function (d, b) {\n\t        if (typeof b !== \"function\" && b !== null)\n\t            throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n\t        extendStatics(d, b);\n\t        function __() { this.constructor = d; }\n\t        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n\t    };\n\t})();\n\tObject.defineProperty(exports, \"__esModule\", { value: true });\n\texports.Web3Provider = void 0;\n\n\n\n\tvar logger = new lib.Logger(_version$I.version);\n\n\tvar _nextId = 1;\n\tfunction buildWeb3LegacyFetcher(provider, sendFunc) {\n\t    var fetcher = \"Web3LegacyFetcher\";\n\t    return function (method, params) {\n\t        var _this = this;\n\t        var request = {\n\t            method: method,\n\t            params: params,\n\t            id: (_nextId++),\n\t            jsonrpc: \"2.0\"\n\t        };\n\t        return new Promise(function (resolve, reject) {\n\t            _this.emit(\"debug\", {\n\t                action: \"request\",\n\t                fetcher: fetcher,\n\t                request: (0, lib$3.deepCopy)(request),\n\t                provider: _this\n\t            });\n\t            sendFunc(request, function (error, response) {\n\t                if (error) {\n\t                    _this.emit(\"debug\", {\n\t                        action: \"response\",\n\t                        fetcher: fetcher,\n\t                        error: error,\n\t                        request: request,\n\t                        provider: _this\n\t                    });\n\t                    return reject(error);\n\t                }\n\t                _this.emit(\"debug\", {\n\t                    action: \"response\",\n\t                    fetcher: fetcher,\n\t                    request: request,\n\t                    response: response,\n\t                    provider: _this\n\t                });\n\t                if (response.error) {\n\t                    var error_1 = new Error(response.error.message);\n\t                    error_1.code = response.error.code;\n\t                    error_1.data = response.error.data;\n\t                    return reject(error_1);\n\t                }\n\t                resolve(response.result);\n\t            });\n\t        });\n\t    };\n\t}\n\tfunction buildEip1193Fetcher(provider) {\n\t    return function (method, params) {\n\t        var _this = this;\n\t        if (params == null) {\n\t            params = [];\n\t        }\n\t        var request = { method: method, params: params };\n\t        this.emit(\"debug\", {\n\t            action: \"request\",\n\t            fetcher: \"Eip1193Fetcher\",\n\t            request: (0, lib$3.deepCopy)(request),\n\t            provider: this\n\t        });\n\t        return provider.request(request).then(function (response) {\n\t            _this.emit(\"debug\", {\n\t                action: \"response\",\n\t                fetcher: \"Eip1193Fetcher\",\n\t                request: request,\n\t                response: response,\n\t                provider: _this\n\t            });\n\t            return response;\n\t        }, function (error) {\n\t            _this.emit(\"debug\", {\n\t                action: \"response\",\n\t                fetcher: \"Eip1193Fetcher\",\n\t                request: request,\n\t                error: error,\n\t                provider: _this\n\t            });\n\t            throw error;\n\t        });\n\t    };\n\t}\n\tvar Web3Provider = /** @class */ (function (_super) {\n\t    __extends(Web3Provider, _super);\n\t    function Web3Provider(provider, network) {\n\t        var _newTarget = this.constructor;\n\t        var _this = this;\n\t        logger.checkNew(_newTarget, Web3Provider);\n\t        if (provider == null) {\n\t            logger.throwArgumentError(\"missing provider\", \"provider\", provider);\n\t        }\n\t        var path = null;\n\t        var jsonRpcFetchFunc = null;\n\t        var subprovider = null;\n\t        if (typeof (provider) === \"function\") {\n\t            path = \"unknown:\";\n\t            jsonRpcFetchFunc = provider;\n\t        }\n\t        else {\n\t            path = provider.host || provider.path || \"\";\n\t            if (!path && provider.isMetaMask) {\n\t                path = \"metamask\";\n\t            }\n\t            subprovider = provider;\n\t            if (provider.request) {\n\t                if (path === \"\") {\n\t                    path = \"eip-1193:\";\n\t                }\n\t                jsonRpcFetchFunc = buildEip1193Fetcher(provider);\n\t            }\n\t            else if (provider.sendAsync) {\n\t                jsonRpcFetchFunc = buildWeb3LegacyFetcher(provider, provider.sendAsync.bind(provider));\n\t            }\n\t            else if (provider.send) {\n\t                jsonRpcFetchFunc = buildWeb3LegacyFetcher(provider, provider.send.bind(provider));\n\t            }\n\t            else {\n\t                logger.throwArgumentError(\"unsupported provider\", \"provider\", provider);\n\t            }\n\t            if (!path) {\n\t                path = \"unknown:\";\n\t            }\n\t        }\n\t        _this = _super.call(this, path, network) || this;\n\t        (0, lib$3.defineReadOnly)(_this, \"jsonRpcFetchFunc\", jsonRpcFetchFunc);\n\t        (0, lib$3.defineReadOnly)(_this, \"provider\", subprovider);\n\t        return _this;\n\t    }\n\t    Web3Provider.prototype.send = function (method, params) {\n\t        return this.jsonRpcFetchFunc(method, params);\n\t    };\n\t    return Web3Provider;\n\t}(jsonRpcProvider.JsonRpcProvider));\n\texports.Web3Provider = Web3Provider;\n\n\t});\n\n\tvar web3Provider$1 = /*@__PURE__*/getDefaultExportFromCjs(web3Provider);\n\n\tvar lib$r = createCommonjsModule(function (module, exports) {\n\t\"use strict\";\n\tObject.defineProperty(exports, \"__esModule\", { value: true });\n\texports.Formatter = exports.showThrottleMessage = exports.isCommunityResourcable = exports.isCommunityResource = exports.getNetwork = exports.getDefaultProvider = exports.JsonRpcSigner = exports.IpcProvider = exports.WebSocketProvider = exports.Web3Provider = exports.StaticJsonRpcProvider = exports.PocketProvider = exports.NodesmithProvider = exports.JsonRpcBatchProvider = exports.JsonRpcProvider = exports.InfuraWebSocketProvider = exports.InfuraProvider = exports.EtherscanProvider = exports.CloudflareProvider = exports.AlchemyWebSocketProvider = exports.AlchemyProvider = exports.FallbackProvider = exports.UrlJsonRpcProvider = exports.Resolver = exports.BaseProvider = exports.Provider = void 0;\n\n\tObject.defineProperty(exports, \"Provider\", { enumerable: true, get: function () { return lib$b.Provider; } });\n\n\tObject.defineProperty(exports, \"getNetwork\", { enumerable: true, get: function () { return lib$o.getNetwork; } });\n\n\tObject.defineProperty(exports, \"BaseProvider\", { enumerable: true, get: function () { return baseProvider.BaseProvider; } });\n\tObject.defineProperty(exports, \"Resolver\", { enumerable: true, get: function () { return baseProvider.Resolver; } });\n\n\tObject.defineProperty(exports, \"AlchemyProvider\", { enumerable: true, get: function () { return alchemyProvider.AlchemyProvider; } });\n\tObject.defineProperty(exports, \"AlchemyWebSocketProvider\", { enumerable: true, get: function () { return alchemyProvider.AlchemyWebSocketProvider; } });\n\n\tObject.defineProperty(exports, \"CloudflareProvider\", { enumerable: true, get: function () { return cloudflareProvider.CloudflareProvider; } });\n\n\tObject.defineProperty(exports, \"EtherscanProvider\", { enumerable: true, get: function () { return etherscanProvider.EtherscanProvider; } });\n\n\tObject.defineProperty(exports, \"FallbackProvider\", { enumerable: true, get: function () { return fallbackProvider.FallbackProvider; } });\n\n\tObject.defineProperty(exports, \"IpcProvider\", { enumerable: true, get: function () { return browserIpcProvider.IpcProvider; } });\n\n\tObject.defineProperty(exports, \"InfuraProvider\", { enumerable: true, get: function () { return infuraProvider.InfuraProvider; } });\n\tObject.defineProperty(exports, \"InfuraWebSocketProvider\", { enumerable: true, get: function () { return infuraProvider.InfuraWebSocketProvider; } });\n\n\tObject.defineProperty(exports, \"JsonRpcProvider\", { enumerable: true, get: function () { return jsonRpcProvider.JsonRpcProvider; } });\n\tObject.defineProperty(exports, \"JsonRpcSigner\", { enumerable: true, get: function () { return jsonRpcProvider.JsonRpcSigner; } });\n\n\tObject.defineProperty(exports, \"JsonRpcBatchProvider\", { enumerable: true, get: function () { return jsonRpcBatchProvider.JsonRpcBatchProvider; } });\n\n\tObject.defineProperty(exports, \"NodesmithProvider\", { enumerable: true, get: function () { return nodesmithProvider.NodesmithProvider; } });\n\n\tObject.defineProperty(exports, \"PocketProvider\", { enumerable: true, get: function () { return pocketProvider.PocketProvider; } });\n\n\tObject.defineProperty(exports, \"StaticJsonRpcProvider\", { enumerable: true, get: function () { return urlJsonRpcProvider.StaticJsonRpcProvider; } });\n\tObject.defineProperty(exports, \"UrlJsonRpcProvider\", { enumerable: true, get: function () { return urlJsonRpcProvider.UrlJsonRpcProvider; } });\n\n\tObject.defineProperty(exports, \"Web3Provider\", { enumerable: true, get: function () { return web3Provider.Web3Provider; } });\n\n\tObject.defineProperty(exports, \"WebSocketProvider\", { enumerable: true, get: function () { return websocketProvider.WebSocketProvider; } });\n\n\tObject.defineProperty(exports, \"Formatter\", { enumerable: true, get: function () { return formatter.Formatter; } });\n\tObject.defineProperty(exports, \"isCommunityResourcable\", { enumerable: true, get: function () { return formatter.isCommunityResourcable; } });\n\tObject.defineProperty(exports, \"isCommunityResource\", { enumerable: true, get: function () { return formatter.isCommunityResource; } });\n\tObject.defineProperty(exports, \"showThrottleMessage\", { enumerable: true, get: function () { return formatter.showThrottleMessage; } });\n\n\n\tvar logger = new lib.Logger(_version$I.version);\n\t////////////////////////\n\t// Helper Functions\n\tfunction getDefaultProvider(network, options) {\n\t    if (network == null) {\n\t        network = \"homestead\";\n\t    }\n\t    // If passed a URL, figure out the right type of provider based on the scheme\n\t    if (typeof (network) === \"string\") {\n\t        // @TODO: Add support for IpcProvider; maybe if it ends in \".ipc\"?\n\t        // Handle http and ws (and their secure variants)\n\t        var match = network.match(/^(ws|http)s?:/i);\n\t        if (match) {\n\t            switch (match[1]) {\n\t                case \"http\":\n\t                    return new jsonRpcProvider.JsonRpcProvider(network);\n\t                case \"ws\":\n\t                    return new websocketProvider.WebSocketProvider(network);\n\t                default:\n\t                    logger.throwArgumentError(\"unsupported URL scheme\", \"network\", network);\n\t            }\n\t        }\n\t    }\n\t    var n = (0, lib$o.getNetwork)(network);\n\t    if (!n || !n._defaultProvider) {\n\t        logger.throwError(\"unsupported getDefaultProvider network\", lib.Logger.errors.NETWORK_ERROR, {\n\t            operation: \"getDefaultProvider\",\n\t            network: network\n\t        });\n\t    }\n\t    return n._defaultProvider({\n\t        FallbackProvider: fallbackProvider.FallbackProvider,\n\t        AlchemyProvider: alchemyProvider.AlchemyProvider,\n\t        CloudflareProvider: cloudflareProvider.CloudflareProvider,\n\t        EtherscanProvider: etherscanProvider.EtherscanProvider,\n\t        InfuraProvider: infuraProvider.InfuraProvider,\n\t        JsonRpcProvider: jsonRpcProvider.JsonRpcProvider,\n\t        NodesmithProvider: nodesmithProvider.NodesmithProvider,\n\t        PocketProvider: pocketProvider.PocketProvider,\n\t        Web3Provider: web3Provider.Web3Provider,\n\t        IpcProvider: browserIpcProvider.IpcProvider,\n\t    }, options);\n\t}\n\texports.getDefaultProvider = getDefaultProvider;\n\n\t});\n\n\tvar index$r = /*@__PURE__*/getDefaultExportFromCjs(lib$r);\n\n\tvar _version$K = createCommonjsModule(function (module, exports) {\n\t\"use strict\";\n\tObject.defineProperty(exports, \"__esModule\", { value: true });\n\texports.version = void 0;\n\texports.version = \"solidity/5.5.0\";\n\n\t});\n\n\tvar _version$L = /*@__PURE__*/getDefaultExportFromCjs(_version$K);\n\n\tvar lib$s = createCommonjsModule(function (module, exports) {\n\t\"use strict\";\n\tObject.defineProperty(exports, \"__esModule\", { value: true });\n\texports.sha256 = exports.keccak256 = exports.pack = void 0;\n\n\n\n\n\n\tvar regexBytes = new RegExp(\"^bytes([0-9]+)$\");\n\tvar regexNumber = new RegExp(\"^(u?int)([0-9]*)$\");\n\tvar regexArray = new RegExp(\"^(.*)\\\\[([0-9]*)\\\\]$\");\n\tvar Zeros = \"0000000000000000000000000000000000000000000000000000000000000000\";\n\n\n\tvar logger = new lib.Logger(_version$K.version);\n\tfunction _pack(type, value, isArray) {\n\t    switch (type) {\n\t        case \"address\":\n\t            if (isArray) {\n\t                return (0, lib$1.zeroPad)(value, 32);\n\t            }\n\t            return (0, lib$1.arrayify)(value);\n\t        case \"string\":\n\t            return (0, lib$8.toUtf8Bytes)(value);\n\t        case \"bytes\":\n\t            return (0, lib$1.arrayify)(value);\n\t        case \"bool\":\n\t            value = (value ? \"0x01\" : \"0x00\");\n\t            if (isArray) {\n\t                return (0, lib$1.zeroPad)(value, 32);\n\t            }\n\t            return (0, lib$1.arrayify)(value);\n\t    }\n\t    var match = type.match(regexNumber);\n\t    if (match) {\n\t        //let signed = (match[1] === \"int\")\n\t        var size = parseInt(match[2] || \"256\");\n\t        if ((match[2] && String(size) !== match[2]) || (size % 8 !== 0) || size === 0 || size > 256) {\n\t            logger.throwArgumentError(\"invalid number type\", \"type\", type);\n\t        }\n\t        if (isArray) {\n\t            size = 256;\n\t        }\n\t        value = lib$2.BigNumber.from(value).toTwos(size);\n\t        return (0, lib$1.zeroPad)(value, size / 8);\n\t    }\n\t    match = type.match(regexBytes);\n\t    if (match) {\n\t        var size = parseInt(match[1]);\n\t        if (String(size) !== match[1] || size === 0 || size > 32) {\n\t            logger.throwArgumentError(\"invalid bytes type\", \"type\", type);\n\t        }\n\t        if ((0, lib$1.arrayify)(value).byteLength !== size) {\n\t            logger.throwArgumentError(\"invalid value for \" + type, \"value\", value);\n\t        }\n\t        if (isArray) {\n\t            return (0, lib$1.arrayify)((value + Zeros).substring(0, 66));\n\t        }\n\t        return value;\n\t    }\n\t    match = type.match(regexArray);\n\t    if (match && Array.isArray(value)) {\n\t        var baseType_1 = match[1];\n\t        var count = parseInt(match[2] || String(value.length));\n\t        if (count != value.length) {\n\t            logger.throwArgumentError(\"invalid array length for \" + type, \"value\", value);\n\t        }\n\t        var result_1 = [];\n\t        value.forEach(function (value) {\n\t            result_1.push(_pack(baseType_1, value, true));\n\t        });\n\t        return (0, lib$1.concat)(result_1);\n\t    }\n\t    return logger.throwArgumentError(\"invalid type\", \"type\", type);\n\t}\n\t// @TODO: Array Enum\n\tfunction pack(types, values) {\n\t    if (types.length != values.length) {\n\t        logger.throwArgumentError(\"wrong number of values; expected ${ types.length }\", \"values\", values);\n\t    }\n\t    var tight = [];\n\t    types.forEach(function (type, index) {\n\t        tight.push(_pack(type, values[index]));\n\t    });\n\t    return (0, lib$1.hexlify)((0, lib$1.concat)(tight));\n\t}\n\texports.pack = pack;\n\tfunction keccak256(types, values) {\n\t    return (0, lib$4.keccak256)(pack(types, values));\n\t}\n\texports.keccak256 = keccak256;\n\tfunction sha256(types, values) {\n\t    return (0, lib$h.sha256)(pack(types, values));\n\t}\n\texports.sha256 = sha256;\n\n\t});\n\n\tvar index$s = /*@__PURE__*/getDefaultExportFromCjs(lib$s);\n\n\tvar _version$M = createCommonjsModule(function (module, exports) {\n\t\"use strict\";\n\tObject.defineProperty(exports, \"__esModule\", { value: true });\n\texports.version = void 0;\n\texports.version = \"units/5.5.0\";\n\n\t});\n\n\tvar _version$N = /*@__PURE__*/getDefaultExportFromCjs(_version$M);\n\n\tvar lib$t = createCommonjsModule(function (module, exports) {\n\t\"use strict\";\n\tObject.defineProperty(exports, \"__esModule\", { value: true });\n\texports.parseEther = exports.formatEther = exports.parseUnits = exports.formatUnits = exports.commify = void 0;\n\n\n\n\tvar logger = new lib.Logger(_version$M.version);\n\tvar names = [\n\t    \"wei\",\n\t    \"kwei\",\n\t    \"mwei\",\n\t    \"gwei\",\n\t    \"szabo\",\n\t    \"finney\",\n\t    \"ether\",\n\t];\n\t// Some environments have issues with RegEx that contain back-tracking, so we cannot\n\t// use them.\n\tfunction commify(value) {\n\t    var comps = String(value).split(\".\");\n\t    if (comps.length > 2 || !comps[0].match(/^-?[0-9]*$/) || (comps[1] && !comps[1].match(/^[0-9]*$/)) || value === \".\" || value === \"-.\") {\n\t        logger.throwArgumentError(\"invalid value\", \"value\", value);\n\t    }\n\t    // Make sure we have at least one whole digit (0 if none)\n\t    var whole = comps[0];\n\t    var negative = \"\";\n\t    if (whole.substring(0, 1) === \"-\") {\n\t        negative = \"-\";\n\t        whole = whole.substring(1);\n\t    }\n\t    // Make sure we have at least 1 whole digit with no leading zeros\n\t    while (whole.substring(0, 1) === \"0\") {\n\t        whole = whole.substring(1);\n\t    }\n\t    if (whole === \"\") {\n\t        whole = \"0\";\n\t    }\n\t    var suffix = \"\";\n\t    if (comps.length === 2) {\n\t        suffix = \".\" + (comps[1] || \"0\");\n\t    }\n\t    while (suffix.length > 2 && suffix[suffix.length - 1] === \"0\") {\n\t        suffix = suffix.substring(0, suffix.length - 1);\n\t    }\n\t    var formatted = [];\n\t    while (whole.length) {\n\t        if (whole.length <= 3) {\n\t            formatted.unshift(whole);\n\t            break;\n\t        }\n\t        else {\n\t            var index = whole.length - 3;\n\t            formatted.unshift(whole.substring(index));\n\t            whole = whole.substring(0, index);\n\t        }\n\t    }\n\t    return negative + formatted.join(\",\") + suffix;\n\t}\n\texports.commify = commify;\n\tfunction formatUnits(value, unitName) {\n\t    if (typeof (unitName) === \"string\") {\n\t        var index = names.indexOf(unitName);\n\t        if (index !== -1) {\n\t            unitName = 3 * index;\n\t        }\n\t    }\n\t    return (0, lib$2.formatFixed)(value, (unitName != null) ? unitName : 18);\n\t}\n\texports.formatUnits = formatUnits;\n\tfunction parseUnits(value, unitName) {\n\t    if (typeof (value) !== \"string\") {\n\t        logger.throwArgumentError(\"value must be a string\", \"value\", value);\n\t    }\n\t    if (typeof (unitName) === \"string\") {\n\t        var index = names.indexOf(unitName);\n\t        if (index !== -1) {\n\t            unitName = 3 * index;\n\t        }\n\t    }\n\t    return (0, lib$2.parseFixed)(value, (unitName != null) ? unitName : 18);\n\t}\n\texports.parseUnits = parseUnits;\n\tfunction formatEther(wei) {\n\t    return formatUnits(wei, 18);\n\t}\n\texports.formatEther = formatEther;\n\tfunction parseEther(ether) {\n\t    return parseUnits(ether, 18);\n\t}\n\texports.parseEther = parseEther;\n\n\t});\n\n\tvar index$t = /*@__PURE__*/getDefaultExportFromCjs(lib$t);\n\n\tvar utils$3 = createCommonjsModule(function (module, exports) {\n\t\"use strict\";\n\tvar __createBinding = (commonjsGlobal && commonjsGlobal.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n\t    if (k2 === undefined) k2 = k;\n\t    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\n\t}) : (function(o, m, k, k2) {\n\t    if (k2 === undefined) k2 = k;\n\t    o[k2] = m[k];\n\t}));\n\tvar __setModuleDefault = (commonjsGlobal && commonjsGlobal.__setModuleDefault) || (Object.create ? (function(o, v) {\n\t    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n\t}) : function(o, v) {\n\t    o[\"default\"] = v;\n\t});\n\tvar __importStar = (commonjsGlobal && commonjsGlobal.__importStar) || function (mod) {\n\t    if (mod && mod.__esModule) return mod;\n\t    var result = {};\n\t    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n\t    __setModuleDefault(result, mod);\n\t    return result;\n\t};\n\tObject.defineProperty(exports, \"__esModule\", { value: true });\n\texports.formatBytes32String = exports.Utf8ErrorFuncs = exports.toUtf8String = exports.toUtf8CodePoints = exports.toUtf8Bytes = exports._toEscapedUtf8String = exports.nameprep = exports.hexDataSlice = exports.hexDataLength = exports.hexZeroPad = exports.hexValue = exports.hexStripZeros = exports.hexConcat = exports.isHexString = exports.hexlify = exports.base64 = exports.base58 = exports.TransactionDescription = exports.LogDescription = exports.Interface = exports.SigningKey = exports.HDNode = exports.defaultPath = exports.isBytesLike = exports.isBytes = exports.zeroPad = exports.stripZeros = exports.concat = exports.arrayify = exports.shallowCopy = exports.resolveProperties = exports.getStatic = exports.defineReadOnly = exports.deepCopy = exports.checkProperties = exports.poll = exports.fetchJson = exports._fetchData = exports.RLP = exports.Logger = exports.checkResultErrors = exports.FormatTypes = exports.ParamType = exports.FunctionFragment = exports.EventFragment = exports.ErrorFragment = exports.ConstructorFragment = exports.Fragment = exports.defaultAbiCoder = exports.AbiCoder = void 0;\n\texports.Indexed = exports.Utf8ErrorReason = exports.UnicodeNormalizationForm = exports.SupportedAlgorithm = exports.mnemonicToSeed = exports.isValidMnemonic = exports.entropyToMnemonic = exports.mnemonicToEntropy = exports.getAccountPath = exports.verifyTypedData = exports.verifyMessage = exports.recoverPublicKey = exports.computePublicKey = exports.recoverAddress = exports.computeAddress = exports.getJsonWalletAddress = exports.TransactionTypes = exports.serializeTransaction = exports.parseTransaction = exports.accessListify = exports.joinSignature = exports.splitSignature = exports.soliditySha256 = exports.solidityKeccak256 = exports.solidityPack = exports.shuffled = exports.randomBytes = exports.sha512 = exports.sha256 = exports.ripemd160 = exports.keccak256 = exports.computeHmac = exports.commify = exports.parseUnits = exports.formatUnits = exports.parseEther = exports.formatEther = exports.isAddress = exports.getCreate2Address = exports.getContractAddress = exports.getIcapAddress = exports.getAddress = exports._TypedDataEncoder = exports.id = exports.isValidName = exports.namehash = exports.hashMessage = exports.parseBytes32String = void 0;\n\n\tObject.defineProperty(exports, \"AbiCoder\", { enumerable: true, get: function () { return lib$a.AbiCoder; } });\n\tObject.defineProperty(exports, \"checkResultErrors\", { enumerable: true, get: function () { return lib$a.checkResultErrors; } });\n\tObject.defineProperty(exports, \"ConstructorFragment\", { enumerable: true, get: function () { return lib$a.ConstructorFragment; } });\n\tObject.defineProperty(exports, \"defaultAbiCoder\", { enumerable: true, get: function () { return lib$a.defaultAbiCoder; } });\n\tObject.defineProperty(exports, \"ErrorFragment\", { enumerable: true, get: function () { return lib$a.ErrorFragment; } });\n\tObject.defineProperty(exports, \"EventFragment\", { enumerable: true, get: function () { return lib$a.EventFragment; } });\n\tObject.defineProperty(exports, \"FormatTypes\", { enumerable: true, get: function () { return lib$a.FormatTypes; } });\n\tObject.defineProperty(exports, \"Fragment\", { enumerable: true, get: function () { return lib$a.Fragment; } });\n\tObject.defineProperty(exports, \"FunctionFragment\", { enumerable: true, get: function () { return lib$a.FunctionFragment; } });\n\tObject.defineProperty(exports, \"Indexed\", { enumerable: true, get: function () { return lib$a.Indexed; } });\n\tObject.defineProperty(exports, \"Interface\", { enumerable: true, get: function () { return lib$a.Interface; } });\n\tObject.defineProperty(exports, \"LogDescription\", { enumerable: true, get: function () { return lib$a.LogDescription; } });\n\tObject.defineProperty(exports, \"ParamType\", { enumerable: true, get: function () { return lib$a.ParamType; } });\n\tObject.defineProperty(exports, \"TransactionDescription\", { enumerable: true, get: function () { return lib$a.TransactionDescription; } });\n\n\tObject.defineProperty(exports, \"getAddress\", { enumerable: true, get: function () { return lib$6.getAddress; } });\n\tObject.defineProperty(exports, \"getCreate2Address\", { enumerable: true, get: function () { return lib$6.getCreate2Address; } });\n\tObject.defineProperty(exports, \"getContractAddress\", { enumerable: true, get: function () { return lib$6.getContractAddress; } });\n\tObject.defineProperty(exports, \"getIcapAddress\", { enumerable: true, get: function () { return lib$6.getIcapAddress; } });\n\tObject.defineProperty(exports, \"isAddress\", { enumerable: true, get: function () { return lib$6.isAddress; } });\n\tvar base64 = __importStar(lib$p);\n\texports.base64 = base64;\n\n\tObject.defineProperty(exports, \"base58\", { enumerable: true, get: function () { return lib$g.Base58; } });\n\n\tObject.defineProperty(exports, \"arrayify\", { enumerable: true, get: function () { return lib$1.arrayify; } });\n\tObject.defineProperty(exports, \"concat\", { enumerable: true, get: function () { return lib$1.concat; } });\n\tObject.defineProperty(exports, \"hexConcat\", { enumerable: true, get: function () { return lib$1.hexConcat; } });\n\tObject.defineProperty(exports, \"hexDataSlice\", { enumerable: true, get: function () { return lib$1.hexDataSlice; } });\n\tObject.defineProperty(exports, \"hexDataLength\", { enumerable: true, get: function () { return lib$1.hexDataLength; } });\n\tObject.defineProperty(exports, \"hexlify\", { enumerable: true, get: function () { return lib$1.hexlify; } });\n\tObject.defineProperty(exports, \"hexStripZeros\", { enumerable: true, get: function () { return lib$1.hexStripZeros; } });\n\tObject.defineProperty(exports, \"hexValue\", { enumerable: true, get: function () { return lib$1.hexValue; } });\n\tObject.defineProperty(exports, \"hexZeroPad\", { enumerable: true, get: function () { return lib$1.hexZeroPad; } });\n\tObject.defineProperty(exports, \"isBytes\", { enumerable: true, get: function () { return lib$1.isBytes; } });\n\tObject.defineProperty(exports, \"isBytesLike\", { enumerable: true, get: function () { return lib$1.isBytesLike; } });\n\tObject.defineProperty(exports, \"isHexString\", { enumerable: true, get: function () { return lib$1.isHexString; } });\n\tObject.defineProperty(exports, \"joinSignature\", { enumerable: true, get: function () { return lib$1.joinSignature; } });\n\tObject.defineProperty(exports, \"zeroPad\", { enumerable: true, get: function () { return lib$1.zeroPad; } });\n\tObject.defineProperty(exports, \"splitSignature\", { enumerable: true, get: function () { return lib$1.splitSignature; } });\n\tObject.defineProperty(exports, \"stripZeros\", { enumerable: true, get: function () { return lib$1.stripZeros; } });\n\n\tObject.defineProperty(exports, \"_TypedDataEncoder\", { enumerable: true, get: function () { return lib$9._TypedDataEncoder; } });\n\tObject.defineProperty(exports, \"hashMessage\", { enumerable: true, get: function () { return lib$9.hashMessage; } });\n\tObject.defineProperty(exports, \"id\", { enumerable: true, get: function () { return lib$9.id; } });\n\tObject.defineProperty(exports, \"isValidName\", { enumerable: true, get: function () { return lib$9.isValidName; } });\n\tObject.defineProperty(exports, \"namehash\", { enumerable: true, get: function () { return lib$9.namehash; } });\n\n\tObject.defineProperty(exports, \"defaultPath\", { enumerable: true, get: function () { return lib$k.defaultPath; } });\n\tObject.defineProperty(exports, \"entropyToMnemonic\", { enumerable: true, get: function () { return lib$k.entropyToMnemonic; } });\n\tObject.defineProperty(exports, \"getAccountPath\", { enumerable: true, get: function () { return lib$k.getAccountPath; } });\n\tObject.defineProperty(exports, \"HDNode\", { enumerable: true, get: function () { return lib$k.HDNode; } });\n\tObject.defineProperty(exports, \"isValidMnemonic\", { enumerable: true, get: function () { return lib$k.isValidMnemonic; } });\n\tObject.defineProperty(exports, \"mnemonicToEntropy\", { enumerable: true, get: function () { return lib$k.mnemonicToEntropy; } });\n\tObject.defineProperty(exports, \"mnemonicToSeed\", { enumerable: true, get: function () { return lib$k.mnemonicToSeed; } });\n\n\tObject.defineProperty(exports, \"getJsonWalletAddress\", { enumerable: true, get: function () { return lib$m.getJsonWalletAddress; } });\n\n\tObject.defineProperty(exports, \"keccak256\", { enumerable: true, get: function () { return lib$4.keccak256; } });\n\n\tObject.defineProperty(exports, \"Logger\", { enumerable: true, get: function () { return lib.Logger; } });\n\n\tObject.defineProperty(exports, \"computeHmac\", { enumerable: true, get: function () { return lib$h.computeHmac; } });\n\tObject.defineProperty(exports, \"ripemd160\", { enumerable: true, get: function () { return lib$h.ripemd160; } });\n\tObject.defineProperty(exports, \"sha256\", { enumerable: true, get: function () { return lib$h.sha256; } });\n\tObject.defineProperty(exports, \"sha512\", { enumerable: true, get: function () { return lib$h.sha512; } });\n\n\tObject.defineProperty(exports, \"solidityKeccak256\", { enumerable: true, get: function () { return lib$s.keccak256; } });\n\tObject.defineProperty(exports, \"solidityPack\", { enumerable: true, get: function () { return lib$s.pack; } });\n\tObject.defineProperty(exports, \"soliditySha256\", { enumerable: true, get: function () { return lib$s.sha256; } });\n\n\tObject.defineProperty(exports, \"randomBytes\", { enumerable: true, get: function () { return lib$l.randomBytes; } });\n\tObject.defineProperty(exports, \"shuffled\", { enumerable: true, get: function () { return lib$l.shuffled; } });\n\n\tObject.defineProperty(exports, \"checkProperties\", { enumerable: true, get: function () { return lib$3.checkProperties; } });\n\tObject.defineProperty(exports, \"deepCopy\", { enumerable: true, get: function () { return lib$3.deepCopy; } });\n\tObject.defineProperty(exports, \"defineReadOnly\", { enumerable: true, get: function () { return lib$3.defineReadOnly; } });\n\tObject.defineProperty(exports, \"getStatic\", { enumerable: true, get: function () { return lib$3.getStatic; } });\n\tObject.defineProperty(exports, \"resolveProperties\", { enumerable: true, get: function () { return lib$3.resolveProperties; } });\n\tObject.defineProperty(exports, \"shallowCopy\", { enumerable: true, get: function () { return lib$3.shallowCopy; } });\n\tvar RLP = __importStar(lib$5);\n\texports.RLP = RLP;\n\n\tObject.defineProperty(exports, \"computePublicKey\", { enumerable: true, get: function () { return lib$d.computePublicKey; } });\n\tObject.defineProperty(exports, \"recoverPublicKey\", { enumerable: true, get: function () { return lib$d.recoverPublicKey; } });\n\tObject.defineProperty(exports, \"SigningKey\", { enumerable: true, get: function () { return lib$d.SigningKey; } });\n\n\tObject.defineProperty(exports, \"formatBytes32String\", { enumerable: true, get: function () { return lib$8.formatBytes32String; } });\n\tObject.defineProperty(exports, \"nameprep\", { enumerable: true, get: function () { return lib$8.nameprep; } });\n\tObject.defineProperty(exports, \"parseBytes32String\", { enumerable: true, get: function () { return lib$8.parseBytes32String; } });\n\tObject.defineProperty(exports, \"_toEscapedUtf8String\", { enumerable: true, get: function () { return lib$8._toEscapedUtf8String; } });\n\tObject.defineProperty(exports, \"toUtf8Bytes\", { enumerable: true, get: function () { return lib$8.toUtf8Bytes; } });\n\tObject.defineProperty(exports, \"toUtf8CodePoints\", { enumerable: true, get: function () { return lib$8.toUtf8CodePoints; } });\n\tObject.defineProperty(exports, \"toUtf8String\", { enumerable: true, get: function () { return lib$8.toUtf8String; } });\n\tObject.defineProperty(exports, \"Utf8ErrorFuncs\", { enumerable: true, get: function () { return lib$8.Utf8ErrorFuncs; } });\n\n\tObject.defineProperty(exports, \"accessListify\", { enumerable: true, get: function () { return lib$e.accessListify; } });\n\tObject.defineProperty(exports, \"computeAddress\", { enumerable: true, get: function () { return lib$e.computeAddress; } });\n\tObject.defineProperty(exports, \"parseTransaction\", { enumerable: true, get: function () { return lib$e.parse; } });\n\tObject.defineProperty(exports, \"recoverAddress\", { enumerable: true, get: function () { return lib$e.recoverAddress; } });\n\tObject.defineProperty(exports, \"serializeTransaction\", { enumerable: true, get: function () { return lib$e.serialize; } });\n\tObject.defineProperty(exports, \"TransactionTypes\", { enumerable: true, get: function () { return lib$e.TransactionTypes; } });\n\n\tObject.defineProperty(exports, \"commify\", { enumerable: true, get: function () { return lib$t.commify; } });\n\tObject.defineProperty(exports, \"formatEther\", { enumerable: true, get: function () { return lib$t.formatEther; } });\n\tObject.defineProperty(exports, \"parseEther\", { enumerable: true, get: function () { return lib$t.parseEther; } });\n\tObject.defineProperty(exports, \"formatUnits\", { enumerable: true, get: function () { return lib$t.formatUnits; } });\n\tObject.defineProperty(exports, \"parseUnits\", { enumerable: true, get: function () { return lib$t.parseUnits; } });\n\n\tObject.defineProperty(exports, \"verifyMessage\", { enumerable: true, get: function () { return lib$n.verifyMessage; } });\n\tObject.defineProperty(exports, \"verifyTypedData\", { enumerable: true, get: function () { return lib$n.verifyTypedData; } });\n\n\tObject.defineProperty(exports, \"_fetchData\", { enumerable: true, get: function () { return lib$q._fetchData; } });\n\tObject.defineProperty(exports, \"fetchJson\", { enumerable: true, get: function () { return lib$q.fetchJson; } });\n\tObject.defineProperty(exports, \"poll\", { enumerable: true, get: function () { return lib$q.poll; } });\n\t////////////////////////\n\t// Enums\n\tvar sha2_2 = lib$h;\n\tObject.defineProperty(exports, \"SupportedAlgorithm\", { enumerable: true, get: function () { return sha2_2.SupportedAlgorithm; } });\n\tvar strings_2 = lib$8;\n\tObject.defineProperty(exports, \"UnicodeNormalizationForm\", { enumerable: true, get: function () { return strings_2.UnicodeNormalizationForm; } });\n\tObject.defineProperty(exports, \"Utf8ErrorReason\", { enumerable: true, get: function () { return strings_2.Utf8ErrorReason; } });\n\n\t});\n\n\tvar utils$4 = /*@__PURE__*/getDefaultExportFromCjs(utils$3);\n\n\tvar _version$O = createCommonjsModule(function (module, exports) {\n\t\"use strict\";\n\tObject.defineProperty(exports, \"__esModule\", { value: true });\n\texports.version = void 0;\n\texports.version = \"ethers/5.5.1\";\n\n\t});\n\n\tvar _version$P = /*@__PURE__*/getDefaultExportFromCjs(_version$O);\n\n\tvar ethers = createCommonjsModule(function (module, exports) {\n\t\"use strict\";\n\tvar __createBinding = (commonjsGlobal && commonjsGlobal.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n\t    if (k2 === undefined) k2 = k;\n\t    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\n\t}) : (function(o, m, k, k2) {\n\t    if (k2 === undefined) k2 = k;\n\t    o[k2] = m[k];\n\t}));\n\tvar __setModuleDefault = (commonjsGlobal && commonjsGlobal.__setModuleDefault) || (Object.create ? (function(o, v) {\n\t    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n\t}) : function(o, v) {\n\t    o[\"default\"] = v;\n\t});\n\tvar __importStar = (commonjsGlobal && commonjsGlobal.__importStar) || function (mod) {\n\t    if (mod && mod.__esModule) return mod;\n\t    var result = {};\n\t    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n\t    __setModuleDefault(result, mod);\n\t    return result;\n\t};\n\tObject.defineProperty(exports, \"__esModule\", { value: true });\n\texports.Wordlist = exports.version = exports.wordlists = exports.utils = exports.logger = exports.errors = exports.constants = exports.FixedNumber = exports.BigNumber = exports.ContractFactory = exports.Contract = exports.BaseContract = exports.providers = exports.getDefaultProvider = exports.VoidSigner = exports.Wallet = exports.Signer = void 0;\n\n\tObject.defineProperty(exports, \"BaseContract\", { enumerable: true, get: function () { return lib$f.BaseContract; } });\n\tObject.defineProperty(exports, \"Contract\", { enumerable: true, get: function () { return lib$f.Contract; } });\n\tObject.defineProperty(exports, \"ContractFactory\", { enumerable: true, get: function () { return lib$f.ContractFactory; } });\n\n\tObject.defineProperty(exports, \"BigNumber\", { enumerable: true, get: function () { return lib$2.BigNumber; } });\n\tObject.defineProperty(exports, \"FixedNumber\", { enumerable: true, get: function () { return lib$2.FixedNumber; } });\n\n\tObject.defineProperty(exports, \"Signer\", { enumerable: true, get: function () { return lib$c.Signer; } });\n\tObject.defineProperty(exports, \"VoidSigner\", { enumerable: true, get: function () { return lib$c.VoidSigner; } });\n\n\tObject.defineProperty(exports, \"Wallet\", { enumerable: true, get: function () { return lib$n.Wallet; } });\n\tvar constants = __importStar(lib$7);\n\texports.constants = constants;\n\tvar providers = __importStar(lib$r);\n\texports.providers = providers;\n\tvar providers_1 = lib$r;\n\tObject.defineProperty(exports, \"getDefaultProvider\", { enumerable: true, get: function () { return providers_1.getDefaultProvider; } });\n\n\tObject.defineProperty(exports, \"Wordlist\", { enumerable: true, get: function () { return lib$j.Wordlist; } });\n\tObject.defineProperty(exports, \"wordlists\", { enumerable: true, get: function () { return lib$j.wordlists; } });\n\tvar utils = __importStar(utils$3);\n\texports.utils = utils;\n\n\tObject.defineProperty(exports, \"errors\", { enumerable: true, get: function () { return lib.ErrorCode; } });\n\t////////////////////////\n\t// Compile-Time Constants\n\t// This is generated by \"npm run dist\"\n\n\tObject.defineProperty(exports, \"version\", { enumerable: true, get: function () { return _version$O.version; } });\n\tvar logger = new lib.Logger(_version$O.version);\n\texports.logger = logger;\n\n\t});\n\n\tvar ethers$1 = /*@__PURE__*/getDefaultExportFromCjs(ethers);\n\n\tvar lib$u = createCommonjsModule(function (module, exports) {\n\t\"use strict\";\n\tvar __createBinding = (commonjsGlobal && commonjsGlobal.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n\t    if (k2 === undefined) k2 = k;\n\t    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\n\t}) : (function(o, m, k, k2) {\n\t    if (k2 === undefined) k2 = k;\n\t    o[k2] = m[k];\n\t}));\n\tvar __setModuleDefault = (commonjsGlobal && commonjsGlobal.__setModuleDefault) || (Object.create ? (function(o, v) {\n\t    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n\t}) : function(o, v) {\n\t    o[\"default\"] = v;\n\t});\n\tvar __importStar = (commonjsGlobal && commonjsGlobal.__importStar) || function (mod) {\n\t    if (mod && mod.__esModule) return mod;\n\t    var result = {};\n\t    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n\t    __setModuleDefault(result, mod);\n\t    return result;\n\t};\n\tObject.defineProperty(exports, \"__esModule\", { value: true });\n\texports.Wordlist = exports.version = exports.wordlists = exports.utils = exports.logger = exports.errors = exports.constants = exports.FixedNumber = exports.BigNumber = exports.ContractFactory = exports.Contract = exports.BaseContract = exports.providers = exports.getDefaultProvider = exports.VoidSigner = exports.Wallet = exports.Signer = exports.ethers = void 0;\n\t// To modify this file, you must update ./misc/admin/lib/cmds/update-exports.js\n\tvar ethers$1 = __importStar(ethers);\n\texports.ethers = ethers$1;\n\ttry {\n\t    var anyGlobal = window;\n\t    if (anyGlobal._ethers == null) {\n\t        anyGlobal._ethers = ethers$1;\n\t    }\n\t}\n\tcatch (error) { }\n\tvar ethers_1 = ethers;\n\tObject.defineProperty(exports, \"Signer\", { enumerable: true, get: function () { return ethers_1.Signer; } });\n\tObject.defineProperty(exports, \"Wallet\", { enumerable: true, get: function () { return ethers_1.Wallet; } });\n\tObject.defineProperty(exports, \"VoidSigner\", { enumerable: true, get: function () { return ethers_1.VoidSigner; } });\n\tObject.defineProperty(exports, \"getDefaultProvider\", { enumerable: true, get: function () { return ethers_1.getDefaultProvider; } });\n\tObject.defineProperty(exports, \"providers\", { enumerable: true, get: function () { return ethers_1.providers; } });\n\tObject.defineProperty(exports, \"BaseContract\", { enumerable: true, get: function () { return ethers_1.BaseContract; } });\n\tObject.defineProperty(exports, \"Contract\", { enumerable: true, get: function () { return ethers_1.Contract; } });\n\tObject.defineProperty(exports, \"ContractFactory\", { enumerable: true, get: function () { return ethers_1.ContractFactory; } });\n\tObject.defineProperty(exports, \"BigNumber\", { enumerable: true, get: function () { return ethers_1.BigNumber; } });\n\tObject.defineProperty(exports, \"FixedNumber\", { enumerable: true, get: function () { return ethers_1.FixedNumber; } });\n\tObject.defineProperty(exports, \"constants\", { enumerable: true, get: function () { return ethers_1.constants; } });\n\tObject.defineProperty(exports, \"errors\", { enumerable: true, get: function () { return ethers_1.errors; } });\n\tObject.defineProperty(exports, \"logger\", { enumerable: true, get: function () { return ethers_1.logger; } });\n\tObject.defineProperty(exports, \"utils\", { enumerable: true, get: function () { return ethers_1.utils; } });\n\tObject.defineProperty(exports, \"wordlists\", { enumerable: true, get: function () { return ethers_1.wordlists; } });\n\t////////////////////////\n\t// Compile-Time Constants\n\tObject.defineProperty(exports, \"version\", { enumerable: true, get: function () { return ethers_1.version; } });\n\tObject.defineProperty(exports, \"Wordlist\", { enumerable: true, get: function () { return ethers_1.Wordlist; } });\n\n\t});\n\n\tvar index$u = /*@__PURE__*/getDefaultExportFromCjs(lib$u);\n\n\treturn index$u;\n\n})));\n//# sourceMappingURL=ethers.umd.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vbm9kZV9tb2R1bGVzL2V0aGVycy9kaXN0L2V0aGVycy51bWQuanMuanMiLCJtYXBwaW5ncyI6IjtBQUFBO0FBQ0EsQ0FBQyxLQUE0RDtBQUM3RCxDQUFDLENBQ3FHO0FBQ3RHLENBQUMsc0JBQXNCOztBQUV2Qix1SEFBdUgscUJBQU0sbUJBQW1CLHFCQUFNOztBQUV0SjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxrQ0FBa0MsaUJBQWlCLFlBQVk7QUFDL0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0osR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsMENBQTBDO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxxQkFBcUIsaUJBQWlCO0FBQ3RDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLFFBQVE7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLDBCQUEwQixtQkFBbUI7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixpQkFBaUI7QUFDdEM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG1DQUFtQyxZQUFZO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSwyREFBMkQsbUJBQW1CO0FBQzlFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixTQUFTO0FBQ2xDOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esd0NBQXdDLHNCQUFzQjtBQUM5RDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx5QkFBeUIsU0FBUztBQUNsQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxtQkFBbUIsU0FBUztBQUM1QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EscUJBQXFCLGlCQUFpQjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLGlCQUFpQjtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Es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O0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLHFCQUFxQixTQUFTO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzREFBc0QsV0FBVztBQUNqRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHFCQUFxQixvQkFBb0I7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0RBQXNELFdBQVc7QUFDakU7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxPQUFPO0FBQ1A7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLE9BQU87QUFDNUI7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHFCQUFxQixPQUFPO0FBQzVCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixPQUFPO0FBQzVCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEscUJBQXFCLE9BQU87QUFDNUI7O0FBRUE7QUFDQTs7QUFFQSx1QkFBdUIsT0FBTztBQUM5QjtBQUNBOztBQUVBLHlCQUF5QixPQUFPO0FBQ2hDO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsR0FBRztBQUM1QjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxxQkFBcUIsV0FBVztBQUNoQzs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxxQkFBcUIsV0FBVztBQUNoQztBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EscUJBQXFCLFNBQVM7QUFDOUI7O0FBRUEsb0NBQW9DO0FBQ3BDLHdDQUF3QztBQUN4Qzs7QUFFQTtBQUNBLHVCQUF1QixPQUFPO0FBQzlCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxxQkFBcUIsT0FBTztBQUM1QjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBLHFCQUFxQixPQUFPO0FBQzVCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxxQkFBcUIsaUJBQWlCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHFCQUFxQixjQUFjO0FBQ25DO0FBQ0E7O0FBRUE7QUFDQSwrQkFBK0IsY0FBYztBQUM3Qzs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLG1CQUFtQixpQkFBaUI7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsaUNBQWlDLFFBQVE7QUFDekM7QUFDQTs7QUFFQSxtQkFBbUIsT0FBTztBQUMxQjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx1QkFBdUIsT0FBTztBQUM5QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsbUJBQW1CLGlCQUFpQjtBQUNwQztBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLCtCQUErQixtQ0FBbUM7QUFDbEU7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EscUJBQXFCLCtDQUErQztBQUNwRTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSx1QkFBdUIsc0NBQXNDO0FBQzdEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsaUJBQWlCLGdCQUFnQjtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLHlCQUF5QjtBQUNyQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsaUJBQWlCO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixjQUFjO0FBQ3JDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx5QkFBeUIsUUFBUTtBQUNqQztBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxtQ0FBbUMsUUFBUTtBQUMzQztBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsbUNBQW1DLFFBQVE7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsK0JBQStCLG1DQUFtQztBQUNsRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSwrQkFBK0IsbUNBQW1DO0FBQ2xFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsK0JBQStCLG1DQUFtQztBQUNsRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLCtCQUErQixtQ0FBbUM7QUFDbEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EseUJBQXlCLDBCQUEwQjtBQUNuRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQSxPQUFPOztBQUVQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxxQkFBcUIsZ0NBQWdDO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxtQ0FBbUMsUUFBUTtBQUMzQztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHFCQUFxQixZQUFZO0FBQ2pDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxrQkFBa0Isa0JBQWtCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHFCQUFxQixnQkFBZ0I7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsZ0JBQWdCO0FBQ3JDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLE9BQU87QUFDUDtBQUNBLE9BQU87QUFDUDtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFD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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLGtCQUFrQjtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0RBQWtELGdCQUFnQjtBQUNsRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrRUFBa0U7QUFDbEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEVBQUU7O0FBRUY7O0FBRUE7QUFDQTtBQUNBLGdEQUFnRCxhQUFhO0FBQzdEO0FBQ0E7O0FBRUEsRUFBRTs7QUFFRjs7QUFFQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEM7QUFDOUM7QUFDQSxnREFBZ0QsYUFBYTtBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0VBQWtFO0FBQ2xFO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFGQUFxRjtBQUNyRjtBQUNBO0FBQ0E7QUFDQSx1RkFBdUYsdUVBQXVFO0FBQzlKO0FBQ0E7QUFDQSw2SEFBNkg7QUFDN0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxFQUFFOztBQUVGOztBQUVBO0FBQ0E7QUFDQSxnREFBZ0QsYUFBYTtBQUM3RDs7OztBQUlBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0VBQW9FO0FBQ3BFO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9FQUFvRTtBQUNwRTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2REFBNkQ7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvREFBb0Q7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5REFBeUQ7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTs7QUFFQSxFQUFFOztBQUVGOztBQUVBO0FBQ0E7QUFDQSxnREFBZ0QsYUFBYTtBQUM3RDs7QUFFQSwrQ0FBK0MscUNBQXFDLCtCQUErQjs7QUFFbkgsaURBQWlELHFDQUFxQyxtQ0FBbUM7QUFDekgsaURBQWlELHFDQUFxQyxtQ0FBbUM7QUFDekgsaURBQWlELHFDQUFxQyxtQ0FBbUM7QUFDekgsZ0RBQWdELHFDQUFxQyxrQ0FBa0M7QUFDdkg7QUFDQTtBQUNBLGlEQUFpRCxxQ0FBcUMsbUNBQW1DO0FBQ3pILGlEQUFpRCxxQ0FBcUMsbUNBQW1DOztBQUV6SCxFQUFFOztBQUVGOztBQUVBO0FBQ0E7QUFDQSxnREFBZ0QsYUFBYTtBQUM3RDtBQUNBOztBQUVBLEVBQUU7O0FBRUY7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLCtEQUErRCxpQkFBaUI7QUFDN0c7QUFDQSxxQ0FBcUMsTUFBTSwrQkFBK0IsWUFBWTtBQUN0RixvQ0FBb0MsTUFBTSxtQ0FBbUMsWUFBWTtBQUN6RixpQ0FBaUM7QUFDakM7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLGVBQWUsNkJBQTZCLDBCQUEwQixjQUFjLHFCQUFxQjtBQUN6RyxrQkFBa0Isb0RBQW9ELHFFQUFxRSxjQUFjO0FBQ3pKLHdCQUF3QixzQkFBc0I7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDO0FBQ3pDLG9DQUFvQyxTQUFTO0FBQzdDLG9DQUFvQyxXQUFXLFVBQVU7QUFDekQsMkNBQTJDLGNBQWM7QUFDekQ7QUFDQSwrR0FBK0csT0FBTztBQUN0SCxrRkFBa0YsaUJBQWlCO0FBQ25HLDBEQUEwRCxnQkFBZ0IsUUFBUTtBQUNsRixnREFBZ0QsZ0JBQWdCLGdCQUFnQjtBQUNoRjtBQUNBLG1DQUFtQztBQUNuQztBQUNBO0FBQ0EsV0FBVyxZQUFZLGFBQWEsU0FBUyxVQUFVO0FBQ3ZELHFDQUFxQyxTQUFTO0FBQzlDO0FBQ0E7QUFDQSxnREFBZ0QsYUFBYTtBQUM3RDs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLFFBQVE7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyRUFBMkUsVUFBVSxvQkFBb0IsSUFBSTtBQUM3RyxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLElBQUk7QUFDOUI7QUFDQSxVQUFVO0FBQ1YsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLGlCQUFpQjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJEQUEyRCx3QkFBd0I7QUFDbkY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7O0FBRUEsRUFBRTs7QUFFRjs7QUFFQTtBQUNBO0FBQ0EsZ0RBQWdELGFBQWE7QUFDN0Q7QUFDQTs7QUFFQSxFQUFFOztBQUVGOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsZ0JBQWdCLHNDQUFzQyxrQkFBa0I7QUFDeEYsK0JBQStCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0EsRUFBRTtBQUNGLGdEQUFnRCxhQUFhO0FBQzdEOzs7OztBQUtBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4Qix1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQiw2Q0FBNkM7QUFDbkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQiw2QkFBNkI7QUFDakQ7QUFDQSxxQkFBcUIsa0JBQWtCO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixrREFBa0Q7QUFDdkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2RUFBNkUseUNBQXlDO0FBQ3RIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1RUFBdUUsNkJBQTZCO0FBQ3BHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBLHVEQUF1RCxpREFBaUQ7QUFDeEc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0REFBNEQsMENBQTBDO0FBQ3RHLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0VBQXdFLDhCQUE4QjtBQUN0RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1EQUFtRDtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0REFBNEQsMENBQTBDO0FBQ3RHLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBLDBFQUEwRSw4QkFBOEI7QUFDeEc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDREQUE0RCwwQ0FBMEM7QUFDdEcsK0RBQStELDJDQUEyQztBQUMxRyxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdFQUF3RSw4QkFBOEI7QUFDdEc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4RUFBOEUsK0JBQStCO0FBQzdHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDREQUE0RCwwQ0FBMEM7QUFDdEcsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3RUFBd0UsOEJBQThCO0FBQ3RHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixvQ0FBb0M7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLFFBQVE7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNERBQTREO0FBQzVELHFEQUFxRDtBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVFQUF1RSxtQ0FBbUM7QUFDMUc7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxSEFBcUgsNkJBQTZCO0FBQ2xKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNGQUFzRjtBQUN0RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBEQUEwRCxtQ0FBbUM7QUFDN0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9HQUFvRyw4REFBOEQ7QUFDbEs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUVBQW1FLG1DQUFtQztBQUN0RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbURBQW1ELDhCQUE4QjtBQUNqRjtBQUNBO0FBQ0EsbURBQW1ELHVEQUF1RDtBQUMxRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QztBQUM1QyxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDO0FBQ3hDLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsbUJBQW1CO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrREFBa0Q7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGOztBQUVBLEVBQUU7O0FBRUY7O0FBRUE7QUFDQTtBQUNBLGdEQUFnRCxhQUFhO0FBQzdEOztBQUVBLHlEQUF5RCxxQ0FBcUMseUNBQXlDO0FBQ3ZJLG1EQUFtRCxxQ0FBcUMsbUNBQW1DO0FBQzNILG1EQUFtRCxxQ0FBcUMsbUNBQW1DO0FBQzNILGlEQUFpRCxxQ0FBcUMsaUNBQWlDO0FBQ3ZILDhDQUE4QyxxQ0FBcUMsOEJBQThCO0FBQ2pILHNEQUFzRCxxQ0FBcUMsc0NBQXNDO0FBQ2pJLCtDQUErQyxxQ0FBcUMsK0JBQStCOztBQUVuSCw4Q0FBOEMscUNBQXFDLDZCQUE2QjtBQUNoSCxxREFBcUQscUNBQXFDLG9DQUFvQzs7QUFFOUgsdURBQXVELHFDQUFxQyx3Q0FBd0M7QUFDcEksNkNBQTZDLHFDQUFxQyw4QkFBOEI7QUFDaEgsK0NBQStDLHFDQUFxQyxnQ0FBZ0M7QUFDcEgsb0RBQW9ELHFDQUFxQyxxQ0FBcUM7QUFDOUgsNERBQTRELHFDQUFxQyw2Q0FBNkM7O0FBRTlJLEVBQUU7O0FBRUY7O0FBRUE7QUFDQTtBQUNBLGdEQUFnRCxhQUFhO0FBQzdEO0FBQ0E7O0FBRUEsRUFBRTs7QUFFRjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLGdCQUFnQixzQ0FBc0Msa0JBQWtCO0FBQ3hGLCtCQUErQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBLDZCQUE2QiwrREFBK0QsaUJBQWlCO0FBQzdHO0FBQ0EscUNBQXFDLE1BQU0sK0JBQStCLFlBQVk7QUFDdEYsb0NBQW9DLE1BQU0sbUNBQW1DLFlBQVk7QUFDekYsaUNBQWlDO0FBQ2pDO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxlQUFlLDZCQUE2QiwwQkFBMEIsY0FBYyxxQkFBcUI7QUFDekcsa0JBQWtCLG9EQUFvRCxxRUFBcUUsY0FBYztBQUN6Six3QkFBd0Isc0JBQXNCO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QztBQUN6QyxvQ0FBb0MsU0FBUztBQUM3QyxvQ0FBb0MsV0FBVyxVQUFVO0FBQ3pELDJDQUEyQyxjQUFjO0FBQ3pEO0FBQ0EsK0dBQStHLE9BQU87QUFDdEgsa0ZBQWtGLGlCQUFpQjtBQUNuRywwREFBMEQsZ0JBQWdCLFFBQVE7QUFDbEYsZ0RBQWdELGdCQUFnQixnQkFBZ0I7QUFDaEY7QUFDQSxtQ0FBbUM7QUFDbkM7QUFDQTtBQUNBLFdBQVcsWUFBWSxhQUFhLFNBQVMsVUFBVTtBQUN2RCxxQ0FBcUMsU0FBUztBQUM5QztBQUNBO0FBQ0EsZ0RBQWdELGFBQWE7QUFDN0Q7Ozs7OztBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEI7QUFDOUIsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaURBQWlELDRGQUE0RjtBQUM3STtBQUNBLGNBQWM7QUFDZCxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7O0FBRUEsRUFBRTs7QUFFRjs7QUFFQTtBQUNBO0FBQ0EsZ0RBQWdELGFBQWE7QUFDN0Q7QUFDQTs7QUFFQSxFQUFFOztBQUVGOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsZ0JBQWdCLHNDQUFzQyxrQkFBa0I7QUFDeEYsK0JBQStCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0EsNkJBQTZCLCtEQUErRCxpQkFBaUI7QUFDN0c7QUFDQSxxQ0FBcUMsTUFBTSwrQkFBK0IsWUFBWTtBQUN0RixvQ0FBb0MsTUFBTSxtQ0FBbUMsWUFBWTtBQUN6RixpQ0FBaUM7QUFDakM7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLGVBQWUsNkJBQTZCLDBCQUEwQixjQUFjLHFCQUFxQjtBQUN6RyxrQkFBa0Isb0RBQW9ELHFFQUFxRSxjQUFjO0FBQ3pKLHdCQUF3QixzQkFBc0I7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDO0FBQ3pDLG9DQUFvQyxTQUFTO0FBQzdDLG9DQUFvQyxXQUFXLFVBQVU7QUFDekQsMkNBQTJDLGNBQWM7QUFDekQ7QUFDQSwrR0FBK0csT0FBTztBQUN0SCxrRkFBa0YsaUJBQWlCO0FBQ25HLDBEQUEwRCxnQkFBZ0IsUUFBUTtBQUNsRixnREFBZ0QsZ0JBQWdCLGdCQUFnQjtBQUNoRjtBQUNBLG1DQUFtQztBQUNuQztBQUNBO0FBQ0EsV0FBVyxZQUFZLGFBQWEsU0FBUyxVQUFVO0FBQ3ZELHFDQUFxQyxTQUFTO0FBQzlDO0FBQ0E7QUFDQSxnREFBZ0QsYUFBYTtBQUM3RDs7OztBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZCxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2QsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZCxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2QsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZCxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2QsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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QUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG1CQUFtQixXQUFXO0FBQzlCLHFCQUFxQixVQUFVO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixTQUFTO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG1CQUFtQixPQUFPO0FBQzFCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGOzs7Ozs7O0FBT0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSw2REFBNkQ7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTixLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLE9BQU8sY0FBYztBQUNyQixPQUFPLGNBQWM7QUFDckI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsbUJBQW1CO0FBQzFDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHVCQUF1QixXQUFXO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLFNBQVM7QUFDMUI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxlQUFlLFNBQVM7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7Ozs7O0FBS0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLGdCQUFnQjtBQUN2QztBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLGdCQUFnQjtBQUNuQztBQUNBO0FBQ0EsS0FBSztBQUNMLGlCQUFpQixnQkFBZ0I7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsbUJBQW1CLGdCQUFnQjtBQUNuQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxtQkFBbUIsZ0JBQWdCO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsZ0JBQWdCO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSwwQkFBMEIsZ0JBQWdCO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7OztBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHFCQUFxQixnQkFBZ0I7QUFDckM7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixPQUFPO0FBQzFCOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixvQkFBb0I7QUFDekM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGlCQUFpQixvQkFBb0I7QUFDckM7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7O0FBR0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7Ozs7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLG1CQUFtQixRQUFRO0FBQzNCOztBQUVBLFNBQVMsY0FBYztBQUN2Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGVBQWUsY0FBYztBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUFPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLG1CQUFtQixRQUFRO0FBQzNCO0FBQ0EsVUFBVSxjQUFjO0FBQ3hCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxlQUFlLGNBQWM7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7OztBQUtBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7O0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsbUJBQW1CLFFBQVE7QUFDM0I7QUFDQSxVQUFVLGNBQWM7QUFDeEIsaURBQWlEO0FBQ2pEO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0EsbURBQW1EO0FBQ25EO0FBQ0EsNkJBQTZCO0FBQzdCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsbUJBQW1CLGNBQWM7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHdDQUF3QztBQUN4Qyx3Q0FBd0M7O0FBRXhDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHdDQUF3QztBQUN4Qyx3Q0FBd0M7O0FBRXhDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDOztBQUV4QztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3Qzs7QUFFeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHlDQUF5QztBQUN6Qzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx5Q0FBeUM7QUFDekM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7O0FBTUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7OztBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixRQUFRO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7O0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDRCQUE0QixvQkFBb0I7QUFDaEQ7O0FBRUEsZUFBZSxnQkFBZ0I7QUFDL0I7QUFDQTs7QUFFQTtBQUNBLGVBQWUsZ0JBQWdCO0FBQy9CO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7O0FBRUE7Ozs7OztBQU1BOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsTUFBTTtBQUNOLElBQUk7QUFDSjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRixFQUFFOztBQUVGOzs7Ozs7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxtQkFBbUIsbUJBQW1CO0FBQ3RDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsMkNBQTJDO0FBQzNDOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7QUFJQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxvQkFBb0IscUJBQXFCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLGNBQWM7QUFDZDtBQUNBLGNBQWM7QUFDZDtBQUNBLGNBQWM7O0FBRWQsWUFBWTtBQUNaOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7QUFLQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGtDQUFrQyxjQUFjO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7OztBQU1BLDREQUE0RCxpQ0FBaUM7QUFDN0Y7Ozs7O0FBS0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGlCQUFpQjs7QUFFakI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtB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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtEQUErRDtBQUMvRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxREFBcUQ7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3RkFBd0Y7QUFDeEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEMsdUNBQXVDO0FBQ25GO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdELHdGQUF3RjtBQUN4STtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQSxFQUFFOztBQUVGOztBQUVBO0FBQ0E7QUFDQSxnREFBZ0QsYUFBYTtBQUM3RDtBQUNBOztBQUVBLEVBQUU7O0FBRUY7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixnQkFBZ0Isc0NBQXNDLGtCQUFrQjtBQUN4RiwrQkFBK0I7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQSw2QkFBNkIsK0RBQStELGlCQUFpQjtBQUM3RztBQUNBLHFDQUFxQyxNQUFNLCtCQUErQixZQUFZO0FBQ3RGLG9DQUFvQyxNQUFNLG1DQUFtQyxZQUFZO0FBQ3pGLGlDQUFpQztBQUNqQztBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsZUFBZSw2QkFBNkIsMEJBQTBCLGNBQWMscUJBQXFCO0FBQ3pHLGtCQUFrQixvREFBb0QscUVBQXFFLGNBQWM7QUFDekosd0JBQXdCLHNCQUFzQjtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUM7QUFDekMsb0NBQW9DLFNBQVM7QUFDN0Msb0NBQW9DLFdBQVcsVUFBVTtBQUN6RCwyQ0FBMkMsY0FBYztBQUN6RDtBQUNBLCtHQUErRyxPQUFPO0FBQ3RILGtGQUFrRixpQkFBaUI7QUFDbkcsMERBQTBELGdCQUFnQixRQUFRO0FBQ2xGLGdEQUFnRCxnQkFBZ0IsZ0JBQWdCO0FBQ2hGO0FBQ0EsbUNBQW1DO0FBQ25DO0FBQ0E7QUFDQSxXQUFXLFlBQVksYUFBYSxTQUFTLFVBQVU7QUFDdkQscUNBQXFDLFNBQVM7QUFDOUM7QUFDQTtBQUNBO0FBQ0EsOEVBQThFLE9BQU87QUFDckY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0QsYUFBYTtBQUM3RDs7Ozs7Ozs7Ozs7QUFXQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVixNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0EsK0VBQStFLGdFQUFnRTtBQUMvSTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1YsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLDBCQUEwQjtBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQztBQUMxQztBQUNBO0FBQ0Esa0NBQWtDO0FBQ2xDLDhCQUE4QixJQUFJO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0ZBQXNGO0FBQ3RGLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQyxrQkFBa0I7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0ZBQWdGLGtDQUFrQztBQUNsSDtBQUNBLDZGQUE2RiwyQkFBMkI7QUFDeEg7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1YsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLHVCQUF1QjtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsdUJBQXVCO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVEQUF1RDtBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzREFBc0Q7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLHVCQUF1QjtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2QsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsdUJBQXVCO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsZ0NBQWdDO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbURBQW1ELG9CQUFvQjtBQUN2RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLGtCQUFrQjtBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlEQUF5RDtBQUN6RCwwREFBMEQ7QUFDMUQsd0RBQXdEO0FBQ3hELGtFQUFrRTtBQUNsRSxzREFBc0Q7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLHVCQUF1QjtBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBLDZEQUE2RDtBQUM3RCw0REFBNEQ7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRDtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0M7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUhBQXFILHdDQUF3QztBQUM3SjtBQUNBLHdEQUF3RDtBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9HQUFvRyxnQkFBZ0I7QUFDcEgsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNERBQTREO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVEQUF1RDtBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QztBQUN4Qyw4Q0FBOEM7QUFDOUMscURBQXFEO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUlBQW1JLG1CQUFtQjtBQUN0SjtBQUNBO0FBQ0EsOEVBQThFO0FBQzlFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLG1EQUFtRDtBQUNqRyxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQix1QkFBdUI7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvREFBb0Q7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBLDBCQUEwQix1QkFBdUI7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9HQUFvRyxnQkFBZ0I7QUFDcEgsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQix1QkFBdUI7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixpQkFBaUI7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBLEVBQUU7O0FBRUY7O0FBRUE7QUFDQTtBQUNBLGdEQUFnRCxhQUFhO0FBQzdEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEVBQUU7O0FBRUY7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsNkJBQTZCLFFBQVE7QUFDckM7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsOEJBQThCLFFBQVE7QUFDdEM7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsNkJBQTZCLFFBQVE7QUFDckM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1YsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUEsRUFBRTs7QUFFRjs7QUFFQTtBQUNBO0FBQ0EsZ0RBQWdELGFBQWE7QUFDN0Q7O0FBRUEsc0RBQXNELHFDQUFxQyw2QkFBNkI7O0FBRXhILDBEQUEwRCxxQ0FBcUMsd0NBQXdDO0FBQ3ZJLHVEQUF1RCxxQ0FBcUMscUNBQXFDO0FBQ2pJLHNEQUFzRCxxQ0FBcUMsb0NBQW9DOztBQUUvSCxxREFBcUQscUNBQXFDLDRCQUE0QjtBQUN0SCx5REFBeUQscUNBQXFDLGdDQUFnQztBQUM5SCxxREFBcUQscUNBQXFDLDRCQUE0QjtBQUN0SDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsRUFBRTs7QUFFRjs7QUFFQTtBQUNBO0FBQ0EsZ0RBQWdELGFBQWE7QUFDN0Q7QUFDQTs7QUFFQSxFQUFFOztBQUVGOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsZ0JBQWdCLHNDQUFzQyxrQkFBa0I7QUFDeEYsK0JBQStCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0EsNkJBQTZCLCtEQUErRCxpQkFBaUI7QUFDN0c7QUFDQSxxQ0FBcUMsTUFBTSwrQkFBK0IsWUFBWTtBQUN0RixvQ0FBb0MsTUFBTSxtQ0FBbUMsWUFBWTtBQUN6RixpQ0FBaUM7QUFDakM7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLGVBQWUsNkJBQTZCLDBCQUEwQixjQUFjLHFCQUFxQjtBQUN6RyxrQkFBa0Isb0RBQW9ELHFFQUFxRSxjQUFjO0FBQ3pKLHdCQUF3QixzQkFBc0I7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDO0FBQ3pDLG9DQUFvQyxTQUFTO0FBQzdDLG9DQUFvQyxXQUFXLFVBQVU7QUFDekQsMkNBQTJDLGNBQWM7QUFDekQ7QUFDQSwrR0FBK0csT0FBTztBQUN0SCxrRkFBa0YsaUJBQWlCO0FBQ25HLDBEQUEwRCxnQkFBZ0IsUUFBUTtBQUNsRixnREFBZ0QsZ0JBQWdCLGdCQUFnQjtBQUNoRjtBQUNBLG1DQUFtQztBQUNuQztBQUNBO0FBQ0EsV0FBVyxZQUFZLGFBQWEsU0FBUyxVQUFVO0FBQ3ZELHFDQUFxQyxTQUFTO0FBQzlDO0FBQ0E7QUFDQSxnREFBZ0QsYUFBYTtBQUM3RDs7Ozs7Ozs7Ozs7Ozs7O0FBZUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJFQUEyRSxzQkFBc0I7QUFDakc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkVBQTZFO0FBQzdFO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixJQUFJO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkVBQTZFLGNBQWM7QUFDM0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUVBQW1FO0FBQ25FO0FBQ0EsK0VBQStFLG9CQUFvQjtBQUNuRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrRUFBK0Usc0JBQXNCO0FBQ3JHO0FBQ0EseUVBQXlFLGNBQWM7QUFDdkY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsMEJBQTBCO0FBQ3REO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSw0QkFBNEIsdUNBQXVDO0FBQ25FO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSw0QkFBNEIsc0NBQXNDO0FBQ2xFO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0M7QUFDbEM7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZCxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsRUFBRTs7QUFFRjs7QUFFQTtBQUNBO0FBQ0EsZ0RBQWdELGFBQWE7QUFDN0Q7QUFDQTs7QUFFQSxFQUFFOztBQUVGOztBQUVBO0FBQ0E7QUFDQSxnREFBZ0QsYUFBYTtBQUM3RDs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGlDQUFpQztBQUNyRDtBQUNBO0FBQ0EsZUFBZSw0QkFBNEI7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOLHNCQUFzQixvQ0FBb0M7QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOLGFBQWEsNEJBQTRCO0FBQ3pDLGNBQWMsNkJBQTZCO0FBQzNDLGlCQUFpQixrQ0FBa0M7QUFDbkQsWUFBWSwwQkFBMEI7QUFDdEMsYUFBYSwyQkFBMkI7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZFQUE2RTtBQUM3RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEVBQUU7O0FBRUY7O0FBRUE7QUFDQTtBQUNBLGdEQUFnRCxhQUFhO0FBQzdEOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixxQkFBcUI7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixpQkFBaUI7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxFQUFFOztBQUVGOztBQUVBO0FBQ0E7QUFDQSxnREFBZ0QsYUFBYTtBQUM3RDs7QUFFQSw0Q0FBNEMscUNBQXFDLGdDQUFnQztBQUNqSCw0Q0FBNEMscUNBQXFDLGdDQUFnQzs7QUFFakgsRUFBRTs7QUFFRjs7QUFFQTtBQUNBO0FBQ0EsZ0RBQWdELGFBQWE7QUFDN0Q7QUFDQTs7QUFFQSxFQUFFOztBQUVGOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QiwrREFBK0QsaUJBQWlCO0FBQzdHO0FBQ0EscUNBQXFDLE1BQU0sK0JBQStCLFlBQVk7QUFDdEYsb0NBQW9DLE1BQU0sbUNBQW1DLFlBQVk7QUFDekYsaUNBQWlDO0FBQ2pDO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxlQUFlLDZCQUE2QiwwQkFBMEIsY0FBYyxxQkFBcUI7QUFDekcsa0JBQWtCLG9EQUFvRCxxRUFBcUUsY0FBYztBQUN6Six3QkFBd0Isc0JBQXNCO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QztBQUN6QyxvQ0FBb0MsU0FBUztBQUM3QyxvQ0FBb0MsV0FBVyxVQUFVO0FBQ3pELDJDQUEyQyxjQUFjO0FBQ3pEO0FBQ0EsK0dBQStHLE9BQU87QUFDdEgsa0ZBQWtGLGlCQUFpQjtBQUNuRywwREFBMEQsZ0JBQWdCLFFBQVE7QUFDbEYsZ0RBQWdELGdCQUFnQixnQkFBZ0I7QUFDaEY7QUFDQSxtQ0FBbUM7QUFDbkM7QUFDQTtBQUNBLFdBQVcsWUFBWSxhQUFhLFNBQVMsVUFBVTtBQUN2RCxxQ0FBcUMsU0FBUztBQUM5QztBQUNBO0FBQ0EsZ0RBQWdELGFBQWE7QUFDN0Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdEQUF3RDtBQUN4RDtBQUNBO0FBQ0E7QUFDQSxnREFBZ0Q7QUFDaEQscURBQXFEO0FBQ3JELDhEQUE4RDtBQUM5RCxzREFBc0Q7QUFDdEQsc0RBQXNEO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQSxVQUFVO0FBQ1YsTUFBTTtBQUNOO0FBQ0E7O0FBRUEsRUFBRTs7QUFFRjs7QUFFQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsK0RBQStELGlCQUFpQjtBQUM3RztBQUNBLHFDQUFxQyxNQUFNLCtCQUErQixZQUFZO0FBQ3RGLG9DQUFvQyxNQUFNLG1DQUFtQyxZQUFZO0FBQ3pGLGlDQUFpQztBQUNqQztBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsZUFBZSw2QkFBNkIsMEJBQTBCLGNBQWMscUJBQXFCO0FBQ3pHLGtCQUFrQixvREFBb0QscUVBQXFFLGNBQWM7QUFDekosd0JBQXdCLHNCQUFzQjtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUM7QUFDekMsb0NBQW9DLFNBQVM7QUFDN0Msb0NBQW9DLFdBQVcsVUFBVTtBQUN6RCwyQ0FBMkMsY0FBYztBQUN6RDtBQUNBLCtHQUErRyxPQUFPO0FBQ3RILGtGQUFrRixpQkFBaUI7QUFDbkcsMERBQTBELGdCQUFnQixRQUFRO0FBQ2xGLGdEQUFnRCxnQkFBZ0IsZ0JBQWdCO0FBQ2hGO0FBQ0EsbUNBQW1DO0FBQ25DO0FBQ0E7QUFDQSxXQUFXLFlBQVksYUFBYSxTQUFTLFVBQVU7QUFDdkQscUNBQXFDLFNBQVM7QUFDOUM7QUFDQTtBQUNBLGdEQUFnRCxhQUFhO0FBQzdEOzs7Ozs7O0FBT0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9FQUFvRTtBQUNwRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQztBQUMxQztBQUNBLHVEQUF1RDtBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRDtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkhBQTZILDBFQUEwRTtBQUN2TTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUM7QUFDekM7QUFDQTtBQUNBLDJDQUEyQztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCLGtCQUFrQjtBQUNsQjtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQixNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBLGNBQWM7QUFDZCxVQUFVO0FBQ1YsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtEQUErRCxpQkFBaUI7QUFDaEY7QUFDQSxzRkFBc0YsOENBQThDO0FBQ3BJO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUEsRUFBRTs7QUFFRjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxpQkFBaUIscUJBQXFCO0FBQ3RDOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG1CQUFtQixtQkFBbUI7QUFDdEM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsZUFBZSxtQkFBbUI7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsbUJBQW1CLGtCQUFrQjtBQUNyQztBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxlQUFlLE9BQU87QUFDdEI7QUFDQTtBQUNBOztBQUVBLGVBQWUsT0FBTztBQUN0QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLG1CQUFtQixzQkFBc0I7QUFDekM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxZQUFZO0FBQ1o7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxtQkFBbUIsaUJBQWlCO0FBQ3BDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGdEQUFnRCxhQUFhO0FBQzdEO0FBQ0E7O0FBRUEsRUFBRTs7QUFFRjs7QUFFQTtBQUNBO0FBQ0EsZ0RBQWdELGFBQWE7QUFDN0Q7Ozs7Ozs7OztBQVNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0VBQStFO0FBQy9FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0Q7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QztBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdEQUF3RDtBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlHQUFpRywwQ0FBMEM7QUFDM0k7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDLHlCQUF5QjtBQUN0RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxFQUFFOztBQUVGOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsZ0JBQWdCLHNDQUFzQyxrQkFBa0I7QUFDeEYsK0JBQStCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0EsNkJBQTZCLCtEQUErRCxpQkFBaUI7QUFDN0c7QUFDQSxxQ0FBcUMsTUFBTSwrQkFBK0IsWUFBWTtBQUN0RixvQ0FBb0MsTUFBTSxtQ0FBbUMsWUFBWTtBQUN6RixpQ0FBaUM7QUFDakM7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLGVBQWUsNkJBQTZCLDBCQUEwQixjQUFjLHFCQUFxQjtBQUN6RyxrQkFBa0Isb0RBQW9ELHFFQUFxRSxjQUFjO0FBQ3pKLHdCQUF3QixzQkFBc0I7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDO0FBQ3pDLG9DQUFvQyxTQUFTO0FBQzdDLG9DQUFvQyxXQUFXLFVBQVU7QUFDekQsMkNBQTJDLGNBQWM7QUFDekQ7QUFDQSwrR0FBK0csT0FBTztBQUN0SCxrRkFBa0YsaUJBQWlCO0FBQ25HLDBEQUEwRCxnQkFBZ0IsUUFBUTtBQUNsRixnREFBZ0QsZ0JBQWdCLGdCQUFnQjtBQUNoRjtBQUNBLG1DQUFtQztBQUNuQztBQUNBO0FBQ0EsV0FBVyxZQUFZLGFBQWEsU0FBUyxVQUFVO0FBQ3ZELHFDQUFxQyxTQUFTO0FBQzlDO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QztBQUM5QztBQUNBLGdEQUFnRCxhQUFhO0FBQzdEOzs7Ozs7Ozs7Ozs7QUFZQTs7O0FBR0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksc0RBQXNEO0FBQ2xFLFlBQVksdURBQXVEO0FBQ25FLFlBQVkseUNBQXlDO0FBQ3JELGFBQWEsMkJBQTJCO0FBQ3hDLGFBQWEsMkJBQTJCO0FBQ3hDLGNBQWMsNEJBQTRCO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZCxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3Qyw4QkFBOEI7QUFDdEUsaURBQWlELCtCQUErQjtBQUNoRjtBQUNBLHdDQUF3QywrQkFBK0I7QUFDdkUsaURBQWlELCtCQUErQjtBQUNoRjtBQUNBLHdDQUF3QywrQkFBK0I7QUFDdkUsaURBQWlELDhFQUE4RTtBQUMvSDtBQUNBO0FBQ0Esd0NBQXdDLGlDQUFpQztBQUN6RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0Msb0NBQW9DO0FBQzVFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLDhDQUE4QztBQUN0RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3Qyw0Q0FBNEM7QUFDcEYsdURBQXVELElBQUk7QUFDM0Q7QUFDQSxpRUFBaUUsR0FBRztBQUNwRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLHFEQUFxRDtBQUM3Rix3Q0FBd0Msc0NBQXNDO0FBQzlFLGlEQUFpRCx1Q0FBdUM7QUFDeEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0EsY0FBYztBQUNkLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkLFVBQVU7QUFDVjtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVEQUF1RDtBQUN2RCwrQ0FBK0M7QUFDL0M7QUFDQSxzREFBc0Q7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzREFBc0Q7QUFDdEQ7QUFDQTtBQUNBLHlHQUF5RztBQUN6RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQztBQUN0QztBQUNBO0FBQ0E7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QUFDQTtBQUNBLGNBQWMsc0JBQXNCO0FBQ3BDO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLDBEQUEwRCxlQUFlO0FBQ3pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBEQUEwRCxlQUFlO0FBQ3pFO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkVBQTJFLFNBQVM7QUFDcEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0VBQWdFLHNEQUFzRDtBQUN0SDtBQUNBO0FBQ0E7QUFDQSxxRkFBcUY7QUFDckY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1RUFBdUU7QUFDdkU7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1RUFBdUU7QUFDdkU7QUFD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Q0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQztBQUNsQztBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2QsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQztBQUNsQztBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2QsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2QsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUZBQWlGO0FBQ2pGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZCxVQUFVO0FBQ1Y7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtEQUFrRDtBQUNsRDtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBLHNCQUFzQjtBQUN0QixrQkFBa0I7QUFDbEIsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0EsY0FBYztBQUNkLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFD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SSwrQ0FBK0MscUNBQXFDLDhCQUE4QjtBQUNsSCxrREFBa0QscUNBQXFDLGlDQUFpQztBQUN4SCw4Q0FBOEMscUNBQXFDLDZCQUE2QjtBQUNoSCxxREFBcUQscUNBQXFDLG9DQUFvQztBQUM5SCwrQ0FBK0MscUNBQXFDLDhCQUE4QjtBQUNsSCxpREFBaUQscUNBQXFDLGdDQUFnQztBQUN0SCwrQ0FBK0MscUNBQXFDLDhCQUE4QjtBQUNsSCw0Q0FBNEMscUNBQXFDLDJCQUEyQjtBQUM1Ryw0Q0FBNEMscUNBQXFDLDJCQUEyQjtBQUM1RywyQ0FBMkMscUNBQXFDLDBCQUEwQjtBQUMxRywrQ0FBK0MscUNBQXFDLDhCQUE4QjtBQUNsSDtBQUNBO0FBQ0EsNkNBQTZDLHFDQUFxQyw0QkFBNEI7QUFDOUcsOENBQThDLHFDQUFxQyw2QkFBNkI7O0FBRWhILEVBQUU7O0FBRUY7O0FBRUE7O0FBRUEsQ0FBQztBQUNEIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uLi9ub2RlX21vZHVsZXMvZXRoZXJzL2Rpc3QvZXRoZXJzLnVtZC5qcz81MzFjIl0sInNvdXJjZXNDb250ZW50IjpbIihmdW5jdGlvbiAoZ2xvYmFsLCBmYWN0b3J5KSB7XG5cdHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJyA/IG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeSgpIDpcblx0dHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kID8gZGVmaW5lKGZhY3RvcnkpIDpcblx0KGdsb2JhbCA9IHR5cGVvZiBnbG9iYWxUaGlzICE9PSAndW5kZWZpbmVkJyA/IGdsb2JhbFRoaXMgOiBnbG9iYWwgfHwgc2VsZiwgZ2xvYmFsLmV0aGVycyA9IGZhY3RvcnkoKSk7XG59KHRoaXMsIChmdW5jdGlvbiAoKSB7ICd1c2Ugc3RyaWN0JztcblxuXHR2YXIgY29tbW9uanNHbG9iYWwgPSB0eXBlb2YgZ2xvYmFsVGhpcyAhPT0gJ3VuZGVmaW5lZCcgPyBnbG9iYWxUaGlzIDogdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgPyB3aW5kb3cgOiB0eXBlb2YgZ2xvYmFsICE9PSAndW5kZWZpbmVkJyA/IGdsb2JhbCA6IHR5cGVvZiBzZWxmICE9PSAndW5kZWZpbmVkJyA/IHNlbGYgOiB7fTtcblxuXHRmdW5jdGlvbiBnZXREZWZhdWx0RXhwb3J0RnJvbUNqcyAoeCkge1xuXHRcdHJldHVybiB4ICYmIHguX19lc01vZHVsZSAmJiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoeCwgJ2RlZmF1bHQnKSA/IHhbJ2RlZmF1bHQnXSA6IHg7XG5cdH1cblxuXHRmdW5jdGlvbiBjcmVhdGVDb21tb25qc01vZHVsZShmbiwgYmFzZWRpciwgbW9kdWxlKSB7XG5cdFx0cmV0dXJuIG1vZHVsZSA9IHtcblx0XHRcdHBhdGg6IGJhc2VkaXIsXG5cdFx0XHRleHBvcnRzOiB7fSxcblx0XHRcdHJlcXVpcmU6IGZ1bmN0aW9uIChwYXRoLCBiYXNlKSB7XG5cdFx0XHRcdHJldHVybiBjb21tb25qc1JlcXVpcmUocGF0aCwgKGJhc2UgPT09IHVuZGVmaW5lZCB8fCBiYXNlID09PSBudWxsKSA/IG1vZHVsZS5wYXRoIDogYmFzZSk7XG5cdFx0XHR9XG5cdFx0fSwgZm4obW9kdWxlLCBtb2R1bGUuZXhwb3J0cyksIG1vZHVsZS5leHBvcnRzO1xuXHR9XG5cblx0ZnVuY3Rpb24gZ2V0RGVmYXVsdEV4cG9ydEZyb21OYW1lc3BhY2VJZlByZXNlbnQgKG4pIHtcblx0XHRyZXR1cm4gbiAmJiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwobiwgJ2RlZmF1bHQnKSA/IG5bJ2RlZmF1bHQnXSA6IG47XG5cdH1cblxuXHRmdW5jdGlvbiBnZXREZWZhdWx0RXhwb3J0RnJvbU5hbWVzcGFjZUlmTm90TmFtZWQgKG4pIHtcblx0XHRyZXR1cm4gbiAmJiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwobiwgJ2RlZmF1bHQnKSAmJiBPYmplY3Qua2V5cyhuKS5sZW5ndGggPT09IDEgPyBuWydkZWZhdWx0J10gOiBuO1xuXHR9XG5cblx0ZnVuY3Rpb24gZ2V0QXVnbWVudGVkTmFtZXNwYWNlKG4pIHtcblx0XHRpZiAobi5fX2VzTW9kdWxlKSByZXR1cm4gbjtcblx0XHR2YXIgYSA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh7fSwgJ19fZXNNb2R1bGUnLCB7dmFsdWU6IHRydWV9KTtcblx0XHRPYmplY3Qua2V5cyhuKS5mb3JFYWNoKGZ1bmN0aW9uIChrKSB7XG5cdFx0XHR2YXIgZCA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iobiwgayk7XG5cdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoYSwgaywgZC5nZXQgPyBkIDoge1xuXHRcdFx0XHRlbnVtZXJhYmxlOiB0cnVlLFxuXHRcdFx0XHRnZXQ6IGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0XHRyZXR1cm4gbltrXTtcblx0XHRcdFx0fVxuXHRcdFx0fSk7XG5cdFx0fSk7XG5cdFx0cmV0dXJuIGE7XG5cdH1cblxuXHRmdW5jdGlvbiBjb21tb25qc1JlcXVpcmUgKCkge1xuXHRcdHRocm93IG5ldyBFcnJvcignRHluYW1pYyByZXF1aXJlcyBhcmUgbm90IGN1cnJlbnRseSBzdXBwb3J0ZWQgYnkgQHJvbGx1cC9wbHVnaW4tY29tbW9uanMnKTtcblx0fVxuXG5cdHZhciBibiA9IGNyZWF0ZUNvbW1vbmpzTW9kdWxlKGZ1bmN0aW9uIChtb2R1bGUpIHtcblx0KGZ1bmN0aW9uIChtb2R1bGUsIGV4cG9ydHMpIHtcblx0ICAndXNlIHN0cmljdCc7XG5cblx0ICAvLyBVdGlsc1xuXHQgIGZ1bmN0aW9uIGFzc2VydCAodmFsLCBtc2cpIHtcblx0ICAgIGlmICghdmFsKSB0aHJvdyBuZXcgRXJyb3IobXNnIHx8ICdBc3NlcnRpb24gZmFpbGVkJyk7XG5cdCAgfVxuXG5cdCAgLy8gQ291bGQgdXNlIGBpbmhlcml0c2AgbW9kdWxlLCBidXQgZG9uJ3Qgd2FudCB0byBtb3ZlIGZyb20gc2luZ2xlIGZpbGVcblx0ICAvLyBhcmNoaXRlY3R1cmUgeWV0LlxuXHQgIGZ1bmN0aW9uIGluaGVyaXRzIChjdG9yLCBzdXBlckN0b3IpIHtcblx0ICAgIGN0b3Iuc3VwZXJfID0gc3VwZXJDdG9yO1xuXHQgICAgdmFyIFRlbXBDdG9yID0gZnVuY3Rpb24gKCkge307XG5cdCAgICBUZW1wQ3Rvci5wcm90b3R5cGUgPSBzdXBlckN0b3IucHJvdG90eXBlO1xuXHQgICAgY3Rvci5wcm90b3R5cGUgPSBuZXcgVGVtcEN0b3IoKTtcblx0ICAgIGN0b3IucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gY3Rvcjtcblx0ICB9XG5cblx0ICAvLyBCTlxuXG5cdCAgZnVuY3Rpb24gQk4gKG51bWJlciwgYmFzZSwgZW5kaWFuKSB7XG5cdCAgICBpZiAoQk4uaXNCTihudW1iZXIpKSB7XG5cdCAgICAgIHJldHVybiBudW1iZXI7XG5cdCAgICB9XG5cblx0ICAgIHRoaXMubmVnYXRpdmUgPSAwO1xuXHQgICAgdGhpcy53b3JkcyA9IG51bGw7XG5cdCAgICB0aGlzLmxlbmd0aCA9IDA7XG5cblx0ICAgIC8vIFJlZHVjdGlvbiBjb250ZXh0XG5cdCAgICB0aGlzLnJlZCA9IG51bGw7XG5cblx0ICAgIGlmIChudW1iZXIgIT09IG51bGwpIHtcblx0ICAgICAgaWYgKGJhc2UgPT09ICdsZScgfHwgYmFzZSA9PT0gJ2JlJykge1xuXHQgICAgICAgIGVuZGlhbiA9IGJhc2U7XG5cdCAgICAgICAgYmFzZSA9IDEwO1xuXHQgICAgICB9XG5cblx0ICAgICAgdGhpcy5faW5pdChudW1iZXIgfHwgMCwgYmFzZSB8fCAxMCwgZW5kaWFuIHx8ICdiZScpO1xuXHQgICAgfVxuXHQgIH1cblx0ICBpZiAodHlwZW9mIG1vZHVsZSA9PT0gJ29iamVjdCcpIHtcblx0ICAgIG1vZHVsZS5leHBvcnRzID0gQk47XG5cdCAgfSBlbHNlIHtcblx0ICAgIGV4cG9ydHMuQk4gPSBCTjtcblx0ICB9XG5cblx0ICBCTi5CTiA9IEJOO1xuXHQgIEJOLndvcmRTaXplID0gMjY7XG5cblx0ICB2YXIgQnVmZmVyO1xuXHQgIHRyeSB7XG5cdCAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIHdpbmRvdy5CdWZmZXIgIT09ICd1bmRlZmluZWQnKSB7XG5cdCAgICAgIEJ1ZmZlciA9IHdpbmRvdy5CdWZmZXI7XG5cdCAgICB9IGVsc2Uge1xuXHQgICAgICBCdWZmZXIgPSAvKlJpY01vbzpldGhlcnM6cmVxdWlyZShidWZmZXIpKi8obnVsbCkuQnVmZmVyO1xuXHQgICAgfVxuXHQgIH0gY2F0Y2ggKGUpIHtcblx0ICB9XG5cblx0ICBCTi5pc0JOID0gZnVuY3Rpb24gaXNCTiAobnVtKSB7XG5cdCAgICBpZiAobnVtIGluc3RhbmNlb2YgQk4pIHtcblx0ICAgICAgcmV0dXJuIHRydWU7XG5cdCAgICB9XG5cblx0ICAgIHJldHVybiBudW0gIT09IG51bGwgJiYgdHlwZW9mIG51bSA9PT0gJ29iamVjdCcgJiZcblx0ICAgICAgbnVtLmNvbnN0cnVjdG9yLndvcmRTaXplID09PSBCTi53b3JkU2l6ZSAmJiBBcnJheS5pc0FycmF5KG51bS53b3Jkcyk7XG5cdCAgfTtcblxuXHQgIEJOLm1heCA9IGZ1bmN0aW9uIG1heCAobGVmdCwgcmlnaHQpIHtcblx0ICAgIGlmIChsZWZ0LmNtcChyaWdodCkgPiAwKSByZXR1cm4gbGVmdDtcblx0ICAgIHJldHVybiByaWdodDtcblx0ICB9O1xuXG5cdCAgQk4ubWluID0gZnVuY3Rpb24gbWluIChsZWZ0LCByaWdodCkge1xuXHQgICAgaWYgKGxlZnQuY21wKHJpZ2h0KSA8IDApIHJldHVybiBsZWZ0O1xuXHQgICAgcmV0dXJuIHJpZ2h0O1xuXHQgIH07XG5cblx0ICBCTi5wcm90b3R5cGUuX2luaXQgPSBmdW5jdGlvbiBpbml0IChudW1iZXIsIGJhc2UsIGVuZGlhbikge1xuXHQgICAgaWYgKHR5cGVvZiBudW1iZXIgPT09ICdudW1iZXInKSB7XG5cdCAgICAgIHJldHVybiB0aGlzLl9pbml0TnVtYmVyKG51bWJlciwgYmFzZSwgZW5kaWFuKTtcblx0ICAgIH1cblxuXHQgICAgaWYgKHR5cGVvZiBudW1iZXIgPT09ICdvYmplY3QnKSB7XG5cdCAgICAgIHJldHVybiB0aGlzLl9pbml0QXJyYXkobnVtYmVyLCBiYXNlLCBlbmRpYW4pO1xuXHQgICAgfVxuXG5cdCAgICBpZiAoYmFzZSA9PT0gJ2hleCcpIHtcblx0ICAgICAgYmFzZSA9IDE2O1xuXHQgICAgfVxuXHQgICAgYXNzZXJ0KGJhc2UgPT09IChiYXNlIHwgMCkgJiYgYmFzZSA+PSAyICYmIGJhc2UgPD0gMzYpO1xuXG5cdCAgICBudW1iZXIgPSBudW1iZXIudG9TdHJpbmcoKS5yZXBsYWNlKC9cXHMrL2csICcnKTtcblx0ICAgIHZhciBzdGFydCA9IDA7XG5cdCAgICBpZiAobnVtYmVyWzBdID09PSAnLScpIHtcblx0ICAgICAgc3RhcnQrKztcblx0ICAgICAgdGhpcy5uZWdhdGl2ZSA9IDE7XG5cdCAgICB9XG5cblx0ICAgIGlmIChzdGFydCA8IG51bWJlci5sZW5ndGgpIHtcblx0ICAgICAgaWYgKGJhc2UgPT09IDE2KSB7XG5cdCAgICAgICAgdGhpcy5fcGFyc2VIZXgobnVtYmVyLCBzdGFydCwgZW5kaWFuKTtcblx0ICAgICAgfSBlbHNlIHtcblx0ICAgICAgICB0aGlzLl9wYXJzZUJhc2UobnVtYmVyLCBiYXNlLCBzdGFydCk7XG5cdCAgICAgICAgaWYgKGVuZGlhbiA9PT0gJ2xlJykge1xuXHQgICAgICAgICAgdGhpcy5faW5pdEFycmF5KHRoaXMudG9BcnJheSgpLCBiYXNlLCBlbmRpYW4pO1xuXHQgICAgICAgIH1cblx0ICAgICAgfVxuXHQgICAgfVxuXHQgIH07XG5cblx0ICBCTi5wcm90b3R5cGUuX2luaXROdW1iZXIgPSBmdW5jdGlvbiBfaW5pdE51bWJlciAobnVtYmVyLCBiYXNlLCBlbmRpYW4pIHtcblx0ICAgIGlmIChudW1iZXIgPCAwKSB7XG5cdCAgICAgIHRoaXMubmVnYXRpdmUgPSAxO1xuXHQgICAgICBudW1iZXIgPSAtbnVtYmVyO1xuXHQgICAgfVxuXHQgICAgaWYgKG51bWJlciA8IDB4NDAwMDAwMCkge1xuXHQgICAgICB0aGlzLndvcmRzID0gWyBudW1iZXIgJiAweDNmZmZmZmYgXTtcblx0ICAgICAgdGhpcy5sZW5ndGggPSAxO1xuXHQgICAgfSBlbHNlIGlmIChudW1iZXIgPCAweDEwMDAwMDAwMDAwMDAwKSB7XG5cdCAgICAgIHRoaXMud29yZHMgPSBbXG5cdCAgICAgICAgbnVtYmVyICYgMHgzZmZmZmZmLFxuXHQgICAgICAgIChudW1iZXIgLyAweDQwMDAwMDApICYgMHgzZmZmZmZmXG5cdCAgICAgIF07XG5cdCAgICAgIHRoaXMubGVuZ3RoID0gMjtcblx0ICAgIH0gZWxzZSB7XG5cdCAgICAgIGFzc2VydChudW1iZXIgPCAweDIwMDAwMDAwMDAwMDAwKTsgLy8gMiBeIDUzICh1bnNhZmUpXG5cdCAgICAgIHRoaXMud29yZHMgPSBbXG5cdCAgICAgICAgbnVtYmVyICYgMHgzZmZmZmZmLFxuXHQgICAgICAgIChudW1iZXIgLyAweDQwMDAwMDApICYgMHgzZmZmZmZmLFxuXHQgICAgICAgIDFcblx0ICAgICAgXTtcblx0ICAgICAgdGhpcy5sZW5ndGggPSAzO1xuXHQgICAgfVxuXG5cdCAgICBpZiAoZW5kaWFuICE9PSAnbGUnKSByZXR1cm47XG5cblx0ICAgIC8vIFJldmVyc2UgdGhlIGJ5dGVzXG5cdCAgICB0aGlzLl9pbml0QXJyYXkodGhpcy50b0FycmF5KCksIGJhc2UsIGVuZGlhbik7XG5cdCAgfTtcblxuXHQgIEJOLnByb3RvdHlwZS5faW5pdEFycmF5ID0gZnVuY3Rpb24gX2luaXRBcnJheSAobnVtYmVyLCBiYXNlLCBlbmRpYW4pIHtcblx0ICAgIC8vIFBlcmhhcHMgYSBVaW50OEFycmF5XG5cdCAgICBhc3NlcnQodHlwZW9mIG51bWJlci5sZW5ndGggPT09ICdudW1iZXInKTtcblx0ICAgIGlmIChudW1iZXIubGVuZ3RoIDw9IDApIHtcblx0ICAgICAgdGhpcy53b3JkcyA9IFsgMCBdO1xuXHQgICAgICB0aGlzLmxlbmd0aCA9IDE7XG5cdCAgICAgIHJldHVybiB0aGlzO1xuXHQgICAgfVxuXG5cdCAgICB0aGlzLmxlbmd0aCA9IE1hdGguY2VpbChudW1iZXIubGVuZ3RoIC8gMyk7XG5cdCAgICB0aGlzLndvcmRzID0gbmV3IEFycmF5KHRoaXMubGVuZ3RoKTtcblx0ICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkrKykge1xuXHQgICAgICB0aGlzLndvcmRzW2ldID0gMDtcblx0ICAgIH1cblxuXHQgICAgdmFyIGosIHc7XG5cdCAgICB2YXIgb2ZmID0gMDtcblx0ICAgIGlmIChlbmRpYW4gPT09ICdiZScpIHtcblx0ICAgICAgZm9yIChpID0gbnVtYmVyLmxlbmd0aCAtIDEsIGogPSAwOyBpID49IDA7IGkgLT0gMykge1xuXHQgICAgICAgIHcgPSBudW1iZXJbaV0gfCAobnVtYmVyW2kgLSAxXSA8PCA4KSB8IChudW1iZXJbaSAtIDJdIDw8IDE2KTtcblx0ICAgICAgICB0aGlzLndvcmRzW2pdIHw9ICh3IDw8IG9mZikgJiAweDNmZmZmZmY7XG5cdCAgICAgICAgdGhpcy53b3Jkc1tqICsgMV0gPSAodyA+Pj4gKDI2IC0gb2ZmKSkgJiAweDNmZmZmZmY7XG5cdCAgICAgICAgb2ZmICs9IDI0O1xuXHQgICAgICAgIGlmIChvZmYgPj0gMjYpIHtcblx0ICAgICAgICAgIG9mZiAtPSAyNjtcblx0ICAgICAgICAgIGorKztcblx0ICAgICAgICB9XG5cdCAgICAgIH1cblx0ICAgIH0gZWxzZSBpZiAoZW5kaWFuID09PSAnbGUnKSB7XG5cdCAgICAgIGZvciAoaSA9IDAsIGogPSAwOyBpIDwgbnVtYmVyLmxlbmd0aDsgaSArPSAzKSB7XG5cdCAgICAgICAgdyA9IG51bWJlcltpXSB8IChudW1iZXJbaSArIDFdIDw8IDgpIHwgKG51bWJlcltpICsgMl0gPDwgMTYpO1xuXHQgICAgICAgIHRoaXMud29yZHNbal0gfD0gKHcgPDwgb2ZmKSAmIDB4M2ZmZmZmZjtcblx0ICAgICAgICB0aGlzLndvcmRzW2ogKyAxXSA9ICh3ID4+PiAoMjYgLSBvZmYpKSAmIDB4M2ZmZmZmZjtcblx0ICAgICAgICBvZmYgKz0gMjQ7XG5cdCAgICAgICAgaWYgKG9mZiA+PSAyNikge1xuXHQgICAgICAgICAgb2ZmIC09IDI2O1xuXHQgICAgICAgICAgaisrO1xuXHQgICAgICAgIH1cblx0ICAgICAgfVxuXHQgICAgfVxuXHQgICAgcmV0dXJuIHRoaXMuc3RyaXAoKTtcblx0ICB9O1xuXG5cdCAgZnVuY3Rpb24gcGFyc2VIZXg0Qml0cyAoc3RyaW5nLCBpbmRleCkge1xuXHQgICAgdmFyIGMgPSBzdHJpbmcuY2hhckNvZGVBdChpbmRleCk7XG5cdCAgICAvLyAnQScgLSAnRidcblx0ICAgIGlmIChjID49IDY1ICYmIGMgPD0gNzApIHtcblx0ICAgICAgcmV0dXJuIGMgLSA1NTtcblx0ICAgIC8vICdhJyAtICdmJ1xuXHQgICAgfSBlbHNlIGlmIChjID49IDk3ICYmIGMgPD0gMTAyKSB7XG5cdCAgICAgIHJldHVybiBjIC0gODc7XG5cdCAgICAvLyAnMCcgLSAnOSdcblx0ICAgIH0gZWxzZSB7XG5cdCAgICAgIHJldHVybiAoYyAtIDQ4KSAmIDB4Zjtcblx0ICAgIH1cblx0ICB9XG5cblx0ICBmdW5jdGlvbiBwYXJzZUhleEJ5dGUgKHN0cmluZywgbG93ZXJCb3VuZCwgaW5kZXgpIHtcblx0ICAgIHZhciByID0gcGFyc2VIZXg0Qml0cyhzdHJpbmcsIGluZGV4KTtcblx0ICAgIGlmIChpbmRleCAtIDEgPj0gbG93ZXJCb3VuZCkge1xuXHQgICAgICByIHw9IHBhcnNlSGV4NEJpdHMoc3RyaW5nLCBpbmRleCAtIDEpIDw8IDQ7XG5cdCAgICB9XG5cdCAgICByZXR1cm4gcjtcblx0ICB9XG5cblx0ICBCTi5wcm90b3R5cGUuX3BhcnNlSGV4ID0gZnVuY3Rpb24gX3BhcnNlSGV4IChudW1iZXIsIHN0YXJ0LCBlbmRpYW4pIHtcblx0ICAgIC8vIENyZWF0ZSBwb3NzaWJseSBiaWdnZXIgYXJyYXkgdG8gZW5zdXJlIHRoYXQgaXQgZml0cyB0aGUgbnVtYmVyXG5cdCAgICB0aGlzLmxlbmd0aCA9IE1hdGguY2VpbCgobnVtYmVyLmxlbmd0aCAtIHN0YXJ0KSAvIDYpO1xuXHQgICAgdGhpcy53b3JkcyA9IG5ldyBBcnJheSh0aGlzLmxlbmd0aCk7XG5cdCAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpKyspIHtcblx0ICAgICAgdGhpcy53b3Jkc1tpXSA9IDA7XG5cdCAgICB9XG5cblx0ICAgIC8vIDI0LWJpdHMgY2h1bmtzXG5cdCAgICB2YXIgb2ZmID0gMDtcblx0ICAgIHZhciBqID0gMDtcblxuXHQgICAgdmFyIHc7XG5cdCAgICBpZiAoZW5kaWFuID09PSAnYmUnKSB7XG5cdCAgICAgIGZvciAoaSA9IG51bWJlci5sZW5ndGggLSAxOyBpID49IHN0YXJ0OyBpIC09IDIpIHtcblx0ICAgICAgICB3ID0gcGFyc2VIZXhCeXRlKG51bWJlciwgc3RhcnQsIGkpIDw8IG9mZjtcblx0ICAgICAgICB0aGlzLndvcmRzW2pdIHw9IHcgJiAweDNmZmZmZmY7XG5cdCAgICAgICAgaWYgKG9mZiA+PSAxOCkge1xuXHQgICAgICAgICAgb2ZmIC09IDE4O1xuXHQgICAgICAgICAgaiArPSAxO1xuXHQgICAgICAgICAgdGhpcy53b3Jkc1tqXSB8PSB3ID4+PiAyNjtcblx0ICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgb2ZmICs9IDg7XG5cdCAgICAgICAgfVxuXHQgICAgICB9XG5cdCAgICB9IGVsc2Uge1xuXHQgICAgICB2YXIgcGFyc2VMZW5ndGggPSBudW1iZXIubGVuZ3RoIC0gc3RhcnQ7XG5cdCAgICAgIGZvciAoaSA9IHBhcnNlTGVuZ3RoICUgMiA9PT0gMCA/IHN0YXJ0ICsgMSA6IHN0YXJ0OyBpIDwgbnVtYmVyLmxlbmd0aDsgaSArPSAyKSB7XG5cdCAgICAgICAgdyA9IHBhcnNlSGV4Qnl0ZShudW1iZXIsIHN0YXJ0LCBpKSA8PCBvZmY7XG5cdCAgICAgICAgdGhpcy53b3Jkc1tqXSB8PSB3ICYgMHgzZmZmZmZmO1xuXHQgICAgICAgIGlmIChvZmYgPj0gMTgpIHtcblx0ICAgICAgICAgIG9mZiAtPSAxODtcblx0ICAgICAgICAgIGogKz0gMTtcblx0ICAgICAgICAgIHRoaXMud29yZHNbal0gfD0gdyA+Pj4gMjY7XG5cdCAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgIG9mZiArPSA4O1xuXHQgICAgICAgIH1cblx0ICAgICAgfVxuXHQgICAgfVxuXG5cdCAgICB0aGlzLnN0cmlwKCk7XG5cdCAgfTtcblxuXHQgIGZ1bmN0aW9uIHBhcnNlQmFzZSAoc3RyLCBzdGFydCwgZW5kLCBtdWwpIHtcblx0ICAgIHZhciByID0gMDtcblx0ICAgIHZhciBsZW4gPSBNYXRoLm1pbihzdHIubGVuZ3RoLCBlbmQpO1xuXHQgICAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgbGVuOyBpKyspIHtcblx0ICAgICAgdmFyIGMgPSBzdHIuY2hhckNvZGVBdChpKSAtIDQ4O1xuXG5cdCAgICAgIHIgKj0gbXVsO1xuXG5cdCAgICAgIC8vICdhJ1xuXHQgICAgICBpZiAoYyA+PSA0OSkge1xuXHQgICAgICAgIHIgKz0gYyAtIDQ5ICsgMHhhO1xuXG5cdCAgICAgIC8vICdBJ1xuXHQgICAgICB9IGVsc2UgaWYgKGMgPj0gMTcpIHtcblx0ICAgICAgICByICs9IGMgLSAxNyArIDB4YTtcblxuXHQgICAgICAvLyAnMCcgLSAnOSdcblx0ICAgICAgfSBlbHNlIHtcblx0ICAgICAgICByICs9IGM7XG5cdCAgICAgIH1cblx0ICAgIH1cblx0ICAgIHJldHVybiByO1xuXHQgIH1cblxuXHQgIEJOLnByb3RvdHlwZS5fcGFyc2VCYXNlID0gZnVuY3Rpb24gX3BhcnNlQmFzZSAobnVtYmVyLCBiYXNlLCBzdGFydCkge1xuXHQgICAgLy8gSW5pdGlhbGl6ZSBhcyB6ZXJvXG5cdCAgICB0aGlzLndvcmRzID0gWyAwIF07XG5cdCAgICB0aGlzLmxlbmd0aCA9IDE7XG5cblx0ICAgIC8vIEZpbmQgbGVuZ3RoIG9mIGxpbWIgaW4gYmFzZVxuXHQgICAgZm9yICh2YXIgbGltYkxlbiA9IDAsIGxpbWJQb3cgPSAxOyBsaW1iUG93IDw9IDB4M2ZmZmZmZjsgbGltYlBvdyAqPSBiYXNlKSB7XG5cdCAgICAgIGxpbWJMZW4rKztcblx0ICAgIH1cblx0ICAgIGxpbWJMZW4tLTtcblx0ICAgIGxpbWJQb3cgPSAobGltYlBvdyAvIGJhc2UpIHwgMDtcblxuXHQgICAgdmFyIHRvdGFsID0gbnVtYmVyLmxlbmd0aCAtIHN0YXJ0O1xuXHQgICAgdmFyIG1vZCA9IHRvdGFsICUgbGltYkxlbjtcblx0ICAgIHZhciBlbmQgPSBNYXRoLm1pbih0b3RhbCwgdG90YWwgLSBtb2QpICsgc3RhcnQ7XG5cblx0ICAgIHZhciB3b3JkID0gMDtcblx0ICAgIGZvciAodmFyIGkgPSBzdGFydDsgaSA8IGVuZDsgaSArPSBsaW1iTGVuKSB7XG5cdCAgICAgIHdvcmQgPSBwYXJzZUJhc2UobnVtYmVyLCBpLCBpICsgbGltYkxlbiwgYmFzZSk7XG5cblx0ICAgICAgdGhpcy5pbXVsbihsaW1iUG93KTtcblx0ICAgICAgaWYgKHRoaXMud29yZHNbMF0gKyB3b3JkIDwgMHg0MDAwMDAwKSB7XG5cdCAgICAgICAgdGhpcy53b3Jkc1swXSArPSB3b3JkO1xuXHQgICAgICB9IGVsc2Uge1xuXHQgICAgICAgIHRoaXMuX2lhZGRuKHdvcmQpO1xuXHQgICAgICB9XG5cdCAgICB9XG5cblx0ICAgIGlmIChtb2QgIT09IDApIHtcblx0ICAgICAgdmFyIHBvdyA9IDE7XG5cdCAgICAgIHdvcmQgPSBwYXJzZUJhc2UobnVtYmVyLCBpLCBudW1iZXIubGVuZ3RoLCBiYXNlKTtcblxuXHQgICAgICBmb3IgKGkgPSAwOyBpIDwgbW9kOyBpKyspIHtcblx0ICAgICAgICBwb3cgKj0gYmFzZTtcblx0ICAgICAgfVxuXG5cdCAgICAgIHRoaXMuaW11bG4ocG93KTtcblx0ICAgICAgaWYgKHRoaXMud29yZHNbMF0gKyB3b3JkIDwgMHg0MDAwMDAwKSB7XG5cdCAgICAgICAgdGhpcy53b3Jkc1swXSArPSB3b3JkO1xuXHQgICAgICB9IGVsc2Uge1xuXHQgICAgICAgIHRoaXMuX2lhZGRuKHdvcmQpO1xuXHQgICAgICB9XG5cdCAgICB9XG5cblx0ICAgIHRoaXMuc3RyaXAoKTtcblx0ICB9O1xuXG5cdCAgQk4ucHJvdG90eXBlLmNvcHkgPSBmdW5jdGlvbiBjb3B5IChkZXN0KSB7XG5cdCAgICBkZXN0LndvcmRzID0gbmV3IEFycmF5KHRoaXMubGVuZ3RoKTtcblx0ICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkrKykge1xuXHQgICAgICBkZXN0LndvcmRzW2ldID0gdGhpcy53b3Jkc1tpXTtcblx0ICAgIH1cblx0ICAgIGRlc3QubGVuZ3RoID0gdGhpcy5sZW5ndGg7XG5cdCAgICBkZXN0Lm5lZ2F0aXZlID0gdGhpcy5uZWdhdGl2ZTtcblx0ICAgIGRlc3QucmVkID0gdGhpcy5yZWQ7XG5cdCAgfTtcblxuXHQgIEJOLnByb3RvdHlwZS5jbG9uZSA9IGZ1bmN0aW9uIGNsb25lICgpIHtcblx0ICAgIHZhciByID0gbmV3IEJOKG51bGwpO1xuXHQgICAgdGhpcy5jb3B5KHIpO1xuXHQgICAgcmV0dXJuIHI7XG5cdCAgfTtcblxuXHQgIEJOLnByb3RvdHlwZS5fZXhwYW5kID0gZnVuY3Rpb24gX2V4cGFuZCAoc2l6ZSkge1xuXHQgICAgd2hpbGUgKHRoaXMubGVuZ3RoIDwgc2l6ZSkge1xuXHQgICAgICB0aGlzLndvcmRzW3RoaXMubGVuZ3RoKytdID0gMDtcblx0ICAgIH1cblx0ICAgIHJldHVybiB0aGlzO1xuXHQgIH07XG5cblx0ICAvLyBSZW1vdmUgbGVhZGluZyBgMGAgZnJvbSBgdGhpc2Bcblx0ICBCTi5wcm90b3R5cGUuc3RyaXAgPSBmdW5jdGlvbiBzdHJpcCAoKSB7XG5cdCAgICB3aGlsZSAodGhpcy5sZW5ndGggPiAxICYmIHRoaXMud29yZHNbdGhpcy5sZW5ndGggLSAxXSA9PT0gMCkge1xuXHQgICAgICB0aGlzLmxlbmd0aC0tO1xuXHQgICAgfVxuXHQgICAgcmV0dXJuIHRoaXMuX25vcm1TaWduKCk7XG5cdCAgfTtcblxuXHQgIEJOLnByb3RvdHlwZS5fbm9ybVNpZ24gPSBmdW5jdGlvbiBfbm9ybVNpZ24gKCkge1xuXHQgICAgLy8gLTAgPSAwXG5cdCAgICBpZiAodGhpcy5sZW5ndGggPT09IDEgJiYgdGhpcy53b3Jkc1swXSA9PT0gMCkge1xuXHQgICAgICB0aGlzLm5lZ2F0aXZlID0gMDtcblx0ICAgIH1cblx0ICAgIHJldHVybiB0aGlzO1xuXHQgIH07XG5cblx0ICBCTi5wcm90b3R5cGUuaW5zcGVjdCA9IGZ1bmN0aW9uIGluc3BlY3QgKCkge1xuXHQgICAgcmV0dXJuICh0aGlzLnJlZCA/ICc8Qk4tUjogJyA6ICc8Qk46ICcpICsgdGhpcy50b1N0cmluZygxNikgKyAnPic7XG5cdCAgfTtcblxuXHQgIC8qXG5cblx0ICB2YXIgemVyb3MgPSBbXTtcblx0ICB2YXIgZ3JvdXBTaXplcyA9IFtdO1xuXHQgIHZhciBncm91cEJhc2VzID0gW107XG5cblx0ICB2YXIgcyA9ICcnO1xuXHQgIHZhciBpID0gLTE7XG5cdCAgd2hpbGUgKCsraSA8IEJOLndvcmRTaXplKSB7XG5cdCAgICB6ZXJvc1tpXSA9IHM7XG5cdCAgICBzICs9ICcwJztcblx0ICB9XG5cdCAgZ3JvdXBTaXplc1swXSA9IDA7XG5cdCAgZ3JvdXBTaXplc1sxXSA9IDA7XG5cdCAgZ3JvdXBCYXNlc1swXSA9IDA7XG5cdCAgZ3JvdXBCYXNlc1sxXSA9IDA7XG5cdCAgdmFyIGJhc2UgPSAyIC0gMTtcblx0ICB3aGlsZSAoKytiYXNlIDwgMzYgKyAxKSB7XG5cdCAgICB2YXIgZ3JvdXBTaXplID0gMDtcblx0ICAgIHZhciBncm91cEJhc2UgPSAxO1xuXHQgICAgd2hpbGUgKGdyb3VwQmFzZSA8ICgxIDw8IEJOLndvcmRTaXplKSAvIGJhc2UpIHtcblx0ICAgICAgZ3JvdXBCYXNlICo9IGJhc2U7XG5cdCAgICAgIGdyb3VwU2l6ZSArPSAxO1xuXHQgICAgfVxuXHQgICAgZ3JvdXBTaXplc1tiYXNlXSA9IGdyb3VwU2l6ZTtcblx0ICAgIGdyb3VwQmFzZXNbYmFzZV0gPSBncm91cEJhc2U7XG5cdCAgfVxuXG5cdCAgKi9cblxuXHQgIHZhciB6ZXJvcyA9IFtcblx0ICAgICcnLFxuXHQgICAgJzAnLFxuXHQgICAgJzAwJyxcblx0ICAgICcwMDAnLFxuXHQgICAgJzAwMDAnLFxuXHQgICAgJzAwMDAwJyxcblx0ICAgICcwMDAwMDAnLFxuXHQgICAgJzAwMDAwMDAnLFxuXHQgICAgJzAwMDAwMDAwJyxcblx0ICAgICcwMDAwMDAwMDAnLFxuXHQgICAgJzAwMDAwMDAwMDAnLFxuXHQgICAgJzAwMDAwMDAwMDAwJyxcblx0ICAgICcwMDAwMDAwMDAwMDAnLFxuXHQgICAgJzAwMDAwMDAwMDAwMDAnLFxuXHQgICAgJzAwMDAwMDAwMDAwMDAwJyxcblx0ICAgICcwMDAwMDAwMDAwMDAwMDAnLFxuXHQgICAgJzAwMDAwMDAwMDAwMDAwMDAnLFxuXHQgICAgJzAwMDAwMDAwMDAwMDAwMDAwJyxcblx0ICAgICcwMDAwMDAwMDAwMDAwMDAwMDAnLFxuXHQgICAgJzAwMDAwMDAwMDAwMDAwMDAwMDAnLFxuXHQgICAgJzAwMDAwMDAwMDAwMDAwMDAwMDAwJyxcblx0ICAgICcwMDAwMDAwMDAwMDAwMDAwMDAwMDAnLFxuXHQgICAgJzAwMDAwMDAwMDAwMDAwMDAwMDAwMDAnLFxuXHQgICAgJzAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwJyxcblx0ICAgICcwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAnLFxuXHQgICAgJzAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAnXG5cdCAgXTtcblxuXHQgIHZhciBncm91cFNpemVzID0gW1xuXHQgICAgMCwgMCxcblx0ICAgIDI1LCAxNiwgMTIsIDExLCAxMCwgOSwgOCxcblx0ICAgIDgsIDcsIDcsIDcsIDcsIDYsIDYsXG5cdCAgICA2LCA2LCA2LCA2LCA2LCA1LCA1LFxuXHQgICAgNSwgNSwgNSwgNSwgNSwgNSwgNSxcblx0ICAgIDUsIDUsIDUsIDUsIDUsIDUsIDVcblx0ICBdO1xuXG5cdCAgdmFyIGdyb3VwQmFzZXMgPSBbXG5cdCAgICAwLCAwLFxuXHQgICAgMzM1NTQ0MzIsIDQzMDQ2NzIxLCAxNjc3NzIxNiwgNDg4MjgxMjUsIDYwNDY2MTc2LCA0MDM1MzYwNywgMTY3NzcyMTYsXG5cdCAgICA0MzA0NjcyMSwgMTAwMDAwMDAsIDE5NDg3MTcxLCAzNTgzMTgwOCwgNjI3NDg1MTcsIDc1Mjk1MzYsIDExMzkwNjI1LFxuXHQgICAgMTY3NzcyMTYsIDI0MTM3NTY5LCAzNDAxMjIyNCwgNDcwNDU4ODEsIDY0MDAwMDAwLCA0MDg0MTAxLCA1MTUzNjMyLFxuXHQgICAgNjQzNjM0MywgNzk2MjYyNCwgOTc2NTYyNSwgMTE4ODEzNzYsIDE0MzQ4OTA3LCAxNzIxMDM2OCwgMjA1MTExNDksXG5cdCAgICAyNDMwMDAwMCwgMjg2MjkxNTEsIDMzNTU0NDMyLCAzOTEzNTM5MywgNDU0MzU0MjQsIDUyNTIxODc1LCA2MDQ2NjE3NlxuXHQgIF07XG5cblx0ICBCTi5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZyAoYmFzZSwgcGFkZGluZykge1xuXHQgICAgYmFzZSA9IGJhc2UgfHwgMTA7XG5cdCAgICBwYWRkaW5nID0gcGFkZGluZyB8IDAgfHwgMTtcblxuXHQgICAgdmFyIG91dDtcblx0ICAgIGlmIChiYXNlID09PSAxNiB8fCBiYXNlID09PSAnaGV4Jykge1xuXHQgICAgICBvdXQgPSAnJztcblx0ICAgICAgdmFyIG9mZiA9IDA7XG5cdCAgICAgIHZhciBjYXJyeSA9IDA7XG5cdCAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkrKykge1xuXHQgICAgICAgIHZhciB3ID0gdGhpcy53b3Jkc1tpXTtcblx0ICAgICAgICB2YXIgd29yZCA9ICgoKHcgPDwgb2ZmKSB8IGNhcnJ5KSAmIDB4ZmZmZmZmKS50b1N0cmluZygxNik7XG5cdCAgICAgICAgY2FycnkgPSAodyA+Pj4gKDI0IC0gb2ZmKSkgJiAweGZmZmZmZjtcblx0ICAgICAgICBpZiAoY2FycnkgIT09IDAgfHwgaSAhPT0gdGhpcy5sZW5ndGggLSAxKSB7XG5cdCAgICAgICAgICBvdXQgPSB6ZXJvc1s2IC0gd29yZC5sZW5ndGhdICsgd29yZCArIG91dDtcblx0ICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgb3V0ID0gd29yZCArIG91dDtcblx0ICAgICAgICB9XG5cdCAgICAgICAgb2ZmICs9IDI7XG5cdCAgICAgICAgaWYgKG9mZiA+PSAyNikge1xuXHQgICAgICAgICAgb2ZmIC09IDI2O1xuXHQgICAgICAgICAgaS0tO1xuXHQgICAgICAgIH1cblx0ICAgICAgfVxuXHQgICAgICBpZiAoY2FycnkgIT09IDApIHtcblx0ICAgICAgICBvdXQgPSBjYXJyeS50b1N0cmluZygxNikgKyBvdXQ7XG5cdCAgICAgIH1cblx0ICAgICAgd2hpbGUgKG91dC5sZW5ndGggJSBwYWRkaW5nICE9PSAwKSB7XG5cdCAgICAgICAgb3V0ID0gJzAnICsgb3V0O1xuXHQgICAgICB9XG5cdCAgICAgIGlmICh0aGlzLm5lZ2F0aXZlICE9PSAwKSB7XG5cdCAgICAgICAgb3V0ID0gJy0nICsgb3V0O1xuXHQgICAgICB9XG5cdCAgICAgIHJldHVybiBvdXQ7XG5cdCAgICB9XG5cblx0ICAgIGlmIChiYXNlID09PSAoYmFzZSB8IDApICYmIGJhc2UgPj0gMiAmJiBiYXNlIDw9IDM2KSB7XG5cdCAgICAgIC8vIHZhciBncm91cFNpemUgPSBNYXRoLmZsb29yKEJOLndvcmRTaXplICogTWF0aC5MTjIgLyBNYXRoLmxvZyhiYXNlKSk7XG5cdCAgICAgIHZhciBncm91cFNpemUgPSBncm91cFNpemVzW2Jhc2VdO1xuXHQgICAgICAvLyB2YXIgZ3JvdXBCYXNlID0gTWF0aC5wb3coYmFzZSwgZ3JvdXBTaXplKTtcblx0ICAgICAgdmFyIGdyb3VwQmFzZSA9IGdyb3VwQmFzZXNbYmFzZV07XG5cdCAgICAgIG91dCA9ICcnO1xuXHQgICAgICB2YXIgYyA9IHRoaXMuY2xvbmUoKTtcblx0ICAgICAgYy5uZWdhdGl2ZSA9IDA7XG5cdCAgICAgIHdoaWxlICghYy5pc1plcm8oKSkge1xuXHQgICAgICAgIHZhciByID0gYy5tb2RuKGdyb3VwQmFzZSkudG9TdHJpbmcoYmFzZSk7XG5cdCAgICAgICAgYyA9IGMuaWRpdm4oZ3JvdXBCYXNlKTtcblxuXHQgICAgICAgIGlmICghYy5pc1plcm8oKSkge1xuXHQgICAgICAgICAgb3V0ID0gemVyb3NbZ3JvdXBTaXplIC0gci5sZW5ndGhdICsgciArIG91dDtcblx0ICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgb3V0ID0gciArIG91dDtcblx0ICAgICAgICB9XG5cdCAgICAgIH1cblx0ICAgICAgaWYgKHRoaXMuaXNaZXJvKCkpIHtcblx0ICAgICAgICBvdXQgPSAnMCcgKyBvdXQ7XG5cdCAgICAgIH1cblx0ICAgICAgd2hpbGUgKG91dC5sZW5ndGggJSBwYWRkaW5nICE9PSAwKSB7XG5cdCAgICAgICAgb3V0ID0gJzAnICsgb3V0O1xuXHQgICAgICB9XG5cdCAgICAgIGlmICh0aGlzLm5lZ2F0aXZlICE9PSAwKSB7XG5cdCAgICAgICAgb3V0ID0gJy0nICsgb3V0O1xuXHQgICAgICB9XG5cdCAgICAgIHJldHVybiBvdXQ7XG5cdCAgICB9XG5cblx0ICAgIGFzc2VydChmYWxzZSwgJ0Jhc2Ugc2hvdWxkIGJlIGJldHdlZW4gMiBhbmQgMzYnKTtcblx0ICB9O1xuXG5cdCAgQk4ucHJvdG90eXBlLnRvTnVtYmVyID0gZnVuY3Rpb24gdG9OdW1iZXIgKCkge1xuXHQgICAgdmFyIHJldCA9IHRoaXMud29yZHNbMF07XG5cdCAgICBpZiAodGhpcy5sZW5ndGggPT09IDIpIHtcblx0ICAgICAgcmV0ICs9IHRoaXMud29yZHNbMV0gKiAweDQwMDAwMDA7XG5cdCAgICB9IGVsc2UgaWYgKHRoaXMubGVuZ3RoID09PSAzICYmIHRoaXMud29yZHNbMl0gPT09IDB4MDEpIHtcblx0ICAgICAgLy8gTk9URTogYXQgdGhpcyBzdGFnZSBpdCBpcyBrbm93biB0aGF0IHRoZSB0b3AgYml0IGlzIHNldFxuXHQgICAgICByZXQgKz0gMHgxMDAwMDAwMDAwMDAwMCArICh0aGlzLndvcmRzWzFdICogMHg0MDAwMDAwKTtcblx0ICAgIH0gZWxzZSBpZiAodGhpcy5sZW5ndGggPiAyKSB7XG5cdCAgICAgIGFzc2VydChmYWxzZSwgJ051bWJlciBjYW4gb25seSBzYWZlbHkgc3RvcmUgdXAgdG8gNTMgYml0cycpO1xuXHQgICAgfVxuXHQgICAgcmV0dXJuICh0aGlzLm5lZ2F0aXZlICE9PSAwKSA/IC1yZXQgOiByZXQ7XG5cdCAgfTtcblxuXHQgIEJOLnByb3RvdHlwZS50b0pTT04gPSBmdW5jdGlvbiB0b0pTT04gKCkge1xuXHQgICAgcmV0dXJuIHRoaXMudG9TdHJpbmcoMTYpO1xuXHQgIH07XG5cblx0ICBCTi5wcm90b3R5cGUudG9CdWZmZXIgPSBmdW5jdGlvbiB0b0J1ZmZlciAoZW5kaWFuLCBsZW5ndGgpIHtcblx0ICAgIGFzc2VydCh0eXBlb2YgQnVmZmVyICE9PSAndW5kZWZpbmVkJyk7XG5cdCAgICByZXR1cm4gdGhpcy50b0FycmF5TGlrZShCdWZmZXIsIGVuZGlhbiwgbGVuZ3RoKTtcblx0ICB9O1xuXG5cdCAgQk4ucHJvdG90eXBlLnRvQXJyYXkgPSBmdW5jdGlvbiB0b0FycmF5IChlbmRpYW4sIGxlbmd0aCkge1xuXHQgICAgcmV0dXJuIHRoaXMudG9BcnJheUxpa2UoQXJyYXksIGVuZGlhbiwgbGVuZ3RoKTtcblx0ICB9O1xuXG5cdCAgQk4ucHJvdG90eXBlLnRvQXJyYXlMaWtlID0gZnVuY3Rpb24gdG9BcnJheUxpa2UgKEFycmF5VHlwZSwgZW5kaWFuLCBsZW5ndGgpIHtcblx0ICAgIHZhciBieXRlTGVuZ3RoID0gdGhpcy5ieXRlTGVuZ3RoKCk7XG5cdCAgICB2YXIgcmVxTGVuZ3RoID0gbGVuZ3RoIHx8IE1hdGgubWF4KDEsIGJ5dGVMZW5ndGgpO1xuXHQgICAgYXNzZXJ0KGJ5dGVMZW5ndGggPD0gcmVxTGVuZ3RoLCAnYnl0ZSBhcnJheSBsb25nZXIgdGhhbiBkZXNpcmVkIGxlbmd0aCcpO1xuXHQgICAgYXNzZXJ0KHJlcUxlbmd0aCA+IDAsICdSZXF1ZXN0ZWQgYXJyYXkgbGVuZ3RoIDw9IDAnKTtcblxuXHQgICAgdGhpcy5zdHJpcCgpO1xuXHQgICAgdmFyIGxpdHRsZUVuZGlhbiA9IGVuZGlhbiA9PT0gJ2xlJztcblx0ICAgIHZhciByZXMgPSBuZXcgQXJyYXlUeXBlKHJlcUxlbmd0aCk7XG5cblx0ICAgIHZhciBiLCBpO1xuXHQgICAgdmFyIHEgPSB0aGlzLmNsb25lKCk7XG5cdCAgICBpZiAoIWxpdHRsZUVuZGlhbikge1xuXHQgICAgICAvLyBBc3N1bWUgYmlnLWVuZGlhblxuXHQgICAgICBmb3IgKGkgPSAwOyBpIDwgcmVxTGVuZ3RoIC0gYnl0ZUxlbmd0aDsgaSsrKSB7XG5cdCAgICAgICAgcmVzW2ldID0gMDtcblx0ICAgICAgfVxuXG5cdCAgICAgIGZvciAoaSA9IDA7ICFxLmlzWmVybygpOyBpKyspIHtcblx0ICAgICAgICBiID0gcS5hbmRsbigweGZmKTtcblx0ICAgICAgICBxLml1c2hybig4KTtcblxuXHQgICAgICAgIHJlc1tyZXFMZW5ndGggLSBpIC0gMV0gPSBiO1xuXHQgICAgICB9XG5cdCAgICB9IGVsc2Uge1xuXHQgICAgICBmb3IgKGkgPSAwOyAhcS5pc1plcm8oKTsgaSsrKSB7XG5cdCAgICAgICAgYiA9IHEuYW5kbG4oMHhmZik7XG5cdCAgICAgICAgcS5pdXNocm4oOCk7XG5cblx0ICAgICAgICByZXNbaV0gPSBiO1xuXHQgICAgICB9XG5cblx0ICAgICAgZm9yICg7IGkgPCByZXFMZW5ndGg7IGkrKykge1xuXHQgICAgICAgIHJlc1tpXSA9IDA7XG5cdCAgICAgIH1cblx0ICAgIH1cblxuXHQgICAgcmV0dXJuIHJlcztcblx0ICB9O1xuXG5cdCAgaWYgKE1hdGguY2x6MzIpIHtcblx0ICAgIEJOLnByb3RvdHlwZS5fY291bnRCaXRzID0gZnVuY3Rpb24gX2NvdW50Qml0cyAodykge1xuXHQgICAgICByZXR1cm4gMzIgLSBNYXRoLmNsejMyKHcpO1xuXHQgICAgfTtcblx0ICB9IGVsc2Uge1xuXHQgICAgQk4ucHJvdG90eXBlLl9jb3VudEJpdHMgPSBmdW5jdGlvbiBfY291bnRCaXRzICh3KSB7XG5cdCAgICAgIHZhciB0ID0gdztcblx0ICAgICAgdmFyIHIgPSAwO1xuXHQgICAgICBpZiAodCA+PSAweDEwMDApIHtcblx0ICAgICAgICByICs9IDEzO1xuXHQgICAgICAgIHQgPj4+PSAxMztcblx0ICAgICAgfVxuXHQgICAgICBpZiAodCA+PSAweDQwKSB7XG5cdCAgICAgICAgciArPSA3O1xuXHQgICAgICAgIHQgPj4+PSA3O1xuXHQgICAgICB9XG5cdCAgICAgIGlmICh0ID49IDB4OCkge1xuXHQgICAgICAgIHIgKz0gNDtcblx0ICAgICAgICB0ID4+Pj0gNDtcblx0ICAgICAgfVxuXHQgICAgICBpZiAodCA+PSAweDAyKSB7XG5cdCAgICAgICAgciArPSAyO1xuXHQgICAgICAgIHQgPj4+PSAyO1xuXHQgICAgICB9XG5cdCAgICAgIHJldHVybiByICsgdDtcblx0ICAgIH07XG5cdCAgfVxuXG5cdCAgQk4ucHJvdG90eXBlLl96ZXJvQml0cyA9IGZ1bmN0aW9uIF96ZXJvQml0cyAodykge1xuXHQgICAgLy8gU2hvcnQtY3V0XG5cdCAgICBpZiAodyA9PT0gMCkgcmV0dXJuIDI2O1xuXG5cdCAgICB2YXIgdCA9IHc7XG5cdCAgICB2YXIgciA9IDA7XG5cdCAgICBpZiAoKHQgJiAweDFmZmYpID09PSAwKSB7XG5cdCAgICAgIHIgKz0gMTM7XG5cdCAgICAgIHQgPj4+PSAxMztcblx0ICAgIH1cblx0ICAgIGlmICgodCAmIDB4N2YpID09PSAwKSB7XG5cdCAgICAgIHIgKz0gNztcblx0ICAgICAgdCA+Pj49IDc7XG5cdCAgICB9XG5cdCAgICBpZiAoKHQgJiAweGYpID09PSAwKSB7XG5cdCAgICAgIHIgKz0gNDtcblx0ICAgICAgdCA+Pj49IDQ7XG5cdCAgICB9XG5cdCAgICBpZiAoKHQgJiAweDMpID09PSAwKSB7XG5cdCAgICAgIHIgKz0gMjtcblx0ICAgICAgdCA+Pj49IDI7XG5cdCAgICB9XG5cdCAgICBpZiAoKHQgJiAweDEpID09PSAwKSB7XG5cdCAgICAgIHIrKztcblx0ICAgIH1cblx0ICAgIHJldHVybiByO1xuXHQgIH07XG5cblx0ICAvLyBSZXR1cm4gbnVtYmVyIG9mIHVzZWQgYml0cyBpbiBhIEJOXG5cdCAgQk4ucHJvdG90eXBlLmJpdExlbmd0aCA9IGZ1bmN0aW9uIGJpdExlbmd0aCAoKSB7XG5cdCAgICB2YXIgdyA9IHRoaXMud29yZHNbdGhpcy5sZW5ndGggLSAxXTtcblx0ICAgIHZhciBoaSA9IHRoaXMuX2NvdW50Qml0cyh3KTtcblx0ICAgIHJldHVybiAodGhpcy5sZW5ndGggLSAxKSAqIDI2ICsgaGk7XG5cdCAgfTtcblxuXHQgIGZ1bmN0aW9uIHRvQml0QXJyYXkgKG51bSkge1xuXHQgICAgdmFyIHcgPSBuZXcgQXJyYXkobnVtLmJpdExlbmd0aCgpKTtcblxuXHQgICAgZm9yICh2YXIgYml0ID0gMDsgYml0IDwgdy5sZW5ndGg7IGJpdCsrKSB7XG5cdCAgICAgIHZhciBvZmYgPSAoYml0IC8gMjYpIHwgMDtcblx0ICAgICAgdmFyIHdiaXQgPSBiaXQgJSAyNjtcblxuXHQgICAgICB3W2JpdF0gPSAobnVtLndvcmRzW29mZl0gJiAoMSA8PCB3Yml0KSkgPj4+IHdiaXQ7XG5cdCAgICB9XG5cblx0ICAgIHJldHVybiB3O1xuXHQgIH1cblxuXHQgIC8vIE51bWJlciBvZiB0cmFpbGluZyB6ZXJvIGJpdHNcblx0ICBCTi5wcm90b3R5cGUuemVyb0JpdHMgPSBmdW5jdGlvbiB6ZXJvQml0cyAoKSB7XG5cdCAgICBpZiAodGhpcy5pc1plcm8oKSkgcmV0dXJuIDA7XG5cblx0ICAgIHZhciByID0gMDtcblx0ICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkrKykge1xuXHQgICAgICB2YXIgYiA9IHRoaXMuX3plcm9CaXRzKHRoaXMud29yZHNbaV0pO1xuXHQgICAgICByICs9IGI7XG5cdCAgICAgIGlmIChiICE9PSAyNikgYnJlYWs7XG5cdCAgICB9XG5cdCAgICByZXR1cm4gcjtcblx0ICB9O1xuXG5cdCAgQk4ucHJvdG90eXBlLmJ5dGVMZW5ndGggPSBmdW5jdGlvbiBieXRlTGVuZ3RoICgpIHtcblx0ICAgIHJldHVybiBNYXRoLmNlaWwodGhpcy5iaXRMZW5ndGgoKSAvIDgpO1xuXHQgIH07XG5cblx0ICBCTi5wcm90b3R5cGUudG9Ud29zID0gZnVuY3Rpb24gdG9Ud29zICh3aWR0aCkge1xuXHQgICAgaWYgKHRoaXMubmVnYXRpdmUgIT09IDApIHtcblx0ICAgICAgcmV0dXJuIHRoaXMuYWJzKCkuaW5vdG4od2lkdGgpLmlhZGRuKDEpO1xuXHQgICAgfVxuXHQgICAgcmV0dXJuIHRoaXMuY2xvbmUoKTtcblx0ICB9O1xuXG5cdCAgQk4ucHJvdG90eXBlLmZyb21Ud29zID0gZnVuY3Rpb24gZnJvbVR3b3MgKHdpZHRoKSB7XG5cdCAgICBpZiAodGhpcy50ZXN0bih3aWR0aCAtIDEpKSB7XG5cdCAgICAgIHJldHVybiB0aGlzLm5vdG4od2lkdGgpLmlhZGRuKDEpLmluZWcoKTtcblx0ICAgIH1cblx0ICAgIHJldHVybiB0aGlzLmNsb25lKCk7XG5cdCAgfTtcblxuXHQgIEJOLnByb3RvdHlwZS5pc05lZyA9IGZ1bmN0aW9uIGlzTmVnICgpIHtcblx0ICAgIHJldHVybiB0aGlzLm5lZ2F0aXZlICE9PSAwO1xuXHQgIH07XG5cblx0ICAvLyBSZXR1cm4gbmVnYXRpdmUgY2xvbmUgb2YgYHRoaXNgXG5cdCAgQk4ucHJvdG90eXBlLm5lZyA9IGZ1bmN0aW9uIG5lZyAoKSB7XG5cdCAgICByZXR1cm4gdGhpcy5jbG9uZSgpLmluZWcoKTtcblx0ICB9O1xuXG5cdCAgQk4ucHJvdG90eXBlLmluZWcgPSBmdW5jdGlvbiBpbmVnICgpIHtcblx0ICAgIGlmICghdGhpcy5pc1plcm8oKSkge1xuXHQgICAgICB0aGlzLm5lZ2F0aXZlIF49IDE7XG5cdCAgICB9XG5cblx0ICAgIHJldHVybiB0aGlzO1xuXHQgIH07XG5cblx0ICAvLyBPciBgbnVtYCB3aXRoIGB0aGlzYCBpbi1wbGFjZVxuXHQgIEJOLnByb3RvdHlwZS5pdW9yID0gZnVuY3Rpb24gaXVvciAobnVtKSB7XG5cdCAgICB3aGlsZSAodGhpcy5sZW5ndGggPCBudW0ubGVuZ3RoKSB7XG5cdCAgICAgIHRoaXMud29yZHNbdGhpcy5sZW5ndGgrK10gPSAwO1xuXHQgICAgfVxuXG5cdCAgICBmb3IgKHZhciBpID0gMDsgaSA8IG51bS5sZW5ndGg7IGkrKykge1xuXHQgICAgICB0aGlzLndvcmRzW2ldID0gdGhpcy53b3Jkc1tpXSB8IG51bS53b3Jkc1tpXTtcblx0ICAgIH1cblxuXHQgICAgcmV0dXJuIHRoaXMuc3RyaXAoKTtcblx0ICB9O1xuXG5cdCAgQk4ucHJvdG90eXBlLmlvciA9IGZ1bmN0aW9uIGlvciAobnVtKSB7XG5cdCAgICBhc3NlcnQoKHRoaXMubmVnYXRpdmUgfCBudW0ubmVnYXRpdmUpID09PSAwKTtcblx0ICAgIHJldHVybiB0aGlzLml1b3IobnVtKTtcblx0ICB9O1xuXG5cdCAgLy8gT3IgYG51bWAgd2l0aCBgdGhpc2Bcblx0ICBCTi5wcm90b3R5cGUub3IgPSBmdW5jdGlvbiBvciAobnVtKSB7XG5cdCAgICBpZiAodGhpcy5sZW5ndGggPiBudW0ubGVuZ3RoKSByZXR1cm4gdGhpcy5jbG9uZSgpLmlvcihudW0pO1xuXHQgICAgcmV0dXJuIG51bS5jbG9uZSgpLmlvcih0aGlzKTtcblx0ICB9O1xuXG5cdCAgQk4ucHJvdG90eXBlLnVvciA9IGZ1bmN0aW9uIHVvciAobnVtKSB7XG5cdCAgICBpZiAodGhpcy5sZW5ndGggPiBudW0ubGVuZ3RoKSByZXR1cm4gdGhpcy5jbG9uZSgpLml1b3IobnVtKTtcblx0ICAgIHJldHVybiBudW0uY2xvbmUoKS5pdW9yKHRoaXMpO1xuXHQgIH07XG5cblx0ICAvLyBBbmQgYG51bWAgd2l0aCBgdGhpc2AgaW4tcGxhY2Vcblx0ICBCTi5wcm90b3R5cGUuaXVhbmQgPSBmdW5jdGlvbiBpdWFuZCAobnVtKSB7XG5cdCAgICAvLyBiID0gbWluLWxlbmd0aChudW0sIHRoaXMpXG5cdCAgICB2YXIgYjtcblx0ICAgIGlmICh0aGlzLmxlbmd0aCA+IG51bS5sZW5ndGgpIHtcblx0ICAgICAgYiA9IG51bTtcblx0ICAgIH0gZWxzZSB7XG5cdCAgICAgIGIgPSB0aGlzO1xuXHQgICAgfVxuXG5cdCAgICBmb3IgKHZhciBpID0gMDsgaSA8IGIubGVuZ3RoOyBpKyspIHtcblx0ICAgICAgdGhpcy53b3Jkc1tpXSA9IHRoaXMud29yZHNbaV0gJiBudW0ud29yZHNbaV07XG5cdCAgICB9XG5cblx0ICAgIHRoaXMubGVuZ3RoID0gYi5sZW5ndGg7XG5cblx0ICAgIHJldHVybiB0aGlzLnN0cmlwKCk7XG5cdCAgfTtcblxuXHQgIEJOLnByb3RvdHlwZS5pYW5kID0gZnVuY3Rpb24gaWFuZCAobnVtKSB7XG5cdCAgICBhc3NlcnQoKHRoaXMubmVnYXRpdmUgfCBudW0ubmVnYXRpdmUpID09PSAwKTtcblx0ICAgIHJldHVybiB0aGlzLml1YW5kKG51bSk7XG5cdCAgfTtcblxuXHQgIC8vIEFuZCBgbnVtYCB3aXRoIGB0aGlzYFxuXHQgIEJOLnByb3RvdHlwZS5hbmQgPSBmdW5jdGlvbiBhbmQgKG51bSkge1xuXHQgICAgaWYgKHRoaXMubGVuZ3RoID4gbnVtLmxlbmd0aCkgcmV0dXJuIHRoaXMuY2xvbmUoKS5pYW5kKG51bSk7XG5cdCAgICByZXR1cm4gbnVtLmNsb25lKCkuaWFuZCh0aGlzKTtcblx0ICB9O1xuXG5cdCAgQk4ucHJvdG90eXBlLnVhbmQgPSBmdW5jdGlvbiB1YW5kIChudW0pIHtcblx0ICAgIGlmICh0aGlzLmxlbmd0aCA+IG51bS5sZW5ndGgpIHJldHVybiB0aGlzLmNsb25lKCkuaXVhbmQobnVtKTtcblx0ICAgIHJldHVybiBudW0uY2xvbmUoKS5pdWFuZCh0aGlzKTtcblx0ICB9O1xuXG5cdCAgLy8gWG9yIGBudW1gIHdpdGggYHRoaXNgIGluLXBsYWNlXG5cdCAgQk4ucHJvdG90eXBlLml1eG9yID0gZnVuY3Rpb24gaXV4b3IgKG51bSkge1xuXHQgICAgLy8gYS5sZW5ndGggPiBiLmxlbmd0aFxuXHQgICAgdmFyIGE7XG5cdCAgICB2YXIgYjtcblx0ICAgIGlmICh0aGlzLmxlbmd0aCA+IG51bS5sZW5ndGgpIHtcblx0ICAgICAgYSA9IHRoaXM7XG5cdCAgICAgIGIgPSBudW07XG5cdCAgICB9IGVsc2Uge1xuXHQgICAgICBhID0gbnVtO1xuXHQgICAgICBiID0gdGhpcztcblx0ICAgIH1cblxuXHQgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBiLmxlbmd0aDsgaSsrKSB7XG5cdCAgICAgIHRoaXMud29yZHNbaV0gPSBhLndvcmRzW2ldIF4gYi53b3Jkc1tpXTtcblx0ICAgIH1cblxuXHQgICAgaWYgKHRoaXMgIT09IGEpIHtcblx0ICAgICAgZm9yICg7IGkgPCBhLmxlbmd0aDsgaSsrKSB7XG5cdCAgICAgICAgdGhpcy53b3Jkc1tpXSA9IGEud29yZHNbaV07XG5cdCAgICAgIH1cblx0ICAgIH1cblxuXHQgICAgdGhpcy5sZW5ndGggPSBhLmxlbmd0aDtcblxuXHQgICAgcmV0dXJuIHRoaXMuc3RyaXAoKTtcblx0ICB9O1xuXG5cdCAgQk4ucHJvdG90eXBlLml4b3IgPSBmdW5jdGlvbiBpeG9yIChudW0pIHtcblx0ICAgIGFzc2VydCgodGhpcy5uZWdhdGl2ZSB8IG51bS5uZWdhdGl2ZSkgPT09IDApO1xuXHQgICAgcmV0dXJuIHRoaXMuaXV4b3IobnVtKTtcblx0ICB9O1xuXG5cdCAgLy8gWG9yIGBudW1gIHdpdGggYHRoaXNgXG5cdCAgQk4ucHJvdG90eXBlLnhvciA9IGZ1bmN0aW9uIHhvciAobnVtKSB7XG5cdCAgICBpZiAodGhpcy5sZW5ndGggPiBudW0ubGVuZ3RoKSByZXR1cm4gdGhpcy5jbG9uZSgpLml4b3IobnVtKTtcblx0ICAgIHJldHVybiBudW0uY2xvbmUoKS5peG9yKHRoaXMpO1xuXHQgIH07XG5cblx0ICBCTi5wcm90b3R5cGUudXhvciA9IGZ1bmN0aW9uIHV4b3IgKG51bSkge1xuXHQgICAgaWYgKHRoaXMubGVuZ3RoID4gbnVtLmxlbmd0aCkgcmV0dXJuIHRoaXMuY2xvbmUoKS5pdXhvcihudW0pO1xuXHQgICAgcmV0dXJuIG51bS5jbG9uZSgpLml1eG9yKHRoaXMpO1xuXHQgIH07XG5cblx0ICAvLyBOb3QgYGB0aGlzYGAgd2l0aCBgYHdpZHRoYGAgYml0d2lkdGhcblx0ICBCTi5wcm90b3R5cGUuaW5vdG4gPSBmdW5jdGlvbiBpbm90biAod2lkdGgpIHtcblx0ICAgIGFzc2VydCh0eXBlb2Ygd2lkdGggPT09ICdudW1iZXInICYmIHdpZHRoID49IDApO1xuXG5cdCAgICB2YXIgYnl0ZXNOZWVkZWQgPSBNYXRoLmNlaWwod2lkdGggLyAyNikgfCAwO1xuXHQgICAgdmFyIGJpdHNMZWZ0ID0gd2lkdGggJSAyNjtcblxuXHQgICAgLy8gRXh0ZW5kIHRoZSBidWZmZXIgd2l0aCBsZWFkaW5nIHplcm9lc1xuXHQgICAgdGhpcy5fZXhwYW5kKGJ5dGVzTmVlZGVkKTtcblxuXHQgICAgaWYgKGJpdHNMZWZ0ID4gMCkge1xuXHQgICAgICBieXRlc05lZWRlZC0tO1xuXHQgICAgfVxuXG5cdCAgICAvLyBIYW5kbGUgY29tcGxldGUgd29yZHNcblx0ICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYnl0ZXNOZWVkZWQ7IGkrKykge1xuXHQgICAgICB0aGlzLndvcmRzW2ldID0gfnRoaXMud29yZHNbaV0gJiAweDNmZmZmZmY7XG5cdCAgICB9XG5cblx0ICAgIC8vIEhhbmRsZSB0aGUgcmVzaWR1ZVxuXHQgICAgaWYgKGJpdHNMZWZ0ID4gMCkge1xuXHQgICAgICB0aGlzLndvcmRzW2ldID0gfnRoaXMud29yZHNbaV0gJiAoMHgzZmZmZmZmID4+ICgyNiAtIGJpdHNMZWZ0KSk7XG5cdCAgICB9XG5cblx0ICAgIC8vIEFuZCByZW1vdmUgbGVhZGluZyB6ZXJvZXNcblx0ICAgIHJldHVybiB0aGlzLnN0cmlwKCk7XG5cdCAgfTtcblxuXHQgIEJOLnByb3RvdHlwZS5ub3RuID0gZnVuY3Rpb24gbm90biAod2lkdGgpIHtcblx0ICAgIHJldHVybiB0aGlzLmNsb25lKCkuaW5vdG4od2lkdGgpO1xuXHQgIH07XG5cblx0ICAvLyBTZXQgYGJpdGAgb2YgYHRoaXNgXG5cdCAgQk4ucHJvdG90eXBlLnNldG4gPSBmdW5jdGlvbiBzZXRuIChiaXQsIHZhbCkge1xuXHQgICAgYXNzZXJ0KHR5cGVvZiBiaXQgPT09ICdudW1iZXInICYmIGJpdCA+PSAwKTtcblxuXHQgICAgdmFyIG9mZiA9IChiaXQgLyAyNikgfCAwO1xuXHQgICAgdmFyIHdiaXQgPSBiaXQgJSAyNjtcblxuXHQgICAgdGhpcy5fZXhwYW5kKG9mZiArIDEpO1xuXG5cdCAgICBpZiAodmFsKSB7XG5cdCAgICAgIHRoaXMud29yZHNbb2ZmXSA9IHRoaXMud29yZHNbb2ZmXSB8ICgxIDw8IHdiaXQpO1xuXHQgICAgfSBlbHNlIHtcblx0ICAgICAgdGhpcy53b3Jkc1tvZmZdID0gdGhpcy53b3Jkc1tvZmZdICYgfigxIDw8IHdiaXQpO1xuXHQgICAgfVxuXG5cdCAgICByZXR1cm4gdGhpcy5zdHJpcCgpO1xuXHQgIH07XG5cblx0ICAvLyBBZGQgYG51bWAgdG8gYHRoaXNgIGluLXBsYWNlXG5cdCAgQk4ucHJvdG90eXBlLmlhZGQgPSBmdW5jdGlvbiBpYWRkIChudW0pIHtcblx0ICAgIHZhciByO1xuXG5cdCAgICAvLyBuZWdhdGl2ZSArIHBvc2l0aXZlXG5cdCAgICBpZiAodGhpcy5uZWdhdGl2ZSAhPT0gMCAmJiBudW0ubmVnYXRpdmUgPT09IDApIHtcblx0ICAgICAgdGhpcy5uZWdhdGl2ZSA9IDA7XG5cdCAgICAgIHIgPSB0aGlzLmlzdWIobnVtKTtcblx0ICAgICAgdGhpcy5uZWdhdGl2ZSBePSAxO1xuXHQgICAgICByZXR1cm4gdGhpcy5fbm9ybVNpZ24oKTtcblxuXHQgICAgLy8gcG9zaXRpdmUgKyBuZWdhdGl2ZVxuXHQgICAgfSBlbHNlIGlmICh0aGlzLm5lZ2F0aXZlID09PSAwICYmIG51bS5uZWdhdGl2ZSAhPT0gMCkge1xuXHQgICAgICBudW0ubmVnYXRpdmUgPSAwO1xuXHQgICAgICByID0gdGhpcy5pc3ViKG51bSk7XG5cdCAgICAgIG51bS5uZWdhdGl2ZSA9IDE7XG5cdCAgICAgIHJldHVybiByLl9ub3JtU2lnbigpO1xuXHQgICAgfVxuXG5cdCAgICAvLyBhLmxlbmd0aCA+IGIubGVuZ3RoXG5cdCAgICB2YXIgYSwgYjtcblx0ICAgIGlmICh0aGlzLmxlbmd0aCA+IG51bS5sZW5ndGgpIHtcblx0ICAgICAgYSA9IHRoaXM7XG5cdCAgICAgIGIgPSBudW07XG5cdCAgICB9IGVsc2Uge1xuXHQgICAgICBhID0gbnVtO1xuXHQgICAgICBiID0gdGhpcztcblx0ICAgIH1cblxuXHQgICAgdmFyIGNhcnJ5ID0gMDtcblx0ICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYi5sZW5ndGg7IGkrKykge1xuXHQgICAgICByID0gKGEud29yZHNbaV0gfCAwKSArIChiLndvcmRzW2ldIHwgMCkgKyBjYXJyeTtcblx0ICAgICAgdGhpcy53b3Jkc1tpXSA9IHIgJiAweDNmZmZmZmY7XG5cdCAgICAgIGNhcnJ5ID0gciA+Pj4gMjY7XG5cdCAgICB9XG5cdCAgICBmb3IgKDsgY2FycnkgIT09IDAgJiYgaSA8IGEubGVuZ3RoOyBpKyspIHtcblx0ICAgICAgciA9IChhLndvcmRzW2ldIHwgMCkgKyBjYXJyeTtcblx0ICAgICAgdGhpcy53b3Jkc1tpXSA9IHIgJiAweDNmZmZmZmY7XG5cdCAgICAgIGNhcnJ5ID0gciA+Pj4gMjY7XG5cdCAgICB9XG5cblx0ICAgIHRoaXMubGVuZ3RoID0gYS5sZW5ndGg7XG5cdCAgICBpZiAoY2FycnkgIT09IDApIHtcblx0ICAgICAgdGhpcy53b3Jkc1t0aGlzLmxlbmd0aF0gPSBjYXJyeTtcblx0ICAgICAgdGhpcy5sZW5ndGgrKztcblx0ICAgIC8vIENvcHkgdGhlIHJlc3Qgb2YgdGhlIHdvcmRzXG5cdCAgICB9IGVsc2UgaWYgKGEgIT09IHRoaXMpIHtcblx0ICAgICAgZm9yICg7IGkgPCBhLmxlbmd0aDsgaSsrKSB7XG5cdCAgICAgICAgdGhpcy53b3Jkc1tpXSA9IGEud29yZHNbaV07XG5cdCAgICAgIH1cblx0ICAgIH1cblxuXHQgICAgcmV0dXJuIHRoaXM7XG5cdCAgfTtcblxuXHQgIC8vIEFkZCBgbnVtYCB0byBgdGhpc2Bcblx0ICBCTi5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24gYWRkIChudW0pIHtcblx0ICAgIHZhciByZXM7XG5cdCAgICBpZiAobnVtLm5lZ2F0aXZlICE9PSAwICYmIHRoaXMubmVnYXRpdmUgPT09IDApIHtcblx0ICAgICAgbnVtLm5lZ2F0aXZlID0gMDtcblx0ICAgICAgcmVzID0gdGhpcy5zdWIobnVtKTtcblx0ICAgICAgbnVtLm5lZ2F0aXZlIF49IDE7XG5cdCAgICAgIHJldHVybiByZXM7XG5cdCAgICB9IGVsc2UgaWYgKG51bS5uZWdhdGl2ZSA9PT0gMCAmJiB0aGlzLm5lZ2F0aXZlICE9PSAwKSB7XG5cdCAgICAgIHRoaXMubmVnYXRpdmUgPSAwO1xuXHQgICAgICByZXMgPSBudW0uc3ViKHRoaXMpO1xuXHQgICAgICB0aGlzLm5lZ2F0aXZlID0gMTtcblx0ICAgICAgcmV0dXJuIHJlcztcblx0ICAgIH1cblxuXHQgICAgaWYgKHRoaXMubGVuZ3RoID4gbnVtLmxlbmd0aCkgcmV0dXJuIHRoaXMuY2xvbmUoKS5pYWRkKG51bSk7XG5cblx0ICAgIHJldHVybiBudW0uY2xvbmUoKS5pYWRkKHRoaXMpO1xuXHQgIH07XG5cblx0ICAvLyBTdWJ0cmFjdCBgbnVtYCBmcm9tIGB0aGlzYCBpbi1wbGFjZVxuXHQgIEJOLnByb3RvdHlwZS5pc3ViID0gZnVuY3Rpb24gaXN1YiAobnVtKSB7XG5cdCAgICAvLyB0aGlzIC0gKC1udW0pID0gdGhpcyArIG51bVxuXHQgICAgaWYgKG51bS5uZWdhdGl2ZSAhPT0gMCkge1xuXHQgICAgICBudW0ubmVnYXRpdmUgPSAwO1xuXHQgICAgICB2YXIgciA9IHRoaXMuaWFkZChudW0pO1xuXHQgICAgICBudW0ubmVnYXRpdmUgPSAxO1xuXHQgICAgICByZXR1cm4gci5fbm9ybVNpZ24oKTtcblxuXHQgICAgLy8gLXRoaXMgLSBudW0gPSAtKHRoaXMgKyBudW0pXG5cdCAgICB9IGVsc2UgaWYgKHRoaXMubmVnYXRpdmUgIT09IDApIHtcblx0ICAgICAgdGhpcy5uZWdhdGl2ZSA9IDA7XG5cdCAgICAgIHRoaXMuaWFkZChudW0pO1xuXHQgICAgICB0aGlzLm5lZ2F0aXZlID0gMTtcblx0ICAgICAgcmV0dXJuIHRoaXMuX25vcm1TaWduKCk7XG5cdCAgICB9XG5cblx0ICAgIC8vIEF0IHRoaXMgcG9pbnQgYm90aCBudW1iZXJzIGFyZSBwb3NpdGl2ZVxuXHQgICAgdmFyIGNtcCA9IHRoaXMuY21wKG51bSk7XG5cblx0ICAgIC8vIE9wdGltaXphdGlvbiAtIHplcm9pZnlcblx0ICAgIGlmIChjbXAgPT09IDApIHtcblx0ICAgICAgdGhpcy5uZWdhdGl2ZSA9IDA7XG5cdCAgICAgIHRoaXMubGVuZ3RoID0gMTtcblx0ICAgICAgdGhpcy53b3Jkc1swXSA9IDA7XG5cdCAgICAgIHJldHVybiB0aGlzO1xuXHQgICAgfVxuXG5cdCAgICAvLyBhID4gYlxuXHQgICAgdmFyIGEsIGI7XG5cdCAgICBpZiAoY21wID4gMCkge1xuXHQgICAgICBhID0gdGhpcztcblx0ICAgICAgYiA9IG51bTtcblx0ICAgIH0gZWxzZSB7XG5cdCAgICAgIGEgPSBudW07XG5cdCAgICAgIGIgPSB0aGlzO1xuXHQgICAgfVxuXG5cdCAgICB2YXIgY2FycnkgPSAwO1xuXHQgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBiLmxlbmd0aDsgaSsrKSB7XG5cdCAgICAgIHIgPSAoYS53b3Jkc1tpXSB8IDApIC0gKGIud29yZHNbaV0gfCAwKSArIGNhcnJ5O1xuXHQgICAgICBjYXJyeSA9IHIgPj4gMjY7XG5cdCAgICAgIHRoaXMud29yZHNbaV0gPSByICYgMHgzZmZmZmZmO1xuXHQgICAgfVxuXHQgICAgZm9yICg7IGNhcnJ5ICE9PSAwICYmIGkgPCBhLmxlbmd0aDsgaSsrKSB7XG5cdCAgICAgIHIgPSAoYS53b3Jkc1tpXSB8IDApICsgY2Fycnk7XG5cdCAgICAgIGNhcnJ5ID0gciA+PiAyNjtcblx0ICAgICAgdGhpcy53b3Jkc1tpXSA9IHIgJiAweDNmZmZmZmY7XG5cdCAgICB9XG5cblx0ICAgIC8vIENvcHkgcmVzdCBvZiB0aGUgd29yZHNcblx0ICAgIGlmIChjYXJyeSA9PT0gMCAmJiBpIDwgYS5sZW5ndGggJiYgYSAhPT0gdGhpcykge1xuXHQgICAgICBmb3IgKDsgaSA8IGEubGVuZ3RoOyBpKyspIHtcblx0ICAgICAgICB0aGlzLndvcmRzW2ldID0gYS53b3Jkc1tpXTtcblx0ICAgICAgfVxuXHQgICAgfVxuXG5cdCAgICB0aGlzLmxlbmd0aCA9IE1hdGgubWF4KHRoaXMubGVuZ3RoLCBpKTtcblxuXHQgICAgaWYgKGEgIT09IHRoaXMpIHtcblx0ICAgICAgdGhpcy5uZWdhdGl2ZSA9IDE7XG5cdCAgICB9XG5cblx0ICAgIHJldHVybiB0aGlzLnN0cmlwKCk7XG5cdCAgfTtcblxuXHQgIC8vIFN1YnRyYWN0IGBudW1gIGZyb20gYHRoaXNgXG5cdCAgQk4ucHJvdG90eXBlLnN1YiA9IGZ1bmN0aW9uIHN1YiAobnVtKSB7XG5cdCAgICByZXR1cm4gdGhpcy5jbG9uZSgpLmlzdWIobnVtKTtcblx0ICB9O1xuXG5cdCAgZnVuY3Rpb24gc21hbGxNdWxUbyAoc2VsZiwgbnVtLCBvdXQpIHtcblx0ICAgIG91dC5uZWdhdGl2ZSA9IG51bS5uZWdhdGl2ZSBeIHNlbGYubmVnYXRpdmU7XG5cdCAgICB2YXIgbGVuID0gKHNlbGYubGVuZ3RoICsgbnVtLmxlbmd0aCkgfCAwO1xuXHQgICAgb3V0Lmxlbmd0aCA9IGxlbjtcblx0ICAgIGxlbiA9IChsZW4gLSAxKSB8IDA7XG5cblx0ICAgIC8vIFBlZWwgb25lIGl0ZXJhdGlvbiAoY29tcGlsZXIgY2FuJ3QgZG8gaXQsIGJlY2F1c2Ugb2YgY29kZSBjb21wbGV4aXR5KVxuXHQgICAgdmFyIGEgPSBzZWxmLndvcmRzWzBdIHwgMDtcblx0ICAgIHZhciBiID0gbnVtLndvcmRzWzBdIHwgMDtcblx0ICAgIHZhciByID0gYSAqIGI7XG5cblx0ICAgIHZhciBsbyA9IHIgJiAweDNmZmZmZmY7XG5cdCAgICB2YXIgY2FycnkgPSAociAvIDB4NDAwMDAwMCkgfCAwO1xuXHQgICAgb3V0LndvcmRzWzBdID0gbG87XG5cblx0ICAgIGZvciAodmFyIGsgPSAxOyBrIDwgbGVuOyBrKyspIHtcblx0ICAgICAgLy8gU3VtIGFsbCB3b3JkcyB3aXRoIHRoZSBzYW1lIGBpICsgaiA9IGtgIGFuZCBhY2N1bXVsYXRlIGBuY2FycnlgLFxuXHQgICAgICAvLyBub3RlIHRoYXQgbmNhcnJ5IGNvdWxkIGJlID49IDB4M2ZmZmZmZlxuXHQgICAgICB2YXIgbmNhcnJ5ID0gY2FycnkgPj4+IDI2O1xuXHQgICAgICB2YXIgcndvcmQgPSBjYXJyeSAmIDB4M2ZmZmZmZjtcblx0ICAgICAgdmFyIG1heEogPSBNYXRoLm1pbihrLCBudW0ubGVuZ3RoIC0gMSk7XG5cdCAgICAgIGZvciAodmFyIGogPSBNYXRoLm1heCgwLCBrIC0gc2VsZi5sZW5ndGggKyAxKTsgaiA8PSBtYXhKOyBqKyspIHtcblx0ICAgICAgICB2YXIgaSA9IChrIC0gaikgfCAwO1xuXHQgICAgICAgIGEgPSBzZWxmLndvcmRzW2ldIHwgMDtcblx0ICAgICAgICBiID0gbnVtLndvcmRzW2pdIHwgMDtcblx0ICAgICAgICByID0gYSAqIGIgKyByd29yZDtcblx0ICAgICAgICBuY2FycnkgKz0gKHIgLyAweDQwMDAwMDApIHwgMDtcblx0ICAgICAgICByd29yZCA9IHIgJiAweDNmZmZmZmY7XG5cdCAgICAgIH1cblx0ICAgICAgb3V0LndvcmRzW2tdID0gcndvcmQgfCAwO1xuXHQgICAgICBjYXJyeSA9IG5jYXJyeSB8IDA7XG5cdCAgICB9XG5cdCAgICBpZiAoY2FycnkgIT09IDApIHtcblx0ICAgICAgb3V0LndvcmRzW2tdID0gY2FycnkgfCAwO1xuXHQgICAgfSBlbHNlIHtcblx0ICAgICAgb3V0Lmxlbmd0aC0tO1xuXHQgICAgfVxuXG5cdCAgICByZXR1cm4gb3V0LnN0cmlwKCk7XG5cdCAgfVxuXG5cdCAgLy8gVE9ETyhpbmR1dG55KTogaXQgbWF5IGJlIHJlYXNvbmFibGUgdG8gb21pdCBpdCBmb3IgdXNlcnMgd2hvIGRvbid0IG5lZWRcblx0ICAvLyB0byB3b3JrIHdpdGggMjU2LWJpdCBudW1iZXJzLCBvdGhlcndpc2UgaXQgZ2l2ZXMgMjAlIGltcHJvdmVtZW50IGZvciAyNTYtYml0XG5cdCAgLy8gbXVsdGlwbGljYXRpb24gKGxpa2UgZWxsaXB0aWMgc2VjcDI1NmsxKS5cblx0ICB2YXIgY29tYjEwTXVsVG8gPSBmdW5jdGlvbiBjb21iMTBNdWxUbyAoc2VsZiwgbnVtLCBvdXQpIHtcblx0ICAgIHZhciBhID0gc2VsZi53b3Jkcztcblx0ICAgIHZhciBiID0gbnVtLndvcmRzO1xuXHQgICAgdmFyIG8gPSBvdXQud29yZHM7XG5cdCAgICB2YXIgYyA9IDA7XG5cdCAgICB2YXIgbG87XG5cdCAgICB2YXIgbWlkO1xuXHQgICAgdmFyIGhpO1xuXHQgICAgdmFyIGEwID0gYVswXSB8IDA7XG5cdCAgICB2YXIgYWwwID0gYTAgJiAweDFmZmY7XG5cdCAgICB2YXIgYWgwID0gYTAgPj4+IDEzO1xuXHQgICAgdmFyIGExID0gYVsxXSB8IDA7XG5cdCAgICB2YXIgYWwxID0gYTEgJiAweDFmZmY7XG5cdCAgICB2YXIgYWgxID0gYTEgPj4+IDEzO1xuXHQgICAgdmFyIGEyID0gYVsyXSB8IDA7XG5cdCAgICB2YXIgYWwyID0gYTIgJiAweDFmZmY7XG5cdCAgICB2YXIgYWgyID0gYTIgPj4+IDEzO1xuXHQgICAgdmFyIGEzID0gYVszXSB8IDA7XG5cdCAgICB2YXIgYWwzID0gYTMgJiAweDFmZmY7XG5cdCAgICB2YXIgYWgzID0gYTMgPj4+IDEzO1xuXHQgICAgdmFyIGE0ID0gYVs0XSB8IDA7XG5cdCAgICB2YXIgYWw0ID0gYTQgJiAweDFmZmY7XG5cdCAgICB2YXIgYWg0ID0gYTQgPj4+IDEzO1xuXHQgICAgdmFyIGE1ID0gYVs1XSB8IDA7XG5cdCAgICB2YXIgYWw1ID0gYTUgJiAweDFmZmY7XG5cdCAgICB2YXIgYWg1ID0gYTUgPj4+IDEzO1xuXHQgICAgdmFyIGE2ID0gYVs2XSB8IDA7XG5cdCAgICB2YXIgYWw2ID0gYTYgJiAweDFmZmY7XG5cdCAgICB2YXIgYWg2ID0gYTYgPj4+IDEzO1xuXHQgICAgdmFyIGE3ID0gYVs3XSB8IDA7XG5cdCAgICB2YXIgYWw3ID0gYTcgJiAweDFmZmY7XG5cdCAgICB2YXIgYWg3ID0gYTcgPj4+IDEzO1xuXHQgICAgdmFyIGE4ID0gYVs4XSB8IDA7XG5cdCAgICB2YXIgYWw4ID0gYTggJiAweDFmZmY7XG5cdCAgICB2YXIgYWg4ID0gYTggPj4+IDEzO1xuXHQgICAgdmFyIGE5ID0gYVs5XSB8IDA7XG5cdCAgICB2YXIgYWw5ID0gYTkgJiAweDFmZmY7XG5cdCAgICB2YXIgYWg5ID0gYTkgPj4+IDEzO1xuXHQgICAgdmFyIGIwID0gYlswXSB8IDA7XG5cdCAgICB2YXIgYmwwID0gYjAgJiAweDFmZmY7XG5cdCAgICB2YXIgYmgwID0gYjAgPj4+IDEzO1xuXHQgICAgdmFyIGIxID0gYlsxXSB8IDA7XG5cdCAgICB2YXIgYmwxID0gYjEgJiAweDFmZmY7XG5cdCAgICB2YXIgYmgxID0gYjEgPj4+IDEzO1xuXHQgICAgdmFyIGIyID0gYlsyXSB8IDA7XG5cdCAgICB2YXIgYmwyID0gYjIgJiAweDFmZmY7XG5cdCAgICB2YXIgYmgyID0gYjIgPj4+IDEzO1xuXHQgICAgdmFyIGIzID0gYlszXSB8IDA7XG5cdCAgICB2YXIgYmwzID0gYjMgJiAweDFmZmY7XG5cdCAgICB2YXIgYmgzID0gYjMgPj4+IDEzO1xuXHQgICAgdmFyIGI0ID0gYls0XSB8IDA7XG5cdCAgICB2YXIgYmw0ID0gYjQgJiAweDFmZmY7XG5cdCAgICB2YXIgYmg0ID0gYjQgPj4+IDEzO1xuXHQgICAgdmFyIGI1ID0gYls1XSB8IDA7XG5cdCAgICB2YXIgYmw1ID0gYjUgJiAweDFmZmY7XG5cdCAgICB2YXIgYmg1ID0gYjUgPj4+IDEzO1xuXHQgICAgdmFyIGI2ID0gYls2XSB8IDA7XG5cdCAgICB2YXIgYmw2ID0gYjYgJiAweDFmZmY7XG5cdCAgICB2YXIgYmg2ID0gYjYgPj4+IDEzO1xuXHQgICAgdmFyIGI3ID0gYls3XSB8IDA7XG5cdCAgICB2YXIgYmw3ID0gYjcgJiAweDFmZmY7XG5cdCAgICB2YXIgYmg3ID0gYjcgPj4+IDEzO1xuXHQgICAgdmFyIGI4ID0gYls4XSB8IDA7XG5cdCAgICB2YXIgYmw4ID0gYjggJiAweDFmZmY7XG5cdCAgICB2YXIgYmg4ID0gYjggPj4+IDEzO1xuXHQgICAgdmFyIGI5ID0gYls5XSB8IDA7XG5cdCAgICB2YXIgYmw5ID0gYjkgJiAweDFmZmY7XG5cdCAgICB2YXIgYmg5ID0gYjkgPj4+IDEzO1xuXG5cdCAgICBvdXQubmVnYXRpdmUgPSBzZWxmLm5lZ2F0aXZlIF4gbnVtLm5lZ2F0aXZlO1xuXHQgICAgb3V0Lmxlbmd0aCA9IDE5O1xuXHQgICAgLyogayA9IDAgKi9cblx0ICAgIGxvID0gTWF0aC5pbXVsKGFsMCwgYmwwKTtcblx0ICAgIG1pZCA9IE1hdGguaW11bChhbDAsIGJoMCk7XG5cdCAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoMCwgYmwwKSkgfCAwO1xuXHQgICAgaGkgPSBNYXRoLmltdWwoYWgwLCBiaDApO1xuXHQgICAgdmFyIHcwID0gKCgoYyArIGxvKSB8IDApICsgKChtaWQgJiAweDFmZmYpIDw8IDEzKSkgfCAwO1xuXHQgICAgYyA9ICgoKGhpICsgKG1pZCA+Pj4gMTMpKSB8IDApICsgKHcwID4+PiAyNikpIHwgMDtcblx0ICAgIHcwICY9IDB4M2ZmZmZmZjtcblx0ICAgIC8qIGsgPSAxICovXG5cdCAgICBsbyA9IE1hdGguaW11bChhbDEsIGJsMCk7XG5cdCAgICBtaWQgPSBNYXRoLmltdWwoYWwxLCBiaDApO1xuXHQgICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDEsIGJsMCkpIHwgMDtcblx0ICAgIGhpID0gTWF0aC5pbXVsKGFoMSwgYmgwKTtcblx0ICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsMCwgYmwxKSkgfCAwO1xuXHQgICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDAsIGJoMSkpIHwgMDtcblx0ICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWgwLCBibDEpKSB8IDA7XG5cdCAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDAsIGJoMSkpIHwgMDtcblx0ICAgIHZhciB3MSA9ICgoKGMgKyBsbykgfCAwKSArICgobWlkICYgMHgxZmZmKSA8PCAxMykpIHwgMDtcblx0ICAgIGMgPSAoKChoaSArIChtaWQgPj4+IDEzKSkgfCAwKSArICh3MSA+Pj4gMjYpKSB8IDA7XG5cdCAgICB3MSAmPSAweDNmZmZmZmY7XG5cdCAgICAvKiBrID0gMiAqL1xuXHQgICAgbG8gPSBNYXRoLmltdWwoYWwyLCBibDApO1xuXHQgICAgbWlkID0gTWF0aC5pbXVsKGFsMiwgYmgwKTtcblx0ICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWgyLCBibDApKSB8IDA7XG5cdCAgICBoaSA9IE1hdGguaW11bChhaDIsIGJoMCk7XG5cdCAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDEsIGJsMSkpIHwgMDtcblx0ICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWwxLCBiaDEpKSB8IDA7XG5cdCAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoMSwgYmwxKSkgfCAwO1xuXHQgICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWgxLCBiaDEpKSB8IDA7XG5cdCAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDAsIGJsMikpIHwgMDtcblx0ICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWwwLCBiaDIpKSB8IDA7XG5cdCAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoMCwgYmwyKSkgfCAwO1xuXHQgICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWgwLCBiaDIpKSB8IDA7XG5cdCAgICB2YXIgdzIgPSAoKChjICsgbG8pIHwgMCkgKyAoKG1pZCAmIDB4MWZmZikgPDwgMTMpKSB8IDA7XG5cdCAgICBjID0gKCgoaGkgKyAobWlkID4+PiAxMykpIHwgMCkgKyAodzIgPj4+IDI2KSkgfCAwO1xuXHQgICAgdzIgJj0gMHgzZmZmZmZmO1xuXHQgICAgLyogayA9IDMgKi9cblx0ICAgIGxvID0gTWF0aC5pbXVsKGFsMywgYmwwKTtcblx0ICAgIG1pZCA9IE1hdGguaW11bChhbDMsIGJoMCk7XG5cdCAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoMywgYmwwKSkgfCAwO1xuXHQgICAgaGkgPSBNYXRoLmltdWwoYWgzLCBiaDApO1xuXHQgICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWwyLCBibDEpKSB8IDA7XG5cdCAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsMiwgYmgxKSkgfCAwO1xuXHQgICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDIsIGJsMSkpIHwgMDtcblx0ICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoMiwgYmgxKSkgfCAwO1xuXHQgICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWwxLCBibDIpKSB8IDA7XG5cdCAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsMSwgYmgyKSkgfCAwO1xuXHQgICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDEsIGJsMikpIHwgMDtcblx0ICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoMSwgYmgyKSkgfCAwO1xuXHQgICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWwwLCBibDMpKSB8IDA7XG5cdCAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsMCwgYmgzKSkgfCAwO1xuXHQgICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDAsIGJsMykpIHwgMDtcblx0ICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoMCwgYmgzKSkgfCAwO1xuXHQgICAgdmFyIHczID0gKCgoYyArIGxvKSB8IDApICsgKChtaWQgJiAweDFmZmYpIDw8IDEzKSkgfCAwO1xuXHQgICAgYyA9ICgoKGhpICsgKG1pZCA+Pj4gMTMpKSB8IDApICsgKHczID4+PiAyNikpIHwgMDtcblx0ICAgIHczICY9IDB4M2ZmZmZmZjtcblx0ICAgIC8qIGsgPSA0ICovXG5cdCAgICBsbyA9IE1hdGguaW11bChhbDQsIGJsMCk7XG5cdCAgICBtaWQgPSBNYXRoLmltdWwoYWw0LCBiaDApO1xuXHQgICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDQsIGJsMCkpIHwgMDtcblx0ICAgIGhpID0gTWF0aC5pbXVsKGFoNCwgYmgwKTtcblx0ICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsMywgYmwxKSkgfCAwO1xuXHQgICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDMsIGJoMSkpIHwgMDtcblx0ICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWgzLCBibDEpKSB8IDA7XG5cdCAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDMsIGJoMSkpIHwgMDtcblx0ICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsMiwgYmwyKSkgfCAwO1xuXHQgICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDIsIGJoMikpIHwgMDtcblx0ICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWgyLCBibDIpKSB8IDA7XG5cdCAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDIsIGJoMikpIHwgMDtcblx0ICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsMSwgYmwzKSkgfCAwO1xuXHQgICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDEsIGJoMykpIHwgMDtcblx0ICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWgxLCBibDMpKSB8IDA7XG5cdCAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDEsIGJoMykpIHwgMDtcblx0ICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsMCwgYmw0KSkgfCAwO1xuXHQgICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDAsIGJoNCkpIHwgMDtcblx0ICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWgwLCBibDQpKSB8IDA7XG5cdCAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDAsIGJoNCkpIHwgMDtcblx0ICAgIHZhciB3NCA9ICgoKGMgKyBsbykgfCAwKSArICgobWlkICYgMHgxZmZmKSA8PCAxMykpIHwgMDtcblx0ICAgIGMgPSAoKChoaSArIChtaWQgPj4+IDEzKSkgfCAwKSArICh3NCA+Pj4gMjYpKSB8IDA7XG5cdCAgICB3NCAmPSAweDNmZmZmZmY7XG5cdCAgICAvKiBrID0gNSAqL1xuXHQgICAgbG8gPSBNYXRoLmltdWwoYWw1LCBibDApO1xuXHQgICAgbWlkID0gTWF0aC5pbXVsKGFsNSwgYmgwKTtcblx0ICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg1LCBibDApKSB8IDA7XG5cdCAgICBoaSA9IE1hdGguaW11bChhaDUsIGJoMCk7XG5cdCAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDQsIGJsMSkpIHwgMDtcblx0ICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWw0LCBiaDEpKSB8IDA7XG5cdCAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoNCwgYmwxKSkgfCAwO1xuXHQgICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWg0LCBiaDEpKSB8IDA7XG5cdCAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDMsIGJsMikpIHwgMDtcblx0ICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWwzLCBiaDIpKSB8IDA7XG5cdCAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoMywgYmwyKSkgfCAwO1xuXHQgICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWgzLCBiaDIpKSB8IDA7XG5cdCAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDIsIGJsMykpIHwgMDtcblx0ICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWwyLCBiaDMpKSB8IDA7XG5cdCAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoMiwgYmwzKSkgfCAwO1xuXHQgICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWgyLCBiaDMpKSB8IDA7XG5cdCAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDEsIGJsNCkpIHwgMDtcblx0ICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWwxLCBiaDQpKSB8IDA7XG5cdCAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoMSwgYmw0KSkgfCAwO1xuXHQgICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWgxLCBiaDQpKSB8IDA7XG5cdCAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDAsIGJsNSkpIHwgMDtcblx0ICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWwwLCBiaDUpKSB8IDA7XG5cdCAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoMCwgYmw1KSkgfCAwO1xuXHQgICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWgwLCBiaDUpKSB8IDA7XG5cdCAgICB2YXIgdzUgPSAoKChjICsgbG8pIHwgMCkgKyAoKG1pZCAmIDB4MWZmZikgPDwgMTMpKSB8IDA7XG5cdCAgICBjID0gKCgoaGkgKyAobWlkID4+PiAxMykpIHwgMCkgKyAodzUgPj4+IDI2KSkgfCAwO1xuXHQgICAgdzUgJj0gMHgzZmZmZmZmO1xuXHQgICAgLyogayA9IDYgKi9cblx0ICAgIGxvID0gTWF0aC5pbXVsKGFsNiwgYmwwKTtcblx0ICAgIG1pZCA9IE1hdGguaW11bChhbDYsIGJoMCk7XG5cdCAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoNiwgYmwwKSkgfCAwO1xuXHQgICAgaGkgPSBNYXRoLmltdWwoYWg2LCBiaDApO1xuXHQgICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWw1LCBibDEpKSB8IDA7XG5cdCAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsNSwgYmgxKSkgfCAwO1xuXHQgICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDUsIGJsMSkpIHwgMDtcblx0ICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoNSwgYmgxKSkgfCAwO1xuXHQgICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWw0LCBibDIpKSB8IDA7XG5cdCAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsNCwgYmgyKSkgfCAwO1xuXHQgICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDQsIGJsMikpIHwgMDtcblx0ICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoNCwgYmgyKSkgfCAwO1xuXHQgICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWwzLCBibDMpKSB8IDA7XG5cdCAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsMywgYmgzKSkgfCAwO1xuXHQgICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDMsIGJsMykpIHwgMDtcblx0ICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoMywgYmgzKSkgfCAwO1xuXHQgICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWwyLCBibDQpKSB8IDA7XG5cdCAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsMiwgYmg0KSkgfCAwO1xuXHQgICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDIsIGJsNCkpIHwgMDtcblx0ICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoMiwgYmg0KSkgfCAwO1xuXHQgICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWwxLCBibDUpKSB8IDA7XG5cdCAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsMSwgYmg1KSkgfCAwO1xuXHQgICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDEsIGJsNSkpIHwgMDtcblx0ICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoMSwgYmg1KSkgfCAwO1xuXHQgICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWwwLCBibDYpKSB8IDA7XG5cdCAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsMCwgYmg2KSkgfCAwO1xuXHQgICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDAsIGJsNikpIHwgMDtcblx0ICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoMCwgYmg2KSkgfCAwO1xuXHQgICAgdmFyIHc2ID0gKCgoYyArIGxvKSB8IDApICsgKChtaWQgJiAweDFmZmYpIDw8IDEzKSkgfCAwO1xuXHQgICAgYyA9ICgoKGhpICsgKG1pZCA+Pj4gMTMpKSB8IDApICsgKHc2ID4+PiAyNikpIHwgMDtcblx0ICAgIHc2ICY9IDB4M2ZmZmZmZjtcblx0ICAgIC8qIGsgPSA3ICovXG5cdCAgICBsbyA9IE1hdGguaW11bChhbDcsIGJsMCk7XG5cdCAgICBtaWQgPSBNYXRoLmltdWwoYWw3LCBiaDApO1xuXHQgICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDcsIGJsMCkpIHwgMDtcblx0ICAgIGhpID0gTWF0aC5pbXVsKGFoNywgYmgwKTtcblx0ICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsNiwgYmwxKSkgfCAwO1xuXHQgICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDYsIGJoMSkpIHwgMDtcblx0ICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg2LCBibDEpKSB8IDA7XG5cdCAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDYsIGJoMSkpIHwgMDtcblx0ICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsNSwgYmwyKSkgfCAwO1xuXHQgICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDUsIGJoMikpIHwgMDtcblx0ICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg1LCBibDIpKSB8IDA7XG5cdCAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDUsIGJoMikpIHwgMDtcblx0ICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsNCwgYmwzKSkgfCAwO1xuXHQgICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDQsIGJoMykpIHwgMDtcblx0ICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg0LCBibDMpKSB8IDA7XG5cdCAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDQsIGJoMykpIHwgMDtcblx0ICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsMywgYmw0KSkgfCAwO1xuXHQgICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDMsIGJoNCkpIHwgMDtcblx0ICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWgzLCBibDQpKSB8IDA7XG5cdCAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDMsIGJoNCkpIHwgMDtcblx0ICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsMiwgYmw1KSkgfCAwO1xuXHQgICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDIsIGJoNSkpIHwgMDtcblx0ICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWgyLCBibDUpKSB8IDA7XG5cdCAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDIsIGJoNSkpIHwgMDtcblx0ICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsMSwgYmw2KSkgfCAwO1xuXHQgICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDEsIGJoNikpIHwgMDtcblx0ICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWgxLCBibDYpKSB8IDA7XG5cdCAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDEsIGJoNikpIHwgMDtcblx0ICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsMCwgYmw3KSkgfCAwO1xuXHQgICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDAsIGJoNykpIHwgMDtcblx0ICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWgwLCBibDcpKSB8IDA7XG5cdCAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDAsIGJoNykpIHwgMDtcblx0ICAgIHZhciB3NyA9ICgoKGMgKyBsbykgfCAwKSArICgobWlkICYgMHgxZmZmKSA8PCAxMykpIHwgMDtcblx0ICAgIGMgPSAoKChoaSArIChtaWQgPj4+IDEzKSkgfCAwKSArICh3NyA+Pj4gMjYpKSB8IDA7XG5cdCAgICB3NyAmPSAweDNmZmZmZmY7XG5cdCAgICAvKiBrID0gOCAqL1xuXHQgICAgbG8gPSBNYXRoLmltdWwoYWw4LCBibDApO1xuXHQgICAgbWlkID0gTWF0aC5pbXVsKGFsOCwgYmgwKTtcblx0ICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg4LCBibDApKSB8IDA7XG5cdCAgICBoaSA9IE1hdGguaW11bChhaDgsIGJoMCk7XG5cdCAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDcsIGJsMSkpIHwgMDtcblx0ICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWw3LCBiaDEpKSB8IDA7XG5cdCAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoNywgYmwxKSkgfCAwO1xuXHQgICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWg3LCBiaDEpKSB8IDA7XG5cdCAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDYsIGJsMikpIHwgMDtcblx0ICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWw2LCBiaDIpKSB8IDA7XG5cdCAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoNiwgYmwyKSkgfCAwO1xuXHQgICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWg2LCBiaDIpKSB8IDA7XG5cdCAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDUsIGJsMykpIHwgMDtcblx0ICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWw1LCBiaDMpKSB8IDA7XG5cdCAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoNSwgYmwzKSkgfCAwO1xuXHQgICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWg1LCBiaDMpKSB8IDA7XG5cdCAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDQsIGJsNCkpIHwgMDtcblx0ICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWw0LCBiaDQpKSB8IDA7XG5cdCAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoNCwgYmw0KSkgfCAwO1xuXHQgICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWg0LCBiaDQpKSB8IDA7XG5cdCAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDMsIGJsNSkpIHwgMDtcblx0ICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWwzLCBiaDUpKSB8IDA7XG5cdCAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoMywgYmw1KSkgfCAwO1xuXHQgICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWgzLCBiaDUpKSB8IDA7XG5cdCAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDIsIGJsNikpIHwgMDtcblx0ICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWwyLCBiaDYpKSB8IDA7XG5cdCAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoMiwgYmw2KSkgfCAwO1xuXHQgICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWgyLCBiaDYpKSB8IDA7XG5cdCAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDEsIGJsNykpIHwgMDtcblx0ICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWwxLCBiaDcpKSB8IDA7XG5cdCAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoMSwgYmw3KSkgfCAwO1xuXHQgICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWgxLCBiaDcpKSB8IDA7XG5cdCAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDAsIGJsOCkpIHwgMDtcblx0ICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWwwLCBiaDgpKSB8IDA7XG5cdCAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoMCwgYmw4KSkgfCAwO1xuXHQgICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWgwLCBiaDgpKSB8IDA7XG5cdCAgICB2YXIgdzggPSAoKChjICsgbG8pIHwgMCkgKyAoKG1pZCAmIDB4MWZmZikgPDwgMTMpKSB8IDA7XG5cdCAgICBjID0gKCgoaGkgKyAobWlkID4+PiAxMykpIHwgMCkgKyAodzggPj4+IDI2KSkgfCAwO1xuXHQgICAgdzggJj0gMHgzZmZmZmZmO1xuXHQgICAgLyogayA9IDkgKi9cblx0ICAgIGxvID0gTWF0aC5pbXVsKGFsOSwgYmwwKTtcblx0ICAgIG1pZCA9IE1hdGguaW11bChhbDksIGJoMCk7XG5cdCAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoOSwgYmwwKSkgfCAwO1xuXHQgICAgaGkgPSBNYXRoLmltdWwoYWg5LCBiaDApO1xuXHQgICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWw4LCBibDEpKSB8IDA7XG5cdCAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsOCwgYmgxKSkgfCAwO1xuXHQgICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDgsIGJsMSkpIHwgMDtcblx0ICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoOCwgYmgxKSkgfCAwO1xuXHQgICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWw3LCBibDIpKSB8IDA7XG5cdCAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsNywgYmgyKSkgfCAwO1xuXHQgICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDcsIGJsMikpIHwgMDtcblx0ICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoNywgYmgyKSkgfCAwO1xuXHQgICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWw2LCBibDMpKSB8IDA7XG5cdCAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsNiwgYmgzKSkgfCAwO1xuXHQgICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDYsIGJsMykpIHwgMDtcblx0ICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoNiwgYmgzKSkgfCAwO1xuXHQgICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWw1LCBibDQpKSB8IDA7XG5cdCAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsNSwgYmg0KSkgfCAwO1xuXHQgICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDUsIGJsNCkpIHwgMDtcblx0ICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoNSwgYmg0KSkgfCAwO1xuXHQgICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWw0LCBibDUpKSB8IDA7XG5cdCAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsNCwgYmg1KSkgfCAwO1xuXHQgICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDQsIGJsNSkpIHwgMDtcblx0ICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoNCwgYmg1KSkgfCAwO1xuXHQgICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWwzLCBibDYpKSB8IDA7XG5cdCAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsMywgYmg2KSkgfCAwO1xuXHQgICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDMsIGJsNikpIHwgMDtcblx0ICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoMywgYmg2KSkgfCAwO1xuXHQgICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWwyLCBibDcpKSB8IDA7XG5cdCAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsMiwgYmg3KSkgfCAwO1xuXHQgICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDIsIGJsNykpIHwgMDtcblx0ICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoMiwgYmg3KSkgfCAwO1xuXHQgICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWwxLCBibDgpKSB8IDA7XG5cdCAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsMSwgYmg4KSkgfCAwO1xuXHQgICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDEsIGJsOCkpIHwgMDtcblx0ICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoMSwgYmg4KSkgfCAwO1xuXHQgICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWwwLCBibDkpKSB8IDA7XG5cdCAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsMCwgYmg5KSkgfCAwO1xuXHQgICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDAsIGJsOSkpIHwgMDtcblx0ICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoMCwgYmg5KSkgfCAwO1xuXHQgICAgdmFyIHc5ID0gKCgoYyArIGxvKSB8IDApICsgKChtaWQgJiAweDFmZmYpIDw8IDEzKSkgfCAwO1xuXHQgICAgYyA9ICgoKGhpICsgKG1pZCA+Pj4gMTMpKSB8IDApICsgKHc5ID4+PiAyNikpIHwgMDtcblx0ICAgIHc5ICY9IDB4M2ZmZmZmZjtcblx0ICAgIC8qIGsgPSAxMCAqL1xuXHQgICAgbG8gPSBNYXRoLmltdWwoYWw5LCBibDEpO1xuXHQgICAgbWlkID0gTWF0aC5pbXVsKGFsOSwgYmgxKTtcblx0ICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg5LCBibDEpKSB8IDA7XG5cdCAgICBoaSA9IE1hdGguaW11bChhaDksIGJoMSk7XG5cdCAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDgsIGJsMikpIHwgMDtcblx0ICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWw4LCBiaDIpKSB8IDA7XG5cdCAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoOCwgYmwyKSkgfCAwO1xuXHQgICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWg4LCBiaDIpKSB8IDA7XG5cdCAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDcsIGJsMykpIHwgMDtcblx0ICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWw3LCBiaDMpKSB8IDA7XG5cdCAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoNywgYmwzKSkgfCAwO1xuXHQgICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWg3LCBiaDMpKSB8IDA7XG5cdCAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDYsIGJsNCkpIHwgMDtcblx0ICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWw2LCBiaDQpKSB8IDA7XG5cdCAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoNiwgYmw0KSkgfCAwO1xuXHQgICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWg2LCBiaDQpKSB8IDA7XG5cdCAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDUsIGJsNSkpIHwgMDtcblx0ICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWw1LCBiaDUpKSB8IDA7XG5cdCAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoNSwgYmw1KSkgfCAwO1xuXHQgICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWg1LCBiaDUpKSB8IDA7XG5cdCAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDQsIGJsNikpIHwgMDtcblx0ICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWw0LCBiaDYpKSB8IDA7XG5cdCAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoNCwgYmw2KSkgfCAwO1xuXHQgICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWg0LCBiaDYpKSB8IDA7XG5cdCAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDMsIGJsNykpIHwgMDtcblx0ICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWwzLCBiaDcpKSB8IDA7XG5cdCAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoMywgYmw3KSkgfCAwO1xuXHQgICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWgzLCBiaDcpKSB8IDA7XG5cdCAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDIsIGJsOCkpIHwgMDtcblx0ICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWwyLCBiaDgpKSB8IDA7XG5cdCAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoMiwgYmw4KSkgfCAwO1xuXHQgICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWgyLCBiaDgpKSB8IDA7XG5cdCAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDEsIGJsOSkpIHwgMDtcblx0ICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWwxLCBiaDkpKSB8IDA7XG5cdCAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoMSwgYmw5KSkgfCAwO1xuXHQgICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWgxLCBiaDkpKSB8IDA7XG5cdCAgICB2YXIgdzEwID0gKCgoYyArIGxvKSB8IDApICsgKChtaWQgJiAweDFmZmYpIDw8IDEzKSkgfCAwO1xuXHQgICAgYyA9ICgoKGhpICsgKG1pZCA+Pj4gMTMpKSB8IDApICsgKHcxMCA+Pj4gMjYpKSB8IDA7XG5cdCAgICB3MTAgJj0gMHgzZmZmZmZmO1xuXHQgICAgLyogayA9IDExICovXG5cdCAgICBsbyA9IE1hdGguaW11bChhbDksIGJsMik7XG5cdCAgICBtaWQgPSBNYXRoLmltdWwoYWw5LCBiaDIpO1xuXHQgICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDksIGJsMikpIHwgMDtcblx0ICAgIGhpID0gTWF0aC5pbXVsKGFoOSwgYmgyKTtcblx0ICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsOCwgYmwzKSkgfCAwO1xuXHQgICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDgsIGJoMykpIHwgMDtcblx0ICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg4LCBibDMpKSB8IDA7XG5cdCAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDgsIGJoMykpIHwgMDtcblx0ICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsNywgYmw0KSkgfCAwO1xuXHQgICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDcsIGJoNCkpIHwgMDtcblx0ICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg3LCBibDQpKSB8IDA7XG5cdCAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDcsIGJoNCkpIHwgMDtcblx0ICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsNiwgYmw1KSkgfCAwO1xuXHQgICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDYsIGJoNSkpIHwgMDtcblx0ICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg2LCBibDUpKSB8IDA7XG5cdCAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDYsIGJoNSkpIHwgMDtcblx0ICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsNSwgYmw2KSkgfCAwO1xuXHQgICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDUsIGJoNikpIHwgMDtcblx0ICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg1LCBibDYpKSB8IDA7XG5cdCAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDUsIGJoNikpIHwgMDtcblx0ICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsNCwgYmw3KSkgfCAwO1xuXHQgICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDQsIGJoNykpIHwgMDtcblx0ICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg0LCBibDcpKSB8IDA7XG5cdCAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDQsIGJoNykpIHwgMDtcblx0ICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsMywgYmw4KSkgfCAwO1xuXHQgICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDMsIGJoOCkpIHwgMDtcblx0ICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWgzLCBibDgpKSB8IDA7XG5cdCAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDMsIGJoOCkpIHwgMDtcblx0ICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsMiwgYmw5KSkgfCAwO1xuXHQgICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDIsIGJoOSkpIHwgMDtcblx0ICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWgyLCBibDkpKSB8IDA7XG5cdCAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDIsIGJoOSkpIHwgMDtcblx0ICAgIHZhciB3MTEgPSAoKChjICsgbG8pIHwgMCkgKyAoKG1pZCAmIDB4MWZmZikgPDwgMTMpKSB8IDA7XG5cdCAgICBjID0gKCgoaGkgKyAobWlkID4+PiAxMykpIHwgMCkgKyAodzExID4+PiAyNikpIHwgMDtcblx0ICAgIHcxMSAmPSAweDNmZmZmZmY7XG5cdCAgICAvKiBrID0gMTIgKi9cblx0ICAgIGxvID0gTWF0aC5pbXVsKGFsOSwgYmwzKTtcblx0ICAgIG1pZCA9IE1hdGguaW11bChhbDksIGJoMyk7XG5cdCAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoOSwgYmwzKSkgfCAwO1xuXHQgICAgaGkgPSBNYXRoLmltdWwoYWg5LCBiaDMpO1xuXHQgICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWw4LCBibDQpKSB8IDA7XG5cdCAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsOCwgYmg0KSkgfCAwO1xuXHQgICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDgsIGJsNCkpIHwgMDtcblx0ICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoOCwgYmg0KSkgfCAwO1xuXHQgICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWw3LCBibDUpKSB8IDA7XG5cdCAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsNywgYmg1KSkgfCAwO1xuXHQgICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDcsIGJsNSkpIHwgMDtcblx0ICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoNywgYmg1KSkgfCAwO1xuXHQgICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWw2LCBibDYpKSB8IDA7XG5cdCAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsNiwgYmg2KSkgfCAwO1xuXHQgICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDYsIGJsNikpIHwgMDtcblx0ICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoNiwgYmg2KSkgfCAwO1xuXHQgICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWw1LCBibDcpKSB8IDA7XG5cdCAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsNSwgYmg3KSkgfCAwO1xuXHQgICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDUsIGJsNykpIHwgMDtcblx0ICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoNSwgYmg3KSkgfCAwO1xuXHQgICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWw0LCBibDgpKSB8IDA7XG5cdCAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsNCwgYmg4KSkgfCAwO1xuXHQgICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDQsIGJsOCkpIHwgMDtcblx0ICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoNCwgYmg4KSkgfCAwO1xuXHQgICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWwzLCBibDkpKSB8IDA7XG5cdCAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsMywgYmg5KSkgfCAwO1xuXHQgICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDMsIGJsOSkpIHwgMDtcblx0ICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoMywgYmg5KSkgfCAwO1xuXHQgICAgdmFyIHcxMiA9ICgoKGMgKyBsbykgfCAwKSArICgobWlkICYgMHgxZmZmKSA8PCAxMykpIHwgMDtcblx0ICAgIGMgPSAoKChoaSArIChtaWQgPj4+IDEzKSkgfCAwKSArICh3MTIgPj4+IDI2KSkgfCAwO1xuXHQgICAgdzEyICY9IDB4M2ZmZmZmZjtcblx0ICAgIC8qIGsgPSAxMyAqL1xuXHQgICAgbG8gPSBNYXRoLmltdWwoYWw5LCBibDQpO1xuXHQgICAgbWlkID0gTWF0aC5pbXVsKGFsOSwgYmg0KTtcblx0ICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg5LCBibDQpKSB8IDA7XG5cdCAgICBoaSA9IE1hdGguaW11bChhaDksIGJoNCk7XG5cdCAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDgsIGJsNSkpIHwgMDtcblx0ICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWw4LCBiaDUpKSB8IDA7XG5cdCAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoOCwgYmw1KSkgfCAwO1xuXHQgICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWg4LCBiaDUpKSB8IDA7XG5cdCAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDcsIGJsNikpIHwgMDtcblx0ICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWw3LCBiaDYpKSB8IDA7XG5cdCAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoNywgYmw2KSkgfCAwO1xuXHQgICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWg3LCBiaDYpKSB8IDA7XG5cdCAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDYsIGJsNykpIHwgMDtcblx0ICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWw2LCBiaDcpKSB8IDA7XG5cdCAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoNiwgYmw3KSkgfCAwO1xuXHQgICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWg2LCBiaDcpKSB8IDA7XG5cdCAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDUsIGJsOCkpIHwgMDtcblx0ICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWw1LCBiaDgpKSB8IDA7XG5cdCAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoNSwgYmw4KSkgfCAwO1xuXHQgICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWg1LCBiaDgpKSB8IDA7XG5cdCAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDQsIGJsOSkpIHwgMDtcblx0ICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWw0LCBiaDkpKSB8IDA7XG5cdCAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoNCwgYmw5KSkgfCAwO1xuXHQgICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWg0LCBiaDkpKSB8IDA7XG5cdCAgICB2YXIgdzEzID0gKCgoYyArIGxvKSB8IDApICsgKChtaWQgJiAweDFmZmYpIDw8IDEzKSkgfCAwO1xuXHQgICAgYyA9ICgoKGhpICsgKG1pZCA+Pj4gMTMpKSB8IDApICsgKHcxMyA+Pj4gMjYpKSB8IDA7XG5cdCAgICB3MTMgJj0gMHgzZmZmZmZmO1xuXHQgICAgLyogayA9IDE0ICovXG5cdCAgICBsbyA9IE1hdGguaW11bChhbDksIGJsNSk7XG5cdCAgICBtaWQgPSBNYXRoLmltdWwoYWw5LCBiaDUpO1xuXHQgICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDksIGJsNSkpIHwgMDtcblx0ICAgIGhpID0gTWF0aC5pbXVsKGFoOSwgYmg1KTtcblx0ICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsOCwgYmw2KSkgfCAwO1xuXHQgICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDgsIGJoNikpIHwgMDtcblx0ICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg4LCBibDYpKSB8IDA7XG5cdCAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDgsIGJoNikpIHwgMDtcblx0ICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsNywgYmw3KSkgfCAwO1xuXHQgICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDcsIGJoNykpIHwgMDtcblx0ICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg3LCBibDcpKSB8IDA7XG5cdCAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDcsIGJoNykpIHwgMDtcblx0ICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsNiwgYmw4KSkgfCAwO1xuXHQgICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDYsIGJoOCkpIHwgMDtcblx0ICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg2LCBibDgpKSB8IDA7XG5cdCAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDYsIGJoOCkpIHwgMDtcblx0ICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsNSwgYmw5KSkgfCAwO1xuXHQgICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDUsIGJoOSkpIHwgMDtcblx0ICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg1LCBibDkpKSB8IDA7XG5cdCAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDUsIGJoOSkpIHwgMDtcblx0ICAgIHZhciB3MTQgPSAoKChjICsgbG8pIHwgMCkgKyAoKG1pZCAmIDB4MWZmZikgPDwgMTMpKSB8IDA7XG5cdCAgICBjID0gKCgoaGkgKyAobWlkID4+PiAxMykpIHwgMCkgKyAodzE0ID4+PiAyNikpIHwgMDtcblx0ICAgIHcxNCAmPSAweDNmZmZmZmY7XG5cdCAgICAvKiBrID0gMTUgKi9cblx0ICAgIGxvID0gTWF0aC5pbXVsKGFsOSwgYmw2KTtcblx0ICAgIG1pZCA9IE1hdGguaW11bChhbDksIGJoNik7XG5cdCAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoOSwgYmw2KSkgfCAwO1xuXHQgICAgaGkgPSBNYXRoLmltdWwoYWg5LCBiaDYpO1xuXHQgICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWw4LCBibDcpKSB8IDA7XG5cdCAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsOCwgYmg3KSkgfCAwO1xuXHQgICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDgsIGJsNykpIHwgMDtcblx0ICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoOCwgYmg3KSkgfCAwO1xuXHQgICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWw3LCBibDgpKSB8IDA7XG5cdCAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsNywgYmg4KSkgfCAwO1xuXHQgICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDcsIGJsOCkpIHwgMDtcblx0ICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoNywgYmg4KSkgfCAwO1xuXHQgICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWw2LCBibDkpKSB8IDA7XG5cdCAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsNiwgYmg5KSkgfCAwO1xuXHQgICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDYsIGJsOSkpIHwgMDtcblx0ICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoNiwgYmg5KSkgfCAwO1xuXHQgICAgdmFyIHcxNSA9ICgoKGMgKyBsbykgfCAwKSArICgobWlkICYgMHgxZmZmKSA8PCAxMykpIHwgMDtcblx0ICAgIGMgPSAoKChoaSArIChtaWQgPj4+IDEzKSkgfCAwKSArICh3MTUgPj4+IDI2KSkgfCAwO1xuXHQgICAgdzE1ICY9IDB4M2ZmZmZmZjtcblx0ICAgIC8qIGsgPSAxNiAqL1xuXHQgICAgbG8gPSBNYXRoLmltdWwoYWw5LCBibDcpO1xuXHQgICAgbWlkID0gTWF0aC5pbXVsKGFsOSwgYmg3KTtcblx0ICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg5LCBibDcpKSB8IDA7XG5cdCAgICBoaSA9IE1hdGguaW11bChhaDksIGJoNyk7XG5cdCAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDgsIGJsOCkpIHwgMDtcblx0ICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWw4LCBiaDgpKSB8IDA7XG5cdCAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoOCwgYmw4KSkgfCAwO1xuXHQgICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWg4LCBiaDgpKSB8IDA7XG5cdCAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDcsIGJsOSkpIHwgMDtcblx0ICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWw3LCBiaDkpKSB8IDA7XG5cdCAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoNywgYmw5KSkgfCAwO1xuXHQgICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWg3LCBiaDkpKSB8IDA7XG5cdCAgICB2YXIgdzE2ID0gKCgoYyArIGxvKSB8IDApICsgKChtaWQgJiAweDFmZmYpIDw8IDEzKSkgfCAwO1xuXHQgICAgYyA9ICgoKGhpICsgKG1pZCA+Pj4gMTMpKSB8IDApICsgKHcxNiA+Pj4gMjYpKSB8IDA7XG5cdCAgICB3MTYgJj0gMHgzZmZmZmZmO1xuXHQgICAgLyogayA9IDE3ICovXG5cdCAgICBsbyA9IE1hdGguaW11bChhbDksIGJsOCk7XG5cdCAgICBtaWQgPSBNYXRoLmltdWwoYWw5LCBiaDgpO1xuXHQgICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDksIGJsOCkpIHwgMDtcblx0ICAgIGhpID0gTWF0aC5pbXVsKGFoOSwgYmg4KTtcblx0ICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsOCwgYmw5KSkgfCAwO1xuXHQgICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDgsIGJoOSkpIHwgMDtcblx0ICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg4LCBibDkpKSB8IDA7XG5cdCAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDgsIGJoOSkpIHwgMDtcblx0ICAgIHZhciB3MTcgPSAoKChjICsgbG8pIHwgMCkgKyAoKG1pZCAmIDB4MWZmZikgPDwgMTMpKSB8IDA7XG5cdCAgICBjID0gKCgoaGkgKyAobWlkID4+PiAxMykpIHwgMCkgKyAodzE3ID4+PiAyNikpIHwgMDtcblx0ICAgIHcxNyAmPSAweDNmZmZmZmY7XG5cdCAgICAvKiBrID0gMTggKi9cblx0ICAgIGxvID0gTWF0aC5pbXVsKGFsOSwgYmw5KTtcblx0ICAgIG1pZCA9IE1hdGguaW11bChhbDksIGJoOSk7XG5cdCAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoOSwgYmw5KSkgfCAwO1xuXHQgICAgaGkgPSBNYXRoLmltdWwoYWg5LCBiaDkpO1xuXHQgICAgdmFyIHcxOCA9ICgoKGMgKyBsbykgfCAwKSArICgobWlkICYgMHgxZmZmKSA8PCAxMykpIHwgMDtcblx0ICAgIGMgPSAoKChoaSArIChtaWQgPj4+IDEzKSkgfCAwKSArICh3MTggPj4+IDI2KSkgfCAwO1xuXHQgICAgdzE4ICY9IDB4M2ZmZmZmZjtcblx0ICAgIG9bMF0gPSB3MDtcblx0ICAgIG9bMV0gPSB3MTtcblx0ICAgIG9bMl0gPSB3Mjtcblx0ICAgIG9bM10gPSB3Mztcblx0ICAgIG9bNF0gPSB3NDtcblx0ICAgIG9bNV0gPSB3NTtcblx0ICAgIG9bNl0gPSB3Njtcblx0ICAgIG9bN10gPSB3Nztcblx0ICAgIG9bOF0gPSB3ODtcblx0ICAgIG9bOV0gPSB3OTtcblx0ICAgIG9bMTBdID0gdzEwO1xuXHQgICAgb1sxMV0gPSB3MTE7XG5cdCAgICBvWzEyXSA9IHcxMjtcblx0ICAgIG9bMTNdID0gdzEzO1xuXHQgICAgb1sxNF0gPSB3MTQ7XG5cdCAgICBvWzE1XSA9IHcxNTtcblx0ICAgIG9bMTZdID0gdzE2O1xuXHQgICAgb1sxN10gPSB3MTc7XG5cdCAgICBvWzE4XSA9IHcxODtcblx0ICAgIGlmIChjICE9PSAwKSB7XG5cdCAgICAgIG9bMTldID0gYztcblx0ICAgICAgb3V0Lmxlbmd0aCsrO1xuXHQgICAgfVxuXHQgICAgcmV0dXJuIG91dDtcblx0ICB9O1xuXG5cdCAgLy8gUG9seWZpbGwgY29tYlxuXHQgIGlmICghTWF0aC5pbXVsKSB7XG5cdCAgICBjb21iMTBNdWxUbyA9IHNtYWxsTXVsVG87XG5cdCAgfVxuXG5cdCAgZnVuY3Rpb24gYmlnTXVsVG8gKHNlbGYsIG51bSwgb3V0KSB7XG5cdCAgICBvdXQubmVnYXRpdmUgPSBudW0ubmVnYXRpdmUgXiBzZWxmLm5lZ2F0aXZlO1xuXHQgICAgb3V0Lmxlbmd0aCA9IHNlbGYubGVuZ3RoICsgbnVtLmxlbmd0aDtcblxuXHQgICAgdmFyIGNhcnJ5ID0gMDtcblx0ICAgIHZhciBobmNhcnJ5ID0gMDtcblx0ICAgIGZvciAodmFyIGsgPSAwOyBrIDwgb3V0Lmxlbmd0aCAtIDE7IGsrKykge1xuXHQgICAgICAvLyBTdW0gYWxsIHdvcmRzIHdpdGggdGhlIHNhbWUgYGkgKyBqID0ga2AgYW5kIGFjY3VtdWxhdGUgYG5jYXJyeWAsXG5cdCAgICAgIC8vIG5vdGUgdGhhdCBuY2FycnkgY291bGQgYmUgPj0gMHgzZmZmZmZmXG5cdCAgICAgIHZhciBuY2FycnkgPSBobmNhcnJ5O1xuXHQgICAgICBobmNhcnJ5ID0gMDtcblx0ICAgICAgdmFyIHJ3b3JkID0gY2FycnkgJiAweDNmZmZmZmY7XG5cdCAgICAgIHZhciBtYXhKID0gTWF0aC5taW4oaywgbnVtLmxlbmd0aCAtIDEpO1xuXHQgICAgICBmb3IgKHZhciBqID0gTWF0aC5tYXgoMCwgayAtIHNlbGYubGVuZ3RoICsgMSk7IGogPD0gbWF4SjsgaisrKSB7XG5cdCAgICAgICAgdmFyIGkgPSBrIC0gajtcblx0ICAgICAgICB2YXIgYSA9IHNlbGYud29yZHNbaV0gfCAwO1xuXHQgICAgICAgIHZhciBiID0gbnVtLndvcmRzW2pdIHwgMDtcblx0ICAgICAgICB2YXIgciA9IGEgKiBiO1xuXG5cdCAgICAgICAgdmFyIGxvID0gciAmIDB4M2ZmZmZmZjtcblx0ICAgICAgICBuY2FycnkgPSAobmNhcnJ5ICsgKChyIC8gMHg0MDAwMDAwKSB8IDApKSB8IDA7XG5cdCAgICAgICAgbG8gPSAobG8gKyByd29yZCkgfCAwO1xuXHQgICAgICAgIHJ3b3JkID0gbG8gJiAweDNmZmZmZmY7XG5cdCAgICAgICAgbmNhcnJ5ID0gKG5jYXJyeSArIChsbyA+Pj4gMjYpKSB8IDA7XG5cblx0ICAgICAgICBobmNhcnJ5ICs9IG5jYXJyeSA+Pj4gMjY7XG5cdCAgICAgICAgbmNhcnJ5ICY9IDB4M2ZmZmZmZjtcblx0ICAgICAgfVxuXHQgICAgICBvdXQud29yZHNba10gPSByd29yZDtcblx0ICAgICAgY2FycnkgPSBuY2Fycnk7XG5cdCAgICAgIG5jYXJyeSA9IGhuY2Fycnk7XG5cdCAgICB9XG5cdCAgICBpZiAoY2FycnkgIT09IDApIHtcblx0ICAgICAgb3V0LndvcmRzW2tdID0gY2Fycnk7XG5cdCAgICB9IGVsc2Uge1xuXHQgICAgICBvdXQubGVuZ3RoLS07XG5cdCAgICB9XG5cblx0ICAgIHJldHVybiBvdXQuc3RyaXAoKTtcblx0ICB9XG5cblx0ICBmdW5jdGlvbiBqdW1ib011bFRvIChzZWxmLCBudW0sIG91dCkge1xuXHQgICAgdmFyIGZmdG0gPSBuZXcgRkZUTSgpO1xuXHQgICAgcmV0dXJuIGZmdG0ubXVscChzZWxmLCBudW0sIG91dCk7XG5cdCAgfVxuXG5cdCAgQk4ucHJvdG90eXBlLm11bFRvID0gZnVuY3Rpb24gbXVsVG8gKG51bSwgb3V0KSB7XG5cdCAgICB2YXIgcmVzO1xuXHQgICAgdmFyIGxlbiA9IHRoaXMubGVuZ3RoICsgbnVtLmxlbmd0aDtcblx0ICAgIGlmICh0aGlzLmxlbmd0aCA9PT0gMTAgJiYgbnVtLmxlbmd0aCA9PT0gMTApIHtcblx0ICAgICAgcmVzID0gY29tYjEwTXVsVG8odGhpcywgbnVtLCBvdXQpO1xuXHQgICAgfSBlbHNlIGlmIChsZW4gPCA2Mykge1xuXHQgICAgICByZXMgPSBzbWFsbE11bFRvKHRoaXMsIG51bSwgb3V0KTtcblx0ICAgIH0gZWxzZSBpZiAobGVuIDwgMTAyNCkge1xuXHQgICAgICByZXMgPSBiaWdNdWxUbyh0aGlzLCBudW0sIG91dCk7XG5cdCAgICB9IGVsc2Uge1xuXHQgICAgICByZXMgPSBqdW1ib011bFRvKHRoaXMsIG51bSwgb3V0KTtcblx0ICAgIH1cblxuXHQgICAgcmV0dXJuIHJlcztcblx0ICB9O1xuXG5cdCAgLy8gQ29vbGV5LVR1a2V5IGFsZ29yaXRobSBmb3IgRkZUXG5cdCAgLy8gc2xpZ2h0bHkgcmV2aXNpdGVkIHRvIHJlbHkgb24gbG9vcGluZyBpbnN0ZWFkIG9mIHJlY3Vyc2lvblxuXG5cdCAgZnVuY3Rpb24gRkZUTSAoeCwgeSkge1xuXHQgICAgdGhpcy54ID0geDtcblx0ICAgIHRoaXMueSA9IHk7XG5cdCAgfVxuXG5cdCAgRkZUTS5wcm90b3R5cGUubWFrZVJCVCA9IGZ1bmN0aW9uIG1ha2VSQlQgKE4pIHtcblx0ICAgIHZhciB0ID0gbmV3IEFycmF5KE4pO1xuXHQgICAgdmFyIGwgPSBCTi5wcm90b3R5cGUuX2NvdW50Qml0cyhOKSAtIDE7XG5cdCAgICBmb3IgKHZhciBpID0gMDsgaSA8IE47IGkrKykge1xuXHQgICAgICB0W2ldID0gdGhpcy5yZXZCaW4oaSwgbCwgTik7XG5cdCAgICB9XG5cblx0ICAgIHJldHVybiB0O1xuXHQgIH07XG5cblx0ICAvLyBSZXR1cm5zIGJpbmFyeS1yZXZlcnNlZCByZXByZXNlbnRhdGlvbiBvZiBgeGBcblx0ICBGRlRNLnByb3RvdHlwZS5yZXZCaW4gPSBmdW5jdGlvbiByZXZCaW4gKHgsIGwsIE4pIHtcblx0ICAgIGlmICh4ID09PSAwIHx8IHggPT09IE4gLSAxKSByZXR1cm4geDtcblxuXHQgICAgdmFyIHJiID0gMDtcblx0ICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbDsgaSsrKSB7XG5cdCAgICAgIHJiIHw9ICh4ICYgMSkgPDwgKGwgLSBpIC0gMSk7XG5cdCAgICAgIHggPj49IDE7XG5cdCAgICB9XG5cblx0ICAgIHJldHVybiByYjtcblx0ICB9O1xuXG5cdCAgLy8gUGVyZm9ybXMgXCJ0d2VlZGxpbmdcIiBwaGFzZSwgdGhlcmVmb3JlICdlbXVsYXRpbmcnXG5cdCAgLy8gYmVoYXZpb3VyIG9mIHRoZSByZWN1cnNpdmUgYWxnb3JpdGhtXG5cdCAgRkZUTS5wcm90b3R5cGUucGVybXV0ZSA9IGZ1bmN0aW9uIHBlcm11dGUgKHJidCwgcndzLCBpd3MsIHJ0d3MsIGl0d3MsIE4pIHtcblx0ICAgIGZvciAodmFyIGkgPSAwOyBpIDwgTjsgaSsrKSB7XG5cdCAgICAgIHJ0d3NbaV0gPSByd3NbcmJ0W2ldXTtcblx0ICAgICAgaXR3c1tpXSA9IGl3c1tyYnRbaV1dO1xuXHQgICAgfVxuXHQgIH07XG5cblx0ICBGRlRNLnByb3RvdHlwZS50cmFuc2Zvcm0gPSBmdW5jdGlvbiB0cmFuc2Zvcm0gKHJ3cywgaXdzLCBydHdzLCBpdHdzLCBOLCByYnQpIHtcblx0ICAgIHRoaXMucGVybXV0ZShyYnQsIHJ3cywgaXdzLCBydHdzLCBpdHdzLCBOKTtcblxuXHQgICAgZm9yICh2YXIgcyA9IDE7IHMgPCBOOyBzIDw8PSAxKSB7XG5cdCAgICAgIHZhciBsID0gcyA8PCAxO1xuXG5cdCAgICAgIHZhciBydHdkZiA9IE1hdGguY29zKDIgKiBNYXRoLlBJIC8gbCk7XG5cdCAgICAgIHZhciBpdHdkZiA9IE1hdGguc2luKDIgKiBNYXRoLlBJIC8gbCk7XG5cblx0ICAgICAgZm9yICh2YXIgcCA9IDA7IHAgPCBOOyBwICs9IGwpIHtcblx0ICAgICAgICB2YXIgcnR3ZGZfID0gcnR3ZGY7XG5cdCAgICAgICAgdmFyIGl0d2RmXyA9IGl0d2RmO1xuXG5cdCAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBzOyBqKyspIHtcblx0ICAgICAgICAgIHZhciByZSA9IHJ0d3NbcCArIGpdO1xuXHQgICAgICAgICAgdmFyIGllID0gaXR3c1twICsgal07XG5cblx0ICAgICAgICAgIHZhciBybyA9IHJ0d3NbcCArIGogKyBzXTtcblx0ICAgICAgICAgIHZhciBpbyA9IGl0d3NbcCArIGogKyBzXTtcblxuXHQgICAgICAgICAgdmFyIHJ4ID0gcnR3ZGZfICogcm8gLSBpdHdkZl8gKiBpbztcblxuXHQgICAgICAgICAgaW8gPSBydHdkZl8gKiBpbyArIGl0d2RmXyAqIHJvO1xuXHQgICAgICAgICAgcm8gPSByeDtcblxuXHQgICAgICAgICAgcnR3c1twICsgal0gPSByZSArIHJvO1xuXHQgICAgICAgICAgaXR3c1twICsgal0gPSBpZSArIGlvO1xuXG5cdCAgICAgICAgICBydHdzW3AgKyBqICsgc10gPSByZSAtIHJvO1xuXHQgICAgICAgICAgaXR3c1twICsgaiArIHNdID0gaWUgLSBpbztcblxuXHQgICAgICAgICAgLyoganNoaW50IG1heGRlcHRoIDogZmFsc2UgKi9cblx0ICAgICAgICAgIGlmIChqICE9PSBsKSB7XG5cdCAgICAgICAgICAgIHJ4ID0gcnR3ZGYgKiBydHdkZl8gLSBpdHdkZiAqIGl0d2RmXztcblxuXHQgICAgICAgICAgICBpdHdkZl8gPSBydHdkZiAqIGl0d2RmXyArIGl0d2RmICogcnR3ZGZfO1xuXHQgICAgICAgICAgICBydHdkZl8gPSByeDtcblx0ICAgICAgICAgIH1cblx0ICAgICAgICB9XG5cdCAgICAgIH1cblx0ICAgIH1cblx0ICB9O1xuXG5cdCAgRkZUTS5wcm90b3R5cGUuZ3Vlc3NMZW4xM2IgPSBmdW5jdGlvbiBndWVzc0xlbjEzYiAobiwgbSkge1xuXHQgICAgdmFyIE4gPSBNYXRoLm1heChtLCBuKSB8IDE7XG5cdCAgICB2YXIgb2RkID0gTiAmIDE7XG5cdCAgICB2YXIgaSA9IDA7XG5cdCAgICBmb3IgKE4gPSBOIC8gMiB8IDA7IE47IE4gPSBOID4+PiAxKSB7XG5cdCAgICAgIGkrKztcblx0ICAgIH1cblxuXHQgICAgcmV0dXJuIDEgPDwgaSArIDEgKyBvZGQ7XG5cdCAgfTtcblxuXHQgIEZGVE0ucHJvdG90eXBlLmNvbmp1Z2F0ZSA9IGZ1bmN0aW9uIGNvbmp1Z2F0ZSAocndzLCBpd3MsIE4pIHtcblx0ICAgIGlmIChOIDw9IDEpIHJldHVybjtcblxuXHQgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBOIC8gMjsgaSsrKSB7XG5cdCAgICAgIHZhciB0ID0gcndzW2ldO1xuXG5cdCAgICAgIHJ3c1tpXSA9IHJ3c1tOIC0gaSAtIDFdO1xuXHQgICAgICByd3NbTiAtIGkgLSAxXSA9IHQ7XG5cblx0ICAgICAgdCA9IGl3c1tpXTtcblxuXHQgICAgICBpd3NbaV0gPSAtaXdzW04gLSBpIC0gMV07XG5cdCAgICAgIGl3c1tOIC0gaSAtIDFdID0gLXQ7XG5cdCAgICB9XG5cdCAgfTtcblxuXHQgIEZGVE0ucHJvdG90eXBlLm5vcm1hbGl6ZTEzYiA9IGZ1bmN0aW9uIG5vcm1hbGl6ZTEzYiAod3MsIE4pIHtcblx0ICAgIHZhciBjYXJyeSA9IDA7XG5cdCAgICBmb3IgKHZhciBpID0gMDsgaSA8IE4gLyAyOyBpKyspIHtcblx0ICAgICAgdmFyIHcgPSBNYXRoLnJvdW5kKHdzWzIgKiBpICsgMV0gLyBOKSAqIDB4MjAwMCArXG5cdCAgICAgICAgTWF0aC5yb3VuZCh3c1syICogaV0gLyBOKSArXG5cdCAgICAgICAgY2Fycnk7XG5cblx0ICAgICAgd3NbaV0gPSB3ICYgMHgzZmZmZmZmO1xuXG5cdCAgICAgIGlmICh3IDwgMHg0MDAwMDAwKSB7XG5cdCAgICAgICAgY2FycnkgPSAwO1xuXHQgICAgICB9IGVsc2Uge1xuXHQgICAgICAgIGNhcnJ5ID0gdyAvIDB4NDAwMDAwMCB8IDA7XG5cdCAgICAgIH1cblx0ICAgIH1cblxuXHQgICAgcmV0dXJuIHdzO1xuXHQgIH07XG5cblx0ICBGRlRNLnByb3RvdHlwZS5jb252ZXJ0MTNiID0gZnVuY3Rpb24gY29udmVydDEzYiAod3MsIGxlbiwgcndzLCBOKSB7XG5cdCAgICB2YXIgY2FycnkgPSAwO1xuXHQgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuXHQgICAgICBjYXJyeSA9IGNhcnJ5ICsgKHdzW2ldIHwgMCk7XG5cblx0ICAgICAgcndzWzIgKiBpXSA9IGNhcnJ5ICYgMHgxZmZmOyBjYXJyeSA9IGNhcnJ5ID4+PiAxMztcblx0ICAgICAgcndzWzIgKiBpICsgMV0gPSBjYXJyeSAmIDB4MWZmZjsgY2FycnkgPSBjYXJyeSA+Pj4gMTM7XG5cdCAgICB9XG5cblx0ICAgIC8vIFBhZCB3aXRoIHplcm9lc1xuXHQgICAgZm9yIChpID0gMiAqIGxlbjsgaSA8IE47ICsraSkge1xuXHQgICAgICByd3NbaV0gPSAwO1xuXHQgICAgfVxuXG5cdCAgICBhc3NlcnQoY2FycnkgPT09IDApO1xuXHQgICAgYXNzZXJ0KChjYXJyeSAmIH4weDFmZmYpID09PSAwKTtcblx0ICB9O1xuXG5cdCAgRkZUTS5wcm90b3R5cGUuc3R1YiA9IGZ1bmN0aW9uIHN0dWIgKE4pIHtcblx0ICAgIHZhciBwaCA9IG5ldyBBcnJheShOKTtcblx0ICAgIGZvciAodmFyIGkgPSAwOyBpIDwgTjsgaSsrKSB7XG5cdCAgICAgIHBoW2ldID0gMDtcblx0ICAgIH1cblxuXHQgICAgcmV0dXJuIHBoO1xuXHQgIH07XG5cblx0ICBGRlRNLnByb3RvdHlwZS5tdWxwID0gZnVuY3Rpb24gbXVscCAoeCwgeSwgb3V0KSB7XG5cdCAgICB2YXIgTiA9IDIgKiB0aGlzLmd1ZXNzTGVuMTNiKHgubGVuZ3RoLCB5Lmxlbmd0aCk7XG5cblx0ICAgIHZhciByYnQgPSB0aGlzLm1ha2VSQlQoTik7XG5cblx0ICAgIHZhciBfID0gdGhpcy5zdHViKE4pO1xuXG5cdCAgICB2YXIgcndzID0gbmV3IEFycmF5KE4pO1xuXHQgICAgdmFyIHJ3c3QgPSBuZXcgQXJyYXkoTik7XG5cdCAgICB2YXIgaXdzdCA9IG5ldyBBcnJheShOKTtcblxuXHQgICAgdmFyIG5yd3MgPSBuZXcgQXJyYXkoTik7XG5cdCAgICB2YXIgbnJ3c3QgPSBuZXcgQXJyYXkoTik7XG5cdCAgICB2YXIgbml3c3QgPSBuZXcgQXJyYXkoTik7XG5cblx0ICAgIHZhciBybXdzID0gb3V0LndvcmRzO1xuXHQgICAgcm13cy5sZW5ndGggPSBOO1xuXG5cdCAgICB0aGlzLmNvbnZlcnQxM2IoeC53b3JkcywgeC5sZW5ndGgsIHJ3cywgTik7XG5cdCAgICB0aGlzLmNvbnZlcnQxM2IoeS53b3JkcywgeS5sZW5ndGgsIG5yd3MsIE4pO1xuXG5cdCAgICB0aGlzLnRyYW5zZm9ybShyd3MsIF8sIHJ3c3QsIGl3c3QsIE4sIHJidCk7XG5cdCAgICB0aGlzLnRyYW5zZm9ybShucndzLCBfLCBucndzdCwgbml3c3QsIE4sIHJidCk7XG5cblx0ICAgIGZvciAodmFyIGkgPSAwOyBpIDwgTjsgaSsrKSB7XG5cdCAgICAgIHZhciByeCA9IHJ3c3RbaV0gKiBucndzdFtpXSAtIGl3c3RbaV0gKiBuaXdzdFtpXTtcblx0ICAgICAgaXdzdFtpXSA9IHJ3c3RbaV0gKiBuaXdzdFtpXSArIGl3c3RbaV0gKiBucndzdFtpXTtcblx0ICAgICAgcndzdFtpXSA9IHJ4O1xuXHQgICAgfVxuXG5cdCAgICB0aGlzLmNvbmp1Z2F0ZShyd3N0LCBpd3N0LCBOKTtcblx0ICAgIHRoaXMudHJhbnNmb3JtKHJ3c3QsIGl3c3QsIHJtd3MsIF8sIE4sIHJidCk7XG5cdCAgICB0aGlzLmNvbmp1Z2F0ZShybXdzLCBfLCBOKTtcblx0ICAgIHRoaXMubm9ybWFsaXplMTNiKHJtd3MsIE4pO1xuXG5cdCAgICBvdXQubmVnYXRpdmUgPSB4Lm5lZ2F0aXZlIF4geS5uZWdhdGl2ZTtcblx0ICAgIG91dC5sZW5ndGggPSB4Lmxlbmd0aCArIHkubGVuZ3RoO1xuXHQgICAgcmV0dXJuIG91dC5zdHJpcCgpO1xuXHQgIH07XG5cblx0ICAvLyBNdWx0aXBseSBgdGhpc2AgYnkgYG51bWBcblx0ICBCTi5wcm90b3R5cGUubXVsID0gZnVuY3Rpb24gbXVsIChudW0pIHtcblx0ICAgIHZhciBvdXQgPSBuZXcgQk4obnVsbCk7XG5cdCAgICBvdXQud29yZHMgPSBuZXcgQXJyYXkodGhpcy5sZW5ndGggKyBudW0ubGVuZ3RoKTtcblx0ICAgIHJldHVybiB0aGlzLm11bFRvKG51bSwgb3V0KTtcblx0ICB9O1xuXG5cdCAgLy8gTXVsdGlwbHkgZW1wbG95aW5nIEZGVFxuXHQgIEJOLnByb3RvdHlwZS5tdWxmID0gZnVuY3Rpb24gbXVsZiAobnVtKSB7XG5cdCAgICB2YXIgb3V0ID0gbmV3IEJOKG51bGwpO1xuXHQgICAgb3V0LndvcmRzID0gbmV3IEFycmF5KHRoaXMubGVuZ3RoICsgbnVtLmxlbmd0aCk7XG5cdCAgICByZXR1cm4ganVtYm9NdWxUbyh0aGlzLCBudW0sIG91dCk7XG5cdCAgfTtcblxuXHQgIC8vIEluLXBsYWNlIE11bHRpcGxpY2F0aW9uXG5cdCAgQk4ucHJvdG90eXBlLmltdWwgPSBmdW5jdGlvbiBpbXVsIChudW0pIHtcblx0ICAgIHJldHVybiB0aGlzLmNsb25lKCkubXVsVG8obnVtLCB0aGlzKTtcblx0ICB9O1xuXG5cdCAgQk4ucHJvdG90eXBlLmltdWxuID0gZnVuY3Rpb24gaW11bG4gKG51bSkge1xuXHQgICAgYXNzZXJ0KHR5cGVvZiBudW0gPT09ICdudW1iZXInKTtcblx0ICAgIGFzc2VydChudW0gPCAweDQwMDAwMDApO1xuXG5cdCAgICAvLyBDYXJyeVxuXHQgICAgdmFyIGNhcnJ5ID0gMDtcblx0ICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkrKykge1xuXHQgICAgICB2YXIgdyA9ICh0aGlzLndvcmRzW2ldIHwgMCkgKiBudW07XG5cdCAgICAgIHZhciBsbyA9ICh3ICYgMHgzZmZmZmZmKSArIChjYXJyeSAmIDB4M2ZmZmZmZik7XG5cdCAgICAgIGNhcnJ5ID4+PSAyNjtcblx0ICAgICAgY2FycnkgKz0gKHcgLyAweDQwMDAwMDApIHwgMDtcblx0ICAgICAgLy8gTk9URTogbG8gaXMgMjdiaXQgbWF4aW11bVxuXHQgICAgICBjYXJyeSArPSBsbyA+Pj4gMjY7XG5cdCAgICAgIHRoaXMud29yZHNbaV0gPSBsbyAmIDB4M2ZmZmZmZjtcblx0ICAgIH1cblxuXHQgICAgaWYgKGNhcnJ5ICE9PSAwKSB7XG5cdCAgICAgIHRoaXMud29yZHNbaV0gPSBjYXJyeTtcblx0ICAgICAgdGhpcy5sZW5ndGgrKztcblx0ICAgIH1cblxuXHQgICAgcmV0dXJuIHRoaXM7XG5cdCAgfTtcblxuXHQgIEJOLnByb3RvdHlwZS5tdWxuID0gZnVuY3Rpb24gbXVsbiAobnVtKSB7XG5cdCAgICByZXR1cm4gdGhpcy5jbG9uZSgpLmltdWxuKG51bSk7XG5cdCAgfTtcblxuXHQgIC8vIGB0aGlzYCAqIGB0aGlzYFxuXHQgIEJOLnByb3RvdHlwZS5zcXIgPSBmdW5jdGlvbiBzcXIgKCkge1xuXHQgICAgcmV0dXJuIHRoaXMubXVsKHRoaXMpO1xuXHQgIH07XG5cblx0ICAvLyBgdGhpc2AgKiBgdGhpc2AgaW4tcGxhY2Vcblx0ICBCTi5wcm90b3R5cGUuaXNxciA9IGZ1bmN0aW9uIGlzcXIgKCkge1xuXHQgICAgcmV0dXJuIHRoaXMuaW11bCh0aGlzLmNsb25lKCkpO1xuXHQgIH07XG5cblx0ICAvLyBNYXRoLnBvdyhgdGhpc2AsIGBudW1gKVxuXHQgIEJOLnByb3RvdHlwZS5wb3cgPSBmdW5jdGlvbiBwb3cgKG51bSkge1xuXHQgICAgdmFyIHcgPSB0b0JpdEFycmF5KG51bSk7XG5cdCAgICBpZiAody5sZW5ndGggPT09IDApIHJldHVybiBuZXcgQk4oMSk7XG5cblx0ICAgIC8vIFNraXAgbGVhZGluZyB6ZXJvZXNcblx0ICAgIHZhciByZXMgPSB0aGlzO1xuXHQgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB3Lmxlbmd0aDsgaSsrLCByZXMgPSByZXMuc3FyKCkpIHtcblx0ICAgICAgaWYgKHdbaV0gIT09IDApIGJyZWFrO1xuXHQgICAgfVxuXG5cdCAgICBpZiAoKytpIDwgdy5sZW5ndGgpIHtcblx0ICAgICAgZm9yICh2YXIgcSA9IHJlcy5zcXIoKTsgaSA8IHcubGVuZ3RoOyBpKyssIHEgPSBxLnNxcigpKSB7XG5cdCAgICAgICAgaWYgKHdbaV0gPT09IDApIGNvbnRpbnVlO1xuXG5cdCAgICAgICAgcmVzID0gcmVzLm11bChxKTtcblx0ICAgICAgfVxuXHQgICAgfVxuXG5cdCAgICByZXR1cm4gcmVzO1xuXHQgIH07XG5cblx0ICAvLyBTaGlmdC1sZWZ0IGluLXBsYWNlXG5cdCAgQk4ucHJvdG90eXBlLml1c2hsbiA9IGZ1bmN0aW9uIGl1c2hsbiAoYml0cykge1xuXHQgICAgYXNzZXJ0KHR5cGVvZiBiaXRzID09PSAnbnVtYmVyJyAmJiBiaXRzID49IDApO1xuXHQgICAgdmFyIHIgPSBiaXRzICUgMjY7XG5cdCAgICB2YXIgcyA9IChiaXRzIC0gcikgLyAyNjtcblx0ICAgIHZhciBjYXJyeU1hc2sgPSAoMHgzZmZmZmZmID4+PiAoMjYgLSByKSkgPDwgKDI2IC0gcik7XG5cdCAgICB2YXIgaTtcblxuXHQgICAgaWYgKHIgIT09IDApIHtcblx0ICAgICAgdmFyIGNhcnJ5ID0gMDtcblxuXHQgICAgICBmb3IgKGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkrKykge1xuXHQgICAgICAgIHZhciBuZXdDYXJyeSA9IHRoaXMud29yZHNbaV0gJiBjYXJyeU1hc2s7XG5cdCAgICAgICAgdmFyIGMgPSAoKHRoaXMud29yZHNbaV0gfCAwKSAtIG5ld0NhcnJ5KSA8PCByO1xuXHQgICAgICAgIHRoaXMud29yZHNbaV0gPSBjIHwgY2Fycnk7XG5cdCAgICAgICAgY2FycnkgPSBuZXdDYXJyeSA+Pj4gKDI2IC0gcik7XG5cdCAgICAgIH1cblxuXHQgICAgICBpZiAoY2FycnkpIHtcblx0ICAgICAgICB0aGlzLndvcmRzW2ldID0gY2Fycnk7XG5cdCAgICAgICAgdGhpcy5sZW5ndGgrKztcblx0ICAgICAgfVxuXHQgICAgfVxuXG5cdCAgICBpZiAocyAhPT0gMCkge1xuXHQgICAgICBmb3IgKGkgPSB0aGlzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG5cdCAgICAgICAgdGhpcy53b3Jkc1tpICsgc10gPSB0aGlzLndvcmRzW2ldO1xuXHQgICAgICB9XG5cblx0ICAgICAgZm9yIChpID0gMDsgaSA8IHM7IGkrKykge1xuXHQgICAgICAgIHRoaXMud29yZHNbaV0gPSAwO1xuXHQgICAgICB9XG5cblx0ICAgICAgdGhpcy5sZW5ndGggKz0gcztcblx0ICAgIH1cblxuXHQgICAgcmV0dXJuIHRoaXMuc3RyaXAoKTtcblx0ICB9O1xuXG5cdCAgQk4ucHJvdG90eXBlLmlzaGxuID0gZnVuY3Rpb24gaXNobG4gKGJpdHMpIHtcblx0ICAgIC8vIFRPRE8oaW5kdXRueSk6IGltcGxlbWVudCBtZVxuXHQgICAgYXNzZXJ0KHRoaXMubmVnYXRpdmUgPT09IDApO1xuXHQgICAgcmV0dXJuIHRoaXMuaXVzaGxuKGJpdHMpO1xuXHQgIH07XG5cblx0ICAvLyBTaGlmdC1yaWdodCBpbi1wbGFjZVxuXHQgIC8vIE5PVEU6IGBoaW50YCBpcyBhIGxvd2VzdCBiaXQgYmVmb3JlIHRyYWlsaW5nIHplcm9lc1xuXHQgIC8vIE5PVEU6IGlmIGBleHRlbmRlZGAgaXMgcHJlc2VudCAtIGl0IHdpbGwgYmUgZmlsbGVkIHdpdGggZGVzdHJveWVkIGJpdHNcblx0ICBCTi5wcm90b3R5cGUuaXVzaHJuID0gZnVuY3Rpb24gaXVzaHJuIChiaXRzLCBoaW50LCBleHRlbmRlZCkge1xuXHQgICAgYXNzZXJ0KHR5cGVvZiBiaXRzID09PSAnbnVtYmVyJyAmJiBiaXRzID49IDApO1xuXHQgICAgdmFyIGg7XG5cdCAgICBpZiAoaGludCkge1xuXHQgICAgICBoID0gKGhpbnQgLSAoaGludCAlIDI2KSkgLyAyNjtcblx0ICAgIH0gZWxzZSB7XG5cdCAgICAgIGggPSAwO1xuXHQgICAgfVxuXG5cdCAgICB2YXIgciA9IGJpdHMgJSAyNjtcblx0ICAgIHZhciBzID0gTWF0aC5taW4oKGJpdHMgLSByKSAvIDI2LCB0aGlzLmxlbmd0aCk7XG5cdCAgICB2YXIgbWFzayA9IDB4M2ZmZmZmZiBeICgoMHgzZmZmZmZmID4+PiByKSA8PCByKTtcblx0ICAgIHZhciBtYXNrZWRXb3JkcyA9IGV4dGVuZGVkO1xuXG5cdCAgICBoIC09IHM7XG5cdCAgICBoID0gTWF0aC5tYXgoMCwgaCk7XG5cblx0ICAgIC8vIEV4dGVuZGVkIG1vZGUsIGNvcHkgbWFza2VkIHBhcnRcblx0ICAgIGlmIChtYXNrZWRXb3Jkcykge1xuXHQgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHM7IGkrKykge1xuXHQgICAgICAgIG1hc2tlZFdvcmRzLndvcmRzW2ldID0gdGhpcy53b3Jkc1tpXTtcblx0ICAgICAgfVxuXHQgICAgICBtYXNrZWRXb3Jkcy5sZW5ndGggPSBzO1xuXHQgICAgfVxuXG5cdCAgICBpZiAocyA9PT0gMCkge1xuXHQgICAgICAvLyBOby1vcCwgd2Ugc2hvdWxkIG5vdCBtb3ZlIGFueXRoaW5nIGF0IGFsbFxuXHQgICAgfSBlbHNlIGlmICh0aGlzLmxlbmd0aCA+IHMpIHtcblx0ICAgICAgdGhpcy5sZW5ndGggLT0gcztcblx0ICAgICAgZm9yIChpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpKyspIHtcblx0ICAgICAgICB0aGlzLndvcmRzW2ldID0gdGhpcy53b3Jkc1tpICsgc107XG5cdCAgICAgIH1cblx0ICAgIH0gZWxzZSB7XG5cdCAgICAgIHRoaXMud29yZHNbMF0gPSAwO1xuXHQgICAgICB0aGlzLmxlbmd0aCA9IDE7XG5cdCAgICB9XG5cblx0ICAgIHZhciBjYXJyeSA9IDA7XG5cdCAgICBmb3IgKGkgPSB0aGlzLmxlbmd0aCAtIDE7IGkgPj0gMCAmJiAoY2FycnkgIT09IDAgfHwgaSA+PSBoKTsgaS0tKSB7XG5cdCAgICAgIHZhciB3b3JkID0gdGhpcy53b3Jkc1tpXSB8IDA7XG5cdCAgICAgIHRoaXMud29yZHNbaV0gPSAoY2FycnkgPDwgKDI2IC0gcikpIHwgKHdvcmQgPj4+IHIpO1xuXHQgICAgICBjYXJyeSA9IHdvcmQgJiBtYXNrO1xuXHQgICAgfVxuXG5cdCAgICAvLyBQdXNoIGNhcnJpZWQgYml0cyBhcyBhIG1hc2tcblx0ICAgIGlmIChtYXNrZWRXb3JkcyAmJiBjYXJyeSAhPT0gMCkge1xuXHQgICAgICBtYXNrZWRXb3Jkcy53b3Jkc1ttYXNrZWRXb3Jkcy5sZW5ndGgrK10gPSBjYXJyeTtcblx0ICAgIH1cblxuXHQgICAgaWYgKHRoaXMubGVuZ3RoID09PSAwKSB7XG5cdCAgICAgIHRoaXMud29yZHNbMF0gPSAwO1xuXHQgICAgICB0aGlzLmxlbmd0aCA9IDE7XG5cdCAgICB9XG5cblx0ICAgIHJldHVybiB0aGlzLnN0cmlwKCk7XG5cdCAgfTtcblxuXHQgIEJOLnByb3RvdHlwZS5pc2hybiA9IGZ1bmN0aW9uIGlzaHJuIChiaXRzLCBoaW50LCBleHRlbmRlZCkge1xuXHQgICAgLy8gVE9ETyhpbmR1dG55KTogaW1wbGVtZW50IG1lXG5cdCAgICBhc3NlcnQodGhpcy5uZWdhdGl2ZSA9PT0gMCk7XG5cdCAgICByZXR1cm4gdGhpcy5pdXNocm4oYml0cywgaGludCwgZXh0ZW5kZWQpO1xuXHQgIH07XG5cblx0ICAvLyBTaGlmdC1sZWZ0XG5cdCAgQk4ucHJvdG90eXBlLnNobG4gPSBmdW5jdGlvbiBzaGxuIChiaXRzKSB7XG5cdCAgICByZXR1cm4gdGhpcy5jbG9uZSgpLmlzaGxuKGJpdHMpO1xuXHQgIH07XG5cblx0ICBCTi5wcm90b3R5cGUudXNobG4gPSBmdW5jdGlvbiB1c2hsbiAoYml0cykge1xuXHQgICAgcmV0dXJuIHRoaXMuY2xvbmUoKS5pdXNobG4oYml0cyk7XG5cdCAgfTtcblxuXHQgIC8vIFNoaWZ0LXJpZ2h0XG5cdCAgQk4ucHJvdG90eXBlLnNocm4gPSBmdW5jdGlvbiBzaHJuIChiaXRzKSB7XG5cdCAgICByZXR1cm4gdGhpcy5jbG9uZSgpLmlzaHJuKGJpdHMpO1xuXHQgIH07XG5cblx0ICBCTi5wcm90b3R5cGUudXNocm4gPSBmdW5jdGlvbiB1c2hybiAoYml0cykge1xuXHQgICAgcmV0dXJuIHRoaXMuY2xvbmUoKS5pdXNocm4oYml0cyk7XG5cdCAgfTtcblxuXHQgIC8vIFRlc3QgaWYgbiBiaXQgaXMgc2V0XG5cdCAgQk4ucHJvdG90eXBlLnRlc3RuID0gZnVuY3Rpb24gdGVzdG4gKGJpdCkge1xuXHQgICAgYXNzZXJ0KHR5cGVvZiBiaXQgPT09ICdudW1iZXInICYmIGJpdCA+PSAwKTtcblx0ICAgIHZhciByID0gYml0ICUgMjY7XG5cdCAgICB2YXIgcyA9IChiaXQgLSByKSAvIDI2O1xuXHQgICAgdmFyIHEgPSAxIDw8IHI7XG5cblx0ICAgIC8vIEZhc3QgY2FzZTogYml0IGlzIG11Y2ggaGlnaGVyIHRoYW4gYWxsIGV4aXN0aW5nIHdvcmRzXG5cdCAgICBpZiAodGhpcy5sZW5ndGggPD0gcykgcmV0dXJuIGZhbHNlO1xuXG5cdCAgICAvLyBDaGVjayBiaXQgYW5kIHJldHVyblxuXHQgICAgdmFyIHcgPSB0aGlzLndvcmRzW3NdO1xuXG5cdCAgICByZXR1cm4gISEodyAmIHEpO1xuXHQgIH07XG5cblx0ICAvLyBSZXR1cm4gb25seSBsb3dlcnMgYml0cyBvZiBudW1iZXIgKGluLXBsYWNlKVxuXHQgIEJOLnByb3RvdHlwZS5pbWFza24gPSBmdW5jdGlvbiBpbWFza24gKGJpdHMpIHtcblx0ICAgIGFzc2VydCh0eXBlb2YgYml0cyA9PT0gJ251bWJlcicgJiYgYml0cyA+PSAwKTtcblx0ICAgIHZhciByID0gYml0cyAlIDI2O1xuXHQgICAgdmFyIHMgPSAoYml0cyAtIHIpIC8gMjY7XG5cblx0ICAgIGFzc2VydCh0aGlzLm5lZ2F0aXZlID09PSAwLCAnaW1hc2tuIHdvcmtzIG9ubHkgd2l0aCBwb3NpdGl2ZSBudW1iZXJzJyk7XG5cblx0ICAgIGlmICh0aGlzLmxlbmd0aCA8PSBzKSB7XG5cdCAgICAgIHJldHVybiB0aGlzO1xuXHQgICAgfVxuXG5cdCAgICBpZiAociAhPT0gMCkge1xuXHQgICAgICBzKys7XG5cdCAgICB9XG5cdCAgICB0aGlzLmxlbmd0aCA9IE1hdGgubWluKHMsIHRoaXMubGVuZ3RoKTtcblxuXHQgICAgaWYgKHIgIT09IDApIHtcblx0ICAgICAgdmFyIG1hc2sgPSAweDNmZmZmZmYgXiAoKDB4M2ZmZmZmZiA+Pj4gcikgPDwgcik7XG5cdCAgICAgIHRoaXMud29yZHNbdGhpcy5sZW5ndGggLSAxXSAmPSBtYXNrO1xuXHQgICAgfVxuXG5cdCAgICByZXR1cm4gdGhpcy5zdHJpcCgpO1xuXHQgIH07XG5cblx0ICAvLyBSZXR1cm4gb25seSBsb3dlcnMgYml0cyBvZiBudW1iZXJcblx0ICBCTi5wcm90b3R5cGUubWFza24gPSBmdW5jdGlvbiBtYXNrbiAoYml0cykge1xuXHQgICAgcmV0dXJuIHRoaXMuY2xvbmUoKS5pbWFza24oYml0cyk7XG5cdCAgfTtcblxuXHQgIC8vIEFkZCBwbGFpbiBudW1iZXIgYG51bWAgdG8gYHRoaXNgXG5cdCAgQk4ucHJvdG90eXBlLmlhZGRuID0gZnVuY3Rpb24gaWFkZG4gKG51bSkge1xuXHQgICAgYXNzZXJ0KHR5cGVvZiBudW0gPT09ICdudW1iZXInKTtcblx0ICAgIGFzc2VydChudW0gPCAweDQwMDAwMDApO1xuXHQgICAgaWYgKG51bSA8IDApIHJldHVybiB0aGlzLmlzdWJuKC1udW0pO1xuXG5cdCAgICAvLyBQb3NzaWJsZSBzaWduIGNoYW5nZVxuXHQgICAgaWYgKHRoaXMubmVnYXRpdmUgIT09IDApIHtcblx0ICAgICAgaWYgKHRoaXMubGVuZ3RoID09PSAxICYmICh0aGlzLndvcmRzWzBdIHwgMCkgPCBudW0pIHtcblx0ICAgICAgICB0aGlzLndvcmRzWzBdID0gbnVtIC0gKHRoaXMud29yZHNbMF0gfCAwKTtcblx0ICAgICAgICB0aGlzLm5lZ2F0aXZlID0gMDtcblx0ICAgICAgICByZXR1cm4gdGhpcztcblx0ICAgICAgfVxuXG5cdCAgICAgIHRoaXMubmVnYXRpdmUgPSAwO1xuXHQgICAgICB0aGlzLmlzdWJuKG51bSk7XG5cdCAgICAgIHRoaXMubmVnYXRpdmUgPSAxO1xuXHQgICAgICByZXR1cm4gdGhpcztcblx0ICAgIH1cblxuXHQgICAgLy8gQWRkIHdpdGhvdXQgY2hlY2tzXG5cdCAgICByZXR1cm4gdGhpcy5faWFkZG4obnVtKTtcblx0ICB9O1xuXG5cdCAgQk4ucHJvdG90eXBlLl9pYWRkbiA9IGZ1bmN0aW9uIF9pYWRkbiAobnVtKSB7XG5cdCAgICB0aGlzLndvcmRzWzBdICs9IG51bTtcblxuXHQgICAgLy8gQ2Fycnlcblx0ICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5sZW5ndGggJiYgdGhpcy53b3Jkc1tpXSA+PSAweDQwMDAwMDA7IGkrKykge1xuXHQgICAgICB0aGlzLndvcmRzW2ldIC09IDB4NDAwMDAwMDtcblx0ICAgICAgaWYgKGkgPT09IHRoaXMubGVuZ3RoIC0gMSkge1xuXHQgICAgICAgIHRoaXMud29yZHNbaSArIDFdID0gMTtcblx0ICAgICAgfSBlbHNlIHtcblx0ICAgICAgICB0aGlzLndvcmRzW2kgKyAxXSsrO1xuXHQgICAgICB9XG5cdCAgICB9XG5cdCAgICB0aGlzLmxlbmd0aCA9IE1hdGgubWF4KHRoaXMubGVuZ3RoLCBpICsgMSk7XG5cblx0ICAgIHJldHVybiB0aGlzO1xuXHQgIH07XG5cblx0ICAvLyBTdWJ0cmFjdCBwbGFpbiBudW1iZXIgYG51bWAgZnJvbSBgdGhpc2Bcblx0ICBCTi5wcm90b3R5cGUuaXN1Ym4gPSBmdW5jdGlvbiBpc3VibiAobnVtKSB7XG5cdCAgICBhc3NlcnQodHlwZW9mIG51bSA9PT0gJ251bWJlcicpO1xuXHQgICAgYXNzZXJ0KG51bSA8IDB4NDAwMDAwMCk7XG5cdCAgICBpZiAobnVtIDwgMCkgcmV0dXJuIHRoaXMuaWFkZG4oLW51bSk7XG5cblx0ICAgIGlmICh0aGlzLm5lZ2F0aXZlICE9PSAwKSB7XG5cdCAgICAgIHRoaXMubmVnYXRpdmUgPSAwO1xuXHQgICAgICB0aGlzLmlhZGRuKG51bSk7XG5cdCAgICAgIHRoaXMubmVnYXRpdmUgPSAxO1xuXHQgICAgICByZXR1cm4gdGhpcztcblx0ICAgIH1cblxuXHQgICAgdGhpcy53b3Jkc1swXSAtPSBudW07XG5cblx0ICAgIGlmICh0aGlzLmxlbmd0aCA9PT0gMSAmJiB0aGlzLndvcmRzWzBdIDwgMCkge1xuXHQgICAgICB0aGlzLndvcmRzWzBdID0gLXRoaXMud29yZHNbMF07XG5cdCAgICAgIHRoaXMubmVnYXRpdmUgPSAxO1xuXHQgICAgfSBlbHNlIHtcblx0ICAgICAgLy8gQ2Fycnlcblx0ICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmxlbmd0aCAmJiB0aGlzLndvcmRzW2ldIDwgMDsgaSsrKSB7XG5cdCAgICAgICAgdGhpcy53b3Jkc1tpXSArPSAweDQwMDAwMDA7XG5cdCAgICAgICAgdGhpcy53b3Jkc1tpICsgMV0gLT0gMTtcblx0ICAgICAgfVxuXHQgICAgfVxuXG5cdCAgICByZXR1cm4gdGhpcy5zdHJpcCgpO1xuXHQgIH07XG5cblx0ICBCTi5wcm90b3R5cGUuYWRkbiA9IGZ1bmN0aW9uIGFkZG4gKG51bSkge1xuXHQgICAgcmV0dXJuIHRoaXMuY2xvbmUoKS5pYWRkbihudW0pO1xuXHQgIH07XG5cblx0ICBCTi5wcm90b3R5cGUuc3VibiA9IGZ1bmN0aW9uIHN1Ym4gKG51bSkge1xuXHQgICAgcmV0dXJuIHRoaXMuY2xvbmUoKS5pc3VibihudW0pO1xuXHQgIH07XG5cblx0ICBCTi5wcm90b3R5cGUuaWFicyA9IGZ1bmN0aW9uIGlhYnMgKCkge1xuXHQgICAgdGhpcy5uZWdhdGl2ZSA9IDA7XG5cblx0ICAgIHJldHVybiB0aGlzO1xuXHQgIH07XG5cblx0ICBCTi5wcm90b3R5cGUuYWJzID0gZnVuY3Rpb24gYWJzICgpIHtcblx0ICAgIHJldHVybiB0aGlzLmNsb25lKCkuaWFicygpO1xuXHQgIH07XG5cblx0ICBCTi5wcm90b3R5cGUuX2lzaGxuc3VibXVsID0gZnVuY3Rpb24gX2lzaGxuc3VibXVsIChudW0sIG11bCwgc2hpZnQpIHtcblx0ICAgIHZhciBsZW4gPSBudW0ubGVuZ3RoICsgc2hpZnQ7XG5cdCAgICB2YXIgaTtcblxuXHQgICAgdGhpcy5fZXhwYW5kKGxlbik7XG5cblx0ICAgIHZhciB3O1xuXHQgICAgdmFyIGNhcnJ5ID0gMDtcblx0ICAgIGZvciAoaSA9IDA7IGkgPCBudW0ubGVuZ3RoOyBpKyspIHtcblx0ICAgICAgdyA9ICh0aGlzLndvcmRzW2kgKyBzaGlmdF0gfCAwKSArIGNhcnJ5O1xuXHQgICAgICB2YXIgcmlnaHQgPSAobnVtLndvcmRzW2ldIHwgMCkgKiBtdWw7XG5cdCAgICAgIHcgLT0gcmlnaHQgJiAweDNmZmZmZmY7XG5cdCAgICAgIGNhcnJ5ID0gKHcgPj4gMjYpIC0gKChyaWdodCAvIDB4NDAwMDAwMCkgfCAwKTtcblx0ICAgICAgdGhpcy53b3Jkc1tpICsgc2hpZnRdID0gdyAmIDB4M2ZmZmZmZjtcblx0ICAgIH1cblx0ICAgIGZvciAoOyBpIDwgdGhpcy5sZW5ndGggLSBzaGlmdDsgaSsrKSB7XG5cdCAgICAgIHcgPSAodGhpcy53b3Jkc1tpICsgc2hpZnRdIHwgMCkgKyBjYXJyeTtcblx0ICAgICAgY2FycnkgPSB3ID4+IDI2O1xuXHQgICAgICB0aGlzLndvcmRzW2kgKyBzaGlmdF0gPSB3ICYgMHgzZmZmZmZmO1xuXHQgICAgfVxuXG5cdCAgICBpZiAoY2FycnkgPT09IDApIHJldHVybiB0aGlzLnN0cmlwKCk7XG5cblx0ICAgIC8vIFN1YnRyYWN0aW9uIG92ZXJmbG93XG5cdCAgICBhc3NlcnQoY2FycnkgPT09IC0xKTtcblx0ICAgIGNhcnJ5ID0gMDtcblx0ICAgIGZvciAoaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgaSsrKSB7XG5cdCAgICAgIHcgPSAtKHRoaXMud29yZHNbaV0gfCAwKSArIGNhcnJ5O1xuXHQgICAgICBjYXJyeSA9IHcgPj4gMjY7XG5cdCAgICAgIHRoaXMud29yZHNbaV0gPSB3ICYgMHgzZmZmZmZmO1xuXHQgICAgfVxuXHQgICAgdGhpcy5uZWdhdGl2ZSA9IDE7XG5cblx0ICAgIHJldHVybiB0aGlzLnN0cmlwKCk7XG5cdCAgfTtcblxuXHQgIEJOLnByb3RvdHlwZS5fd29yZERpdiA9IGZ1bmN0aW9uIF93b3JkRGl2IChudW0sIG1vZGUpIHtcblx0ICAgIHZhciBzaGlmdCA9IHRoaXMubGVuZ3RoIC0gbnVtLmxlbmd0aDtcblxuXHQgICAgdmFyIGEgPSB0aGlzLmNsb25lKCk7XG5cdCAgICB2YXIgYiA9IG51bTtcblxuXHQgICAgLy8gTm9ybWFsaXplXG5cdCAgICB2YXIgYmhpID0gYi53b3Jkc1tiLmxlbmd0aCAtIDFdIHwgMDtcblx0ICAgIHZhciBiaGlCaXRzID0gdGhpcy5fY291bnRCaXRzKGJoaSk7XG5cdCAgICBzaGlmdCA9IDI2IC0gYmhpQml0cztcblx0ICAgIGlmIChzaGlmdCAhPT0gMCkge1xuXHQgICAgICBiID0gYi51c2hsbihzaGlmdCk7XG5cdCAgICAgIGEuaXVzaGxuKHNoaWZ0KTtcblx0ICAgICAgYmhpID0gYi53b3Jkc1tiLmxlbmd0aCAtIDFdIHwgMDtcblx0ICAgIH1cblxuXHQgICAgLy8gSW5pdGlhbGl6ZSBxdW90aWVudFxuXHQgICAgdmFyIG0gPSBhLmxlbmd0aCAtIGIubGVuZ3RoO1xuXHQgICAgdmFyIHE7XG5cblx0ICAgIGlmIChtb2RlICE9PSAnbW9kJykge1xuXHQgICAgICBxID0gbmV3IEJOKG51bGwpO1xuXHQgICAgICBxLmxlbmd0aCA9IG0gKyAxO1xuXHQgICAgICBxLndvcmRzID0gbmV3IEFycmF5KHEubGVuZ3RoKTtcblx0ICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBxLmxlbmd0aDsgaSsrKSB7XG5cdCAgICAgICAgcS53b3Jkc1tpXSA9IDA7XG5cdCAgICAgIH1cblx0ICAgIH1cblxuXHQgICAgdmFyIGRpZmYgPSBhLmNsb25lKCkuX2lzaGxuc3VibXVsKGIsIDEsIG0pO1xuXHQgICAgaWYgKGRpZmYubmVnYXRpdmUgPT09IDApIHtcblx0ICAgICAgYSA9IGRpZmY7XG5cdCAgICAgIGlmIChxKSB7XG5cdCAgICAgICAgcS53b3Jkc1ttXSA9IDE7XG5cdCAgICAgIH1cblx0ICAgIH1cblxuXHQgICAgZm9yICh2YXIgaiA9IG0gLSAxOyBqID49IDA7IGotLSkge1xuXHQgICAgICB2YXIgcWogPSAoYS53b3Jkc1tiLmxlbmd0aCArIGpdIHwgMCkgKiAweDQwMDAwMDAgK1xuXHQgICAgICAgIChhLndvcmRzW2IubGVuZ3RoICsgaiAtIDFdIHwgMCk7XG5cblx0ICAgICAgLy8gTk9URTogKHFqIC8gYmhpKSBpcyAoMHgzZmZmZmZmICogMHg0MDAwMDAwICsgMHgzZmZmZmZmKSAvIDB4MjAwMDAwMCBtYXhcblx0ICAgICAgLy8gKDB4N2ZmZmZmZilcblx0ICAgICAgcWogPSBNYXRoLm1pbigocWogLyBiaGkpIHwgMCwgMHgzZmZmZmZmKTtcblxuXHQgICAgICBhLl9pc2hsbnN1Ym11bChiLCBxaiwgaik7XG5cdCAgICAgIHdoaWxlIChhLm5lZ2F0aXZlICE9PSAwKSB7XG5cdCAgICAgICAgcWotLTtcblx0ICAgICAgICBhLm5lZ2F0aXZlID0gMDtcblx0ICAgICAgICBhLl9pc2hsbnN1Ym11bChiLCAxLCBqKTtcblx0ICAgICAgICBpZiAoIWEuaXNaZXJvKCkpIHtcblx0ICAgICAgICAgIGEubmVnYXRpdmUgXj0gMTtcblx0ICAgICAgICB9XG5cdCAgICAgIH1cblx0ICAgICAgaWYgKHEpIHtcblx0ICAgICAgICBxLndvcmRzW2pdID0gcWo7XG5cdCAgICAgIH1cblx0ICAgIH1cblx0ICAgIGlmIChxKSB7XG5cdCAgICAgIHEuc3RyaXAoKTtcblx0ICAgIH1cblx0ICAgIGEuc3RyaXAoKTtcblxuXHQgICAgLy8gRGVub3JtYWxpemVcblx0ICAgIGlmIChtb2RlICE9PSAnZGl2JyAmJiBzaGlmdCAhPT0gMCkge1xuXHQgICAgICBhLml1c2hybihzaGlmdCk7XG5cdCAgICB9XG5cblx0ICAgIHJldHVybiB7XG5cdCAgICAgIGRpdjogcSB8fCBudWxsLFxuXHQgICAgICBtb2Q6IGFcblx0ICAgIH07XG5cdCAgfTtcblxuXHQgIC8vIE5PVEU6IDEpIGBtb2RlYCBjYW4gYmUgc2V0IHRvIGBtb2RgIHRvIHJlcXVlc3QgbW9kIG9ubHksXG5cdCAgLy8gICAgICAgdG8gYGRpdmAgdG8gcmVxdWVzdCBkaXYgb25seSwgb3IgYmUgYWJzZW50IHRvXG5cdCAgLy8gICAgICAgcmVxdWVzdCBib3RoIGRpdiAmIG1vZFxuXHQgIC8vICAgICAgIDIpIGBwb3NpdGl2ZWAgaXMgdHJ1ZSBpZiB1bnNpZ25lZCBtb2QgaXMgcmVxdWVzdGVkXG5cdCAgQk4ucHJvdG90eXBlLmRpdm1vZCA9IGZ1bmN0aW9uIGRpdm1vZCAobnVtLCBtb2RlLCBwb3NpdGl2ZSkge1xuXHQgICAgYXNzZXJ0KCFudW0uaXNaZXJvKCkpO1xuXG5cdCAgICBpZiAodGhpcy5pc1plcm8oKSkge1xuXHQgICAgICByZXR1cm4ge1xuXHQgICAgICAgIGRpdjogbmV3IEJOKDApLFxuXHQgICAgICAgIG1vZDogbmV3IEJOKDApXG5cdCAgICAgIH07XG5cdCAgICB9XG5cblx0ICAgIHZhciBkaXYsIG1vZCwgcmVzO1xuXHQgICAgaWYgKHRoaXMubmVnYXRpdmUgIT09IDAgJiYgbnVtLm5lZ2F0aXZlID09PSAwKSB7XG5cdCAgICAgIHJlcyA9IHRoaXMubmVnKCkuZGl2bW9kKG51bSwgbW9kZSk7XG5cblx0ICAgICAgaWYgKG1vZGUgIT09ICdtb2QnKSB7XG5cdCAgICAgICAgZGl2ID0gcmVzLmRpdi5uZWcoKTtcblx0ICAgICAgfVxuXG5cdCAgICAgIGlmIChtb2RlICE9PSAnZGl2Jykge1xuXHQgICAgICAgIG1vZCA9IHJlcy5tb2QubmVnKCk7XG5cdCAgICAgICAgaWYgKHBvc2l0aXZlICYmIG1vZC5uZWdhdGl2ZSAhPT0gMCkge1xuXHQgICAgICAgICAgbW9kLmlhZGQobnVtKTtcblx0ICAgICAgICB9XG5cdCAgICAgIH1cblxuXHQgICAgICByZXR1cm4ge1xuXHQgICAgICAgIGRpdjogZGl2LFxuXHQgICAgICAgIG1vZDogbW9kXG5cdCAgICAgIH07XG5cdCAgICB9XG5cblx0ICAgIGlmICh0aGlzLm5lZ2F0aXZlID09PSAwICYmIG51bS5uZWdhdGl2ZSAhPT0gMCkge1xuXHQgICAgICByZXMgPSB0aGlzLmRpdm1vZChudW0ubmVnKCksIG1vZGUpO1xuXG5cdCAgICAgIGlmIChtb2RlICE9PSAnbW9kJykge1xuXHQgICAgICAgIGRpdiA9IHJlcy5kaXYubmVnKCk7XG5cdCAgICAgIH1cblxuXHQgICAgICByZXR1cm4ge1xuXHQgICAgICAgIGRpdjogZGl2LFxuXHQgICAgICAgIG1vZDogcmVzLm1vZFxuXHQgICAgICB9O1xuXHQgICAgfVxuXG5cdCAgICBpZiAoKHRoaXMubmVnYXRpdmUgJiBudW0ubmVnYXRpdmUpICE9PSAwKSB7XG5cdCAgICAgIHJlcyA9IHRoaXMubmVnKCkuZGl2bW9kKG51bS5uZWcoKSwgbW9kZSk7XG5cblx0ICAgICAgaWYgKG1vZGUgIT09ICdkaXYnKSB7XG5cdCAgICAgICAgbW9kID0gcmVzLm1vZC5uZWcoKTtcblx0ICAgICAgICBpZiAocG9zaXRpdmUgJiYgbW9kLm5lZ2F0aXZlICE9PSAwKSB7XG5cdCAgICAgICAgICBtb2QuaXN1YihudW0pO1xuXHQgICAgICAgIH1cblx0ICAgICAgfVxuXG5cdCAgICAgIHJldHVybiB7XG5cdCAgICAgICAgZGl2OiByZXMuZGl2LFxuXHQgICAgICAgIG1vZDogbW9kXG5cdCAgICAgIH07XG5cdCAgICB9XG5cblx0ICAgIC8vIEJvdGggbnVtYmVycyBhcmUgcG9zaXRpdmUgYXQgdGhpcyBwb2ludFxuXG5cdCAgICAvLyBTdHJpcCBib3RoIG51bWJlcnMgdG8gYXBwcm94aW1hdGUgc2hpZnQgdmFsdWVcblx0ICAgIGlmIChudW0ubGVuZ3RoID4gdGhpcy5sZW5ndGggfHwgdGhpcy5jbXAobnVtKSA8IDApIHtcblx0ICAgICAgcmV0dXJuIHtcblx0ICAgICAgICBkaXY6IG5ldyBCTigwKSxcblx0ICAgICAgICBtb2Q6IHRoaXNcblx0ICAgICAgfTtcblx0ICAgIH1cblxuXHQgICAgLy8gVmVyeSBzaG9ydCByZWR1Y3Rpb25cblx0ICAgIGlmIChudW0ubGVuZ3RoID09PSAxKSB7XG5cdCAgICAgIGlmIChtb2RlID09PSAnZGl2Jykge1xuXHQgICAgICAgIHJldHVybiB7XG5cdCAgICAgICAgICBkaXY6IHRoaXMuZGl2bihudW0ud29yZHNbMF0pLFxuXHQgICAgICAgICAgbW9kOiBudWxsXG5cdCAgICAgICAgfTtcblx0ICAgICAgfVxuXG5cdCAgICAgIGlmIChtb2RlID09PSAnbW9kJykge1xuXHQgICAgICAgIHJldHVybiB7XG5cdCAgICAgICAgICBkaXY6IG51bGwsXG5cdCAgICAgICAgICBtb2Q6IG5ldyBCTih0aGlzLm1vZG4obnVtLndvcmRzWzBdKSlcblx0ICAgICAgICB9O1xuXHQgICAgICB9XG5cblx0ICAgICAgcmV0dXJuIHtcblx0ICAgICAgICBkaXY6IHRoaXMuZGl2bihudW0ud29yZHNbMF0pLFxuXHQgICAgICAgIG1vZDogbmV3IEJOKHRoaXMubW9kbihudW0ud29yZHNbMF0pKVxuXHQgICAgICB9O1xuXHQgICAgfVxuXG5cdCAgICByZXR1cm4gdGhpcy5fd29yZERpdihudW0sIG1vZGUpO1xuXHQgIH07XG5cblx0ICAvLyBGaW5kIGB0aGlzYCAvIGBudW1gXG5cdCAgQk4ucHJvdG90eXBlLmRpdiA9IGZ1bmN0aW9uIGRpdiAobnVtKSB7XG5cdCAgICByZXR1cm4gdGhpcy5kaXZtb2QobnVtLCAnZGl2JywgZmFsc2UpLmRpdjtcblx0ICB9O1xuXG5cdCAgLy8gRmluZCBgdGhpc2AgJSBgbnVtYFxuXHQgIEJOLnByb3RvdHlwZS5tb2QgPSBmdW5jdGlvbiBtb2QgKG51bSkge1xuXHQgICAgcmV0dXJuIHRoaXMuZGl2bW9kKG51bSwgJ21vZCcsIGZhbHNlKS5tb2Q7XG5cdCAgfTtcblxuXHQgIEJOLnByb3RvdHlwZS51bW9kID0gZnVuY3Rpb24gdW1vZCAobnVtKSB7XG5cdCAgICByZXR1cm4gdGhpcy5kaXZtb2QobnVtLCAnbW9kJywgdHJ1ZSkubW9kO1xuXHQgIH07XG5cblx0ICAvLyBGaW5kIFJvdW5kKGB0aGlzYCAvIGBudW1gKVxuXHQgIEJOLnByb3RvdHlwZS5kaXZSb3VuZCA9IGZ1bmN0aW9uIGRpdlJvdW5kIChudW0pIHtcblx0ICAgIHZhciBkbSA9IHRoaXMuZGl2bW9kKG51bSk7XG5cblx0ICAgIC8vIEZhc3QgY2FzZSAtIGV4YWN0IGRpdmlzaW9uXG5cdCAgICBpZiAoZG0ubW9kLmlzWmVybygpKSByZXR1cm4gZG0uZGl2O1xuXG5cdCAgICB2YXIgbW9kID0gZG0uZGl2Lm5lZ2F0aXZlICE9PSAwID8gZG0ubW9kLmlzdWIobnVtKSA6IGRtLm1vZDtcblxuXHQgICAgdmFyIGhhbGYgPSBudW0udXNocm4oMSk7XG5cdCAgICB2YXIgcjIgPSBudW0uYW5kbG4oMSk7XG5cdCAgICB2YXIgY21wID0gbW9kLmNtcChoYWxmKTtcblxuXHQgICAgLy8gUm91bmQgZG93blxuXHQgICAgaWYgKGNtcCA8IDAgfHwgcjIgPT09IDEgJiYgY21wID09PSAwKSByZXR1cm4gZG0uZGl2O1xuXG5cdCAgICAvLyBSb3VuZCB1cFxuXHQgICAgcmV0dXJuIGRtLmRpdi5uZWdhdGl2ZSAhPT0gMCA/IGRtLmRpdi5pc3VibigxKSA6IGRtLmRpdi5pYWRkbigxKTtcblx0ICB9O1xuXG5cdCAgQk4ucHJvdG90eXBlLm1vZG4gPSBmdW5jdGlvbiBtb2RuIChudW0pIHtcblx0ICAgIGFzc2VydChudW0gPD0gMHgzZmZmZmZmKTtcblx0ICAgIHZhciBwID0gKDEgPDwgMjYpICUgbnVtO1xuXG5cdCAgICB2YXIgYWNjID0gMDtcblx0ICAgIGZvciAodmFyIGkgPSB0aGlzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG5cdCAgICAgIGFjYyA9IChwICogYWNjICsgKHRoaXMud29yZHNbaV0gfCAwKSkgJSBudW07XG5cdCAgICB9XG5cblx0ICAgIHJldHVybiBhY2M7XG5cdCAgfTtcblxuXHQgIC8vIEluLXBsYWNlIGRpdmlzaW9uIGJ5IG51bWJlclxuXHQgIEJOLnByb3RvdHlwZS5pZGl2biA9IGZ1bmN0aW9uIGlkaXZuIChudW0pIHtcblx0ICAgIGFzc2VydChudW0gPD0gMHgzZmZmZmZmKTtcblxuXHQgICAgdmFyIGNhcnJ5ID0gMDtcblx0ICAgIGZvciAodmFyIGkgPSB0aGlzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG5cdCAgICAgIHZhciB3ID0gKHRoaXMud29yZHNbaV0gfCAwKSArIGNhcnJ5ICogMHg0MDAwMDAwO1xuXHQgICAgICB0aGlzLndvcmRzW2ldID0gKHcgLyBudW0pIHwgMDtcblx0ICAgICAgY2FycnkgPSB3ICUgbnVtO1xuXHQgICAgfVxuXG5cdCAgICByZXR1cm4gdGhpcy5zdHJpcCgpO1xuXHQgIH07XG5cblx0ICBCTi5wcm90b3R5cGUuZGl2biA9IGZ1bmN0aW9uIGRpdm4gKG51bSkge1xuXHQgICAgcmV0dXJuIHRoaXMuY2xvbmUoKS5pZGl2bihudW0pO1xuXHQgIH07XG5cblx0ICBCTi5wcm90b3R5cGUuZWdjZCA9IGZ1bmN0aW9uIGVnY2QgKHApIHtcblx0ICAgIGFzc2VydChwLm5lZ2F0aXZlID09PSAwKTtcblx0ICAgIGFzc2VydCghcC5pc1plcm8oKSk7XG5cblx0ICAgIHZhciB4ID0gdGhpcztcblx0ICAgIHZhciB5ID0gcC5jbG9uZSgpO1xuXG5cdCAgICBpZiAoeC5uZWdhdGl2ZSAhPT0gMCkge1xuXHQgICAgICB4ID0geC51bW9kKHApO1xuXHQgICAgfSBlbHNlIHtcblx0ICAgICAgeCA9IHguY2xvbmUoKTtcblx0ICAgIH1cblxuXHQgICAgLy8gQSAqIHggKyBCICogeSA9IHhcblx0ICAgIHZhciBBID0gbmV3IEJOKDEpO1xuXHQgICAgdmFyIEIgPSBuZXcgQk4oMCk7XG5cblx0ICAgIC8vIEMgKiB4ICsgRCAqIHkgPSB5XG5cdCAgICB2YXIgQyA9IG5ldyBCTigwKTtcblx0ICAgIHZhciBEID0gbmV3IEJOKDEpO1xuXG5cdCAgICB2YXIgZyA9IDA7XG5cblx0ICAgIHdoaWxlICh4LmlzRXZlbigpICYmIHkuaXNFdmVuKCkpIHtcblx0ICAgICAgeC5pdXNocm4oMSk7XG5cdCAgICAgIHkuaXVzaHJuKDEpO1xuXHQgICAgICArK2c7XG5cdCAgICB9XG5cblx0ICAgIHZhciB5cCA9IHkuY2xvbmUoKTtcblx0ICAgIHZhciB4cCA9IHguY2xvbmUoKTtcblxuXHQgICAgd2hpbGUgKCF4LmlzWmVybygpKSB7XG5cdCAgICAgIGZvciAodmFyIGkgPSAwLCBpbSA9IDE7ICh4LndvcmRzWzBdICYgaW0pID09PSAwICYmIGkgPCAyNjsgKytpLCBpbSA8PD0gMSk7XG5cdCAgICAgIGlmIChpID4gMCkge1xuXHQgICAgICAgIHguaXVzaHJuKGkpO1xuXHQgICAgICAgIHdoaWxlIChpLS0gPiAwKSB7XG5cdCAgICAgICAgICBpZiAoQS5pc09kZCgpIHx8IEIuaXNPZGQoKSkge1xuXHQgICAgICAgICAgICBBLmlhZGQoeXApO1xuXHQgICAgICAgICAgICBCLmlzdWIoeHApO1xuXHQgICAgICAgICAgfVxuXG5cdCAgICAgICAgICBBLml1c2hybigxKTtcblx0ICAgICAgICAgIEIuaXVzaHJuKDEpO1xuXHQgICAgICAgIH1cblx0ICAgICAgfVxuXG5cdCAgICAgIGZvciAodmFyIGogPSAwLCBqbSA9IDE7ICh5LndvcmRzWzBdICYgam0pID09PSAwICYmIGogPCAyNjsgKytqLCBqbSA8PD0gMSk7XG5cdCAgICAgIGlmIChqID4gMCkge1xuXHQgICAgICAgIHkuaXVzaHJuKGopO1xuXHQgICAgICAgIHdoaWxlIChqLS0gPiAwKSB7XG5cdCAgICAgICAgICBpZiAoQy5pc09kZCgpIHx8IEQuaXNPZGQoKSkge1xuXHQgICAgICAgICAgICBDLmlhZGQoeXApO1xuXHQgICAgICAgICAgICBELmlzdWIoeHApO1xuXHQgICAgICAgICAgfVxuXG5cdCAgICAgICAgICBDLml1c2hybigxKTtcblx0ICAgICAgICAgIEQuaXVzaHJuKDEpO1xuXHQgICAgICAgIH1cblx0ICAgICAgfVxuXG5cdCAgICAgIGlmICh4LmNtcCh5KSA+PSAwKSB7XG5cdCAgICAgICAgeC5pc3ViKHkpO1xuXHQgICAgICAgIEEuaXN1YihDKTtcblx0ICAgICAgICBCLmlzdWIoRCk7XG5cdCAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgeS5pc3ViKHgpO1xuXHQgICAgICAgIEMuaXN1YihBKTtcblx0ICAgICAgICBELmlzdWIoQik7XG5cdCAgICAgIH1cblx0ICAgIH1cblxuXHQgICAgcmV0dXJuIHtcblx0ICAgICAgYTogQyxcblx0ICAgICAgYjogRCxcblx0ICAgICAgZ2NkOiB5Lml1c2hsbihnKVxuXHQgICAgfTtcblx0ICB9O1xuXG5cdCAgLy8gVGhpcyBpcyByZWR1Y2VkIGluY2FybmF0aW9uIG9mIHRoZSBiaW5hcnkgRUVBXG5cdCAgLy8gYWJvdmUsIGRlc2lnbmF0ZWQgdG8gaW52ZXJ0IG1lbWJlcnMgb2YgdGhlXG5cdCAgLy8gX3ByaW1lXyBmaWVsZHMgRihwKSBhdCBhIG1heGltYWwgc3BlZWRcblx0ICBCTi5wcm90b3R5cGUuX2ludm1wID0gZnVuY3Rpb24gX2ludm1wIChwKSB7XG5cdCAgICBhc3NlcnQocC5uZWdhdGl2ZSA9PT0gMCk7XG5cdCAgICBhc3NlcnQoIXAuaXNaZXJvKCkpO1xuXG5cdCAgICB2YXIgYSA9IHRoaXM7XG5cdCAgICB2YXIgYiA9IHAuY2xvbmUoKTtcblxuXHQgICAgaWYgKGEubmVnYXRpdmUgIT09IDApIHtcblx0ICAgICAgYSA9IGEudW1vZChwKTtcblx0ICAgIH0gZWxzZSB7XG5cdCAgICAgIGEgPSBhLmNsb25lKCk7XG5cdCAgICB9XG5cblx0ICAgIHZhciB4MSA9IG5ldyBCTigxKTtcblx0ICAgIHZhciB4MiA9IG5ldyBCTigwKTtcblxuXHQgICAgdmFyIGRlbHRhID0gYi5jbG9uZSgpO1xuXG5cdCAgICB3aGlsZSAoYS5jbXBuKDEpID4gMCAmJiBiLmNtcG4oMSkgPiAwKSB7XG5cdCAgICAgIGZvciAodmFyIGkgPSAwLCBpbSA9IDE7IChhLndvcmRzWzBdICYgaW0pID09PSAwICYmIGkgPCAyNjsgKytpLCBpbSA8PD0gMSk7XG5cdCAgICAgIGlmIChpID4gMCkge1xuXHQgICAgICAgIGEuaXVzaHJuKGkpO1xuXHQgICAgICAgIHdoaWxlIChpLS0gPiAwKSB7XG5cdCAgICAgICAgICBpZiAoeDEuaXNPZGQoKSkge1xuXHQgICAgICAgICAgICB4MS5pYWRkKGRlbHRhKTtcblx0ICAgICAgICAgIH1cblxuXHQgICAgICAgICAgeDEuaXVzaHJuKDEpO1xuXHQgICAgICAgIH1cblx0ICAgICAgfVxuXG5cdCAgICAgIGZvciAodmFyIGogPSAwLCBqbSA9IDE7IChiLndvcmRzWzBdICYgam0pID09PSAwICYmIGogPCAyNjsgKytqLCBqbSA8PD0gMSk7XG5cdCAgICAgIGlmIChqID4gMCkge1xuXHQgICAgICAgIGIuaXVzaHJuKGopO1xuXHQgICAgICAgIHdoaWxlIChqLS0gPiAwKSB7XG5cdCAgICAgICAgICBpZiAoeDIuaXNPZGQoKSkge1xuXHQgICAgICAgICAgICB4Mi5pYWRkKGRlbHRhKTtcblx0ICAgICAgICAgIH1cblxuXHQgICAgICAgICAgeDIuaXVzaHJuKDEpO1xuXHQgICAgICAgIH1cblx0ICAgICAgfVxuXG5cdCAgICAgIGlmIChhLmNtcChiKSA+PSAwKSB7XG5cdCAgICAgICAgYS5pc3ViKGIpO1xuXHQgICAgICAgIHgxLmlzdWIoeDIpO1xuXHQgICAgICB9IGVsc2Uge1xuXHQgICAgICAgIGIuaXN1YihhKTtcblx0ICAgICAgICB4Mi5pc3ViKHgxKTtcblx0ICAgICAgfVxuXHQgICAgfVxuXG5cdCAgICB2YXIgcmVzO1xuXHQgICAgaWYgKGEuY21wbigxKSA9PT0gMCkge1xuXHQgICAgICByZXMgPSB4MTtcblx0ICAgIH0gZWxzZSB7XG5cdCAgICAgIHJlcyA9IHgyO1xuXHQgICAgfVxuXG5cdCAgICBpZiAocmVzLmNtcG4oMCkgPCAwKSB7XG5cdCAgICAgIHJlcy5pYWRkKHApO1xuXHQgICAgfVxuXG5cdCAgICByZXR1cm4gcmVzO1xuXHQgIH07XG5cblx0ICBCTi5wcm90b3R5cGUuZ2NkID0gZnVuY3Rpb24gZ2NkIChudW0pIHtcblx0ICAgIGlmICh0aGlzLmlzWmVybygpKSByZXR1cm4gbnVtLmFicygpO1xuXHQgICAgaWYgKG51bS5pc1plcm8oKSkgcmV0dXJuIHRoaXMuYWJzKCk7XG5cblx0ICAgIHZhciBhID0gdGhpcy5jbG9uZSgpO1xuXHQgICAgdmFyIGIgPSBudW0uY2xvbmUoKTtcblx0ICAgIGEubmVnYXRpdmUgPSAwO1xuXHQgICAgYi5uZWdhdGl2ZSA9IDA7XG5cblx0ICAgIC8vIFJlbW92ZSBjb21tb24gZmFjdG9yIG9mIHR3b1xuXHQgICAgZm9yICh2YXIgc2hpZnQgPSAwOyBhLmlzRXZlbigpICYmIGIuaXNFdmVuKCk7IHNoaWZ0KyspIHtcblx0ICAgICAgYS5pdXNocm4oMSk7XG5cdCAgICAgIGIuaXVzaHJuKDEpO1xuXHQgICAgfVxuXG5cdCAgICBkbyB7XG5cdCAgICAgIHdoaWxlIChhLmlzRXZlbigpKSB7XG5cdCAgICAgICAgYS5pdXNocm4oMSk7XG5cdCAgICAgIH1cblx0ICAgICAgd2hpbGUgKGIuaXNFdmVuKCkpIHtcblx0ICAgICAgICBiLml1c2hybigxKTtcblx0ICAgICAgfVxuXG5cdCAgICAgIHZhciByID0gYS5jbXAoYik7XG5cdCAgICAgIGlmIChyIDwgMCkge1xuXHQgICAgICAgIC8vIFN3YXAgYGFgIGFuZCBgYmAgdG8gbWFrZSBgYWAgYWx3YXlzIGJpZ2dlciB0aGFuIGBiYFxuXHQgICAgICAgIHZhciB0ID0gYTtcblx0ICAgICAgICBhID0gYjtcblx0ICAgICAgICBiID0gdDtcblx0ICAgICAgfSBlbHNlIGlmIChyID09PSAwIHx8IGIuY21wbigxKSA9PT0gMCkge1xuXHQgICAgICAgIGJyZWFrO1xuXHQgICAgICB9XG5cblx0ICAgICAgYS5pc3ViKGIpO1xuXHQgICAgfSB3aGlsZSAodHJ1ZSk7XG5cblx0ICAgIHJldHVybiBiLml1c2hsbihzaGlmdCk7XG5cdCAgfTtcblxuXHQgIC8vIEludmVydCBudW1iZXIgaW4gdGhlIGZpZWxkIEYobnVtKVxuXHQgIEJOLnByb3RvdHlwZS5pbnZtID0gZnVuY3Rpb24gaW52bSAobnVtKSB7XG5cdCAgICByZXR1cm4gdGhpcy5lZ2NkKG51bSkuYS51bW9kKG51bSk7XG5cdCAgfTtcblxuXHQgIEJOLnByb3RvdHlwZS5pc0V2ZW4gPSBmdW5jdGlvbiBpc0V2ZW4gKCkge1xuXHQgICAgcmV0dXJuICh0aGlzLndvcmRzWzBdICYgMSkgPT09IDA7XG5cdCAgfTtcblxuXHQgIEJOLnByb3RvdHlwZS5pc09kZCA9IGZ1bmN0aW9uIGlzT2RkICgpIHtcblx0ICAgIHJldHVybiAodGhpcy53b3Jkc1swXSAmIDEpID09PSAxO1xuXHQgIH07XG5cblx0ICAvLyBBbmQgZmlyc3Qgd29yZCBhbmQgbnVtXG5cdCAgQk4ucHJvdG90eXBlLmFuZGxuID0gZnVuY3Rpb24gYW5kbG4gKG51bSkge1xuXHQgICAgcmV0dXJuIHRoaXMud29yZHNbMF0gJiBudW07XG5cdCAgfTtcblxuXHQgIC8vIEluY3JlbWVudCBhdCB0aGUgYml0IHBvc2l0aW9uIGluLWxpbmVcblx0ICBCTi5wcm90b3R5cGUuYmluY24gPSBmdW5jdGlvbiBiaW5jbiAoYml0KSB7XG5cdCAgICBhc3NlcnQodHlwZW9mIGJpdCA9PT0gJ251bWJlcicpO1xuXHQgICAgdmFyIHIgPSBiaXQgJSAyNjtcblx0ICAgIHZhciBzID0gKGJpdCAtIHIpIC8gMjY7XG5cdCAgICB2YXIgcSA9IDEgPDwgcjtcblxuXHQgICAgLy8gRmFzdCBjYXNlOiBiaXQgaXMgbXVjaCBoaWdoZXIgdGhhbiBhbGwgZXhpc3Rpbmcgd29yZHNcblx0ICAgIGlmICh0aGlzLmxlbmd0aCA8PSBzKSB7XG5cdCAgICAgIHRoaXMuX2V4cGFuZChzICsgMSk7XG5cdCAgICAgIHRoaXMud29yZHNbc10gfD0gcTtcblx0ICAgICAgcmV0dXJuIHRoaXM7XG5cdCAgICB9XG5cblx0ICAgIC8vIEFkZCBiaXQgYW5kIHByb3BhZ2F0ZSwgaWYgbmVlZGVkXG5cdCAgICB2YXIgY2FycnkgPSBxO1xuXHQgICAgZm9yICh2YXIgaSA9IHM7IGNhcnJ5ICE9PSAwICYmIGkgPCB0aGlzLmxlbmd0aDsgaSsrKSB7XG5cdCAgICAgIHZhciB3ID0gdGhpcy53b3Jkc1tpXSB8IDA7XG5cdCAgICAgIHcgKz0gY2Fycnk7XG5cdCAgICAgIGNhcnJ5ID0gdyA+Pj4gMjY7XG5cdCAgICAgIHcgJj0gMHgzZmZmZmZmO1xuXHQgICAgICB0aGlzLndvcmRzW2ldID0gdztcblx0ICAgIH1cblx0ICAgIGlmIChjYXJyeSAhPT0gMCkge1xuXHQgICAgICB0aGlzLndvcmRzW2ldID0gY2Fycnk7XG5cdCAgICAgIHRoaXMubGVuZ3RoKys7XG5cdCAgICB9XG5cdCAgICByZXR1cm4gdGhpcztcblx0ICB9O1xuXG5cdCAgQk4ucHJvdG90eXBlLmlzWmVybyA9IGZ1bmN0aW9uIGlzWmVybyAoKSB7XG5cdCAgICByZXR1cm4gdGhpcy5sZW5ndGggPT09IDEgJiYgdGhpcy53b3Jkc1swXSA9PT0gMDtcblx0ICB9O1xuXG5cdCAgQk4ucHJvdG90eXBlLmNtcG4gPSBmdW5jdGlvbiBjbXBuIChudW0pIHtcblx0ICAgIHZhciBuZWdhdGl2ZSA9IG51bSA8IDA7XG5cblx0ICAgIGlmICh0aGlzLm5lZ2F0aXZlICE9PSAwICYmICFuZWdhdGl2ZSkgcmV0dXJuIC0xO1xuXHQgICAgaWYgKHRoaXMubmVnYXRpdmUgPT09IDAgJiYgbmVnYXRpdmUpIHJldHVybiAxO1xuXG5cdCAgICB0aGlzLnN0cmlwKCk7XG5cblx0ICAgIHZhciByZXM7XG5cdCAgICBpZiAodGhpcy5sZW5ndGggPiAxKSB7XG5cdCAgICAgIHJlcyA9IDE7XG5cdCAgICB9IGVsc2Uge1xuXHQgICAgICBpZiAobmVnYXRpdmUpIHtcblx0ICAgICAgICBudW0gPSAtbnVtO1xuXHQgICAgICB9XG5cblx0ICAgICAgYXNzZXJ0KG51bSA8PSAweDNmZmZmZmYsICdOdW1iZXIgaXMgdG9vIGJpZycpO1xuXG5cdCAgICAgIHZhciB3ID0gdGhpcy53b3Jkc1swXSB8IDA7XG5cdCAgICAgIHJlcyA9IHcgPT09IG51bSA/IDAgOiB3IDwgbnVtID8gLTEgOiAxO1xuXHQgICAgfVxuXHQgICAgaWYgKHRoaXMubmVnYXRpdmUgIT09IDApIHJldHVybiAtcmVzIHwgMDtcblx0ICAgIHJldHVybiByZXM7XG5cdCAgfTtcblxuXHQgIC8vIENvbXBhcmUgdHdvIG51bWJlcnMgYW5kIHJldHVybjpcblx0ICAvLyAxIC0gaWYgYHRoaXNgID4gYG51bWBcblx0ICAvLyAwIC0gaWYgYHRoaXNgID09IGBudW1gXG5cdCAgLy8gLTEgLSBpZiBgdGhpc2AgPCBgbnVtYFxuXHQgIEJOLnByb3RvdHlwZS5jbXAgPSBmdW5jdGlvbiBjbXAgKG51bSkge1xuXHQgICAgaWYgKHRoaXMubmVnYXRpdmUgIT09IDAgJiYgbnVtLm5lZ2F0aXZlID09PSAwKSByZXR1cm4gLTE7XG5cdCAgICBpZiAodGhpcy5uZWdhdGl2ZSA9PT0gMCAmJiBudW0ubmVnYXRpdmUgIT09IDApIHJldHVybiAxO1xuXG5cdCAgICB2YXIgcmVzID0gdGhpcy51Y21wKG51bSk7XG5cdCAgICBpZiAodGhpcy5uZWdhdGl2ZSAhPT0gMCkgcmV0dXJuIC1yZXMgfCAwO1xuXHQgICAgcmV0dXJuIHJlcztcblx0ICB9O1xuXG5cdCAgLy8gVW5zaWduZWQgY29tcGFyaXNvblxuXHQgIEJOLnByb3RvdHlwZS51Y21wID0gZnVuY3Rpb24gdWNtcCAobnVtKSB7XG5cdCAgICAvLyBBdCB0aGlzIHBvaW50IGJvdGggbnVtYmVycyBoYXZlIHRoZSBzYW1lIHNpZ25cblx0ICAgIGlmICh0aGlzLmxlbmd0aCA+IG51bS5sZW5ndGgpIHJldHVybiAxO1xuXHQgICAgaWYgKHRoaXMubGVuZ3RoIDwgbnVtLmxlbmd0aCkgcmV0dXJuIC0xO1xuXG5cdCAgICB2YXIgcmVzID0gMDtcblx0ICAgIGZvciAodmFyIGkgPSB0aGlzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG5cdCAgICAgIHZhciBhID0gdGhpcy53b3Jkc1tpXSB8IDA7XG5cdCAgICAgIHZhciBiID0gbnVtLndvcmRzW2ldIHwgMDtcblxuXHQgICAgICBpZiAoYSA9PT0gYikgY29udGludWU7XG5cdCAgICAgIGlmIChhIDwgYikge1xuXHQgICAgICAgIHJlcyA9IC0xO1xuXHQgICAgICB9IGVsc2UgaWYgKGEgPiBiKSB7XG5cdCAgICAgICAgcmVzID0gMTtcblx0ICAgICAgfVxuXHQgICAgICBicmVhaztcblx0ICAgIH1cblx0ICAgIHJldHVybiByZXM7XG5cdCAgfTtcblxuXHQgIEJOLnByb3RvdHlwZS5ndG4gPSBmdW5jdGlvbiBndG4gKG51bSkge1xuXHQgICAgcmV0dXJuIHRoaXMuY21wbihudW0pID09PSAxO1xuXHQgIH07XG5cblx0ICBCTi5wcm90b3R5cGUuZ3QgPSBmdW5jdGlvbiBndCAobnVtKSB7XG5cdCAgICByZXR1cm4gdGhpcy5jbXAobnVtKSA9PT0gMTtcblx0ICB9O1xuXG5cdCAgQk4ucHJvdG90eXBlLmd0ZW4gPSBmdW5jdGlvbiBndGVuIChudW0pIHtcblx0ICAgIHJldHVybiB0aGlzLmNtcG4obnVtKSA+PSAwO1xuXHQgIH07XG5cblx0ICBCTi5wcm90b3R5cGUuZ3RlID0gZnVuY3Rpb24gZ3RlIChudW0pIHtcblx0ICAgIHJldHVybiB0aGlzLmNtcChudW0pID49IDA7XG5cdCAgfTtcblxuXHQgIEJOLnByb3RvdHlwZS5sdG4gPSBmdW5jdGlvbiBsdG4gKG51bSkge1xuXHQgICAgcmV0dXJuIHRoaXMuY21wbihudW0pID09PSAtMTtcblx0ICB9O1xuXG5cdCAgQk4ucHJvdG90eXBlLmx0ID0gZnVuY3Rpb24gbHQgKG51bSkge1xuXHQgICAgcmV0dXJuIHRoaXMuY21wKG51bSkgPT09IC0xO1xuXHQgIH07XG5cblx0ICBCTi5wcm90b3R5cGUubHRlbiA9IGZ1bmN0aW9uIGx0ZW4gKG51bSkge1xuXHQgICAgcmV0dXJuIHRoaXMuY21wbihudW0pIDw9IDA7XG5cdCAgfTtcblxuXHQgIEJOLnByb3RvdHlwZS5sdGUgPSBmdW5jdGlvbiBsdGUgKG51bSkge1xuXHQgICAgcmV0dXJuIHRoaXMuY21wKG51bSkgPD0gMDtcblx0ICB9O1xuXG5cdCAgQk4ucHJvdG90eXBlLmVxbiA9IGZ1bmN0aW9uIGVxbiAobnVtKSB7XG5cdCAgICByZXR1cm4gdGhpcy5jbXBuKG51bSkgPT09IDA7XG5cdCAgfTtcblxuXHQgIEJOLnByb3RvdHlwZS5lcSA9IGZ1bmN0aW9uIGVxIChudW0pIHtcblx0ICAgIHJldHVybiB0aGlzLmNtcChudW0pID09PSAwO1xuXHQgIH07XG5cblx0ICAvL1xuXHQgIC8vIEEgcmVkdWNlIGNvbnRleHQsIGNvdWxkIGJlIHVzaW5nIG1vbnRnb21lcnkgb3Igc29tZXRoaW5nIGJldHRlciwgZGVwZW5kaW5nXG5cdCAgLy8gb24gdGhlIGBtYCBpdHNlbGYuXG5cdCAgLy9cblx0ICBCTi5yZWQgPSBmdW5jdGlvbiByZWQgKG51bSkge1xuXHQgICAgcmV0dXJuIG5ldyBSZWQobnVtKTtcblx0ICB9O1xuXG5cdCAgQk4ucHJvdG90eXBlLnRvUmVkID0gZnVuY3Rpb24gdG9SZWQgKGN0eCkge1xuXHQgICAgYXNzZXJ0KCF0aGlzLnJlZCwgJ0FscmVhZHkgYSBudW1iZXIgaW4gcmVkdWN0aW9uIGNvbnRleHQnKTtcblx0ICAgIGFzc2VydCh0aGlzLm5lZ2F0aXZlID09PSAwLCAncmVkIHdvcmtzIG9ubHkgd2l0aCBwb3NpdGl2ZXMnKTtcblx0ICAgIHJldHVybiBjdHguY29udmVydFRvKHRoaXMpLl9mb3JjZVJlZChjdHgpO1xuXHQgIH07XG5cblx0ICBCTi5wcm90b3R5cGUuZnJvbVJlZCA9IGZ1bmN0aW9uIGZyb21SZWQgKCkge1xuXHQgICAgYXNzZXJ0KHRoaXMucmVkLCAnZnJvbVJlZCB3b3JrcyBvbmx5IHdpdGggbnVtYmVycyBpbiByZWR1Y3Rpb24gY29udGV4dCcpO1xuXHQgICAgcmV0dXJuIHRoaXMucmVkLmNvbnZlcnRGcm9tKHRoaXMpO1xuXHQgIH07XG5cblx0ICBCTi5wcm90b3R5cGUuX2ZvcmNlUmVkID0gZnVuY3Rpb24gX2ZvcmNlUmVkIChjdHgpIHtcblx0ICAgIHRoaXMucmVkID0gY3R4O1xuXHQgICAgcmV0dXJuIHRoaXM7XG5cdCAgfTtcblxuXHQgIEJOLnByb3RvdHlwZS5mb3JjZVJlZCA9IGZ1bmN0aW9uIGZvcmNlUmVkIChjdHgpIHtcblx0ICAgIGFzc2VydCghdGhpcy5yZWQsICdBbHJlYWR5IGEgbnVtYmVyIGluIHJlZHVjdGlvbiBjb250ZXh0Jyk7XG5cdCAgICByZXR1cm4gdGhpcy5fZm9yY2VSZWQoY3R4KTtcblx0ICB9O1xuXG5cdCAgQk4ucHJvdG90eXBlLnJlZEFkZCA9IGZ1bmN0aW9uIHJlZEFkZCAobnVtKSB7XG5cdCAgICBhc3NlcnQodGhpcy5yZWQsICdyZWRBZGQgd29ya3Mgb25seSB3aXRoIHJlZCBudW1iZXJzJyk7XG5cdCAgICByZXR1cm4gdGhpcy5yZWQuYWRkKHRoaXMsIG51bSk7XG5cdCAgfTtcblxuXHQgIEJOLnByb3RvdHlwZS5yZWRJQWRkID0gZnVuY3Rpb24gcmVkSUFkZCAobnVtKSB7XG5cdCAgICBhc3NlcnQodGhpcy5yZWQsICdyZWRJQWRkIHdvcmtzIG9ubHkgd2l0aCByZWQgbnVtYmVycycpO1xuXHQgICAgcmV0dXJuIHRoaXMucmVkLmlhZGQodGhpcywgbnVtKTtcblx0ICB9O1xuXG5cdCAgQk4ucHJvdG90eXBlLnJlZFN1YiA9IGZ1bmN0aW9uIHJlZFN1YiAobnVtKSB7XG5cdCAgICBhc3NlcnQodGhpcy5yZWQsICdyZWRTdWIgd29ya3Mgb25seSB3aXRoIHJlZCBudW1iZXJzJyk7XG5cdCAgICByZXR1cm4gdGhpcy5yZWQuc3ViKHRoaXMsIG51bSk7XG5cdCAgfTtcblxuXHQgIEJOLnByb3RvdHlwZS5yZWRJU3ViID0gZnVuY3Rpb24gcmVkSVN1YiAobnVtKSB7XG5cdCAgICBhc3NlcnQodGhpcy5yZWQsICdyZWRJU3ViIHdvcmtzIG9ubHkgd2l0aCByZWQgbnVtYmVycycpO1xuXHQgICAgcmV0dXJuIHRoaXMucmVkLmlzdWIodGhpcywgbnVtKTtcblx0ICB9O1xuXG5cdCAgQk4ucHJvdG90eXBlLnJlZFNobCA9IGZ1bmN0aW9uIHJlZFNobCAobnVtKSB7XG5cdCAgICBhc3NlcnQodGhpcy5yZWQsICdyZWRTaGwgd29ya3Mgb25seSB3aXRoIHJlZCBudW1iZXJzJyk7XG5cdCAgICByZXR1cm4gdGhpcy5yZWQuc2hsKHRoaXMsIG51bSk7XG5cdCAgfTtcblxuXHQgIEJOLnByb3RvdHlwZS5yZWRNdWwgPSBmdW5jdGlvbiByZWRNdWwgKG51bSkge1xuXHQgICAgYXNzZXJ0KHRoaXMucmVkLCAncmVkTXVsIHdvcmtzIG9ubHkgd2l0aCByZWQgbnVtYmVycycpO1xuXHQgICAgdGhpcy5yZWQuX3ZlcmlmeTIodGhpcywgbnVtKTtcblx0ICAgIHJldHVybiB0aGlzLnJlZC5tdWwodGhpcywgbnVtKTtcblx0ICB9O1xuXG5cdCAgQk4ucHJvdG90eXBlLnJlZElNdWwgPSBmdW5jdGlvbiByZWRJTXVsIChudW0pIHtcblx0ICAgIGFzc2VydCh0aGlzLnJlZCwgJ3JlZE11bCB3b3JrcyBvbmx5IHdpdGggcmVkIG51bWJlcnMnKTtcblx0ICAgIHRoaXMucmVkLl92ZXJpZnkyKHRoaXMsIG51bSk7XG5cdCAgICByZXR1cm4gdGhpcy5yZWQuaW11bCh0aGlzLCBudW0pO1xuXHQgIH07XG5cblx0ICBCTi5wcm90b3R5cGUucmVkU3FyID0gZnVuY3Rpb24gcmVkU3FyICgpIHtcblx0ICAgIGFzc2VydCh0aGlzLnJlZCwgJ3JlZFNxciB3b3JrcyBvbmx5IHdpdGggcmVkIG51bWJlcnMnKTtcblx0ICAgIHRoaXMucmVkLl92ZXJpZnkxKHRoaXMpO1xuXHQgICAgcmV0dXJuIHRoaXMucmVkLnNxcih0aGlzKTtcblx0ICB9O1xuXG5cdCAgQk4ucHJvdG90eXBlLnJlZElTcXIgPSBmdW5jdGlvbiByZWRJU3FyICgpIHtcblx0ICAgIGFzc2VydCh0aGlzLnJlZCwgJ3JlZElTcXIgd29ya3Mgb25seSB3aXRoIHJlZCBudW1iZXJzJyk7XG5cdCAgICB0aGlzLnJlZC5fdmVyaWZ5MSh0aGlzKTtcblx0ICAgIHJldHVybiB0aGlzLnJlZC5pc3FyKHRoaXMpO1xuXHQgIH07XG5cblx0ICAvLyBTcXVhcmUgcm9vdCBvdmVyIHBcblx0ICBCTi5wcm90b3R5cGUucmVkU3FydCA9IGZ1bmN0aW9uIHJlZFNxcnQgKCkge1xuXHQgICAgYXNzZXJ0KHRoaXMucmVkLCAncmVkU3FydCB3b3JrcyBvbmx5IHdpdGggcmVkIG51bWJlcnMnKTtcblx0ICAgIHRoaXMucmVkLl92ZXJpZnkxKHRoaXMpO1xuXHQgICAgcmV0dXJuIHRoaXMucmVkLnNxcnQodGhpcyk7XG5cdCAgfTtcblxuXHQgIEJOLnByb3RvdHlwZS5yZWRJbnZtID0gZnVuY3Rpb24gcmVkSW52bSAoKSB7XG5cdCAgICBhc3NlcnQodGhpcy5yZWQsICdyZWRJbnZtIHdvcmtzIG9ubHkgd2l0aCByZWQgbnVtYmVycycpO1xuXHQgICAgdGhpcy5yZWQuX3ZlcmlmeTEodGhpcyk7XG5cdCAgICByZXR1cm4gdGhpcy5yZWQuaW52bSh0aGlzKTtcblx0ICB9O1xuXG5cdCAgLy8gUmV0dXJuIG5lZ2F0aXZlIGNsb25lIG9mIGB0aGlzYCAlIGByZWQgbW9kdWxvYFxuXHQgIEJOLnByb3RvdHlwZS5yZWROZWcgPSBmdW5jdGlvbiByZWROZWcgKCkge1xuXHQgICAgYXNzZXJ0KHRoaXMucmVkLCAncmVkTmVnIHdvcmtzIG9ubHkgd2l0aCByZWQgbnVtYmVycycpO1xuXHQgICAgdGhpcy5yZWQuX3ZlcmlmeTEodGhpcyk7XG5cdCAgICByZXR1cm4gdGhpcy5yZWQubmVnKHRoaXMpO1xuXHQgIH07XG5cblx0ICBCTi5wcm90b3R5cGUucmVkUG93ID0gZnVuY3Rpb24gcmVkUG93IChudW0pIHtcblx0ICAgIGFzc2VydCh0aGlzLnJlZCAmJiAhbnVtLnJlZCwgJ3JlZFBvdyhub3JtYWxOdW0pJyk7XG5cdCAgICB0aGlzLnJlZC5fdmVyaWZ5MSh0aGlzKTtcblx0ICAgIHJldHVybiB0aGlzLnJlZC5wb3codGhpcywgbnVtKTtcblx0ICB9O1xuXG5cdCAgLy8gUHJpbWUgbnVtYmVycyB3aXRoIGVmZmljaWVudCByZWR1Y3Rpb25cblx0ICB2YXIgcHJpbWVzID0ge1xuXHQgICAgazI1NjogbnVsbCxcblx0ICAgIHAyMjQ6IG51bGwsXG5cdCAgICBwMTkyOiBudWxsLFxuXHQgICAgcDI1NTE5OiBudWxsXG5cdCAgfTtcblxuXHQgIC8vIFBzZXVkby1NZXJzZW5uZSBwcmltZVxuXHQgIGZ1bmN0aW9uIE1QcmltZSAobmFtZSwgcCkge1xuXHQgICAgLy8gUCA9IDIgXiBOIC0gS1xuXHQgICAgdGhpcy5uYW1lID0gbmFtZTtcblx0ICAgIHRoaXMucCA9IG5ldyBCTihwLCAxNik7XG5cdCAgICB0aGlzLm4gPSB0aGlzLnAuYml0TGVuZ3RoKCk7XG5cdCAgICB0aGlzLmsgPSBuZXcgQk4oMSkuaXVzaGxuKHRoaXMubikuaXN1Yih0aGlzLnApO1xuXG5cdCAgICB0aGlzLnRtcCA9IHRoaXMuX3RtcCgpO1xuXHQgIH1cblxuXHQgIE1QcmltZS5wcm90b3R5cGUuX3RtcCA9IGZ1bmN0aW9uIF90bXAgKCkge1xuXHQgICAgdmFyIHRtcCA9IG5ldyBCTihudWxsKTtcblx0ICAgIHRtcC53b3JkcyA9IG5ldyBBcnJheShNYXRoLmNlaWwodGhpcy5uIC8gMTMpKTtcblx0ICAgIHJldHVybiB0bXA7XG5cdCAgfTtcblxuXHQgIE1QcmltZS5wcm90b3R5cGUuaXJlZHVjZSA9IGZ1bmN0aW9uIGlyZWR1Y2UgKG51bSkge1xuXHQgICAgLy8gQXNzdW1lcyB0aGF0IGBudW1gIGlzIGxlc3MgdGhhbiBgUF4yYFxuXHQgICAgLy8gbnVtID0gSEkgKiAoMiBeIE4gLSBLKSArIEhJICogSyArIExPID0gSEkgKiBLICsgTE8gKG1vZCBQKVxuXHQgICAgdmFyIHIgPSBudW07XG5cdCAgICB2YXIgcmxlbjtcblxuXHQgICAgZG8ge1xuXHQgICAgICB0aGlzLnNwbGl0KHIsIHRoaXMudG1wKTtcblx0ICAgICAgciA9IHRoaXMuaW11bEsocik7XG5cdCAgICAgIHIgPSByLmlhZGQodGhpcy50bXApO1xuXHQgICAgICBybGVuID0gci5iaXRMZW5ndGgoKTtcblx0ICAgIH0gd2hpbGUgKHJsZW4gPiB0aGlzLm4pO1xuXG5cdCAgICB2YXIgY21wID0gcmxlbiA8IHRoaXMubiA/IC0xIDogci51Y21wKHRoaXMucCk7XG5cdCAgICBpZiAoY21wID09PSAwKSB7XG5cdCAgICAgIHIud29yZHNbMF0gPSAwO1xuXHQgICAgICByLmxlbmd0aCA9IDE7XG5cdCAgICB9IGVsc2UgaWYgKGNtcCA+IDApIHtcblx0ICAgICAgci5pc3ViKHRoaXMucCk7XG5cdCAgICB9IGVsc2Uge1xuXHQgICAgICBpZiAoci5zdHJpcCAhPT0gdW5kZWZpbmVkKSB7XG5cdCAgICAgICAgLy8gciBpcyBCTiB2NCBpbnN0YW5jZVxuXHQgICAgICAgIHIuc3RyaXAoKTtcblx0ICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAvLyByIGlzIEJOIHY1IGluc3RhbmNlXG5cdCAgICAgICAgci5fc3RyaXAoKTtcblx0ICAgICAgfVxuXHQgICAgfVxuXG5cdCAgICByZXR1cm4gcjtcblx0ICB9O1xuXG5cdCAgTVByaW1lLnByb3RvdHlwZS5zcGxpdCA9IGZ1bmN0aW9uIHNwbGl0IChpbnB1dCwgb3V0KSB7XG5cdCAgICBpbnB1dC5pdXNocm4odGhpcy5uLCAwLCBvdXQpO1xuXHQgIH07XG5cblx0ICBNUHJpbWUucHJvdG90eXBlLmltdWxLID0gZnVuY3Rpb24gaW11bEsgKG51bSkge1xuXHQgICAgcmV0dXJuIG51bS5pbXVsKHRoaXMuayk7XG5cdCAgfTtcblxuXHQgIGZ1bmN0aW9uIEsyNTYgKCkge1xuXHQgICAgTVByaW1lLmNhbGwoXG5cdCAgICAgIHRoaXMsXG5cdCAgICAgICdrMjU2Jyxcblx0ICAgICAgJ2ZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZlIGZmZmZmYzJmJyk7XG5cdCAgfVxuXHQgIGluaGVyaXRzKEsyNTYsIE1QcmltZSk7XG5cblx0ICBLMjU2LnByb3RvdHlwZS5zcGxpdCA9IGZ1bmN0aW9uIHNwbGl0IChpbnB1dCwgb3V0cHV0KSB7XG5cdCAgICAvLyAyNTYgPSA5ICogMjYgKyAyMlxuXHQgICAgdmFyIG1hc2sgPSAweDNmZmZmZjtcblxuXHQgICAgdmFyIG91dExlbiA9IE1hdGgubWluKGlucHV0Lmxlbmd0aCwgOSk7XG5cdCAgICBmb3IgKHZhciBpID0gMDsgaSA8IG91dExlbjsgaSsrKSB7XG5cdCAgICAgIG91dHB1dC53b3Jkc1tpXSA9IGlucHV0LndvcmRzW2ldO1xuXHQgICAgfVxuXHQgICAgb3V0cHV0Lmxlbmd0aCA9IG91dExlbjtcblxuXHQgICAgaWYgKGlucHV0Lmxlbmd0aCA8PSA5KSB7XG5cdCAgICAgIGlucHV0LndvcmRzWzBdID0gMDtcblx0ICAgICAgaW5wdXQubGVuZ3RoID0gMTtcblx0ICAgICAgcmV0dXJuO1xuXHQgICAgfVxuXG5cdCAgICAvLyBTaGlmdCBieSA5IGxpbWJzXG5cdCAgICB2YXIgcHJldiA9IGlucHV0LndvcmRzWzldO1xuXHQgICAgb3V0cHV0LndvcmRzW291dHB1dC5sZW5ndGgrK10gPSBwcmV2ICYgbWFzaztcblxuXHQgICAgZm9yIChpID0gMTA7IGkgPCBpbnB1dC5sZW5ndGg7IGkrKykge1xuXHQgICAgICB2YXIgbmV4dCA9IGlucHV0LndvcmRzW2ldIHwgMDtcblx0ICAgICAgaW5wdXQud29yZHNbaSAtIDEwXSA9ICgobmV4dCAmIG1hc2spIDw8IDQpIHwgKHByZXYgPj4+IDIyKTtcblx0ICAgICAgcHJldiA9IG5leHQ7XG5cdCAgICB9XG5cdCAgICBwcmV2ID4+Pj0gMjI7XG5cdCAgICBpbnB1dC53b3Jkc1tpIC0gMTBdID0gcHJldjtcblx0ICAgIGlmIChwcmV2ID09PSAwICYmIGlucHV0Lmxlbmd0aCA+IDEwKSB7XG5cdCAgICAgIGlucHV0Lmxlbmd0aCAtPSAxMDtcblx0ICAgIH0gZWxzZSB7XG5cdCAgICAgIGlucHV0Lmxlbmd0aCAtPSA5O1xuXHQgICAgfVxuXHQgIH07XG5cblx0ICBLMjU2LnByb3RvdHlwZS5pbXVsSyA9IGZ1bmN0aW9uIGltdWxLIChudW0pIHtcblx0ICAgIC8vIEsgPSAweDEwMDAwMDNkMSA9IFsgMHg0MCwgMHgzZDEgXVxuXHQgICAgbnVtLndvcmRzW251bS5sZW5ndGhdID0gMDtcblx0ICAgIG51bS53b3Jkc1tudW0ubGVuZ3RoICsgMV0gPSAwO1xuXHQgICAgbnVtLmxlbmd0aCArPSAyO1xuXG5cdCAgICAvLyBib3VuZGVkIGF0OiAweDQwICogMHgzZmZmZmZmICsgMHgzZDAgPSAweDEwMDAwMDM5MFxuXHQgICAgdmFyIGxvID0gMDtcblx0ICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbnVtLmxlbmd0aDsgaSsrKSB7XG5cdCAgICAgIHZhciB3ID0gbnVtLndvcmRzW2ldIHwgMDtcblx0ICAgICAgbG8gKz0gdyAqIDB4M2QxO1xuXHQgICAgICBudW0ud29yZHNbaV0gPSBsbyAmIDB4M2ZmZmZmZjtcblx0ICAgICAgbG8gPSB3ICogMHg0MCArICgobG8gLyAweDQwMDAwMDApIHwgMCk7XG5cdCAgICB9XG5cblx0ICAgIC8vIEZhc3QgbGVuZ3RoIHJlZHVjdGlvblxuXHQgICAgaWYgKG51bS53b3Jkc1tudW0ubGVuZ3RoIC0gMV0gPT09IDApIHtcblx0ICAgICAgbnVtLmxlbmd0aC0tO1xuXHQgICAgICBpZiAobnVtLndvcmRzW251bS5sZW5ndGggLSAxXSA9PT0gMCkge1xuXHQgICAgICAgIG51bS5sZW5ndGgtLTtcblx0ICAgICAgfVxuXHQgICAgfVxuXHQgICAgcmV0dXJuIG51bTtcblx0ICB9O1xuXG5cdCAgZnVuY3Rpb24gUDIyNCAoKSB7XG5cdCAgICBNUHJpbWUuY2FsbChcblx0ICAgICAgdGhpcyxcblx0ICAgICAgJ3AyMjQnLFxuXHQgICAgICAnZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgMDAwMDAwMDAgMDAwMDAwMDAgMDAwMDAwMDEnKTtcblx0ICB9XG5cdCAgaW5oZXJpdHMoUDIyNCwgTVByaW1lKTtcblxuXHQgIGZ1bmN0aW9uIFAxOTIgKCkge1xuXHQgICAgTVByaW1lLmNhbGwoXG5cdCAgICAgIHRoaXMsXG5cdCAgICAgICdwMTkyJyxcblx0ICAgICAgJ2ZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZlIGZmZmZmZmZmIGZmZmZmZmZmJyk7XG5cdCAgfVxuXHQgIGluaGVyaXRzKFAxOTIsIE1QcmltZSk7XG5cblx0ICBmdW5jdGlvbiBQMjU1MTkgKCkge1xuXHQgICAgLy8gMiBeIDI1NSAtIDE5XG5cdCAgICBNUHJpbWUuY2FsbChcblx0ICAgICAgdGhpcyxcblx0ICAgICAgJzI1NTE5Jyxcblx0ICAgICAgJzdmZmZmZmZmZmZmZmZmZmYgZmZmZmZmZmZmZmZmZmZmZiBmZmZmZmZmZmZmZmZmZmZmIGZmZmZmZmZmZmZmZmZmZWQnKTtcblx0ICB9XG5cdCAgaW5oZXJpdHMoUDI1NTE5LCBNUHJpbWUpO1xuXG5cdCAgUDI1NTE5LnByb3RvdHlwZS5pbXVsSyA9IGZ1bmN0aW9uIGltdWxLIChudW0pIHtcblx0ICAgIC8vIEsgPSAweDEzXG5cdCAgICB2YXIgY2FycnkgPSAwO1xuXHQgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBudW0ubGVuZ3RoOyBpKyspIHtcblx0ICAgICAgdmFyIGhpID0gKG51bS53b3Jkc1tpXSB8IDApICogMHgxMyArIGNhcnJ5O1xuXHQgICAgICB2YXIgbG8gPSBoaSAmIDB4M2ZmZmZmZjtcblx0ICAgICAgaGkgPj4+PSAyNjtcblxuXHQgICAgICBudW0ud29yZHNbaV0gPSBsbztcblx0ICAgICAgY2FycnkgPSBoaTtcblx0ICAgIH1cblx0ICAgIGlmIChjYXJyeSAhPT0gMCkge1xuXHQgICAgICBudW0ud29yZHNbbnVtLmxlbmd0aCsrXSA9IGNhcnJ5O1xuXHQgICAgfVxuXHQgICAgcmV0dXJuIG51bTtcblx0ICB9O1xuXG5cdCAgLy8gRXhwb3J0ZWQgbW9zdGx5IGZvciB0ZXN0aW5nIHB1cnBvc2VzLCB1c2UgcGxhaW4gbmFtZSBpbnN0ZWFkXG5cdCAgQk4uX3ByaW1lID0gZnVuY3Rpb24gcHJpbWUgKG5hbWUpIHtcblx0ICAgIC8vIENhY2hlZCB2ZXJzaW9uIG9mIHByaW1lXG5cdCAgICBpZiAocHJpbWVzW25hbWVdKSByZXR1cm4gcHJpbWVzW25hbWVdO1xuXG5cdCAgICB2YXIgcHJpbWU7XG5cdCAgICBpZiAobmFtZSA9PT0gJ2syNTYnKSB7XG5cdCAgICAgIHByaW1lID0gbmV3IEsyNTYoKTtcblx0ICAgIH0gZWxzZSBpZiAobmFtZSA9PT0gJ3AyMjQnKSB7XG5cdCAgICAgIHByaW1lID0gbmV3IFAyMjQoKTtcblx0ICAgIH0gZWxzZSBpZiAobmFtZSA9PT0gJ3AxOTInKSB7XG5cdCAgICAgIHByaW1lID0gbmV3IFAxOTIoKTtcblx0ICAgIH0gZWxzZSBpZiAobmFtZSA9PT0gJ3AyNTUxOScpIHtcblx0ICAgICAgcHJpbWUgPSBuZXcgUDI1NTE5KCk7XG5cdCAgICB9IGVsc2Uge1xuXHQgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vua25vd24gcHJpbWUgJyArIG5hbWUpO1xuXHQgICAgfVxuXHQgICAgcHJpbWVzW25hbWVdID0gcHJpbWU7XG5cblx0ICAgIHJldHVybiBwcmltZTtcblx0ICB9O1xuXG5cdCAgLy9cblx0ICAvLyBCYXNlIHJlZHVjdGlvbiBlbmdpbmVcblx0ICAvL1xuXHQgIGZ1bmN0aW9uIFJlZCAobSkge1xuXHQgICAgaWYgKHR5cGVvZiBtID09PSAnc3RyaW5nJykge1xuXHQgICAgICB2YXIgcHJpbWUgPSBCTi5fcHJpbWUobSk7XG5cdCAgICAgIHRoaXMubSA9IHByaW1lLnA7XG5cdCAgICAgIHRoaXMucHJpbWUgPSBwcmltZTtcblx0ICAgIH0gZWxzZSB7XG5cdCAgICAgIGFzc2VydChtLmd0bigxKSwgJ21vZHVsdXMgbXVzdCBiZSBncmVhdGVyIHRoYW4gMScpO1xuXHQgICAgICB0aGlzLm0gPSBtO1xuXHQgICAgICB0aGlzLnByaW1lID0gbnVsbDtcblx0ICAgIH1cblx0ICB9XG5cblx0ICBSZWQucHJvdG90eXBlLl92ZXJpZnkxID0gZnVuY3Rpb24gX3ZlcmlmeTEgKGEpIHtcblx0ICAgIGFzc2VydChhLm5lZ2F0aXZlID09PSAwLCAncmVkIHdvcmtzIG9ubHkgd2l0aCBwb3NpdGl2ZXMnKTtcblx0ICAgIGFzc2VydChhLnJlZCwgJ3JlZCB3b3JrcyBvbmx5IHdpdGggcmVkIG51bWJlcnMnKTtcblx0ICB9O1xuXG5cdCAgUmVkLnByb3RvdHlwZS5fdmVyaWZ5MiA9IGZ1bmN0aW9uIF92ZXJpZnkyIChhLCBiKSB7XG5cdCAgICBhc3NlcnQoKGEubmVnYXRpdmUgfCBiLm5lZ2F0aXZlKSA9PT0gMCwgJ3JlZCB3b3JrcyBvbmx5IHdpdGggcG9zaXRpdmVzJyk7XG5cdCAgICBhc3NlcnQoYS5yZWQgJiYgYS5yZWQgPT09IGIucmVkLFxuXHQgICAgICAncmVkIHdvcmtzIG9ubHkgd2l0aCByZWQgbnVtYmVycycpO1xuXHQgIH07XG5cblx0ICBSZWQucHJvdG90eXBlLmltb2QgPSBmdW5jdGlvbiBpbW9kIChhKSB7XG5cdCAgICBpZiAodGhpcy5wcmltZSkgcmV0dXJuIHRoaXMucHJpbWUuaXJlZHVjZShhKS5fZm9yY2VSZWQodGhpcyk7XG5cdCAgICByZXR1cm4gYS51bW9kKHRoaXMubSkuX2ZvcmNlUmVkKHRoaXMpO1xuXHQgIH07XG5cblx0ICBSZWQucHJvdG90eXBlLm5lZyA9IGZ1bmN0aW9uIG5lZyAoYSkge1xuXHQgICAgaWYgKGEuaXNaZXJvKCkpIHtcblx0ICAgICAgcmV0dXJuIGEuY2xvbmUoKTtcblx0ICAgIH1cblxuXHQgICAgcmV0dXJuIHRoaXMubS5zdWIoYSkuX2ZvcmNlUmVkKHRoaXMpO1xuXHQgIH07XG5cblx0ICBSZWQucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uIGFkZCAoYSwgYikge1xuXHQgICAgdGhpcy5fdmVyaWZ5MihhLCBiKTtcblxuXHQgICAgdmFyIHJlcyA9IGEuYWRkKGIpO1xuXHQgICAgaWYgKHJlcy5jbXAodGhpcy5tKSA+PSAwKSB7XG5cdCAgICAgIHJlcy5pc3ViKHRoaXMubSk7XG5cdCAgICB9XG5cdCAgICByZXR1cm4gcmVzLl9mb3JjZVJlZCh0aGlzKTtcblx0ICB9O1xuXG5cdCAgUmVkLnByb3RvdHlwZS5pYWRkID0gZnVuY3Rpb24gaWFkZCAoYSwgYikge1xuXHQgICAgdGhpcy5fdmVyaWZ5MihhLCBiKTtcblxuXHQgICAgdmFyIHJlcyA9IGEuaWFkZChiKTtcblx0ICAgIGlmIChyZXMuY21wKHRoaXMubSkgPj0gMCkge1xuXHQgICAgICByZXMuaXN1Yih0aGlzLm0pO1xuXHQgICAgfVxuXHQgICAgcmV0dXJuIHJlcztcblx0ICB9O1xuXG5cdCAgUmVkLnByb3RvdHlwZS5zdWIgPSBmdW5jdGlvbiBzdWIgKGEsIGIpIHtcblx0ICAgIHRoaXMuX3ZlcmlmeTIoYSwgYik7XG5cblx0ICAgIHZhciByZXMgPSBhLnN1YihiKTtcblx0ICAgIGlmIChyZXMuY21wbigwKSA8IDApIHtcblx0ICAgICAgcmVzLmlhZGQodGhpcy5tKTtcblx0ICAgIH1cblx0ICAgIHJldHVybiByZXMuX2ZvcmNlUmVkKHRoaXMpO1xuXHQgIH07XG5cblx0ICBSZWQucHJvdG90eXBlLmlzdWIgPSBmdW5jdGlvbiBpc3ViIChhLCBiKSB7XG5cdCAgICB0aGlzLl92ZXJpZnkyKGEsIGIpO1xuXG5cdCAgICB2YXIgcmVzID0gYS5pc3ViKGIpO1xuXHQgICAgaWYgKHJlcy5jbXBuKDApIDwgMCkge1xuXHQgICAgICByZXMuaWFkZCh0aGlzLm0pO1xuXHQgICAgfVxuXHQgICAgcmV0dXJuIHJlcztcblx0ICB9O1xuXG5cdCAgUmVkLnByb3RvdHlwZS5zaGwgPSBmdW5jdGlvbiBzaGwgKGEsIG51bSkge1xuXHQgICAgdGhpcy5fdmVyaWZ5MShhKTtcblx0ICAgIHJldHVybiB0aGlzLmltb2QoYS51c2hsbihudW0pKTtcblx0ICB9O1xuXG5cdCAgUmVkLnByb3RvdHlwZS5pbXVsID0gZnVuY3Rpb24gaW11bCAoYSwgYikge1xuXHQgICAgdGhpcy5fdmVyaWZ5MihhLCBiKTtcblx0ICAgIHJldHVybiB0aGlzLmltb2QoYS5pbXVsKGIpKTtcblx0ICB9O1xuXG5cdCAgUmVkLnByb3RvdHlwZS5tdWwgPSBmdW5jdGlvbiBtdWwgKGEsIGIpIHtcblx0ICAgIHRoaXMuX3ZlcmlmeTIoYSwgYik7XG5cdCAgICByZXR1cm4gdGhpcy5pbW9kKGEubXVsKGIpKTtcblx0ICB9O1xuXG5cdCAgUmVkLnByb3RvdHlwZS5pc3FyID0gZnVuY3Rpb24gaXNxciAoYSkge1xuXHQgICAgcmV0dXJuIHRoaXMuaW11bChhLCBhLmNsb25lKCkpO1xuXHQgIH07XG5cblx0ICBSZWQucHJvdG90eXBlLnNxciA9IGZ1bmN0aW9uIHNxciAoYSkge1xuXHQgICAgcmV0dXJuIHRoaXMubXVsKGEsIGEpO1xuXHQgIH07XG5cblx0ICBSZWQucHJvdG90eXBlLnNxcnQgPSBmdW5jdGlvbiBzcXJ0IChhKSB7XG5cdCAgICBpZiAoYS5pc1plcm8oKSkgcmV0dXJuIGEuY2xvbmUoKTtcblxuXHQgICAgdmFyIG1vZDMgPSB0aGlzLm0uYW5kbG4oMyk7XG5cdCAgICBhc3NlcnQobW9kMyAlIDIgPT09IDEpO1xuXG5cdCAgICAvLyBGYXN0IGNhc2Vcblx0ICAgIGlmIChtb2QzID09PSAzKSB7XG5cdCAgICAgIHZhciBwb3cgPSB0aGlzLm0uYWRkKG5ldyBCTigxKSkuaXVzaHJuKDIpO1xuXHQgICAgICByZXR1cm4gdGhpcy5wb3coYSwgcG93KTtcblx0ICAgIH1cblxuXHQgICAgLy8gVG9uZWxsaS1TaGFua3MgYWxnb3JpdGhtIChUb3RhbGx5IHVub3B0aW1pemVkIGFuZCBzbG93KVxuXHQgICAgLy9cblx0ICAgIC8vIEZpbmQgUSBhbmQgUywgdGhhdCBRICogMiBeIFMgPSAoUCAtIDEpXG5cdCAgICB2YXIgcSA9IHRoaXMubS5zdWJuKDEpO1xuXHQgICAgdmFyIHMgPSAwO1xuXHQgICAgd2hpbGUgKCFxLmlzWmVybygpICYmIHEuYW5kbG4oMSkgPT09IDApIHtcblx0ICAgICAgcysrO1xuXHQgICAgICBxLml1c2hybigxKTtcblx0ICAgIH1cblx0ICAgIGFzc2VydCghcS5pc1plcm8oKSk7XG5cblx0ICAgIHZhciBvbmUgPSBuZXcgQk4oMSkudG9SZWQodGhpcyk7XG5cdCAgICB2YXIgbk9uZSA9IG9uZS5yZWROZWcoKTtcblxuXHQgICAgLy8gRmluZCBxdWFkcmF0aWMgbm9uLXJlc2lkdWVcblx0ICAgIC8vIE5PVEU6IE1heCBpcyBzdWNoIGJlY2F1c2Ugb2YgZ2VuZXJhbGl6ZWQgUmllbWFubiBoeXBvdGhlc2lzLlxuXHQgICAgdmFyIGxwb3cgPSB0aGlzLm0uc3VibigxKS5pdXNocm4oMSk7XG5cdCAgICB2YXIgeiA9IHRoaXMubS5iaXRMZW5ndGgoKTtcblx0ICAgIHogPSBuZXcgQk4oMiAqIHogKiB6KS50b1JlZCh0aGlzKTtcblxuXHQgICAgd2hpbGUgKHRoaXMucG93KHosIGxwb3cpLmNtcChuT25lKSAhPT0gMCkge1xuXHQgICAgICB6LnJlZElBZGQobk9uZSk7XG5cdCAgICB9XG5cblx0ICAgIHZhciBjID0gdGhpcy5wb3coeiwgcSk7XG5cdCAgICB2YXIgciA9IHRoaXMucG93KGEsIHEuYWRkbigxKS5pdXNocm4oMSkpO1xuXHQgICAgdmFyIHQgPSB0aGlzLnBvdyhhLCBxKTtcblx0ICAgIHZhciBtID0gcztcblx0ICAgIHdoaWxlICh0LmNtcChvbmUpICE9PSAwKSB7XG5cdCAgICAgIHZhciB0bXAgPSB0O1xuXHQgICAgICBmb3IgKHZhciBpID0gMDsgdG1wLmNtcChvbmUpICE9PSAwOyBpKyspIHtcblx0ICAgICAgICB0bXAgPSB0bXAucmVkU3FyKCk7XG5cdCAgICAgIH1cblx0ICAgICAgYXNzZXJ0KGkgPCBtKTtcblx0ICAgICAgdmFyIGIgPSB0aGlzLnBvdyhjLCBuZXcgQk4oMSkuaXVzaGxuKG0gLSBpIC0gMSkpO1xuXG5cdCAgICAgIHIgPSByLnJlZE11bChiKTtcblx0ICAgICAgYyA9IGIucmVkU3FyKCk7XG5cdCAgICAgIHQgPSB0LnJlZE11bChjKTtcblx0ICAgICAgbSA9IGk7XG5cdCAgICB9XG5cblx0ICAgIHJldHVybiByO1xuXHQgIH07XG5cblx0ICBSZWQucHJvdG90eXBlLmludm0gPSBmdW5jdGlvbiBpbnZtIChhKSB7XG5cdCAgICB2YXIgaW52ID0gYS5faW52bXAodGhpcy5tKTtcblx0ICAgIGlmIChpbnYubmVnYXRpdmUgIT09IDApIHtcblx0ICAgICAgaW52Lm5lZ2F0aXZlID0gMDtcblx0ICAgICAgcmV0dXJuIHRoaXMuaW1vZChpbnYpLnJlZE5lZygpO1xuXHQgICAgfSBlbHNlIHtcblx0ICAgICAgcmV0dXJuIHRoaXMuaW1vZChpbnYpO1xuXHQgICAgfVxuXHQgIH07XG5cblx0ICBSZWQucHJvdG90eXBlLnBvdyA9IGZ1bmN0aW9uIHBvdyAoYSwgbnVtKSB7XG5cdCAgICBpZiAobnVtLmlzWmVybygpKSByZXR1cm4gbmV3IEJOKDEpLnRvUmVkKHRoaXMpO1xuXHQgICAgaWYgKG51bS5jbXBuKDEpID09PSAwKSByZXR1cm4gYS5jbG9uZSgpO1xuXG5cdCAgICB2YXIgd2luZG93U2l6ZSA9IDQ7XG5cdCAgICB2YXIgd25kID0gbmV3IEFycmF5KDEgPDwgd2luZG93U2l6ZSk7XG5cdCAgICB3bmRbMF0gPSBuZXcgQk4oMSkudG9SZWQodGhpcyk7XG5cdCAgICB3bmRbMV0gPSBhO1xuXHQgICAgZm9yICh2YXIgaSA9IDI7IGkgPCB3bmQubGVuZ3RoOyBpKyspIHtcblx0ICAgICAgd25kW2ldID0gdGhpcy5tdWwod25kW2kgLSAxXSwgYSk7XG5cdCAgICB9XG5cblx0ICAgIHZhciByZXMgPSB3bmRbMF07XG5cdCAgICB2YXIgY3VycmVudCA9IDA7XG5cdCAgICB2YXIgY3VycmVudExlbiA9IDA7XG5cdCAgICB2YXIgc3RhcnQgPSBudW0uYml0TGVuZ3RoKCkgJSAyNjtcblx0ICAgIGlmIChzdGFydCA9PT0gMCkge1xuXHQgICAgICBzdGFydCA9IDI2O1xuXHQgICAgfVxuXG5cdCAgICBmb3IgKGkgPSBudW0ubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcblx0ICAgICAgdmFyIHdvcmQgPSBudW0ud29yZHNbaV07XG5cdCAgICAgIGZvciAodmFyIGogPSBzdGFydCAtIDE7IGogPj0gMDsgai0tKSB7XG5cdCAgICAgICAgdmFyIGJpdCA9ICh3b3JkID4+IGopICYgMTtcblx0ICAgICAgICBpZiAocmVzICE9PSB3bmRbMF0pIHtcblx0ICAgICAgICAgIHJlcyA9IHRoaXMuc3FyKHJlcyk7XG5cdCAgICAgICAgfVxuXG5cdCAgICAgICAgaWYgKGJpdCA9PT0gMCAmJiBjdXJyZW50ID09PSAwKSB7XG5cdCAgICAgICAgICBjdXJyZW50TGVuID0gMDtcblx0ICAgICAgICAgIGNvbnRpbnVlO1xuXHQgICAgICAgIH1cblxuXHQgICAgICAgIGN1cnJlbnQgPDw9IDE7XG5cdCAgICAgICAgY3VycmVudCB8PSBiaXQ7XG5cdCAgICAgICAgY3VycmVudExlbisrO1xuXHQgICAgICAgIGlmIChjdXJyZW50TGVuICE9PSB3aW5kb3dTaXplICYmIChpICE9PSAwIHx8IGogIT09IDApKSBjb250aW51ZTtcblxuXHQgICAgICAgIHJlcyA9IHRoaXMubXVsKHJlcywgd25kW2N1cnJlbnRdKTtcblx0ICAgICAgICBjdXJyZW50TGVuID0gMDtcblx0ICAgICAgICBjdXJyZW50ID0gMDtcblx0ICAgICAgfVxuXHQgICAgICBzdGFydCA9IDI2O1xuXHQgICAgfVxuXG5cdCAgICByZXR1cm4gcmVzO1xuXHQgIH07XG5cblx0ICBSZWQucHJvdG90eXBlLmNvbnZlcnRUbyA9IGZ1bmN0aW9uIGNvbnZlcnRUbyAobnVtKSB7XG5cdCAgICB2YXIgciA9IG51bS51bW9kKHRoaXMubSk7XG5cblx0ICAgIHJldHVybiByID09PSBudW0gPyByLmNsb25lKCkgOiByO1xuXHQgIH07XG5cblx0ICBSZWQucHJvdG90eXBlLmNvbnZlcnRGcm9tID0gZnVuY3Rpb24gY29udmVydEZyb20gKG51bSkge1xuXHQgICAgdmFyIHJlcyA9IG51bS5jbG9uZSgpO1xuXHQgICAgcmVzLnJlZCA9IG51bGw7XG5cdCAgICByZXR1cm4gcmVzO1xuXHQgIH07XG5cblx0ICAvL1xuXHQgIC8vIE1vbnRnb21lcnkgbWV0aG9kIGVuZ2luZVxuXHQgIC8vXG5cblx0ICBCTi5tb250ID0gZnVuY3Rpb24gbW9udCAobnVtKSB7XG5cdCAgICByZXR1cm4gbmV3IE1vbnQobnVtKTtcblx0ICB9O1xuXG5cdCAgZnVuY3Rpb24gTW9udCAobSkge1xuXHQgICAgUmVkLmNhbGwodGhpcywgbSk7XG5cblx0ICAgIHRoaXMuc2hpZnQgPSB0aGlzLm0uYml0TGVuZ3RoKCk7XG5cdCAgICBpZiAodGhpcy5zaGlmdCAlIDI2ICE9PSAwKSB7XG5cdCAgICAgIHRoaXMuc2hpZnQgKz0gMjYgLSAodGhpcy5zaGlmdCAlIDI2KTtcblx0ICAgIH1cblxuXHQgICAgdGhpcy5yID0gbmV3IEJOKDEpLml1c2hsbih0aGlzLnNoaWZ0KTtcblx0ICAgIHRoaXMucjIgPSB0aGlzLmltb2QodGhpcy5yLnNxcigpKTtcblx0ICAgIHRoaXMucmludiA9IHRoaXMuci5faW52bXAodGhpcy5tKTtcblxuXHQgICAgdGhpcy5taW52ID0gdGhpcy5yaW52Lm11bCh0aGlzLnIpLmlzdWJuKDEpLmRpdih0aGlzLm0pO1xuXHQgICAgdGhpcy5taW52ID0gdGhpcy5taW52LnVtb2QodGhpcy5yKTtcblx0ICAgIHRoaXMubWludiA9IHRoaXMuci5zdWIodGhpcy5taW52KTtcblx0ICB9XG5cdCAgaW5oZXJpdHMoTW9udCwgUmVkKTtcblxuXHQgIE1vbnQucHJvdG90eXBlLmNvbnZlcnRUbyA9IGZ1bmN0aW9uIGNvbnZlcnRUbyAobnVtKSB7XG5cdCAgICByZXR1cm4gdGhpcy5pbW9kKG51bS51c2hsbih0aGlzLnNoaWZ0KSk7XG5cdCAgfTtcblxuXHQgIE1vbnQucHJvdG90eXBlLmNvbnZlcnRGcm9tID0gZnVuY3Rpb24gY29udmVydEZyb20gKG51bSkge1xuXHQgICAgdmFyIHIgPSB0aGlzLmltb2QobnVtLm11bCh0aGlzLnJpbnYpKTtcblx0ICAgIHIucmVkID0gbnVsbDtcblx0ICAgIHJldHVybiByO1xuXHQgIH07XG5cblx0ICBNb250LnByb3RvdHlwZS5pbXVsID0gZnVuY3Rpb24gaW11bCAoYSwgYikge1xuXHQgICAgaWYgKGEuaXNaZXJvKCkgfHwgYi5pc1plcm8oKSkge1xuXHQgICAgICBhLndvcmRzWzBdID0gMDtcblx0ICAgICAgYS5sZW5ndGggPSAxO1xuXHQgICAgICByZXR1cm4gYTtcblx0ICAgIH1cblxuXHQgICAgdmFyIHQgPSBhLmltdWwoYik7XG5cdCAgICB2YXIgYyA9IHQubWFza24odGhpcy5zaGlmdCkubXVsKHRoaXMubWludikuaW1hc2tuKHRoaXMuc2hpZnQpLm11bCh0aGlzLm0pO1xuXHQgICAgdmFyIHUgPSB0LmlzdWIoYykuaXVzaHJuKHRoaXMuc2hpZnQpO1xuXHQgICAgdmFyIHJlcyA9IHU7XG5cblx0ICAgIGlmICh1LmNtcCh0aGlzLm0pID49IDApIHtcblx0ICAgICAgcmVzID0gdS5pc3ViKHRoaXMubSk7XG5cdCAgICB9IGVsc2UgaWYgKHUuY21wbigwKSA8IDApIHtcblx0ICAgICAgcmVzID0gdS5pYWRkKHRoaXMubSk7XG5cdCAgICB9XG5cblx0ICAgIHJldHVybiByZXMuX2ZvcmNlUmVkKHRoaXMpO1xuXHQgIH07XG5cblx0ICBNb250LnByb3RvdHlwZS5tdWwgPSBmdW5jdGlvbiBtdWwgKGEsIGIpIHtcblx0ICAgIGlmIChhLmlzWmVybygpIHx8IGIuaXNaZXJvKCkpIHJldHVybiBuZXcgQk4oMCkuX2ZvcmNlUmVkKHRoaXMpO1xuXG5cdCAgICB2YXIgdCA9IGEubXVsKGIpO1xuXHQgICAgdmFyIGMgPSB0Lm1hc2tuKHRoaXMuc2hpZnQpLm11bCh0aGlzLm1pbnYpLmltYXNrbih0aGlzLnNoaWZ0KS5tdWwodGhpcy5tKTtcblx0ICAgIHZhciB1ID0gdC5pc3ViKGMpLml1c2hybih0aGlzLnNoaWZ0KTtcblx0ICAgIHZhciByZXMgPSB1O1xuXHQgICAgaWYgKHUuY21wKHRoaXMubSkgPj0gMCkge1xuXHQgICAgICByZXMgPSB1LmlzdWIodGhpcy5tKTtcblx0ICAgIH0gZWxzZSBpZiAodS5jbXBuKDApIDwgMCkge1xuXHQgICAgICByZXMgPSB1LmlhZGQodGhpcy5tKTtcblx0ICAgIH1cblxuXHQgICAgcmV0dXJuIHJlcy5fZm9yY2VSZWQodGhpcyk7XG5cdCAgfTtcblxuXHQgIE1vbnQucHJvdG90eXBlLmludm0gPSBmdW5jdGlvbiBpbnZtIChhKSB7XG5cdCAgICAvLyAoQVIpXi0xICogUl4yID0gKEFeLTEgKiBSXi0xKSAqIFJeMiA9IEFeLTEgKiBSXG5cdCAgICB2YXIgcmVzID0gdGhpcy5pbW9kKGEuX2ludm1wKHRoaXMubSkubXVsKHRoaXMucjIpKTtcblx0ICAgIHJldHVybiByZXMuX2ZvcmNlUmVkKHRoaXMpO1xuXHQgIH07XG5cdH0pKCdvYmplY3QnID09PSAndW5kZWZpbmVkJyB8fCBtb2R1bGUsIGNvbW1vbmpzR2xvYmFsKTtcblx0fSk7XG5cblx0dmFyIF92ZXJzaW9uID0gY3JlYXRlQ29tbW9uanNNb2R1bGUoZnVuY3Rpb24gKG1vZHVsZSwgZXhwb3J0cykge1xuXHRcInVzZSBzdHJpY3RcIjtcblx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuXHRleHBvcnRzLnZlcnNpb24gPSB2b2lkIDA7XG5cdGV4cG9ydHMudmVyc2lvbiA9IFwibG9nZ2VyLzUuNS4wXCI7XG5cblx0fSk7XG5cblx0dmFyIF92ZXJzaW9uJDEgPSAvKkBfX1BVUkVfXyovZ2V0RGVmYXVsdEV4cG9ydEZyb21DanMoX3ZlcnNpb24pO1xuXG5cdHZhciBsaWIgPSBjcmVhdGVDb21tb25qc01vZHVsZShmdW5jdGlvbiAobW9kdWxlLCBleHBvcnRzKSB7XG5cdFwidXNlIHN0cmljdFwiO1xuXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5cdGV4cG9ydHMuTG9nZ2VyID0gZXhwb3J0cy5FcnJvckNvZGUgPSBleHBvcnRzLkxvZ0xldmVsID0gdm9pZCAwO1xuXHR2YXIgX3Blcm1hbmVudENlbnNvckVycm9ycyA9IGZhbHNlO1xuXHR2YXIgX2NlbnNvckVycm9ycyA9IGZhbHNlO1xuXHR2YXIgTG9nTGV2ZWxzID0geyBkZWJ1ZzogMSwgXCJkZWZhdWx0XCI6IDIsIGluZm86IDIsIHdhcm5pbmc6IDMsIGVycm9yOiA0LCBvZmY6IDUgfTtcblx0dmFyIF9sb2dMZXZlbCA9IExvZ0xldmVsc1tcImRlZmF1bHRcIl07XG5cblx0dmFyIF9nbG9iYWxMb2dnZXIgPSBudWxsO1xuXHRmdW5jdGlvbiBfY2hlY2tOb3JtYWxpemUoKSB7XG5cdCAgICB0cnkge1xuXHQgICAgICAgIHZhciBtaXNzaW5nXzEgPSBbXTtcblx0ICAgICAgICAvLyBNYWtlIHN1cmUgYWxsIGZvcm1zIG9mIG5vcm1hbGl6YXRpb24gYXJlIHN1cHBvcnRlZFxuXHQgICAgICAgIFtcIk5GRFwiLCBcIk5GQ1wiLCBcIk5GS0RcIiwgXCJORktDXCJdLmZvckVhY2goZnVuY3Rpb24gKGZvcm0pIHtcblx0ICAgICAgICAgICAgdHJ5IHtcblx0ICAgICAgICAgICAgICAgIGlmIChcInRlc3RcIi5ub3JtYWxpemUoZm9ybSkgIT09IFwidGVzdFwiKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiYmFkIG5vcm1hbGl6ZVwiKTtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgIDtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcblx0ICAgICAgICAgICAgICAgIG1pc3NpbmdfMS5wdXNoKGZvcm0pO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfSk7XG5cdCAgICAgICAgaWYgKG1pc3NpbmdfMS5sZW5ndGgpIHtcblx0ICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwibWlzc2luZyBcIiArIG1pc3NpbmdfMS5qb2luKFwiLCBcIikpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBpZiAoU3RyaW5nLmZyb21DaGFyQ29kZSgweGU5KS5ub3JtYWxpemUoXCJORkRcIikgIT09IFN0cmluZy5mcm9tQ2hhckNvZGUoMHg2NSwgMHgwMzAxKSkge1xuXHQgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJicm9rZW4gaW1wbGVtZW50YXRpb25cIik7XG5cdCAgICAgICAgfVxuXHQgICAgfVxuXHQgICAgY2F0Y2ggKGVycm9yKSB7XG5cdCAgICAgICAgcmV0dXJuIGVycm9yLm1lc3NhZ2U7XG5cdCAgICB9XG5cdCAgICByZXR1cm4gbnVsbDtcblx0fVxuXHR2YXIgX25vcm1hbGl6ZUVycm9yID0gX2NoZWNrTm9ybWFsaXplKCk7XG5cdHZhciBMb2dMZXZlbDtcblx0KGZ1bmN0aW9uIChMb2dMZXZlbCkge1xuXHQgICAgTG9nTGV2ZWxbXCJERUJVR1wiXSA9IFwiREVCVUdcIjtcblx0ICAgIExvZ0xldmVsW1wiSU5GT1wiXSA9IFwiSU5GT1wiO1xuXHQgICAgTG9nTGV2ZWxbXCJXQVJOSU5HXCJdID0gXCJXQVJOSU5HXCI7XG5cdCAgICBMb2dMZXZlbFtcIkVSUk9SXCJdID0gXCJFUlJPUlwiO1xuXHQgICAgTG9nTGV2ZWxbXCJPRkZcIl0gPSBcIk9GRlwiO1xuXHR9KShMb2dMZXZlbCA9IGV4cG9ydHMuTG9nTGV2ZWwgfHwgKGV4cG9ydHMuTG9nTGV2ZWwgPSB7fSkpO1xuXHR2YXIgRXJyb3JDb2RlO1xuXHQoZnVuY3Rpb24gKEVycm9yQ29kZSkge1xuXHQgICAgLy8vLy8vLy8vLy8vLy8vLy8vL1xuXHQgICAgLy8gR2VuZXJpYyBFcnJvcnNcblx0ICAgIC8vIFVua25vd24gRXJyb3Jcblx0ICAgIEVycm9yQ29kZVtcIlVOS05PV05fRVJST1JcIl0gPSBcIlVOS05PV05fRVJST1JcIjtcblx0ICAgIC8vIE5vdCBJbXBsZW1lbnRlZFxuXHQgICAgRXJyb3JDb2RlW1wiTk9UX0lNUExFTUVOVEVEXCJdID0gXCJOT1RfSU1QTEVNRU5URURcIjtcblx0ICAgIC8vIFVuc3VwcG9ydGVkIE9wZXJhdGlvblxuXHQgICAgLy8gICAtIG9wZXJhdGlvblxuXHQgICAgRXJyb3JDb2RlW1wiVU5TVVBQT1JURURfT1BFUkFUSU9OXCJdID0gXCJVTlNVUFBPUlRFRF9PUEVSQVRJT05cIjtcblx0ICAgIC8vIE5ldHdvcmsgRXJyb3IgKGkuZS4gRXRoZXJldW0gTmV0d29yaywgc3VjaCBhcyBhbiBpbnZhbGlkIGNoYWluIElEKVxuXHQgICAgLy8gICAtIGV2ZW50IChcIm5vTmV0d29ya1wiIGlzIG5vdCByZS10aHJvd24gaW4gcHJvdmlkZXIucmVhZHk7IG90aGVyd2lzZSB0aHJvd24pXG5cdCAgICBFcnJvckNvZGVbXCJORVRXT1JLX0VSUk9SXCJdID0gXCJORVRXT1JLX0VSUk9SXCI7XG5cdCAgICAvLyBTb21lIHNvcnQgb2YgYmFkIHJlc3BvbnNlIGZyb20gdGhlIHNlcnZlclxuXHQgICAgRXJyb3JDb2RlW1wiU0VSVkVSX0VSUk9SXCJdID0gXCJTRVJWRVJfRVJST1JcIjtcblx0ICAgIC8vIFRpbWVvdXRcblx0ICAgIEVycm9yQ29kZVtcIlRJTUVPVVRcIl0gPSBcIlRJTUVPVVRcIjtcblx0ICAgIC8vLy8vLy8vLy8vLy8vLy8vLy9cblx0ICAgIC8vIE9wZXJhdGlvbmFsICBFcnJvcnNcblx0ICAgIC8vIEJ1ZmZlciBPdmVycnVuXG5cdCAgICBFcnJvckNvZGVbXCJCVUZGRVJfT1ZFUlJVTlwiXSA9IFwiQlVGRkVSX09WRVJSVU5cIjtcblx0ICAgIC8vIE51bWVyaWMgRmF1bHRcblx0ICAgIC8vICAgLSBvcGVyYXRpb246IHRoZSBvcGVyYXRpb24gYmVpbmcgZXhlY3V0ZWRcblx0ICAgIC8vICAgLSBmYXVsdDogdGhlIHJlYXNvbiB0aGlzIGZhdWx0ZWRcblx0ICAgIEVycm9yQ29kZVtcIk5VTUVSSUNfRkFVTFRcIl0gPSBcIk5VTUVSSUNfRkFVTFRcIjtcblx0ICAgIC8vLy8vLy8vLy8vLy8vLy8vLy9cblx0ICAgIC8vIEFyZ3VtZW50IEVycm9yc1xuXHQgICAgLy8gTWlzc2luZyBuZXcgb3BlcmF0b3IgdG8gYW4gb2JqZWN0XG5cdCAgICAvLyAgLSBuYW1lOiBUaGUgbmFtZSBvZiB0aGUgY2xhc3Ncblx0ICAgIEVycm9yQ29kZVtcIk1JU1NJTkdfTkVXXCJdID0gXCJNSVNTSU5HX05FV1wiO1xuXHQgICAgLy8gSW52YWxpZCBhcmd1bWVudCAoZS5nLiB2YWx1ZSBpcyBpbmNvbXBhdGlibGUgd2l0aCB0eXBlKSB0byBhIGZ1bmN0aW9uOlxuXHQgICAgLy8gICAtIGFyZ3VtZW50OiBUaGUgYXJndW1lbnQgbmFtZSB0aGF0IHdhcyBpbnZhbGlkXG5cdCAgICAvLyAgIC0gdmFsdWU6IFRoZSB2YWx1ZSBvZiB0aGUgYXJndW1lbnRcblx0ICAgIEVycm9yQ29kZVtcIklOVkFMSURfQVJHVU1FTlRcIl0gPSBcIklOVkFMSURfQVJHVU1FTlRcIjtcblx0ICAgIC8vIE1pc3NpbmcgYXJndW1lbnQgdG8gYSBmdW5jdGlvbjpcblx0ICAgIC8vICAgLSBjb3VudDogVGhlIG51bWJlciBvZiBhcmd1bWVudHMgcmVjZWl2ZWRcblx0ICAgIC8vICAgLSBleHBlY3RlZENvdW50OiBUaGUgbnVtYmVyIG9mIGFyZ3VtZW50cyBleHBlY3RlZFxuXHQgICAgRXJyb3JDb2RlW1wiTUlTU0lOR19BUkdVTUVOVFwiXSA9IFwiTUlTU0lOR19BUkdVTUVOVFwiO1xuXHQgICAgLy8gVG9vIG1hbnkgYXJndW1lbnRzXG5cdCAgICAvLyAgIC0gY291bnQ6IFRoZSBudW1iZXIgb2YgYXJndW1lbnRzIHJlY2VpdmVkXG5cdCAgICAvLyAgIC0gZXhwZWN0ZWRDb3VudDogVGhlIG51bWJlciBvZiBhcmd1bWVudHMgZXhwZWN0ZWRcblx0ICAgIEVycm9yQ29kZVtcIlVORVhQRUNURURfQVJHVU1FTlRcIl0gPSBcIlVORVhQRUNURURfQVJHVU1FTlRcIjtcblx0ICAgIC8vLy8vLy8vLy8vLy8vLy8vLy9cblx0ICAgIC8vIEJsb2NrY2hhaW4gRXJyb3JzXG5cdCAgICAvLyBDYWxsIGV4Y2VwdGlvblxuXHQgICAgLy8gIC0gdHJhbnNhY3Rpb246IHRoZSB0cmFuc2FjdGlvblxuXHQgICAgLy8gIC0gYWRkcmVzcz86IHRoZSBjb250cmFjdCBhZGRyZXNzXG5cdCAgICAvLyAgLSBhcmdzPzogVGhlIGFyZ3VtZW50cyBwYXNzZWQgaW50byB0aGUgZnVuY3Rpb25cblx0ICAgIC8vICAtIG1ldGhvZD86IFRoZSBTb2xpZGl0eSBtZXRob2Qgc2lnbmF0dXJlXG5cdCAgICAvLyAgLSBlcnJvclNpZ25hdHVyZT86IFRoZSBFSVA4NDggZXJyb3Igc2lnbmF0dXJlXG5cdCAgICAvLyAgLSBlcnJvckFyZ3M/OiBUaGUgRUlQODQ4IGVycm9yIHBhcmFtZXRlcnNcblx0ICAgIC8vICAtIHJlYXNvbjogVGhlIHJlYXNvbiAob25seSBmb3IgRUlQODQ4IFwiRXJyb3Ioc3RyaW5nKVwiKVxuXHQgICAgRXJyb3JDb2RlW1wiQ0FMTF9FWENFUFRJT05cIl0gPSBcIkNBTExfRVhDRVBUSU9OXCI7XG5cdCAgICAvLyBJbnN1ZmZpY2llbnQgZnVuZHMgKDwgdmFsdWUgKyBnYXNMaW1pdCAqIGdhc1ByaWNlKVxuXHQgICAgLy8gICAtIHRyYW5zYWN0aW9uOiB0aGUgdHJhbnNhY3Rpb24gYXR0ZW1wdGVkXG5cdCAgICBFcnJvckNvZGVbXCJJTlNVRkZJQ0lFTlRfRlVORFNcIl0gPSBcIklOU1VGRklDSUVOVF9GVU5EU1wiO1xuXHQgICAgLy8gTm9uY2UgaGFzIGFscmVhZHkgYmVlbiB1c2VkXG5cdCAgICAvLyAgIC0gdHJhbnNhY3Rpb246IHRoZSB0cmFuc2FjdGlvbiBhdHRlbXB0ZWRcblx0ICAgIEVycm9yQ29kZVtcIk5PTkNFX0VYUElSRURcIl0gPSBcIk5PTkNFX0VYUElSRURcIjtcblx0ICAgIC8vIFRoZSByZXBsYWNlbWVudCBmZWUgZm9yIHRoZSB0cmFuc2FjdGlvbiBpcyB0b28gbG93XG5cdCAgICAvLyAgIC0gdHJhbnNhY3Rpb246IHRoZSB0cmFuc2FjdGlvbiBhdHRlbXB0ZWRcblx0ICAgIEVycm9yQ29kZVtcIlJFUExBQ0VNRU5UX1VOREVSUFJJQ0VEXCJdID0gXCJSRVBMQUNFTUVOVF9VTkRFUlBSSUNFRFwiO1xuXHQgICAgLy8gVGhlIGdhcyBsaW1pdCBjb3VsZCBub3QgYmUgZXN0aW1hdGVkXG5cdCAgICAvLyAgIC0gdHJhbnNhY3Rpb246IHRoZSB0cmFuc2FjdGlvbiBwYXNzZWQgdG8gZXN0aW1hdGVHYXNcblx0ICAgIEVycm9yQ29kZVtcIlVOUFJFRElDVEFCTEVfR0FTX0xJTUlUXCJdID0gXCJVTlBSRURJQ1RBQkxFX0dBU19MSU1JVFwiO1xuXHQgICAgLy8gVGhlIHRyYW5zYWN0aW9uIHdhcyByZXBsYWNlZCBieSBvbmUgd2l0aCBhIGhpZ2hlciBnYXMgcHJpY2Vcblx0ICAgIC8vICAgLSByZWFzb246IFwiY2FuY2VsbGVkXCIsIFwicmVwbGFjZWRcIiBvciBcInJlcHJpY2VkXCJcblx0ICAgIC8vICAgLSBjYW5jZWxsZWQ6IHRydWUgaWYgcmVhc29uID09IFwiY2FuY2VsbGVkXCIgb3IgcmVhc29uID09IFwicmVwbGFjZWRcIilcblx0ICAgIC8vICAgLSBoYXNoOiBvcmlnaW5hbCB0cmFuc2FjdGlvbiBoYXNoXG5cdCAgICAvLyAgIC0gcmVwbGFjZW1lbnQ6IHRoZSBmdWxsIFRyYW5zYWN0aW9uc1Jlc3BvbnNlIGZvciB0aGUgcmVwbGFjZW1lbnRcblx0ICAgIC8vICAgLSByZWNlaXB0OiB0aGUgcmVjZWlwdCBvZiB0aGUgcmVwbGFjZW1lbnRcblx0ICAgIEVycm9yQ29kZVtcIlRSQU5TQUNUSU9OX1JFUExBQ0VEXCJdID0gXCJUUkFOU0FDVElPTl9SRVBMQUNFRFwiO1xuXHR9KShFcnJvckNvZGUgPSBleHBvcnRzLkVycm9yQ29kZSB8fCAoZXhwb3J0cy5FcnJvckNvZGUgPSB7fSkpO1xuXHQ7XG5cdHZhciBIRVggPSBcIjAxMjM0NTY3ODlhYmNkZWZcIjtcblx0dmFyIExvZ2dlciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcblx0ICAgIGZ1bmN0aW9uIExvZ2dlcih2ZXJzaW9uKSB7XG5cdCAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwidmVyc2lvblwiLCB7XG5cdCAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG5cdCAgICAgICAgICAgIHZhbHVlOiB2ZXJzaW9uLFxuXHQgICAgICAgICAgICB3cml0YWJsZTogZmFsc2Vcblx0ICAgICAgICB9KTtcblx0ICAgIH1cblx0ICAgIExvZ2dlci5wcm90b3R5cGUuX2xvZyA9IGZ1bmN0aW9uIChsb2dMZXZlbCwgYXJncykge1xuXHQgICAgICAgIHZhciBsZXZlbCA9IGxvZ0xldmVsLnRvTG93ZXJDYXNlKCk7XG5cdCAgICAgICAgaWYgKExvZ0xldmVsc1tsZXZlbF0gPT0gbnVsbCkge1xuXHQgICAgICAgICAgICB0aGlzLnRocm93QXJndW1lbnRFcnJvcihcImludmFsaWQgbG9nIGxldmVsIG5hbWVcIiwgXCJsb2dMZXZlbFwiLCBsb2dMZXZlbCk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGlmIChfbG9nTGV2ZWwgPiBMb2dMZXZlbHNbbGV2ZWxdKSB7XG5cdCAgICAgICAgICAgIHJldHVybjtcblx0ICAgICAgICB9XG5cdCAgICAgICAgY29uc29sZS5sb2cuYXBwbHkoY29uc29sZSwgYXJncyk7XG5cdCAgICB9O1xuXHQgICAgTG9nZ2VyLnByb3RvdHlwZS5kZWJ1ZyA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICB2YXIgYXJncyA9IFtdO1xuXHQgICAgICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG5cdCAgICAgICAgICAgIGFyZ3NbX2ldID0gYXJndW1lbnRzW19pXTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgdGhpcy5fbG9nKExvZ2dlci5sZXZlbHMuREVCVUcsIGFyZ3MpO1xuXHQgICAgfTtcblx0ICAgIExvZ2dlci5wcm90b3R5cGUuaW5mbyA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICB2YXIgYXJncyA9IFtdO1xuXHQgICAgICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG5cdCAgICAgICAgICAgIGFyZ3NbX2ldID0gYXJndW1lbnRzW19pXTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgdGhpcy5fbG9nKExvZ2dlci5sZXZlbHMuSU5GTywgYXJncyk7XG5cdCAgICB9O1xuXHQgICAgTG9nZ2VyLnByb3RvdHlwZS53YXJuID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIHZhciBhcmdzID0gW107XG5cdCAgICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcblx0ICAgICAgICAgICAgYXJnc1tfaV0gPSBhcmd1bWVudHNbX2ldO1xuXHQgICAgICAgIH1cblx0ICAgICAgICB0aGlzLl9sb2coTG9nZ2VyLmxldmVscy5XQVJOSU5HLCBhcmdzKTtcblx0ICAgIH07XG5cdCAgICBMb2dnZXIucHJvdG90eXBlLm1ha2VFcnJvciA9IGZ1bmN0aW9uIChtZXNzYWdlLCBjb2RlLCBwYXJhbXMpIHtcblx0ICAgICAgICAvLyBFcnJvcnMgYXJlIGJlaW5nIGNlbnNvcmVkXG5cdCAgICAgICAgaWYgKF9jZW5zb3JFcnJvcnMpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIHRoaXMubWFrZUVycm9yKFwiY2Vuc29yZWQgZXJyb3JcIiwgY29kZSwge30pO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBpZiAoIWNvZGUpIHtcblx0ICAgICAgICAgICAgY29kZSA9IExvZ2dlci5lcnJvcnMuVU5LTk9XTl9FUlJPUjtcblx0ICAgICAgICB9XG5cdCAgICAgICAgaWYgKCFwYXJhbXMpIHtcblx0ICAgICAgICAgICAgcGFyYW1zID0ge307XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHZhciBtZXNzYWdlRGV0YWlscyA9IFtdO1xuXHQgICAgICAgIE9iamVjdC5rZXlzKHBhcmFtcykuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG5cdCAgICAgICAgICAgIHZhciB2YWx1ZSA9IHBhcmFtc1trZXldO1xuXHQgICAgICAgICAgICB0cnkge1xuXHQgICAgICAgICAgICAgICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgVWludDhBcnJheSkge1xuXHQgICAgICAgICAgICAgICAgICAgIHZhciBoZXggPSBcIlwiO1xuXHQgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdmFsdWUubGVuZ3RoOyBpKyspIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgaGV4ICs9IEhFWFt2YWx1ZVtpXSA+PiA0XTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgaGV4ICs9IEhFWFt2YWx1ZVtpXSAmIDB4MGZdO1xuXHQgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICBtZXNzYWdlRGV0YWlscy5wdXNoKGtleSArIFwiPVVpbnQ4QXJyYXkoMHhcIiArIGhleCArIFwiKVwiKTtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgIGVsc2Uge1xuXHQgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2VEZXRhaWxzLnB1c2goa2V5ICsgXCI9XCIgKyBKU09OLnN0cmluZ2lmeSh2YWx1ZSkpO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuXHQgICAgICAgICAgICAgICAgbWVzc2FnZURldGFpbHMucHVzaChrZXkgKyBcIj1cIiArIEpTT04uc3RyaW5naWZ5KHBhcmFtc1trZXldLnRvU3RyaW5nKCkpKTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH0pO1xuXHQgICAgICAgIG1lc3NhZ2VEZXRhaWxzLnB1c2goXCJjb2RlPVwiICsgY29kZSk7XG5cdCAgICAgICAgbWVzc2FnZURldGFpbHMucHVzaChcInZlcnNpb249XCIgKyB0aGlzLnZlcnNpb24pO1xuXHQgICAgICAgIHZhciByZWFzb24gPSBtZXNzYWdlO1xuXHQgICAgICAgIGlmIChtZXNzYWdlRGV0YWlscy5sZW5ndGgpIHtcblx0ICAgICAgICAgICAgbWVzc2FnZSArPSBcIiAoXCIgKyBtZXNzYWdlRGV0YWlscy5qb2luKFwiLCBcIikgKyBcIilcIjtcblx0ICAgICAgICB9XG5cdCAgICAgICAgLy8gQFRPRE86IEFueT8/XG5cdCAgICAgICAgdmFyIGVycm9yID0gbmV3IEVycm9yKG1lc3NhZ2UpO1xuXHQgICAgICAgIGVycm9yLnJlYXNvbiA9IHJlYXNvbjtcblx0ICAgICAgICBlcnJvci5jb2RlID0gY29kZTtcblx0ICAgICAgICBPYmplY3Qua2V5cyhwYXJhbXMpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuXHQgICAgICAgICAgICBlcnJvcltrZXldID0gcGFyYW1zW2tleV07XG5cdCAgICAgICAgfSk7XG5cdCAgICAgICAgcmV0dXJuIGVycm9yO1xuXHQgICAgfTtcblx0ICAgIExvZ2dlci5wcm90b3R5cGUudGhyb3dFcnJvciA9IGZ1bmN0aW9uIChtZXNzYWdlLCBjb2RlLCBwYXJhbXMpIHtcblx0ICAgICAgICB0aHJvdyB0aGlzLm1ha2VFcnJvcihtZXNzYWdlLCBjb2RlLCBwYXJhbXMpO1xuXHQgICAgfTtcblx0ICAgIExvZ2dlci5wcm90b3R5cGUudGhyb3dBcmd1bWVudEVycm9yID0gZnVuY3Rpb24gKG1lc3NhZ2UsIG5hbWUsIHZhbHVlKSB7XG5cdCAgICAgICAgcmV0dXJuIHRoaXMudGhyb3dFcnJvcihtZXNzYWdlLCBMb2dnZXIuZXJyb3JzLklOVkFMSURfQVJHVU1FTlQsIHtcblx0ICAgICAgICAgICAgYXJndW1lbnQ6IG5hbWUsXG5cdCAgICAgICAgICAgIHZhbHVlOiB2YWx1ZVxuXHQgICAgICAgIH0pO1xuXHQgICAgfTtcblx0ICAgIExvZ2dlci5wcm90b3R5cGUuYXNzZXJ0ID0gZnVuY3Rpb24gKGNvbmRpdGlvbiwgbWVzc2FnZSwgY29kZSwgcGFyYW1zKSB7XG5cdCAgICAgICAgaWYgKCEhY29uZGl0aW9uKSB7XG5cdCAgICAgICAgICAgIHJldHVybjtcblx0ICAgICAgICB9XG5cdCAgICAgICAgdGhpcy50aHJvd0Vycm9yKG1lc3NhZ2UsIGNvZGUsIHBhcmFtcyk7XG5cdCAgICB9O1xuXHQgICAgTG9nZ2VyLnByb3RvdHlwZS5hc3NlcnRBcmd1bWVudCA9IGZ1bmN0aW9uIChjb25kaXRpb24sIG1lc3NhZ2UsIG5hbWUsIHZhbHVlKSB7XG5cdCAgICAgICAgaWYgKCEhY29uZGl0aW9uKSB7XG5cdCAgICAgICAgICAgIHJldHVybjtcblx0ICAgICAgICB9XG5cdCAgICAgICAgdGhpcy50aHJvd0FyZ3VtZW50RXJyb3IobWVzc2FnZSwgbmFtZSwgdmFsdWUpO1xuXHQgICAgfTtcblx0ICAgIExvZ2dlci5wcm90b3R5cGUuY2hlY2tOb3JtYWxpemUgPSBmdW5jdGlvbiAobWVzc2FnZSkge1xuXHQgICAgICAgIGlmIChtZXNzYWdlID09IG51bGwpIHtcblx0ICAgICAgICAgICAgbWVzc2FnZSA9IFwicGxhdGZvcm0gbWlzc2luZyBTdHJpbmcucHJvdG90eXBlLm5vcm1hbGl6ZVwiO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBpZiAoX25vcm1hbGl6ZUVycm9yKSB7XG5cdCAgICAgICAgICAgIHRoaXMudGhyb3dFcnJvcihcInBsYXRmb3JtIG1pc3NpbmcgU3RyaW5nLnByb3RvdHlwZS5ub3JtYWxpemVcIiwgTG9nZ2VyLmVycm9ycy5VTlNVUFBPUlRFRF9PUEVSQVRJT04sIHtcblx0ICAgICAgICAgICAgICAgIG9wZXJhdGlvbjogXCJTdHJpbmcucHJvdG90eXBlLm5vcm1hbGl6ZVwiLCBmb3JtOiBfbm9ybWFsaXplRXJyb3Jcblx0ICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgfVxuXHQgICAgfTtcblx0ICAgIExvZ2dlci5wcm90b3R5cGUuY2hlY2tTYWZlVWludDUzID0gZnVuY3Rpb24gKHZhbHVlLCBtZXNzYWdlKSB7XG5cdCAgICAgICAgaWYgKHR5cGVvZiAodmFsdWUpICE9PSBcIm51bWJlclwiKSB7XG5cdCAgICAgICAgICAgIHJldHVybjtcblx0ICAgICAgICB9XG5cdCAgICAgICAgaWYgKG1lc3NhZ2UgPT0gbnVsbCkge1xuXHQgICAgICAgICAgICBtZXNzYWdlID0gXCJ2YWx1ZSBub3Qgc2FmZVwiO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBpZiAodmFsdWUgPCAwIHx8IHZhbHVlID49IDB4MWZmZmZmZmZmZmZmZmYpIHtcblx0ICAgICAgICAgICAgdGhpcy50aHJvd0Vycm9yKG1lc3NhZ2UsIExvZ2dlci5lcnJvcnMuTlVNRVJJQ19GQVVMVCwge1xuXHQgICAgICAgICAgICAgICAgb3BlcmF0aW9uOiBcImNoZWNrU2FmZUludGVnZXJcIixcblx0ICAgICAgICAgICAgICAgIGZhdWx0OiBcIm91dC1vZi1zYWZlLXJhbmdlXCIsXG5cdCAgICAgICAgICAgICAgICB2YWx1ZTogdmFsdWVcblx0ICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGlmICh2YWx1ZSAlIDEpIHtcblx0ICAgICAgICAgICAgdGhpcy50aHJvd0Vycm9yKG1lc3NhZ2UsIExvZ2dlci5lcnJvcnMuTlVNRVJJQ19GQVVMVCwge1xuXHQgICAgICAgICAgICAgICAgb3BlcmF0aW9uOiBcImNoZWNrU2FmZUludGVnZXJcIixcblx0ICAgICAgICAgICAgICAgIGZhdWx0OiBcIm5vbi1pbnRlZ2VyXCIsXG5cdCAgICAgICAgICAgICAgICB2YWx1ZTogdmFsdWVcblx0ICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgfVxuXHQgICAgfTtcblx0ICAgIExvZ2dlci5wcm90b3R5cGUuY2hlY2tBcmd1bWVudENvdW50ID0gZnVuY3Rpb24gKGNvdW50LCBleHBlY3RlZENvdW50LCBtZXNzYWdlKSB7XG5cdCAgICAgICAgaWYgKG1lc3NhZ2UpIHtcblx0ICAgICAgICAgICAgbWVzc2FnZSA9IFwiOiBcIiArIG1lc3NhZ2U7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGVsc2Uge1xuXHQgICAgICAgICAgICBtZXNzYWdlID0gXCJcIjtcblx0ICAgICAgICB9XG5cdCAgICAgICAgaWYgKGNvdW50IDwgZXhwZWN0ZWRDb3VudCkge1xuXHQgICAgICAgICAgICB0aGlzLnRocm93RXJyb3IoXCJtaXNzaW5nIGFyZ3VtZW50XCIgKyBtZXNzYWdlLCBMb2dnZXIuZXJyb3JzLk1JU1NJTkdfQVJHVU1FTlQsIHtcblx0ICAgICAgICAgICAgICAgIGNvdW50OiBjb3VudCxcblx0ICAgICAgICAgICAgICAgIGV4cGVjdGVkQ291bnQ6IGV4cGVjdGVkQ291bnRcblx0ICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGlmIChjb3VudCA+IGV4cGVjdGVkQ291bnQpIHtcblx0ICAgICAgICAgICAgdGhpcy50aHJvd0Vycm9yKFwidG9vIG1hbnkgYXJndW1lbnRzXCIgKyBtZXNzYWdlLCBMb2dnZXIuZXJyb3JzLlVORVhQRUNURURfQVJHVU1FTlQsIHtcblx0ICAgICAgICAgICAgICAgIGNvdW50OiBjb3VudCxcblx0ICAgICAgICAgICAgICAgIGV4cGVjdGVkQ291bnQ6IGV4cGVjdGVkQ291bnRcblx0ICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgfVxuXHQgICAgfTtcblx0ICAgIExvZ2dlci5wcm90b3R5cGUuY2hlY2tOZXcgPSBmdW5jdGlvbiAodGFyZ2V0LCBraW5kKSB7XG5cdCAgICAgICAgaWYgKHRhcmdldCA9PT0gT2JqZWN0IHx8IHRhcmdldCA9PSBudWxsKSB7XG5cdCAgICAgICAgICAgIHRoaXMudGhyb3dFcnJvcihcIm1pc3NpbmcgbmV3XCIsIExvZ2dlci5lcnJvcnMuTUlTU0lOR19ORVcsIHsgbmFtZToga2luZC5uYW1lIH0pO1xuXHQgICAgICAgIH1cblx0ICAgIH07XG5cdCAgICBMb2dnZXIucHJvdG90eXBlLmNoZWNrQWJzdHJhY3QgPSBmdW5jdGlvbiAodGFyZ2V0LCBraW5kKSB7XG5cdCAgICAgICAgaWYgKHRhcmdldCA9PT0ga2luZCkge1xuXHQgICAgICAgICAgICB0aGlzLnRocm93RXJyb3IoXCJjYW5ub3QgaW5zdGFudGlhdGUgYWJzdHJhY3QgY2xhc3MgXCIgKyBKU09OLnN0cmluZ2lmeShraW5kLm5hbWUpICsgXCIgZGlyZWN0bHk7IHVzZSBhIHN1Yi1jbGFzc1wiLCBMb2dnZXIuZXJyb3JzLlVOU1VQUE9SVEVEX09QRVJBVElPTiwgeyBuYW1lOiB0YXJnZXQubmFtZSwgb3BlcmF0aW9uOiBcIm5ld1wiIH0pO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBlbHNlIGlmICh0YXJnZXQgPT09IE9iamVjdCB8fCB0YXJnZXQgPT0gbnVsbCkge1xuXHQgICAgICAgICAgICB0aGlzLnRocm93RXJyb3IoXCJtaXNzaW5nIG5ld1wiLCBMb2dnZXIuZXJyb3JzLk1JU1NJTkdfTkVXLCB7IG5hbWU6IGtpbmQubmFtZSB9KTtcblx0ICAgICAgICB9XG5cdCAgICB9O1xuXHQgICAgTG9nZ2VyLmdsb2JhbExvZ2dlciA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICBpZiAoIV9nbG9iYWxMb2dnZXIpIHtcblx0ICAgICAgICAgICAgX2dsb2JhbExvZ2dlciA9IG5ldyBMb2dnZXIoX3ZlcnNpb24udmVyc2lvbik7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHJldHVybiBfZ2xvYmFsTG9nZ2VyO1xuXHQgICAgfTtcblx0ICAgIExvZ2dlci5zZXRDZW5zb3JzaGlwID0gZnVuY3Rpb24gKGNlbnNvcnNoaXAsIHBlcm1hbmVudCkge1xuXHQgICAgICAgIGlmICghY2Vuc29yc2hpcCAmJiBwZXJtYW5lbnQpIHtcblx0ICAgICAgICAgICAgdGhpcy5nbG9iYWxMb2dnZXIoKS50aHJvd0Vycm9yKFwiY2Fubm90IHBlcm1hbmVudGx5IGRpc2FibGUgY2Vuc29yc2hpcFwiLCBMb2dnZXIuZXJyb3JzLlVOU1VQUE9SVEVEX09QRVJBVElPTiwge1xuXHQgICAgICAgICAgICAgICAgb3BlcmF0aW9uOiBcInNldENlbnNvcnNoaXBcIlxuXHQgICAgICAgICAgICB9KTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgaWYgKF9wZXJtYW5lbnRDZW5zb3JFcnJvcnMpIHtcblx0ICAgICAgICAgICAgaWYgKCFjZW5zb3JzaGlwKSB7XG5cdCAgICAgICAgICAgICAgICByZXR1cm47XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgdGhpcy5nbG9iYWxMb2dnZXIoKS50aHJvd0Vycm9yKFwiZXJyb3IgY2Vuc29yc2hpcCBwZXJtYW5lbnRcIiwgTG9nZ2VyLmVycm9ycy5VTlNVUFBPUlRFRF9PUEVSQVRJT04sIHtcblx0ICAgICAgICAgICAgICAgIG9wZXJhdGlvbjogXCJzZXRDZW5zb3JzaGlwXCJcblx0ICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIF9jZW5zb3JFcnJvcnMgPSAhIWNlbnNvcnNoaXA7XG5cdCAgICAgICAgX3Blcm1hbmVudENlbnNvckVycm9ycyA9ICEhcGVybWFuZW50O1xuXHQgICAgfTtcblx0ICAgIExvZ2dlci5zZXRMb2dMZXZlbCA9IGZ1bmN0aW9uIChsb2dMZXZlbCkge1xuXHQgICAgICAgIHZhciBsZXZlbCA9IExvZ0xldmVsc1tsb2dMZXZlbC50b0xvd2VyQ2FzZSgpXTtcblx0ICAgICAgICBpZiAobGV2ZWwgPT0gbnVsbCkge1xuXHQgICAgICAgICAgICBMb2dnZXIuZ2xvYmFsTG9nZ2VyKCkud2FybihcImludmFsaWQgbG9nIGxldmVsIC0gXCIgKyBsb2dMZXZlbCk7XG5cdCAgICAgICAgICAgIHJldHVybjtcblx0ICAgICAgICB9XG5cdCAgICAgICAgX2xvZ0xldmVsID0gbGV2ZWw7XG5cdCAgICB9O1xuXHQgICAgTG9nZ2VyLmZyb20gPSBmdW5jdGlvbiAodmVyc2lvbikge1xuXHQgICAgICAgIHJldHVybiBuZXcgTG9nZ2VyKHZlcnNpb24pO1xuXHQgICAgfTtcblx0ICAgIExvZ2dlci5lcnJvcnMgPSBFcnJvckNvZGU7XG5cdCAgICBMb2dnZXIubGV2ZWxzID0gTG9nTGV2ZWw7XG5cdCAgICByZXR1cm4gTG9nZ2VyO1xuXHR9KCkpO1xuXHRleHBvcnRzLkxvZ2dlciA9IExvZ2dlcjtcblxuXHR9KTtcblxuXHR2YXIgaW5kZXggPSAvKkBfX1BVUkVfXyovZ2V0RGVmYXVsdEV4cG9ydEZyb21DanMobGliKTtcblxuXHR2YXIgX3ZlcnNpb24kMiA9IGNyZWF0ZUNvbW1vbmpzTW9kdWxlKGZ1bmN0aW9uIChtb2R1bGUsIGV4cG9ydHMpIHtcblx0XCJ1c2Ugc3RyaWN0XCI7XG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcblx0ZXhwb3J0cy52ZXJzaW9uID0gdm9pZCAwO1xuXHRleHBvcnRzLnZlcnNpb24gPSBcImJ5dGVzLzUuNS4wXCI7XG5cblx0fSk7XG5cblx0dmFyIF92ZXJzaW9uJDMgPSAvKkBfX1BVUkVfXyovZ2V0RGVmYXVsdEV4cG9ydEZyb21DanMoX3ZlcnNpb24kMik7XG5cblx0dmFyIGxpYiQxID0gY3JlYXRlQ29tbW9uanNNb2R1bGUoZnVuY3Rpb24gKG1vZHVsZSwgZXhwb3J0cykge1xuXHRcInVzZSBzdHJpY3RcIjtcblx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuXHRleHBvcnRzLmpvaW5TaWduYXR1cmUgPSBleHBvcnRzLnNwbGl0U2lnbmF0dXJlID0gZXhwb3J0cy5oZXhaZXJvUGFkID0gZXhwb3J0cy5oZXhTdHJpcFplcm9zID0gZXhwb3J0cy5oZXhWYWx1ZSA9IGV4cG9ydHMuaGV4Q29uY2F0ID0gZXhwb3J0cy5oZXhEYXRhU2xpY2UgPSBleHBvcnRzLmhleERhdGFMZW5ndGggPSBleHBvcnRzLmhleGxpZnkgPSBleHBvcnRzLmlzSGV4U3RyaW5nID0gZXhwb3J0cy56ZXJvUGFkID0gZXhwb3J0cy5zdHJpcFplcm9zID0gZXhwb3J0cy5jb25jYXQgPSBleHBvcnRzLmFycmF5aWZ5ID0gZXhwb3J0cy5pc0J5dGVzID0gZXhwb3J0cy5pc0J5dGVzTGlrZSA9IHZvaWQgMDtcblxuXG5cdHZhciBsb2dnZXIgPSBuZXcgbGliLkxvZ2dlcihfdmVyc2lvbiQyLnZlcnNpb24pO1xuXHQvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5cdGZ1bmN0aW9uIGlzSGV4YWJsZSh2YWx1ZSkge1xuXHQgICAgcmV0dXJuICEhKHZhbHVlLnRvSGV4U3RyaW5nKTtcblx0fVxuXHRmdW5jdGlvbiBhZGRTbGljZShhcnJheSkge1xuXHQgICAgaWYgKGFycmF5LnNsaWNlKSB7XG5cdCAgICAgICAgcmV0dXJuIGFycmF5O1xuXHQgICAgfVxuXHQgICAgYXJyYXkuc2xpY2UgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgdmFyIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpO1xuXHQgICAgICAgIHJldHVybiBhZGRTbGljZShuZXcgVWludDhBcnJheShBcnJheS5wcm90b3R5cGUuc2xpY2UuYXBwbHkoYXJyYXksIGFyZ3MpKSk7XG5cdCAgICB9O1xuXHQgICAgcmV0dXJuIGFycmF5O1xuXHR9XG5cdGZ1bmN0aW9uIGlzQnl0ZXNMaWtlKHZhbHVlKSB7XG5cdCAgICByZXR1cm4gKChpc0hleFN0cmluZyh2YWx1ZSkgJiYgISh2YWx1ZS5sZW5ndGggJSAyKSkgfHwgaXNCeXRlcyh2YWx1ZSkpO1xuXHR9XG5cdGV4cG9ydHMuaXNCeXRlc0xpa2UgPSBpc0J5dGVzTGlrZTtcblx0ZnVuY3Rpb24gaXNJbnRlZ2VyKHZhbHVlKSB7XG5cdCAgICByZXR1cm4gKHR5cGVvZiAodmFsdWUpID09PSBcIm51bWJlclwiICYmIHZhbHVlID09IHZhbHVlICYmICh2YWx1ZSAlIDEpID09PSAwKTtcblx0fVxuXHRmdW5jdGlvbiBpc0J5dGVzKHZhbHVlKSB7XG5cdCAgICBpZiAodmFsdWUgPT0gbnVsbCkge1xuXHQgICAgICAgIHJldHVybiBmYWxzZTtcblx0ICAgIH1cblx0ICAgIGlmICh2YWx1ZS5jb25zdHJ1Y3RvciA9PT0gVWludDhBcnJheSkge1xuXHQgICAgICAgIHJldHVybiB0cnVlO1xuXHQgICAgfVxuXHQgICAgaWYgKHR5cGVvZiAodmFsdWUpID09PSBcInN0cmluZ1wiKSB7XG5cdCAgICAgICAgcmV0dXJuIGZhbHNlO1xuXHQgICAgfVxuXHQgICAgaWYgKCFpc0ludGVnZXIodmFsdWUubGVuZ3RoKSB8fCB2YWx1ZS5sZW5ndGggPCAwKSB7XG5cdCAgICAgICAgcmV0dXJuIGZhbHNlO1xuXHQgICAgfVxuXHQgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB2YWx1ZS5sZW5ndGg7IGkrKykge1xuXHQgICAgICAgIHZhciB2ID0gdmFsdWVbaV07XG5cdCAgICAgICAgaWYgKCFpc0ludGVnZXIodikgfHwgdiA8IDAgfHwgdiA+PSAyNTYpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuXHQgICAgICAgIH1cblx0ICAgIH1cblx0ICAgIHJldHVybiB0cnVlO1xuXHR9XG5cdGV4cG9ydHMuaXNCeXRlcyA9IGlzQnl0ZXM7XG5cdGZ1bmN0aW9uIGFycmF5aWZ5KHZhbHVlLCBvcHRpb25zKSB7XG5cdCAgICBpZiAoIW9wdGlvbnMpIHtcblx0ICAgICAgICBvcHRpb25zID0ge307XG5cdCAgICB9XG5cdCAgICBpZiAodHlwZW9mICh2YWx1ZSkgPT09IFwibnVtYmVyXCIpIHtcblx0ICAgICAgICBsb2dnZXIuY2hlY2tTYWZlVWludDUzKHZhbHVlLCBcImludmFsaWQgYXJyYXlpZnkgdmFsdWVcIik7XG5cdCAgICAgICAgdmFyIHJlc3VsdCA9IFtdO1xuXHQgICAgICAgIHdoaWxlICh2YWx1ZSkge1xuXHQgICAgICAgICAgICByZXN1bHQudW5zaGlmdCh2YWx1ZSAmIDB4ZmYpO1xuXHQgICAgICAgICAgICB2YWx1ZSA9IHBhcnNlSW50KFN0cmluZyh2YWx1ZSAvIDI1NikpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBpZiAocmVzdWx0Lmxlbmd0aCA9PT0gMCkge1xuXHQgICAgICAgICAgICByZXN1bHQucHVzaCgwKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgcmV0dXJuIGFkZFNsaWNlKG5ldyBVaW50OEFycmF5KHJlc3VsdCkpO1xuXHQgICAgfVxuXHQgICAgaWYgKG9wdGlvbnMuYWxsb3dNaXNzaW5nUHJlZml4ICYmIHR5cGVvZiAodmFsdWUpID09PSBcInN0cmluZ1wiICYmIHZhbHVlLnN1YnN0cmluZygwLCAyKSAhPT0gXCIweFwiKSB7XG5cdCAgICAgICAgdmFsdWUgPSBcIjB4XCIgKyB2YWx1ZTtcblx0ICAgIH1cblx0ICAgIGlmIChpc0hleGFibGUodmFsdWUpKSB7XG5cdCAgICAgICAgdmFsdWUgPSB2YWx1ZS50b0hleFN0cmluZygpO1xuXHQgICAgfVxuXHQgICAgaWYgKGlzSGV4U3RyaW5nKHZhbHVlKSkge1xuXHQgICAgICAgIHZhciBoZXggPSB2YWx1ZS5zdWJzdHJpbmcoMik7XG5cdCAgICAgICAgaWYgKGhleC5sZW5ndGggJSAyKSB7XG5cdCAgICAgICAgICAgIGlmIChvcHRpb25zLmhleFBhZCA9PT0gXCJsZWZ0XCIpIHtcblx0ICAgICAgICAgICAgICAgIGhleCA9IFwiMHgwXCIgKyBoZXguc3Vic3RyaW5nKDIpO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIGVsc2UgaWYgKG9wdGlvbnMuaGV4UGFkID09PSBcInJpZ2h0XCIpIHtcblx0ICAgICAgICAgICAgICAgIGhleCArPSBcIjBcIjtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICBlbHNlIHtcblx0ICAgICAgICAgICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJoZXggZGF0YSBpcyBvZGQtbGVuZ3RoXCIsIFwidmFsdWVcIiwgdmFsdWUpO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHZhciByZXN1bHQgPSBbXTtcblx0ICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGhleC5sZW5ndGg7IGkgKz0gMikge1xuXHQgICAgICAgICAgICByZXN1bHQucHVzaChwYXJzZUludChoZXguc3Vic3RyaW5nKGksIGkgKyAyKSwgMTYpKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgcmV0dXJuIGFkZFNsaWNlKG5ldyBVaW50OEFycmF5KHJlc3VsdCkpO1xuXHQgICAgfVxuXHQgICAgaWYgKGlzQnl0ZXModmFsdWUpKSB7XG5cdCAgICAgICAgcmV0dXJuIGFkZFNsaWNlKG5ldyBVaW50OEFycmF5KHZhbHVlKSk7XG5cdCAgICB9XG5cdCAgICByZXR1cm4gbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcImludmFsaWQgYXJyYXlpZnkgdmFsdWVcIiwgXCJ2YWx1ZVwiLCB2YWx1ZSk7XG5cdH1cblx0ZXhwb3J0cy5hcnJheWlmeSA9IGFycmF5aWZ5O1xuXHRmdW5jdGlvbiBjb25jYXQoaXRlbXMpIHtcblx0ICAgIHZhciBvYmplY3RzID0gaXRlbXMubWFwKGZ1bmN0aW9uIChpdGVtKSB7IHJldHVybiBhcnJheWlmeShpdGVtKTsgfSk7XG5cdCAgICB2YXIgbGVuZ3RoID0gb2JqZWN0cy5yZWR1Y2UoZnVuY3Rpb24gKGFjY3VtLCBpdGVtKSB7IHJldHVybiAoYWNjdW0gKyBpdGVtLmxlbmd0aCk7IH0sIDApO1xuXHQgICAgdmFyIHJlc3VsdCA9IG5ldyBVaW50OEFycmF5KGxlbmd0aCk7XG5cdCAgICBvYmplY3RzLnJlZHVjZShmdW5jdGlvbiAob2Zmc2V0LCBvYmplY3QpIHtcblx0ICAgICAgICByZXN1bHQuc2V0KG9iamVjdCwgb2Zmc2V0KTtcblx0ICAgICAgICByZXR1cm4gb2Zmc2V0ICsgb2JqZWN0Lmxlbmd0aDtcblx0ICAgIH0sIDApO1xuXHQgICAgcmV0dXJuIGFkZFNsaWNlKHJlc3VsdCk7XG5cdH1cblx0ZXhwb3J0cy5jb25jYXQgPSBjb25jYXQ7XG5cdGZ1bmN0aW9uIHN0cmlwWmVyb3ModmFsdWUpIHtcblx0ICAgIHZhciByZXN1bHQgPSBhcnJheWlmeSh2YWx1ZSk7XG5cdCAgICBpZiAocmVzdWx0Lmxlbmd0aCA9PT0gMCkge1xuXHQgICAgICAgIHJldHVybiByZXN1bHQ7XG5cdCAgICB9XG5cdCAgICAvLyBGaW5kIHRoZSBmaXJzdCBub24temVybyBlbnRyeVxuXHQgICAgdmFyIHN0YXJ0ID0gMDtcblx0ICAgIHdoaWxlIChzdGFydCA8IHJlc3VsdC5sZW5ndGggJiYgcmVzdWx0W3N0YXJ0XSA9PT0gMCkge1xuXHQgICAgICAgIHN0YXJ0Kys7XG5cdCAgICB9XG5cdCAgICAvLyBJZiB3ZSBzdGFydGVkIHdpdGggemVyb3MsIHN0cmlwIHRoZW1cblx0ICAgIGlmIChzdGFydCkge1xuXHQgICAgICAgIHJlc3VsdCA9IHJlc3VsdC5zbGljZShzdGFydCk7XG5cdCAgICB9XG5cdCAgICByZXR1cm4gcmVzdWx0O1xuXHR9XG5cdGV4cG9ydHMuc3RyaXBaZXJvcyA9IHN0cmlwWmVyb3M7XG5cdGZ1bmN0aW9uIHplcm9QYWQodmFsdWUsIGxlbmd0aCkge1xuXHQgICAgdmFsdWUgPSBhcnJheWlmeSh2YWx1ZSk7XG5cdCAgICBpZiAodmFsdWUubGVuZ3RoID4gbGVuZ3RoKSB7XG5cdCAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcInZhbHVlIG91dCBvZiByYW5nZVwiLCBcInZhbHVlXCIsIGFyZ3VtZW50c1swXSk7XG5cdCAgICB9XG5cdCAgICB2YXIgcmVzdWx0ID0gbmV3IFVpbnQ4QXJyYXkobGVuZ3RoKTtcblx0ICAgIHJlc3VsdC5zZXQodmFsdWUsIGxlbmd0aCAtIHZhbHVlLmxlbmd0aCk7XG5cdCAgICByZXR1cm4gYWRkU2xpY2UocmVzdWx0KTtcblx0fVxuXHRleHBvcnRzLnplcm9QYWQgPSB6ZXJvUGFkO1xuXHRmdW5jdGlvbiBpc0hleFN0cmluZyh2YWx1ZSwgbGVuZ3RoKSB7XG5cdCAgICBpZiAodHlwZW9mICh2YWx1ZSkgIT09IFwic3RyaW5nXCIgfHwgIXZhbHVlLm1hdGNoKC9eMHhbMC05QS1GYS1mXSokLykpIHtcblx0ICAgICAgICByZXR1cm4gZmFsc2U7XG5cdCAgICB9XG5cdCAgICBpZiAobGVuZ3RoICYmIHZhbHVlLmxlbmd0aCAhPT0gMiArIDIgKiBsZW5ndGgpIHtcblx0ICAgICAgICByZXR1cm4gZmFsc2U7XG5cdCAgICB9XG5cdCAgICByZXR1cm4gdHJ1ZTtcblx0fVxuXHRleHBvcnRzLmlzSGV4U3RyaW5nID0gaXNIZXhTdHJpbmc7XG5cdHZhciBIZXhDaGFyYWN0ZXJzID0gXCIwMTIzNDU2Nzg5YWJjZGVmXCI7XG5cdGZ1bmN0aW9uIGhleGxpZnkodmFsdWUsIG9wdGlvbnMpIHtcblx0ICAgIGlmICghb3B0aW9ucykge1xuXHQgICAgICAgIG9wdGlvbnMgPSB7fTtcblx0ICAgIH1cblx0ICAgIGlmICh0eXBlb2YgKHZhbHVlKSA9PT0gXCJudW1iZXJcIikge1xuXHQgICAgICAgIGxvZ2dlci5jaGVja1NhZmVVaW50NTModmFsdWUsIFwiaW52YWxpZCBoZXhsaWZ5IHZhbHVlXCIpO1xuXHQgICAgICAgIHZhciBoZXggPSBcIlwiO1xuXHQgICAgICAgIHdoaWxlICh2YWx1ZSkge1xuXHQgICAgICAgICAgICBoZXggPSBIZXhDaGFyYWN0ZXJzW3ZhbHVlICYgMHhmXSArIGhleDtcblx0ICAgICAgICAgICAgdmFsdWUgPSBNYXRoLmZsb29yKHZhbHVlIC8gMTYpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBpZiAoaGV4Lmxlbmd0aCkge1xuXHQgICAgICAgICAgICBpZiAoaGV4Lmxlbmd0aCAlIDIpIHtcblx0ICAgICAgICAgICAgICAgIGhleCA9IFwiMFwiICsgaGV4O1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIHJldHVybiBcIjB4XCIgKyBoZXg7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHJldHVybiBcIjB4MDBcIjtcblx0ICAgIH1cblx0ICAgIGlmICh0eXBlb2YgKHZhbHVlKSA9PT0gXCJiaWdpbnRcIikge1xuXHQgICAgICAgIHZhbHVlID0gdmFsdWUudG9TdHJpbmcoMTYpO1xuXHQgICAgICAgIGlmICh2YWx1ZS5sZW5ndGggJSAyKSB7XG5cdCAgICAgICAgICAgIHJldHVybiAoXCIweDBcIiArIHZhbHVlKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgcmV0dXJuIFwiMHhcIiArIHZhbHVlO1xuXHQgICAgfVxuXHQgICAgaWYgKG9wdGlvbnMuYWxsb3dNaXNzaW5nUHJlZml4ICYmIHR5cGVvZiAodmFsdWUpID09PSBcInN0cmluZ1wiICYmIHZhbHVlLnN1YnN0cmluZygwLCAyKSAhPT0gXCIweFwiKSB7XG5cdCAgICAgICAgdmFsdWUgPSBcIjB4XCIgKyB2YWx1ZTtcblx0ICAgIH1cblx0ICAgIGlmIChpc0hleGFibGUodmFsdWUpKSB7XG5cdCAgICAgICAgcmV0dXJuIHZhbHVlLnRvSGV4U3RyaW5nKCk7XG5cdCAgICB9XG5cdCAgICBpZiAoaXNIZXhTdHJpbmcodmFsdWUpKSB7XG5cdCAgICAgICAgaWYgKHZhbHVlLmxlbmd0aCAlIDIpIHtcblx0ICAgICAgICAgICAgaWYgKG9wdGlvbnMuaGV4UGFkID09PSBcImxlZnRcIikge1xuXHQgICAgICAgICAgICAgICAgdmFsdWUgPSBcIjB4MFwiICsgdmFsdWUuc3Vic3RyaW5nKDIpO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIGVsc2UgaWYgKG9wdGlvbnMuaGV4UGFkID09PSBcInJpZ2h0XCIpIHtcblx0ICAgICAgICAgICAgICAgIHZhbHVlICs9IFwiMFwiO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIGVsc2Uge1xuXHQgICAgICAgICAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcImhleCBkYXRhIGlzIG9kZC1sZW5ndGhcIiwgXCJ2YWx1ZVwiLCB2YWx1ZSk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9XG5cdCAgICAgICAgcmV0dXJuIHZhbHVlLnRvTG93ZXJDYXNlKCk7XG5cdCAgICB9XG5cdCAgICBpZiAoaXNCeXRlcyh2YWx1ZSkpIHtcblx0ICAgICAgICB2YXIgcmVzdWx0ID0gXCIweFwiO1xuXHQgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdmFsdWUubGVuZ3RoOyBpKyspIHtcblx0ICAgICAgICAgICAgdmFyIHYgPSB2YWx1ZVtpXTtcblx0ICAgICAgICAgICAgcmVzdWx0ICs9IEhleENoYXJhY3RlcnNbKHYgJiAweGYwKSA+PiA0XSArIEhleENoYXJhY3RlcnNbdiAmIDB4MGZdO1xuXHQgICAgICAgIH1cblx0ICAgICAgICByZXR1cm4gcmVzdWx0O1xuXHQgICAgfVxuXHQgICAgcmV0dXJuIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJpbnZhbGlkIGhleGxpZnkgdmFsdWVcIiwgXCJ2YWx1ZVwiLCB2YWx1ZSk7XG5cdH1cblx0ZXhwb3J0cy5oZXhsaWZ5ID0gaGV4bGlmeTtcblx0Lypcblx0ZnVuY3Rpb24gdW5vZGRpZnkodmFsdWU6IEJ5dGVzTGlrZSB8IEhleGFibGUgfCBudW1iZXIpOiBCeXRlc0xpa2UgfCBIZXhhYmxlIHwgbnVtYmVyIHtcblx0ICAgIGlmICh0eXBlb2YodmFsdWUpID09PSBcInN0cmluZ1wiICYmIHZhbHVlLmxlbmd0aCAlIDIgJiYgdmFsdWUuc3Vic3RyaW5nKDAsIDIpID09PSBcIjB4XCIpIHtcblx0ICAgICAgICByZXR1cm4gXCIweDBcIiArIHZhbHVlLnN1YnN0cmluZygyKTtcblx0ICAgIH1cblx0ICAgIHJldHVybiB2YWx1ZTtcblx0fVxuXHQqL1xuXHRmdW5jdGlvbiBoZXhEYXRhTGVuZ3RoKGRhdGEpIHtcblx0ICAgIGlmICh0eXBlb2YgKGRhdGEpICE9PSBcInN0cmluZ1wiKSB7XG5cdCAgICAgICAgZGF0YSA9IGhleGxpZnkoZGF0YSk7XG5cdCAgICB9XG5cdCAgICBlbHNlIGlmICghaXNIZXhTdHJpbmcoZGF0YSkgfHwgKGRhdGEubGVuZ3RoICUgMikpIHtcblx0ICAgICAgICByZXR1cm4gbnVsbDtcblx0ICAgIH1cblx0ICAgIHJldHVybiAoZGF0YS5sZW5ndGggLSAyKSAvIDI7XG5cdH1cblx0ZXhwb3J0cy5oZXhEYXRhTGVuZ3RoID0gaGV4RGF0YUxlbmd0aDtcblx0ZnVuY3Rpb24gaGV4RGF0YVNsaWNlKGRhdGEsIG9mZnNldCwgZW5kT2Zmc2V0KSB7XG5cdCAgICBpZiAodHlwZW9mIChkYXRhKSAhPT0gXCJzdHJpbmdcIikge1xuXHQgICAgICAgIGRhdGEgPSBoZXhsaWZ5KGRhdGEpO1xuXHQgICAgfVxuXHQgICAgZWxzZSBpZiAoIWlzSGV4U3RyaW5nKGRhdGEpIHx8IChkYXRhLmxlbmd0aCAlIDIpKSB7XG5cdCAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcImludmFsaWQgaGV4RGF0YVwiLCBcInZhbHVlXCIsIGRhdGEpO1xuXHQgICAgfVxuXHQgICAgb2Zmc2V0ID0gMiArIDIgKiBvZmZzZXQ7XG5cdCAgICBpZiAoZW5kT2Zmc2V0ICE9IG51bGwpIHtcblx0ICAgICAgICByZXR1cm4gXCIweFwiICsgZGF0YS5zdWJzdHJpbmcob2Zmc2V0LCAyICsgMiAqIGVuZE9mZnNldCk7XG5cdCAgICB9XG5cdCAgICByZXR1cm4gXCIweFwiICsgZGF0YS5zdWJzdHJpbmcob2Zmc2V0KTtcblx0fVxuXHRleHBvcnRzLmhleERhdGFTbGljZSA9IGhleERhdGFTbGljZTtcblx0ZnVuY3Rpb24gaGV4Q29uY2F0KGl0ZW1zKSB7XG5cdCAgICB2YXIgcmVzdWx0ID0gXCIweFwiO1xuXHQgICAgaXRlbXMuZm9yRWFjaChmdW5jdGlvbiAoaXRlbSkge1xuXHQgICAgICAgIHJlc3VsdCArPSBoZXhsaWZ5KGl0ZW0pLnN1YnN0cmluZygyKTtcblx0ICAgIH0pO1xuXHQgICAgcmV0dXJuIHJlc3VsdDtcblx0fVxuXHRleHBvcnRzLmhleENvbmNhdCA9IGhleENvbmNhdDtcblx0ZnVuY3Rpb24gaGV4VmFsdWUodmFsdWUpIHtcblx0ICAgIHZhciB0cmltbWVkID0gaGV4U3RyaXBaZXJvcyhoZXhsaWZ5KHZhbHVlLCB7IGhleFBhZDogXCJsZWZ0XCIgfSkpO1xuXHQgICAgaWYgKHRyaW1tZWQgPT09IFwiMHhcIikge1xuXHQgICAgICAgIHJldHVybiBcIjB4MFwiO1xuXHQgICAgfVxuXHQgICAgcmV0dXJuIHRyaW1tZWQ7XG5cdH1cblx0ZXhwb3J0cy5oZXhWYWx1ZSA9IGhleFZhbHVlO1xuXHRmdW5jdGlvbiBoZXhTdHJpcFplcm9zKHZhbHVlKSB7XG5cdCAgICBpZiAodHlwZW9mICh2YWx1ZSkgIT09IFwic3RyaW5nXCIpIHtcblx0ICAgICAgICB2YWx1ZSA9IGhleGxpZnkodmFsdWUpO1xuXHQgICAgfVxuXHQgICAgaWYgKCFpc0hleFN0cmluZyh2YWx1ZSkpIHtcblx0ICAgICAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwiaW52YWxpZCBoZXggc3RyaW5nXCIsIFwidmFsdWVcIiwgdmFsdWUpO1xuXHQgICAgfVxuXHQgICAgdmFsdWUgPSB2YWx1ZS5zdWJzdHJpbmcoMik7XG5cdCAgICB2YXIgb2Zmc2V0ID0gMDtcblx0ICAgIHdoaWxlIChvZmZzZXQgPCB2YWx1ZS5sZW5ndGggJiYgdmFsdWVbb2Zmc2V0XSA9PT0gXCIwXCIpIHtcblx0ICAgICAgICBvZmZzZXQrKztcblx0ICAgIH1cblx0ICAgIHJldHVybiBcIjB4XCIgKyB2YWx1ZS5zdWJzdHJpbmcob2Zmc2V0KTtcblx0fVxuXHRleHBvcnRzLmhleFN0cmlwWmVyb3MgPSBoZXhTdHJpcFplcm9zO1xuXHRmdW5jdGlvbiBoZXhaZXJvUGFkKHZhbHVlLCBsZW5ndGgpIHtcblx0ICAgIGlmICh0eXBlb2YgKHZhbHVlKSAhPT0gXCJzdHJpbmdcIikge1xuXHQgICAgICAgIHZhbHVlID0gaGV4bGlmeSh2YWx1ZSk7XG5cdCAgICB9XG5cdCAgICBlbHNlIGlmICghaXNIZXhTdHJpbmcodmFsdWUpKSB7XG5cdCAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcImludmFsaWQgaGV4IHN0cmluZ1wiLCBcInZhbHVlXCIsIHZhbHVlKTtcblx0ICAgIH1cblx0ICAgIGlmICh2YWx1ZS5sZW5ndGggPiAyICogbGVuZ3RoICsgMikge1xuXHQgICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJ2YWx1ZSBvdXQgb2YgcmFuZ2VcIiwgXCJ2YWx1ZVwiLCBhcmd1bWVudHNbMV0pO1xuXHQgICAgfVxuXHQgICAgd2hpbGUgKHZhbHVlLmxlbmd0aCA8IDIgKiBsZW5ndGggKyAyKSB7XG5cdCAgICAgICAgdmFsdWUgPSBcIjB4MFwiICsgdmFsdWUuc3Vic3RyaW5nKDIpO1xuXHQgICAgfVxuXHQgICAgcmV0dXJuIHZhbHVlO1xuXHR9XG5cdGV4cG9ydHMuaGV4WmVyb1BhZCA9IGhleFplcm9QYWQ7XG5cdGZ1bmN0aW9uIHNwbGl0U2lnbmF0dXJlKHNpZ25hdHVyZSkge1xuXHQgICAgdmFyIHJlc3VsdCA9IHtcblx0ICAgICAgICByOiBcIjB4XCIsXG5cdCAgICAgICAgczogXCIweFwiLFxuXHQgICAgICAgIF92czogXCIweFwiLFxuXHQgICAgICAgIHJlY292ZXJ5UGFyYW06IDAsXG5cdCAgICAgICAgdjogMFxuXHQgICAgfTtcblx0ICAgIGlmIChpc0J5dGVzTGlrZShzaWduYXR1cmUpKSB7XG5cdCAgICAgICAgdmFyIGJ5dGVzID0gYXJyYXlpZnkoc2lnbmF0dXJlKTtcblx0ICAgICAgICBpZiAoYnl0ZXMubGVuZ3RoICE9PSA2NSkge1xuXHQgICAgICAgICAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwiaW52YWxpZCBzaWduYXR1cmUgc3RyaW5nOyBtdXN0IGJlIDY1IGJ5dGVzXCIsIFwic2lnbmF0dXJlXCIsIHNpZ25hdHVyZSk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIC8vIEdldCB0aGUgciwgcyBhbmQgdlxuXHQgICAgICAgIHJlc3VsdC5yID0gaGV4bGlmeShieXRlcy5zbGljZSgwLCAzMikpO1xuXHQgICAgICAgIHJlc3VsdC5zID0gaGV4bGlmeShieXRlcy5zbGljZSgzMiwgNjQpKTtcblx0ICAgICAgICByZXN1bHQudiA9IGJ5dGVzWzY0XTtcblx0ICAgICAgICAvLyBBbGxvdyBhIHJlY2lkIHRvIGJlIHVzZWQgYXMgdGhlIHZcblx0ICAgICAgICBpZiAocmVzdWx0LnYgPCAyNykge1xuXHQgICAgICAgICAgICBpZiAocmVzdWx0LnYgPT09IDAgfHwgcmVzdWx0LnYgPT09IDEpIHtcblx0ICAgICAgICAgICAgICAgIHJlc3VsdC52ICs9IDI3O1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIGVsc2Uge1xuXHQgICAgICAgICAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcInNpZ25hdHVyZSBpbnZhbGlkIHYgYnl0ZVwiLCBcInNpZ25hdHVyZVwiLCBzaWduYXR1cmUpO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfVxuXHQgICAgICAgIC8vIENvbXB1dGUgcmVjb3ZlcnlQYXJhbSBmcm9tIHZcblx0ICAgICAgICByZXN1bHQucmVjb3ZlcnlQYXJhbSA9IDEgLSAocmVzdWx0LnYgJSAyKTtcblx0ICAgICAgICAvLyBDb21wdXRlIF92cyBmcm9tIHJlY292ZXJ5UGFyYW0gYW5kIHNcblx0ICAgICAgICBpZiAocmVzdWx0LnJlY292ZXJ5UGFyYW0pIHtcblx0ICAgICAgICAgICAgYnl0ZXNbMzJdIHw9IDB4ODA7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHJlc3VsdC5fdnMgPSBoZXhsaWZ5KGJ5dGVzLnNsaWNlKDMyLCA2NCkpO1xuXHQgICAgfVxuXHQgICAgZWxzZSB7XG5cdCAgICAgICAgcmVzdWx0LnIgPSBzaWduYXR1cmUucjtcblx0ICAgICAgICByZXN1bHQucyA9IHNpZ25hdHVyZS5zO1xuXHQgICAgICAgIHJlc3VsdC52ID0gc2lnbmF0dXJlLnY7XG5cdCAgICAgICAgcmVzdWx0LnJlY292ZXJ5UGFyYW0gPSBzaWduYXR1cmUucmVjb3ZlcnlQYXJhbTtcblx0ICAgICAgICByZXN1bHQuX3ZzID0gc2lnbmF0dXJlLl92cztcblx0ICAgICAgICAvLyBJZiB0aGUgX3ZzIGlzIGF2YWlsYWJsZSwgdXNlIGl0IHRvIHBvcHVsYXRlIG1pc3NpbmcgcywgdiBhbmQgcmVjb3ZlcnlQYXJhbVxuXHQgICAgICAgIC8vIGFuZCB2ZXJpZnkgbm9uLW1pc3NpbmcgcywgdiBhbmQgcmVjb3ZlcnlQYXJhbVxuXHQgICAgICAgIGlmIChyZXN1bHQuX3ZzICE9IG51bGwpIHtcblx0ICAgICAgICAgICAgdmFyIHZzXzEgPSB6ZXJvUGFkKGFycmF5aWZ5KHJlc3VsdC5fdnMpLCAzMik7XG5cdCAgICAgICAgICAgIHJlc3VsdC5fdnMgPSBoZXhsaWZ5KHZzXzEpO1xuXHQgICAgICAgICAgICAvLyBTZXQgb3IgY2hlY2sgdGhlIHJlY2lkXG5cdCAgICAgICAgICAgIHZhciByZWNvdmVyeVBhcmFtID0gKCh2c18xWzBdID49IDEyOCkgPyAxIDogMCk7XG5cdCAgICAgICAgICAgIGlmIChyZXN1bHQucmVjb3ZlcnlQYXJhbSA9PSBudWxsKSB7XG5cdCAgICAgICAgICAgICAgICByZXN1bHQucmVjb3ZlcnlQYXJhbSA9IHJlY292ZXJ5UGFyYW07XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgZWxzZSBpZiAocmVzdWx0LnJlY292ZXJ5UGFyYW0gIT09IHJlY292ZXJ5UGFyYW0pIHtcblx0ICAgICAgICAgICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJzaWduYXR1cmUgcmVjb3ZlcnlQYXJhbSBtaXNtYXRjaCBfdnNcIiwgXCJzaWduYXR1cmVcIiwgc2lnbmF0dXJlKTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAvLyBTZXQgb3IgY2hlY2sgdGhlIHNcblx0ICAgICAgICAgICAgdnNfMVswXSAmPSAweDdmO1xuXHQgICAgICAgICAgICB2YXIgcyA9IGhleGxpZnkodnNfMSk7XG5cdCAgICAgICAgICAgIGlmIChyZXN1bHQucyA9PSBudWxsKSB7XG5cdCAgICAgICAgICAgICAgICByZXN1bHQucyA9IHM7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgZWxzZSBpZiAocmVzdWx0LnMgIT09IHMpIHtcblx0ICAgICAgICAgICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJzaWduYXR1cmUgdiBtaXNtYXRjaCBfdnNcIiwgXCJzaWduYXR1cmVcIiwgc2lnbmF0dXJlKTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH1cblx0ICAgICAgICAvLyBVc2UgcmVjaWQgYW5kIHYgdG8gcG9wdWxhdGUgZWFjaCBvdGhlclxuXHQgICAgICAgIGlmIChyZXN1bHQucmVjb3ZlcnlQYXJhbSA9PSBudWxsKSB7XG5cdCAgICAgICAgICAgIGlmIChyZXN1bHQudiA9PSBudWxsKSB7XG5cdCAgICAgICAgICAgICAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwic2lnbmF0dXJlIG1pc3NpbmcgdiBhbmQgcmVjb3ZlcnlQYXJhbVwiLCBcInNpZ25hdHVyZVwiLCBzaWduYXR1cmUpO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIGVsc2UgaWYgKHJlc3VsdC52ID09PSAwIHx8IHJlc3VsdC52ID09PSAxKSB7XG5cdCAgICAgICAgICAgICAgICByZXN1bHQucmVjb3ZlcnlQYXJhbSA9IHJlc3VsdC52O1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIGVsc2Uge1xuXHQgICAgICAgICAgICAgICAgcmVzdWx0LnJlY292ZXJ5UGFyYW0gPSAxIC0gKHJlc3VsdC52ICUgMik7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9XG5cdCAgICAgICAgZWxzZSB7XG5cdCAgICAgICAgICAgIGlmIChyZXN1bHQudiA9PSBudWxsKSB7XG5cdCAgICAgICAgICAgICAgICByZXN1bHQudiA9IDI3ICsgcmVzdWx0LnJlY292ZXJ5UGFyYW07XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgZWxzZSB7XG5cdCAgICAgICAgICAgICAgICB2YXIgcmVjSWQgPSAocmVzdWx0LnYgPT09IDAgfHwgcmVzdWx0LnYgPT09IDEpID8gcmVzdWx0LnYgOiAoMSAtIChyZXN1bHQudiAlIDIpKTtcblx0ICAgICAgICAgICAgICAgIGlmIChyZXN1bHQucmVjb3ZlcnlQYXJhbSAhPT0gcmVjSWQpIHtcblx0ICAgICAgICAgICAgICAgICAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwic2lnbmF0dXJlIHJlY292ZXJ5UGFyYW0gbWlzbWF0Y2ggdlwiLCBcInNpZ25hdHVyZVwiLCBzaWduYXR1cmUpO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGlmIChyZXN1bHQuciA9PSBudWxsIHx8ICFpc0hleFN0cmluZyhyZXN1bHQucikpIHtcblx0ICAgICAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcInNpZ25hdHVyZSBtaXNzaW5nIG9yIGludmFsaWQgclwiLCBcInNpZ25hdHVyZVwiLCBzaWduYXR1cmUpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBlbHNlIHtcblx0ICAgICAgICAgICAgcmVzdWx0LnIgPSBoZXhaZXJvUGFkKHJlc3VsdC5yLCAzMik7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGlmIChyZXN1bHQucyA9PSBudWxsIHx8ICFpc0hleFN0cmluZyhyZXN1bHQucykpIHtcblx0ICAgICAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcInNpZ25hdHVyZSBtaXNzaW5nIG9yIGludmFsaWQgc1wiLCBcInNpZ25hdHVyZVwiLCBzaWduYXR1cmUpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBlbHNlIHtcblx0ICAgICAgICAgICAgcmVzdWx0LnMgPSBoZXhaZXJvUGFkKHJlc3VsdC5zLCAzMik7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHZhciB2cyA9IGFycmF5aWZ5KHJlc3VsdC5zKTtcblx0ICAgICAgICBpZiAodnNbMF0gPj0gMTI4KSB7XG5cdCAgICAgICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJzaWduYXR1cmUgcyBvdXQgb2YgcmFuZ2VcIiwgXCJzaWduYXR1cmVcIiwgc2lnbmF0dXJlKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgaWYgKHJlc3VsdC5yZWNvdmVyeVBhcmFtKSB7XG5cdCAgICAgICAgICAgIHZzWzBdIHw9IDB4ODA7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHZhciBfdnMgPSBoZXhsaWZ5KHZzKTtcblx0ICAgICAgICBpZiAocmVzdWx0Ll92cykge1xuXHQgICAgICAgICAgICBpZiAoIWlzSGV4U3RyaW5nKHJlc3VsdC5fdnMpKSB7XG5cdCAgICAgICAgICAgICAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwic2lnbmF0dXJlIGludmFsaWQgX3ZzXCIsIFwic2lnbmF0dXJlXCIsIHNpZ25hdHVyZSk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgcmVzdWx0Ll92cyA9IGhleFplcm9QYWQocmVzdWx0Ll92cywgMzIpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICAvLyBTZXQgb3IgY2hlY2sgdGhlIF92c1xuXHQgICAgICAgIGlmIChyZXN1bHQuX3ZzID09IG51bGwpIHtcblx0ICAgICAgICAgICAgcmVzdWx0Ll92cyA9IF92cztcblx0ICAgICAgICB9XG5cdCAgICAgICAgZWxzZSBpZiAocmVzdWx0Ll92cyAhPT0gX3ZzKSB7XG5cdCAgICAgICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJzaWduYXR1cmUgX3ZzIG1pc21hdGNoIHYgYW5kIHNcIiwgXCJzaWduYXR1cmVcIiwgc2lnbmF0dXJlKTtcblx0ICAgICAgICB9XG5cdCAgICB9XG5cdCAgICByZXR1cm4gcmVzdWx0O1xuXHR9XG5cdGV4cG9ydHMuc3BsaXRTaWduYXR1cmUgPSBzcGxpdFNpZ25hdHVyZTtcblx0ZnVuY3Rpb24gam9pblNpZ25hdHVyZShzaWduYXR1cmUpIHtcblx0ICAgIHNpZ25hdHVyZSA9IHNwbGl0U2lnbmF0dXJlKHNpZ25hdHVyZSk7XG5cdCAgICByZXR1cm4gaGV4bGlmeShjb25jYXQoW1xuXHQgICAgICAgIHNpZ25hdHVyZS5yLFxuXHQgICAgICAgIHNpZ25hdHVyZS5zLFxuXHQgICAgICAgIChzaWduYXR1cmUucmVjb3ZlcnlQYXJhbSA/IFwiMHgxY1wiIDogXCIweDFiXCIpXG5cdCAgICBdKSk7XG5cdH1cblx0ZXhwb3J0cy5qb2luU2lnbmF0dXJlID0gam9pblNpZ25hdHVyZTtcblxuXHR9KTtcblxuXHR2YXIgaW5kZXgkMSA9IC8qQF9fUFVSRV9fKi9nZXREZWZhdWx0RXhwb3J0RnJvbUNqcyhsaWIkMSk7XG5cblx0dmFyIF92ZXJzaW9uJDQgPSBjcmVhdGVDb21tb25qc01vZHVsZShmdW5jdGlvbiAobW9kdWxlLCBleHBvcnRzKSB7XG5cdFwidXNlIHN0cmljdFwiO1xuXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5cdGV4cG9ydHMudmVyc2lvbiA9IHZvaWQgMDtcblx0ZXhwb3J0cy52ZXJzaW9uID0gXCJiaWdudW1iZXIvNS41LjBcIjtcblxuXHR9KTtcblxuXHR2YXIgX3ZlcnNpb24kNSA9IC8qQF9fUFVSRV9fKi9nZXREZWZhdWx0RXhwb3J0RnJvbUNqcyhfdmVyc2lvbiQ0KTtcblxuXHR2YXIgYmlnbnVtYmVyID0gY3JlYXRlQ29tbW9uanNNb2R1bGUoZnVuY3Rpb24gKG1vZHVsZSwgZXhwb3J0cykge1xuXHRcInVzZSBzdHJpY3RcIjtcblx0dmFyIF9faW1wb3J0RGVmYXVsdCA9IChjb21tb25qc0dsb2JhbCAmJiBjb21tb25qc0dsb2JhbC5fX2ltcG9ydERlZmF1bHQpIHx8IGZ1bmN0aW9uIChtb2QpIHtcblx0ICAgIHJldHVybiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSA/IG1vZCA6IHsgXCJkZWZhdWx0XCI6IG1vZCB9O1xuXHR9O1xuXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5cdGV4cG9ydHMuX2Jhc2UxNlRvMzYgPSBleHBvcnRzLl9iYXNlMzZUbzE2ID0gZXhwb3J0cy5CaWdOdW1iZXIgPSBleHBvcnRzLmlzQmlnTnVtYmVyaXNoID0gdm9pZCAwO1xuXHQvKipcblx0ICogIEJpZ051bWJlclxuXHQgKlxuXHQgKiAgQSB3cmFwcGVyIGFyb3VuZCB0aGUgQk4uanMgb2JqZWN0LiBXZSB1c2UgdGhlIEJOLmpzIGxpYnJhcnlcblx0ICogIGJlY2F1c2UgaXQgaXMgdXNlZCBieSBlbGxpcHRpYywgc28gaXQgaXMgcmVxdWlyZWQgcmVnYXJkbGVzcy5cblx0ICpcblx0ICovXG5cdHZhciBibl9qc18xID0gX19pbXBvcnREZWZhdWx0KGJuKTtcblx0dmFyIEJOID0gYm5fanNfMS5kZWZhdWx0LkJOO1xuXG5cblxuXHR2YXIgbG9nZ2VyID0gbmV3IGxpYi5Mb2dnZXIoX3ZlcnNpb24kNC52ZXJzaW9uKTtcblx0dmFyIF9jb25zdHJ1Y3Rvckd1YXJkID0ge307XG5cdHZhciBNQVhfU0FGRSA9IDB4MWZmZmZmZmZmZmZmZmY7XG5cdGZ1bmN0aW9uIGlzQmlnTnVtYmVyaXNoKHZhbHVlKSB7XG5cdCAgICByZXR1cm4gKHZhbHVlICE9IG51bGwpICYmIChCaWdOdW1iZXIuaXNCaWdOdW1iZXIodmFsdWUpIHx8XG5cdCAgICAgICAgKHR5cGVvZiAodmFsdWUpID09PSBcIm51bWJlclwiICYmICh2YWx1ZSAlIDEpID09PSAwKSB8fFxuXHQgICAgICAgICh0eXBlb2YgKHZhbHVlKSA9PT0gXCJzdHJpbmdcIiAmJiAhIXZhbHVlLm1hdGNoKC9eLT9bMC05XSskLykpIHx8XG5cdCAgICAgICAgKDAsIGxpYiQxLmlzSGV4U3RyaW5nKSh2YWx1ZSkgfHxcblx0ICAgICAgICAodHlwZW9mICh2YWx1ZSkgPT09IFwiYmlnaW50XCIpIHx8XG5cdCAgICAgICAgKDAsIGxpYiQxLmlzQnl0ZXMpKHZhbHVlKSk7XG5cdH1cblx0ZXhwb3J0cy5pc0JpZ051bWJlcmlzaCA9IGlzQmlnTnVtYmVyaXNoO1xuXHQvLyBPbmx5IHdhcm4gYWJvdXQgcGFzc2luZyAxMCBpbnRvIHJhZGl4IG9uY2Vcblx0dmFyIF93YXJuZWRUb1N0cmluZ1JhZGl4ID0gZmFsc2U7XG5cdHZhciBCaWdOdW1iZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG5cdCAgICBmdW5jdGlvbiBCaWdOdW1iZXIoY29uc3RydWN0b3JHdWFyZCwgaGV4KSB7XG5cdCAgICAgICAgdmFyIF9uZXdUYXJnZXQgPSB0aGlzLmNvbnN0cnVjdG9yO1xuXHQgICAgICAgIGxvZ2dlci5jaGVja05ldyhfbmV3VGFyZ2V0LCBCaWdOdW1iZXIpO1xuXHQgICAgICAgIGlmIChjb25zdHJ1Y3Rvckd1YXJkICE9PSBfY29uc3RydWN0b3JHdWFyZCkge1xuXHQgICAgICAgICAgICBsb2dnZXIudGhyb3dFcnJvcihcImNhbm5vdCBjYWxsIGNvbnN0cnVjdG9yIGRpcmVjdGx5OyB1c2UgQmlnTnVtYmVyLmZyb21cIiwgbGliLkxvZ2dlci5lcnJvcnMuVU5TVVBQT1JURURfT1BFUkFUSU9OLCB7XG5cdCAgICAgICAgICAgICAgICBvcGVyYXRpb246IFwibmV3IChCaWdOdW1iZXIpXCJcblx0ICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHRoaXMuX2hleCA9IGhleDtcblx0ICAgICAgICB0aGlzLl9pc0JpZ051bWJlciA9IHRydWU7XG5cdCAgICAgICAgT2JqZWN0LmZyZWV6ZSh0aGlzKTtcblx0ICAgIH1cblx0ICAgIEJpZ051bWJlci5wcm90b3R5cGUuZnJvbVR3b3MgPSBmdW5jdGlvbiAodmFsdWUpIHtcblx0ICAgICAgICByZXR1cm4gdG9CaWdOdW1iZXIodG9CTih0aGlzKS5mcm9tVHdvcyh2YWx1ZSkpO1xuXHQgICAgfTtcblx0ICAgIEJpZ051bWJlci5wcm90b3R5cGUudG9Ud29zID0gZnVuY3Rpb24gKHZhbHVlKSB7XG5cdCAgICAgICAgcmV0dXJuIHRvQmlnTnVtYmVyKHRvQk4odGhpcykudG9Ud29zKHZhbHVlKSk7XG5cdCAgICB9O1xuXHQgICAgQmlnTnVtYmVyLnByb3RvdHlwZS5hYnMgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgaWYgKHRoaXMuX2hleFswXSA9PT0gXCItXCIpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIEJpZ051bWJlci5mcm9tKHRoaXMuX2hleC5zdWJzdHJpbmcoMSkpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICByZXR1cm4gdGhpcztcblx0ICAgIH07XG5cdCAgICBCaWdOdW1iZXIucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uIChvdGhlcikge1xuXHQgICAgICAgIHJldHVybiB0b0JpZ051bWJlcih0b0JOKHRoaXMpLmFkZCh0b0JOKG90aGVyKSkpO1xuXHQgICAgfTtcblx0ICAgIEJpZ051bWJlci5wcm90b3R5cGUuc3ViID0gZnVuY3Rpb24gKG90aGVyKSB7XG5cdCAgICAgICAgcmV0dXJuIHRvQmlnTnVtYmVyKHRvQk4odGhpcykuc3ViKHRvQk4ob3RoZXIpKSk7XG5cdCAgICB9O1xuXHQgICAgQmlnTnVtYmVyLnByb3RvdHlwZS5kaXYgPSBmdW5jdGlvbiAob3RoZXIpIHtcblx0ICAgICAgICB2YXIgbyA9IEJpZ051bWJlci5mcm9tKG90aGVyKTtcblx0ICAgICAgICBpZiAoby5pc1plcm8oKSkge1xuXHQgICAgICAgICAgICB0aHJvd0ZhdWx0KFwiZGl2aXNpb24gYnkgemVyb1wiLCBcImRpdlwiKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgcmV0dXJuIHRvQmlnTnVtYmVyKHRvQk4odGhpcykuZGl2KHRvQk4ob3RoZXIpKSk7XG5cdCAgICB9O1xuXHQgICAgQmlnTnVtYmVyLnByb3RvdHlwZS5tdWwgPSBmdW5jdGlvbiAob3RoZXIpIHtcblx0ICAgICAgICByZXR1cm4gdG9CaWdOdW1iZXIodG9CTih0aGlzKS5tdWwodG9CTihvdGhlcikpKTtcblx0ICAgIH07XG5cdCAgICBCaWdOdW1iZXIucHJvdG90eXBlLm1vZCA9IGZ1bmN0aW9uIChvdGhlcikge1xuXHQgICAgICAgIHZhciB2YWx1ZSA9IHRvQk4ob3RoZXIpO1xuXHQgICAgICAgIGlmICh2YWx1ZS5pc05lZygpKSB7XG5cdCAgICAgICAgICAgIHRocm93RmF1bHQoXCJjYW5ub3QgbW9kdWxvIG5lZ2F0aXZlIHZhbHVlc1wiLCBcIm1vZFwiKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgcmV0dXJuIHRvQmlnTnVtYmVyKHRvQk4odGhpcykudW1vZCh2YWx1ZSkpO1xuXHQgICAgfTtcblx0ICAgIEJpZ051bWJlci5wcm90b3R5cGUucG93ID0gZnVuY3Rpb24gKG90aGVyKSB7XG5cdCAgICAgICAgdmFyIHZhbHVlID0gdG9CTihvdGhlcik7XG5cdCAgICAgICAgaWYgKHZhbHVlLmlzTmVnKCkpIHtcblx0ICAgICAgICAgICAgdGhyb3dGYXVsdChcImNhbm5vdCByYWlzZSB0byBuZWdhdGl2ZSB2YWx1ZXNcIiwgXCJwb3dcIik7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHJldHVybiB0b0JpZ051bWJlcih0b0JOKHRoaXMpLnBvdyh2YWx1ZSkpO1xuXHQgICAgfTtcblx0ICAgIEJpZ051bWJlci5wcm90b3R5cGUuYW5kID0gZnVuY3Rpb24gKG90aGVyKSB7XG5cdCAgICAgICAgdmFyIHZhbHVlID0gdG9CTihvdGhlcik7XG5cdCAgICAgICAgaWYgKHRoaXMuaXNOZWdhdGl2ZSgpIHx8IHZhbHVlLmlzTmVnKCkpIHtcblx0ICAgICAgICAgICAgdGhyb3dGYXVsdChcImNhbm5vdCAnYW5kJyBuZWdhdGl2ZSB2YWx1ZXNcIiwgXCJhbmRcIik7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHJldHVybiB0b0JpZ051bWJlcih0b0JOKHRoaXMpLmFuZCh2YWx1ZSkpO1xuXHQgICAgfTtcblx0ICAgIEJpZ051bWJlci5wcm90b3R5cGUub3IgPSBmdW5jdGlvbiAob3RoZXIpIHtcblx0ICAgICAgICB2YXIgdmFsdWUgPSB0b0JOKG90aGVyKTtcblx0ICAgICAgICBpZiAodGhpcy5pc05lZ2F0aXZlKCkgfHwgdmFsdWUuaXNOZWcoKSkge1xuXHQgICAgICAgICAgICB0aHJvd0ZhdWx0KFwiY2Fubm90ICdvcicgbmVnYXRpdmUgdmFsdWVzXCIsIFwib3JcIik7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHJldHVybiB0b0JpZ051bWJlcih0b0JOKHRoaXMpLm9yKHZhbHVlKSk7XG5cdCAgICB9O1xuXHQgICAgQmlnTnVtYmVyLnByb3RvdHlwZS54b3IgPSBmdW5jdGlvbiAob3RoZXIpIHtcblx0ICAgICAgICB2YXIgdmFsdWUgPSB0b0JOKG90aGVyKTtcblx0ICAgICAgICBpZiAodGhpcy5pc05lZ2F0aXZlKCkgfHwgdmFsdWUuaXNOZWcoKSkge1xuXHQgICAgICAgICAgICB0aHJvd0ZhdWx0KFwiY2Fubm90ICd4b3InIG5lZ2F0aXZlIHZhbHVlc1wiLCBcInhvclwiKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgcmV0dXJuIHRvQmlnTnVtYmVyKHRvQk4odGhpcykueG9yKHZhbHVlKSk7XG5cdCAgICB9O1xuXHQgICAgQmlnTnVtYmVyLnByb3RvdHlwZS5tYXNrID0gZnVuY3Rpb24gKHZhbHVlKSB7XG5cdCAgICAgICAgaWYgKHRoaXMuaXNOZWdhdGl2ZSgpIHx8IHZhbHVlIDwgMCkge1xuXHQgICAgICAgICAgICB0aHJvd0ZhdWx0KFwiY2Fubm90IG1hc2sgbmVnYXRpdmUgdmFsdWVzXCIsIFwibWFza1wiKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgcmV0dXJuIHRvQmlnTnVtYmVyKHRvQk4odGhpcykubWFza24odmFsdWUpKTtcblx0ICAgIH07XG5cdCAgICBCaWdOdW1iZXIucHJvdG90eXBlLnNobCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuXHQgICAgICAgIGlmICh0aGlzLmlzTmVnYXRpdmUoKSB8fCB2YWx1ZSA8IDApIHtcblx0ICAgICAgICAgICAgdGhyb3dGYXVsdChcImNhbm5vdCBzaGlmdCBuZWdhdGl2ZSB2YWx1ZXNcIiwgXCJzaGxcIik7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHJldHVybiB0b0JpZ051bWJlcih0b0JOKHRoaXMpLnNobG4odmFsdWUpKTtcblx0ICAgIH07XG5cdCAgICBCaWdOdW1iZXIucHJvdG90eXBlLnNociA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuXHQgICAgICAgIGlmICh0aGlzLmlzTmVnYXRpdmUoKSB8fCB2YWx1ZSA8IDApIHtcblx0ICAgICAgICAgICAgdGhyb3dGYXVsdChcImNhbm5vdCBzaGlmdCBuZWdhdGl2ZSB2YWx1ZXNcIiwgXCJzaHJcIik7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHJldHVybiB0b0JpZ051bWJlcih0b0JOKHRoaXMpLnNocm4odmFsdWUpKTtcblx0ICAgIH07XG5cdCAgICBCaWdOdW1iZXIucHJvdG90eXBlLmVxID0gZnVuY3Rpb24gKG90aGVyKSB7XG5cdCAgICAgICAgcmV0dXJuIHRvQk4odGhpcykuZXEodG9CTihvdGhlcikpO1xuXHQgICAgfTtcblx0ICAgIEJpZ051bWJlci5wcm90b3R5cGUubHQgPSBmdW5jdGlvbiAob3RoZXIpIHtcblx0ICAgICAgICByZXR1cm4gdG9CTih0aGlzKS5sdCh0b0JOKG90aGVyKSk7XG5cdCAgICB9O1xuXHQgICAgQmlnTnVtYmVyLnByb3RvdHlwZS5sdGUgPSBmdW5jdGlvbiAob3RoZXIpIHtcblx0ICAgICAgICByZXR1cm4gdG9CTih0aGlzKS5sdGUodG9CTihvdGhlcikpO1xuXHQgICAgfTtcblx0ICAgIEJpZ051bWJlci5wcm90b3R5cGUuZ3QgPSBmdW5jdGlvbiAob3RoZXIpIHtcblx0ICAgICAgICByZXR1cm4gdG9CTih0aGlzKS5ndCh0b0JOKG90aGVyKSk7XG5cdCAgICB9O1xuXHQgICAgQmlnTnVtYmVyLnByb3RvdHlwZS5ndGUgPSBmdW5jdGlvbiAob3RoZXIpIHtcblx0ICAgICAgICByZXR1cm4gdG9CTih0aGlzKS5ndGUodG9CTihvdGhlcikpO1xuXHQgICAgfTtcblx0ICAgIEJpZ051bWJlci5wcm90b3R5cGUuaXNOZWdhdGl2ZSA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICByZXR1cm4gKHRoaXMuX2hleFswXSA9PT0gXCItXCIpO1xuXHQgICAgfTtcblx0ICAgIEJpZ051bWJlci5wcm90b3R5cGUuaXNaZXJvID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIHJldHVybiB0b0JOKHRoaXMpLmlzWmVybygpO1xuXHQgICAgfTtcblx0ICAgIEJpZ051bWJlci5wcm90b3R5cGUudG9OdW1iZXIgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgdHJ5IHtcblx0ICAgICAgICAgICAgcmV0dXJuIHRvQk4odGhpcykudG9OdW1iZXIoKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG5cdCAgICAgICAgICAgIHRocm93RmF1bHQoXCJvdmVyZmxvd1wiLCBcInRvTnVtYmVyXCIsIHRoaXMudG9TdHJpbmcoKSk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHJldHVybiBudWxsO1xuXHQgICAgfTtcblx0ICAgIEJpZ051bWJlci5wcm90b3R5cGUudG9CaWdJbnQgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgdHJ5IHtcblx0ICAgICAgICAgICAgcmV0dXJuIEJpZ0ludCh0aGlzLnRvU3RyaW5nKCkpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBjYXRjaCAoZSkgeyB9XG5cdCAgICAgICAgcmV0dXJuIGxvZ2dlci50aHJvd0Vycm9yKFwidGhpcyBwbGF0Zm9ybSBkb2VzIG5vdCBzdXBwb3J0IEJpZ0ludFwiLCBsaWIuTG9nZ2VyLmVycm9ycy5VTlNVUFBPUlRFRF9PUEVSQVRJT04sIHtcblx0ICAgICAgICAgICAgdmFsdWU6IHRoaXMudG9TdHJpbmcoKVxuXHQgICAgICAgIH0pO1xuXHQgICAgfTtcblx0ICAgIEJpZ051bWJlci5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgLy8gTG90cyBvZiBwZW9wbGUgZXhwZWN0IHRoaXMsIHdoaWNoIHdlIGRvIG5vdCBzdXBwb3J0LCBzbyBjaGVjayAoU2VlOiAjODg5KVxuXHQgICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMCkge1xuXHQgICAgICAgICAgICBpZiAoYXJndW1lbnRzWzBdID09PSAxMCkge1xuXHQgICAgICAgICAgICAgICAgaWYgKCFfd2FybmVkVG9TdHJpbmdSYWRpeCkge1xuXHQgICAgICAgICAgICAgICAgICAgIF93YXJuZWRUb1N0cmluZ1JhZGl4ID0gdHJ1ZTtcblx0ICAgICAgICAgICAgICAgICAgICBsb2dnZXIud2FybihcIkJpZ051bWJlci50b1N0cmluZyBkb2VzIG5vdCBhY2NlcHQgYW55IHBhcmFtZXRlcnM7IGJhc2UtMTAgaXMgYXNzdW1lZFwiKTtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICBlbHNlIGlmIChhcmd1bWVudHNbMF0gPT09IDE2KSB7XG5cdCAgICAgICAgICAgICAgICBsb2dnZXIudGhyb3dFcnJvcihcIkJpZ051bWJlci50b1N0cmluZyBkb2VzIG5vdCBhY2NlcHQgYW55IHBhcmFtZXRlcnM7IHVzZSBiaWdOdW1iZXIudG9IZXhTdHJpbmcoKVwiLCBsaWIuTG9nZ2VyLmVycm9ycy5VTkVYUEVDVEVEX0FSR1VNRU5ULCB7fSk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgZWxzZSB7XG5cdCAgICAgICAgICAgICAgICBsb2dnZXIudGhyb3dFcnJvcihcIkJpZ051bWJlci50b1N0cmluZyBkb2VzIG5vdCBhY2NlcHQgcGFyYW1ldGVyc1wiLCBsaWIuTG9nZ2VyLmVycm9ycy5VTkVYUEVDVEVEX0FSR1VNRU5ULCB7fSk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9XG5cdCAgICAgICAgcmV0dXJuIHRvQk4odGhpcykudG9TdHJpbmcoMTApO1xuXHQgICAgfTtcblx0ICAgIEJpZ051bWJlci5wcm90b3R5cGUudG9IZXhTdHJpbmcgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgcmV0dXJuIHRoaXMuX2hleDtcblx0ICAgIH07XG5cdCAgICBCaWdOdW1iZXIucHJvdG90eXBlLnRvSlNPTiA9IGZ1bmN0aW9uIChrZXkpIHtcblx0ICAgICAgICByZXR1cm4geyB0eXBlOiBcIkJpZ051bWJlclwiLCBoZXg6IHRoaXMudG9IZXhTdHJpbmcoKSB9O1xuXHQgICAgfTtcblx0ICAgIEJpZ051bWJlci5mcm9tID0gZnVuY3Rpb24gKHZhbHVlKSB7XG5cdCAgICAgICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgQmlnTnVtYmVyKSB7XG5cdCAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgaWYgKHR5cGVvZiAodmFsdWUpID09PSBcInN0cmluZ1wiKSB7XG5cdCAgICAgICAgICAgIGlmICh2YWx1ZS5tYXRjaCgvXi0/MHhbMC05YS1mXSskL2kpKSB7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gbmV3IEJpZ051bWJlcihfY29uc3RydWN0b3JHdWFyZCwgdG9IZXgodmFsdWUpKTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICBpZiAodmFsdWUubWF0Y2goL14tP1swLTldKyQvKSkge1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBCaWdOdW1iZXIoX2NvbnN0cnVjdG9yR3VhcmQsIHRvSGV4KG5ldyBCTih2YWx1ZSkpKTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICByZXR1cm4gbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcImludmFsaWQgQmlnTnVtYmVyIHN0cmluZ1wiLCBcInZhbHVlXCIsIHZhbHVlKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgaWYgKHR5cGVvZiAodmFsdWUpID09PSBcIm51bWJlclwiKSB7XG5cdCAgICAgICAgICAgIGlmICh2YWx1ZSAlIDEpIHtcblx0ICAgICAgICAgICAgICAgIHRocm93RmF1bHQoXCJ1bmRlcmZsb3dcIiwgXCJCaWdOdW1iZXIuZnJvbVwiLCB2YWx1ZSk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgaWYgKHZhbHVlID49IE1BWF9TQUZFIHx8IHZhbHVlIDw9IC1NQVhfU0FGRSkge1xuXHQgICAgICAgICAgICAgICAgdGhyb3dGYXVsdChcIm92ZXJmbG93XCIsIFwiQmlnTnVtYmVyLmZyb21cIiwgdmFsdWUpO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIHJldHVybiBCaWdOdW1iZXIuZnJvbShTdHJpbmcodmFsdWUpKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgdmFyIGFueVZhbHVlID0gdmFsdWU7XG5cdCAgICAgICAgaWYgKHR5cGVvZiAoYW55VmFsdWUpID09PSBcImJpZ2ludFwiKSB7XG5cdCAgICAgICAgICAgIHJldHVybiBCaWdOdW1iZXIuZnJvbShhbnlWYWx1ZS50b1N0cmluZygpKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgaWYgKCgwLCBsaWIkMS5pc0J5dGVzKShhbnlWYWx1ZSkpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIEJpZ051bWJlci5mcm9tKCgwLCBsaWIkMS5oZXhsaWZ5KShhbnlWYWx1ZSkpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBpZiAoYW55VmFsdWUpIHtcblx0ICAgICAgICAgICAgLy8gSGV4YWJsZSBpbnRlcmZhY2UgKHRha2VzIHByaW9yaXR5KVxuXHQgICAgICAgICAgICBpZiAoYW55VmFsdWUudG9IZXhTdHJpbmcpIHtcblx0ICAgICAgICAgICAgICAgIHZhciBoZXggPSBhbnlWYWx1ZS50b0hleFN0cmluZygpO1xuXHQgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiAoaGV4KSA9PT0gXCJzdHJpbmdcIikge1xuXHQgICAgICAgICAgICAgICAgICAgIHJldHVybiBCaWdOdW1iZXIuZnJvbShoZXgpO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIGVsc2Uge1xuXHQgICAgICAgICAgICAgICAgLy8gRm9yIG5vdywgaGFuZGxlIGxlZ2FjeSBKU09OLWlmaWVkIHZhbHVlcyAoZ29lcyBhd2F5IGluIHY2KVxuXHQgICAgICAgICAgICAgICAgdmFyIGhleCA9IGFueVZhbHVlLl9oZXg7XG5cdCAgICAgICAgICAgICAgICAvLyBOZXctZm9ybSBKU09OXG5cdCAgICAgICAgICAgICAgICBpZiAoaGV4ID09IG51bGwgJiYgYW55VmFsdWUudHlwZSA9PT0gXCJCaWdOdW1iZXJcIikge1xuXHQgICAgICAgICAgICAgICAgICAgIGhleCA9IGFueVZhbHVlLmhleDtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgKGhleCkgPT09IFwic3RyaW5nXCIpIHtcblx0ICAgICAgICAgICAgICAgICAgICBpZiAoKDAsIGxpYiQxLmlzSGV4U3RyaW5nKShoZXgpIHx8IChoZXhbMF0gPT09IFwiLVwiICYmICgwLCBsaWIkMS5pc0hleFN0cmluZykoaGV4LnN1YnN0cmluZygxKSkpKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBCaWdOdW1iZXIuZnJvbShoZXgpO1xuXHQgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH1cblx0ICAgICAgICByZXR1cm4gbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcImludmFsaWQgQmlnTnVtYmVyIHZhbHVlXCIsIFwidmFsdWVcIiwgdmFsdWUpO1xuXHQgICAgfTtcblx0ICAgIEJpZ051bWJlci5pc0JpZ051bWJlciA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuXHQgICAgICAgIHJldHVybiAhISh2YWx1ZSAmJiB2YWx1ZS5faXNCaWdOdW1iZXIpO1xuXHQgICAgfTtcblx0ICAgIHJldHVybiBCaWdOdW1iZXI7XG5cdH0oKSk7XG5cdGV4cG9ydHMuQmlnTnVtYmVyID0gQmlnTnVtYmVyO1xuXHQvLyBOb3JtYWxpemUgdGhlIGhleCBzdHJpbmdcblx0ZnVuY3Rpb24gdG9IZXgodmFsdWUpIHtcblx0ICAgIC8vIEZvciBCTiwgY2FsbCBvbiB0aGUgaGV4IHN0cmluZ1xuXHQgICAgaWYgKHR5cGVvZiAodmFsdWUpICE9PSBcInN0cmluZ1wiKSB7XG5cdCAgICAgICAgcmV0dXJuIHRvSGV4KHZhbHVlLnRvU3RyaW5nKDE2KSk7XG5cdCAgICB9XG5cdCAgICAvLyBJZiBuZWdhdGl2ZSwgcHJlcGVuZCB0aGUgbmVnYXRpdmUgc2lnbiB0byB0aGUgbm9ybWFsaXplZCBwb3NpdGl2ZSB2YWx1ZVxuXHQgICAgaWYgKHZhbHVlWzBdID09PSBcIi1cIikge1xuXHQgICAgICAgIC8vIFN0cmlwIG9mZiB0aGUgbmVnYXRpdmUgc2lnblxuXHQgICAgICAgIHZhbHVlID0gdmFsdWUuc3Vic3RyaW5nKDEpO1xuXHQgICAgICAgIC8vIENhbm5vdCBoYXZlIG11bHRpcGxlIG5lZ2F0aXZlIHNpZ25zIChlLmcuIFwiLS0weDA0XCIpXG5cdCAgICAgICAgaWYgKHZhbHVlWzBdID09PSBcIi1cIikge1xuXHQgICAgICAgICAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwiaW52YWxpZCBoZXhcIiwgXCJ2YWx1ZVwiLCB2YWx1ZSk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIC8vIENhbGwgdG9IZXggb24gdGhlIHBvc2l0aXZlIGNvbXBvbmVudFxuXHQgICAgICAgIHZhbHVlID0gdG9IZXgodmFsdWUpO1xuXHQgICAgICAgIC8vIERvIG5vdCBhbGxvdyBcIi0weDAwXCJcblx0ICAgICAgICBpZiAodmFsdWUgPT09IFwiMHgwMFwiKSB7XG5cdCAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgLy8gTmVnYXRlIHRoZSB2YWx1ZVxuXHQgICAgICAgIHJldHVybiBcIi1cIiArIHZhbHVlO1xuXHQgICAgfVxuXHQgICAgLy8gQWRkIGEgXCIweFwiIHByZWZpeCBpZiBtaXNzaW5nXG5cdCAgICBpZiAodmFsdWUuc3Vic3RyaW5nKDAsIDIpICE9PSBcIjB4XCIpIHtcblx0ICAgICAgICB2YWx1ZSA9IFwiMHhcIiArIHZhbHVlO1xuXHQgICAgfVxuXHQgICAgLy8gTm9ybWFsaXplIHplcm9cblx0ICAgIGlmICh2YWx1ZSA9PT0gXCIweFwiKSB7XG5cdCAgICAgICAgcmV0dXJuIFwiMHgwMFwiO1xuXHQgICAgfVxuXHQgICAgLy8gTWFrZSB0aGUgc3RyaW5nIGV2ZW4gbGVuZ3RoXG5cdCAgICBpZiAodmFsdWUubGVuZ3RoICUgMikge1xuXHQgICAgICAgIHZhbHVlID0gXCIweDBcIiArIHZhbHVlLnN1YnN0cmluZygyKTtcblx0ICAgIH1cblx0ICAgIC8vIFRyaW0gdG8gc21hbGxlc3QgZXZlbi1sZW5ndGggc3RyaW5nXG5cdCAgICB3aGlsZSAodmFsdWUubGVuZ3RoID4gNCAmJiB2YWx1ZS5zdWJzdHJpbmcoMCwgNCkgPT09IFwiMHgwMFwiKSB7XG5cdCAgICAgICAgdmFsdWUgPSBcIjB4XCIgKyB2YWx1ZS5zdWJzdHJpbmcoNCk7XG5cdCAgICB9XG5cdCAgICByZXR1cm4gdmFsdWU7XG5cdH1cblx0ZnVuY3Rpb24gdG9CaWdOdW1iZXIodmFsdWUpIHtcblx0ICAgIHJldHVybiBCaWdOdW1iZXIuZnJvbSh0b0hleCh2YWx1ZSkpO1xuXHR9XG5cdGZ1bmN0aW9uIHRvQk4odmFsdWUpIHtcblx0ICAgIHZhciBoZXggPSBCaWdOdW1iZXIuZnJvbSh2YWx1ZSkudG9IZXhTdHJpbmcoKTtcblx0ICAgIGlmIChoZXhbMF0gPT09IFwiLVwiKSB7XG5cdCAgICAgICAgcmV0dXJuIChuZXcgQk4oXCItXCIgKyBoZXguc3Vic3RyaW5nKDMpLCAxNikpO1xuXHQgICAgfVxuXHQgICAgcmV0dXJuIG5ldyBCTihoZXguc3Vic3RyaW5nKDIpLCAxNik7XG5cdH1cblx0ZnVuY3Rpb24gdGhyb3dGYXVsdChmYXVsdCwgb3BlcmF0aW9uLCB2YWx1ZSkge1xuXHQgICAgdmFyIHBhcmFtcyA9IHsgZmF1bHQ6IGZhdWx0LCBvcGVyYXRpb246IG9wZXJhdGlvbiB9O1xuXHQgICAgaWYgKHZhbHVlICE9IG51bGwpIHtcblx0ICAgICAgICBwYXJhbXMudmFsdWUgPSB2YWx1ZTtcblx0ICAgIH1cblx0ICAgIHJldHVybiBsb2dnZXIudGhyb3dFcnJvcihmYXVsdCwgbGliLkxvZ2dlci5lcnJvcnMuTlVNRVJJQ19GQVVMVCwgcGFyYW1zKTtcblx0fVxuXHQvLyB2YWx1ZSBzaG91bGQgaGF2ZSBubyBwcmVmaXhcblx0ZnVuY3Rpb24gX2Jhc2UzNlRvMTYodmFsdWUpIHtcblx0ICAgIHJldHVybiAobmV3IEJOKHZhbHVlLCAzNikpLnRvU3RyaW5nKDE2KTtcblx0fVxuXHRleHBvcnRzLl9iYXNlMzZUbzE2ID0gX2Jhc2UzNlRvMTY7XG5cdC8vIHZhbHVlIHNob3VsZCBoYXZlIG5vIHByZWZpeFxuXHRmdW5jdGlvbiBfYmFzZTE2VG8zNih2YWx1ZSkge1xuXHQgICAgcmV0dXJuIChuZXcgQk4odmFsdWUsIDE2KSkudG9TdHJpbmcoMzYpO1xuXHR9XG5cdGV4cG9ydHMuX2Jhc2UxNlRvMzYgPSBfYmFzZTE2VG8zNjtcblxuXHR9KTtcblxuXHR2YXIgYmlnbnVtYmVyJDEgPSAvKkBfX1BVUkVfXyovZ2V0RGVmYXVsdEV4cG9ydEZyb21DanMoYmlnbnVtYmVyKTtcblxuXHR2YXIgZml4ZWRudW1iZXIgPSBjcmVhdGVDb21tb25qc01vZHVsZShmdW5jdGlvbiAobW9kdWxlLCBleHBvcnRzKSB7XG5cdFwidXNlIHN0cmljdFwiO1xuXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5cdGV4cG9ydHMuRml4ZWROdW1iZXIgPSBleHBvcnRzLkZpeGVkRm9ybWF0ID0gZXhwb3J0cy5wYXJzZUZpeGVkID0gZXhwb3J0cy5mb3JtYXRGaXhlZCA9IHZvaWQgMDtcblxuXG5cblx0dmFyIGxvZ2dlciA9IG5ldyBsaWIuTG9nZ2VyKF92ZXJzaW9uJDQudmVyc2lvbik7XG5cblx0dmFyIF9jb25zdHJ1Y3Rvckd1YXJkID0ge307XG5cdHZhciBaZXJvID0gYmlnbnVtYmVyLkJpZ051bWJlci5mcm9tKDApO1xuXHR2YXIgTmVnYXRpdmVPbmUgPSBiaWdudW1iZXIuQmlnTnVtYmVyLmZyb20oLTEpO1xuXHRmdW5jdGlvbiB0aHJvd0ZhdWx0KG1lc3NhZ2UsIGZhdWx0LCBvcGVyYXRpb24sIHZhbHVlKSB7XG5cdCAgICB2YXIgcGFyYW1zID0geyBmYXVsdDogZmF1bHQsIG9wZXJhdGlvbjogb3BlcmF0aW9uIH07XG5cdCAgICBpZiAodmFsdWUgIT09IHVuZGVmaW5lZCkge1xuXHQgICAgICAgIHBhcmFtcy52YWx1ZSA9IHZhbHVlO1xuXHQgICAgfVxuXHQgICAgcmV0dXJuIGxvZ2dlci50aHJvd0Vycm9yKG1lc3NhZ2UsIGxpYi5Mb2dnZXIuZXJyb3JzLk5VTUVSSUNfRkFVTFQsIHBhcmFtcyk7XG5cdH1cblx0Ly8gQ29uc3RhbnQgdG8gcHVsbCB6ZXJvcyBmcm9tIGZvciBtdWx0aXBsaWVyc1xuXHR2YXIgemVyb3MgPSBcIjBcIjtcblx0d2hpbGUgKHplcm9zLmxlbmd0aCA8IDI1Nikge1xuXHQgICAgemVyb3MgKz0gemVyb3M7XG5cdH1cblx0Ly8gUmV0dXJucyBhIHN0cmluZyBcIjFcIiBmb2xsb3dlZCBieSBkZWNpbWFsIFwiMFwic1xuXHRmdW5jdGlvbiBnZXRNdWx0aXBsaWVyKGRlY2ltYWxzKSB7XG5cdCAgICBpZiAodHlwZW9mIChkZWNpbWFscykgIT09IFwibnVtYmVyXCIpIHtcblx0ICAgICAgICB0cnkge1xuXHQgICAgICAgICAgICBkZWNpbWFscyA9IGJpZ251bWJlci5CaWdOdW1iZXIuZnJvbShkZWNpbWFscykudG9OdW1iZXIoKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgY2F0Y2ggKGUpIHsgfVxuXHQgICAgfVxuXHQgICAgaWYgKHR5cGVvZiAoZGVjaW1hbHMpID09PSBcIm51bWJlclwiICYmIGRlY2ltYWxzID49IDAgJiYgZGVjaW1hbHMgPD0gMjU2ICYmICEoZGVjaW1hbHMgJSAxKSkge1xuXHQgICAgICAgIHJldHVybiAoXCIxXCIgKyB6ZXJvcy5zdWJzdHJpbmcoMCwgZGVjaW1hbHMpKTtcblx0ICAgIH1cblx0ICAgIHJldHVybiBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwiaW52YWxpZCBkZWNpbWFsIHNpemVcIiwgXCJkZWNpbWFsc1wiLCBkZWNpbWFscyk7XG5cdH1cblx0ZnVuY3Rpb24gZm9ybWF0Rml4ZWQodmFsdWUsIGRlY2ltYWxzKSB7XG5cdCAgICBpZiAoZGVjaW1hbHMgPT0gbnVsbCkge1xuXHQgICAgICAgIGRlY2ltYWxzID0gMDtcblx0ICAgIH1cblx0ICAgIHZhciBtdWx0aXBsaWVyID0gZ2V0TXVsdGlwbGllcihkZWNpbWFscyk7XG5cdCAgICAvLyBNYWtlIHN1cmUgd2VpIGlzIGEgYmlnIG51bWJlciAoY29udmVydCBhcyBuZWNlc3NhcnkpXG5cdCAgICB2YWx1ZSA9IGJpZ251bWJlci5CaWdOdW1iZXIuZnJvbSh2YWx1ZSk7XG5cdCAgICB2YXIgbmVnYXRpdmUgPSB2YWx1ZS5sdChaZXJvKTtcblx0ICAgIGlmIChuZWdhdGl2ZSkge1xuXHQgICAgICAgIHZhbHVlID0gdmFsdWUubXVsKE5lZ2F0aXZlT25lKTtcblx0ICAgIH1cblx0ICAgIHZhciBmcmFjdGlvbiA9IHZhbHVlLm1vZChtdWx0aXBsaWVyKS50b1N0cmluZygpO1xuXHQgICAgd2hpbGUgKGZyYWN0aW9uLmxlbmd0aCA8IG11bHRpcGxpZXIubGVuZ3RoIC0gMSkge1xuXHQgICAgICAgIGZyYWN0aW9uID0gXCIwXCIgKyBmcmFjdGlvbjtcblx0ICAgIH1cblx0ICAgIC8vIFN0cmlwIHRyYWluaW5nIDBcblx0ICAgIGZyYWN0aW9uID0gZnJhY3Rpb24ubWF0Y2goL14oWzAtOV0qWzEtOV18MCkoMCopLylbMV07XG5cdCAgICB2YXIgd2hvbGUgPSB2YWx1ZS5kaXYobXVsdGlwbGllcikudG9TdHJpbmcoKTtcblx0ICAgIGlmIChtdWx0aXBsaWVyLmxlbmd0aCA9PT0gMSkge1xuXHQgICAgICAgIHZhbHVlID0gd2hvbGU7XG5cdCAgICB9XG5cdCAgICBlbHNlIHtcblx0ICAgICAgICB2YWx1ZSA9IHdob2xlICsgXCIuXCIgKyBmcmFjdGlvbjtcblx0ICAgIH1cblx0ICAgIGlmIChuZWdhdGl2ZSkge1xuXHQgICAgICAgIHZhbHVlID0gXCItXCIgKyB2YWx1ZTtcblx0ICAgIH1cblx0ICAgIHJldHVybiB2YWx1ZTtcblx0fVxuXHRleHBvcnRzLmZvcm1hdEZpeGVkID0gZm9ybWF0Rml4ZWQ7XG5cdGZ1bmN0aW9uIHBhcnNlRml4ZWQodmFsdWUsIGRlY2ltYWxzKSB7XG5cdCAgICBpZiAoZGVjaW1hbHMgPT0gbnVsbCkge1xuXHQgICAgICAgIGRlY2ltYWxzID0gMDtcblx0ICAgIH1cblx0ICAgIHZhciBtdWx0aXBsaWVyID0gZ2V0TXVsdGlwbGllcihkZWNpbWFscyk7XG5cdCAgICBpZiAodHlwZW9mICh2YWx1ZSkgIT09IFwic3RyaW5nXCIgfHwgIXZhbHVlLm1hdGNoKC9eLT9bMC05Ll0rJC8pKSB7XG5cdCAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcImludmFsaWQgZGVjaW1hbCB2YWx1ZVwiLCBcInZhbHVlXCIsIHZhbHVlKTtcblx0ICAgIH1cblx0ICAgIC8vIElzIGl0IG5lZ2F0aXZlP1xuXHQgICAgdmFyIG5lZ2F0aXZlID0gKHZhbHVlLnN1YnN0cmluZygwLCAxKSA9PT0gXCItXCIpO1xuXHQgICAgaWYgKG5lZ2F0aXZlKSB7XG5cdCAgICAgICAgdmFsdWUgPSB2YWx1ZS5zdWJzdHJpbmcoMSk7XG5cdCAgICB9XG5cdCAgICBpZiAodmFsdWUgPT09IFwiLlwiKSB7XG5cdCAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcIm1pc3NpbmcgdmFsdWVcIiwgXCJ2YWx1ZVwiLCB2YWx1ZSk7XG5cdCAgICB9XG5cdCAgICAvLyBTcGxpdCBpdCBpbnRvIGEgd2hvbGUgYW5kIGZyYWN0aW9uYWwgcGFydFxuXHQgICAgdmFyIGNvbXBzID0gdmFsdWUuc3BsaXQoXCIuXCIpO1xuXHQgICAgaWYgKGNvbXBzLmxlbmd0aCA+IDIpIHtcblx0ICAgICAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwidG9vIG1hbnkgZGVjaW1hbCBwb2ludHNcIiwgXCJ2YWx1ZVwiLCB2YWx1ZSk7XG5cdCAgICB9XG5cdCAgICB2YXIgd2hvbGUgPSBjb21wc1swXSwgZnJhY3Rpb24gPSBjb21wc1sxXTtcblx0ICAgIGlmICghd2hvbGUpIHtcblx0ICAgICAgICB3aG9sZSA9IFwiMFwiO1xuXHQgICAgfVxuXHQgICAgaWYgKCFmcmFjdGlvbikge1xuXHQgICAgICAgIGZyYWN0aW9uID0gXCIwXCI7XG5cdCAgICB9XG5cdCAgICAvLyBUcmltIHRyYWlsaW5nIHplcm9zXG5cdCAgICB3aGlsZSAoZnJhY3Rpb25bZnJhY3Rpb24ubGVuZ3RoIC0gMV0gPT09IFwiMFwiKSB7XG5cdCAgICAgICAgZnJhY3Rpb24gPSBmcmFjdGlvbi5zdWJzdHJpbmcoMCwgZnJhY3Rpb24ubGVuZ3RoIC0gMSk7XG5cdCAgICB9XG5cdCAgICAvLyBDaGVjayB0aGUgZnJhY3Rpb24gZG9lc24ndCBleGNlZWQgb3VyIGRlY2ltYWxzIHNpemVcblx0ICAgIGlmIChmcmFjdGlvbi5sZW5ndGggPiBtdWx0aXBsaWVyLmxlbmd0aCAtIDEpIHtcblx0ICAgICAgICB0aHJvd0ZhdWx0KFwiZnJhY3Rpb25hbCBjb21wb25lbnQgZXhjZWVkcyBkZWNpbWFsc1wiLCBcInVuZGVyZmxvd1wiLCBcInBhcnNlRml4ZWRcIik7XG5cdCAgICB9XG5cdCAgICAvLyBJZiBkZWNpbWFscyBpcyAwLCB3ZSBoYXZlIGFuIGVtcHR5IHN0cmluZyBmb3IgZnJhY3Rpb25cblx0ICAgIGlmIChmcmFjdGlvbiA9PT0gXCJcIikge1xuXHQgICAgICAgIGZyYWN0aW9uID0gXCIwXCI7XG5cdCAgICB9XG5cdCAgICAvLyBGdWxseSBwYWQgdGhlIHN0cmluZyB3aXRoIHplcm9zIHRvIGdldCB0byB3ZWlcblx0ICAgIHdoaWxlIChmcmFjdGlvbi5sZW5ndGggPCBtdWx0aXBsaWVyLmxlbmd0aCAtIDEpIHtcblx0ICAgICAgICBmcmFjdGlvbiArPSBcIjBcIjtcblx0ICAgIH1cblx0ICAgIHZhciB3aG9sZVZhbHVlID0gYmlnbnVtYmVyLkJpZ051bWJlci5mcm9tKHdob2xlKTtcblx0ICAgIHZhciBmcmFjdGlvblZhbHVlID0gYmlnbnVtYmVyLkJpZ051bWJlci5mcm9tKGZyYWN0aW9uKTtcblx0ICAgIHZhciB3ZWkgPSAod2hvbGVWYWx1ZS5tdWwobXVsdGlwbGllcikpLmFkZChmcmFjdGlvblZhbHVlKTtcblx0ICAgIGlmIChuZWdhdGl2ZSkge1xuXHQgICAgICAgIHdlaSA9IHdlaS5tdWwoTmVnYXRpdmVPbmUpO1xuXHQgICAgfVxuXHQgICAgcmV0dXJuIHdlaTtcblx0fVxuXHRleHBvcnRzLnBhcnNlRml4ZWQgPSBwYXJzZUZpeGVkO1xuXHR2YXIgRml4ZWRGb3JtYXQgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG5cdCAgICBmdW5jdGlvbiBGaXhlZEZvcm1hdChjb25zdHJ1Y3Rvckd1YXJkLCBzaWduZWQsIHdpZHRoLCBkZWNpbWFscykge1xuXHQgICAgICAgIGlmIChjb25zdHJ1Y3Rvckd1YXJkICE9PSBfY29uc3RydWN0b3JHdWFyZCkge1xuXHQgICAgICAgICAgICBsb2dnZXIudGhyb3dFcnJvcihcImNhbm5vdCB1c2UgRml4ZWRGb3JtYXQgY29uc3RydWN0b3I7IHVzZSBGaXhlZEZvcm1hdC5mcm9tXCIsIGxpYi5Mb2dnZXIuZXJyb3JzLlVOU1VQUE9SVEVEX09QRVJBVElPTiwge1xuXHQgICAgICAgICAgICAgICAgb3BlcmF0aW9uOiBcIm5ldyBGaXhlZEZvcm1hdFwiXG5cdCAgICAgICAgICAgIH0pO1xuXHQgICAgICAgIH1cblx0ICAgICAgICB0aGlzLnNpZ25lZCA9IHNpZ25lZDtcblx0ICAgICAgICB0aGlzLndpZHRoID0gd2lkdGg7XG5cdCAgICAgICAgdGhpcy5kZWNpbWFscyA9IGRlY2ltYWxzO1xuXHQgICAgICAgIHRoaXMubmFtZSA9IChzaWduZWQgPyBcIlwiIDogXCJ1XCIpICsgXCJmaXhlZFwiICsgU3RyaW5nKHdpZHRoKSArIFwieFwiICsgU3RyaW5nKGRlY2ltYWxzKTtcblx0ICAgICAgICB0aGlzLl9tdWx0aXBsaWVyID0gZ2V0TXVsdGlwbGllcihkZWNpbWFscyk7XG5cdCAgICAgICAgT2JqZWN0LmZyZWV6ZSh0aGlzKTtcblx0ICAgIH1cblx0ICAgIEZpeGVkRm9ybWF0LmZyb20gPSBmdW5jdGlvbiAodmFsdWUpIHtcblx0ICAgICAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBGaXhlZEZvcm1hdCkge1xuXHQgICAgICAgICAgICByZXR1cm4gdmFsdWU7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGlmICh0eXBlb2YgKHZhbHVlKSA9PT0gXCJudW1iZXJcIikge1xuXHQgICAgICAgICAgICB2YWx1ZSA9IFwiZml4ZWQxMjh4XCIgKyB2YWx1ZTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgdmFyIHNpZ25lZCA9IHRydWU7XG5cdCAgICAgICAgdmFyIHdpZHRoID0gMTI4O1xuXHQgICAgICAgIHZhciBkZWNpbWFscyA9IDE4O1xuXHQgICAgICAgIGlmICh0eXBlb2YgKHZhbHVlKSA9PT0gXCJzdHJpbmdcIikge1xuXHQgICAgICAgICAgICBpZiAodmFsdWUgPT09IFwiZml4ZWRcIikge1xuXHQgICAgICAgICAgICAgICAgLy8gZGVmYXVsdHMuLi5cblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICBlbHNlIGlmICh2YWx1ZSA9PT0gXCJ1Zml4ZWRcIikge1xuXHQgICAgICAgICAgICAgICAgc2lnbmVkID0gZmFsc2U7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgZWxzZSB7XG5cdCAgICAgICAgICAgICAgICB2YXIgbWF0Y2ggPSB2YWx1ZS5tYXRjaCgvXih1PylmaXhlZChbMC05XSspeChbMC05XSspJC8pO1xuXHQgICAgICAgICAgICAgICAgaWYgKCFtYXRjaCkge1xuXHQgICAgICAgICAgICAgICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJpbnZhbGlkIGZpeGVkIGZvcm1hdFwiLCBcImZvcm1hdFwiLCB2YWx1ZSk7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICBzaWduZWQgPSAobWF0Y2hbMV0gIT09IFwidVwiKTtcblx0ICAgICAgICAgICAgICAgIHdpZHRoID0gcGFyc2VJbnQobWF0Y2hbMl0pO1xuXHQgICAgICAgICAgICAgICAgZGVjaW1hbHMgPSBwYXJzZUludChtYXRjaFszXSk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9XG5cdCAgICAgICAgZWxzZSBpZiAodmFsdWUpIHtcblx0ICAgICAgICAgICAgdmFyIGNoZWNrID0gZnVuY3Rpb24gKGtleSwgdHlwZSwgZGVmYXVsdFZhbHVlKSB7XG5cdCAgICAgICAgICAgICAgICBpZiAodmFsdWVba2V5XSA9PSBudWxsKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGRlZmF1bHRWYWx1ZTtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgKHZhbHVlW2tleV0pICE9PSB0eXBlKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcImludmFsaWQgZml4ZWQgZm9ybWF0IChcIiArIGtleSArIFwiIG5vdCBcIiArIHR5cGUgKyBcIilcIiwgXCJmb3JtYXQuXCIgKyBrZXksIHZhbHVlW2tleV0pO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlW2tleV07XG5cdCAgICAgICAgICAgIH07XG5cdCAgICAgICAgICAgIHNpZ25lZCA9IGNoZWNrKFwic2lnbmVkXCIsIFwiYm9vbGVhblwiLCBzaWduZWQpO1xuXHQgICAgICAgICAgICB3aWR0aCA9IGNoZWNrKFwid2lkdGhcIiwgXCJudW1iZXJcIiwgd2lkdGgpO1xuXHQgICAgICAgICAgICBkZWNpbWFscyA9IGNoZWNrKFwiZGVjaW1hbHNcIiwgXCJudW1iZXJcIiwgZGVjaW1hbHMpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBpZiAod2lkdGggJSA4KSB7XG5cdCAgICAgICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJpbnZhbGlkIGZpeGVkIGZvcm1hdCB3aWR0aCAobm90IGJ5dGUgYWxpZ25lZClcIiwgXCJmb3JtYXQud2lkdGhcIiwgd2lkdGgpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBpZiAoZGVjaW1hbHMgPiA4MCkge1xuXHQgICAgICAgICAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwiaW52YWxpZCBmaXhlZCBmb3JtYXQgKGRlY2ltYWxzIHRvbyBsYXJnZSlcIiwgXCJmb3JtYXQuZGVjaW1hbHNcIiwgZGVjaW1hbHMpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICByZXR1cm4gbmV3IEZpeGVkRm9ybWF0KF9jb25zdHJ1Y3Rvckd1YXJkLCBzaWduZWQsIHdpZHRoLCBkZWNpbWFscyk7XG5cdCAgICB9O1xuXHQgICAgcmV0dXJuIEZpeGVkRm9ybWF0O1xuXHR9KCkpO1xuXHRleHBvcnRzLkZpeGVkRm9ybWF0ID0gRml4ZWRGb3JtYXQ7XG5cdHZhciBGaXhlZE51bWJlciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcblx0ICAgIGZ1bmN0aW9uIEZpeGVkTnVtYmVyKGNvbnN0cnVjdG9yR3VhcmQsIGhleCwgdmFsdWUsIGZvcm1hdCkge1xuXHQgICAgICAgIHZhciBfbmV3VGFyZ2V0ID0gdGhpcy5jb25zdHJ1Y3Rvcjtcblx0ICAgICAgICBsb2dnZXIuY2hlY2tOZXcoX25ld1RhcmdldCwgRml4ZWROdW1iZXIpO1xuXHQgICAgICAgIGlmIChjb25zdHJ1Y3Rvckd1YXJkICE9PSBfY29uc3RydWN0b3JHdWFyZCkge1xuXHQgICAgICAgICAgICBsb2dnZXIudGhyb3dFcnJvcihcImNhbm5vdCB1c2UgRml4ZWROdW1iZXIgY29uc3RydWN0b3I7IHVzZSBGaXhlZE51bWJlci5mcm9tXCIsIGxpYi5Mb2dnZXIuZXJyb3JzLlVOU1VQUE9SVEVEX09QRVJBVElPTiwge1xuXHQgICAgICAgICAgICAgICAgb3BlcmF0aW9uOiBcIm5ldyBGaXhlZEZvcm1hdFwiXG5cdCAgICAgICAgICAgIH0pO1xuXHQgICAgICAgIH1cblx0ICAgICAgICB0aGlzLmZvcm1hdCA9IGZvcm1hdDtcblx0ICAgICAgICB0aGlzLl9oZXggPSBoZXg7XG5cdCAgICAgICAgdGhpcy5fdmFsdWUgPSB2YWx1ZTtcblx0ICAgICAgICB0aGlzLl9pc0ZpeGVkTnVtYmVyID0gdHJ1ZTtcblx0ICAgICAgICBPYmplY3QuZnJlZXplKHRoaXMpO1xuXHQgICAgfVxuXHQgICAgRml4ZWROdW1iZXIucHJvdG90eXBlLl9jaGVja0Zvcm1hdCA9IGZ1bmN0aW9uIChvdGhlcikge1xuXHQgICAgICAgIGlmICh0aGlzLmZvcm1hdC5uYW1lICE9PSBvdGhlci5mb3JtYXQubmFtZSkge1xuXHQgICAgICAgICAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwiaW5jb21wYXRpYmxlIGZvcm1hdDsgdXNlIGZpeGVkTnVtYmVyLnRvRm9ybWF0XCIsIFwib3RoZXJcIiwgb3RoZXIpO1xuXHQgICAgICAgIH1cblx0ICAgIH07XG5cdCAgICBGaXhlZE51bWJlci5wcm90b3R5cGUuYWRkVW5zYWZlID0gZnVuY3Rpb24gKG90aGVyKSB7XG5cdCAgICAgICAgdGhpcy5fY2hlY2tGb3JtYXQob3RoZXIpO1xuXHQgICAgICAgIHZhciBhID0gcGFyc2VGaXhlZCh0aGlzLl92YWx1ZSwgdGhpcy5mb3JtYXQuZGVjaW1hbHMpO1xuXHQgICAgICAgIHZhciBiID0gcGFyc2VGaXhlZChvdGhlci5fdmFsdWUsIG90aGVyLmZvcm1hdC5kZWNpbWFscyk7XG5cdCAgICAgICAgcmV0dXJuIEZpeGVkTnVtYmVyLmZyb21WYWx1ZShhLmFkZChiKSwgdGhpcy5mb3JtYXQuZGVjaW1hbHMsIHRoaXMuZm9ybWF0KTtcblx0ICAgIH07XG5cdCAgICBGaXhlZE51bWJlci5wcm90b3R5cGUuc3ViVW5zYWZlID0gZnVuY3Rpb24gKG90aGVyKSB7XG5cdCAgICAgICAgdGhpcy5fY2hlY2tGb3JtYXQob3RoZXIpO1xuXHQgICAgICAgIHZhciBhID0gcGFyc2VGaXhlZCh0aGlzLl92YWx1ZSwgdGhpcy5mb3JtYXQuZGVjaW1hbHMpO1xuXHQgICAgICAgIHZhciBiID0gcGFyc2VGaXhlZChvdGhlci5fdmFsdWUsIG90aGVyLmZvcm1hdC5kZWNpbWFscyk7XG5cdCAgICAgICAgcmV0dXJuIEZpeGVkTnVtYmVyLmZyb21WYWx1ZShhLnN1YihiKSwgdGhpcy5mb3JtYXQuZGVjaW1hbHMsIHRoaXMuZm9ybWF0KTtcblx0ICAgIH07XG5cdCAgICBGaXhlZE51bWJlci5wcm90b3R5cGUubXVsVW5zYWZlID0gZnVuY3Rpb24gKG90aGVyKSB7XG5cdCAgICAgICAgdGhpcy5fY2hlY2tGb3JtYXQob3RoZXIpO1xuXHQgICAgICAgIHZhciBhID0gcGFyc2VGaXhlZCh0aGlzLl92YWx1ZSwgdGhpcy5mb3JtYXQuZGVjaW1hbHMpO1xuXHQgICAgICAgIHZhciBiID0gcGFyc2VGaXhlZChvdGhlci5fdmFsdWUsIG90aGVyLmZvcm1hdC5kZWNpbWFscyk7XG5cdCAgICAgICAgcmV0dXJuIEZpeGVkTnVtYmVyLmZyb21WYWx1ZShhLm11bChiKS5kaXYodGhpcy5mb3JtYXQuX211bHRpcGxpZXIpLCB0aGlzLmZvcm1hdC5kZWNpbWFscywgdGhpcy5mb3JtYXQpO1xuXHQgICAgfTtcblx0ICAgIEZpeGVkTnVtYmVyLnByb3RvdHlwZS5kaXZVbnNhZmUgPSBmdW5jdGlvbiAob3RoZXIpIHtcblx0ICAgICAgICB0aGlzLl9jaGVja0Zvcm1hdChvdGhlcik7XG5cdCAgICAgICAgdmFyIGEgPSBwYXJzZUZpeGVkKHRoaXMuX3ZhbHVlLCB0aGlzLmZvcm1hdC5kZWNpbWFscyk7XG5cdCAgICAgICAgdmFyIGIgPSBwYXJzZUZpeGVkKG90aGVyLl92YWx1ZSwgb3RoZXIuZm9ybWF0LmRlY2ltYWxzKTtcblx0ICAgICAgICByZXR1cm4gRml4ZWROdW1iZXIuZnJvbVZhbHVlKGEubXVsKHRoaXMuZm9ybWF0Ll9tdWx0aXBsaWVyKS5kaXYoYiksIHRoaXMuZm9ybWF0LmRlY2ltYWxzLCB0aGlzLmZvcm1hdCk7XG5cdCAgICB9O1xuXHQgICAgRml4ZWROdW1iZXIucHJvdG90eXBlLmZsb29yID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIHZhciBjb21wcyA9IHRoaXMudG9TdHJpbmcoKS5zcGxpdChcIi5cIik7XG5cdCAgICAgICAgaWYgKGNvbXBzLmxlbmd0aCA9PT0gMSkge1xuXHQgICAgICAgICAgICBjb21wcy5wdXNoKFwiMFwiKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgdmFyIHJlc3VsdCA9IEZpeGVkTnVtYmVyLmZyb20oY29tcHNbMF0sIHRoaXMuZm9ybWF0KTtcblx0ICAgICAgICB2YXIgaGFzRnJhY3Rpb24gPSAhY29tcHNbMV0ubWF0Y2goL14oMCopJC8pO1xuXHQgICAgICAgIGlmICh0aGlzLmlzTmVnYXRpdmUoKSAmJiBoYXNGcmFjdGlvbikge1xuXHQgICAgICAgICAgICByZXN1bHQgPSByZXN1bHQuc3ViVW5zYWZlKE9ORS50b0Zvcm1hdChyZXN1bHQuZm9ybWF0KSk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHJldHVybiByZXN1bHQ7XG5cdCAgICB9O1xuXHQgICAgRml4ZWROdW1iZXIucHJvdG90eXBlLmNlaWxpbmcgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgdmFyIGNvbXBzID0gdGhpcy50b1N0cmluZygpLnNwbGl0KFwiLlwiKTtcblx0ICAgICAgICBpZiAoY29tcHMubGVuZ3RoID09PSAxKSB7XG5cdCAgICAgICAgICAgIGNvbXBzLnB1c2goXCIwXCIpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICB2YXIgcmVzdWx0ID0gRml4ZWROdW1iZXIuZnJvbShjb21wc1swXSwgdGhpcy5mb3JtYXQpO1xuXHQgICAgICAgIHZhciBoYXNGcmFjdGlvbiA9ICFjb21wc1sxXS5tYXRjaCgvXigwKikkLyk7XG5cdCAgICAgICAgaWYgKCF0aGlzLmlzTmVnYXRpdmUoKSAmJiBoYXNGcmFjdGlvbikge1xuXHQgICAgICAgICAgICByZXN1bHQgPSByZXN1bHQuYWRkVW5zYWZlKE9ORS50b0Zvcm1hdChyZXN1bHQuZm9ybWF0KSk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHJldHVybiByZXN1bHQ7XG5cdCAgICB9O1xuXHQgICAgLy8gQFRPRE86IFN1cHBvcnQgb3RoZXIgcm91bmRpbmcgYWxnb3JpdGhtc1xuXHQgICAgRml4ZWROdW1iZXIucHJvdG90eXBlLnJvdW5kID0gZnVuY3Rpb24gKGRlY2ltYWxzKSB7XG5cdCAgICAgICAgaWYgKGRlY2ltYWxzID09IG51bGwpIHtcblx0ICAgICAgICAgICAgZGVjaW1hbHMgPSAwO1xuXHQgICAgICAgIH1cblx0ICAgICAgICAvLyBJZiB3ZSBhcmUgYWxyZWFkeSBpbiByYW5nZSwgd2UncmUgZG9uZVxuXHQgICAgICAgIHZhciBjb21wcyA9IHRoaXMudG9TdHJpbmcoKS5zcGxpdChcIi5cIik7XG5cdCAgICAgICAgaWYgKGNvbXBzLmxlbmd0aCA9PT0gMSkge1xuXHQgICAgICAgICAgICBjb21wcy5wdXNoKFwiMFwiKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgaWYgKGRlY2ltYWxzIDwgMCB8fCBkZWNpbWFscyA+IDgwIHx8IChkZWNpbWFscyAlIDEpKSB7XG5cdCAgICAgICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJpbnZhbGlkIGRlY2ltYWwgY291bnRcIiwgXCJkZWNpbWFsc1wiLCBkZWNpbWFscyk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGlmIChjb21wc1sxXS5sZW5ndGggPD0gZGVjaW1hbHMpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHZhciBmYWN0b3IgPSBGaXhlZE51bWJlci5mcm9tKFwiMVwiICsgemVyb3Muc3Vic3RyaW5nKDAsIGRlY2ltYWxzKSwgdGhpcy5mb3JtYXQpO1xuXHQgICAgICAgIHZhciBidW1wID0gQlVNUC50b0Zvcm1hdCh0aGlzLmZvcm1hdCk7XG5cdCAgICAgICAgcmV0dXJuIHRoaXMubXVsVW5zYWZlKGZhY3RvcikuYWRkVW5zYWZlKGJ1bXApLmZsb29yKCkuZGl2VW5zYWZlKGZhY3Rvcik7XG5cdCAgICB9O1xuXHQgICAgRml4ZWROdW1iZXIucHJvdG90eXBlLmlzWmVybyA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICByZXR1cm4gKHRoaXMuX3ZhbHVlID09PSBcIjAuMFwiIHx8IHRoaXMuX3ZhbHVlID09PSBcIjBcIik7XG5cdCAgICB9O1xuXHQgICAgRml4ZWROdW1iZXIucHJvdG90eXBlLmlzTmVnYXRpdmUgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgcmV0dXJuICh0aGlzLl92YWx1ZVswXSA9PT0gXCItXCIpO1xuXHQgICAgfTtcblx0ICAgIEZpeGVkTnVtYmVyLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX3ZhbHVlOyB9O1xuXHQgICAgRml4ZWROdW1iZXIucHJvdG90eXBlLnRvSGV4U3RyaW5nID0gZnVuY3Rpb24gKHdpZHRoKSB7XG5cdCAgICAgICAgaWYgKHdpZHRoID09IG51bGwpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2hleDtcblx0ICAgICAgICB9XG5cdCAgICAgICAgaWYgKHdpZHRoICUgOCkge1xuXHQgICAgICAgICAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwiaW52YWxpZCBieXRlIHdpZHRoXCIsIFwid2lkdGhcIiwgd2lkdGgpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICB2YXIgaGV4ID0gYmlnbnVtYmVyLkJpZ051bWJlci5mcm9tKHRoaXMuX2hleCkuZnJvbVR3b3ModGhpcy5mb3JtYXQud2lkdGgpLnRvVHdvcyh3aWR0aCkudG9IZXhTdHJpbmcoKTtcblx0ICAgICAgICByZXR1cm4gKDAsIGxpYiQxLmhleFplcm9QYWQpKGhleCwgd2lkdGggLyA4KTtcblx0ICAgIH07XG5cdCAgICBGaXhlZE51bWJlci5wcm90b3R5cGUudG9VbnNhZmVGbG9hdCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHBhcnNlRmxvYXQodGhpcy50b1N0cmluZygpKTsgfTtcblx0ICAgIEZpeGVkTnVtYmVyLnByb3RvdHlwZS50b0Zvcm1hdCA9IGZ1bmN0aW9uIChmb3JtYXQpIHtcblx0ICAgICAgICByZXR1cm4gRml4ZWROdW1iZXIuZnJvbVN0cmluZyh0aGlzLl92YWx1ZSwgZm9ybWF0KTtcblx0ICAgIH07XG5cdCAgICBGaXhlZE51bWJlci5mcm9tVmFsdWUgPSBmdW5jdGlvbiAodmFsdWUsIGRlY2ltYWxzLCBmb3JtYXQpIHtcblx0ICAgICAgICAvLyBJZiBkZWNpbWFscyBsb29rcyBtb3JlIGxpa2UgYSBmb3JtYXQsIGFuZCB0aGVyZSBpcyBubyBmb3JtYXQsIHNoaWZ0IHRoZSBwYXJhbWV0ZXJzXG5cdCAgICAgICAgaWYgKGZvcm1hdCA9PSBudWxsICYmIGRlY2ltYWxzICE9IG51bGwgJiYgISgwLCBiaWdudW1iZXIuaXNCaWdOdW1iZXJpc2gpKGRlY2ltYWxzKSkge1xuXHQgICAgICAgICAgICBmb3JtYXQgPSBkZWNpbWFscztcblx0ICAgICAgICAgICAgZGVjaW1hbHMgPSBudWxsO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBpZiAoZGVjaW1hbHMgPT0gbnVsbCkge1xuXHQgICAgICAgICAgICBkZWNpbWFscyA9IDA7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGlmIChmb3JtYXQgPT0gbnVsbCkge1xuXHQgICAgICAgICAgICBmb3JtYXQgPSBcImZpeGVkXCI7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHJldHVybiBGaXhlZE51bWJlci5mcm9tU3RyaW5nKGZvcm1hdEZpeGVkKHZhbHVlLCBkZWNpbWFscyksIEZpeGVkRm9ybWF0LmZyb20oZm9ybWF0KSk7XG5cdCAgICB9O1xuXHQgICAgRml4ZWROdW1iZXIuZnJvbVN0cmluZyA9IGZ1bmN0aW9uICh2YWx1ZSwgZm9ybWF0KSB7XG5cdCAgICAgICAgaWYgKGZvcm1hdCA9PSBudWxsKSB7XG5cdCAgICAgICAgICAgIGZvcm1hdCA9IFwiZml4ZWRcIjtcblx0ICAgICAgICB9XG5cdCAgICAgICAgdmFyIGZpeGVkRm9ybWF0ID0gRml4ZWRGb3JtYXQuZnJvbShmb3JtYXQpO1xuXHQgICAgICAgIHZhciBudW1lcmljID0gcGFyc2VGaXhlZCh2YWx1ZSwgZml4ZWRGb3JtYXQuZGVjaW1hbHMpO1xuXHQgICAgICAgIGlmICghZml4ZWRGb3JtYXQuc2lnbmVkICYmIG51bWVyaWMubHQoWmVybykpIHtcblx0ICAgICAgICAgICAgdGhyb3dGYXVsdChcInVuc2lnbmVkIHZhbHVlIGNhbm5vdCBiZSBuZWdhdGl2ZVwiLCBcIm92ZXJmbG93XCIsIFwidmFsdWVcIiwgdmFsdWUpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICB2YXIgaGV4ID0gbnVsbDtcblx0ICAgICAgICBpZiAoZml4ZWRGb3JtYXQuc2lnbmVkKSB7XG5cdCAgICAgICAgICAgIGhleCA9IG51bWVyaWMudG9Ud29zKGZpeGVkRm9ybWF0LndpZHRoKS50b0hleFN0cmluZygpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBlbHNlIHtcblx0ICAgICAgICAgICAgaGV4ID0gbnVtZXJpYy50b0hleFN0cmluZygpO1xuXHQgICAgICAgICAgICBoZXggPSAoMCwgbGliJDEuaGV4WmVyb1BhZCkoaGV4LCBmaXhlZEZvcm1hdC53aWR0aCAvIDgpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICB2YXIgZGVjaW1hbCA9IGZvcm1hdEZpeGVkKG51bWVyaWMsIGZpeGVkRm9ybWF0LmRlY2ltYWxzKTtcblx0ICAgICAgICByZXR1cm4gbmV3IEZpeGVkTnVtYmVyKF9jb25zdHJ1Y3Rvckd1YXJkLCBoZXgsIGRlY2ltYWwsIGZpeGVkRm9ybWF0KTtcblx0ICAgIH07XG5cdCAgICBGaXhlZE51bWJlci5mcm9tQnl0ZXMgPSBmdW5jdGlvbiAodmFsdWUsIGZvcm1hdCkge1xuXHQgICAgICAgIGlmIChmb3JtYXQgPT0gbnVsbCkge1xuXHQgICAgICAgICAgICBmb3JtYXQgPSBcImZpeGVkXCI7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHZhciBmaXhlZEZvcm1hdCA9IEZpeGVkRm9ybWF0LmZyb20oZm9ybWF0KTtcblx0ICAgICAgICBpZiAoKDAsIGxpYiQxLmFycmF5aWZ5KSh2YWx1ZSkubGVuZ3RoID4gZml4ZWRGb3JtYXQud2lkdGggLyA4KSB7XG5cdCAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIm92ZXJmbG93XCIpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICB2YXIgbnVtZXJpYyA9IGJpZ251bWJlci5CaWdOdW1iZXIuZnJvbSh2YWx1ZSk7XG5cdCAgICAgICAgaWYgKGZpeGVkRm9ybWF0LnNpZ25lZCkge1xuXHQgICAgICAgICAgICBudW1lcmljID0gbnVtZXJpYy5mcm9tVHdvcyhmaXhlZEZvcm1hdC53aWR0aCk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHZhciBoZXggPSBudW1lcmljLnRvVHdvcygoZml4ZWRGb3JtYXQuc2lnbmVkID8gMCA6IDEpICsgZml4ZWRGb3JtYXQud2lkdGgpLnRvSGV4U3RyaW5nKCk7XG5cdCAgICAgICAgdmFyIGRlY2ltYWwgPSBmb3JtYXRGaXhlZChudW1lcmljLCBmaXhlZEZvcm1hdC5kZWNpbWFscyk7XG5cdCAgICAgICAgcmV0dXJuIG5ldyBGaXhlZE51bWJlcihfY29uc3RydWN0b3JHdWFyZCwgaGV4LCBkZWNpbWFsLCBmaXhlZEZvcm1hdCk7XG5cdCAgICB9O1xuXHQgICAgRml4ZWROdW1iZXIuZnJvbSA9IGZ1bmN0aW9uICh2YWx1ZSwgZm9ybWF0KSB7XG5cdCAgICAgICAgaWYgKHR5cGVvZiAodmFsdWUpID09PSBcInN0cmluZ1wiKSB7XG5cdCAgICAgICAgICAgIHJldHVybiBGaXhlZE51bWJlci5mcm9tU3RyaW5nKHZhbHVlLCBmb3JtYXQpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBpZiAoKDAsIGxpYiQxLmlzQnl0ZXMpKHZhbHVlKSkge1xuXHQgICAgICAgICAgICByZXR1cm4gRml4ZWROdW1iZXIuZnJvbUJ5dGVzKHZhbHVlLCBmb3JtYXQpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICB0cnkge1xuXHQgICAgICAgICAgICByZXR1cm4gRml4ZWROdW1iZXIuZnJvbVZhbHVlKHZhbHVlLCAwLCBmb3JtYXQpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBjYXRjaCAoZXJyb3IpIHtcblx0ICAgICAgICAgICAgLy8gQWxsb3cgTlVNRVJJQ19GQVVMVCB0byBidWJibGUgdXBcblx0ICAgICAgICAgICAgaWYgKGVycm9yLmNvZGUgIT09IGxpYi5Mb2dnZXIuZXJyb3JzLklOVkFMSURfQVJHVU1FTlQpIHtcblx0ICAgICAgICAgICAgICAgIHRocm93IGVycm9yO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHJldHVybiBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwiaW52YWxpZCBGaXhlZE51bWJlciB2YWx1ZVwiLCBcInZhbHVlXCIsIHZhbHVlKTtcblx0ICAgIH07XG5cdCAgICBGaXhlZE51bWJlci5pc0ZpeGVkTnVtYmVyID0gZnVuY3Rpb24gKHZhbHVlKSB7XG5cdCAgICAgICAgcmV0dXJuICEhKHZhbHVlICYmIHZhbHVlLl9pc0ZpeGVkTnVtYmVyKTtcblx0ICAgIH07XG5cdCAgICByZXR1cm4gRml4ZWROdW1iZXI7XG5cdH0oKSk7XG5cdGV4cG9ydHMuRml4ZWROdW1iZXIgPSBGaXhlZE51bWJlcjtcblx0dmFyIE9ORSA9IEZpeGVkTnVtYmVyLmZyb20oMSk7XG5cdHZhciBCVU1QID0gRml4ZWROdW1iZXIuZnJvbShcIjAuNVwiKTtcblxuXHR9KTtcblxuXHR2YXIgZml4ZWRudW1iZXIkMSA9IC8qQF9fUFVSRV9fKi9nZXREZWZhdWx0RXhwb3J0RnJvbUNqcyhmaXhlZG51bWJlcik7XG5cblx0dmFyIGxpYiQyID0gY3JlYXRlQ29tbW9uanNNb2R1bGUoZnVuY3Rpb24gKG1vZHVsZSwgZXhwb3J0cykge1xuXHRcInVzZSBzdHJpY3RcIjtcblx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuXHRleHBvcnRzLl9iYXNlMzZUbzE2ID0gZXhwb3J0cy5fYmFzZTE2VG8zNiA9IGV4cG9ydHMucGFyc2VGaXhlZCA9IGV4cG9ydHMuRml4ZWROdW1iZXIgPSBleHBvcnRzLkZpeGVkRm9ybWF0ID0gZXhwb3J0cy5mb3JtYXRGaXhlZCA9IGV4cG9ydHMuQmlnTnVtYmVyID0gdm9pZCAwO1xuXG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkJpZ051bWJlclwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gYmlnbnVtYmVyLkJpZ051bWJlcjsgfSB9KTtcblxuXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJmb3JtYXRGaXhlZFwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gZml4ZWRudW1iZXIuZm9ybWF0Rml4ZWQ7IH0gfSk7XG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkZpeGVkRm9ybWF0XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBmaXhlZG51bWJlci5GaXhlZEZvcm1hdDsgfSB9KTtcblx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiRml4ZWROdW1iZXJcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGZpeGVkbnVtYmVyLkZpeGVkTnVtYmVyOyB9IH0pO1xuXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJwYXJzZUZpeGVkXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBmaXhlZG51bWJlci5wYXJzZUZpeGVkOyB9IH0pO1xuXHQvLyBJbnRlcm5hbCBtZXRob2RzIHVzZWQgYnkgYWRkcmVzc1xuXHR2YXIgYmlnbnVtYmVyXzIgPSBiaWdudW1iZXI7XG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9iYXNlMTZUbzM2XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBiaWdudW1iZXJfMi5fYmFzZTE2VG8zNjsgfSB9KTtcblx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX2Jhc2UzNlRvMTZcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGJpZ251bWJlcl8yLl9iYXNlMzZUbzE2OyB9IH0pO1xuXG5cdH0pO1xuXG5cdHZhciBpbmRleCQyID0gLypAX19QVVJFX18qL2dldERlZmF1bHRFeHBvcnRGcm9tQ2pzKGxpYiQyKTtcblxuXHR2YXIgX3ZlcnNpb24kNiA9IGNyZWF0ZUNvbW1vbmpzTW9kdWxlKGZ1bmN0aW9uIChtb2R1bGUsIGV4cG9ydHMpIHtcblx0XCJ1c2Ugc3RyaWN0XCI7XG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcblx0ZXhwb3J0cy52ZXJzaW9uID0gdm9pZCAwO1xuXHRleHBvcnRzLnZlcnNpb24gPSBcInByb3BlcnRpZXMvNS41LjBcIjtcblxuXHR9KTtcblxuXHR2YXIgX3ZlcnNpb24kNyA9IC8qQF9fUFVSRV9fKi9nZXREZWZhdWx0RXhwb3J0RnJvbUNqcyhfdmVyc2lvbiQ2KTtcblxuXHR2YXIgbGliJDMgPSBjcmVhdGVDb21tb25qc01vZHVsZShmdW5jdGlvbiAobW9kdWxlLCBleHBvcnRzKSB7XG5cdFwidXNlIHN0cmljdFwiO1xuXHR2YXIgX19hd2FpdGVyID0gKGNvbW1vbmpzR2xvYmFsICYmIGNvbW1vbmpzR2xvYmFsLl9fYXdhaXRlcikgfHwgZnVuY3Rpb24gKHRoaXNBcmcsIF9hcmd1bWVudHMsIFAsIGdlbmVyYXRvcikge1xuXHQgICAgZnVuY3Rpb24gYWRvcHQodmFsdWUpIHsgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgUCA/IHZhbHVlIDogbmV3IFAoZnVuY3Rpb24gKHJlc29sdmUpIHsgcmVzb2x2ZSh2YWx1ZSk7IH0pOyB9XG5cdCAgICByZXR1cm4gbmV3IChQIHx8IChQID0gUHJvbWlzZSkpKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcblx0ICAgICAgICBmdW5jdGlvbiBmdWxmaWxsZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3IubmV4dCh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG5cdCAgICAgICAgZnVuY3Rpb24gcmVqZWN0ZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3JbXCJ0aHJvd1wiXSh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG5cdCAgICAgICAgZnVuY3Rpb24gc3RlcChyZXN1bHQpIHsgcmVzdWx0LmRvbmUgPyByZXNvbHZlKHJlc3VsdC52YWx1ZSkgOiBhZG9wdChyZXN1bHQudmFsdWUpLnRoZW4oZnVsZmlsbGVkLCByZWplY3RlZCk7IH1cblx0ICAgICAgICBzdGVwKChnZW5lcmF0b3IgPSBnZW5lcmF0b3IuYXBwbHkodGhpc0FyZywgX2FyZ3VtZW50cyB8fCBbXSkpLm5leHQoKSk7XG5cdCAgICB9KTtcblx0fTtcblx0dmFyIF9fZ2VuZXJhdG9yID0gKGNvbW1vbmpzR2xvYmFsICYmIGNvbW1vbmpzR2xvYmFsLl9fZ2VuZXJhdG9yKSB8fCBmdW5jdGlvbiAodGhpc0FyZywgYm9keSkge1xuXHQgICAgdmFyIF8gPSB7IGxhYmVsOiAwLCBzZW50OiBmdW5jdGlvbigpIHsgaWYgKHRbMF0gJiAxKSB0aHJvdyB0WzFdOyByZXR1cm4gdFsxXTsgfSwgdHJ5czogW10sIG9wczogW10gfSwgZiwgeSwgdCwgZztcblx0ICAgIHJldHVybiBnID0geyBuZXh0OiB2ZXJiKDApLCBcInRocm93XCI6IHZlcmIoMSksIFwicmV0dXJuXCI6IHZlcmIoMikgfSwgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIChnW1N5bWJvbC5pdGVyYXRvcl0gPSBmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXM7IH0pLCBnO1xuXHQgICAgZnVuY3Rpb24gdmVyYihuKSB7IHJldHVybiBmdW5jdGlvbiAodikgeyByZXR1cm4gc3RlcChbbiwgdl0pOyB9OyB9XG5cdCAgICBmdW5jdGlvbiBzdGVwKG9wKSB7XG5cdCAgICAgICAgaWYgKGYpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJHZW5lcmF0b3IgaXMgYWxyZWFkeSBleGVjdXRpbmcuXCIpO1xuXHQgICAgICAgIHdoaWxlIChfKSB0cnkge1xuXHQgICAgICAgICAgICBpZiAoZiA9IDEsIHkgJiYgKHQgPSBvcFswXSAmIDIgPyB5W1wicmV0dXJuXCJdIDogb3BbMF0gPyB5W1widGhyb3dcIl0gfHwgKCh0ID0geVtcInJldHVyblwiXSkgJiYgdC5jYWxsKHkpLCAwKSA6IHkubmV4dCkgJiYgISh0ID0gdC5jYWxsKHksIG9wWzFdKSkuZG9uZSkgcmV0dXJuIHQ7XG5cdCAgICAgICAgICAgIGlmICh5ID0gMCwgdCkgb3AgPSBbb3BbMF0gJiAyLCB0LnZhbHVlXTtcblx0ICAgICAgICAgICAgc3dpdGNoIChvcFswXSkge1xuXHQgICAgICAgICAgICAgICAgY2FzZSAwOiBjYXNlIDE6IHQgPSBvcDsgYnJlYWs7XG5cdCAgICAgICAgICAgICAgICBjYXNlIDQ6IF8ubGFiZWwrKzsgcmV0dXJuIHsgdmFsdWU6IG9wWzFdLCBkb25lOiBmYWxzZSB9O1xuXHQgICAgICAgICAgICAgICAgY2FzZSA1OiBfLmxhYmVsKys7IHkgPSBvcFsxXTsgb3AgPSBbMF07IGNvbnRpbnVlO1xuXHQgICAgICAgICAgICAgICAgY2FzZSA3OiBvcCA9IF8ub3BzLnBvcCgpOyBfLnRyeXMucG9wKCk7IGNvbnRpbnVlO1xuXHQgICAgICAgICAgICAgICAgZGVmYXVsdDpcblx0ICAgICAgICAgICAgICAgICAgICBpZiAoISh0ID0gXy50cnlzLCB0ID0gdC5sZW5ndGggPiAwICYmIHRbdC5sZW5ndGggLSAxXSkgJiYgKG9wWzBdID09PSA2IHx8IG9wWzBdID09PSAyKSkgeyBfID0gMDsgY29udGludWU7IH1cblx0ICAgICAgICAgICAgICAgICAgICBpZiAob3BbMF0gPT09IDMgJiYgKCF0IHx8IChvcFsxXSA+IHRbMF0gJiYgb3BbMV0gPCB0WzNdKSkpIHsgXy5sYWJlbCA9IG9wWzFdOyBicmVhazsgfVxuXHQgICAgICAgICAgICAgICAgICAgIGlmIChvcFswXSA9PT0gNiAmJiBfLmxhYmVsIDwgdFsxXSkgeyBfLmxhYmVsID0gdFsxXTsgdCA9IG9wOyBicmVhazsgfVxuXHQgICAgICAgICAgICAgICAgICAgIGlmICh0ICYmIF8ubGFiZWwgPCB0WzJdKSB7IF8ubGFiZWwgPSB0WzJdOyBfLm9wcy5wdXNoKG9wKTsgYnJlYWs7IH1cblx0ICAgICAgICAgICAgICAgICAgICBpZiAodFsyXSkgXy5vcHMucG9wKCk7XG5cdCAgICAgICAgICAgICAgICAgICAgXy50cnlzLnBvcCgpOyBjb250aW51ZTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICBvcCA9IGJvZHkuY2FsbCh0aGlzQXJnLCBfKTtcblx0ICAgICAgICB9IGNhdGNoIChlKSB7IG9wID0gWzYsIGVdOyB5ID0gMDsgfSBmaW5hbGx5IHsgZiA9IHQgPSAwOyB9XG5cdCAgICAgICAgaWYgKG9wWzBdICYgNSkgdGhyb3cgb3BbMV07IHJldHVybiB7IHZhbHVlOiBvcFswXSA/IG9wWzFdIDogdm9pZCAwLCBkb25lOiB0cnVlIH07XG5cdCAgICB9XG5cdH07XG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcblx0ZXhwb3J0cy5EZXNjcmlwdGlvbiA9IGV4cG9ydHMuZGVlcENvcHkgPSBleHBvcnRzLnNoYWxsb3dDb3B5ID0gZXhwb3J0cy5jaGVja1Byb3BlcnRpZXMgPSBleHBvcnRzLnJlc29sdmVQcm9wZXJ0aWVzID0gZXhwb3J0cy5nZXRTdGF0aWMgPSBleHBvcnRzLmRlZmluZVJlYWRPbmx5ID0gdm9pZCAwO1xuXG5cblx0dmFyIGxvZ2dlciA9IG5ldyBsaWIuTG9nZ2VyKF92ZXJzaW9uJDYudmVyc2lvbik7XG5cdGZ1bmN0aW9uIGRlZmluZVJlYWRPbmx5KG9iamVjdCwgbmFtZSwgdmFsdWUpIHtcblx0ICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmplY3QsIG5hbWUsIHtcblx0ICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuXHQgICAgICAgIHZhbHVlOiB2YWx1ZSxcblx0ICAgICAgICB3cml0YWJsZTogZmFsc2UsXG5cdCAgICB9KTtcblx0fVxuXHRleHBvcnRzLmRlZmluZVJlYWRPbmx5ID0gZGVmaW5lUmVhZE9ubHk7XG5cdC8vIENyYXdsIHVwIHRoZSBjb25zdHJ1Y3RvciBjaGFpbiB0byBmaW5kIGEgc3RhdGljIG1ldGhvZFxuXHRmdW5jdGlvbiBnZXRTdGF0aWMoY3Rvciwga2V5KSB7XG5cdCAgICBmb3IgKHZhciBpID0gMDsgaSA8IDMyOyBpKyspIHtcblx0ICAgICAgICBpZiAoY3RvcltrZXldKSB7XG5cdCAgICAgICAgICAgIHJldHVybiBjdG9yW2tleV07XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGlmICghY3Rvci5wcm90b3R5cGUgfHwgdHlwZW9mIChjdG9yLnByb3RvdHlwZSkgIT09IFwib2JqZWN0XCIpIHtcblx0ICAgICAgICAgICAgYnJlYWs7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGN0b3IgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YoY3Rvci5wcm90b3R5cGUpLmNvbnN0cnVjdG9yO1xuXHQgICAgfVxuXHQgICAgcmV0dXJuIG51bGw7XG5cdH1cblx0ZXhwb3J0cy5nZXRTdGF0aWMgPSBnZXRTdGF0aWM7XG5cdGZ1bmN0aW9uIHJlc29sdmVQcm9wZXJ0aWVzKG9iamVjdCkge1xuXHQgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIHZhciBwcm9taXNlcywgcmVzdWx0cztcblx0ICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG5cdCAgICAgICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcblx0ICAgICAgICAgICAgICAgIGNhc2UgMDpcblx0ICAgICAgICAgICAgICAgICAgICBwcm9taXNlcyA9IE9iamVjdC5rZXlzKG9iamVjdCkubWFwKGZ1bmN0aW9uIChrZXkpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHZhbHVlID0gb2JqZWN0W2tleV07XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUodmFsdWUpLnRoZW4oZnVuY3Rpb24gKHYpIHsgcmV0dXJuICh7IGtleToga2V5LCB2YWx1ZTogdiB9KTsgfSk7XG5cdCAgICAgICAgICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgUHJvbWlzZS5hbGwocHJvbWlzZXMpXTtcblx0ICAgICAgICAgICAgICAgIGNhc2UgMTpcblx0ICAgICAgICAgICAgICAgICAgICByZXN1bHRzID0gX2Euc2VudCgpO1xuXHQgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCByZXN1bHRzLnJlZHVjZShmdW5jdGlvbiAoYWNjdW0sIHJlc3VsdCkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgYWNjdW1bKHJlc3VsdC5rZXkpXSA9IHJlc3VsdC52YWx1ZTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBhY2N1bTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfSwge30pXTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH0pO1xuXHQgICAgfSk7XG5cdH1cblx0ZXhwb3J0cy5yZXNvbHZlUHJvcGVydGllcyA9IHJlc29sdmVQcm9wZXJ0aWVzO1xuXHRmdW5jdGlvbiBjaGVja1Byb3BlcnRpZXMob2JqZWN0LCBwcm9wZXJ0aWVzKSB7XG5cdCAgICBpZiAoIW9iamVjdCB8fCB0eXBlb2YgKG9iamVjdCkgIT09IFwib2JqZWN0XCIpIHtcblx0ICAgICAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwiaW52YWxpZCBvYmplY3RcIiwgXCJvYmplY3RcIiwgb2JqZWN0KTtcblx0ICAgIH1cblx0ICAgIE9iamVjdC5rZXlzKG9iamVjdCkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG5cdCAgICAgICAgaWYgKCFwcm9wZXJ0aWVzW2tleV0pIHtcblx0ICAgICAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcImludmFsaWQgb2JqZWN0IGtleSAtIFwiICsga2V5LCBcInRyYW5zYWN0aW9uOlwiICsga2V5LCBvYmplY3QpO1xuXHQgICAgICAgIH1cblx0ICAgIH0pO1xuXHR9XG5cdGV4cG9ydHMuY2hlY2tQcm9wZXJ0aWVzID0gY2hlY2tQcm9wZXJ0aWVzO1xuXHRmdW5jdGlvbiBzaGFsbG93Q29weShvYmplY3QpIHtcblx0ICAgIHZhciByZXN1bHQgPSB7fTtcblx0ICAgIGZvciAodmFyIGtleSBpbiBvYmplY3QpIHtcblx0ICAgICAgICByZXN1bHRba2V5XSA9IG9iamVjdFtrZXldO1xuXHQgICAgfVxuXHQgICAgcmV0dXJuIHJlc3VsdDtcblx0fVxuXHRleHBvcnRzLnNoYWxsb3dDb3B5ID0gc2hhbGxvd0NvcHk7XG5cdHZhciBvcGFxdWUgPSB7IGJpZ2ludDogdHJ1ZSwgYm9vbGVhbjogdHJ1ZSwgXCJmdW5jdGlvblwiOiB0cnVlLCBudW1iZXI6IHRydWUsIHN0cmluZzogdHJ1ZSB9O1xuXHRmdW5jdGlvbiBfaXNGcm96ZW4ob2JqZWN0KSB7XG5cdCAgICAvLyBPcGFxdWUgb2JqZWN0cyBhcmUgbm90IG11dGFibGUsIHNvIHNhZmUgdG8gY29weSBieSBhc3NpZ25tZW50XG5cdCAgICBpZiAob2JqZWN0ID09PSB1bmRlZmluZWQgfHwgb2JqZWN0ID09PSBudWxsIHx8IG9wYXF1ZVt0eXBlb2YgKG9iamVjdCldKSB7XG5cdCAgICAgICAgcmV0dXJuIHRydWU7XG5cdCAgICB9XG5cdCAgICBpZiAoQXJyYXkuaXNBcnJheShvYmplY3QpIHx8IHR5cGVvZiAob2JqZWN0KSA9PT0gXCJvYmplY3RcIikge1xuXHQgICAgICAgIGlmICghT2JqZWN0LmlzRnJvemVuKG9iamVjdCkpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuXHQgICAgICAgIH1cblx0ICAgICAgICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKG9iamVjdCk7XG5cdCAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKSB7XG5cdCAgICAgICAgICAgIHZhciB2YWx1ZSA9IG51bGw7XG5cdCAgICAgICAgICAgIHRyeSB7XG5cdCAgICAgICAgICAgICAgICB2YWx1ZSA9IG9iamVjdFtrZXlzW2ldXTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcblx0ICAgICAgICAgICAgICAgIC8vIElmIGFjY2Vzc2luZyBhIHZhbHVlIHRyaWdnZXJzIGFuIGVycm9yLCBpdCBpcyBhIGdldHRlclxuXHQgICAgICAgICAgICAgICAgLy8gZGVzaWduZWQgdG8gZG8gc28gKGUuZy4gUmVzdWx0KSBhbmQgaXMgdGhlcmVmb3JlIFwiZnJvemVuXCJcblx0ICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIGlmICghX2lzRnJvemVuKHZhbHVlKSkge1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHJldHVybiB0cnVlO1xuXHQgICAgfVxuXHQgICAgcmV0dXJuIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJDYW5ub3QgZGVlcENvcHkgXCIgKyB0eXBlb2YgKG9iamVjdCksIFwib2JqZWN0XCIsIG9iamVjdCk7XG5cdH1cblx0Ly8gUmV0dXJucyBhIG5ldyBjb3B5IG9mIG9iamVjdCwgc3VjaCB0aGF0IG5vIHByb3BlcnRpZXMgbWF5IGJlIHJlcGxhY2VkLlxuXHQvLyBOZXcgcHJvcGVydGllcyBtYXkgYmUgYWRkZWQgb25seSB0byBvYmplY3RzLlxuXHRmdW5jdGlvbiBfZGVlcENvcHkob2JqZWN0KSB7XG5cdCAgICBpZiAoX2lzRnJvemVuKG9iamVjdCkpIHtcblx0ICAgICAgICByZXR1cm4gb2JqZWN0O1xuXHQgICAgfVxuXHQgICAgLy8gQXJyYXlzIGFyZSBtdXRhYmxlLCBzbyB3ZSBuZWVkIHRvIGNyZWF0ZSBhIGNvcHlcblx0ICAgIGlmIChBcnJheS5pc0FycmF5KG9iamVjdCkpIHtcblx0ICAgICAgICByZXR1cm4gT2JqZWN0LmZyZWV6ZShvYmplY3QubWFwKGZ1bmN0aW9uIChpdGVtKSB7IHJldHVybiBkZWVwQ29weShpdGVtKTsgfSkpO1xuXHQgICAgfVxuXHQgICAgaWYgKHR5cGVvZiAob2JqZWN0KSA9PT0gXCJvYmplY3RcIikge1xuXHQgICAgICAgIHZhciByZXN1bHQgPSB7fTtcblx0ICAgICAgICBmb3IgKHZhciBrZXkgaW4gb2JqZWN0KSB7XG5cdCAgICAgICAgICAgIHZhciB2YWx1ZSA9IG9iamVjdFtrZXldO1xuXHQgICAgICAgICAgICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCkge1xuXHQgICAgICAgICAgICAgICAgY29udGludWU7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgZGVmaW5lUmVhZE9ubHkocmVzdWx0LCBrZXksIGRlZXBDb3B5KHZhbHVlKSk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHJldHVybiByZXN1bHQ7XG5cdCAgICB9XG5cdCAgICByZXR1cm4gbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcIkNhbm5vdCBkZWVwQ29weSBcIiArIHR5cGVvZiAob2JqZWN0KSwgXCJvYmplY3RcIiwgb2JqZWN0KTtcblx0fVxuXHRmdW5jdGlvbiBkZWVwQ29weShvYmplY3QpIHtcblx0ICAgIHJldHVybiBfZGVlcENvcHkob2JqZWN0KTtcblx0fVxuXHRleHBvcnRzLmRlZXBDb3B5ID0gZGVlcENvcHk7XG5cdHZhciBEZXNjcmlwdGlvbiA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcblx0ICAgIGZ1bmN0aW9uIERlc2NyaXB0aW9uKGluZm8pIHtcblx0ICAgICAgICBmb3IgKHZhciBrZXkgaW4gaW5mbykge1xuXHQgICAgICAgICAgICB0aGlzW2tleV0gPSBkZWVwQ29weShpbmZvW2tleV0pO1xuXHQgICAgICAgIH1cblx0ICAgIH1cblx0ICAgIHJldHVybiBEZXNjcmlwdGlvbjtcblx0fSgpKTtcblx0ZXhwb3J0cy5EZXNjcmlwdGlvbiA9IERlc2NyaXB0aW9uO1xuXG5cdH0pO1xuXG5cdHZhciBpbmRleCQzID0gLypAX19QVVJFX18qL2dldERlZmF1bHRFeHBvcnRGcm9tQ2pzKGxpYiQzKTtcblxuXHR2YXIgX3ZlcnNpb24kOCA9IGNyZWF0ZUNvbW1vbmpzTW9kdWxlKGZ1bmN0aW9uIChtb2R1bGUsIGV4cG9ydHMpIHtcblx0XCJ1c2Ugc3RyaWN0XCI7XG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcblx0ZXhwb3J0cy52ZXJzaW9uID0gdm9pZCAwO1xuXHRleHBvcnRzLnZlcnNpb24gPSBcImFiaS81LjUuMFwiO1xuXG5cdH0pO1xuXG5cdHZhciBfdmVyc2lvbiQ5ID0gLypAX19QVVJFX18qL2dldERlZmF1bHRFeHBvcnRGcm9tQ2pzKF92ZXJzaW9uJDgpO1xuXG5cdHZhciBmcmFnbWVudHMgPSBjcmVhdGVDb21tb25qc01vZHVsZShmdW5jdGlvbiAobW9kdWxlLCBleHBvcnRzKSB7XG5cdFwidXNlIHN0cmljdFwiO1xuXHR2YXIgX19leHRlbmRzID0gKGNvbW1vbmpzR2xvYmFsICYmIGNvbW1vbmpzR2xvYmFsLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcblx0ICAgIHZhciBleHRlbmRTdGF0aWNzID0gZnVuY3Rpb24gKGQsIGIpIHtcblx0ICAgICAgICBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG5cdCAgICAgICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcblx0ICAgICAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGIsIHApKSBkW3BdID0gYltwXTsgfTtcblx0ICAgICAgICByZXR1cm4gZXh0ZW5kU3RhdGljcyhkLCBiKTtcblx0ICAgIH07XG5cdCAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcblx0ICAgICAgICBpZiAodHlwZW9mIGIgIT09IFwiZnVuY3Rpb25cIiAmJiBiICE9PSBudWxsKVxuXHQgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2xhc3MgZXh0ZW5kcyB2YWx1ZSBcIiArIFN0cmluZyhiKSArIFwiIGlzIG5vdCBhIGNvbnN0cnVjdG9yIG9yIG51bGxcIik7XG5cdCAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcblx0ICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cblx0ICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG5cdCAgICB9O1xuXHR9KSgpO1xuXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5cdGV4cG9ydHMuRXJyb3JGcmFnbWVudCA9IGV4cG9ydHMuRnVuY3Rpb25GcmFnbWVudCA9IGV4cG9ydHMuQ29uc3RydWN0b3JGcmFnbWVudCA9IGV4cG9ydHMuRXZlbnRGcmFnbWVudCA9IGV4cG9ydHMuRnJhZ21lbnQgPSBleHBvcnRzLlBhcmFtVHlwZSA9IGV4cG9ydHMuRm9ybWF0VHlwZXMgPSB2b2lkIDA7XG5cblxuXG5cblx0dmFyIGxvZ2dlciA9IG5ldyBsaWIuTG9nZ2VyKF92ZXJzaW9uJDgudmVyc2lvbik7XG5cdDtcblx0dmFyIF9jb25zdHJ1Y3Rvckd1YXJkID0ge307XG5cdHZhciBNb2RpZmllcnNCeXRlcyA9IHsgY2FsbGRhdGE6IHRydWUsIG1lbW9yeTogdHJ1ZSwgc3RvcmFnZTogdHJ1ZSB9O1xuXHR2YXIgTW9kaWZpZXJzTmVzdCA9IHsgY2FsbGRhdGE6IHRydWUsIG1lbW9yeTogdHJ1ZSB9O1xuXHRmdW5jdGlvbiBjaGVja01vZGlmaWVyKHR5cGUsIG5hbWUpIHtcblx0ICAgIGlmICh0eXBlID09PSBcImJ5dGVzXCIgfHwgdHlwZSA9PT0gXCJzdHJpbmdcIikge1xuXHQgICAgICAgIGlmIChNb2RpZmllcnNCeXRlc1tuYW1lXSkge1xuXHQgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcblx0ICAgICAgICB9XG5cdCAgICB9XG5cdCAgICBlbHNlIGlmICh0eXBlID09PSBcImFkZHJlc3NcIikge1xuXHQgICAgICAgIGlmIChuYW1lID09PSBcInBheWFibGVcIikge1xuXHQgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcblx0ICAgICAgICB9XG5cdCAgICB9XG5cdCAgICBlbHNlIGlmICh0eXBlLmluZGV4T2YoXCJbXCIpID49IDAgfHwgdHlwZSA9PT0gXCJ0dXBsZVwiKSB7XG5cdCAgICAgICAgaWYgKE1vZGlmaWVyc05lc3RbbmFtZV0pIHtcblx0ICAgICAgICAgICAgcmV0dXJuIHRydWU7XG5cdCAgICAgICAgfVxuXHQgICAgfVxuXHQgICAgaWYgKE1vZGlmaWVyc0J5dGVzW25hbWVdIHx8IG5hbWUgPT09IFwicGF5YWJsZVwiKSB7XG5cdCAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcImludmFsaWQgbW9kaWZpZXJcIiwgXCJuYW1lXCIsIG5hbWUpO1xuXHQgICAgfVxuXHQgICAgcmV0dXJuIGZhbHNlO1xuXHR9XG5cdC8vIEBUT0RPOiBNYWtlIHN1cmUgdGhhdCBjaGlsZHJlbiBvZiBhbiBpbmRleGVkIHR1cGxlIGFyZSBtYXJrZWQgd2l0aCBhIG51bGwgaW5kZXhlZFxuXHRmdW5jdGlvbiBwYXJzZVBhcmFtVHlwZShwYXJhbSwgYWxsb3dJbmRleGVkKSB7XG5cdCAgICB2YXIgb3JpZ2luYWxQYXJhbSA9IHBhcmFtO1xuXHQgICAgZnVuY3Rpb24gdGhyb3dFcnJvcihpKSB7XG5cdCAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcInVuZXhwZWN0ZWQgY2hhcmFjdGVyIGF0IHBvc2l0aW9uIFwiICsgaSwgXCJwYXJhbVwiLCBwYXJhbSk7XG5cdCAgICB9XG5cdCAgICBwYXJhbSA9IHBhcmFtLnJlcGxhY2UoL1xccy9nLCBcIiBcIik7XG5cdCAgICBmdW5jdGlvbiBuZXdOb2RlKHBhcmVudCkge1xuXHQgICAgICAgIHZhciBub2RlID0geyB0eXBlOiBcIlwiLCBuYW1lOiBcIlwiLCBwYXJlbnQ6IHBhcmVudCwgc3RhdGU6IHsgYWxsb3dUeXBlOiB0cnVlIH0gfTtcblx0ICAgICAgICBpZiAoYWxsb3dJbmRleGVkKSB7XG5cdCAgICAgICAgICAgIG5vZGUuaW5kZXhlZCA9IGZhbHNlO1xuXHQgICAgICAgIH1cblx0ICAgICAgICByZXR1cm4gbm9kZTtcblx0ICAgIH1cblx0ICAgIHZhciBwYXJlbnQgPSB7IHR5cGU6IFwiXCIsIG5hbWU6IFwiXCIsIHN0YXRlOiB7IGFsbG93VHlwZTogdHJ1ZSB9IH07XG5cdCAgICB2YXIgbm9kZSA9IHBhcmVudDtcblx0ICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcGFyYW0ubGVuZ3RoOyBpKyspIHtcblx0ICAgICAgICB2YXIgYyA9IHBhcmFtW2ldO1xuXHQgICAgICAgIHN3aXRjaCAoYykge1xuXHQgICAgICAgICAgICBjYXNlIFwiKFwiOlxuXHQgICAgICAgICAgICAgICAgaWYgKG5vZGUuc3RhdGUuYWxsb3dUeXBlICYmIG5vZGUudHlwZSA9PT0gXCJcIikge1xuXHQgICAgICAgICAgICAgICAgICAgIG5vZGUudHlwZSA9IFwidHVwbGVcIjtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgIGVsc2UgaWYgKCFub2RlLnN0YXRlLmFsbG93UGFyYW1zKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgdGhyb3dFcnJvcihpKTtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgIG5vZGUuc3RhdGUuYWxsb3dUeXBlID0gZmFsc2U7XG5cdCAgICAgICAgICAgICAgICBub2RlLnR5cGUgPSB2ZXJpZnlUeXBlKG5vZGUudHlwZSk7XG5cdCAgICAgICAgICAgICAgICBub2RlLmNvbXBvbmVudHMgPSBbbmV3Tm9kZShub2RlKV07XG5cdCAgICAgICAgICAgICAgICBub2RlID0gbm9kZS5jb21wb25lbnRzWzBdO1xuXHQgICAgICAgICAgICAgICAgYnJlYWs7XG5cdCAgICAgICAgICAgIGNhc2UgXCIpXCI6XG5cdCAgICAgICAgICAgICAgICBkZWxldGUgbm9kZS5zdGF0ZTtcblx0ICAgICAgICAgICAgICAgIGlmIChub2RlLm5hbWUgPT09IFwiaW5kZXhlZFwiKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKCFhbGxvd0luZGV4ZWQpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3dFcnJvcihpKTtcblx0ICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgbm9kZS5pbmRleGVkID0gdHJ1ZTtcblx0ICAgICAgICAgICAgICAgICAgICBub2RlLm5hbWUgPSBcIlwiO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgaWYgKGNoZWNrTW9kaWZpZXIobm9kZS50eXBlLCBub2RlLm5hbWUpKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgbm9kZS5uYW1lID0gXCJcIjtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgIG5vZGUudHlwZSA9IHZlcmlmeVR5cGUobm9kZS50eXBlKTtcblx0ICAgICAgICAgICAgICAgIHZhciBjaGlsZCA9IG5vZGU7XG5cdCAgICAgICAgICAgICAgICBub2RlID0gbm9kZS5wYXJlbnQ7XG5cdCAgICAgICAgICAgICAgICBpZiAoIW5vZGUpIHtcblx0ICAgICAgICAgICAgICAgICAgICB0aHJvd0Vycm9yKGkpO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgZGVsZXRlIGNoaWxkLnBhcmVudDtcblx0ICAgICAgICAgICAgICAgIG5vZGUuc3RhdGUuYWxsb3dQYXJhbXMgPSBmYWxzZTtcblx0ICAgICAgICAgICAgICAgIG5vZGUuc3RhdGUuYWxsb3dOYW1lID0gdHJ1ZTtcblx0ICAgICAgICAgICAgICAgIG5vZGUuc3RhdGUuYWxsb3dBcnJheSA9IHRydWU7XG5cdCAgICAgICAgICAgICAgICBicmVhaztcblx0ICAgICAgICAgICAgY2FzZSBcIixcIjpcblx0ICAgICAgICAgICAgICAgIGRlbGV0ZSBub2RlLnN0YXRlO1xuXHQgICAgICAgICAgICAgICAgaWYgKG5vZGUubmFtZSA9PT0gXCJpbmRleGVkXCIpIHtcblx0ICAgICAgICAgICAgICAgICAgICBpZiAoIWFsbG93SW5kZXhlZCkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB0aHJvd0Vycm9yKGkpO1xuXHQgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICBub2RlLmluZGV4ZWQgPSB0cnVlO1xuXHQgICAgICAgICAgICAgICAgICAgIG5vZGUubmFtZSA9IFwiXCI7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICBpZiAoY2hlY2tNb2RpZmllcihub2RlLnR5cGUsIG5vZGUubmFtZSkpIHtcblx0ICAgICAgICAgICAgICAgICAgICBub2RlLm5hbWUgPSBcIlwiO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgbm9kZS50eXBlID0gdmVyaWZ5VHlwZShub2RlLnR5cGUpO1xuXHQgICAgICAgICAgICAgICAgdmFyIHNpYmxpbmcgPSBuZXdOb2RlKG5vZGUucGFyZW50KTtcblx0ICAgICAgICAgICAgICAgIC8veyB0eXBlOiBcIlwiLCBuYW1lOiBcIlwiLCBwYXJlbnQ6IG5vZGUucGFyZW50LCBzdGF0ZTogeyBhbGxvd1R5cGU6IHRydWUgfSB9O1xuXHQgICAgICAgICAgICAgICAgbm9kZS5wYXJlbnQuY29tcG9uZW50cy5wdXNoKHNpYmxpbmcpO1xuXHQgICAgICAgICAgICAgICAgZGVsZXRlIG5vZGUucGFyZW50O1xuXHQgICAgICAgICAgICAgICAgbm9kZSA9IHNpYmxpbmc7XG5cdCAgICAgICAgICAgICAgICBicmVhaztcblx0ICAgICAgICAgICAgLy8gSGl0IGEgc3BhY2UuLi5cblx0ICAgICAgICAgICAgY2FzZSBcIiBcIjpcblx0ICAgICAgICAgICAgICAgIC8vIElmIHJlYWRpbmcgdHlwZSwgdGhlIHR5cGUgaXMgZG9uZSBhbmQgbWF5IHJlYWQgYSBwYXJhbSBvciBuYW1lXG5cdCAgICAgICAgICAgICAgICBpZiAobm9kZS5zdGF0ZS5hbGxvd1R5cGUpIHtcblx0ICAgICAgICAgICAgICAgICAgICBpZiAobm9kZS50eXBlICE9PSBcIlwiKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIG5vZGUudHlwZSA9IHZlcmlmeVR5cGUobm9kZS50eXBlKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgZGVsZXRlIG5vZGUuc3RhdGUuYWxsb3dUeXBlO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBub2RlLnN0YXRlLmFsbG93TmFtZSA9IHRydWU7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIG5vZGUuc3RhdGUuYWxsb3dQYXJhbXMgPSB0cnVlO1xuXHQgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgIC8vIElmIHJlYWRpbmcgbmFtZSwgdGhlIG5hbWUgaXMgZG9uZVxuXHQgICAgICAgICAgICAgICAgaWYgKG5vZGUuc3RhdGUuYWxsb3dOYW1lKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKG5vZGUubmFtZSAhPT0gXCJcIikge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBpZiAobm9kZS5uYW1lID09PSBcImluZGV4ZWRcIikge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFhbGxvd0luZGV4ZWQpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvd0Vycm9yKGkpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG5vZGUuaW5kZXhlZCkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93RXJyb3IoaSk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBub2RlLmluZGV4ZWQgPSB0cnVlO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgbm9kZS5uYW1lID0gXCJcIjtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChjaGVja01vZGlmaWVyKG5vZGUudHlwZSwgbm9kZS5uYW1lKSkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgbm9kZS5uYW1lID0gXCJcIjtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vZGUuc3RhdGUuYWxsb3dOYW1lID0gZmFsc2U7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICBicmVhaztcblx0ICAgICAgICAgICAgY2FzZSBcIltcIjpcblx0ICAgICAgICAgICAgICAgIGlmICghbm9kZS5zdGF0ZS5hbGxvd0FycmF5KSB7XG5cdCAgICAgICAgICAgICAgICAgICAgdGhyb3dFcnJvcihpKTtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgIG5vZGUudHlwZSArPSBjO1xuXHQgICAgICAgICAgICAgICAgbm9kZS5zdGF0ZS5hbGxvd0FycmF5ID0gZmFsc2U7XG5cdCAgICAgICAgICAgICAgICBub2RlLnN0YXRlLmFsbG93TmFtZSA9IGZhbHNlO1xuXHQgICAgICAgICAgICAgICAgbm9kZS5zdGF0ZS5yZWFkQXJyYXkgPSB0cnVlO1xuXHQgICAgICAgICAgICAgICAgYnJlYWs7XG5cdCAgICAgICAgICAgIGNhc2UgXCJdXCI6XG5cdCAgICAgICAgICAgICAgICBpZiAoIW5vZGUuc3RhdGUucmVhZEFycmF5KSB7XG5cdCAgICAgICAgICAgICAgICAgICAgdGhyb3dFcnJvcihpKTtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgIG5vZGUudHlwZSArPSBjO1xuXHQgICAgICAgICAgICAgICAgbm9kZS5zdGF0ZS5yZWFkQXJyYXkgPSBmYWxzZTtcblx0ICAgICAgICAgICAgICAgIG5vZGUuc3RhdGUuYWxsb3dBcnJheSA9IHRydWU7XG5cdCAgICAgICAgICAgICAgICBub2RlLnN0YXRlLmFsbG93TmFtZSA9IHRydWU7XG5cdCAgICAgICAgICAgICAgICBicmVhaztcblx0ICAgICAgICAgICAgZGVmYXVsdDpcblx0ICAgICAgICAgICAgICAgIGlmIChub2RlLnN0YXRlLmFsbG93VHlwZSkge1xuXHQgICAgICAgICAgICAgICAgICAgIG5vZGUudHlwZSArPSBjO1xuXHQgICAgICAgICAgICAgICAgICAgIG5vZGUuc3RhdGUuYWxsb3dQYXJhbXMgPSB0cnVlO1xuXHQgICAgICAgICAgICAgICAgICAgIG5vZGUuc3RhdGUuYWxsb3dBcnJheSA9IHRydWU7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICBlbHNlIGlmIChub2RlLnN0YXRlLmFsbG93TmFtZSkge1xuXHQgICAgICAgICAgICAgICAgICAgIG5vZGUubmFtZSArPSBjO1xuXHQgICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBub2RlLnN0YXRlLmFsbG93QXJyYXk7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICBlbHNlIGlmIChub2RlLnN0YXRlLnJlYWRBcnJheSkge1xuXHQgICAgICAgICAgICAgICAgICAgIG5vZGUudHlwZSArPSBjO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgZWxzZSB7XG5cdCAgICAgICAgICAgICAgICAgICAgdGhyb3dFcnJvcihpKTtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICB9XG5cdCAgICB9XG5cdCAgICBpZiAobm9kZS5wYXJlbnQpIHtcblx0ICAgICAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwidW5leHBlY3RlZCBlb2ZcIiwgXCJwYXJhbVwiLCBwYXJhbSk7XG5cdCAgICB9XG5cdCAgICBkZWxldGUgcGFyZW50LnN0YXRlO1xuXHQgICAgaWYgKG5vZGUubmFtZSA9PT0gXCJpbmRleGVkXCIpIHtcblx0ICAgICAgICBpZiAoIWFsbG93SW5kZXhlZCkge1xuXHQgICAgICAgICAgICB0aHJvd0Vycm9yKG9yaWdpbmFsUGFyYW0ubGVuZ3RoIC0gNyk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGlmIChub2RlLmluZGV4ZWQpIHtcblx0ICAgICAgICAgICAgdGhyb3dFcnJvcihvcmlnaW5hbFBhcmFtLmxlbmd0aCAtIDcpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBub2RlLmluZGV4ZWQgPSB0cnVlO1xuXHQgICAgICAgIG5vZGUubmFtZSA9IFwiXCI7XG5cdCAgICB9XG5cdCAgICBlbHNlIGlmIChjaGVja01vZGlmaWVyKG5vZGUudHlwZSwgbm9kZS5uYW1lKSkge1xuXHQgICAgICAgIG5vZGUubmFtZSA9IFwiXCI7XG5cdCAgICB9XG5cdCAgICBwYXJlbnQudHlwZSA9IHZlcmlmeVR5cGUocGFyZW50LnR5cGUpO1xuXHQgICAgcmV0dXJuIHBhcmVudDtcblx0fVxuXHRmdW5jdGlvbiBwb3B1bGF0ZShvYmplY3QsIHBhcmFtcykge1xuXHQgICAgZm9yICh2YXIga2V5IGluIHBhcmFtcykge1xuXHQgICAgICAgICgwLCBsaWIkMy5kZWZpbmVSZWFkT25seSkob2JqZWN0LCBrZXksIHBhcmFtc1trZXldKTtcblx0ICAgIH1cblx0fVxuXHRleHBvcnRzLkZvcm1hdFR5cGVzID0gT2JqZWN0LmZyZWV6ZSh7XG5cdCAgICAvLyBCYXJlIGZvcm1hdHRpbmcsIGFzIGlzIG5lZWRlZCBmb3IgY29tcHV0aW5nIGEgc2lnaGFzaCBvZiBhbiBldmVudCBvciBmdW5jdGlvblxuXHQgICAgc2lnaGFzaDogXCJzaWdoYXNoXCIsXG5cdCAgICAvLyBIdW1hbi1SZWFkYWJsZSB3aXRoIE1pbmltYWwgc3BhY2luZyBhbmQgd2l0aG91dCBuYW1lcyAoY29tcGFjdCBodW1hbi1yZWFkYWJsZSlcblx0ICAgIG1pbmltYWw6IFwibWluaW1hbFwiLFxuXHQgICAgLy8gSHVtYW4tUmVhZGFibGUgd2l0aCBuaWNlIHNwYWNpbmcsIGluY2x1ZGluZyBhbGwgbmFtZXNcblx0ICAgIGZ1bGw6IFwiZnVsbFwiLFxuXHQgICAgLy8gSlNPTi1mb3JtYXQgYSBsYSBTb2xpZGl0eVxuXHQgICAganNvbjogXCJqc29uXCJcblx0fSk7XG5cdHZhciBwYXJhbVR5cGVBcnJheSA9IG5ldyBSZWdFeHAoL14oLiopXFxbKFswLTldKilcXF0kLyk7XG5cdHZhciBQYXJhbVR5cGUgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG5cdCAgICBmdW5jdGlvbiBQYXJhbVR5cGUoY29uc3RydWN0b3JHdWFyZCwgcGFyYW1zKSB7XG5cdCAgICAgICAgaWYgKGNvbnN0cnVjdG9yR3VhcmQgIT09IF9jb25zdHJ1Y3Rvckd1YXJkKSB7XG5cdCAgICAgICAgICAgIGxvZ2dlci50aHJvd0Vycm9yKFwidXNlIGZyb21TdHJpbmdcIiwgbGliLkxvZ2dlci5lcnJvcnMuVU5TVVBQT1JURURfT1BFUkFUSU9OLCB7XG5cdCAgICAgICAgICAgICAgICBvcGVyYXRpb246IFwibmV3IFBhcmFtVHlwZSgpXCJcblx0ICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHBvcHVsYXRlKHRoaXMsIHBhcmFtcyk7XG5cdCAgICAgICAgdmFyIG1hdGNoID0gdGhpcy50eXBlLm1hdGNoKHBhcmFtVHlwZUFycmF5KTtcblx0ICAgICAgICBpZiAobWF0Y2gpIHtcblx0ICAgICAgICAgICAgcG9wdWxhdGUodGhpcywge1xuXHQgICAgICAgICAgICAgICAgYXJyYXlMZW5ndGg6IHBhcnNlSW50KG1hdGNoWzJdIHx8IFwiLTFcIiksXG5cdCAgICAgICAgICAgICAgICBhcnJheUNoaWxkcmVuOiBQYXJhbVR5cGUuZnJvbU9iamVjdCh7XG5cdCAgICAgICAgICAgICAgICAgICAgdHlwZTogbWF0Y2hbMV0sXG5cdCAgICAgICAgICAgICAgICAgICAgY29tcG9uZW50czogdGhpcy5jb21wb25lbnRzXG5cdCAgICAgICAgICAgICAgICB9KSxcblx0ICAgICAgICAgICAgICAgIGJhc2VUeXBlOiBcImFycmF5XCJcblx0ICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGVsc2Uge1xuXHQgICAgICAgICAgICBwb3B1bGF0ZSh0aGlzLCB7XG5cdCAgICAgICAgICAgICAgICBhcnJheUxlbmd0aDogbnVsbCxcblx0ICAgICAgICAgICAgICAgIGFycmF5Q2hpbGRyZW46IG51bGwsXG5cdCAgICAgICAgICAgICAgICBiYXNlVHlwZTogKCh0aGlzLmNvbXBvbmVudHMgIT0gbnVsbCkgPyBcInR1cGxlXCIgOiB0aGlzLnR5cGUpXG5cdCAgICAgICAgICAgIH0pO1xuXHQgICAgICAgIH1cblx0ICAgICAgICB0aGlzLl9pc1BhcmFtVHlwZSA9IHRydWU7XG5cdCAgICAgICAgT2JqZWN0LmZyZWV6ZSh0aGlzKTtcblx0ICAgIH1cblx0ICAgIC8vIEZvcm1hdCB0aGUgcGFyYW1ldGVyIGZyYWdtZW50XG5cdCAgICAvLyAgIC0gc2lnaGFzaDogXCIodWludDI1NixhZGRyZXNzKVwiXG5cdCAgICAvLyAgIC0gbWluaW1hbDogXCJ0dXBsZSh1aW50MjU2LGFkZHJlc3MpIGluZGV4ZWRcIlxuXHQgICAgLy8gICAtIGZ1bGw6ICAgIFwidHVwbGUodWludDI1NiBmb28sIGFkZHJlc3MgYmFyKSBpbmRleGVkIGJhelwiXG5cdCAgICBQYXJhbVR5cGUucHJvdG90eXBlLmZvcm1hdCA9IGZ1bmN0aW9uIChmb3JtYXQpIHtcblx0ICAgICAgICBpZiAoIWZvcm1hdCkge1xuXHQgICAgICAgICAgICBmb3JtYXQgPSBleHBvcnRzLkZvcm1hdFR5cGVzLnNpZ2hhc2g7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGlmICghZXhwb3J0cy5Gb3JtYXRUeXBlc1tmb3JtYXRdKSB7XG5cdCAgICAgICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJpbnZhbGlkIGZvcm1hdCB0eXBlXCIsIFwiZm9ybWF0XCIsIGZvcm1hdCk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGlmIChmb3JtYXQgPT09IGV4cG9ydHMuRm9ybWF0VHlwZXMuanNvbikge1xuXHQgICAgICAgICAgICB2YXIgcmVzdWx0XzEgPSB7XG5cdCAgICAgICAgICAgICAgICB0eXBlOiAoKHRoaXMuYmFzZVR5cGUgPT09IFwidHVwbGVcIikgPyBcInR1cGxlXCIgOiB0aGlzLnR5cGUpLFxuXHQgICAgICAgICAgICAgICAgbmFtZTogKHRoaXMubmFtZSB8fCB1bmRlZmluZWQpXG5cdCAgICAgICAgICAgIH07XG5cdCAgICAgICAgICAgIGlmICh0eXBlb2YgKHRoaXMuaW5kZXhlZCkgPT09IFwiYm9vbGVhblwiKSB7XG5cdCAgICAgICAgICAgICAgICByZXN1bHRfMS5pbmRleGVkID0gdGhpcy5pbmRleGVkO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIGlmICh0aGlzLmNvbXBvbmVudHMpIHtcblx0ICAgICAgICAgICAgICAgIHJlc3VsdF8xLmNvbXBvbmVudHMgPSB0aGlzLmNvbXBvbmVudHMubWFwKGZ1bmN0aW9uIChjb21wKSB7IHJldHVybiBKU09OLnBhcnNlKGNvbXAuZm9ybWF0KGZvcm1hdCkpOyB9KTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkocmVzdWx0XzEpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICB2YXIgcmVzdWx0ID0gXCJcIjtcblx0ICAgICAgICAvLyBBcnJheVxuXHQgICAgICAgIGlmICh0aGlzLmJhc2VUeXBlID09PSBcImFycmF5XCIpIHtcblx0ICAgICAgICAgICAgcmVzdWx0ICs9IHRoaXMuYXJyYXlDaGlsZHJlbi5mb3JtYXQoZm9ybWF0KTtcblx0ICAgICAgICAgICAgcmVzdWx0ICs9IFwiW1wiICsgKHRoaXMuYXJyYXlMZW5ndGggPCAwID8gXCJcIiA6IFN0cmluZyh0aGlzLmFycmF5TGVuZ3RoKSkgKyBcIl1cIjtcblx0ICAgICAgICB9XG5cdCAgICAgICAgZWxzZSB7XG5cdCAgICAgICAgICAgIGlmICh0aGlzLmJhc2VUeXBlID09PSBcInR1cGxlXCIpIHtcblx0ICAgICAgICAgICAgICAgIGlmIChmb3JtYXQgIT09IGV4cG9ydHMuRm9ybWF0VHlwZXMuc2lnaGFzaCkge1xuXHQgICAgICAgICAgICAgICAgICAgIHJlc3VsdCArPSB0aGlzLnR5cGU7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICByZXN1bHQgKz0gXCIoXCIgKyB0aGlzLmNvbXBvbmVudHMubWFwKGZ1bmN0aW9uIChjb21wKSB7IHJldHVybiBjb21wLmZvcm1hdChmb3JtYXQpOyB9KS5qb2luKChmb3JtYXQgPT09IGV4cG9ydHMuRm9ybWF0VHlwZXMuZnVsbCkgPyBcIiwgXCIgOiBcIixcIikgKyBcIilcIjtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICBlbHNlIHtcblx0ICAgICAgICAgICAgICAgIHJlc3VsdCArPSB0aGlzLnR5cGU7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9XG5cdCAgICAgICAgaWYgKGZvcm1hdCAhPT0gZXhwb3J0cy5Gb3JtYXRUeXBlcy5zaWdoYXNoKSB7XG5cdCAgICAgICAgICAgIGlmICh0aGlzLmluZGV4ZWQgPT09IHRydWUpIHtcblx0ICAgICAgICAgICAgICAgIHJlc3VsdCArPSBcIiBpbmRleGVkXCI7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgaWYgKGZvcm1hdCA9PT0gZXhwb3J0cy5Gb3JtYXRUeXBlcy5mdWxsICYmIHRoaXMubmFtZSkge1xuXHQgICAgICAgICAgICAgICAgcmVzdWx0ICs9IFwiIFwiICsgdGhpcy5uYW1lO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHJldHVybiByZXN1bHQ7XG5cdCAgICB9O1xuXHQgICAgUGFyYW1UeXBlLmZyb20gPSBmdW5jdGlvbiAodmFsdWUsIGFsbG93SW5kZXhlZCkge1xuXHQgICAgICAgIGlmICh0eXBlb2YgKHZhbHVlKSA9PT0gXCJzdHJpbmdcIikge1xuXHQgICAgICAgICAgICByZXR1cm4gUGFyYW1UeXBlLmZyb21TdHJpbmcodmFsdWUsIGFsbG93SW5kZXhlZCk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHJldHVybiBQYXJhbVR5cGUuZnJvbU9iamVjdCh2YWx1ZSk7XG5cdCAgICB9O1xuXHQgICAgUGFyYW1UeXBlLmZyb21PYmplY3QgPSBmdW5jdGlvbiAodmFsdWUpIHtcblx0ICAgICAgICBpZiAoUGFyYW1UeXBlLmlzUGFyYW1UeXBlKHZhbHVlKSkge1xuXHQgICAgICAgICAgICByZXR1cm4gdmFsdWU7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHJldHVybiBuZXcgUGFyYW1UeXBlKF9jb25zdHJ1Y3Rvckd1YXJkLCB7XG5cdCAgICAgICAgICAgIG5hbWU6ICh2YWx1ZS5uYW1lIHx8IG51bGwpLFxuXHQgICAgICAgICAgICB0eXBlOiB2ZXJpZnlUeXBlKHZhbHVlLnR5cGUpLFxuXHQgICAgICAgICAgICBpbmRleGVkOiAoKHZhbHVlLmluZGV4ZWQgPT0gbnVsbCkgPyBudWxsIDogISF2YWx1ZS5pbmRleGVkKSxcblx0ICAgICAgICAgICAgY29tcG9uZW50czogKHZhbHVlLmNvbXBvbmVudHMgPyB2YWx1ZS5jb21wb25lbnRzLm1hcChQYXJhbVR5cGUuZnJvbU9iamVjdCkgOiBudWxsKVxuXHQgICAgICAgIH0pO1xuXHQgICAgfTtcblx0ICAgIFBhcmFtVHlwZS5mcm9tU3RyaW5nID0gZnVuY3Rpb24gKHZhbHVlLCBhbGxvd0luZGV4ZWQpIHtcblx0ICAgICAgICBmdW5jdGlvbiBQYXJhbVR5cGlmeShub2RlKSB7XG5cdCAgICAgICAgICAgIHJldHVybiBQYXJhbVR5cGUuZnJvbU9iamVjdCh7XG5cdCAgICAgICAgICAgICAgICBuYW1lOiBub2RlLm5hbWUsXG5cdCAgICAgICAgICAgICAgICB0eXBlOiBub2RlLnR5cGUsXG5cdCAgICAgICAgICAgICAgICBpbmRleGVkOiBub2RlLmluZGV4ZWQsXG5cdCAgICAgICAgICAgICAgICBjb21wb25lbnRzOiBub2RlLmNvbXBvbmVudHNcblx0ICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHJldHVybiBQYXJhbVR5cGlmeShwYXJzZVBhcmFtVHlwZSh2YWx1ZSwgISFhbGxvd0luZGV4ZWQpKTtcblx0ICAgIH07XG5cdCAgICBQYXJhbVR5cGUuaXNQYXJhbVR5cGUgPSBmdW5jdGlvbiAodmFsdWUpIHtcblx0ICAgICAgICByZXR1cm4gISEodmFsdWUgIT0gbnVsbCAmJiB2YWx1ZS5faXNQYXJhbVR5cGUpO1xuXHQgICAgfTtcblx0ICAgIHJldHVybiBQYXJhbVR5cGU7XG5cdH0oKSk7XG5cdGV4cG9ydHMuUGFyYW1UeXBlID0gUGFyYW1UeXBlO1xuXHQ7XG5cdGZ1bmN0aW9uIHBhcnNlUGFyYW1zKHZhbHVlLCBhbGxvd0luZGV4KSB7XG5cdCAgICByZXR1cm4gc3BsaXROZXN0aW5nKHZhbHVlKS5tYXAoZnVuY3Rpb24gKHBhcmFtKSB7IHJldHVybiBQYXJhbVR5cGUuZnJvbVN0cmluZyhwYXJhbSwgYWxsb3dJbmRleCk7IH0pO1xuXHR9XG5cdHZhciBGcmFnbWVudCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcblx0ICAgIGZ1bmN0aW9uIEZyYWdtZW50KGNvbnN0cnVjdG9yR3VhcmQsIHBhcmFtcykge1xuXHQgICAgICAgIGlmIChjb25zdHJ1Y3Rvckd1YXJkICE9PSBfY29uc3RydWN0b3JHdWFyZCkge1xuXHQgICAgICAgICAgICBsb2dnZXIudGhyb3dFcnJvcihcInVzZSBhIHN0YXRpYyBmcm9tIG1ldGhvZFwiLCBsaWIuTG9nZ2VyLmVycm9ycy5VTlNVUFBPUlRFRF9PUEVSQVRJT04sIHtcblx0ICAgICAgICAgICAgICAgIG9wZXJhdGlvbjogXCJuZXcgRnJhZ21lbnQoKVwiXG5cdCAgICAgICAgICAgIH0pO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBwb3B1bGF0ZSh0aGlzLCBwYXJhbXMpO1xuXHQgICAgICAgIHRoaXMuX2lzRnJhZ21lbnQgPSB0cnVlO1xuXHQgICAgICAgIE9iamVjdC5mcmVlemUodGhpcyk7XG5cdCAgICB9XG5cdCAgICBGcmFnbWVudC5mcm9tID0gZnVuY3Rpb24gKHZhbHVlKSB7XG5cdCAgICAgICAgaWYgKEZyYWdtZW50LmlzRnJhZ21lbnQodmFsdWUpKSB7XG5cdCAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgaWYgKHR5cGVvZiAodmFsdWUpID09PSBcInN0cmluZ1wiKSB7XG5cdCAgICAgICAgICAgIHJldHVybiBGcmFnbWVudC5mcm9tU3RyaW5nKHZhbHVlKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgcmV0dXJuIEZyYWdtZW50LmZyb21PYmplY3QodmFsdWUpO1xuXHQgICAgfTtcblx0ICAgIEZyYWdtZW50LmZyb21PYmplY3QgPSBmdW5jdGlvbiAodmFsdWUpIHtcblx0ICAgICAgICBpZiAoRnJhZ21lbnQuaXNGcmFnbWVudCh2YWx1ZSkpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBzd2l0Y2ggKHZhbHVlLnR5cGUpIHtcblx0ICAgICAgICAgICAgY2FzZSBcImZ1bmN0aW9uXCI6XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gRnVuY3Rpb25GcmFnbWVudC5mcm9tT2JqZWN0KHZhbHVlKTtcblx0ICAgICAgICAgICAgY2FzZSBcImV2ZW50XCI6XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gRXZlbnRGcmFnbWVudC5mcm9tT2JqZWN0KHZhbHVlKTtcblx0ICAgICAgICAgICAgY2FzZSBcImNvbnN0cnVjdG9yXCI6XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gQ29uc3RydWN0b3JGcmFnbWVudC5mcm9tT2JqZWN0KHZhbHVlKTtcblx0ICAgICAgICAgICAgY2FzZSBcImVycm9yXCI6XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gRXJyb3JGcmFnbWVudC5mcm9tT2JqZWN0KHZhbHVlKTtcblx0ICAgICAgICAgICAgY2FzZSBcImZhbGxiYWNrXCI6XG5cdCAgICAgICAgICAgIGNhc2UgXCJyZWNlaXZlXCI6XG5cdCAgICAgICAgICAgICAgICAvLyBAVE9ETzogU29tZXRoaW5nPyBNYXliZSByZXR1cm4gYSBGdW5jdGlvbkZyYWdtZW50PyBBIGN1c3RvbSBEZWZhdWx0RnVuY3Rpb25GcmFnbWVudD9cblx0ICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuXHQgICAgICAgIH1cblx0ICAgICAgICByZXR1cm4gbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcImludmFsaWQgZnJhZ21lbnQgb2JqZWN0XCIsIFwidmFsdWVcIiwgdmFsdWUpO1xuXHQgICAgfTtcblx0ICAgIEZyYWdtZW50LmZyb21TdHJpbmcgPSBmdW5jdGlvbiAodmFsdWUpIHtcblx0ICAgICAgICAvLyBNYWtlIHN1cmUgdGhlIFwicmV0dXJuc1wiIGlzIHN1cnJvdW5kZWQgYnkgYSBzcGFjZSBhbmQgYWxsIHdoaXRlc3BhY2UgaXMgZXhhY3RseSBvbmUgc3BhY2Vcblx0ICAgICAgICB2YWx1ZSA9IHZhbHVlLnJlcGxhY2UoL1xccy9nLCBcIiBcIik7XG5cdCAgICAgICAgdmFsdWUgPSB2YWx1ZS5yZXBsYWNlKC9cXCgvZywgXCIgKFwiKS5yZXBsYWNlKC9cXCkvZywgXCIpIFwiKS5yZXBsYWNlKC9cXHMrL2csIFwiIFwiKTtcblx0ICAgICAgICB2YWx1ZSA9IHZhbHVlLnRyaW0oKTtcblx0ICAgICAgICBpZiAodmFsdWUuc3BsaXQoXCIgXCIpWzBdID09PSBcImV2ZW50XCIpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIEV2ZW50RnJhZ21lbnQuZnJvbVN0cmluZyh2YWx1ZS5zdWJzdHJpbmcoNSkudHJpbSgpKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgZWxzZSBpZiAodmFsdWUuc3BsaXQoXCIgXCIpWzBdID09PSBcImZ1bmN0aW9uXCIpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIEZ1bmN0aW9uRnJhZ21lbnQuZnJvbVN0cmluZyh2YWx1ZS5zdWJzdHJpbmcoOCkudHJpbSgpKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgZWxzZSBpZiAodmFsdWUuc3BsaXQoXCIoXCIpWzBdLnRyaW0oKSA9PT0gXCJjb25zdHJ1Y3RvclwiKSB7XG5cdCAgICAgICAgICAgIHJldHVybiBDb25zdHJ1Y3RvckZyYWdtZW50LmZyb21TdHJpbmcodmFsdWUudHJpbSgpKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgZWxzZSBpZiAodmFsdWUuc3BsaXQoXCIgXCIpWzBdID09PSBcImVycm9yXCIpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIEVycm9yRnJhZ21lbnQuZnJvbVN0cmluZyh2YWx1ZS5zdWJzdHJpbmcoNSkudHJpbSgpKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgcmV0dXJuIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJ1bnN1cHBvcnRlZCBmcmFnbWVudFwiLCBcInZhbHVlXCIsIHZhbHVlKTtcblx0ICAgIH07XG5cdCAgICBGcmFnbWVudC5pc0ZyYWdtZW50ID0gZnVuY3Rpb24gKHZhbHVlKSB7XG5cdCAgICAgICAgcmV0dXJuICEhKHZhbHVlICYmIHZhbHVlLl9pc0ZyYWdtZW50KTtcblx0ICAgIH07XG5cdCAgICByZXR1cm4gRnJhZ21lbnQ7XG5cdH0oKSk7XG5cdGV4cG9ydHMuRnJhZ21lbnQgPSBGcmFnbWVudDtcblx0dmFyIEV2ZW50RnJhZ21lbnQgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG5cdCAgICBfX2V4dGVuZHMoRXZlbnRGcmFnbWVudCwgX3N1cGVyKTtcblx0ICAgIGZ1bmN0aW9uIEV2ZW50RnJhZ21lbnQoKSB7XG5cdCAgICAgICAgcmV0dXJuIF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuXHQgICAgfVxuXHQgICAgRXZlbnRGcmFnbWVudC5wcm90b3R5cGUuZm9ybWF0ID0gZnVuY3Rpb24gKGZvcm1hdCkge1xuXHQgICAgICAgIGlmICghZm9ybWF0KSB7XG5cdCAgICAgICAgICAgIGZvcm1hdCA9IGV4cG9ydHMuRm9ybWF0VHlwZXMuc2lnaGFzaDtcblx0ICAgICAgICB9XG5cdCAgICAgICAgaWYgKCFleHBvcnRzLkZvcm1hdFR5cGVzW2Zvcm1hdF0pIHtcblx0ICAgICAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcImludmFsaWQgZm9ybWF0IHR5cGVcIiwgXCJmb3JtYXRcIiwgZm9ybWF0KTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgaWYgKGZvcm1hdCA9PT0gZXhwb3J0cy5Gb3JtYXRUeXBlcy5qc29uKSB7XG5cdCAgICAgICAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeSh7XG5cdCAgICAgICAgICAgICAgICB0eXBlOiBcImV2ZW50XCIsXG5cdCAgICAgICAgICAgICAgICBhbm9ueW1vdXM6IHRoaXMuYW5vbnltb3VzLFxuXHQgICAgICAgICAgICAgICAgbmFtZTogdGhpcy5uYW1lLFxuXHQgICAgICAgICAgICAgICAgaW5wdXRzOiB0aGlzLmlucHV0cy5tYXAoZnVuY3Rpb24gKGlucHV0KSB7IHJldHVybiBKU09OLnBhcnNlKGlucHV0LmZvcm1hdChmb3JtYXQpKTsgfSlcblx0ICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHZhciByZXN1bHQgPSBcIlwiO1xuXHQgICAgICAgIGlmIChmb3JtYXQgIT09IGV4cG9ydHMuRm9ybWF0VHlwZXMuc2lnaGFzaCkge1xuXHQgICAgICAgICAgICByZXN1bHQgKz0gXCJldmVudCBcIjtcblx0ICAgICAgICB9XG5cdCAgICAgICAgcmVzdWx0ICs9IHRoaXMubmFtZSArIFwiKFwiICsgdGhpcy5pbnB1dHMubWFwKGZ1bmN0aW9uIChpbnB1dCkgeyByZXR1cm4gaW5wdXQuZm9ybWF0KGZvcm1hdCk7IH0pLmpvaW4oKGZvcm1hdCA9PT0gZXhwb3J0cy5Gb3JtYXRUeXBlcy5mdWxsKSA/IFwiLCBcIiA6IFwiLFwiKSArIFwiKSBcIjtcblx0ICAgICAgICBpZiAoZm9ybWF0ICE9PSBleHBvcnRzLkZvcm1hdFR5cGVzLnNpZ2hhc2gpIHtcblx0ICAgICAgICAgICAgaWYgKHRoaXMuYW5vbnltb3VzKSB7XG5cdCAgICAgICAgICAgICAgICByZXN1bHQgKz0gXCJhbm9ueW1vdXMgXCI7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9XG5cdCAgICAgICAgcmV0dXJuIHJlc3VsdC50cmltKCk7XG5cdCAgICB9O1xuXHQgICAgRXZlbnRGcmFnbWVudC5mcm9tID0gZnVuY3Rpb24gKHZhbHVlKSB7XG5cdCAgICAgICAgaWYgKHR5cGVvZiAodmFsdWUpID09PSBcInN0cmluZ1wiKSB7XG5cdCAgICAgICAgICAgIHJldHVybiBFdmVudEZyYWdtZW50LmZyb21TdHJpbmcodmFsdWUpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICByZXR1cm4gRXZlbnRGcmFnbWVudC5mcm9tT2JqZWN0KHZhbHVlKTtcblx0ICAgIH07XG5cdCAgICBFdmVudEZyYWdtZW50LmZyb21PYmplY3QgPSBmdW5jdGlvbiAodmFsdWUpIHtcblx0ICAgICAgICBpZiAoRXZlbnRGcmFnbWVudC5pc0V2ZW50RnJhZ21lbnQodmFsdWUpKSB7XG5cdCAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgaWYgKHZhbHVlLnR5cGUgIT09IFwiZXZlbnRcIikge1xuXHQgICAgICAgICAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwiaW52YWxpZCBldmVudCBvYmplY3RcIiwgXCJ2YWx1ZVwiLCB2YWx1ZSk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHZhciBwYXJhbXMgPSB7XG5cdCAgICAgICAgICAgIG5hbWU6IHZlcmlmeUlkZW50aWZpZXIodmFsdWUubmFtZSksXG5cdCAgICAgICAgICAgIGFub255bW91czogdmFsdWUuYW5vbnltb3VzLFxuXHQgICAgICAgICAgICBpbnB1dHM6ICh2YWx1ZS5pbnB1dHMgPyB2YWx1ZS5pbnB1dHMubWFwKFBhcmFtVHlwZS5mcm9tT2JqZWN0KSA6IFtdKSxcblx0ICAgICAgICAgICAgdHlwZTogXCJldmVudFwiXG5cdCAgICAgICAgfTtcblx0ICAgICAgICByZXR1cm4gbmV3IEV2ZW50RnJhZ21lbnQoX2NvbnN0cnVjdG9yR3VhcmQsIHBhcmFtcyk7XG5cdCAgICB9O1xuXHQgICAgRXZlbnRGcmFnbWVudC5mcm9tU3RyaW5nID0gZnVuY3Rpb24gKHZhbHVlKSB7XG5cdCAgICAgICAgdmFyIG1hdGNoID0gdmFsdWUubWF0Y2gocmVnZXhQYXJlbik7XG5cdCAgICAgICAgaWYgKCFtYXRjaCkge1xuXHQgICAgICAgICAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwiaW52YWxpZCBldmVudCBzdHJpbmdcIiwgXCJ2YWx1ZVwiLCB2YWx1ZSk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHZhciBhbm9ueW1vdXMgPSBmYWxzZTtcblx0ICAgICAgICBtYXRjaFszXS5zcGxpdChcIiBcIikuZm9yRWFjaChmdW5jdGlvbiAobW9kaWZpZXIpIHtcblx0ICAgICAgICAgICAgc3dpdGNoIChtb2RpZmllci50cmltKCkpIHtcblx0ICAgICAgICAgICAgICAgIGNhc2UgXCJhbm9ueW1vdXNcIjpcblx0ICAgICAgICAgICAgICAgICAgICBhbm9ueW1vdXMgPSB0cnVlO1xuXHQgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXHQgICAgICAgICAgICAgICAgY2FzZSBcIlwiOlxuXHQgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXHQgICAgICAgICAgICAgICAgZGVmYXVsdDpcblx0ICAgICAgICAgICAgICAgICAgICBsb2dnZXIud2FybihcInVua25vd24gbW9kaWZpZXI6IFwiICsgbW9kaWZpZXIpO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfSk7XG5cdCAgICAgICAgcmV0dXJuIEV2ZW50RnJhZ21lbnQuZnJvbU9iamVjdCh7XG5cdCAgICAgICAgICAgIG5hbWU6IG1hdGNoWzFdLnRyaW0oKSxcblx0ICAgICAgICAgICAgYW5vbnltb3VzOiBhbm9ueW1vdXMsXG5cdCAgICAgICAgICAgIGlucHV0czogcGFyc2VQYXJhbXMobWF0Y2hbMl0sIHRydWUpLFxuXHQgICAgICAgICAgICB0eXBlOiBcImV2ZW50XCJcblx0ICAgICAgICB9KTtcblx0ICAgIH07XG5cdCAgICBFdmVudEZyYWdtZW50LmlzRXZlbnRGcmFnbWVudCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuXHQgICAgICAgIHJldHVybiAodmFsdWUgJiYgdmFsdWUuX2lzRnJhZ21lbnQgJiYgdmFsdWUudHlwZSA9PT0gXCJldmVudFwiKTtcblx0ICAgIH07XG5cdCAgICByZXR1cm4gRXZlbnRGcmFnbWVudDtcblx0fShGcmFnbWVudCkpO1xuXHRleHBvcnRzLkV2ZW50RnJhZ21lbnQgPSBFdmVudEZyYWdtZW50O1xuXHRmdW5jdGlvbiBwYXJzZUdhcyh2YWx1ZSwgcGFyYW1zKSB7XG5cdCAgICBwYXJhbXMuZ2FzID0gbnVsbDtcblx0ICAgIHZhciBjb21wcyA9IHZhbHVlLnNwbGl0KFwiQFwiKTtcblx0ICAgIGlmIChjb21wcy5sZW5ndGggIT09IDEpIHtcblx0ICAgICAgICBpZiAoY29tcHMubGVuZ3RoID4gMikge1xuXHQgICAgICAgICAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwiaW52YWxpZCBodW1hbi1yZWFkYWJsZSBBQkkgc2lnbmF0dXJlXCIsIFwidmFsdWVcIiwgdmFsdWUpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBpZiAoIWNvbXBzWzFdLm1hdGNoKC9eWzAtOV0rJC8pKSB7XG5cdCAgICAgICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJpbnZhbGlkIGh1bWFuLXJlYWRhYmxlIEFCSSBzaWduYXR1cmUgZ2FzXCIsIFwidmFsdWVcIiwgdmFsdWUpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBwYXJhbXMuZ2FzID0gbGliJDIuQmlnTnVtYmVyLmZyb20oY29tcHNbMV0pO1xuXHQgICAgICAgIHJldHVybiBjb21wc1swXTtcblx0ICAgIH1cblx0ICAgIHJldHVybiB2YWx1ZTtcblx0fVxuXHRmdW5jdGlvbiBwYXJzZU1vZGlmaWVycyh2YWx1ZSwgcGFyYW1zKSB7XG5cdCAgICBwYXJhbXMuY29uc3RhbnQgPSBmYWxzZTtcblx0ICAgIHBhcmFtcy5wYXlhYmxlID0gZmFsc2U7XG5cdCAgICBwYXJhbXMuc3RhdGVNdXRhYmlsaXR5ID0gXCJub25wYXlhYmxlXCI7XG5cdCAgICB2YWx1ZS5zcGxpdChcIiBcIikuZm9yRWFjaChmdW5jdGlvbiAobW9kaWZpZXIpIHtcblx0ICAgICAgICBzd2l0Y2ggKG1vZGlmaWVyLnRyaW0oKSkge1xuXHQgICAgICAgICAgICBjYXNlIFwiY29uc3RhbnRcIjpcblx0ICAgICAgICAgICAgICAgIHBhcmFtcy5jb25zdGFudCA9IHRydWU7XG5cdCAgICAgICAgICAgICAgICBicmVhaztcblx0ICAgICAgICAgICAgY2FzZSBcInBheWFibGVcIjpcblx0ICAgICAgICAgICAgICAgIHBhcmFtcy5wYXlhYmxlID0gdHJ1ZTtcblx0ICAgICAgICAgICAgICAgIHBhcmFtcy5zdGF0ZU11dGFiaWxpdHkgPSBcInBheWFibGVcIjtcblx0ICAgICAgICAgICAgICAgIGJyZWFrO1xuXHQgICAgICAgICAgICBjYXNlIFwibm9ucGF5YWJsZVwiOlxuXHQgICAgICAgICAgICAgICAgcGFyYW1zLnBheWFibGUgPSBmYWxzZTtcblx0ICAgICAgICAgICAgICAgIHBhcmFtcy5zdGF0ZU11dGFiaWxpdHkgPSBcIm5vbnBheWFibGVcIjtcblx0ICAgICAgICAgICAgICAgIGJyZWFrO1xuXHQgICAgICAgICAgICBjYXNlIFwicHVyZVwiOlxuXHQgICAgICAgICAgICAgICAgcGFyYW1zLmNvbnN0YW50ID0gdHJ1ZTtcblx0ICAgICAgICAgICAgICAgIHBhcmFtcy5zdGF0ZU11dGFiaWxpdHkgPSBcInB1cmVcIjtcblx0ICAgICAgICAgICAgICAgIGJyZWFrO1xuXHQgICAgICAgICAgICBjYXNlIFwidmlld1wiOlxuXHQgICAgICAgICAgICAgICAgcGFyYW1zLmNvbnN0YW50ID0gdHJ1ZTtcblx0ICAgICAgICAgICAgICAgIHBhcmFtcy5zdGF0ZU11dGFiaWxpdHkgPSBcInZpZXdcIjtcblx0ICAgICAgICAgICAgICAgIGJyZWFrO1xuXHQgICAgICAgICAgICBjYXNlIFwiZXh0ZXJuYWxcIjpcblx0ICAgICAgICAgICAgY2FzZSBcInB1YmxpY1wiOlxuXHQgICAgICAgICAgICBjYXNlIFwiXCI6XG5cdCAgICAgICAgICAgICAgICBicmVhaztcblx0ICAgICAgICAgICAgZGVmYXVsdDpcblx0ICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwidW5rbm93biBtb2RpZmllcjogXCIgKyBtb2RpZmllcik7XG5cdCAgICAgICAgfVxuXHQgICAgfSk7XG5cdH1cblx0ZnVuY3Rpb24gdmVyaWZ5U3RhdGUodmFsdWUpIHtcblx0ICAgIHZhciByZXN1bHQgPSB7XG5cdCAgICAgICAgY29uc3RhbnQ6IGZhbHNlLFxuXHQgICAgICAgIHBheWFibGU6IHRydWUsXG5cdCAgICAgICAgc3RhdGVNdXRhYmlsaXR5OiBcInBheWFibGVcIlxuXHQgICAgfTtcblx0ICAgIGlmICh2YWx1ZS5zdGF0ZU11dGFiaWxpdHkgIT0gbnVsbCkge1xuXHQgICAgICAgIHJlc3VsdC5zdGF0ZU11dGFiaWxpdHkgPSB2YWx1ZS5zdGF0ZU11dGFiaWxpdHk7XG5cdCAgICAgICAgLy8gU2V0IChhbmQgY2hlY2sgdGhpbmdzIGFyZSBjb25zaXN0ZW50KSB0aGUgY29uc3RhbnQgcHJvcGVydHlcblx0ICAgICAgICByZXN1bHQuY29uc3RhbnQgPSAocmVzdWx0LnN0YXRlTXV0YWJpbGl0eSA9PT0gXCJ2aWV3XCIgfHwgcmVzdWx0LnN0YXRlTXV0YWJpbGl0eSA9PT0gXCJwdXJlXCIpO1xuXHQgICAgICAgIGlmICh2YWx1ZS5jb25zdGFudCAhPSBudWxsKSB7XG5cdCAgICAgICAgICAgIGlmICgoISF2YWx1ZS5jb25zdGFudCkgIT09IHJlc3VsdC5jb25zdGFudCkge1xuXHQgICAgICAgICAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcImNhbm5vdCBoYXZlIGNvbnN0YW50IGZ1bmN0aW9uIHdpdGggbXV0YWJpbGl0eSBcIiArIHJlc3VsdC5zdGF0ZU11dGFiaWxpdHksIFwidmFsdWVcIiwgdmFsdWUpO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfVxuXHQgICAgICAgIC8vIFNldCAoYW5kIGNoZWNrIHRoaW5ncyBhcmUgY29uc2lzdGVudCkgdGhlIHBheWFibGUgcHJvcGVydHlcblx0ICAgICAgICByZXN1bHQucGF5YWJsZSA9IChyZXN1bHQuc3RhdGVNdXRhYmlsaXR5ID09PSBcInBheWFibGVcIik7XG5cdCAgICAgICAgaWYgKHZhbHVlLnBheWFibGUgIT0gbnVsbCkge1xuXHQgICAgICAgICAgICBpZiAoKCEhdmFsdWUucGF5YWJsZSkgIT09IHJlc3VsdC5wYXlhYmxlKSB7XG5cdCAgICAgICAgICAgICAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwiY2Fubm90IGhhdmUgcGF5YWJsZSBmdW5jdGlvbiB3aXRoIG11dGFiaWxpdHkgXCIgKyByZXN1bHQuc3RhdGVNdXRhYmlsaXR5LCBcInZhbHVlXCIsIHZhbHVlKTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH1cblx0ICAgIH1cblx0ICAgIGVsc2UgaWYgKHZhbHVlLnBheWFibGUgIT0gbnVsbCkge1xuXHQgICAgICAgIHJlc3VsdC5wYXlhYmxlID0gISF2YWx1ZS5wYXlhYmxlO1xuXHQgICAgICAgIC8vIElmIHBheWFibGUgd2UgY2FuIGFzc3VtZSBub24tY29uc3RhbnQ7IG90aGVyd2lzZSB3ZSBjYW4ndCBhc3N1bWVcblx0ICAgICAgICBpZiAodmFsdWUuY29uc3RhbnQgPT0gbnVsbCAmJiAhcmVzdWx0LnBheWFibGUgJiYgdmFsdWUudHlwZSAhPT0gXCJjb25zdHJ1Y3RvclwiKSB7XG5cdCAgICAgICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJ1bmFibGUgdG8gZGV0ZXJtaW5lIHN0YXRlTXV0YWJpbGl0eVwiLCBcInZhbHVlXCIsIHZhbHVlKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgcmVzdWx0LmNvbnN0YW50ID0gISF2YWx1ZS5jb25zdGFudDtcblx0ICAgICAgICBpZiAocmVzdWx0LmNvbnN0YW50KSB7XG5cdCAgICAgICAgICAgIHJlc3VsdC5zdGF0ZU11dGFiaWxpdHkgPSBcInZpZXdcIjtcblx0ICAgICAgICB9XG5cdCAgICAgICAgZWxzZSB7XG5cdCAgICAgICAgICAgIHJlc3VsdC5zdGF0ZU11dGFiaWxpdHkgPSAocmVzdWx0LnBheWFibGUgPyBcInBheWFibGVcIiA6IFwibm9ucGF5YWJsZVwiKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgaWYgKHJlc3VsdC5wYXlhYmxlICYmIHJlc3VsdC5jb25zdGFudCkge1xuXHQgICAgICAgICAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwiY2Fubm90IGhhdmUgY29uc3RhbnQgcGF5YWJsZSBmdW5jdGlvblwiLCBcInZhbHVlXCIsIHZhbHVlKTtcblx0ICAgICAgICB9XG5cdCAgICB9XG5cdCAgICBlbHNlIGlmICh2YWx1ZS5jb25zdGFudCAhPSBudWxsKSB7XG5cdCAgICAgICAgcmVzdWx0LmNvbnN0YW50ID0gISF2YWx1ZS5jb25zdGFudDtcblx0ICAgICAgICByZXN1bHQucGF5YWJsZSA9ICFyZXN1bHQuY29uc3RhbnQ7XG5cdCAgICAgICAgcmVzdWx0LnN0YXRlTXV0YWJpbGl0eSA9IChyZXN1bHQuY29uc3RhbnQgPyBcInZpZXdcIiA6IFwicGF5YWJsZVwiKTtcblx0ICAgIH1cblx0ICAgIGVsc2UgaWYgKHZhbHVlLnR5cGUgIT09IFwiY29uc3RydWN0b3JcIikge1xuXHQgICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJ1bmFibGUgdG8gZGV0ZXJtaW5lIHN0YXRlTXV0YWJpbGl0eVwiLCBcInZhbHVlXCIsIHZhbHVlKTtcblx0ICAgIH1cblx0ICAgIHJldHVybiByZXN1bHQ7XG5cdH1cblx0dmFyIENvbnN0cnVjdG9yRnJhZ21lbnQgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG5cdCAgICBfX2V4dGVuZHMoQ29uc3RydWN0b3JGcmFnbWVudCwgX3N1cGVyKTtcblx0ICAgIGZ1bmN0aW9uIENvbnN0cnVjdG9yRnJhZ21lbnQoKSB7XG5cdCAgICAgICAgcmV0dXJuIF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuXHQgICAgfVxuXHQgICAgQ29uc3RydWN0b3JGcmFnbWVudC5wcm90b3R5cGUuZm9ybWF0ID0gZnVuY3Rpb24gKGZvcm1hdCkge1xuXHQgICAgICAgIGlmICghZm9ybWF0KSB7XG5cdCAgICAgICAgICAgIGZvcm1hdCA9IGV4cG9ydHMuRm9ybWF0VHlwZXMuc2lnaGFzaDtcblx0ICAgICAgICB9XG5cdCAgICAgICAgaWYgKCFleHBvcnRzLkZvcm1hdFR5cGVzW2Zvcm1hdF0pIHtcblx0ICAgICAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcImludmFsaWQgZm9ybWF0IHR5cGVcIiwgXCJmb3JtYXRcIiwgZm9ybWF0KTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgaWYgKGZvcm1hdCA9PT0gZXhwb3J0cy5Gb3JtYXRUeXBlcy5qc29uKSB7XG5cdCAgICAgICAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeSh7XG5cdCAgICAgICAgICAgICAgICB0eXBlOiBcImNvbnN0cnVjdG9yXCIsXG5cdCAgICAgICAgICAgICAgICBzdGF0ZU11dGFiaWxpdHk6ICgodGhpcy5zdGF0ZU11dGFiaWxpdHkgIT09IFwibm9ucGF5YWJsZVwiKSA/IHRoaXMuc3RhdGVNdXRhYmlsaXR5IDogdW5kZWZpbmVkKSxcblx0ICAgICAgICAgICAgICAgIHBheWFibGU6IHRoaXMucGF5YWJsZSxcblx0ICAgICAgICAgICAgICAgIGdhczogKHRoaXMuZ2FzID8gdGhpcy5nYXMudG9OdW1iZXIoKSA6IHVuZGVmaW5lZCksXG5cdCAgICAgICAgICAgICAgICBpbnB1dHM6IHRoaXMuaW5wdXRzLm1hcChmdW5jdGlvbiAoaW5wdXQpIHsgcmV0dXJuIEpTT04ucGFyc2UoaW5wdXQuZm9ybWF0KGZvcm1hdCkpOyB9KVxuXHQgICAgICAgICAgICB9KTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgaWYgKGZvcm1hdCA9PT0gZXhwb3J0cy5Gb3JtYXRUeXBlcy5zaWdoYXNoKSB7XG5cdCAgICAgICAgICAgIGxvZ2dlci50aHJvd0Vycm9yKFwiY2Fubm90IGZvcm1hdCBhIGNvbnN0cnVjdG9yIGZvciBzaWdoYXNoXCIsIGxpYi5Mb2dnZXIuZXJyb3JzLlVOU1VQUE9SVEVEX09QRVJBVElPTiwge1xuXHQgICAgICAgICAgICAgICAgb3BlcmF0aW9uOiBcImZvcm1hdChzaWdoYXNoKVwiXG5cdCAgICAgICAgICAgIH0pO1xuXHQgICAgICAgIH1cblx0ICAgICAgICB2YXIgcmVzdWx0ID0gXCJjb25zdHJ1Y3RvcihcIiArIHRoaXMuaW5wdXRzLm1hcChmdW5jdGlvbiAoaW5wdXQpIHsgcmV0dXJuIGlucHV0LmZvcm1hdChmb3JtYXQpOyB9KS5qb2luKChmb3JtYXQgPT09IGV4cG9ydHMuRm9ybWF0VHlwZXMuZnVsbCkgPyBcIiwgXCIgOiBcIixcIikgKyBcIikgXCI7XG5cdCAgICAgICAgaWYgKHRoaXMuc3RhdGVNdXRhYmlsaXR5ICYmIHRoaXMuc3RhdGVNdXRhYmlsaXR5ICE9PSBcIm5vbnBheWFibGVcIikge1xuXHQgICAgICAgICAgICByZXN1bHQgKz0gdGhpcy5zdGF0ZU11dGFiaWxpdHkgKyBcIiBcIjtcblx0ICAgICAgICB9XG5cdCAgICAgICAgcmV0dXJuIHJlc3VsdC50cmltKCk7XG5cdCAgICB9O1xuXHQgICAgQ29uc3RydWN0b3JGcmFnbWVudC5mcm9tID0gZnVuY3Rpb24gKHZhbHVlKSB7XG5cdCAgICAgICAgaWYgKHR5cGVvZiAodmFsdWUpID09PSBcInN0cmluZ1wiKSB7XG5cdCAgICAgICAgICAgIHJldHVybiBDb25zdHJ1Y3RvckZyYWdtZW50LmZyb21TdHJpbmcodmFsdWUpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICByZXR1cm4gQ29uc3RydWN0b3JGcmFnbWVudC5mcm9tT2JqZWN0KHZhbHVlKTtcblx0ICAgIH07XG5cdCAgICBDb25zdHJ1Y3RvckZyYWdtZW50LmZyb21PYmplY3QgPSBmdW5jdGlvbiAodmFsdWUpIHtcblx0ICAgICAgICBpZiAoQ29uc3RydWN0b3JGcmFnbWVudC5pc0NvbnN0cnVjdG9yRnJhZ21lbnQodmFsdWUpKSB7XG5cdCAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgaWYgKHZhbHVlLnR5cGUgIT09IFwiY29uc3RydWN0b3JcIikge1xuXHQgICAgICAgICAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwiaW52YWxpZCBjb25zdHJ1Y3RvciBvYmplY3RcIiwgXCJ2YWx1ZVwiLCB2YWx1ZSk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHZhciBzdGF0ZSA9IHZlcmlmeVN0YXRlKHZhbHVlKTtcblx0ICAgICAgICBpZiAoc3RhdGUuY29uc3RhbnQpIHtcblx0ICAgICAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcImNvbnN0cnVjdG9yIGNhbm5vdCBiZSBjb25zdGFudFwiLCBcInZhbHVlXCIsIHZhbHVlKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgdmFyIHBhcmFtcyA9IHtcblx0ICAgICAgICAgICAgbmFtZTogbnVsbCxcblx0ICAgICAgICAgICAgdHlwZTogdmFsdWUudHlwZSxcblx0ICAgICAgICAgICAgaW5wdXRzOiAodmFsdWUuaW5wdXRzID8gdmFsdWUuaW5wdXRzLm1hcChQYXJhbVR5cGUuZnJvbU9iamVjdCkgOiBbXSksXG5cdCAgICAgICAgICAgIHBheWFibGU6IHN0YXRlLnBheWFibGUsXG5cdCAgICAgICAgICAgIHN0YXRlTXV0YWJpbGl0eTogc3RhdGUuc3RhdGVNdXRhYmlsaXR5LFxuXHQgICAgICAgICAgICBnYXM6ICh2YWx1ZS5nYXMgPyBsaWIkMi5CaWdOdW1iZXIuZnJvbSh2YWx1ZS5nYXMpIDogbnVsbClcblx0ICAgICAgICB9O1xuXHQgICAgICAgIHJldHVybiBuZXcgQ29uc3RydWN0b3JGcmFnbWVudChfY29uc3RydWN0b3JHdWFyZCwgcGFyYW1zKTtcblx0ICAgIH07XG5cdCAgICBDb25zdHJ1Y3RvckZyYWdtZW50LmZyb21TdHJpbmcgPSBmdW5jdGlvbiAodmFsdWUpIHtcblx0ICAgICAgICB2YXIgcGFyYW1zID0geyB0eXBlOiBcImNvbnN0cnVjdG9yXCIgfTtcblx0ICAgICAgICB2YWx1ZSA9IHBhcnNlR2FzKHZhbHVlLCBwYXJhbXMpO1xuXHQgICAgICAgIHZhciBwYXJlbnMgPSB2YWx1ZS5tYXRjaChyZWdleFBhcmVuKTtcblx0ICAgICAgICBpZiAoIXBhcmVucyB8fCBwYXJlbnNbMV0udHJpbSgpICE9PSBcImNvbnN0cnVjdG9yXCIpIHtcblx0ICAgICAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcImludmFsaWQgY29uc3RydWN0b3Igc3RyaW5nXCIsIFwidmFsdWVcIiwgdmFsdWUpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBwYXJhbXMuaW5wdXRzID0gcGFyc2VQYXJhbXMocGFyZW5zWzJdLnRyaW0oKSwgZmFsc2UpO1xuXHQgICAgICAgIHBhcnNlTW9kaWZpZXJzKHBhcmVuc1szXS50cmltKCksIHBhcmFtcyk7XG5cdCAgICAgICAgcmV0dXJuIENvbnN0cnVjdG9yRnJhZ21lbnQuZnJvbU9iamVjdChwYXJhbXMpO1xuXHQgICAgfTtcblx0ICAgIENvbnN0cnVjdG9yRnJhZ21lbnQuaXNDb25zdHJ1Y3RvckZyYWdtZW50ID0gZnVuY3Rpb24gKHZhbHVlKSB7XG5cdCAgICAgICAgcmV0dXJuICh2YWx1ZSAmJiB2YWx1ZS5faXNGcmFnbWVudCAmJiB2YWx1ZS50eXBlID09PSBcImNvbnN0cnVjdG9yXCIpO1xuXHQgICAgfTtcblx0ICAgIHJldHVybiBDb25zdHJ1Y3RvckZyYWdtZW50O1xuXHR9KEZyYWdtZW50KSk7XG5cdGV4cG9ydHMuQ29uc3RydWN0b3JGcmFnbWVudCA9IENvbnN0cnVjdG9yRnJhZ21lbnQ7XG5cdHZhciBGdW5jdGlvbkZyYWdtZW50ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuXHQgICAgX19leHRlbmRzKEZ1bmN0aW9uRnJhZ21lbnQsIF9zdXBlcik7XG5cdCAgICBmdW5jdGlvbiBGdW5jdGlvbkZyYWdtZW50KCkge1xuXHQgICAgICAgIHJldHVybiBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcblx0ICAgIH1cblx0ICAgIEZ1bmN0aW9uRnJhZ21lbnQucHJvdG90eXBlLmZvcm1hdCA9IGZ1bmN0aW9uIChmb3JtYXQpIHtcblx0ICAgICAgICBpZiAoIWZvcm1hdCkge1xuXHQgICAgICAgICAgICBmb3JtYXQgPSBleHBvcnRzLkZvcm1hdFR5cGVzLnNpZ2hhc2g7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGlmICghZXhwb3J0cy5Gb3JtYXRUeXBlc1tmb3JtYXRdKSB7XG5cdCAgICAgICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJpbnZhbGlkIGZvcm1hdCB0eXBlXCIsIFwiZm9ybWF0XCIsIGZvcm1hdCk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGlmIChmb3JtYXQgPT09IGV4cG9ydHMuRm9ybWF0VHlwZXMuanNvbikge1xuXHQgICAgICAgICAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkoe1xuXHQgICAgICAgICAgICAgICAgdHlwZTogXCJmdW5jdGlvblwiLFxuXHQgICAgICAgICAgICAgICAgbmFtZTogdGhpcy5uYW1lLFxuXHQgICAgICAgICAgICAgICAgY29uc3RhbnQ6IHRoaXMuY29uc3RhbnQsXG5cdCAgICAgICAgICAgICAgICBzdGF0ZU11dGFiaWxpdHk6ICgodGhpcy5zdGF0ZU11dGFiaWxpdHkgIT09IFwibm9ucGF5YWJsZVwiKSA/IHRoaXMuc3RhdGVNdXRhYmlsaXR5IDogdW5kZWZpbmVkKSxcblx0ICAgICAgICAgICAgICAgIHBheWFibGU6IHRoaXMucGF5YWJsZSxcblx0ICAgICAgICAgICAgICAgIGdhczogKHRoaXMuZ2FzID8gdGhpcy5nYXMudG9OdW1iZXIoKSA6IHVuZGVmaW5lZCksXG5cdCAgICAgICAgICAgICAgICBpbnB1dHM6IHRoaXMuaW5wdXRzLm1hcChmdW5jdGlvbiAoaW5wdXQpIHsgcmV0dXJuIEpTT04ucGFyc2UoaW5wdXQuZm9ybWF0KGZvcm1hdCkpOyB9KSxcblx0ICAgICAgICAgICAgICAgIG91dHB1dHM6IHRoaXMub3V0cHV0cy5tYXAoZnVuY3Rpb24gKG91dHB1dCkgeyByZXR1cm4gSlNPTi5wYXJzZShvdXRwdXQuZm9ybWF0KGZvcm1hdCkpOyB9KSxcblx0ICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHZhciByZXN1bHQgPSBcIlwiO1xuXHQgICAgICAgIGlmIChmb3JtYXQgIT09IGV4cG9ydHMuRm9ybWF0VHlwZXMuc2lnaGFzaCkge1xuXHQgICAgICAgICAgICByZXN1bHQgKz0gXCJmdW5jdGlvbiBcIjtcblx0ICAgICAgICB9XG5cdCAgICAgICAgcmVzdWx0ICs9IHRoaXMubmFtZSArIFwiKFwiICsgdGhpcy5pbnB1dHMubWFwKGZ1bmN0aW9uIChpbnB1dCkgeyByZXR1cm4gaW5wdXQuZm9ybWF0KGZvcm1hdCk7IH0pLmpvaW4oKGZvcm1hdCA9PT0gZXhwb3J0cy5Gb3JtYXRUeXBlcy5mdWxsKSA/IFwiLCBcIiA6IFwiLFwiKSArIFwiKSBcIjtcblx0ICAgICAgICBpZiAoZm9ybWF0ICE9PSBleHBvcnRzLkZvcm1hdFR5cGVzLnNpZ2hhc2gpIHtcblx0ICAgICAgICAgICAgaWYgKHRoaXMuc3RhdGVNdXRhYmlsaXR5KSB7XG5cdCAgICAgICAgICAgICAgICBpZiAodGhpcy5zdGF0ZU11dGFiaWxpdHkgIT09IFwibm9ucGF5YWJsZVwiKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgcmVzdWx0ICs9ICh0aGlzLnN0YXRlTXV0YWJpbGl0eSArIFwiIFwiKTtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICBlbHNlIGlmICh0aGlzLmNvbnN0YW50KSB7XG5cdCAgICAgICAgICAgICAgICByZXN1bHQgKz0gXCJ2aWV3IFwiO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIGlmICh0aGlzLm91dHB1dHMgJiYgdGhpcy5vdXRwdXRzLmxlbmd0aCkge1xuXHQgICAgICAgICAgICAgICAgcmVzdWx0ICs9IFwicmV0dXJucyAoXCIgKyB0aGlzLm91dHB1dHMubWFwKGZ1bmN0aW9uIChvdXRwdXQpIHsgcmV0dXJuIG91dHB1dC5mb3JtYXQoZm9ybWF0KTsgfSkuam9pbihcIiwgXCIpICsgXCIpIFwiO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIGlmICh0aGlzLmdhcyAhPSBudWxsKSB7XG5cdCAgICAgICAgICAgICAgICByZXN1bHQgKz0gXCJAXCIgKyB0aGlzLmdhcy50b1N0cmluZygpICsgXCIgXCI7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9XG5cdCAgICAgICAgcmV0dXJuIHJlc3VsdC50cmltKCk7XG5cdCAgICB9O1xuXHQgICAgRnVuY3Rpb25GcmFnbWVudC5mcm9tID0gZnVuY3Rpb24gKHZhbHVlKSB7XG5cdCAgICAgICAgaWYgKHR5cGVvZiAodmFsdWUpID09PSBcInN0cmluZ1wiKSB7XG5cdCAgICAgICAgICAgIHJldHVybiBGdW5jdGlvbkZyYWdtZW50LmZyb21TdHJpbmcodmFsdWUpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICByZXR1cm4gRnVuY3Rpb25GcmFnbWVudC5mcm9tT2JqZWN0KHZhbHVlKTtcblx0ICAgIH07XG5cdCAgICBGdW5jdGlvbkZyYWdtZW50LmZyb21PYmplY3QgPSBmdW5jdGlvbiAodmFsdWUpIHtcblx0ICAgICAgICBpZiAoRnVuY3Rpb25GcmFnbWVudC5pc0Z1bmN0aW9uRnJhZ21lbnQodmFsdWUpKSB7XG5cdCAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgaWYgKHZhbHVlLnR5cGUgIT09IFwiZnVuY3Rpb25cIikge1xuXHQgICAgICAgICAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwiaW52YWxpZCBmdW5jdGlvbiBvYmplY3RcIiwgXCJ2YWx1ZVwiLCB2YWx1ZSk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHZhciBzdGF0ZSA9IHZlcmlmeVN0YXRlKHZhbHVlKTtcblx0ICAgICAgICB2YXIgcGFyYW1zID0ge1xuXHQgICAgICAgICAgICB0eXBlOiB2YWx1ZS50eXBlLFxuXHQgICAgICAgICAgICBuYW1lOiB2ZXJpZnlJZGVudGlmaWVyKHZhbHVlLm5hbWUpLFxuXHQgICAgICAgICAgICBjb25zdGFudDogc3RhdGUuY29uc3RhbnQsXG5cdCAgICAgICAgICAgIGlucHV0czogKHZhbHVlLmlucHV0cyA/IHZhbHVlLmlucHV0cy5tYXAoUGFyYW1UeXBlLmZyb21PYmplY3QpIDogW10pLFxuXHQgICAgICAgICAgICBvdXRwdXRzOiAodmFsdWUub3V0cHV0cyA/IHZhbHVlLm91dHB1dHMubWFwKFBhcmFtVHlwZS5mcm9tT2JqZWN0KSA6IFtdKSxcblx0ICAgICAgICAgICAgcGF5YWJsZTogc3RhdGUucGF5YWJsZSxcblx0ICAgICAgICAgICAgc3RhdGVNdXRhYmlsaXR5OiBzdGF0ZS5zdGF0ZU11dGFiaWxpdHksXG5cdCAgICAgICAgICAgIGdhczogKHZhbHVlLmdhcyA/IGxpYiQyLkJpZ051bWJlci5mcm9tKHZhbHVlLmdhcykgOiBudWxsKVxuXHQgICAgICAgIH07XG5cdCAgICAgICAgcmV0dXJuIG5ldyBGdW5jdGlvbkZyYWdtZW50KF9jb25zdHJ1Y3Rvckd1YXJkLCBwYXJhbXMpO1xuXHQgICAgfTtcblx0ICAgIEZ1bmN0aW9uRnJhZ21lbnQuZnJvbVN0cmluZyA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuXHQgICAgICAgIHZhciBwYXJhbXMgPSB7IHR5cGU6IFwiZnVuY3Rpb25cIiB9O1xuXHQgICAgICAgIHZhbHVlID0gcGFyc2VHYXModmFsdWUsIHBhcmFtcyk7XG5cdCAgICAgICAgdmFyIGNvbXBzID0gdmFsdWUuc3BsaXQoXCIgcmV0dXJucyBcIik7XG5cdCAgICAgICAgaWYgKGNvbXBzLmxlbmd0aCA+IDIpIHtcblx0ICAgICAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcImludmFsaWQgZnVuY3Rpb24gc3RyaW5nXCIsIFwidmFsdWVcIiwgdmFsdWUpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICB2YXIgcGFyZW5zID0gY29tcHNbMF0ubWF0Y2gocmVnZXhQYXJlbik7XG5cdCAgICAgICAgaWYgKCFwYXJlbnMpIHtcblx0ICAgICAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcImludmFsaWQgZnVuY3Rpb24gc2lnbmF0dXJlXCIsIFwidmFsdWVcIiwgdmFsdWUpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBwYXJhbXMubmFtZSA9IHBhcmVuc1sxXS50cmltKCk7XG5cdCAgICAgICAgaWYgKHBhcmFtcy5uYW1lKSB7XG5cdCAgICAgICAgICAgIHZlcmlmeUlkZW50aWZpZXIocGFyYW1zLm5hbWUpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBwYXJhbXMuaW5wdXRzID0gcGFyc2VQYXJhbXMocGFyZW5zWzJdLCBmYWxzZSk7XG5cdCAgICAgICAgcGFyc2VNb2RpZmllcnMocGFyZW5zWzNdLnRyaW0oKSwgcGFyYW1zKTtcblx0ICAgICAgICAvLyBXZSBoYXZlIG91dHB1dHNcblx0ICAgICAgICBpZiAoY29tcHMubGVuZ3RoID4gMSkge1xuXHQgICAgICAgICAgICB2YXIgcmV0dXJucyA9IGNvbXBzWzFdLm1hdGNoKHJlZ2V4UGFyZW4pO1xuXHQgICAgICAgICAgICBpZiAocmV0dXJuc1sxXS50cmltKCkgIT0gXCJcIiB8fCByZXR1cm5zWzNdLnRyaW0oKSAhPSBcIlwiKSB7XG5cdCAgICAgICAgICAgICAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwidW5leHBlY3RlZCB0b2tlbnNcIiwgXCJ2YWx1ZVwiLCB2YWx1ZSk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgcGFyYW1zLm91dHB1dHMgPSBwYXJzZVBhcmFtcyhyZXR1cm5zWzJdLCBmYWxzZSk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGVsc2Uge1xuXHQgICAgICAgICAgICBwYXJhbXMub3V0cHV0cyA9IFtdO1xuXHQgICAgICAgIH1cblx0ICAgICAgICByZXR1cm4gRnVuY3Rpb25GcmFnbWVudC5mcm9tT2JqZWN0KHBhcmFtcyk7XG5cdCAgICB9O1xuXHQgICAgRnVuY3Rpb25GcmFnbWVudC5pc0Z1bmN0aW9uRnJhZ21lbnQgPSBmdW5jdGlvbiAodmFsdWUpIHtcblx0ICAgICAgICByZXR1cm4gKHZhbHVlICYmIHZhbHVlLl9pc0ZyYWdtZW50ICYmIHZhbHVlLnR5cGUgPT09IFwiZnVuY3Rpb25cIik7XG5cdCAgICB9O1xuXHQgICAgcmV0dXJuIEZ1bmN0aW9uRnJhZ21lbnQ7XG5cdH0oQ29uc3RydWN0b3JGcmFnbWVudCkpO1xuXHRleHBvcnRzLkZ1bmN0aW9uRnJhZ21lbnQgPSBGdW5jdGlvbkZyYWdtZW50O1xuXHQvL2V4cG9ydCBjbGFzcyBTdHJ1Y3RGcmFnbWVudCBleHRlbmRzIEZyYWdtZW50IHtcblx0Ly99XG5cdGZ1bmN0aW9uIGNoZWNrRm9yYmlkZGVuKGZyYWdtZW50KSB7XG5cdCAgICB2YXIgc2lnID0gZnJhZ21lbnQuZm9ybWF0KCk7XG5cdCAgICBpZiAoc2lnID09PSBcIkVycm9yKHN0cmluZylcIiB8fCBzaWcgPT09IFwiUGFuaWModWludDI1NilcIikge1xuXHQgICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJjYW5ub3Qgc3BlY2lmeSB1c2VyIGRlZmluZWQgXCIgKyBzaWcgKyBcIiBlcnJvclwiLCBcImZyYWdtZW50XCIsIGZyYWdtZW50KTtcblx0ICAgIH1cblx0ICAgIHJldHVybiBmcmFnbWVudDtcblx0fVxuXHR2YXIgRXJyb3JGcmFnbWVudCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcblx0ICAgIF9fZXh0ZW5kcyhFcnJvckZyYWdtZW50LCBfc3VwZXIpO1xuXHQgICAgZnVuY3Rpb24gRXJyb3JGcmFnbWVudCgpIHtcblx0ICAgICAgICByZXR1cm4gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG5cdCAgICB9XG5cdCAgICBFcnJvckZyYWdtZW50LnByb3RvdHlwZS5mb3JtYXQgPSBmdW5jdGlvbiAoZm9ybWF0KSB7XG5cdCAgICAgICAgaWYgKCFmb3JtYXQpIHtcblx0ICAgICAgICAgICAgZm9ybWF0ID0gZXhwb3J0cy5Gb3JtYXRUeXBlcy5zaWdoYXNoO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBpZiAoIWV4cG9ydHMuRm9ybWF0VHlwZXNbZm9ybWF0XSkge1xuXHQgICAgICAgICAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwiaW52YWxpZCBmb3JtYXQgdHlwZVwiLCBcImZvcm1hdFwiLCBmb3JtYXQpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBpZiAoZm9ybWF0ID09PSBleHBvcnRzLkZvcm1hdFR5cGVzLmpzb24pIHtcblx0ICAgICAgICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHtcblx0ICAgICAgICAgICAgICAgIHR5cGU6IFwiZXJyb3JcIixcblx0ICAgICAgICAgICAgICAgIG5hbWU6IHRoaXMubmFtZSxcblx0ICAgICAgICAgICAgICAgIGlucHV0czogdGhpcy5pbnB1dHMubWFwKGZ1bmN0aW9uIChpbnB1dCkgeyByZXR1cm4gSlNPTi5wYXJzZShpbnB1dC5mb3JtYXQoZm9ybWF0KSk7IH0pLFxuXHQgICAgICAgICAgICB9KTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgdmFyIHJlc3VsdCA9IFwiXCI7XG5cdCAgICAgICAgaWYgKGZvcm1hdCAhPT0gZXhwb3J0cy5Gb3JtYXRUeXBlcy5zaWdoYXNoKSB7XG5cdCAgICAgICAgICAgIHJlc3VsdCArPSBcImVycm9yIFwiO1xuXHQgICAgICAgIH1cblx0ICAgICAgICByZXN1bHQgKz0gdGhpcy5uYW1lICsgXCIoXCIgKyB0aGlzLmlucHV0cy5tYXAoZnVuY3Rpb24gKGlucHV0KSB7IHJldHVybiBpbnB1dC5mb3JtYXQoZm9ybWF0KTsgfSkuam9pbigoZm9ybWF0ID09PSBleHBvcnRzLkZvcm1hdFR5cGVzLmZ1bGwpID8gXCIsIFwiIDogXCIsXCIpICsgXCIpIFwiO1xuXHQgICAgICAgIHJldHVybiByZXN1bHQudHJpbSgpO1xuXHQgICAgfTtcblx0ICAgIEVycm9yRnJhZ21lbnQuZnJvbSA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuXHQgICAgICAgIGlmICh0eXBlb2YgKHZhbHVlKSA9PT0gXCJzdHJpbmdcIikge1xuXHQgICAgICAgICAgICByZXR1cm4gRXJyb3JGcmFnbWVudC5mcm9tU3RyaW5nKHZhbHVlKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgcmV0dXJuIEVycm9yRnJhZ21lbnQuZnJvbU9iamVjdCh2YWx1ZSk7XG5cdCAgICB9O1xuXHQgICAgRXJyb3JGcmFnbWVudC5mcm9tT2JqZWN0ID0gZnVuY3Rpb24gKHZhbHVlKSB7XG5cdCAgICAgICAgaWYgKEVycm9yRnJhZ21lbnQuaXNFcnJvckZyYWdtZW50KHZhbHVlKSkge1xuXHQgICAgICAgICAgICByZXR1cm4gdmFsdWU7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGlmICh2YWx1ZS50eXBlICE9PSBcImVycm9yXCIpIHtcblx0ICAgICAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcImludmFsaWQgZXJyb3Igb2JqZWN0XCIsIFwidmFsdWVcIiwgdmFsdWUpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICB2YXIgcGFyYW1zID0ge1xuXHQgICAgICAgICAgICB0eXBlOiB2YWx1ZS50eXBlLFxuXHQgICAgICAgICAgICBuYW1lOiB2ZXJpZnlJZGVudGlmaWVyKHZhbHVlLm5hbWUpLFxuXHQgICAgICAgICAgICBpbnB1dHM6ICh2YWx1ZS5pbnB1dHMgPyB2YWx1ZS5pbnB1dHMubWFwKFBhcmFtVHlwZS5mcm9tT2JqZWN0KSA6IFtdKVxuXHQgICAgICAgIH07XG5cdCAgICAgICAgcmV0dXJuIGNoZWNrRm9yYmlkZGVuKG5ldyBFcnJvckZyYWdtZW50KF9jb25zdHJ1Y3Rvckd1YXJkLCBwYXJhbXMpKTtcblx0ICAgIH07XG5cdCAgICBFcnJvckZyYWdtZW50LmZyb21TdHJpbmcgPSBmdW5jdGlvbiAodmFsdWUpIHtcblx0ICAgICAgICB2YXIgcGFyYW1zID0geyB0eXBlOiBcImVycm9yXCIgfTtcblx0ICAgICAgICB2YXIgcGFyZW5zID0gdmFsdWUubWF0Y2gocmVnZXhQYXJlbik7XG5cdCAgICAgICAgaWYgKCFwYXJlbnMpIHtcblx0ICAgICAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcImludmFsaWQgZXJyb3Igc2lnbmF0dXJlXCIsIFwidmFsdWVcIiwgdmFsdWUpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBwYXJhbXMubmFtZSA9IHBhcmVuc1sxXS50cmltKCk7XG5cdCAgICAgICAgaWYgKHBhcmFtcy5uYW1lKSB7XG5cdCAgICAgICAgICAgIHZlcmlmeUlkZW50aWZpZXIocGFyYW1zLm5hbWUpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBwYXJhbXMuaW5wdXRzID0gcGFyc2VQYXJhbXMocGFyZW5zWzJdLCBmYWxzZSk7XG5cdCAgICAgICAgcmV0dXJuIGNoZWNrRm9yYmlkZGVuKEVycm9yRnJhZ21lbnQuZnJvbU9iamVjdChwYXJhbXMpKTtcblx0ICAgIH07XG5cdCAgICBFcnJvckZyYWdtZW50LmlzRXJyb3JGcmFnbWVudCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuXHQgICAgICAgIHJldHVybiAodmFsdWUgJiYgdmFsdWUuX2lzRnJhZ21lbnQgJiYgdmFsdWUudHlwZSA9PT0gXCJlcnJvclwiKTtcblx0ICAgIH07XG5cdCAgICByZXR1cm4gRXJyb3JGcmFnbWVudDtcblx0fShGcmFnbWVudCkpO1xuXHRleHBvcnRzLkVycm9yRnJhZ21lbnQgPSBFcnJvckZyYWdtZW50O1xuXHRmdW5jdGlvbiB2ZXJpZnlUeXBlKHR5cGUpIHtcblx0ICAgIC8vIFRoZXNlIG5lZWQgdG8gYmUgdHJhbnNmb3JtZWQgdG8gdGhlaXIgZnVsbCBkZXNjcmlwdGlvblxuXHQgICAgaWYgKHR5cGUubWF0Y2goL151aW50KCR8W14xLTldKS8pKSB7XG5cdCAgICAgICAgdHlwZSA9IFwidWludDI1NlwiICsgdHlwZS5zdWJzdHJpbmcoNCk7XG5cdCAgICB9XG5cdCAgICBlbHNlIGlmICh0eXBlLm1hdGNoKC9eaW50KCR8W14xLTldKS8pKSB7XG5cdCAgICAgICAgdHlwZSA9IFwiaW50MjU2XCIgKyB0eXBlLnN1YnN0cmluZygzKTtcblx0ICAgIH1cblx0ICAgIC8vIEBUT0RPOiBtb3JlIHZlcmlmaWNhdGlvblxuXHQgICAgcmV0dXJuIHR5cGU7XG5cdH1cblx0Ly8gU2VlOiBodHRwczovL2dpdGh1Yi5jb20vZXRoZXJldW0vc29saWRpdHkvYmxvYi8xZjhmMWEzZGI5M2E1NDhkMDU1NWUzZTE0Y2ZjNTVhMTBlMjViNjBlL2RvY3MvZ3JhbW1hci9Tb2xpZGl0eUxleGVyLmc0I0wyMzRcblx0dmFyIHJlZ2V4SWRlbnRpZmllciA9IG5ldyBSZWdFeHAoXCJeW2EtekEtWiRfXVthLXpBLVowLTkkX10qJFwiKTtcblx0ZnVuY3Rpb24gdmVyaWZ5SWRlbnRpZmllcih2YWx1ZSkge1xuXHQgICAgaWYgKCF2YWx1ZSB8fCAhdmFsdWUubWF0Y2gocmVnZXhJZGVudGlmaWVyKSkge1xuXHQgICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJpbnZhbGlkIGlkZW50aWZpZXIgXFxcIlwiICsgdmFsdWUgKyBcIlxcXCJcIiwgXCJ2YWx1ZVwiLCB2YWx1ZSk7XG5cdCAgICB9XG5cdCAgICByZXR1cm4gdmFsdWU7XG5cdH1cblx0dmFyIHJlZ2V4UGFyZW4gPSBuZXcgUmVnRXhwKFwiXihbXikoXSopXFxcXCgoLiopXFxcXCkoW14pKF0qKSRcIik7XG5cdGZ1bmN0aW9uIHNwbGl0TmVzdGluZyh2YWx1ZSkge1xuXHQgICAgdmFsdWUgPSB2YWx1ZS50cmltKCk7XG5cdCAgICB2YXIgcmVzdWx0ID0gW107XG5cdCAgICB2YXIgYWNjdW0gPSBcIlwiO1xuXHQgICAgdmFyIGRlcHRoID0gMDtcblx0ICAgIGZvciAodmFyIG9mZnNldCA9IDA7IG9mZnNldCA8IHZhbHVlLmxlbmd0aDsgb2Zmc2V0KyspIHtcblx0ICAgICAgICB2YXIgYyA9IHZhbHVlW29mZnNldF07XG5cdCAgICAgICAgaWYgKGMgPT09IFwiLFwiICYmIGRlcHRoID09PSAwKSB7XG5cdCAgICAgICAgICAgIHJlc3VsdC5wdXNoKGFjY3VtKTtcblx0ICAgICAgICAgICAgYWNjdW0gPSBcIlwiO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBlbHNlIHtcblx0ICAgICAgICAgICAgYWNjdW0gKz0gYztcblx0ICAgICAgICAgICAgaWYgKGMgPT09IFwiKFwiKSB7XG5cdCAgICAgICAgICAgICAgICBkZXB0aCsrO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIGVsc2UgaWYgKGMgPT09IFwiKVwiKSB7XG5cdCAgICAgICAgICAgICAgICBkZXB0aC0tO1xuXHQgICAgICAgICAgICAgICAgaWYgKGRlcHRoID09PSAtMSkge1xuXHQgICAgICAgICAgICAgICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJ1bmJhbGFuY2VkIHBhcmVudGhlc2lzXCIsIFwidmFsdWVcIiwgdmFsdWUpO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfVxuXHQgICAgfVxuXHQgICAgaWYgKGFjY3VtKSB7XG5cdCAgICAgICAgcmVzdWx0LnB1c2goYWNjdW0pO1xuXHQgICAgfVxuXHQgICAgcmV0dXJuIHJlc3VsdDtcblx0fVxuXG5cdH0pO1xuXG5cdHZhciBmcmFnbWVudHMkMSA9IC8qQF9fUFVSRV9fKi9nZXREZWZhdWx0RXhwb3J0RnJvbUNqcyhmcmFnbWVudHMpO1xuXG5cdHZhciBhYnN0cmFjdENvZGVyID0gY3JlYXRlQ29tbW9uanNNb2R1bGUoZnVuY3Rpb24gKG1vZHVsZSwgZXhwb3J0cykge1xuXHRcInVzZSBzdHJpY3RcIjtcblx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuXHRleHBvcnRzLlJlYWRlciA9IGV4cG9ydHMuV3JpdGVyID0gZXhwb3J0cy5Db2RlciA9IGV4cG9ydHMuY2hlY2tSZXN1bHRFcnJvcnMgPSB2b2lkIDA7XG5cblxuXG5cblxuXHR2YXIgbG9nZ2VyID0gbmV3IGxpYi5Mb2dnZXIoX3ZlcnNpb24kOC52ZXJzaW9uKTtcblx0ZnVuY3Rpb24gY2hlY2tSZXN1bHRFcnJvcnMocmVzdWx0KSB7XG5cdCAgICAvLyBGaW5kIHRoZSBmaXJzdCBlcnJvciAoaWYgYW55KVxuXHQgICAgdmFyIGVycm9ycyA9IFtdO1xuXHQgICAgdmFyIGNoZWNrRXJyb3JzID0gZnVuY3Rpb24gKHBhdGgsIG9iamVjdCkge1xuXHQgICAgICAgIGlmICghQXJyYXkuaXNBcnJheShvYmplY3QpKSB7XG5cdCAgICAgICAgICAgIHJldHVybjtcblx0ICAgICAgICB9XG5cdCAgICAgICAgZm9yICh2YXIga2V5IGluIG9iamVjdCkge1xuXHQgICAgICAgICAgICB2YXIgY2hpbGRQYXRoID0gcGF0aC5zbGljZSgpO1xuXHQgICAgICAgICAgICBjaGlsZFBhdGgucHVzaChrZXkpO1xuXHQgICAgICAgICAgICB0cnkge1xuXHQgICAgICAgICAgICAgICAgY2hlY2tFcnJvcnMoY2hpbGRQYXRoLCBvYmplY3Rba2V5XSk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG5cdCAgICAgICAgICAgICAgICBlcnJvcnMucHVzaCh7IHBhdGg6IGNoaWxkUGF0aCwgZXJyb3I6IGVycm9yIH0pO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfVxuXHQgICAgfTtcblx0ICAgIGNoZWNrRXJyb3JzKFtdLCByZXN1bHQpO1xuXHQgICAgcmV0dXJuIGVycm9ycztcblx0fVxuXHRleHBvcnRzLmNoZWNrUmVzdWx0RXJyb3JzID0gY2hlY2tSZXN1bHRFcnJvcnM7XG5cdHZhciBDb2RlciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcblx0ICAgIGZ1bmN0aW9uIENvZGVyKG5hbWUsIHR5cGUsIGxvY2FsTmFtZSwgZHluYW1pYykge1xuXHQgICAgICAgIC8vIEBUT0RPOiBkZWZpbmVSZWFkT25seSB0aGVzZVxuXHQgICAgICAgIHRoaXMubmFtZSA9IG5hbWU7XG5cdCAgICAgICAgdGhpcy50eXBlID0gdHlwZTtcblx0ICAgICAgICB0aGlzLmxvY2FsTmFtZSA9IGxvY2FsTmFtZTtcblx0ICAgICAgICB0aGlzLmR5bmFtaWMgPSBkeW5hbWljO1xuXHQgICAgfVxuXHQgICAgQ29kZXIucHJvdG90eXBlLl90aHJvd0Vycm9yID0gZnVuY3Rpb24gKG1lc3NhZ2UsIHZhbHVlKSB7XG5cdCAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihtZXNzYWdlLCB0aGlzLmxvY2FsTmFtZSwgdmFsdWUpO1xuXHQgICAgfTtcblx0ICAgIHJldHVybiBDb2Rlcjtcblx0fSgpKTtcblx0ZXhwb3J0cy5Db2RlciA9IENvZGVyO1xuXHR2YXIgV3JpdGVyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuXHQgICAgZnVuY3Rpb24gV3JpdGVyKHdvcmRTaXplKSB7XG5cdCAgICAgICAgKDAsIGxpYiQzLmRlZmluZVJlYWRPbmx5KSh0aGlzLCBcIndvcmRTaXplXCIsIHdvcmRTaXplIHx8IDMyKTtcblx0ICAgICAgICB0aGlzLl9kYXRhID0gW107XG5cdCAgICAgICAgdGhpcy5fZGF0YUxlbmd0aCA9IDA7XG5cdCAgICAgICAgdGhpcy5fcGFkZGluZyA9IG5ldyBVaW50OEFycmF5KHdvcmRTaXplKTtcblx0ICAgIH1cblx0ICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShXcml0ZXIucHJvdG90eXBlLCBcImRhdGFcIiwge1xuXHQgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICByZXR1cm4gKDAsIGxpYiQxLmhleENvbmNhdCkodGhpcy5fZGF0YSk7XG5cdCAgICAgICAgfSxcblx0ICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcblx0ICAgICAgICBjb25maWd1cmFibGU6IHRydWVcblx0ICAgIH0pO1xuXHQgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFdyaXRlci5wcm90b3R5cGUsIFwibGVuZ3RoXCIsIHtcblx0ICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX2RhdGFMZW5ndGg7IH0sXG5cdCAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG5cdCAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG5cdCAgICB9KTtcblx0ICAgIFdyaXRlci5wcm90b3R5cGUuX3dyaXRlRGF0YSA9IGZ1bmN0aW9uIChkYXRhKSB7XG5cdCAgICAgICAgdGhpcy5fZGF0YS5wdXNoKGRhdGEpO1xuXHQgICAgICAgIHRoaXMuX2RhdGFMZW5ndGggKz0gZGF0YS5sZW5ndGg7XG5cdCAgICAgICAgcmV0dXJuIGRhdGEubGVuZ3RoO1xuXHQgICAgfTtcblx0ICAgIFdyaXRlci5wcm90b3R5cGUuYXBwZW5kV3JpdGVyID0gZnVuY3Rpb24gKHdyaXRlcikge1xuXHQgICAgICAgIHJldHVybiB0aGlzLl93cml0ZURhdGEoKDAsIGxpYiQxLmNvbmNhdCkod3JpdGVyLl9kYXRhKSk7XG5cdCAgICB9O1xuXHQgICAgLy8gQXJyYXlpc2ggaXRlbXM7IHBhZGRlZCBvbiB0aGUgcmlnaHQgdG8gd29yZFNpemVcblx0ICAgIFdyaXRlci5wcm90b3R5cGUud3JpdGVCeXRlcyA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuXHQgICAgICAgIHZhciBieXRlcyA9ICgwLCBsaWIkMS5hcnJheWlmeSkodmFsdWUpO1xuXHQgICAgICAgIHZhciBwYWRkaW5nT2Zmc2V0ID0gYnl0ZXMubGVuZ3RoICUgdGhpcy53b3JkU2l6ZTtcblx0ICAgICAgICBpZiAocGFkZGluZ09mZnNldCkge1xuXHQgICAgICAgICAgICBieXRlcyA9ICgwLCBsaWIkMS5jb25jYXQpKFtieXRlcywgdGhpcy5fcGFkZGluZy5zbGljZShwYWRkaW5nT2Zmc2V0KV0pO1xuXHQgICAgICAgIH1cblx0ICAgICAgICByZXR1cm4gdGhpcy5fd3JpdGVEYXRhKGJ5dGVzKTtcblx0ICAgIH07XG5cdCAgICBXcml0ZXIucHJvdG90eXBlLl9nZXRWYWx1ZSA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuXHQgICAgICAgIHZhciBieXRlcyA9ICgwLCBsaWIkMS5hcnJheWlmeSkobGliJDIuQmlnTnVtYmVyLmZyb20odmFsdWUpKTtcblx0ICAgICAgICBpZiAoYnl0ZXMubGVuZ3RoID4gdGhpcy53b3JkU2l6ZSkge1xuXHQgICAgICAgICAgICBsb2dnZXIudGhyb3dFcnJvcihcInZhbHVlIG91dC1vZi1ib3VuZHNcIiwgbGliLkxvZ2dlci5lcnJvcnMuQlVGRkVSX09WRVJSVU4sIHtcblx0ICAgICAgICAgICAgICAgIGxlbmd0aDogdGhpcy53b3JkU2l6ZSxcblx0ICAgICAgICAgICAgICAgIG9mZnNldDogYnl0ZXMubGVuZ3RoXG5cdCAgICAgICAgICAgIH0pO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBpZiAoYnl0ZXMubGVuZ3RoICUgdGhpcy53b3JkU2l6ZSkge1xuXHQgICAgICAgICAgICBieXRlcyA9ICgwLCBsaWIkMS5jb25jYXQpKFt0aGlzLl9wYWRkaW5nLnNsaWNlKGJ5dGVzLmxlbmd0aCAlIHRoaXMud29yZFNpemUpLCBieXRlc10pO1xuXHQgICAgICAgIH1cblx0ICAgICAgICByZXR1cm4gYnl0ZXM7XG5cdCAgICB9O1xuXHQgICAgLy8gQmlnTnVtYmVyaXNoIGl0ZW1zOyBwYWRkZWQgb24gdGhlIGxlZnQgdG8gd29yZFNpemVcblx0ICAgIFdyaXRlci5wcm90b3R5cGUud3JpdGVWYWx1ZSA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuXHQgICAgICAgIHJldHVybiB0aGlzLl93cml0ZURhdGEodGhpcy5fZ2V0VmFsdWUodmFsdWUpKTtcblx0ICAgIH07XG5cdCAgICBXcml0ZXIucHJvdG90eXBlLndyaXRlVXBkYXRhYmxlVmFsdWUgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgdmFyIF90aGlzID0gdGhpcztcblx0ICAgICAgICB2YXIgb2Zmc2V0ID0gdGhpcy5fZGF0YS5sZW5ndGg7XG5cdCAgICAgICAgdGhpcy5fZGF0YS5wdXNoKHRoaXMuX3BhZGRpbmcpO1xuXHQgICAgICAgIHRoaXMuX2RhdGFMZW5ndGggKz0gdGhpcy53b3JkU2l6ZTtcblx0ICAgICAgICByZXR1cm4gZnVuY3Rpb24gKHZhbHVlKSB7XG5cdCAgICAgICAgICAgIF90aGlzLl9kYXRhW29mZnNldF0gPSBfdGhpcy5fZ2V0VmFsdWUodmFsdWUpO1xuXHQgICAgICAgIH07XG5cdCAgICB9O1xuXHQgICAgcmV0dXJuIFdyaXRlcjtcblx0fSgpKTtcblx0ZXhwb3J0cy5Xcml0ZXIgPSBXcml0ZXI7XG5cdHZhciBSZWFkZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG5cdCAgICBmdW5jdGlvbiBSZWFkZXIoZGF0YSwgd29yZFNpemUsIGNvZXJjZUZ1bmMsIGFsbG93TG9vc2UpIHtcblx0ICAgICAgICAoMCwgbGliJDMuZGVmaW5lUmVhZE9ubHkpKHRoaXMsIFwiX2RhdGFcIiwgKDAsIGxpYiQxLmFycmF5aWZ5KShkYXRhKSk7XG5cdCAgICAgICAgKDAsIGxpYiQzLmRlZmluZVJlYWRPbmx5KSh0aGlzLCBcIndvcmRTaXplXCIsIHdvcmRTaXplIHx8IDMyKTtcblx0ICAgICAgICAoMCwgbGliJDMuZGVmaW5lUmVhZE9ubHkpKHRoaXMsIFwiX2NvZXJjZUZ1bmNcIiwgY29lcmNlRnVuYyk7XG5cdCAgICAgICAgKDAsIGxpYiQzLmRlZmluZVJlYWRPbmx5KSh0aGlzLCBcImFsbG93TG9vc2VcIiwgYWxsb3dMb29zZSk7XG5cdCAgICAgICAgdGhpcy5fb2Zmc2V0ID0gMDtcblx0ICAgIH1cblx0ICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShSZWFkZXIucHJvdG90eXBlLCBcImRhdGFcIiwge1xuXHQgICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gKDAsIGxpYiQxLmhleGxpZnkpKHRoaXMuX2RhdGEpOyB9LFxuXHQgICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuXHQgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuXHQgICAgfSk7XG5cdCAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoUmVhZGVyLnByb3RvdHlwZSwgXCJjb25zdW1lZFwiLCB7XG5cdCAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl9vZmZzZXQ7IH0sXG5cdCAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG5cdCAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG5cdCAgICB9KTtcblx0ICAgIC8vIFRoZSBkZWZhdWx0IENvZXJjZSBmdW5jdGlvblxuXHQgICAgUmVhZGVyLmNvZXJjZSA9IGZ1bmN0aW9uIChuYW1lLCB2YWx1ZSkge1xuXHQgICAgICAgIHZhciBtYXRjaCA9IG5hbWUubWF0Y2goXCJedT9pbnQoWzAtOV0rKSRcIik7XG5cdCAgICAgICAgaWYgKG1hdGNoICYmIHBhcnNlSW50KG1hdGNoWzFdKSA8PSA0OCkge1xuXHQgICAgICAgICAgICB2YWx1ZSA9IHZhbHVlLnRvTnVtYmVyKCk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHJldHVybiB2YWx1ZTtcblx0ICAgIH07XG5cdCAgICBSZWFkZXIucHJvdG90eXBlLmNvZXJjZSA9IGZ1bmN0aW9uIChuYW1lLCB2YWx1ZSkge1xuXHQgICAgICAgIGlmICh0aGlzLl9jb2VyY2VGdW5jKSB7XG5cdCAgICAgICAgICAgIHJldHVybiB0aGlzLl9jb2VyY2VGdW5jKG5hbWUsIHZhbHVlKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgcmV0dXJuIFJlYWRlci5jb2VyY2UobmFtZSwgdmFsdWUpO1xuXHQgICAgfTtcblx0ICAgIFJlYWRlci5wcm90b3R5cGUuX3BlZWtCeXRlcyA9IGZ1bmN0aW9uIChvZmZzZXQsIGxlbmd0aCwgbG9vc2UpIHtcblx0ICAgICAgICB2YXIgYWxpZ25lZExlbmd0aCA9IE1hdGguY2VpbChsZW5ndGggLyB0aGlzLndvcmRTaXplKSAqIHRoaXMud29yZFNpemU7XG5cdCAgICAgICAgaWYgKHRoaXMuX29mZnNldCArIGFsaWduZWRMZW5ndGggPiB0aGlzLl9kYXRhLmxlbmd0aCkge1xuXHQgICAgICAgICAgICBpZiAodGhpcy5hbGxvd0xvb3NlICYmIGxvb3NlICYmIHRoaXMuX29mZnNldCArIGxlbmd0aCA8PSB0aGlzLl9kYXRhLmxlbmd0aCkge1xuXHQgICAgICAgICAgICAgICAgYWxpZ25lZExlbmd0aCA9IGxlbmd0aDtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICBlbHNlIHtcblx0ICAgICAgICAgICAgICAgIGxvZ2dlci50aHJvd0Vycm9yKFwiZGF0YSBvdXQtb2YtYm91bmRzXCIsIGxpYi5Mb2dnZXIuZXJyb3JzLkJVRkZFUl9PVkVSUlVOLCB7XG5cdCAgICAgICAgICAgICAgICAgICAgbGVuZ3RoOiB0aGlzLl9kYXRhLmxlbmd0aCxcblx0ICAgICAgICAgICAgICAgICAgICBvZmZzZXQ6IHRoaXMuX29mZnNldCArIGFsaWduZWRMZW5ndGhcblx0ICAgICAgICAgICAgICAgIH0pO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHJldHVybiB0aGlzLl9kYXRhLnNsaWNlKHRoaXMuX29mZnNldCwgdGhpcy5fb2Zmc2V0ICsgYWxpZ25lZExlbmd0aCk7XG5cdCAgICB9O1xuXHQgICAgUmVhZGVyLnByb3RvdHlwZS5zdWJSZWFkZXIgPSBmdW5jdGlvbiAob2Zmc2V0KSB7XG5cdCAgICAgICAgcmV0dXJuIG5ldyBSZWFkZXIodGhpcy5fZGF0YS5zbGljZSh0aGlzLl9vZmZzZXQgKyBvZmZzZXQpLCB0aGlzLndvcmRTaXplLCB0aGlzLl9jb2VyY2VGdW5jLCB0aGlzLmFsbG93TG9vc2UpO1xuXHQgICAgfTtcblx0ICAgIFJlYWRlci5wcm90b3R5cGUucmVhZEJ5dGVzID0gZnVuY3Rpb24gKGxlbmd0aCwgbG9vc2UpIHtcblx0ICAgICAgICB2YXIgYnl0ZXMgPSB0aGlzLl9wZWVrQnl0ZXMoMCwgbGVuZ3RoLCAhIWxvb3NlKTtcblx0ICAgICAgICB0aGlzLl9vZmZzZXQgKz0gYnl0ZXMubGVuZ3RoO1xuXHQgICAgICAgIC8vIEBUT0RPOiBNYWtlIHN1cmUgdGhlIGxlbmd0aC4uZW5kIGJ5dGVzIGFyZSBhbGwgMD9cblx0ICAgICAgICByZXR1cm4gYnl0ZXMuc2xpY2UoMCwgbGVuZ3RoKTtcblx0ICAgIH07XG5cdCAgICBSZWFkZXIucHJvdG90eXBlLnJlYWRWYWx1ZSA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICByZXR1cm4gbGliJDIuQmlnTnVtYmVyLmZyb20odGhpcy5yZWFkQnl0ZXModGhpcy53b3JkU2l6ZSkpO1xuXHQgICAgfTtcblx0ICAgIHJldHVybiBSZWFkZXI7XG5cdH0oKSk7XG5cdGV4cG9ydHMuUmVhZGVyID0gUmVhZGVyO1xuXG5cdH0pO1xuXG5cdHZhciBhYnN0cmFjdENvZGVyJDEgPSAvKkBfX1BVUkVfXyovZ2V0RGVmYXVsdEV4cG9ydEZyb21DanMoYWJzdHJhY3RDb2Rlcik7XG5cblx0dmFyIHNoYTMgPSBjcmVhdGVDb21tb25qc01vZHVsZShmdW5jdGlvbiAobW9kdWxlKSB7XG5cdC8qKlxuXHQgKiBbanMtc2hhM117QGxpbmsgaHR0cHM6Ly9naXRodWIuY29tL2VtbjE3OC9qcy1zaGEzfVxuXHQgKlxuXHQgKiBAdmVyc2lvbiAwLjguMFxuXHQgKiBAYXV0aG9yIENoZW4sIFlpLUN5dWFuIFtlbW4xNzhAZ21haWwuY29tXVxuXHQgKiBAY29weXJpZ2h0IENoZW4sIFlpLUN5dWFuIDIwMTUtMjAxOFxuXHQgKiBAbGljZW5zZSBNSVRcblx0ICovXG5cdC8qanNsaW50IGJpdHdpc2U6IHRydWUgKi9cblx0KGZ1bmN0aW9uICgpIHtcblx0ICAndXNlIHN0cmljdCc7XG5cblx0ICB2YXIgSU5QVVRfRVJST1IgPSAnaW5wdXQgaXMgaW52YWxpZCB0eXBlJztcblx0ICB2YXIgRklOQUxJWkVfRVJST1IgPSAnZmluYWxpemUgYWxyZWFkeSBjYWxsZWQnO1xuXHQgIHZhciBXSU5ET1cgPSB0eXBlb2Ygd2luZG93ID09PSAnb2JqZWN0Jztcblx0ICB2YXIgcm9vdCA9IFdJTkRPVyA/IHdpbmRvdyA6IHt9O1xuXHQgIGlmIChyb290LkpTX1NIQTNfTk9fV0lORE9XKSB7XG5cdCAgICBXSU5ET1cgPSBmYWxzZTtcblx0ICB9XG5cdCAgdmFyIFdFQl9XT1JLRVIgPSAhV0lORE9XICYmIHR5cGVvZiBzZWxmID09PSAnb2JqZWN0Jztcblx0ICB2YXIgTk9ERV9KUyA9ICFyb290LkpTX1NIQTNfTk9fTk9ERV9KUyAmJiB0eXBlb2YgcHJvY2VzcyA9PT0gJ29iamVjdCcgJiYgcHJvY2Vzcy52ZXJzaW9ucyAmJiBwcm9jZXNzLnZlcnNpb25zLm5vZGU7XG5cdCAgaWYgKE5PREVfSlMpIHtcblx0ICAgIHJvb3QgPSBjb21tb25qc0dsb2JhbDtcblx0ICB9IGVsc2UgaWYgKFdFQl9XT1JLRVIpIHtcblx0ICAgIHJvb3QgPSBzZWxmO1xuXHQgIH1cblx0ICB2YXIgQ09NTU9OX0pTID0gIXJvb3QuSlNfU0hBM19OT19DT01NT05fSlMgJiYgJ29iamVjdCcgPT09ICdvYmplY3QnICYmIG1vZHVsZS5leHBvcnRzO1xuXHQgIHZhciBBTUQgPSB0eXBlb2YgdW5kZWZpbmVkID09PSAnZnVuY3Rpb24nICYmIHVuZGVmaW5lZC5hbWQ7XG5cdCAgdmFyIEFSUkFZX0JVRkZFUiA9ICFyb290LkpTX1NIQTNfTk9fQVJSQVlfQlVGRkVSICYmIHR5cGVvZiBBcnJheUJ1ZmZlciAhPT0gJ3VuZGVmaW5lZCc7XG5cdCAgdmFyIEhFWF9DSEFSUyA9ICcwMTIzNDU2Nzg5YWJjZGVmJy5zcGxpdCgnJyk7XG5cdCAgdmFyIFNIQUtFX1BBRERJTkcgPSBbMzEsIDc5MzYsIDIwMzE2MTYsIDUyMDA5MzY5Nl07XG5cdCAgdmFyIENTSEFLRV9QQURESU5HID0gWzQsIDEwMjQsIDI2MjE0NCwgNjcxMDg4NjRdO1xuXHQgIHZhciBLRUNDQUtfUEFERElORyA9IFsxLCAyNTYsIDY1NTM2LCAxNjc3NzIxNl07XG5cdCAgdmFyIFBBRERJTkcgPSBbNiwgMTUzNiwgMzkzMjE2LCAxMDA2NjMyOTZdO1xuXHQgIHZhciBTSElGVCA9IFswLCA4LCAxNiwgMjRdO1xuXHQgIHZhciBSQyA9IFsxLCAwLCAzMjg5OCwgMCwgMzI5MDYsIDIxNDc0ODM2NDgsIDIxNDc1MTY0MTYsIDIxNDc0ODM2NDgsIDMyOTA3LCAwLCAyMTQ3NDgzNjQ5LFxuXHQgICAgMCwgMjE0NzUxNjU0NSwgMjE0NzQ4MzY0OCwgMzI3NzcsIDIxNDc0ODM2NDgsIDEzOCwgMCwgMTM2LCAwLCAyMTQ3NTE2NDI1LCAwLFxuXHQgICAgMjE0NzQ4MzY1OCwgMCwgMjE0NzUxNjU1NSwgMCwgMTM5LCAyMTQ3NDgzNjQ4LCAzMjkwNSwgMjE0NzQ4MzY0OCwgMzI3NzEsXG5cdCAgICAyMTQ3NDgzNjQ4LCAzMjc3MCwgMjE0NzQ4MzY0OCwgMTI4LCAyMTQ3NDgzNjQ4LCAzMjc3OCwgMCwgMjE0NzQ4MzY1OCwgMjE0NzQ4MzY0OCxcblx0ICAgIDIxNDc1MTY1NDUsIDIxNDc0ODM2NDgsIDMyODk2LCAyMTQ3NDgzNjQ4LCAyMTQ3NDgzNjQ5LCAwLCAyMTQ3NTE2NDI0LCAyMTQ3NDgzNjQ4XTtcblx0ICB2YXIgQklUUyA9IFsyMjQsIDI1NiwgMzg0LCA1MTJdO1xuXHQgIHZhciBTSEFLRV9CSVRTID0gWzEyOCwgMjU2XTtcblx0ICB2YXIgT1VUUFVUX1RZUEVTID0gWydoZXgnLCAnYnVmZmVyJywgJ2FycmF5QnVmZmVyJywgJ2FycmF5JywgJ2RpZ2VzdCddO1xuXHQgIHZhciBDU0hBS0VfQllURVBBRCA9IHtcblx0ICAgICcxMjgnOiAxNjgsXG5cdCAgICAnMjU2JzogMTM2XG5cdCAgfTtcblxuXHQgIGlmIChyb290LkpTX1NIQTNfTk9fTk9ERV9KUyB8fCAhQXJyYXkuaXNBcnJheSkge1xuXHQgICAgQXJyYXkuaXNBcnJheSA9IGZ1bmN0aW9uIChvYmopIHtcblx0ICAgICAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvYmopID09PSAnW29iamVjdCBBcnJheV0nO1xuXHQgICAgfTtcblx0ICB9XG5cblx0ICBpZiAoQVJSQVlfQlVGRkVSICYmIChyb290LkpTX1NIQTNfTk9fQVJSQVlfQlVGRkVSX0lTX1ZJRVcgfHwgIUFycmF5QnVmZmVyLmlzVmlldykpIHtcblx0ICAgIEFycmF5QnVmZmVyLmlzVmlldyA9IGZ1bmN0aW9uIChvYmopIHtcblx0ICAgICAgcmV0dXJuIHR5cGVvZiBvYmogPT09ICdvYmplY3QnICYmIG9iai5idWZmZXIgJiYgb2JqLmJ1ZmZlci5jb25zdHJ1Y3RvciA9PT0gQXJyYXlCdWZmZXI7XG5cdCAgICB9O1xuXHQgIH1cblxuXHQgIHZhciBjcmVhdGVPdXRwdXRNZXRob2QgPSBmdW5jdGlvbiAoYml0cywgcGFkZGluZywgb3V0cHV0VHlwZSkge1xuXHQgICAgcmV0dXJuIGZ1bmN0aW9uIChtZXNzYWdlKSB7XG5cdCAgICAgIHJldHVybiBuZXcgS2VjY2FrKGJpdHMsIHBhZGRpbmcsIGJpdHMpLnVwZGF0ZShtZXNzYWdlKVtvdXRwdXRUeXBlXSgpO1xuXHQgICAgfTtcblx0ICB9O1xuXG5cdCAgdmFyIGNyZWF0ZVNoYWtlT3V0cHV0TWV0aG9kID0gZnVuY3Rpb24gKGJpdHMsIHBhZGRpbmcsIG91dHB1dFR5cGUpIHtcblx0ICAgIHJldHVybiBmdW5jdGlvbiAobWVzc2FnZSwgb3V0cHV0Qml0cykge1xuXHQgICAgICByZXR1cm4gbmV3IEtlY2NhayhiaXRzLCBwYWRkaW5nLCBvdXRwdXRCaXRzKS51cGRhdGUobWVzc2FnZSlbb3V0cHV0VHlwZV0oKTtcblx0ICAgIH07XG5cdCAgfTtcblxuXHQgIHZhciBjcmVhdGVDc2hha2VPdXRwdXRNZXRob2QgPSBmdW5jdGlvbiAoYml0cywgcGFkZGluZywgb3V0cHV0VHlwZSkge1xuXHQgICAgcmV0dXJuIGZ1bmN0aW9uIChtZXNzYWdlLCBvdXRwdXRCaXRzLCBuLCBzKSB7XG5cdCAgICAgIHJldHVybiBtZXRob2RzWydjc2hha2UnICsgYml0c10udXBkYXRlKG1lc3NhZ2UsIG91dHB1dEJpdHMsIG4sIHMpW291dHB1dFR5cGVdKCk7XG5cdCAgICB9O1xuXHQgIH07XG5cblx0ICB2YXIgY3JlYXRlS21hY091dHB1dE1ldGhvZCA9IGZ1bmN0aW9uIChiaXRzLCBwYWRkaW5nLCBvdXRwdXRUeXBlKSB7XG5cdCAgICByZXR1cm4gZnVuY3Rpb24gKGtleSwgbWVzc2FnZSwgb3V0cHV0Qml0cywgcykge1xuXHQgICAgICByZXR1cm4gbWV0aG9kc1sna21hYycgKyBiaXRzXS51cGRhdGUoa2V5LCBtZXNzYWdlLCBvdXRwdXRCaXRzLCBzKVtvdXRwdXRUeXBlXSgpO1xuXHQgICAgfTtcblx0ICB9O1xuXG5cdCAgdmFyIGNyZWF0ZU91dHB1dE1ldGhvZHMgPSBmdW5jdGlvbiAobWV0aG9kLCBjcmVhdGVNZXRob2QsIGJpdHMsIHBhZGRpbmcpIHtcblx0ICAgIGZvciAodmFyIGkgPSAwOyBpIDwgT1VUUFVUX1RZUEVTLmxlbmd0aDsgKytpKSB7XG5cdCAgICAgIHZhciB0eXBlID0gT1VUUFVUX1RZUEVTW2ldO1xuXHQgICAgICBtZXRob2RbdHlwZV0gPSBjcmVhdGVNZXRob2QoYml0cywgcGFkZGluZywgdHlwZSk7XG5cdCAgICB9XG5cdCAgICByZXR1cm4gbWV0aG9kO1xuXHQgIH07XG5cblx0ICB2YXIgY3JlYXRlTWV0aG9kID0gZnVuY3Rpb24gKGJpdHMsIHBhZGRpbmcpIHtcblx0ICAgIHZhciBtZXRob2QgPSBjcmVhdGVPdXRwdXRNZXRob2QoYml0cywgcGFkZGluZywgJ2hleCcpO1xuXHQgICAgbWV0aG9kLmNyZWF0ZSA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgcmV0dXJuIG5ldyBLZWNjYWsoYml0cywgcGFkZGluZywgYml0cyk7XG5cdCAgICB9O1xuXHQgICAgbWV0aG9kLnVwZGF0ZSA9IGZ1bmN0aW9uIChtZXNzYWdlKSB7XG5cdCAgICAgIHJldHVybiBtZXRob2QuY3JlYXRlKCkudXBkYXRlKG1lc3NhZ2UpO1xuXHQgICAgfTtcblx0ICAgIHJldHVybiBjcmVhdGVPdXRwdXRNZXRob2RzKG1ldGhvZCwgY3JlYXRlT3V0cHV0TWV0aG9kLCBiaXRzLCBwYWRkaW5nKTtcblx0ICB9O1xuXG5cdCAgdmFyIGNyZWF0ZVNoYWtlTWV0aG9kID0gZnVuY3Rpb24gKGJpdHMsIHBhZGRpbmcpIHtcblx0ICAgIHZhciBtZXRob2QgPSBjcmVhdGVTaGFrZU91dHB1dE1ldGhvZChiaXRzLCBwYWRkaW5nLCAnaGV4Jyk7XG5cdCAgICBtZXRob2QuY3JlYXRlID0gZnVuY3Rpb24gKG91dHB1dEJpdHMpIHtcblx0ICAgICAgcmV0dXJuIG5ldyBLZWNjYWsoYml0cywgcGFkZGluZywgb3V0cHV0Qml0cyk7XG5cdCAgICB9O1xuXHQgICAgbWV0aG9kLnVwZGF0ZSA9IGZ1bmN0aW9uIChtZXNzYWdlLCBvdXRwdXRCaXRzKSB7XG5cdCAgICAgIHJldHVybiBtZXRob2QuY3JlYXRlKG91dHB1dEJpdHMpLnVwZGF0ZShtZXNzYWdlKTtcblx0ICAgIH07XG5cdCAgICByZXR1cm4gY3JlYXRlT3V0cHV0TWV0aG9kcyhtZXRob2QsIGNyZWF0ZVNoYWtlT3V0cHV0TWV0aG9kLCBiaXRzLCBwYWRkaW5nKTtcblx0ICB9O1xuXG5cdCAgdmFyIGNyZWF0ZUNzaGFrZU1ldGhvZCA9IGZ1bmN0aW9uIChiaXRzLCBwYWRkaW5nKSB7XG5cdCAgICB2YXIgdyA9IENTSEFLRV9CWVRFUEFEW2JpdHNdO1xuXHQgICAgdmFyIG1ldGhvZCA9IGNyZWF0ZUNzaGFrZU91dHB1dE1ldGhvZChiaXRzLCBwYWRkaW5nLCAnaGV4Jyk7XG5cdCAgICBtZXRob2QuY3JlYXRlID0gZnVuY3Rpb24gKG91dHB1dEJpdHMsIG4sIHMpIHtcblx0ICAgICAgaWYgKCFuICYmICFzKSB7XG5cdCAgICAgICAgcmV0dXJuIG1ldGhvZHNbJ3NoYWtlJyArIGJpdHNdLmNyZWF0ZShvdXRwdXRCaXRzKTtcblx0ICAgICAgfSBlbHNlIHtcblx0ICAgICAgICByZXR1cm4gbmV3IEtlY2NhayhiaXRzLCBwYWRkaW5nLCBvdXRwdXRCaXRzKS5ieXRlcGFkKFtuLCBzXSwgdyk7XG5cdCAgICAgIH1cblx0ICAgIH07XG5cdCAgICBtZXRob2QudXBkYXRlID0gZnVuY3Rpb24gKG1lc3NhZ2UsIG91dHB1dEJpdHMsIG4sIHMpIHtcblx0ICAgICAgcmV0dXJuIG1ldGhvZC5jcmVhdGUob3V0cHV0Qml0cywgbiwgcykudXBkYXRlKG1lc3NhZ2UpO1xuXHQgICAgfTtcblx0ICAgIHJldHVybiBjcmVhdGVPdXRwdXRNZXRob2RzKG1ldGhvZCwgY3JlYXRlQ3NoYWtlT3V0cHV0TWV0aG9kLCBiaXRzLCBwYWRkaW5nKTtcblx0ICB9O1xuXG5cdCAgdmFyIGNyZWF0ZUttYWNNZXRob2QgPSBmdW5jdGlvbiAoYml0cywgcGFkZGluZykge1xuXHQgICAgdmFyIHcgPSBDU0hBS0VfQllURVBBRFtiaXRzXTtcblx0ICAgIHZhciBtZXRob2QgPSBjcmVhdGVLbWFjT3V0cHV0TWV0aG9kKGJpdHMsIHBhZGRpbmcsICdoZXgnKTtcblx0ICAgIG1ldGhvZC5jcmVhdGUgPSBmdW5jdGlvbiAoa2V5LCBvdXRwdXRCaXRzLCBzKSB7XG5cdCAgICAgIHJldHVybiBuZXcgS21hYyhiaXRzLCBwYWRkaW5nLCBvdXRwdXRCaXRzKS5ieXRlcGFkKFsnS01BQycsIHNdLCB3KS5ieXRlcGFkKFtrZXldLCB3KTtcblx0ICAgIH07XG5cdCAgICBtZXRob2QudXBkYXRlID0gZnVuY3Rpb24gKGtleSwgbWVzc2FnZSwgb3V0cHV0Qml0cywgcykge1xuXHQgICAgICByZXR1cm4gbWV0aG9kLmNyZWF0ZShrZXksIG91dHB1dEJpdHMsIHMpLnVwZGF0ZShtZXNzYWdlKTtcblx0ICAgIH07XG5cdCAgICByZXR1cm4gY3JlYXRlT3V0cHV0TWV0aG9kcyhtZXRob2QsIGNyZWF0ZUttYWNPdXRwdXRNZXRob2QsIGJpdHMsIHBhZGRpbmcpO1xuXHQgIH07XG5cblx0ICB2YXIgYWxnb3JpdGhtcyA9IFtcblx0ICAgIHsgbmFtZTogJ2tlY2NhaycsIHBhZGRpbmc6IEtFQ0NBS19QQURESU5HLCBiaXRzOiBCSVRTLCBjcmVhdGVNZXRob2Q6IGNyZWF0ZU1ldGhvZCB9LFxuXHQgICAgeyBuYW1lOiAnc2hhMycsIHBhZGRpbmc6IFBBRERJTkcsIGJpdHM6IEJJVFMsIGNyZWF0ZU1ldGhvZDogY3JlYXRlTWV0aG9kIH0sXG5cdCAgICB7IG5hbWU6ICdzaGFrZScsIHBhZGRpbmc6IFNIQUtFX1BBRERJTkcsIGJpdHM6IFNIQUtFX0JJVFMsIGNyZWF0ZU1ldGhvZDogY3JlYXRlU2hha2VNZXRob2QgfSxcblx0ICAgIHsgbmFtZTogJ2NzaGFrZScsIHBhZGRpbmc6IENTSEFLRV9QQURESU5HLCBiaXRzOiBTSEFLRV9CSVRTLCBjcmVhdGVNZXRob2Q6IGNyZWF0ZUNzaGFrZU1ldGhvZCB9LFxuXHQgICAgeyBuYW1lOiAna21hYycsIHBhZGRpbmc6IENTSEFLRV9QQURESU5HLCBiaXRzOiBTSEFLRV9CSVRTLCBjcmVhdGVNZXRob2Q6IGNyZWF0ZUttYWNNZXRob2QgfVxuXHQgIF07XG5cblx0ICB2YXIgbWV0aG9kcyA9IHt9LCBtZXRob2ROYW1lcyA9IFtdO1xuXG5cdCAgZm9yICh2YXIgaSA9IDA7IGkgPCBhbGdvcml0aG1zLmxlbmd0aDsgKytpKSB7XG5cdCAgICB2YXIgYWxnb3JpdGhtID0gYWxnb3JpdGhtc1tpXTtcblx0ICAgIHZhciBiaXRzID0gYWxnb3JpdGhtLmJpdHM7XG5cdCAgICBmb3IgKHZhciBqID0gMDsgaiA8IGJpdHMubGVuZ3RoOyArK2opIHtcblx0ICAgICAgdmFyIG1ldGhvZE5hbWUgPSBhbGdvcml0aG0ubmFtZSArICdfJyArIGJpdHNbal07XG5cdCAgICAgIG1ldGhvZE5hbWVzLnB1c2gobWV0aG9kTmFtZSk7XG5cdCAgICAgIG1ldGhvZHNbbWV0aG9kTmFtZV0gPSBhbGdvcml0aG0uY3JlYXRlTWV0aG9kKGJpdHNbal0sIGFsZ29yaXRobS5wYWRkaW5nKTtcblx0ICAgICAgaWYgKGFsZ29yaXRobS5uYW1lICE9PSAnc2hhMycpIHtcblx0ICAgICAgICB2YXIgbmV3TWV0aG9kTmFtZSA9IGFsZ29yaXRobS5uYW1lICsgYml0c1tqXTtcblx0ICAgICAgICBtZXRob2ROYW1lcy5wdXNoKG5ld01ldGhvZE5hbWUpO1xuXHQgICAgICAgIG1ldGhvZHNbbmV3TWV0aG9kTmFtZV0gPSBtZXRob2RzW21ldGhvZE5hbWVdO1xuXHQgICAgICB9XG5cdCAgICB9XG5cdCAgfVxuXG5cdCAgZnVuY3Rpb24gS2VjY2FrKGJpdHMsIHBhZGRpbmcsIG91dHB1dEJpdHMpIHtcblx0ICAgIHRoaXMuYmxvY2tzID0gW107XG5cdCAgICB0aGlzLnMgPSBbXTtcblx0ICAgIHRoaXMucGFkZGluZyA9IHBhZGRpbmc7XG5cdCAgICB0aGlzLm91dHB1dEJpdHMgPSBvdXRwdXRCaXRzO1xuXHQgICAgdGhpcy5yZXNldCA9IHRydWU7XG5cdCAgICB0aGlzLmZpbmFsaXplZCA9IGZhbHNlO1xuXHQgICAgdGhpcy5ibG9jayA9IDA7XG5cdCAgICB0aGlzLnN0YXJ0ID0gMDtcblx0ICAgIHRoaXMuYmxvY2tDb3VudCA9ICgxNjAwIC0gKGJpdHMgPDwgMSkpID4+IDU7XG5cdCAgICB0aGlzLmJ5dGVDb3VudCA9IHRoaXMuYmxvY2tDb3VudCA8PCAyO1xuXHQgICAgdGhpcy5vdXRwdXRCbG9ja3MgPSBvdXRwdXRCaXRzID4+IDU7XG5cdCAgICB0aGlzLmV4dHJhQnl0ZXMgPSAob3V0cHV0Qml0cyAmIDMxKSA+PiAzO1xuXG5cdCAgICBmb3IgKHZhciBpID0gMDsgaSA8IDUwOyArK2kpIHtcblx0ICAgICAgdGhpcy5zW2ldID0gMDtcblx0ICAgIH1cblx0ICB9XG5cblx0ICBLZWNjYWsucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uIChtZXNzYWdlKSB7XG5cdCAgICBpZiAodGhpcy5maW5hbGl6ZWQpIHtcblx0ICAgICAgdGhyb3cgbmV3IEVycm9yKEZJTkFMSVpFX0VSUk9SKTtcblx0ICAgIH1cblx0ICAgIHZhciBub3RTdHJpbmcsIHR5cGUgPSB0eXBlb2YgbWVzc2FnZTtcblx0ICAgIGlmICh0eXBlICE9PSAnc3RyaW5nJykge1xuXHQgICAgICBpZiAodHlwZSA9PT0gJ29iamVjdCcpIHtcblx0ICAgICAgICBpZiAobWVzc2FnZSA9PT0gbnVsbCkge1xuXHQgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKElOUFVUX0VSUk9SKTtcblx0ICAgICAgICB9IGVsc2UgaWYgKEFSUkFZX0JVRkZFUiAmJiBtZXNzYWdlLmNvbnN0cnVjdG9yID09PSBBcnJheUJ1ZmZlcikge1xuXHQgICAgICAgICAgbWVzc2FnZSA9IG5ldyBVaW50OEFycmF5KG1lc3NhZ2UpO1xuXHQgICAgICAgIH0gZWxzZSBpZiAoIUFycmF5LmlzQXJyYXkobWVzc2FnZSkpIHtcblx0ICAgICAgICAgIGlmICghQVJSQVlfQlVGRkVSIHx8ICFBcnJheUJ1ZmZlci5pc1ZpZXcobWVzc2FnZSkpIHtcblx0ICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKElOUFVUX0VSUk9SKTtcblx0ICAgICAgICAgIH1cblx0ICAgICAgICB9XG5cdCAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgdGhyb3cgbmV3IEVycm9yKElOUFVUX0VSUk9SKTtcblx0ICAgICAgfVxuXHQgICAgICBub3RTdHJpbmcgPSB0cnVlO1xuXHQgICAgfVxuXHQgICAgdmFyIGJsb2NrcyA9IHRoaXMuYmxvY2tzLCBieXRlQ291bnQgPSB0aGlzLmJ5dGVDb3VudCwgbGVuZ3RoID0gbWVzc2FnZS5sZW5ndGgsXG5cdCAgICAgIGJsb2NrQ291bnQgPSB0aGlzLmJsb2NrQ291bnQsIGluZGV4ID0gMCwgcyA9IHRoaXMucywgaSwgY29kZTtcblxuXHQgICAgd2hpbGUgKGluZGV4IDwgbGVuZ3RoKSB7XG5cdCAgICAgIGlmICh0aGlzLnJlc2V0KSB7XG5cdCAgICAgICAgdGhpcy5yZXNldCA9IGZhbHNlO1xuXHQgICAgICAgIGJsb2Nrc1swXSA9IHRoaXMuYmxvY2s7XG5cdCAgICAgICAgZm9yIChpID0gMTsgaSA8IGJsb2NrQ291bnQgKyAxOyArK2kpIHtcblx0ICAgICAgICAgIGJsb2Nrc1tpXSA9IDA7XG5cdCAgICAgICAgfVxuXHQgICAgICB9XG5cdCAgICAgIGlmIChub3RTdHJpbmcpIHtcblx0ICAgICAgICBmb3IgKGkgPSB0aGlzLnN0YXJ0OyBpbmRleCA8IGxlbmd0aCAmJiBpIDwgYnl0ZUNvdW50OyArK2luZGV4KSB7XG5cdCAgICAgICAgICBibG9ja3NbaSA+PiAyXSB8PSBtZXNzYWdlW2luZGV4XSA8PCBTSElGVFtpKysgJiAzXTtcblx0ICAgICAgICB9XG5cdCAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgZm9yIChpID0gdGhpcy5zdGFydDsgaW5kZXggPCBsZW5ndGggJiYgaSA8IGJ5dGVDb3VudDsgKytpbmRleCkge1xuXHQgICAgICAgICAgY29kZSA9IG1lc3NhZ2UuY2hhckNvZGVBdChpbmRleCk7XG5cdCAgICAgICAgICBpZiAoY29kZSA8IDB4ODApIHtcblx0ICAgICAgICAgICAgYmxvY2tzW2kgPj4gMl0gfD0gY29kZSA8PCBTSElGVFtpKysgJiAzXTtcblx0ICAgICAgICAgIH0gZWxzZSBpZiAoY29kZSA8IDB4ODAwKSB7XG5cdCAgICAgICAgICAgIGJsb2Nrc1tpID4+IDJdIHw9ICgweGMwIHwgKGNvZGUgPj4gNikpIDw8IFNISUZUW2krKyAmIDNdO1xuXHQgICAgICAgICAgICBibG9ja3NbaSA+PiAyXSB8PSAoMHg4MCB8IChjb2RlICYgMHgzZikpIDw8IFNISUZUW2krKyAmIDNdO1xuXHQgICAgICAgICAgfSBlbHNlIGlmIChjb2RlIDwgMHhkODAwIHx8IGNvZGUgPj0gMHhlMDAwKSB7XG5cdCAgICAgICAgICAgIGJsb2Nrc1tpID4+IDJdIHw9ICgweGUwIHwgKGNvZGUgPj4gMTIpKSA8PCBTSElGVFtpKysgJiAzXTtcblx0ICAgICAgICAgICAgYmxvY2tzW2kgPj4gMl0gfD0gKDB4ODAgfCAoKGNvZGUgPj4gNikgJiAweDNmKSkgPDwgU0hJRlRbaSsrICYgM107XG5cdCAgICAgICAgICAgIGJsb2Nrc1tpID4+IDJdIHw9ICgweDgwIHwgKGNvZGUgJiAweDNmKSkgPDwgU0hJRlRbaSsrICYgM107XG5cdCAgICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgICBjb2RlID0gMHgxMDAwMCArICgoKGNvZGUgJiAweDNmZikgPDwgMTApIHwgKG1lc3NhZ2UuY2hhckNvZGVBdCgrK2luZGV4KSAmIDB4M2ZmKSk7XG5cdCAgICAgICAgICAgIGJsb2Nrc1tpID4+IDJdIHw9ICgweGYwIHwgKGNvZGUgPj4gMTgpKSA8PCBTSElGVFtpKysgJiAzXTtcblx0ICAgICAgICAgICAgYmxvY2tzW2kgPj4gMl0gfD0gKDB4ODAgfCAoKGNvZGUgPj4gMTIpICYgMHgzZikpIDw8IFNISUZUW2krKyAmIDNdO1xuXHQgICAgICAgICAgICBibG9ja3NbaSA+PiAyXSB8PSAoMHg4MCB8ICgoY29kZSA+PiA2KSAmIDB4M2YpKSA8PCBTSElGVFtpKysgJiAzXTtcblx0ICAgICAgICAgICAgYmxvY2tzW2kgPj4gMl0gfD0gKDB4ODAgfCAoY29kZSAmIDB4M2YpKSA8PCBTSElGVFtpKysgJiAzXTtcblx0ICAgICAgICAgIH1cblx0ICAgICAgICB9XG5cdCAgICAgIH1cblx0ICAgICAgdGhpcy5sYXN0Qnl0ZUluZGV4ID0gaTtcblx0ICAgICAgaWYgKGkgPj0gYnl0ZUNvdW50KSB7XG5cdCAgICAgICAgdGhpcy5zdGFydCA9IGkgLSBieXRlQ291bnQ7XG5cdCAgICAgICAgdGhpcy5ibG9jayA9IGJsb2Nrc1tibG9ja0NvdW50XTtcblx0ICAgICAgICBmb3IgKGkgPSAwOyBpIDwgYmxvY2tDb3VudDsgKytpKSB7XG5cdCAgICAgICAgICBzW2ldIF49IGJsb2Nrc1tpXTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgZihzKTtcblx0ICAgICAgICB0aGlzLnJlc2V0ID0gdHJ1ZTtcblx0ICAgICAgfSBlbHNlIHtcblx0ICAgICAgICB0aGlzLnN0YXJ0ID0gaTtcblx0ICAgICAgfVxuXHQgICAgfVxuXHQgICAgcmV0dXJuIHRoaXM7XG5cdCAgfTtcblxuXHQgIEtlY2Nhay5wcm90b3R5cGUuZW5jb2RlID0gZnVuY3Rpb24gKHgsIHJpZ2h0KSB7XG5cdCAgICB2YXIgbyA9IHggJiAyNTUsIG4gPSAxO1xuXHQgICAgdmFyIGJ5dGVzID0gW29dO1xuXHQgICAgeCA9IHggPj4gODtcblx0ICAgIG8gPSB4ICYgMjU1O1xuXHQgICAgd2hpbGUgKG8gPiAwKSB7XG5cdCAgICAgIGJ5dGVzLnVuc2hpZnQobyk7XG5cdCAgICAgIHggPSB4ID4+IDg7XG5cdCAgICAgIG8gPSB4ICYgMjU1O1xuXHQgICAgICArK247XG5cdCAgICB9XG5cdCAgICBpZiAocmlnaHQpIHtcblx0ICAgICAgYnl0ZXMucHVzaChuKTtcblx0ICAgIH0gZWxzZSB7XG5cdCAgICAgIGJ5dGVzLnVuc2hpZnQobik7XG5cdCAgICB9XG5cdCAgICB0aGlzLnVwZGF0ZShieXRlcyk7XG5cdCAgICByZXR1cm4gYnl0ZXMubGVuZ3RoO1xuXHQgIH07XG5cblx0ICBLZWNjYWsucHJvdG90eXBlLmVuY29kZVN0cmluZyA9IGZ1bmN0aW9uIChzdHIpIHtcblx0ICAgIHZhciBub3RTdHJpbmcsIHR5cGUgPSB0eXBlb2Ygc3RyO1xuXHQgICAgaWYgKHR5cGUgIT09ICdzdHJpbmcnKSB7XG5cdCAgICAgIGlmICh0eXBlID09PSAnb2JqZWN0Jykge1xuXHQgICAgICAgIGlmIChzdHIgPT09IG51bGwpIHtcblx0ICAgICAgICAgIHRocm93IG5ldyBFcnJvcihJTlBVVF9FUlJPUik7XG5cdCAgICAgICAgfSBlbHNlIGlmIChBUlJBWV9CVUZGRVIgJiYgc3RyLmNvbnN0cnVjdG9yID09PSBBcnJheUJ1ZmZlcikge1xuXHQgICAgICAgICAgc3RyID0gbmV3IFVpbnQ4QXJyYXkoc3RyKTtcblx0ICAgICAgICB9IGVsc2UgaWYgKCFBcnJheS5pc0FycmF5KHN0cikpIHtcblx0ICAgICAgICAgIGlmICghQVJSQVlfQlVGRkVSIHx8ICFBcnJheUJ1ZmZlci5pc1ZpZXcoc3RyKSkge1xuXHQgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoSU5QVVRfRVJST1IpO1xuXHQgICAgICAgICAgfVxuXHQgICAgICAgIH1cblx0ICAgICAgfSBlbHNlIHtcblx0ICAgICAgICB0aHJvdyBuZXcgRXJyb3IoSU5QVVRfRVJST1IpO1xuXHQgICAgICB9XG5cdCAgICAgIG5vdFN0cmluZyA9IHRydWU7XG5cdCAgICB9XG5cdCAgICB2YXIgYnl0ZXMgPSAwLCBsZW5ndGggPSBzdHIubGVuZ3RoO1xuXHQgICAgaWYgKG5vdFN0cmluZykge1xuXHQgICAgICBieXRlcyA9IGxlbmd0aDtcblx0ICAgIH0gZWxzZSB7XG5cdCAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgKytpKSB7XG5cdCAgICAgICAgdmFyIGNvZGUgPSBzdHIuY2hhckNvZGVBdChpKTtcblx0ICAgICAgICBpZiAoY29kZSA8IDB4ODApIHtcblx0ICAgICAgICAgIGJ5dGVzICs9IDE7XG5cdCAgICAgICAgfSBlbHNlIGlmIChjb2RlIDwgMHg4MDApIHtcblx0ICAgICAgICAgIGJ5dGVzICs9IDI7XG5cdCAgICAgICAgfSBlbHNlIGlmIChjb2RlIDwgMHhkODAwIHx8IGNvZGUgPj0gMHhlMDAwKSB7XG5cdCAgICAgICAgICBieXRlcyArPSAzO1xuXHQgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICBjb2RlID0gMHgxMDAwMCArICgoKGNvZGUgJiAweDNmZikgPDwgMTApIHwgKHN0ci5jaGFyQ29kZUF0KCsraSkgJiAweDNmZikpO1xuXHQgICAgICAgICAgYnl0ZXMgKz0gNDtcblx0ICAgICAgICB9XG5cdCAgICAgIH1cblx0ICAgIH1cblx0ICAgIGJ5dGVzICs9IHRoaXMuZW5jb2RlKGJ5dGVzICogOCk7XG5cdCAgICB0aGlzLnVwZGF0ZShzdHIpO1xuXHQgICAgcmV0dXJuIGJ5dGVzO1xuXHQgIH07XG5cblx0ICBLZWNjYWsucHJvdG90eXBlLmJ5dGVwYWQgPSBmdW5jdGlvbiAoc3Rycywgdykge1xuXHQgICAgdmFyIGJ5dGVzID0gdGhpcy5lbmNvZGUodyk7XG5cdCAgICBmb3IgKHZhciBpID0gMDsgaSA8IHN0cnMubGVuZ3RoOyArK2kpIHtcblx0ICAgICAgYnl0ZXMgKz0gdGhpcy5lbmNvZGVTdHJpbmcoc3Ryc1tpXSk7XG5cdCAgICB9XG5cdCAgICB2YXIgcGFkZGluZ0J5dGVzID0gdyAtIGJ5dGVzICUgdztcblx0ICAgIHZhciB6ZXJvcyA9IFtdO1xuXHQgICAgemVyb3MubGVuZ3RoID0gcGFkZGluZ0J5dGVzO1xuXHQgICAgdGhpcy51cGRhdGUoemVyb3MpO1xuXHQgICAgcmV0dXJuIHRoaXM7XG5cdCAgfTtcblxuXHQgIEtlY2Nhay5wcm90b3R5cGUuZmluYWxpemUgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICBpZiAodGhpcy5maW5hbGl6ZWQpIHtcblx0ICAgICAgcmV0dXJuO1xuXHQgICAgfVxuXHQgICAgdGhpcy5maW5hbGl6ZWQgPSB0cnVlO1xuXHQgICAgdmFyIGJsb2NrcyA9IHRoaXMuYmxvY2tzLCBpID0gdGhpcy5sYXN0Qnl0ZUluZGV4LCBibG9ja0NvdW50ID0gdGhpcy5ibG9ja0NvdW50LCBzID0gdGhpcy5zO1xuXHQgICAgYmxvY2tzW2kgPj4gMl0gfD0gdGhpcy5wYWRkaW5nW2kgJiAzXTtcblx0ICAgIGlmICh0aGlzLmxhc3RCeXRlSW5kZXggPT09IHRoaXMuYnl0ZUNvdW50KSB7XG5cdCAgICAgIGJsb2Nrc1swXSA9IGJsb2Nrc1tibG9ja0NvdW50XTtcblx0ICAgICAgZm9yIChpID0gMTsgaSA8IGJsb2NrQ291bnQgKyAxOyArK2kpIHtcblx0ICAgICAgICBibG9ja3NbaV0gPSAwO1xuXHQgICAgICB9XG5cdCAgICB9XG5cdCAgICBibG9ja3NbYmxvY2tDb3VudCAtIDFdIHw9IDB4ODAwMDAwMDA7XG5cdCAgICBmb3IgKGkgPSAwOyBpIDwgYmxvY2tDb3VudDsgKytpKSB7XG5cdCAgICAgIHNbaV0gXj0gYmxvY2tzW2ldO1xuXHQgICAgfVxuXHQgICAgZihzKTtcblx0ICB9O1xuXG5cdCAgS2VjY2FrLnByb3RvdHlwZS50b1N0cmluZyA9IEtlY2Nhay5wcm90b3R5cGUuaGV4ID0gZnVuY3Rpb24gKCkge1xuXHQgICAgdGhpcy5maW5hbGl6ZSgpO1xuXG5cdCAgICB2YXIgYmxvY2tDb3VudCA9IHRoaXMuYmxvY2tDb3VudCwgcyA9IHRoaXMucywgb3V0cHV0QmxvY2tzID0gdGhpcy5vdXRwdXRCbG9ja3MsXG5cdCAgICAgIGV4dHJhQnl0ZXMgPSB0aGlzLmV4dHJhQnl0ZXMsIGkgPSAwLCBqID0gMDtcblx0ICAgIHZhciBoZXggPSAnJywgYmxvY2s7XG5cdCAgICB3aGlsZSAoaiA8IG91dHB1dEJsb2Nrcykge1xuXHQgICAgICBmb3IgKGkgPSAwOyBpIDwgYmxvY2tDb3VudCAmJiBqIDwgb3V0cHV0QmxvY2tzOyArK2ksICsraikge1xuXHQgICAgICAgIGJsb2NrID0gc1tpXTtcblx0ICAgICAgICBoZXggKz0gSEVYX0NIQVJTWyhibG9jayA+PiA0KSAmIDB4MEZdICsgSEVYX0NIQVJTW2Jsb2NrICYgMHgwRl0gK1xuXHQgICAgICAgICAgSEVYX0NIQVJTWyhibG9jayA+PiAxMikgJiAweDBGXSArIEhFWF9DSEFSU1soYmxvY2sgPj4gOCkgJiAweDBGXSArXG5cdCAgICAgICAgICBIRVhfQ0hBUlNbKGJsb2NrID4+IDIwKSAmIDB4MEZdICsgSEVYX0NIQVJTWyhibG9jayA+PiAxNikgJiAweDBGXSArXG5cdCAgICAgICAgICBIRVhfQ0hBUlNbKGJsb2NrID4+IDI4KSAmIDB4MEZdICsgSEVYX0NIQVJTWyhibG9jayA+PiAyNCkgJiAweDBGXTtcblx0ICAgICAgfVxuXHQgICAgICBpZiAoaiAlIGJsb2NrQ291bnQgPT09IDApIHtcblx0ICAgICAgICBmKHMpO1xuXHQgICAgICAgIGkgPSAwO1xuXHQgICAgICB9XG5cdCAgICB9XG5cdCAgICBpZiAoZXh0cmFCeXRlcykge1xuXHQgICAgICBibG9jayA9IHNbaV07XG5cdCAgICAgIGhleCArPSBIRVhfQ0hBUlNbKGJsb2NrID4+IDQpICYgMHgwRl0gKyBIRVhfQ0hBUlNbYmxvY2sgJiAweDBGXTtcblx0ICAgICAgaWYgKGV4dHJhQnl0ZXMgPiAxKSB7XG5cdCAgICAgICAgaGV4ICs9IEhFWF9DSEFSU1soYmxvY2sgPj4gMTIpICYgMHgwRl0gKyBIRVhfQ0hBUlNbKGJsb2NrID4+IDgpICYgMHgwRl07XG5cdCAgICAgIH1cblx0ICAgICAgaWYgKGV4dHJhQnl0ZXMgPiAyKSB7XG5cdCAgICAgICAgaGV4ICs9IEhFWF9DSEFSU1soYmxvY2sgPj4gMjApICYgMHgwRl0gKyBIRVhfQ0hBUlNbKGJsb2NrID4+IDE2KSAmIDB4MEZdO1xuXHQgICAgICB9XG5cdCAgICB9XG5cdCAgICByZXR1cm4gaGV4O1xuXHQgIH07XG5cblx0ICBLZWNjYWsucHJvdG90eXBlLmFycmF5QnVmZmVyID0gZnVuY3Rpb24gKCkge1xuXHQgICAgdGhpcy5maW5hbGl6ZSgpO1xuXG5cdCAgICB2YXIgYmxvY2tDb3VudCA9IHRoaXMuYmxvY2tDb3VudCwgcyA9IHRoaXMucywgb3V0cHV0QmxvY2tzID0gdGhpcy5vdXRwdXRCbG9ja3MsXG5cdCAgICAgIGV4dHJhQnl0ZXMgPSB0aGlzLmV4dHJhQnl0ZXMsIGkgPSAwLCBqID0gMDtcblx0ICAgIHZhciBieXRlcyA9IHRoaXMub3V0cHV0Qml0cyA+PiAzO1xuXHQgICAgdmFyIGJ1ZmZlcjtcblx0ICAgIGlmIChleHRyYUJ5dGVzKSB7XG5cdCAgICAgIGJ1ZmZlciA9IG5ldyBBcnJheUJ1ZmZlcigob3V0cHV0QmxvY2tzICsgMSkgPDwgMik7XG5cdCAgICB9IGVsc2Uge1xuXHQgICAgICBidWZmZXIgPSBuZXcgQXJyYXlCdWZmZXIoYnl0ZXMpO1xuXHQgICAgfVxuXHQgICAgdmFyIGFycmF5ID0gbmV3IFVpbnQzMkFycmF5KGJ1ZmZlcik7XG5cdCAgICB3aGlsZSAoaiA8IG91dHB1dEJsb2Nrcykge1xuXHQgICAgICBmb3IgKGkgPSAwOyBpIDwgYmxvY2tDb3VudCAmJiBqIDwgb3V0cHV0QmxvY2tzOyArK2ksICsraikge1xuXHQgICAgICAgIGFycmF5W2pdID0gc1tpXTtcblx0ICAgICAgfVxuXHQgICAgICBpZiAoaiAlIGJsb2NrQ291bnQgPT09IDApIHtcblx0ICAgICAgICBmKHMpO1xuXHQgICAgICB9XG5cdCAgICB9XG5cdCAgICBpZiAoZXh0cmFCeXRlcykge1xuXHQgICAgICBhcnJheVtpXSA9IHNbaV07XG5cdCAgICAgIGJ1ZmZlciA9IGJ1ZmZlci5zbGljZSgwLCBieXRlcyk7XG5cdCAgICB9XG5cdCAgICByZXR1cm4gYnVmZmVyO1xuXHQgIH07XG5cblx0ICBLZWNjYWsucHJvdG90eXBlLmJ1ZmZlciA9IEtlY2Nhay5wcm90b3R5cGUuYXJyYXlCdWZmZXI7XG5cblx0ICBLZWNjYWsucHJvdG90eXBlLmRpZ2VzdCA9IEtlY2Nhay5wcm90b3R5cGUuYXJyYXkgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICB0aGlzLmZpbmFsaXplKCk7XG5cblx0ICAgIHZhciBibG9ja0NvdW50ID0gdGhpcy5ibG9ja0NvdW50LCBzID0gdGhpcy5zLCBvdXRwdXRCbG9ja3MgPSB0aGlzLm91dHB1dEJsb2Nrcyxcblx0ICAgICAgZXh0cmFCeXRlcyA9IHRoaXMuZXh0cmFCeXRlcywgaSA9IDAsIGogPSAwO1xuXHQgICAgdmFyIGFycmF5ID0gW10sIG9mZnNldCwgYmxvY2s7XG5cdCAgICB3aGlsZSAoaiA8IG91dHB1dEJsb2Nrcykge1xuXHQgICAgICBmb3IgKGkgPSAwOyBpIDwgYmxvY2tDb3VudCAmJiBqIDwgb3V0cHV0QmxvY2tzOyArK2ksICsraikge1xuXHQgICAgICAgIG9mZnNldCA9IGogPDwgMjtcblx0ICAgICAgICBibG9jayA9IHNbaV07XG5cdCAgICAgICAgYXJyYXlbb2Zmc2V0XSA9IGJsb2NrICYgMHhGRjtcblx0ICAgICAgICBhcnJheVtvZmZzZXQgKyAxXSA9IChibG9jayA+PiA4KSAmIDB4RkY7XG5cdCAgICAgICAgYXJyYXlbb2Zmc2V0ICsgMl0gPSAoYmxvY2sgPj4gMTYpICYgMHhGRjtcblx0ICAgICAgICBhcnJheVtvZmZzZXQgKyAzXSA9IChibG9jayA+PiAyNCkgJiAweEZGO1xuXHQgICAgICB9XG5cdCAgICAgIGlmIChqICUgYmxvY2tDb3VudCA9PT0gMCkge1xuXHQgICAgICAgIGYocyk7XG5cdCAgICAgIH1cblx0ICAgIH1cblx0ICAgIGlmIChleHRyYUJ5dGVzKSB7XG5cdCAgICAgIG9mZnNldCA9IGogPDwgMjtcblx0ICAgICAgYmxvY2sgPSBzW2ldO1xuXHQgICAgICBhcnJheVtvZmZzZXRdID0gYmxvY2sgJiAweEZGO1xuXHQgICAgICBpZiAoZXh0cmFCeXRlcyA+IDEpIHtcblx0ICAgICAgICBhcnJheVtvZmZzZXQgKyAxXSA9IChibG9jayA+PiA4KSAmIDB4RkY7XG5cdCAgICAgIH1cblx0ICAgICAgaWYgKGV4dHJhQnl0ZXMgPiAyKSB7XG5cdCAgICAgICAgYXJyYXlbb2Zmc2V0ICsgMl0gPSAoYmxvY2sgPj4gMTYpICYgMHhGRjtcblx0ICAgICAgfVxuXHQgICAgfVxuXHQgICAgcmV0dXJuIGFycmF5O1xuXHQgIH07XG5cblx0ICBmdW5jdGlvbiBLbWFjKGJpdHMsIHBhZGRpbmcsIG91dHB1dEJpdHMpIHtcblx0ICAgIEtlY2Nhay5jYWxsKHRoaXMsIGJpdHMsIHBhZGRpbmcsIG91dHB1dEJpdHMpO1xuXHQgIH1cblxuXHQgIEttYWMucHJvdG90eXBlID0gbmV3IEtlY2NhaygpO1xuXG5cdCAgS21hYy5wcm90b3R5cGUuZmluYWxpemUgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICB0aGlzLmVuY29kZSh0aGlzLm91dHB1dEJpdHMsIHRydWUpO1xuXHQgICAgcmV0dXJuIEtlY2Nhay5wcm90b3R5cGUuZmluYWxpemUuY2FsbCh0aGlzKTtcblx0ICB9O1xuXG5cdCAgdmFyIGYgPSBmdW5jdGlvbiAocykge1xuXHQgICAgdmFyIGgsIGwsIG4sIGMwLCBjMSwgYzIsIGMzLCBjNCwgYzUsIGM2LCBjNywgYzgsIGM5LFxuXHQgICAgICBiMCwgYjEsIGIyLCBiMywgYjQsIGI1LCBiNiwgYjcsIGI4LCBiOSwgYjEwLCBiMTEsIGIxMiwgYjEzLCBiMTQsIGIxNSwgYjE2LCBiMTcsXG5cdCAgICAgIGIxOCwgYjE5LCBiMjAsIGIyMSwgYjIyLCBiMjMsIGIyNCwgYjI1LCBiMjYsIGIyNywgYjI4LCBiMjksIGIzMCwgYjMxLCBiMzIsIGIzMyxcblx0ICAgICAgYjM0LCBiMzUsIGIzNiwgYjM3LCBiMzgsIGIzOSwgYjQwLCBiNDEsIGI0MiwgYjQzLCBiNDQsIGI0NSwgYjQ2LCBiNDcsIGI0OCwgYjQ5O1xuXHQgICAgZm9yIChuID0gMDsgbiA8IDQ4OyBuICs9IDIpIHtcblx0ICAgICAgYzAgPSBzWzBdIF4gc1sxMF0gXiBzWzIwXSBeIHNbMzBdIF4gc1s0MF07XG5cdCAgICAgIGMxID0gc1sxXSBeIHNbMTFdIF4gc1syMV0gXiBzWzMxXSBeIHNbNDFdO1xuXHQgICAgICBjMiA9IHNbMl0gXiBzWzEyXSBeIHNbMjJdIF4gc1szMl0gXiBzWzQyXTtcblx0ICAgICAgYzMgPSBzWzNdIF4gc1sxM10gXiBzWzIzXSBeIHNbMzNdIF4gc1s0M107XG5cdCAgICAgIGM0ID0gc1s0XSBeIHNbMTRdIF4gc1syNF0gXiBzWzM0XSBeIHNbNDRdO1xuXHQgICAgICBjNSA9IHNbNV0gXiBzWzE1XSBeIHNbMjVdIF4gc1szNV0gXiBzWzQ1XTtcblx0ICAgICAgYzYgPSBzWzZdIF4gc1sxNl0gXiBzWzI2XSBeIHNbMzZdIF4gc1s0Nl07XG5cdCAgICAgIGM3ID0gc1s3XSBeIHNbMTddIF4gc1syN10gXiBzWzM3XSBeIHNbNDddO1xuXHQgICAgICBjOCA9IHNbOF0gXiBzWzE4XSBeIHNbMjhdIF4gc1szOF0gXiBzWzQ4XTtcblx0ICAgICAgYzkgPSBzWzldIF4gc1sxOV0gXiBzWzI5XSBeIHNbMzldIF4gc1s0OV07XG5cblx0ICAgICAgaCA9IGM4IF4gKChjMiA8PCAxKSB8IChjMyA+Pj4gMzEpKTtcblx0ICAgICAgbCA9IGM5IF4gKChjMyA8PCAxKSB8IChjMiA+Pj4gMzEpKTtcblx0ICAgICAgc1swXSBePSBoO1xuXHQgICAgICBzWzFdIF49IGw7XG5cdCAgICAgIHNbMTBdIF49IGg7XG5cdCAgICAgIHNbMTFdIF49IGw7XG5cdCAgICAgIHNbMjBdIF49IGg7XG5cdCAgICAgIHNbMjFdIF49IGw7XG5cdCAgICAgIHNbMzBdIF49IGg7XG5cdCAgICAgIHNbMzFdIF49IGw7XG5cdCAgICAgIHNbNDBdIF49IGg7XG5cdCAgICAgIHNbNDFdIF49IGw7XG5cdCAgICAgIGggPSBjMCBeICgoYzQgPDwgMSkgfCAoYzUgPj4+IDMxKSk7XG5cdCAgICAgIGwgPSBjMSBeICgoYzUgPDwgMSkgfCAoYzQgPj4+IDMxKSk7XG5cdCAgICAgIHNbMl0gXj0gaDtcblx0ICAgICAgc1szXSBePSBsO1xuXHQgICAgICBzWzEyXSBePSBoO1xuXHQgICAgICBzWzEzXSBePSBsO1xuXHQgICAgICBzWzIyXSBePSBoO1xuXHQgICAgICBzWzIzXSBePSBsO1xuXHQgICAgICBzWzMyXSBePSBoO1xuXHQgICAgICBzWzMzXSBePSBsO1xuXHQgICAgICBzWzQyXSBePSBoO1xuXHQgICAgICBzWzQzXSBePSBsO1xuXHQgICAgICBoID0gYzIgXiAoKGM2IDw8IDEpIHwgKGM3ID4+PiAzMSkpO1xuXHQgICAgICBsID0gYzMgXiAoKGM3IDw8IDEpIHwgKGM2ID4+PiAzMSkpO1xuXHQgICAgICBzWzRdIF49IGg7XG5cdCAgICAgIHNbNV0gXj0gbDtcblx0ICAgICAgc1sxNF0gXj0gaDtcblx0ICAgICAgc1sxNV0gXj0gbDtcblx0ICAgICAgc1syNF0gXj0gaDtcblx0ICAgICAgc1syNV0gXj0gbDtcblx0ICAgICAgc1szNF0gXj0gaDtcblx0ICAgICAgc1szNV0gXj0gbDtcblx0ICAgICAgc1s0NF0gXj0gaDtcblx0ICAgICAgc1s0NV0gXj0gbDtcblx0ICAgICAgaCA9IGM0IF4gKChjOCA8PCAxKSB8IChjOSA+Pj4gMzEpKTtcblx0ICAgICAgbCA9IGM1IF4gKChjOSA8PCAxKSB8IChjOCA+Pj4gMzEpKTtcblx0ICAgICAgc1s2XSBePSBoO1xuXHQgICAgICBzWzddIF49IGw7XG5cdCAgICAgIHNbMTZdIF49IGg7XG5cdCAgICAgIHNbMTddIF49IGw7XG5cdCAgICAgIHNbMjZdIF49IGg7XG5cdCAgICAgIHNbMjddIF49IGw7XG5cdCAgICAgIHNbMzZdIF49IGg7XG5cdCAgICAgIHNbMzddIF49IGw7XG5cdCAgICAgIHNbNDZdIF49IGg7XG5cdCAgICAgIHNbNDddIF49IGw7XG5cdCAgICAgIGggPSBjNiBeICgoYzAgPDwgMSkgfCAoYzEgPj4+IDMxKSk7XG5cdCAgICAgIGwgPSBjNyBeICgoYzEgPDwgMSkgfCAoYzAgPj4+IDMxKSk7XG5cdCAgICAgIHNbOF0gXj0gaDtcblx0ICAgICAgc1s5XSBePSBsO1xuXHQgICAgICBzWzE4XSBePSBoO1xuXHQgICAgICBzWzE5XSBePSBsO1xuXHQgICAgICBzWzI4XSBePSBoO1xuXHQgICAgICBzWzI5XSBePSBsO1xuXHQgICAgICBzWzM4XSBePSBoO1xuXHQgICAgICBzWzM5XSBePSBsO1xuXHQgICAgICBzWzQ4XSBePSBoO1xuXHQgICAgICBzWzQ5XSBePSBsO1xuXG5cdCAgICAgIGIwID0gc1swXTtcblx0ICAgICAgYjEgPSBzWzFdO1xuXHQgICAgICBiMzIgPSAoc1sxMV0gPDwgNCkgfCAoc1sxMF0gPj4+IDI4KTtcblx0ICAgICAgYjMzID0gKHNbMTBdIDw8IDQpIHwgKHNbMTFdID4+PiAyOCk7XG5cdCAgICAgIGIxNCA9IChzWzIwXSA8PCAzKSB8IChzWzIxXSA+Pj4gMjkpO1xuXHQgICAgICBiMTUgPSAoc1syMV0gPDwgMykgfCAoc1syMF0gPj4+IDI5KTtcblx0ICAgICAgYjQ2ID0gKHNbMzFdIDw8IDkpIHwgKHNbMzBdID4+PiAyMyk7XG5cdCAgICAgIGI0NyA9IChzWzMwXSA8PCA5KSB8IChzWzMxXSA+Pj4gMjMpO1xuXHQgICAgICBiMjggPSAoc1s0MF0gPDwgMTgpIHwgKHNbNDFdID4+PiAxNCk7XG5cdCAgICAgIGIyOSA9IChzWzQxXSA8PCAxOCkgfCAoc1s0MF0gPj4+IDE0KTtcblx0ICAgICAgYjIwID0gKHNbMl0gPDwgMSkgfCAoc1szXSA+Pj4gMzEpO1xuXHQgICAgICBiMjEgPSAoc1szXSA8PCAxKSB8IChzWzJdID4+PiAzMSk7XG5cdCAgICAgIGIyID0gKHNbMTNdIDw8IDEyKSB8IChzWzEyXSA+Pj4gMjApO1xuXHQgICAgICBiMyA9IChzWzEyXSA8PCAxMikgfCAoc1sxM10gPj4+IDIwKTtcblx0ICAgICAgYjM0ID0gKHNbMjJdIDw8IDEwKSB8IChzWzIzXSA+Pj4gMjIpO1xuXHQgICAgICBiMzUgPSAoc1syM10gPDwgMTApIHwgKHNbMjJdID4+PiAyMik7XG5cdCAgICAgIGIxNiA9IChzWzMzXSA8PCAxMykgfCAoc1szMl0gPj4+IDE5KTtcblx0ICAgICAgYjE3ID0gKHNbMzJdIDw8IDEzKSB8IChzWzMzXSA+Pj4gMTkpO1xuXHQgICAgICBiNDggPSAoc1s0Ml0gPDwgMikgfCAoc1s0M10gPj4+IDMwKTtcblx0ICAgICAgYjQ5ID0gKHNbNDNdIDw8IDIpIHwgKHNbNDJdID4+PiAzMCk7XG5cdCAgICAgIGI0MCA9IChzWzVdIDw8IDMwKSB8IChzWzRdID4+PiAyKTtcblx0ICAgICAgYjQxID0gKHNbNF0gPDwgMzApIHwgKHNbNV0gPj4+IDIpO1xuXHQgICAgICBiMjIgPSAoc1sxNF0gPDwgNikgfCAoc1sxNV0gPj4+IDI2KTtcblx0ICAgICAgYjIzID0gKHNbMTVdIDw8IDYpIHwgKHNbMTRdID4+PiAyNik7XG5cdCAgICAgIGI0ID0gKHNbMjVdIDw8IDExKSB8IChzWzI0XSA+Pj4gMjEpO1xuXHQgICAgICBiNSA9IChzWzI0XSA8PCAxMSkgfCAoc1syNV0gPj4+IDIxKTtcblx0ICAgICAgYjM2ID0gKHNbMzRdIDw8IDE1KSB8IChzWzM1XSA+Pj4gMTcpO1xuXHQgICAgICBiMzcgPSAoc1szNV0gPDwgMTUpIHwgKHNbMzRdID4+PiAxNyk7XG5cdCAgICAgIGIxOCA9IChzWzQ1XSA8PCAyOSkgfCAoc1s0NF0gPj4+IDMpO1xuXHQgICAgICBiMTkgPSAoc1s0NF0gPDwgMjkpIHwgKHNbNDVdID4+PiAzKTtcblx0ICAgICAgYjEwID0gKHNbNl0gPDwgMjgpIHwgKHNbN10gPj4+IDQpO1xuXHQgICAgICBiMTEgPSAoc1s3XSA8PCAyOCkgfCAoc1s2XSA+Pj4gNCk7XG5cdCAgICAgIGI0MiA9IChzWzE3XSA8PCAyMykgfCAoc1sxNl0gPj4+IDkpO1xuXHQgICAgICBiNDMgPSAoc1sxNl0gPDwgMjMpIHwgKHNbMTddID4+PiA5KTtcblx0ICAgICAgYjI0ID0gKHNbMjZdIDw8IDI1KSB8IChzWzI3XSA+Pj4gNyk7XG5cdCAgICAgIGIyNSA9IChzWzI3XSA8PCAyNSkgfCAoc1syNl0gPj4+IDcpO1xuXHQgICAgICBiNiA9IChzWzM2XSA8PCAyMSkgfCAoc1szN10gPj4+IDExKTtcblx0ICAgICAgYjcgPSAoc1szN10gPDwgMjEpIHwgKHNbMzZdID4+PiAxMSk7XG5cdCAgICAgIGIzOCA9IChzWzQ3XSA8PCAyNCkgfCAoc1s0Nl0gPj4+IDgpO1xuXHQgICAgICBiMzkgPSAoc1s0Nl0gPDwgMjQpIHwgKHNbNDddID4+PiA4KTtcblx0ICAgICAgYjMwID0gKHNbOF0gPDwgMjcpIHwgKHNbOV0gPj4+IDUpO1xuXHQgICAgICBiMzEgPSAoc1s5XSA8PCAyNykgfCAoc1s4XSA+Pj4gNSk7XG5cdCAgICAgIGIxMiA9IChzWzE4XSA8PCAyMCkgfCAoc1sxOV0gPj4+IDEyKTtcblx0ICAgICAgYjEzID0gKHNbMTldIDw8IDIwKSB8IChzWzE4XSA+Pj4gMTIpO1xuXHQgICAgICBiNDQgPSAoc1syOV0gPDwgNykgfCAoc1syOF0gPj4+IDI1KTtcblx0ICAgICAgYjQ1ID0gKHNbMjhdIDw8IDcpIHwgKHNbMjldID4+PiAyNSk7XG5cdCAgICAgIGIyNiA9IChzWzM4XSA8PCA4KSB8IChzWzM5XSA+Pj4gMjQpO1xuXHQgICAgICBiMjcgPSAoc1szOV0gPDwgOCkgfCAoc1szOF0gPj4+IDI0KTtcblx0ICAgICAgYjggPSAoc1s0OF0gPDwgMTQpIHwgKHNbNDldID4+PiAxOCk7XG5cdCAgICAgIGI5ID0gKHNbNDldIDw8IDE0KSB8IChzWzQ4XSA+Pj4gMTgpO1xuXG5cdCAgICAgIHNbMF0gPSBiMCBeICh+YjIgJiBiNCk7XG5cdCAgICAgIHNbMV0gPSBiMSBeICh+YjMgJiBiNSk7XG5cdCAgICAgIHNbMTBdID0gYjEwIF4gKH5iMTIgJiBiMTQpO1xuXHQgICAgICBzWzExXSA9IGIxMSBeICh+YjEzICYgYjE1KTtcblx0ICAgICAgc1syMF0gPSBiMjAgXiAofmIyMiAmIGIyNCk7XG5cdCAgICAgIHNbMjFdID0gYjIxIF4gKH5iMjMgJiBiMjUpO1xuXHQgICAgICBzWzMwXSA9IGIzMCBeICh+YjMyICYgYjM0KTtcblx0ICAgICAgc1szMV0gPSBiMzEgXiAofmIzMyAmIGIzNSk7XG5cdCAgICAgIHNbNDBdID0gYjQwIF4gKH5iNDIgJiBiNDQpO1xuXHQgICAgICBzWzQxXSA9IGI0MSBeICh+YjQzICYgYjQ1KTtcblx0ICAgICAgc1syXSA9IGIyIF4gKH5iNCAmIGI2KTtcblx0ICAgICAgc1szXSA9IGIzIF4gKH5iNSAmIGI3KTtcblx0ICAgICAgc1sxMl0gPSBiMTIgXiAofmIxNCAmIGIxNik7XG5cdCAgICAgIHNbMTNdID0gYjEzIF4gKH5iMTUgJiBiMTcpO1xuXHQgICAgICBzWzIyXSA9IGIyMiBeICh+YjI0ICYgYjI2KTtcblx0ICAgICAgc1syM10gPSBiMjMgXiAofmIyNSAmIGIyNyk7XG5cdCAgICAgIHNbMzJdID0gYjMyIF4gKH5iMzQgJiBiMzYpO1xuXHQgICAgICBzWzMzXSA9IGIzMyBeICh+YjM1ICYgYjM3KTtcblx0ICAgICAgc1s0Ml0gPSBiNDIgXiAofmI0NCAmIGI0Nik7XG5cdCAgICAgIHNbNDNdID0gYjQzIF4gKH5iNDUgJiBiNDcpO1xuXHQgICAgICBzWzRdID0gYjQgXiAofmI2ICYgYjgpO1xuXHQgICAgICBzWzVdID0gYjUgXiAofmI3ICYgYjkpO1xuXHQgICAgICBzWzE0XSA9IGIxNCBeICh+YjE2ICYgYjE4KTtcblx0ICAgICAgc1sxNV0gPSBiMTUgXiAofmIxNyAmIGIxOSk7XG5cdCAgICAgIHNbMjRdID0gYjI0IF4gKH5iMjYgJiBiMjgpO1xuXHQgICAgICBzWzI1XSA9IGIyNSBeICh+YjI3ICYgYjI5KTtcblx0ICAgICAgc1szNF0gPSBiMzQgXiAofmIzNiAmIGIzOCk7XG5cdCAgICAgIHNbMzVdID0gYjM1IF4gKH5iMzcgJiBiMzkpO1xuXHQgICAgICBzWzQ0XSA9IGI0NCBeICh+YjQ2ICYgYjQ4KTtcblx0ICAgICAgc1s0NV0gPSBiNDUgXiAofmI0NyAmIGI0OSk7XG5cdCAgICAgIHNbNl0gPSBiNiBeICh+YjggJiBiMCk7XG5cdCAgICAgIHNbN10gPSBiNyBeICh+YjkgJiBiMSk7XG5cdCAgICAgIHNbMTZdID0gYjE2IF4gKH5iMTggJiBiMTApO1xuXHQgICAgICBzWzE3XSA9IGIxNyBeICh+YjE5ICYgYjExKTtcblx0ICAgICAgc1syNl0gPSBiMjYgXiAofmIyOCAmIGIyMCk7XG5cdCAgICAgIHNbMjddID0gYjI3IF4gKH5iMjkgJiBiMjEpO1xuXHQgICAgICBzWzM2XSA9IGIzNiBeICh+YjM4ICYgYjMwKTtcblx0ICAgICAgc1szN10gPSBiMzcgXiAofmIzOSAmIGIzMSk7XG5cdCAgICAgIHNbNDZdID0gYjQ2IF4gKH5iNDggJiBiNDApO1xuXHQgICAgICBzWzQ3XSA9IGI0NyBeICh+YjQ5ICYgYjQxKTtcblx0ICAgICAgc1s4XSA9IGI4IF4gKH5iMCAmIGIyKTtcblx0ICAgICAgc1s5XSA9IGI5IF4gKH5iMSAmIGIzKTtcblx0ICAgICAgc1sxOF0gPSBiMTggXiAofmIxMCAmIGIxMik7XG5cdCAgICAgIHNbMTldID0gYjE5IF4gKH5iMTEgJiBiMTMpO1xuXHQgICAgICBzWzI4XSA9IGIyOCBeICh+YjIwICYgYjIyKTtcblx0ICAgICAgc1syOV0gPSBiMjkgXiAofmIyMSAmIGIyMyk7XG5cdCAgICAgIHNbMzhdID0gYjM4IF4gKH5iMzAgJiBiMzIpO1xuXHQgICAgICBzWzM5XSA9IGIzOSBeICh+YjMxICYgYjMzKTtcblx0ICAgICAgc1s0OF0gPSBiNDggXiAofmI0MCAmIGI0Mik7XG5cdCAgICAgIHNbNDldID0gYjQ5IF4gKH5iNDEgJiBiNDMpO1xuXG5cdCAgICAgIHNbMF0gXj0gUkNbbl07XG5cdCAgICAgIHNbMV0gXj0gUkNbbiArIDFdO1xuXHQgICAgfVxuXHQgIH07XG5cblx0ICBpZiAoQ09NTU9OX0pTKSB7XG5cdCAgICBtb2R1bGUuZXhwb3J0cyA9IG1ldGhvZHM7XG5cdCAgfSBlbHNlIHtcblx0ICAgIGZvciAoaSA9IDA7IGkgPCBtZXRob2ROYW1lcy5sZW5ndGg7ICsraSkge1xuXHQgICAgICByb290W21ldGhvZE5hbWVzW2ldXSA9IG1ldGhvZHNbbWV0aG9kTmFtZXNbaV1dO1xuXHQgICAgfVxuXHQgICAgaWYgKEFNRCkge1xuXHQgICAgICB1bmRlZmluZWQoZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIHJldHVybiBtZXRob2RzO1xuXHQgICAgICB9KTtcblx0ICAgIH1cblx0ICB9XG5cdH0pKCk7XG5cdH0pO1xuXG5cdHZhciBsaWIkNCA9IGNyZWF0ZUNvbW1vbmpzTW9kdWxlKGZ1bmN0aW9uIChtb2R1bGUsIGV4cG9ydHMpIHtcblx0XCJ1c2Ugc3RyaWN0XCI7XG5cdHZhciBfX2ltcG9ydERlZmF1bHQgPSAoY29tbW9uanNHbG9iYWwgJiYgY29tbW9uanNHbG9iYWwuX19pbXBvcnREZWZhdWx0KSB8fCBmdW5jdGlvbiAobW9kKSB7XG5cdCAgICByZXR1cm4gKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgPyBtb2QgOiB7IFwiZGVmYXVsdFwiOiBtb2QgfTtcblx0fTtcblx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuXHRleHBvcnRzLmtlY2NhazI1NiA9IHZvaWQgMDtcblx0dmFyIGpzX3NoYTNfMSA9IF9faW1wb3J0RGVmYXVsdChzaGEzKTtcblxuXHRmdW5jdGlvbiBrZWNjYWsyNTYoZGF0YSkge1xuXHQgICAgcmV0dXJuICcweCcgKyBqc19zaGEzXzEuZGVmYXVsdC5rZWNjYWtfMjU2KCgwLCBsaWIkMS5hcnJheWlmeSkoZGF0YSkpO1xuXHR9XG5cdGV4cG9ydHMua2VjY2FrMjU2ID0ga2VjY2FrMjU2O1xuXG5cdH0pO1xuXG5cdHZhciBpbmRleCQ0ID0gLypAX19QVVJFX18qL2dldERlZmF1bHRFeHBvcnRGcm9tQ2pzKGxpYiQ0KTtcblxuXHR2YXIgX3ZlcnNpb24kYSA9IGNyZWF0ZUNvbW1vbmpzTW9kdWxlKGZ1bmN0aW9uIChtb2R1bGUsIGV4cG9ydHMpIHtcblx0XCJ1c2Ugc3RyaWN0XCI7XG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcblx0ZXhwb3J0cy52ZXJzaW9uID0gdm9pZCAwO1xuXHRleHBvcnRzLnZlcnNpb24gPSBcInJscC81LjUuMFwiO1xuXG5cdH0pO1xuXG5cdHZhciBfdmVyc2lvbiRiID0gLypAX19QVVJFX18qL2dldERlZmF1bHRFeHBvcnRGcm9tQ2pzKF92ZXJzaW9uJGEpO1xuXG5cdHZhciBsaWIkNSA9IGNyZWF0ZUNvbW1vbmpzTW9kdWxlKGZ1bmN0aW9uIChtb2R1bGUsIGV4cG9ydHMpIHtcblx0XCJ1c2Ugc3RyaWN0XCI7XG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcblx0ZXhwb3J0cy5kZWNvZGUgPSBleHBvcnRzLmVuY29kZSA9IHZvaWQgMDtcblx0Ly9TZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9ldGhlcmV1bS93aWtpL3dpa2kvUkxQXG5cblxuXG5cdHZhciBsb2dnZXIgPSBuZXcgbGliLkxvZ2dlcihfdmVyc2lvbiRhLnZlcnNpb24pO1xuXHRmdW5jdGlvbiBhcnJheWlmeUludGVnZXIodmFsdWUpIHtcblx0ICAgIHZhciByZXN1bHQgPSBbXTtcblx0ICAgIHdoaWxlICh2YWx1ZSkge1xuXHQgICAgICAgIHJlc3VsdC51bnNoaWZ0KHZhbHVlICYgMHhmZik7XG5cdCAgICAgICAgdmFsdWUgPj49IDg7XG5cdCAgICB9XG5cdCAgICByZXR1cm4gcmVzdWx0O1xuXHR9XG5cdGZ1bmN0aW9uIHVuYXJyYXlpZnlJbnRlZ2VyKGRhdGEsIG9mZnNldCwgbGVuZ3RoKSB7XG5cdCAgICB2YXIgcmVzdWx0ID0gMDtcblx0ICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcblx0ICAgICAgICByZXN1bHQgPSAocmVzdWx0ICogMjU2KSArIGRhdGFbb2Zmc2V0ICsgaV07XG5cdCAgICB9XG5cdCAgICByZXR1cm4gcmVzdWx0O1xuXHR9XG5cdGZ1bmN0aW9uIF9lbmNvZGUob2JqZWN0KSB7XG5cdCAgICBpZiAoQXJyYXkuaXNBcnJheShvYmplY3QpKSB7XG5cdCAgICAgICAgdmFyIHBheWxvYWRfMSA9IFtdO1xuXHQgICAgICAgIG9iamVjdC5mb3JFYWNoKGZ1bmN0aW9uIChjaGlsZCkge1xuXHQgICAgICAgICAgICBwYXlsb2FkXzEgPSBwYXlsb2FkXzEuY29uY2F0KF9lbmNvZGUoY2hpbGQpKTtcblx0ICAgICAgICB9KTtcblx0ICAgICAgICBpZiAocGF5bG9hZF8xLmxlbmd0aCA8PSA1NSkge1xuXHQgICAgICAgICAgICBwYXlsb2FkXzEudW5zaGlmdCgweGMwICsgcGF5bG9hZF8xLmxlbmd0aCk7XG5cdCAgICAgICAgICAgIHJldHVybiBwYXlsb2FkXzE7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHZhciBsZW5ndGhfMSA9IGFycmF5aWZ5SW50ZWdlcihwYXlsb2FkXzEubGVuZ3RoKTtcblx0ICAgICAgICBsZW5ndGhfMS51bnNoaWZ0KDB4ZjcgKyBsZW5ndGhfMS5sZW5ndGgpO1xuXHQgICAgICAgIHJldHVybiBsZW5ndGhfMS5jb25jYXQocGF5bG9hZF8xKTtcblx0ICAgIH1cblx0ICAgIGlmICghKDAsIGxpYiQxLmlzQnl0ZXNMaWtlKShvYmplY3QpKSB7XG5cdCAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcIlJMUCBvYmplY3QgbXVzdCBiZSBCeXRlc0xpa2VcIiwgXCJvYmplY3RcIiwgb2JqZWN0KTtcblx0ICAgIH1cblx0ICAgIHZhciBkYXRhID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoKDAsIGxpYiQxLmFycmF5aWZ5KShvYmplY3QpKTtcblx0ICAgIGlmIChkYXRhLmxlbmd0aCA9PT0gMSAmJiBkYXRhWzBdIDw9IDB4N2YpIHtcblx0ICAgICAgICByZXR1cm4gZGF0YTtcblx0ICAgIH1cblx0ICAgIGVsc2UgaWYgKGRhdGEubGVuZ3RoIDw9IDU1KSB7XG5cdCAgICAgICAgZGF0YS51bnNoaWZ0KDB4ODAgKyBkYXRhLmxlbmd0aCk7XG5cdCAgICAgICAgcmV0dXJuIGRhdGE7XG5cdCAgICB9XG5cdCAgICB2YXIgbGVuZ3RoID0gYXJyYXlpZnlJbnRlZ2VyKGRhdGEubGVuZ3RoKTtcblx0ICAgIGxlbmd0aC51bnNoaWZ0KDB4YjcgKyBsZW5ndGgubGVuZ3RoKTtcblx0ICAgIHJldHVybiBsZW5ndGguY29uY2F0KGRhdGEpO1xuXHR9XG5cdGZ1bmN0aW9uIGVuY29kZShvYmplY3QpIHtcblx0ICAgIHJldHVybiAoMCwgbGliJDEuaGV4bGlmeSkoX2VuY29kZShvYmplY3QpKTtcblx0fVxuXHRleHBvcnRzLmVuY29kZSA9IGVuY29kZTtcblx0ZnVuY3Rpb24gX2RlY29kZUNoaWxkcmVuKGRhdGEsIG9mZnNldCwgY2hpbGRPZmZzZXQsIGxlbmd0aCkge1xuXHQgICAgdmFyIHJlc3VsdCA9IFtdO1xuXHQgICAgd2hpbGUgKGNoaWxkT2Zmc2V0IDwgb2Zmc2V0ICsgMSArIGxlbmd0aCkge1xuXHQgICAgICAgIHZhciBkZWNvZGVkID0gX2RlY29kZShkYXRhLCBjaGlsZE9mZnNldCk7XG5cdCAgICAgICAgcmVzdWx0LnB1c2goZGVjb2RlZC5yZXN1bHQpO1xuXHQgICAgICAgIGNoaWxkT2Zmc2V0ICs9IGRlY29kZWQuY29uc3VtZWQ7XG5cdCAgICAgICAgaWYgKGNoaWxkT2Zmc2V0ID4gb2Zmc2V0ICsgMSArIGxlbmd0aCkge1xuXHQgICAgICAgICAgICBsb2dnZXIudGhyb3dFcnJvcihcImNoaWxkIGRhdGEgdG9vIHNob3J0XCIsIGxpYi5Mb2dnZXIuZXJyb3JzLkJVRkZFUl9PVkVSUlVOLCB7fSk7XG5cdCAgICAgICAgfVxuXHQgICAgfVxuXHQgICAgcmV0dXJuIHsgY29uc3VtZWQ6ICgxICsgbGVuZ3RoKSwgcmVzdWx0OiByZXN1bHQgfTtcblx0fVxuXHQvLyByZXR1cm5zIHsgY29uc3VtZWQ6IG51bWJlciwgcmVzdWx0OiBPYmplY3QgfVxuXHRmdW5jdGlvbiBfZGVjb2RlKGRhdGEsIG9mZnNldCkge1xuXHQgICAgaWYgKGRhdGEubGVuZ3RoID09PSAwKSB7XG5cdCAgICAgICAgbG9nZ2VyLnRocm93RXJyb3IoXCJkYXRhIHRvbyBzaG9ydFwiLCBsaWIuTG9nZ2VyLmVycm9ycy5CVUZGRVJfT1ZFUlJVTiwge30pO1xuXHQgICAgfVxuXHQgICAgLy8gQXJyYXkgd2l0aCBleHRyYSBsZW5ndGggcHJlZml4XG5cdCAgICBpZiAoZGF0YVtvZmZzZXRdID49IDB4ZjgpIHtcblx0ICAgICAgICB2YXIgbGVuZ3RoTGVuZ3RoID0gZGF0YVtvZmZzZXRdIC0gMHhmNztcblx0ICAgICAgICBpZiAob2Zmc2V0ICsgMSArIGxlbmd0aExlbmd0aCA+IGRhdGEubGVuZ3RoKSB7XG5cdCAgICAgICAgICAgIGxvZ2dlci50aHJvd0Vycm9yKFwiZGF0YSBzaG9ydCBzZWdtZW50IHRvbyBzaG9ydFwiLCBsaWIuTG9nZ2VyLmVycm9ycy5CVUZGRVJfT1ZFUlJVTiwge30pO1xuXHQgICAgICAgIH1cblx0ICAgICAgICB2YXIgbGVuZ3RoXzIgPSB1bmFycmF5aWZ5SW50ZWdlcihkYXRhLCBvZmZzZXQgKyAxLCBsZW5ndGhMZW5ndGgpO1xuXHQgICAgICAgIGlmIChvZmZzZXQgKyAxICsgbGVuZ3RoTGVuZ3RoICsgbGVuZ3RoXzIgPiBkYXRhLmxlbmd0aCkge1xuXHQgICAgICAgICAgICBsb2dnZXIudGhyb3dFcnJvcihcImRhdGEgbG9uZyBzZWdtZW50IHRvbyBzaG9ydFwiLCBsaWIuTG9nZ2VyLmVycm9ycy5CVUZGRVJfT1ZFUlJVTiwge30pO1xuXHQgICAgICAgIH1cblx0ICAgICAgICByZXR1cm4gX2RlY29kZUNoaWxkcmVuKGRhdGEsIG9mZnNldCwgb2Zmc2V0ICsgMSArIGxlbmd0aExlbmd0aCwgbGVuZ3RoTGVuZ3RoICsgbGVuZ3RoXzIpO1xuXHQgICAgfVxuXHQgICAgZWxzZSBpZiAoZGF0YVtvZmZzZXRdID49IDB4YzApIHtcblx0ICAgICAgICB2YXIgbGVuZ3RoXzMgPSBkYXRhW29mZnNldF0gLSAweGMwO1xuXHQgICAgICAgIGlmIChvZmZzZXQgKyAxICsgbGVuZ3RoXzMgPiBkYXRhLmxlbmd0aCkge1xuXHQgICAgICAgICAgICBsb2dnZXIudGhyb3dFcnJvcihcImRhdGEgYXJyYXkgdG9vIHNob3J0XCIsIGxpYi5Mb2dnZXIuZXJyb3JzLkJVRkZFUl9PVkVSUlVOLCB7fSk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHJldHVybiBfZGVjb2RlQ2hpbGRyZW4oZGF0YSwgb2Zmc2V0LCBvZmZzZXQgKyAxLCBsZW5ndGhfMyk7XG5cdCAgICB9XG5cdCAgICBlbHNlIGlmIChkYXRhW29mZnNldF0gPj0gMHhiOCkge1xuXHQgICAgICAgIHZhciBsZW5ndGhMZW5ndGggPSBkYXRhW29mZnNldF0gLSAweGI3O1xuXHQgICAgICAgIGlmIChvZmZzZXQgKyAxICsgbGVuZ3RoTGVuZ3RoID4gZGF0YS5sZW5ndGgpIHtcblx0ICAgICAgICAgICAgbG9nZ2VyLnRocm93RXJyb3IoXCJkYXRhIGFycmF5IHRvbyBzaG9ydFwiLCBsaWIuTG9nZ2VyLmVycm9ycy5CVUZGRVJfT1ZFUlJVTiwge30pO1xuXHQgICAgICAgIH1cblx0ICAgICAgICB2YXIgbGVuZ3RoXzQgPSB1bmFycmF5aWZ5SW50ZWdlcihkYXRhLCBvZmZzZXQgKyAxLCBsZW5ndGhMZW5ndGgpO1xuXHQgICAgICAgIGlmIChvZmZzZXQgKyAxICsgbGVuZ3RoTGVuZ3RoICsgbGVuZ3RoXzQgPiBkYXRhLmxlbmd0aCkge1xuXHQgICAgICAgICAgICBsb2dnZXIudGhyb3dFcnJvcihcImRhdGEgYXJyYXkgdG9vIHNob3J0XCIsIGxpYi5Mb2dnZXIuZXJyb3JzLkJVRkZFUl9PVkVSUlVOLCB7fSk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHZhciByZXN1bHQgPSAoMCwgbGliJDEuaGV4bGlmeSkoZGF0YS5zbGljZShvZmZzZXQgKyAxICsgbGVuZ3RoTGVuZ3RoLCBvZmZzZXQgKyAxICsgbGVuZ3RoTGVuZ3RoICsgbGVuZ3RoXzQpKTtcblx0ICAgICAgICByZXR1cm4geyBjb25zdW1lZDogKDEgKyBsZW5ndGhMZW5ndGggKyBsZW5ndGhfNCksIHJlc3VsdDogcmVzdWx0IH07XG5cdCAgICB9XG5cdCAgICBlbHNlIGlmIChkYXRhW29mZnNldF0gPj0gMHg4MCkge1xuXHQgICAgICAgIHZhciBsZW5ndGhfNSA9IGRhdGFbb2Zmc2V0XSAtIDB4ODA7XG5cdCAgICAgICAgaWYgKG9mZnNldCArIDEgKyBsZW5ndGhfNSA+IGRhdGEubGVuZ3RoKSB7XG5cdCAgICAgICAgICAgIGxvZ2dlci50aHJvd0Vycm9yKFwiZGF0YSB0b28gc2hvcnRcIiwgbGliLkxvZ2dlci5lcnJvcnMuQlVGRkVSX09WRVJSVU4sIHt9KTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgdmFyIHJlc3VsdCA9ICgwLCBsaWIkMS5oZXhsaWZ5KShkYXRhLnNsaWNlKG9mZnNldCArIDEsIG9mZnNldCArIDEgKyBsZW5ndGhfNSkpO1xuXHQgICAgICAgIHJldHVybiB7IGNvbnN1bWVkOiAoMSArIGxlbmd0aF81KSwgcmVzdWx0OiByZXN1bHQgfTtcblx0ICAgIH1cblx0ICAgIHJldHVybiB7IGNvbnN1bWVkOiAxLCByZXN1bHQ6ICgwLCBsaWIkMS5oZXhsaWZ5KShkYXRhW29mZnNldF0pIH07XG5cdH1cblx0ZnVuY3Rpb24gZGVjb2RlKGRhdGEpIHtcblx0ICAgIHZhciBieXRlcyA9ICgwLCBsaWIkMS5hcnJheWlmeSkoZGF0YSk7XG5cdCAgICB2YXIgZGVjb2RlZCA9IF9kZWNvZGUoYnl0ZXMsIDApO1xuXHQgICAgaWYgKGRlY29kZWQuY29uc3VtZWQgIT09IGJ5dGVzLmxlbmd0aCkge1xuXHQgICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJpbnZhbGlkIHJscCBkYXRhXCIsIFwiZGF0YVwiLCBkYXRhKTtcblx0ICAgIH1cblx0ICAgIHJldHVybiBkZWNvZGVkLnJlc3VsdDtcblx0fVxuXHRleHBvcnRzLmRlY29kZSA9IGRlY29kZTtcblxuXHR9KTtcblxuXHR2YXIgaW5kZXgkNSA9IC8qQF9fUFVSRV9fKi9nZXREZWZhdWx0RXhwb3J0RnJvbUNqcyhsaWIkNSk7XG5cblx0dmFyIF92ZXJzaW9uJGMgPSBjcmVhdGVDb21tb25qc01vZHVsZShmdW5jdGlvbiAobW9kdWxlLCBleHBvcnRzKSB7XG5cdFwidXNlIHN0cmljdFwiO1xuXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5cdGV4cG9ydHMudmVyc2lvbiA9IHZvaWQgMDtcblx0ZXhwb3J0cy52ZXJzaW9uID0gXCJhZGRyZXNzLzUuNS4wXCI7XG5cblx0fSk7XG5cblx0dmFyIF92ZXJzaW9uJGQgPSAvKkBfX1BVUkVfXyovZ2V0RGVmYXVsdEV4cG9ydEZyb21DanMoX3ZlcnNpb24kYyk7XG5cblx0dmFyIGxpYiQ2ID0gY3JlYXRlQ29tbW9uanNNb2R1bGUoZnVuY3Rpb24gKG1vZHVsZSwgZXhwb3J0cykge1xuXHRcInVzZSBzdHJpY3RcIjtcblx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuXHRleHBvcnRzLmdldENyZWF0ZTJBZGRyZXNzID0gZXhwb3J0cy5nZXRDb250cmFjdEFkZHJlc3MgPSBleHBvcnRzLmdldEljYXBBZGRyZXNzID0gZXhwb3J0cy5pc0FkZHJlc3MgPSBleHBvcnRzLmdldEFkZHJlc3MgPSB2b2lkIDA7XG5cblxuXG5cblxuXG5cdHZhciBsb2dnZXIgPSBuZXcgbGliLkxvZ2dlcihfdmVyc2lvbiRjLnZlcnNpb24pO1xuXHRmdW5jdGlvbiBnZXRDaGVja3N1bUFkZHJlc3MoYWRkcmVzcykge1xuXHQgICAgaWYgKCEoMCwgbGliJDEuaXNIZXhTdHJpbmcpKGFkZHJlc3MsIDIwKSkge1xuXHQgICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJpbnZhbGlkIGFkZHJlc3NcIiwgXCJhZGRyZXNzXCIsIGFkZHJlc3MpO1xuXHQgICAgfVxuXHQgICAgYWRkcmVzcyA9IGFkZHJlc3MudG9Mb3dlckNhc2UoKTtcblx0ICAgIHZhciBjaGFycyA9IGFkZHJlc3Muc3Vic3RyaW5nKDIpLnNwbGl0KFwiXCIpO1xuXHQgICAgdmFyIGV4cGFuZGVkID0gbmV3IFVpbnQ4QXJyYXkoNDApO1xuXHQgICAgZm9yICh2YXIgaSA9IDA7IGkgPCA0MDsgaSsrKSB7XG5cdCAgICAgICAgZXhwYW5kZWRbaV0gPSBjaGFyc1tpXS5jaGFyQ29kZUF0KDApO1xuXHQgICAgfVxuXHQgICAgdmFyIGhhc2hlZCA9ICgwLCBsaWIkMS5hcnJheWlmeSkoKDAsIGxpYiQ0LmtlY2NhazI1NikoZXhwYW5kZWQpKTtcblx0ICAgIGZvciAodmFyIGkgPSAwOyBpIDwgNDA7IGkgKz0gMikge1xuXHQgICAgICAgIGlmICgoaGFzaGVkW2kgPj4gMV0gPj4gNCkgPj0gOCkge1xuXHQgICAgICAgICAgICBjaGFyc1tpXSA9IGNoYXJzW2ldLnRvVXBwZXJDYXNlKCk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGlmICgoaGFzaGVkW2kgPj4gMV0gJiAweDBmKSA+PSA4KSB7XG5cdCAgICAgICAgICAgIGNoYXJzW2kgKyAxXSA9IGNoYXJzW2kgKyAxXS50b1VwcGVyQ2FzZSgpO1xuXHQgICAgICAgIH1cblx0ICAgIH1cblx0ICAgIHJldHVybiBcIjB4XCIgKyBjaGFycy5qb2luKFwiXCIpO1xuXHR9XG5cdC8vIFNoaW1zIGZvciBlbnZpcm9ubWVudHMgdGhhdCBhcmUgbWlzc2luZyBzb21lIHJlcXVpcmVkIGNvbnN0YW50cyBhbmQgZnVuY3Rpb25zXG5cdHZhciBNQVhfU0FGRV9JTlRFR0VSID0gMHgxZmZmZmZmZmZmZmZmZjtcblx0ZnVuY3Rpb24gbG9nMTAoeCkge1xuXHQgICAgaWYgKE1hdGgubG9nMTApIHtcblx0ICAgICAgICByZXR1cm4gTWF0aC5sb2cxMCh4KTtcblx0ICAgIH1cblx0ICAgIHJldHVybiBNYXRoLmxvZyh4KSAvIE1hdGguTE4xMDtcblx0fVxuXHQvLyBTZWU6IGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0ludGVybmF0aW9uYWxfQmFua19BY2NvdW50X051bWJlclxuXHQvLyBDcmVhdGUgbG9va3VwIHRhYmxlXG5cdHZhciBpYmFuTG9va3VwID0ge307XG5cdGZvciAodmFyIGkgPSAwOyBpIDwgMTA7IGkrKykge1xuXHQgICAgaWJhbkxvb2t1cFtTdHJpbmcoaSldID0gU3RyaW5nKGkpO1xuXHR9XG5cdGZvciAodmFyIGkgPSAwOyBpIDwgMjY7IGkrKykge1xuXHQgICAgaWJhbkxvb2t1cFtTdHJpbmcuZnJvbUNoYXJDb2RlKDY1ICsgaSldID0gU3RyaW5nKDEwICsgaSk7XG5cdH1cblx0Ly8gSG93IG1hbnkgZGVjaW1hbCBkaWdpdHMgY2FuIHdlIHByb2Nlc3M/IChmb3IgNjQtYml0IGZsb2F0LCB0aGlzIGlzIDE1KVxuXHR2YXIgc2FmZURpZ2l0cyA9IE1hdGguZmxvb3IobG9nMTAoTUFYX1NBRkVfSU5URUdFUikpO1xuXHRmdW5jdGlvbiBpYmFuQ2hlY2tzdW0oYWRkcmVzcykge1xuXHQgICAgYWRkcmVzcyA9IGFkZHJlc3MudG9VcHBlckNhc2UoKTtcblx0ICAgIGFkZHJlc3MgPSBhZGRyZXNzLnN1YnN0cmluZyg0KSArIGFkZHJlc3Muc3Vic3RyaW5nKDAsIDIpICsgXCIwMFwiO1xuXHQgICAgdmFyIGV4cGFuZGVkID0gYWRkcmVzcy5zcGxpdChcIlwiKS5tYXAoZnVuY3Rpb24gKGMpIHsgcmV0dXJuIGliYW5Mb29rdXBbY107IH0pLmpvaW4oXCJcIik7XG5cdCAgICAvLyBKYXZhc2NyaXB0IGNhbiBoYW5kbGUgaW50ZWdlcnMgc2FmZWx5IHVwIHRvIDE1IChkZWNpbWFsKSBkaWdpdHNcblx0ICAgIHdoaWxlIChleHBhbmRlZC5sZW5ndGggPj0gc2FmZURpZ2l0cykge1xuXHQgICAgICAgIHZhciBibG9jayA9IGV4cGFuZGVkLnN1YnN0cmluZygwLCBzYWZlRGlnaXRzKTtcblx0ICAgICAgICBleHBhbmRlZCA9IHBhcnNlSW50KGJsb2NrLCAxMCkgJSA5NyArIGV4cGFuZGVkLnN1YnN0cmluZyhibG9jay5sZW5ndGgpO1xuXHQgICAgfVxuXHQgICAgdmFyIGNoZWNrc3VtID0gU3RyaW5nKDk4IC0gKHBhcnNlSW50KGV4cGFuZGVkLCAxMCkgJSA5NykpO1xuXHQgICAgd2hpbGUgKGNoZWNrc3VtLmxlbmd0aCA8IDIpIHtcblx0ICAgICAgICBjaGVja3N1bSA9IFwiMFwiICsgY2hlY2tzdW07XG5cdCAgICB9XG5cdCAgICByZXR1cm4gY2hlY2tzdW07XG5cdH1cblx0O1xuXHRmdW5jdGlvbiBnZXRBZGRyZXNzKGFkZHJlc3MpIHtcblx0ICAgIHZhciByZXN1bHQgPSBudWxsO1xuXHQgICAgaWYgKHR5cGVvZiAoYWRkcmVzcykgIT09IFwic3RyaW5nXCIpIHtcblx0ICAgICAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwiaW52YWxpZCBhZGRyZXNzXCIsIFwiYWRkcmVzc1wiLCBhZGRyZXNzKTtcblx0ICAgIH1cblx0ICAgIGlmIChhZGRyZXNzLm1hdGNoKC9eKDB4KT9bMC05YS1mQS1GXXs0MH0kLykpIHtcblx0ICAgICAgICAvLyBNaXNzaW5nIHRoZSAweCBwcmVmaXhcblx0ICAgICAgICBpZiAoYWRkcmVzcy5zdWJzdHJpbmcoMCwgMikgIT09IFwiMHhcIikge1xuXHQgICAgICAgICAgICBhZGRyZXNzID0gXCIweFwiICsgYWRkcmVzcztcblx0ICAgICAgICB9XG5cdCAgICAgICAgcmVzdWx0ID0gZ2V0Q2hlY2tzdW1BZGRyZXNzKGFkZHJlc3MpO1xuXHQgICAgICAgIC8vIEl0IGlzIGEgY2hlY2tzdW1tZWQgYWRkcmVzcyB3aXRoIGEgYmFkIGNoZWNrc3VtXG5cdCAgICAgICAgaWYgKGFkZHJlc3MubWF0Y2goLyhbQS1GXS4qW2EtZl0pfChbYS1mXS4qW0EtRl0pLykgJiYgcmVzdWx0ICE9PSBhZGRyZXNzKSB7XG5cdCAgICAgICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJiYWQgYWRkcmVzcyBjaGVja3N1bVwiLCBcImFkZHJlc3NcIiwgYWRkcmVzcyk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIC8vIE1heWJlIElDQVA/ICh3ZSBvbmx5IHN1cHBvcnQgZGlyZWN0IG1vZGUpXG5cdCAgICB9XG5cdCAgICBlbHNlIGlmIChhZGRyZXNzLm1hdGNoKC9eWEVbMC05XXsyfVswLTlBLVphLXpdezMwLDMxfSQvKSkge1xuXHQgICAgICAgIC8vIEl0IGlzIGFuIElDQVAgYWRkcmVzcyB3aXRoIGEgYmFkIGNoZWNrc3VtXG5cdCAgICAgICAgaWYgKGFkZHJlc3Muc3Vic3RyaW5nKDIsIDQpICE9PSBpYmFuQ2hlY2tzdW0oYWRkcmVzcykpIHtcblx0ICAgICAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcImJhZCBpY2FwIGNoZWNrc3VtXCIsIFwiYWRkcmVzc1wiLCBhZGRyZXNzKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgcmVzdWx0ID0gKDAsIGxpYiQyLl9iYXNlMzZUbzE2KShhZGRyZXNzLnN1YnN0cmluZyg0KSk7XG5cdCAgICAgICAgd2hpbGUgKHJlc3VsdC5sZW5ndGggPCA0MCkge1xuXHQgICAgICAgICAgICByZXN1bHQgPSBcIjBcIiArIHJlc3VsdDtcblx0ICAgICAgICB9XG5cdCAgICAgICAgcmVzdWx0ID0gZ2V0Q2hlY2tzdW1BZGRyZXNzKFwiMHhcIiArIHJlc3VsdCk7XG5cdCAgICB9XG5cdCAgICBlbHNlIHtcblx0ICAgICAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwiaW52YWxpZCBhZGRyZXNzXCIsIFwiYWRkcmVzc1wiLCBhZGRyZXNzKTtcblx0ICAgIH1cblx0ICAgIHJldHVybiByZXN1bHQ7XG5cdH1cblx0ZXhwb3J0cy5nZXRBZGRyZXNzID0gZ2V0QWRkcmVzcztcblx0ZnVuY3Rpb24gaXNBZGRyZXNzKGFkZHJlc3MpIHtcblx0ICAgIHRyeSB7XG5cdCAgICAgICAgZ2V0QWRkcmVzcyhhZGRyZXNzKTtcblx0ICAgICAgICByZXR1cm4gdHJ1ZTtcblx0ICAgIH1cblx0ICAgIGNhdGNoIChlcnJvcikgeyB9XG5cdCAgICByZXR1cm4gZmFsc2U7XG5cdH1cblx0ZXhwb3J0cy5pc0FkZHJlc3MgPSBpc0FkZHJlc3M7XG5cdGZ1bmN0aW9uIGdldEljYXBBZGRyZXNzKGFkZHJlc3MpIHtcblx0ICAgIHZhciBiYXNlMzYgPSAoMCwgbGliJDIuX2Jhc2UxNlRvMzYpKGdldEFkZHJlc3MoYWRkcmVzcykuc3Vic3RyaW5nKDIpKS50b1VwcGVyQ2FzZSgpO1xuXHQgICAgd2hpbGUgKGJhc2UzNi5sZW5ndGggPCAzMCkge1xuXHQgICAgICAgIGJhc2UzNiA9IFwiMFwiICsgYmFzZTM2O1xuXHQgICAgfVxuXHQgICAgcmV0dXJuIFwiWEVcIiArIGliYW5DaGVja3N1bShcIlhFMDBcIiArIGJhc2UzNikgKyBiYXNlMzY7XG5cdH1cblx0ZXhwb3J0cy5nZXRJY2FwQWRkcmVzcyA9IGdldEljYXBBZGRyZXNzO1xuXHQvLyBodHRwOi8vZXRoZXJldW0uc3RhY2tleGNoYW5nZS5jb20vcXVlc3Rpb25zLzc2MC9ob3ctaXMtdGhlLWFkZHJlc3Mtb2YtYW4tZXRoZXJldW0tY29udHJhY3QtY29tcHV0ZWRcblx0ZnVuY3Rpb24gZ2V0Q29udHJhY3RBZGRyZXNzKHRyYW5zYWN0aW9uKSB7XG5cdCAgICB2YXIgZnJvbSA9IG51bGw7XG5cdCAgICB0cnkge1xuXHQgICAgICAgIGZyb20gPSBnZXRBZGRyZXNzKHRyYW5zYWN0aW9uLmZyb20pO1xuXHQgICAgfVxuXHQgICAgY2F0Y2ggKGVycm9yKSB7XG5cdCAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcIm1pc3NpbmcgZnJvbSBhZGRyZXNzXCIsIFwidHJhbnNhY3Rpb25cIiwgdHJhbnNhY3Rpb24pO1xuXHQgICAgfVxuXHQgICAgdmFyIG5vbmNlID0gKDAsIGxpYiQxLnN0cmlwWmVyb3MpKCgwLCBsaWIkMS5hcnJheWlmeSkobGliJDIuQmlnTnVtYmVyLmZyb20odHJhbnNhY3Rpb24ubm9uY2UpLnRvSGV4U3RyaW5nKCkpKTtcblx0ICAgIHJldHVybiBnZXRBZGRyZXNzKCgwLCBsaWIkMS5oZXhEYXRhU2xpY2UpKCgwLCBsaWIkNC5rZWNjYWsyNTYpKCgwLCBsaWIkNS5lbmNvZGUpKFtmcm9tLCBub25jZV0pKSwgMTIpKTtcblx0fVxuXHRleHBvcnRzLmdldENvbnRyYWN0QWRkcmVzcyA9IGdldENvbnRyYWN0QWRkcmVzcztcblx0ZnVuY3Rpb24gZ2V0Q3JlYXRlMkFkZHJlc3MoZnJvbSwgc2FsdCwgaW5pdENvZGVIYXNoKSB7XG5cdCAgICBpZiAoKDAsIGxpYiQxLmhleERhdGFMZW5ndGgpKHNhbHQpICE9PSAzMikge1xuXHQgICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJzYWx0IG11c3QgYmUgMzIgYnl0ZXNcIiwgXCJzYWx0XCIsIHNhbHQpO1xuXHQgICAgfVxuXHQgICAgaWYgKCgwLCBsaWIkMS5oZXhEYXRhTGVuZ3RoKShpbml0Q29kZUhhc2gpICE9PSAzMikge1xuXHQgICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJpbml0Q29kZUhhc2ggbXVzdCBiZSAzMiBieXRlc1wiLCBcImluaXRDb2RlSGFzaFwiLCBpbml0Q29kZUhhc2gpO1xuXHQgICAgfVxuXHQgICAgcmV0dXJuIGdldEFkZHJlc3MoKDAsIGxpYiQxLmhleERhdGFTbGljZSkoKDAsIGxpYiQ0LmtlY2NhazI1NikoKDAsIGxpYiQxLmNvbmNhdCkoW1wiMHhmZlwiLCBnZXRBZGRyZXNzKGZyb20pLCBzYWx0LCBpbml0Q29kZUhhc2hdKSksIDEyKSk7XG5cdH1cblx0ZXhwb3J0cy5nZXRDcmVhdGUyQWRkcmVzcyA9IGdldENyZWF0ZTJBZGRyZXNzO1xuXG5cdH0pO1xuXG5cdHZhciBpbmRleCQ2ID0gLypAX19QVVJFX18qL2dldERlZmF1bHRFeHBvcnRGcm9tQ2pzKGxpYiQ2KTtcblxuXHR2YXIgYWRkcmVzcyA9IGNyZWF0ZUNvbW1vbmpzTW9kdWxlKGZ1bmN0aW9uIChtb2R1bGUsIGV4cG9ydHMpIHtcblx0XCJ1c2Ugc3RyaWN0XCI7XG5cdHZhciBfX2V4dGVuZHMgPSAoY29tbW9uanNHbG9iYWwgJiYgY29tbW9uanNHbG9iYWwuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuXHQgICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBmdW5jdGlvbiAoZCwgYikge1xuXHQgICAgICAgIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcblx0ICAgICAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuXHQgICAgICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoYiwgcCkpIGRbcF0gPSBiW3BdOyB9O1xuXHQgICAgICAgIHJldHVybiBleHRlbmRTdGF0aWNzKGQsIGIpO1xuXHQgICAgfTtcblx0ICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuXHQgICAgICAgIGlmICh0eXBlb2YgYiAhPT0gXCJmdW5jdGlvblwiICYmIGIgIT09IG51bGwpXG5cdCAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDbGFzcyBleHRlbmRzIHZhbHVlIFwiICsgU3RyaW5nKGIpICsgXCIgaXMgbm90IGEgY29uc3RydWN0b3Igb3IgbnVsbFwiKTtcblx0ICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuXHQgICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuXHQgICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcblx0ICAgIH07XG5cdH0pKCk7XG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcblx0ZXhwb3J0cy5BZGRyZXNzQ29kZXIgPSB2b2lkIDA7XG5cblxuXG5cdHZhciBBZGRyZXNzQ29kZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG5cdCAgICBfX2V4dGVuZHMoQWRkcmVzc0NvZGVyLCBfc3VwZXIpO1xuXHQgICAgZnVuY3Rpb24gQWRkcmVzc0NvZGVyKGxvY2FsTmFtZSkge1xuXHQgICAgICAgIHJldHVybiBfc3VwZXIuY2FsbCh0aGlzLCBcImFkZHJlc3NcIiwgXCJhZGRyZXNzXCIsIGxvY2FsTmFtZSwgZmFsc2UpIHx8IHRoaXM7XG5cdCAgICB9XG5cdCAgICBBZGRyZXNzQ29kZXIucHJvdG90eXBlLmRlZmF1bHRWYWx1ZSA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICByZXR1cm4gXCIweDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDBcIjtcblx0ICAgIH07XG5cdCAgICBBZGRyZXNzQ29kZXIucHJvdG90eXBlLmVuY29kZSA9IGZ1bmN0aW9uICh3cml0ZXIsIHZhbHVlKSB7XG5cdCAgICAgICAgdHJ5IHtcblx0ICAgICAgICAgICAgdmFsdWUgPSAoMCwgbGliJDYuZ2V0QWRkcmVzcykodmFsdWUpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBjYXRjaCAoZXJyb3IpIHtcblx0ICAgICAgICAgICAgdGhpcy5fdGhyb3dFcnJvcihlcnJvci5tZXNzYWdlLCB2YWx1ZSk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHJldHVybiB3cml0ZXIud3JpdGVWYWx1ZSh2YWx1ZSk7XG5cdCAgICB9O1xuXHQgICAgQWRkcmVzc0NvZGVyLnByb3RvdHlwZS5kZWNvZGUgPSBmdW5jdGlvbiAocmVhZGVyKSB7XG5cdCAgICAgICAgcmV0dXJuICgwLCBsaWIkNi5nZXRBZGRyZXNzKSgoMCwgbGliJDEuaGV4WmVyb1BhZCkocmVhZGVyLnJlYWRWYWx1ZSgpLnRvSGV4U3RyaW5nKCksIDIwKSk7XG5cdCAgICB9O1xuXHQgICAgcmV0dXJuIEFkZHJlc3NDb2Rlcjtcblx0fShhYnN0cmFjdENvZGVyLkNvZGVyKSk7XG5cdGV4cG9ydHMuQWRkcmVzc0NvZGVyID0gQWRkcmVzc0NvZGVyO1xuXG5cdH0pO1xuXG5cdHZhciBhZGRyZXNzJDEgPSAvKkBfX1BVUkVfXyovZ2V0RGVmYXVsdEV4cG9ydEZyb21DanMoYWRkcmVzcyk7XG5cblx0dmFyIGFub255bW91cyA9IGNyZWF0ZUNvbW1vbmpzTW9kdWxlKGZ1bmN0aW9uIChtb2R1bGUsIGV4cG9ydHMpIHtcblx0XCJ1c2Ugc3RyaWN0XCI7XG5cdHZhciBfX2V4dGVuZHMgPSAoY29tbW9uanNHbG9iYWwgJiYgY29tbW9uanNHbG9iYWwuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuXHQgICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBmdW5jdGlvbiAoZCwgYikge1xuXHQgICAgICAgIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcblx0ICAgICAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuXHQgICAgICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoYiwgcCkpIGRbcF0gPSBiW3BdOyB9O1xuXHQgICAgICAgIHJldHVybiBleHRlbmRTdGF0aWNzKGQsIGIpO1xuXHQgICAgfTtcblx0ICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuXHQgICAgICAgIGlmICh0eXBlb2YgYiAhPT0gXCJmdW5jdGlvblwiICYmIGIgIT09IG51bGwpXG5cdCAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDbGFzcyBleHRlbmRzIHZhbHVlIFwiICsgU3RyaW5nKGIpICsgXCIgaXMgbm90IGEgY29uc3RydWN0b3Igb3IgbnVsbFwiKTtcblx0ICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuXHQgICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuXHQgICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcblx0ICAgIH07XG5cdH0pKCk7XG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcblx0ZXhwb3J0cy5Bbm9ueW1vdXNDb2RlciA9IHZvaWQgMDtcblxuXHQvLyBDbG9uZXMgdGhlIGZ1bmN0aW9uYWxpdHkgb2YgYW4gZXhpc3RpbmcgQ29kZXIsIGJ1dCB3aXRob3V0IGEgbG9jYWxOYW1lXG5cdHZhciBBbm9ueW1vdXNDb2RlciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcblx0ICAgIF9fZXh0ZW5kcyhBbm9ueW1vdXNDb2RlciwgX3N1cGVyKTtcblx0ICAgIGZ1bmN0aW9uIEFub255bW91c0NvZGVyKGNvZGVyKSB7XG5cdCAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgY29kZXIubmFtZSwgY29kZXIudHlwZSwgdW5kZWZpbmVkLCBjb2Rlci5keW5hbWljKSB8fCB0aGlzO1xuXHQgICAgICAgIF90aGlzLmNvZGVyID0gY29kZXI7XG5cdCAgICAgICAgcmV0dXJuIF90aGlzO1xuXHQgICAgfVxuXHQgICAgQW5vbnltb3VzQ29kZXIucHJvdG90eXBlLmRlZmF1bHRWYWx1ZSA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICByZXR1cm4gdGhpcy5jb2Rlci5kZWZhdWx0VmFsdWUoKTtcblx0ICAgIH07XG5cdCAgICBBbm9ueW1vdXNDb2Rlci5wcm90b3R5cGUuZW5jb2RlID0gZnVuY3Rpb24gKHdyaXRlciwgdmFsdWUpIHtcblx0ICAgICAgICByZXR1cm4gdGhpcy5jb2Rlci5lbmNvZGUod3JpdGVyLCB2YWx1ZSk7XG5cdCAgICB9O1xuXHQgICAgQW5vbnltb3VzQ29kZXIucHJvdG90eXBlLmRlY29kZSA9IGZ1bmN0aW9uIChyZWFkZXIpIHtcblx0ICAgICAgICByZXR1cm4gdGhpcy5jb2Rlci5kZWNvZGUocmVhZGVyKTtcblx0ICAgIH07XG5cdCAgICByZXR1cm4gQW5vbnltb3VzQ29kZXI7XG5cdH0oYWJzdHJhY3RDb2Rlci5Db2RlcikpO1xuXHRleHBvcnRzLkFub255bW91c0NvZGVyID0gQW5vbnltb3VzQ29kZXI7XG5cblx0fSk7XG5cblx0dmFyIGFub255bW91cyQxID0gLypAX19QVVJFX18qL2dldERlZmF1bHRFeHBvcnRGcm9tQ2pzKGFub255bW91cyk7XG5cblx0dmFyIGFycmF5ID0gY3JlYXRlQ29tbW9uanNNb2R1bGUoZnVuY3Rpb24gKG1vZHVsZSwgZXhwb3J0cykge1xuXHRcInVzZSBzdHJpY3RcIjtcblx0dmFyIF9fZXh0ZW5kcyA9IChjb21tb25qc0dsb2JhbCAmJiBjb21tb25qc0dsb2JhbC5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG5cdCAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IGZ1bmN0aW9uIChkLCBiKSB7XG5cdCAgICAgICAgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuXHQgICAgICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG5cdCAgICAgICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChiLCBwKSkgZFtwXSA9IGJbcF07IH07XG5cdCAgICAgICAgcmV0dXJuIGV4dGVuZFN0YXRpY3MoZCwgYik7XG5cdCAgICB9O1xuXHQgICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG5cdCAgICAgICAgaWYgKHR5cGVvZiBiICE9PSBcImZ1bmN0aW9uXCIgJiYgYiAhPT0gbnVsbClcblx0ICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNsYXNzIGV4dGVuZHMgdmFsdWUgXCIgKyBTdHJpbmcoYikgKyBcIiBpcyBub3QgYSBjb25zdHJ1Y3RvciBvciBudWxsXCIpO1xuXHQgICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG5cdCAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG5cdCAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuXHQgICAgfTtcblx0fSkoKTtcblx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuXHRleHBvcnRzLkFycmF5Q29kZXIgPSBleHBvcnRzLnVucGFjayA9IGV4cG9ydHMucGFjayA9IHZvaWQgMDtcblxuXG5cdHZhciBsb2dnZXIgPSBuZXcgbGliLkxvZ2dlcihfdmVyc2lvbiQ4LnZlcnNpb24pO1xuXG5cblx0ZnVuY3Rpb24gcGFjayh3cml0ZXIsIGNvZGVycywgdmFsdWVzKSB7XG5cdCAgICB2YXIgYXJyYXlWYWx1ZXMgPSBudWxsO1xuXHQgICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWVzKSkge1xuXHQgICAgICAgIGFycmF5VmFsdWVzID0gdmFsdWVzO1xuXHQgICAgfVxuXHQgICAgZWxzZSBpZiAodmFsdWVzICYmIHR5cGVvZiAodmFsdWVzKSA9PT0gXCJvYmplY3RcIikge1xuXHQgICAgICAgIHZhciB1bmlxdWVfMSA9IHt9O1xuXHQgICAgICAgIGFycmF5VmFsdWVzID0gY29kZXJzLm1hcChmdW5jdGlvbiAoY29kZXIpIHtcblx0ICAgICAgICAgICAgdmFyIG5hbWUgPSBjb2Rlci5sb2NhbE5hbWU7XG5cdCAgICAgICAgICAgIGlmICghbmFtZSkge1xuXHQgICAgICAgICAgICAgICAgbG9nZ2VyLnRocm93RXJyb3IoXCJjYW5ub3QgZW5jb2RlIG9iamVjdCBmb3Igc2lnbmF0dXJlIHdpdGggbWlzc2luZyBuYW1lc1wiLCBsaWIuTG9nZ2VyLmVycm9ycy5JTlZBTElEX0FSR1VNRU5ULCB7XG5cdCAgICAgICAgICAgICAgICAgICAgYXJndW1lbnQ6IFwidmFsdWVzXCIsXG5cdCAgICAgICAgICAgICAgICAgICAgY29kZXI6IGNvZGVyLFxuXHQgICAgICAgICAgICAgICAgICAgIHZhbHVlOiB2YWx1ZXNcblx0ICAgICAgICAgICAgICAgIH0pO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIGlmICh1bmlxdWVfMVtuYW1lXSkge1xuXHQgICAgICAgICAgICAgICAgbG9nZ2VyLnRocm93RXJyb3IoXCJjYW5ub3QgZW5jb2RlIG9iamVjdCBmb3Igc2lnbmF0dXJlIHdpdGggZHVwbGljYXRlIG5hbWVzXCIsIGxpYi5Mb2dnZXIuZXJyb3JzLklOVkFMSURfQVJHVU1FTlQsIHtcblx0ICAgICAgICAgICAgICAgICAgICBhcmd1bWVudDogXCJ2YWx1ZXNcIixcblx0ICAgICAgICAgICAgICAgICAgICBjb2RlcjogY29kZXIsXG5cdCAgICAgICAgICAgICAgICAgICAgdmFsdWU6IHZhbHVlc1xuXHQgICAgICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgdW5pcXVlXzFbbmFtZV0gPSB0cnVlO1xuXHQgICAgICAgICAgICByZXR1cm4gdmFsdWVzW25hbWVdO1xuXHQgICAgICAgIH0pO1xuXHQgICAgfVxuXHQgICAgZWxzZSB7XG5cdCAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcImludmFsaWQgdHVwbGUgdmFsdWVcIiwgXCJ0dXBsZVwiLCB2YWx1ZXMpO1xuXHQgICAgfVxuXHQgICAgaWYgKGNvZGVycy5sZW5ndGggIT09IGFycmF5VmFsdWVzLmxlbmd0aCkge1xuXHQgICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJ0eXBlcy92YWx1ZSBsZW5ndGggbWlzbWF0Y2hcIiwgXCJ0dXBsZVwiLCB2YWx1ZXMpO1xuXHQgICAgfVxuXHQgICAgdmFyIHN0YXRpY1dyaXRlciA9IG5ldyBhYnN0cmFjdENvZGVyLldyaXRlcih3cml0ZXIud29yZFNpemUpO1xuXHQgICAgdmFyIGR5bmFtaWNXcml0ZXIgPSBuZXcgYWJzdHJhY3RDb2Rlci5Xcml0ZXIod3JpdGVyLndvcmRTaXplKTtcblx0ICAgIHZhciB1cGRhdGVGdW5jcyA9IFtdO1xuXHQgICAgY29kZXJzLmZvckVhY2goZnVuY3Rpb24gKGNvZGVyLCBpbmRleCkge1xuXHQgICAgICAgIHZhciB2YWx1ZSA9IGFycmF5VmFsdWVzW2luZGV4XTtcblx0ICAgICAgICBpZiAoY29kZXIuZHluYW1pYykge1xuXHQgICAgICAgICAgICAvLyBHZXQgY3VycmVudCBkeW5hbWljIG9mZnNldCAoZm9yIHRoZSBmdXR1cmUgcG9pbnRlcilcblx0ICAgICAgICAgICAgdmFyIGR5bmFtaWNPZmZzZXRfMSA9IGR5bmFtaWNXcml0ZXIubGVuZ3RoO1xuXHQgICAgICAgICAgICAvLyBFbmNvZGUgdGhlIGR5bmFtaWMgdmFsdWUgaW50byB0aGUgZHluYW1pY1dyaXRlclxuXHQgICAgICAgICAgICBjb2Rlci5lbmNvZGUoZHluYW1pY1dyaXRlciwgdmFsdWUpO1xuXHQgICAgICAgICAgICAvLyBQcmVwYXJlIHRvIHBvcHVsYXRlIHRoZSBjb3JyZWN0IG9mZnNldCBvbmNlIHdlIGFyZSBkb25lXG5cdCAgICAgICAgICAgIHZhciB1cGRhdGVGdW5jXzEgPSBzdGF0aWNXcml0ZXIud3JpdGVVcGRhdGFibGVWYWx1ZSgpO1xuXHQgICAgICAgICAgICB1cGRhdGVGdW5jcy5wdXNoKGZ1bmN0aW9uIChiYXNlT2Zmc2V0KSB7XG5cdCAgICAgICAgICAgICAgICB1cGRhdGVGdW5jXzEoYmFzZU9mZnNldCArIGR5bmFtaWNPZmZzZXRfMSk7XG5cdCAgICAgICAgICAgIH0pO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBlbHNlIHtcblx0ICAgICAgICAgICAgY29kZXIuZW5jb2RlKHN0YXRpY1dyaXRlciwgdmFsdWUpO1xuXHQgICAgICAgIH1cblx0ICAgIH0pO1xuXHQgICAgLy8gQmFja2ZpbGwgYWxsIHRoZSBkeW5hbWljIG9mZnNldHMsIG5vdyB0aGF0IHdlIGtub3cgdGhlIHN0YXRpYyBsZW5ndGhcblx0ICAgIHVwZGF0ZUZ1bmNzLmZvckVhY2goZnVuY3Rpb24gKGZ1bmMpIHsgZnVuYyhzdGF0aWNXcml0ZXIubGVuZ3RoKTsgfSk7XG5cdCAgICB2YXIgbGVuZ3RoID0gd3JpdGVyLmFwcGVuZFdyaXRlcihzdGF0aWNXcml0ZXIpO1xuXHQgICAgbGVuZ3RoICs9IHdyaXRlci5hcHBlbmRXcml0ZXIoZHluYW1pY1dyaXRlcik7XG5cdCAgICByZXR1cm4gbGVuZ3RoO1xuXHR9XG5cdGV4cG9ydHMucGFjayA9IHBhY2s7XG5cdGZ1bmN0aW9uIHVucGFjayhyZWFkZXIsIGNvZGVycykge1xuXHQgICAgdmFyIHZhbHVlcyA9IFtdO1xuXHQgICAgLy8gQSByZWFkZXIgYW5jaG9yZWQgdG8gdGhpcyBiYXNlXG5cdCAgICB2YXIgYmFzZVJlYWRlciA9IHJlYWRlci5zdWJSZWFkZXIoMCk7XG5cdCAgICBjb2RlcnMuZm9yRWFjaChmdW5jdGlvbiAoY29kZXIpIHtcblx0ICAgICAgICB2YXIgdmFsdWUgPSBudWxsO1xuXHQgICAgICAgIGlmIChjb2Rlci5keW5hbWljKSB7XG5cdCAgICAgICAgICAgIHZhciBvZmZzZXQgPSByZWFkZXIucmVhZFZhbHVlKCk7XG5cdCAgICAgICAgICAgIHZhciBvZmZzZXRSZWFkZXIgPSBiYXNlUmVhZGVyLnN1YlJlYWRlcihvZmZzZXQudG9OdW1iZXIoKSk7XG5cdCAgICAgICAgICAgIHRyeSB7XG5cdCAgICAgICAgICAgICAgICB2YWx1ZSA9IGNvZGVyLmRlY29kZShvZmZzZXRSZWFkZXIpO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuXHQgICAgICAgICAgICAgICAgLy8gQ2Fubm90IHJlY292ZXIgZnJvbSB0aGlzXG5cdCAgICAgICAgICAgICAgICBpZiAoZXJyb3IuY29kZSA9PT0gbGliLkxvZ2dlci5lcnJvcnMuQlVGRkVSX09WRVJSVU4pIHtcblx0ICAgICAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgIHZhbHVlID0gZXJyb3I7XG5cdCAgICAgICAgICAgICAgICB2YWx1ZS5iYXNlVHlwZSA9IGNvZGVyLm5hbWU7XG5cdCAgICAgICAgICAgICAgICB2YWx1ZS5uYW1lID0gY29kZXIubG9jYWxOYW1lO1xuXHQgICAgICAgICAgICAgICAgdmFsdWUudHlwZSA9IGNvZGVyLnR5cGU7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9XG5cdCAgICAgICAgZWxzZSB7XG5cdCAgICAgICAgICAgIHRyeSB7XG5cdCAgICAgICAgICAgICAgICB2YWx1ZSA9IGNvZGVyLmRlY29kZShyZWFkZXIpO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuXHQgICAgICAgICAgICAgICAgLy8gQ2Fubm90IHJlY292ZXIgZnJvbSB0aGlzXG5cdCAgICAgICAgICAgICAgICBpZiAoZXJyb3IuY29kZSA9PT0gbGliLkxvZ2dlci5lcnJvcnMuQlVGRkVSX09WRVJSVU4pIHtcblx0ICAgICAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgIHZhbHVlID0gZXJyb3I7XG5cdCAgICAgICAgICAgICAgICB2YWx1ZS5iYXNlVHlwZSA9IGNvZGVyLm5hbWU7XG5cdCAgICAgICAgICAgICAgICB2YWx1ZS5uYW1lID0gY29kZXIubG9jYWxOYW1lO1xuXHQgICAgICAgICAgICAgICAgdmFsdWUudHlwZSA9IGNvZGVyLnR5cGU7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9XG5cdCAgICAgICAgaWYgKHZhbHVlICE9IHVuZGVmaW5lZCkge1xuXHQgICAgICAgICAgICB2YWx1ZXMucHVzaCh2YWx1ZSk7XG5cdCAgICAgICAgfVxuXHQgICAgfSk7XG5cdCAgICAvLyBXZSBvbmx5IG91dHB1dCBuYW1lZCBwcm9wZXJ0aWVzIGZvciB1bmlxdWVseSBuYW1lZCBjb2RlcnNcblx0ICAgIHZhciB1bmlxdWVOYW1lcyA9IGNvZGVycy5yZWR1Y2UoZnVuY3Rpb24gKGFjY3VtLCBjb2Rlcikge1xuXHQgICAgICAgIHZhciBuYW1lID0gY29kZXIubG9jYWxOYW1lO1xuXHQgICAgICAgIGlmIChuYW1lKSB7XG5cdCAgICAgICAgICAgIGlmICghYWNjdW1bbmFtZV0pIHtcblx0ICAgICAgICAgICAgICAgIGFjY3VtW25hbWVdID0gMDtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICBhY2N1bVtuYW1lXSsrO1xuXHQgICAgICAgIH1cblx0ICAgICAgICByZXR1cm4gYWNjdW07XG5cdCAgICB9LCB7fSk7XG5cdCAgICAvLyBBZGQgYW55IG5hbWVkIHBhcmFtZXRlcnMgKGkuZS4gdHVwbGVzKVxuXHQgICAgY29kZXJzLmZvckVhY2goZnVuY3Rpb24gKGNvZGVyLCBpbmRleCkge1xuXHQgICAgICAgIHZhciBuYW1lID0gY29kZXIubG9jYWxOYW1lO1xuXHQgICAgICAgIGlmICghbmFtZSB8fCB1bmlxdWVOYW1lc1tuYW1lXSAhPT0gMSkge1xuXHQgICAgICAgICAgICByZXR1cm47XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGlmIChuYW1lID09PSBcImxlbmd0aFwiKSB7XG5cdCAgICAgICAgICAgIG5hbWUgPSBcIl9sZW5ndGhcIjtcblx0ICAgICAgICB9XG5cdCAgICAgICAgaWYgKHZhbHVlc1tuYW1lXSAhPSBudWxsKSB7XG5cdCAgICAgICAgICAgIHJldHVybjtcblx0ICAgICAgICB9XG5cdCAgICAgICAgdmFyIHZhbHVlID0gdmFsdWVzW2luZGV4XTtcblx0ICAgICAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBFcnJvcikge1xuXHQgICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodmFsdWVzLCBuYW1lLCB7XG5cdCAgICAgICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuXHQgICAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHRocm93IHZhbHVlOyB9XG5cdCAgICAgICAgICAgIH0pO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBlbHNlIHtcblx0ICAgICAgICAgICAgdmFsdWVzW25hbWVdID0gdmFsdWU7XG5cdCAgICAgICAgfVxuXHQgICAgfSk7XG5cdCAgICB2YXIgX2xvb3BfMSA9IGZ1bmN0aW9uIChpKSB7XG5cdCAgICAgICAgdmFyIHZhbHVlID0gdmFsdWVzW2ldO1xuXHQgICAgICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIEVycm9yKSB7XG5cdCAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh2YWx1ZXMsIGksIHtcblx0ICAgICAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG5cdCAgICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgdGhyb3cgdmFsdWU7IH1cblx0ICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgfVxuXHQgICAgfTtcblx0ICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdmFsdWVzLmxlbmd0aDsgaSsrKSB7XG5cdCAgICAgICAgX2xvb3BfMShpKTtcblx0ICAgIH1cblx0ICAgIHJldHVybiBPYmplY3QuZnJlZXplKHZhbHVlcyk7XG5cdH1cblx0ZXhwb3J0cy51bnBhY2sgPSB1bnBhY2s7XG5cdHZhciBBcnJheUNvZGVyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuXHQgICAgX19leHRlbmRzKEFycmF5Q29kZXIsIF9zdXBlcik7XG5cdCAgICBmdW5jdGlvbiBBcnJheUNvZGVyKGNvZGVyLCBsZW5ndGgsIGxvY2FsTmFtZSkge1xuXHQgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cdCAgICAgICAgdmFyIHR5cGUgPSAoY29kZXIudHlwZSArIFwiW1wiICsgKGxlbmd0aCA+PSAwID8gbGVuZ3RoIDogXCJcIikgKyBcIl1cIik7XG5cdCAgICAgICAgdmFyIGR5bmFtaWMgPSAobGVuZ3RoID09PSAtMSB8fCBjb2Rlci5keW5hbWljKTtcblx0ICAgICAgICBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIFwiYXJyYXlcIiwgdHlwZSwgbG9jYWxOYW1lLCBkeW5hbWljKSB8fCB0aGlzO1xuXHQgICAgICAgIF90aGlzLmNvZGVyID0gY29kZXI7XG5cdCAgICAgICAgX3RoaXMubGVuZ3RoID0gbGVuZ3RoO1xuXHQgICAgICAgIHJldHVybiBfdGhpcztcblx0ICAgIH1cblx0ICAgIEFycmF5Q29kZXIucHJvdG90eXBlLmRlZmF1bHRWYWx1ZSA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAvLyBWZXJpZmllcyB0aGUgY2hpbGQgY29kZXIgaXMgdmFsaWQgKGV2ZW4gaWYgdGhlIGFycmF5IGlzIGR5bmFtaWMgb3IgMC1sZW5ndGgpXG5cdCAgICAgICAgdmFyIGRlZmF1bHRDaGlsZCA9IHRoaXMuY29kZXIuZGVmYXVsdFZhbHVlKCk7XG5cdCAgICAgICAgdmFyIHJlc3VsdCA9IFtdO1xuXHQgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkrKykge1xuXHQgICAgICAgICAgICByZXN1bHQucHVzaChkZWZhdWx0Q2hpbGQpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICByZXR1cm4gcmVzdWx0O1xuXHQgICAgfTtcblx0ICAgIEFycmF5Q29kZXIucHJvdG90eXBlLmVuY29kZSA9IGZ1bmN0aW9uICh3cml0ZXIsIHZhbHVlKSB7XG5cdCAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuXHQgICAgICAgICAgICB0aGlzLl90aHJvd0Vycm9yKFwiZXhwZWN0ZWQgYXJyYXkgdmFsdWVcIiwgdmFsdWUpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICB2YXIgY291bnQgPSB0aGlzLmxlbmd0aDtcblx0ICAgICAgICBpZiAoY291bnQgPT09IC0xKSB7XG5cdCAgICAgICAgICAgIGNvdW50ID0gdmFsdWUubGVuZ3RoO1xuXHQgICAgICAgICAgICB3cml0ZXIud3JpdGVWYWx1ZSh2YWx1ZS5sZW5ndGgpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBsb2dnZXIuY2hlY2tBcmd1bWVudENvdW50KHZhbHVlLmxlbmd0aCwgY291bnQsIFwiY29kZXIgYXJyYXlcIiArICh0aGlzLmxvY2FsTmFtZSA/IChcIiBcIiArIHRoaXMubG9jYWxOYW1lKSA6IFwiXCIpKTtcblx0ICAgICAgICB2YXIgY29kZXJzID0gW107XG5cdCAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB2YWx1ZS5sZW5ndGg7IGkrKykge1xuXHQgICAgICAgICAgICBjb2RlcnMucHVzaCh0aGlzLmNvZGVyKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgcmV0dXJuIHBhY2sod3JpdGVyLCBjb2RlcnMsIHZhbHVlKTtcblx0ICAgIH07XG5cdCAgICBBcnJheUNvZGVyLnByb3RvdHlwZS5kZWNvZGUgPSBmdW5jdGlvbiAocmVhZGVyKSB7XG5cdCAgICAgICAgdmFyIGNvdW50ID0gdGhpcy5sZW5ndGg7XG5cdCAgICAgICAgaWYgKGNvdW50ID09PSAtMSkge1xuXHQgICAgICAgICAgICBjb3VudCA9IHJlYWRlci5yZWFkVmFsdWUoKS50b051bWJlcigpO1xuXHQgICAgICAgICAgICAvLyBDaGVjayB0aGF0IHRoZXJlIGlzICpyb3VnaGx5KiBlbm91Z2ggZGF0YSB0byBlbnN1cmVcblx0ICAgICAgICAgICAgLy8gc3RyYXkgcmFuZG9tIGRhdGEgaXMgbm90IGJlaW5nIHJlYWQgYXMgYSBsZW5ndGguIEVhY2hcblx0ICAgICAgICAgICAgLy8gc2xvdCByZXF1aXJlcyBhdCBsZWFzdCAzMiBieXRlcyBmb3IgdGhlaXIgdmFsdWUgKG9yIDMyXG5cdCAgICAgICAgICAgIC8vIGJ5dGVzIGFzIGEgbGluayB0byB0aGUgZGF0YSkuIFRoaXMgY291bGQgdXNlIGEgbXVjaFxuXHQgICAgICAgICAgICAvLyB0aWdodGVyIGJvdW5kLCBidXQgd2UgYXJlIGVycm9yaW5nIG9uIHRoZSBzaWRlIG9mIHNhZmV0eS5cblx0ICAgICAgICAgICAgaWYgKGNvdW50ICogMzIgPiByZWFkZXIuX2RhdGEubGVuZ3RoKSB7XG5cdCAgICAgICAgICAgICAgICBsb2dnZXIudGhyb3dFcnJvcihcImluc3VmZmljaWVudCBkYXRhIGxlbmd0aFwiLCBsaWIuTG9nZ2VyLmVycm9ycy5CVUZGRVJfT1ZFUlJVTiwge1xuXHQgICAgICAgICAgICAgICAgICAgIGxlbmd0aDogcmVhZGVyLl9kYXRhLmxlbmd0aCxcblx0ICAgICAgICAgICAgICAgICAgICBjb3VudDogY291bnRcblx0ICAgICAgICAgICAgICAgIH0pO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHZhciBjb2RlcnMgPSBbXTtcblx0ICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNvdW50OyBpKyspIHtcblx0ICAgICAgICAgICAgY29kZXJzLnB1c2gobmV3IGFub255bW91cy5Bbm9ueW1vdXNDb2Rlcih0aGlzLmNvZGVyKSk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHJldHVybiByZWFkZXIuY29lcmNlKHRoaXMubmFtZSwgdW5wYWNrKHJlYWRlciwgY29kZXJzKSk7XG5cdCAgICB9O1xuXHQgICAgcmV0dXJuIEFycmF5Q29kZXI7XG5cdH0oYWJzdHJhY3RDb2Rlci5Db2RlcikpO1xuXHRleHBvcnRzLkFycmF5Q29kZXIgPSBBcnJheUNvZGVyO1xuXG5cdH0pO1xuXG5cdHZhciBhcnJheSQxID0gLypAX19QVVJFX18qL2dldERlZmF1bHRFeHBvcnRGcm9tQ2pzKGFycmF5KTtcblxuXHR2YXIgYm9vbGVhbl8xID0gY3JlYXRlQ29tbW9uanNNb2R1bGUoZnVuY3Rpb24gKG1vZHVsZSwgZXhwb3J0cykge1xuXHRcInVzZSBzdHJpY3RcIjtcblx0dmFyIF9fZXh0ZW5kcyA9IChjb21tb25qc0dsb2JhbCAmJiBjb21tb25qc0dsb2JhbC5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG5cdCAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IGZ1bmN0aW9uIChkLCBiKSB7XG5cdCAgICAgICAgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuXHQgICAgICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG5cdCAgICAgICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChiLCBwKSkgZFtwXSA9IGJbcF07IH07XG5cdCAgICAgICAgcmV0dXJuIGV4dGVuZFN0YXRpY3MoZCwgYik7XG5cdCAgICB9O1xuXHQgICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG5cdCAgICAgICAgaWYgKHR5cGVvZiBiICE9PSBcImZ1bmN0aW9uXCIgJiYgYiAhPT0gbnVsbClcblx0ICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNsYXNzIGV4dGVuZHMgdmFsdWUgXCIgKyBTdHJpbmcoYikgKyBcIiBpcyBub3QgYSBjb25zdHJ1Y3RvciBvciBudWxsXCIpO1xuXHQgICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG5cdCAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG5cdCAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuXHQgICAgfTtcblx0fSkoKTtcblx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuXHRleHBvcnRzLkJvb2xlYW5Db2RlciA9IHZvaWQgMDtcblxuXHR2YXIgQm9vbGVhbkNvZGVyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuXHQgICAgX19leHRlbmRzKEJvb2xlYW5Db2RlciwgX3N1cGVyKTtcblx0ICAgIGZ1bmN0aW9uIEJvb2xlYW5Db2Rlcihsb2NhbE5hbWUpIHtcblx0ICAgICAgICByZXR1cm4gX3N1cGVyLmNhbGwodGhpcywgXCJib29sXCIsIFwiYm9vbFwiLCBsb2NhbE5hbWUsIGZhbHNlKSB8fCB0aGlzO1xuXHQgICAgfVxuXHQgICAgQm9vbGVhbkNvZGVyLnByb3RvdHlwZS5kZWZhdWx0VmFsdWUgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgcmV0dXJuIGZhbHNlO1xuXHQgICAgfTtcblx0ICAgIEJvb2xlYW5Db2Rlci5wcm90b3R5cGUuZW5jb2RlID0gZnVuY3Rpb24gKHdyaXRlciwgdmFsdWUpIHtcblx0ICAgICAgICByZXR1cm4gd3JpdGVyLndyaXRlVmFsdWUodmFsdWUgPyAxIDogMCk7XG5cdCAgICB9O1xuXHQgICAgQm9vbGVhbkNvZGVyLnByb3RvdHlwZS5kZWNvZGUgPSBmdW5jdGlvbiAocmVhZGVyKSB7XG5cdCAgICAgICAgcmV0dXJuIHJlYWRlci5jb2VyY2UodGhpcy50eXBlLCAhcmVhZGVyLnJlYWRWYWx1ZSgpLmlzWmVybygpKTtcblx0ICAgIH07XG5cdCAgICByZXR1cm4gQm9vbGVhbkNvZGVyO1xuXHR9KGFic3RyYWN0Q29kZXIuQ29kZXIpKTtcblx0ZXhwb3J0cy5Cb29sZWFuQ29kZXIgPSBCb29sZWFuQ29kZXI7XG5cblx0fSk7XG5cblx0dmFyIGJvb2xlYW4gPSAvKkBfX1BVUkVfXyovZ2V0RGVmYXVsdEV4cG9ydEZyb21DanMoYm9vbGVhbl8xKTtcblxuXHR2YXIgYnl0ZXMgPSBjcmVhdGVDb21tb25qc01vZHVsZShmdW5jdGlvbiAobW9kdWxlLCBleHBvcnRzKSB7XG5cdFwidXNlIHN0cmljdFwiO1xuXHR2YXIgX19leHRlbmRzID0gKGNvbW1vbmpzR2xvYmFsICYmIGNvbW1vbmpzR2xvYmFsLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcblx0ICAgIHZhciBleHRlbmRTdGF0aWNzID0gZnVuY3Rpb24gKGQsIGIpIHtcblx0ICAgICAgICBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG5cdCAgICAgICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcblx0ICAgICAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGIsIHApKSBkW3BdID0gYltwXTsgfTtcblx0ICAgICAgICByZXR1cm4gZXh0ZW5kU3RhdGljcyhkLCBiKTtcblx0ICAgIH07XG5cdCAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcblx0ICAgICAgICBpZiAodHlwZW9mIGIgIT09IFwiZnVuY3Rpb25cIiAmJiBiICE9PSBudWxsKVxuXHQgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2xhc3MgZXh0ZW5kcyB2YWx1ZSBcIiArIFN0cmluZyhiKSArIFwiIGlzIG5vdCBhIGNvbnN0cnVjdG9yIG9yIG51bGxcIik7XG5cdCAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcblx0ICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cblx0ICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG5cdCAgICB9O1xuXHR9KSgpO1xuXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5cdGV4cG9ydHMuQnl0ZXNDb2RlciA9IGV4cG9ydHMuRHluYW1pY0J5dGVzQ29kZXIgPSB2b2lkIDA7XG5cblxuXHR2YXIgRHluYW1pY0J5dGVzQ29kZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG5cdCAgICBfX2V4dGVuZHMoRHluYW1pY0J5dGVzQ29kZXIsIF9zdXBlcik7XG5cdCAgICBmdW5jdGlvbiBEeW5hbWljQnl0ZXNDb2Rlcih0eXBlLCBsb2NhbE5hbWUpIHtcblx0ICAgICAgICByZXR1cm4gX3N1cGVyLmNhbGwodGhpcywgdHlwZSwgdHlwZSwgbG9jYWxOYW1lLCB0cnVlKSB8fCB0aGlzO1xuXHQgICAgfVxuXHQgICAgRHluYW1pY0J5dGVzQ29kZXIucHJvdG90eXBlLmRlZmF1bHRWYWx1ZSA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICByZXR1cm4gXCIweFwiO1xuXHQgICAgfTtcblx0ICAgIER5bmFtaWNCeXRlc0NvZGVyLnByb3RvdHlwZS5lbmNvZGUgPSBmdW5jdGlvbiAod3JpdGVyLCB2YWx1ZSkge1xuXHQgICAgICAgIHZhbHVlID0gKDAsIGxpYiQxLmFycmF5aWZ5KSh2YWx1ZSk7XG5cdCAgICAgICAgdmFyIGxlbmd0aCA9IHdyaXRlci53cml0ZVZhbHVlKHZhbHVlLmxlbmd0aCk7XG5cdCAgICAgICAgbGVuZ3RoICs9IHdyaXRlci53cml0ZUJ5dGVzKHZhbHVlKTtcblx0ICAgICAgICByZXR1cm4gbGVuZ3RoO1xuXHQgICAgfTtcblx0ICAgIER5bmFtaWNCeXRlc0NvZGVyLnByb3RvdHlwZS5kZWNvZGUgPSBmdW5jdGlvbiAocmVhZGVyKSB7XG5cdCAgICAgICAgcmV0dXJuIHJlYWRlci5yZWFkQnl0ZXMocmVhZGVyLnJlYWRWYWx1ZSgpLnRvTnVtYmVyKCksIHRydWUpO1xuXHQgICAgfTtcblx0ICAgIHJldHVybiBEeW5hbWljQnl0ZXNDb2Rlcjtcblx0fShhYnN0cmFjdENvZGVyLkNvZGVyKSk7XG5cdGV4cG9ydHMuRHluYW1pY0J5dGVzQ29kZXIgPSBEeW5hbWljQnl0ZXNDb2Rlcjtcblx0dmFyIEJ5dGVzQ29kZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG5cdCAgICBfX2V4dGVuZHMoQnl0ZXNDb2RlciwgX3N1cGVyKTtcblx0ICAgIGZ1bmN0aW9uIEJ5dGVzQ29kZXIobG9jYWxOYW1lKSB7XG5cdCAgICAgICAgcmV0dXJuIF9zdXBlci5jYWxsKHRoaXMsIFwiYnl0ZXNcIiwgbG9jYWxOYW1lKSB8fCB0aGlzO1xuXHQgICAgfVxuXHQgICAgQnl0ZXNDb2Rlci5wcm90b3R5cGUuZGVjb2RlID0gZnVuY3Rpb24gKHJlYWRlcikge1xuXHQgICAgICAgIHJldHVybiByZWFkZXIuY29lcmNlKHRoaXMubmFtZSwgKDAsIGxpYiQxLmhleGxpZnkpKF9zdXBlci5wcm90b3R5cGUuZGVjb2RlLmNhbGwodGhpcywgcmVhZGVyKSkpO1xuXHQgICAgfTtcblx0ICAgIHJldHVybiBCeXRlc0NvZGVyO1xuXHR9KER5bmFtaWNCeXRlc0NvZGVyKSk7XG5cdGV4cG9ydHMuQnl0ZXNDb2RlciA9IEJ5dGVzQ29kZXI7XG5cblx0fSk7XG5cblx0dmFyIGJ5dGVzJDEgPSAvKkBfX1BVUkVfXyovZ2V0RGVmYXVsdEV4cG9ydEZyb21DanMoYnl0ZXMpO1xuXG5cdHZhciBmaXhlZEJ5dGVzID0gY3JlYXRlQ29tbW9uanNNb2R1bGUoZnVuY3Rpb24gKG1vZHVsZSwgZXhwb3J0cykge1xuXHRcInVzZSBzdHJpY3RcIjtcblx0dmFyIF9fZXh0ZW5kcyA9IChjb21tb25qc0dsb2JhbCAmJiBjb21tb25qc0dsb2JhbC5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG5cdCAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IGZ1bmN0aW9uIChkLCBiKSB7XG5cdCAgICAgICAgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuXHQgICAgICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG5cdCAgICAgICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChiLCBwKSkgZFtwXSA9IGJbcF07IH07XG5cdCAgICAgICAgcmV0dXJuIGV4dGVuZFN0YXRpY3MoZCwgYik7XG5cdCAgICB9O1xuXHQgICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG5cdCAgICAgICAgaWYgKHR5cGVvZiBiICE9PSBcImZ1bmN0aW9uXCIgJiYgYiAhPT0gbnVsbClcblx0ICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNsYXNzIGV4dGVuZHMgdmFsdWUgXCIgKyBTdHJpbmcoYikgKyBcIiBpcyBub3QgYSBjb25zdHJ1Y3RvciBvciBudWxsXCIpO1xuXHQgICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG5cdCAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG5cdCAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuXHQgICAgfTtcblx0fSkoKTtcblx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuXHRleHBvcnRzLkZpeGVkQnl0ZXNDb2RlciA9IHZvaWQgMDtcblxuXG5cdC8vIEBUT0RPOiBNZXJnZSB0aGlzIHdpdGggYnl0ZXNcblx0dmFyIEZpeGVkQnl0ZXNDb2RlciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcblx0ICAgIF9fZXh0ZW5kcyhGaXhlZEJ5dGVzQ29kZXIsIF9zdXBlcik7XG5cdCAgICBmdW5jdGlvbiBGaXhlZEJ5dGVzQ29kZXIoc2l6ZSwgbG9jYWxOYW1lKSB7XG5cdCAgICAgICAgdmFyIF90aGlzID0gdGhpcztcblx0ICAgICAgICB2YXIgbmFtZSA9IFwiYnl0ZXNcIiArIFN0cmluZyhzaXplKTtcblx0ICAgICAgICBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIG5hbWUsIG5hbWUsIGxvY2FsTmFtZSwgZmFsc2UpIHx8IHRoaXM7XG5cdCAgICAgICAgX3RoaXMuc2l6ZSA9IHNpemU7XG5cdCAgICAgICAgcmV0dXJuIF90aGlzO1xuXHQgICAgfVxuXHQgICAgRml4ZWRCeXRlc0NvZGVyLnByb3RvdHlwZS5kZWZhdWx0VmFsdWUgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgcmV0dXJuIChcIjB4MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMFwiKS5zdWJzdHJpbmcoMCwgMiArIHRoaXMuc2l6ZSAqIDIpO1xuXHQgICAgfTtcblx0ICAgIEZpeGVkQnl0ZXNDb2Rlci5wcm90b3R5cGUuZW5jb2RlID0gZnVuY3Rpb24gKHdyaXRlciwgdmFsdWUpIHtcblx0ICAgICAgICB2YXIgZGF0YSA9ICgwLCBsaWIkMS5hcnJheWlmeSkodmFsdWUpO1xuXHQgICAgICAgIGlmIChkYXRhLmxlbmd0aCAhPT0gdGhpcy5zaXplKSB7XG5cdCAgICAgICAgICAgIHRoaXMuX3Rocm93RXJyb3IoXCJpbmNvcnJlY3QgZGF0YSBsZW5ndGhcIiwgdmFsdWUpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICByZXR1cm4gd3JpdGVyLndyaXRlQnl0ZXMoZGF0YSk7XG5cdCAgICB9O1xuXHQgICAgRml4ZWRCeXRlc0NvZGVyLnByb3RvdHlwZS5kZWNvZGUgPSBmdW5jdGlvbiAocmVhZGVyKSB7XG5cdCAgICAgICAgcmV0dXJuIHJlYWRlci5jb2VyY2UodGhpcy5uYW1lLCAoMCwgbGliJDEuaGV4bGlmeSkocmVhZGVyLnJlYWRCeXRlcyh0aGlzLnNpemUpKSk7XG5cdCAgICB9O1xuXHQgICAgcmV0dXJuIEZpeGVkQnl0ZXNDb2Rlcjtcblx0fShhYnN0cmFjdENvZGVyLkNvZGVyKSk7XG5cdGV4cG9ydHMuRml4ZWRCeXRlc0NvZGVyID0gRml4ZWRCeXRlc0NvZGVyO1xuXG5cdH0pO1xuXG5cdHZhciBmaXhlZEJ5dGVzJDEgPSAvKkBfX1BVUkVfXyovZ2V0RGVmYXVsdEV4cG9ydEZyb21DanMoZml4ZWRCeXRlcyk7XG5cblx0dmFyIF9udWxsID0gY3JlYXRlQ29tbW9uanNNb2R1bGUoZnVuY3Rpb24gKG1vZHVsZSwgZXhwb3J0cykge1xuXHRcInVzZSBzdHJpY3RcIjtcblx0dmFyIF9fZXh0ZW5kcyA9IChjb21tb25qc0dsb2JhbCAmJiBjb21tb25qc0dsb2JhbC5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG5cdCAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IGZ1bmN0aW9uIChkLCBiKSB7XG5cdCAgICAgICAgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuXHQgICAgICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG5cdCAgICAgICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChiLCBwKSkgZFtwXSA9IGJbcF07IH07XG5cdCAgICAgICAgcmV0dXJuIGV4dGVuZFN0YXRpY3MoZCwgYik7XG5cdCAgICB9O1xuXHQgICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG5cdCAgICAgICAgaWYgKHR5cGVvZiBiICE9PSBcImZ1bmN0aW9uXCIgJiYgYiAhPT0gbnVsbClcblx0ICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNsYXNzIGV4dGVuZHMgdmFsdWUgXCIgKyBTdHJpbmcoYikgKyBcIiBpcyBub3QgYSBjb25zdHJ1Y3RvciBvciBudWxsXCIpO1xuXHQgICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG5cdCAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG5cdCAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuXHQgICAgfTtcblx0fSkoKTtcblx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuXHRleHBvcnRzLk51bGxDb2RlciA9IHZvaWQgMDtcblxuXHR2YXIgTnVsbENvZGVyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuXHQgICAgX19leHRlbmRzKE51bGxDb2RlciwgX3N1cGVyKTtcblx0ICAgIGZ1bmN0aW9uIE51bGxDb2Rlcihsb2NhbE5hbWUpIHtcblx0ICAgICAgICByZXR1cm4gX3N1cGVyLmNhbGwodGhpcywgXCJudWxsXCIsIFwiXCIsIGxvY2FsTmFtZSwgZmFsc2UpIHx8IHRoaXM7XG5cdCAgICB9XG5cdCAgICBOdWxsQ29kZXIucHJvdG90eXBlLmRlZmF1bHRWYWx1ZSA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICByZXR1cm4gbnVsbDtcblx0ICAgIH07XG5cdCAgICBOdWxsQ29kZXIucHJvdG90eXBlLmVuY29kZSA9IGZ1bmN0aW9uICh3cml0ZXIsIHZhbHVlKSB7XG5cdCAgICAgICAgaWYgKHZhbHVlICE9IG51bGwpIHtcblx0ICAgICAgICAgICAgdGhpcy5fdGhyb3dFcnJvcihcIm5vdCBudWxsXCIsIHZhbHVlKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgcmV0dXJuIHdyaXRlci53cml0ZUJ5dGVzKFtdKTtcblx0ICAgIH07XG5cdCAgICBOdWxsQ29kZXIucHJvdG90eXBlLmRlY29kZSA9IGZ1bmN0aW9uIChyZWFkZXIpIHtcblx0ICAgICAgICByZWFkZXIucmVhZEJ5dGVzKDApO1xuXHQgICAgICAgIHJldHVybiByZWFkZXIuY29lcmNlKHRoaXMubmFtZSwgbnVsbCk7XG5cdCAgICB9O1xuXHQgICAgcmV0dXJuIE51bGxDb2Rlcjtcblx0fShhYnN0cmFjdENvZGVyLkNvZGVyKSk7XG5cdGV4cG9ydHMuTnVsbENvZGVyID0gTnVsbENvZGVyO1xuXG5cdH0pO1xuXG5cdHZhciBfbnVsbCQxID0gLypAX19QVVJFX18qL2dldERlZmF1bHRFeHBvcnRGcm9tQ2pzKF9udWxsKTtcblxuXHR2YXIgYWRkcmVzc2VzID0gY3JlYXRlQ29tbW9uanNNb2R1bGUoZnVuY3Rpb24gKG1vZHVsZSwgZXhwb3J0cykge1xuXHRcInVzZSBzdHJpY3RcIjtcblx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuXHRleHBvcnRzLkFkZHJlc3NaZXJvID0gdm9pZCAwO1xuXHRleHBvcnRzLkFkZHJlc3NaZXJvID0gXCIweDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDBcIjtcblxuXHR9KTtcblxuXHR2YXIgYWRkcmVzc2VzJDEgPSAvKkBfX1BVUkVfXyovZ2V0RGVmYXVsdEV4cG9ydEZyb21DanMoYWRkcmVzc2VzKTtcblxuXHR2YXIgYmlnbnVtYmVycyA9IGNyZWF0ZUNvbW1vbmpzTW9kdWxlKGZ1bmN0aW9uIChtb2R1bGUsIGV4cG9ydHMpIHtcblx0XCJ1c2Ugc3RyaWN0XCI7XG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcblx0ZXhwb3J0cy5NYXhJbnQyNTYgPSBleHBvcnRzLk1pbkludDI1NiA9IGV4cG9ydHMuTWF4VWludDI1NiA9IGV4cG9ydHMuV2VpUGVyRXRoZXIgPSBleHBvcnRzLlR3byA9IGV4cG9ydHMuT25lID0gZXhwb3J0cy5aZXJvID0gZXhwb3J0cy5OZWdhdGl2ZU9uZSA9IHZvaWQgMDtcblxuXHR2YXIgTmVnYXRpdmVPbmUgPSAoIC8qI19fUFVSRV9fKi9saWIkMi5CaWdOdW1iZXIuZnJvbSgtMSkpO1xuXHRleHBvcnRzLk5lZ2F0aXZlT25lID0gTmVnYXRpdmVPbmU7XG5cdHZhciBaZXJvID0gKCAvKiNfX1BVUkVfXyovbGliJDIuQmlnTnVtYmVyLmZyb20oMCkpO1xuXHRleHBvcnRzLlplcm8gPSBaZXJvO1xuXHR2YXIgT25lID0gKCAvKiNfX1BVUkVfXyovbGliJDIuQmlnTnVtYmVyLmZyb20oMSkpO1xuXHRleHBvcnRzLk9uZSA9IE9uZTtcblx0dmFyIFR3byA9ICggLyojX19QVVJFX18qL2xpYiQyLkJpZ051bWJlci5mcm9tKDIpKTtcblx0ZXhwb3J0cy5Ud28gPSBUd287XG5cdHZhciBXZWlQZXJFdGhlciA9ICggLyojX19QVVJFX18qL2xpYiQyLkJpZ051bWJlci5mcm9tKFwiMTAwMDAwMDAwMDAwMDAwMDAwMFwiKSk7XG5cdGV4cG9ydHMuV2VpUGVyRXRoZXIgPSBXZWlQZXJFdGhlcjtcblx0dmFyIE1heFVpbnQyNTYgPSAoIC8qI19fUFVSRV9fKi9saWIkMi5CaWdOdW1iZXIuZnJvbShcIjB4ZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZlwiKSk7XG5cdGV4cG9ydHMuTWF4VWludDI1NiA9IE1heFVpbnQyNTY7XG5cdHZhciBNaW5JbnQyNTYgPSAoIC8qI19fUFVSRV9fKi9saWIkMi5CaWdOdW1iZXIuZnJvbShcIi0weDgwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDBcIikpO1xuXHRleHBvcnRzLk1pbkludDI1NiA9IE1pbkludDI1Njtcblx0dmFyIE1heEludDI1NiA9ICggLyojX19QVVJFX18qL2xpYiQyLkJpZ051bWJlci5mcm9tKFwiMHg3ZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmXCIpKTtcblx0ZXhwb3J0cy5NYXhJbnQyNTYgPSBNYXhJbnQyNTY7XG5cblx0fSk7XG5cblx0dmFyIGJpZ251bWJlcnMkMSA9IC8qQF9fUFVSRV9fKi9nZXREZWZhdWx0RXhwb3J0RnJvbUNqcyhiaWdudW1iZXJzKTtcblxuXHR2YXIgaGFzaGVzID0gY3JlYXRlQ29tbW9uanNNb2R1bGUoZnVuY3Rpb24gKG1vZHVsZSwgZXhwb3J0cykge1xuXHRcInVzZSBzdHJpY3RcIjtcblx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuXHRleHBvcnRzLkhhc2haZXJvID0gdm9pZCAwO1xuXHRleHBvcnRzLkhhc2haZXJvID0gXCIweDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDBcIjtcblxuXHR9KTtcblxuXHR2YXIgaGFzaGVzJDEgPSAvKkBfX1BVUkVfXyovZ2V0RGVmYXVsdEV4cG9ydEZyb21DanMoaGFzaGVzKTtcblxuXHR2YXIgc3RyaW5ncyA9IGNyZWF0ZUNvbW1vbmpzTW9kdWxlKGZ1bmN0aW9uIChtb2R1bGUsIGV4cG9ydHMpIHtcblx0XCJ1c2Ugc3RyaWN0XCI7XG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcblx0ZXhwb3J0cy5FdGhlclN5bWJvbCA9IHZvaWQgMDtcblx0Ly8gTkZLQyAoY29tcG9zZWQpICAgICAgICAgICAgIC8vIChkZWNvbXBvc2VkKVxuXHRleHBvcnRzLkV0aGVyU3ltYm9sID0gXCJcXHUwMzllXCI7IC8vIFwiXFx1RDgzNVxcdURGNjNcIjtcblxuXHR9KTtcblxuXHR2YXIgc3RyaW5ncyQxID0gLypAX19QVVJFX18qL2dldERlZmF1bHRFeHBvcnRGcm9tQ2pzKHN0cmluZ3MpO1xuXG5cdHZhciBsaWIkNyA9IGNyZWF0ZUNvbW1vbmpzTW9kdWxlKGZ1bmN0aW9uIChtb2R1bGUsIGV4cG9ydHMpIHtcblx0XCJ1c2Ugc3RyaWN0XCI7XG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcblx0ZXhwb3J0cy5FdGhlclN5bWJvbCA9IGV4cG9ydHMuSGFzaFplcm8gPSBleHBvcnRzLk1heEludDI1NiA9IGV4cG9ydHMuTWluSW50MjU2ID0gZXhwb3J0cy5NYXhVaW50MjU2ID0gZXhwb3J0cy5XZWlQZXJFdGhlciA9IGV4cG9ydHMuVHdvID0gZXhwb3J0cy5PbmUgPSBleHBvcnRzLlplcm8gPSBleHBvcnRzLk5lZ2F0aXZlT25lID0gZXhwb3J0cy5BZGRyZXNzWmVybyA9IHZvaWQgMDtcblxuXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJBZGRyZXNzWmVyb1wiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gYWRkcmVzc2VzLkFkZHJlc3NaZXJvOyB9IH0pO1xuXG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIk5lZ2F0aXZlT25lXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBiaWdudW1iZXJzLk5lZ2F0aXZlT25lOyB9IH0pO1xuXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJaZXJvXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBiaWdudW1iZXJzLlplcm87IH0gfSk7XG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIk9uZVwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gYmlnbnVtYmVycy5PbmU7IH0gfSk7XG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlR3b1wiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gYmlnbnVtYmVycy5Ud287IH0gfSk7XG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIldlaVBlckV0aGVyXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBiaWdudW1iZXJzLldlaVBlckV0aGVyOyB9IH0pO1xuXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJNYXhVaW50MjU2XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBiaWdudW1iZXJzLk1heFVpbnQyNTY7IH0gfSk7XG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIk1pbkludDI1NlwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gYmlnbnVtYmVycy5NaW5JbnQyNTY7IH0gfSk7XG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIk1heEludDI1NlwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gYmlnbnVtYmVycy5NYXhJbnQyNTY7IH0gfSk7XG5cblx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiSGFzaFplcm9cIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGhhc2hlcy5IYXNoWmVybzsgfSB9KTtcblxuXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJFdGhlclN5bWJvbFwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gc3RyaW5ncy5FdGhlclN5bWJvbDsgfSB9KTtcblxuXHR9KTtcblxuXHR2YXIgaW5kZXgkNyA9IC8qQF9fUFVSRV9fKi9nZXREZWZhdWx0RXhwb3J0RnJvbUNqcyhsaWIkNyk7XG5cblx0dmFyIG51bWJlciA9IGNyZWF0ZUNvbW1vbmpzTW9kdWxlKGZ1bmN0aW9uIChtb2R1bGUsIGV4cG9ydHMpIHtcblx0XCJ1c2Ugc3RyaWN0XCI7XG5cdHZhciBfX2V4dGVuZHMgPSAoY29tbW9uanNHbG9iYWwgJiYgY29tbW9uanNHbG9iYWwuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuXHQgICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBmdW5jdGlvbiAoZCwgYikge1xuXHQgICAgICAgIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcblx0ICAgICAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuXHQgICAgICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoYiwgcCkpIGRbcF0gPSBiW3BdOyB9O1xuXHQgICAgICAgIHJldHVybiBleHRlbmRTdGF0aWNzKGQsIGIpO1xuXHQgICAgfTtcblx0ICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuXHQgICAgICAgIGlmICh0eXBlb2YgYiAhPT0gXCJmdW5jdGlvblwiICYmIGIgIT09IG51bGwpXG5cdCAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDbGFzcyBleHRlbmRzIHZhbHVlIFwiICsgU3RyaW5nKGIpICsgXCIgaXMgbm90IGEgY29uc3RydWN0b3Igb3IgbnVsbFwiKTtcblx0ICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuXHQgICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuXHQgICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcblx0ICAgIH07XG5cdH0pKCk7XG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcblx0ZXhwb3J0cy5OdW1iZXJDb2RlciA9IHZvaWQgMDtcblxuXG5cblx0dmFyIE51bWJlckNvZGVyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuXHQgICAgX19leHRlbmRzKE51bWJlckNvZGVyLCBfc3VwZXIpO1xuXHQgICAgZnVuY3Rpb24gTnVtYmVyQ29kZXIoc2l6ZSwgc2lnbmVkLCBsb2NhbE5hbWUpIHtcblx0ICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXHQgICAgICAgIHZhciBuYW1lID0gKChzaWduZWQgPyBcImludFwiIDogXCJ1aW50XCIpICsgKHNpemUgKiA4KSk7XG5cdCAgICAgICAgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBuYW1lLCBuYW1lLCBsb2NhbE5hbWUsIGZhbHNlKSB8fCB0aGlzO1xuXHQgICAgICAgIF90aGlzLnNpemUgPSBzaXplO1xuXHQgICAgICAgIF90aGlzLnNpZ25lZCA9IHNpZ25lZDtcblx0ICAgICAgICByZXR1cm4gX3RoaXM7XG5cdCAgICB9XG5cdCAgICBOdW1iZXJDb2Rlci5wcm90b3R5cGUuZGVmYXVsdFZhbHVlID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIHJldHVybiAwO1xuXHQgICAgfTtcblx0ICAgIE51bWJlckNvZGVyLnByb3RvdHlwZS5lbmNvZGUgPSBmdW5jdGlvbiAod3JpdGVyLCB2YWx1ZSkge1xuXHQgICAgICAgIHZhciB2ID0gbGliJDIuQmlnTnVtYmVyLmZyb20odmFsdWUpO1xuXHQgICAgICAgIC8vIENoZWNrIGJvdW5kcyBhcmUgc2FmZSBmb3IgZW5jb2Rpbmdcblx0ICAgICAgICB2YXIgbWF4VWludFZhbHVlID0gbGliJDcuTWF4VWludDI1Ni5tYXNrKHdyaXRlci53b3JkU2l6ZSAqIDgpO1xuXHQgICAgICAgIGlmICh0aGlzLnNpZ25lZCkge1xuXHQgICAgICAgICAgICB2YXIgYm91bmRzID0gbWF4VWludFZhbHVlLm1hc2sodGhpcy5zaXplICogOCAtIDEpO1xuXHQgICAgICAgICAgICBpZiAodi5ndChib3VuZHMpIHx8IHYubHQoYm91bmRzLmFkZChsaWIkNy5PbmUpLm11bChsaWIkNy5OZWdhdGl2ZU9uZSkpKSB7XG5cdCAgICAgICAgICAgICAgICB0aGlzLl90aHJvd0Vycm9yKFwidmFsdWUgb3V0LW9mLWJvdW5kc1wiLCB2YWx1ZSk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9XG5cdCAgICAgICAgZWxzZSBpZiAodi5sdChsaWIkNy5aZXJvKSB8fCB2Lmd0KG1heFVpbnRWYWx1ZS5tYXNrKHRoaXMuc2l6ZSAqIDgpKSkge1xuXHQgICAgICAgICAgICB0aGlzLl90aHJvd0Vycm9yKFwidmFsdWUgb3V0LW9mLWJvdW5kc1wiLCB2YWx1ZSk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHYgPSB2LnRvVHdvcyh0aGlzLnNpemUgKiA4KS5tYXNrKHRoaXMuc2l6ZSAqIDgpO1xuXHQgICAgICAgIGlmICh0aGlzLnNpZ25lZCkge1xuXHQgICAgICAgICAgICB2ID0gdi5mcm9tVHdvcyh0aGlzLnNpemUgKiA4KS50b1R3b3MoOCAqIHdyaXRlci53b3JkU2l6ZSk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHJldHVybiB3cml0ZXIud3JpdGVWYWx1ZSh2KTtcblx0ICAgIH07XG5cdCAgICBOdW1iZXJDb2Rlci5wcm90b3R5cGUuZGVjb2RlID0gZnVuY3Rpb24gKHJlYWRlcikge1xuXHQgICAgICAgIHZhciB2YWx1ZSA9IHJlYWRlci5yZWFkVmFsdWUoKS5tYXNrKHRoaXMuc2l6ZSAqIDgpO1xuXHQgICAgICAgIGlmICh0aGlzLnNpZ25lZCkge1xuXHQgICAgICAgICAgICB2YWx1ZSA9IHZhbHVlLmZyb21Ud29zKHRoaXMuc2l6ZSAqIDgpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICByZXR1cm4gcmVhZGVyLmNvZXJjZSh0aGlzLm5hbWUsIHZhbHVlKTtcblx0ICAgIH07XG5cdCAgICByZXR1cm4gTnVtYmVyQ29kZXI7XG5cdH0oYWJzdHJhY3RDb2Rlci5Db2RlcikpO1xuXHRleHBvcnRzLk51bWJlckNvZGVyID0gTnVtYmVyQ29kZXI7XG5cblx0fSk7XG5cblx0dmFyIG51bWJlciQxID0gLypAX19QVVJFX18qL2dldERlZmF1bHRFeHBvcnRGcm9tQ2pzKG51bWJlcik7XG5cblx0dmFyIF92ZXJzaW9uJGUgPSBjcmVhdGVDb21tb25qc01vZHVsZShmdW5jdGlvbiAobW9kdWxlLCBleHBvcnRzKSB7XG5cdFwidXNlIHN0cmljdFwiO1xuXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5cdGV4cG9ydHMudmVyc2lvbiA9IHZvaWQgMDtcblx0ZXhwb3J0cy52ZXJzaW9uID0gXCJzdHJpbmdzLzUuNS4wXCI7XG5cblx0fSk7XG5cblx0dmFyIF92ZXJzaW9uJGYgPSAvKkBfX1BVUkVfXyovZ2V0RGVmYXVsdEV4cG9ydEZyb21DanMoX3ZlcnNpb24kZSk7XG5cblx0dmFyIHV0ZjggPSBjcmVhdGVDb21tb25qc01vZHVsZShmdW5jdGlvbiAobW9kdWxlLCBleHBvcnRzKSB7XG5cdFwidXNlIHN0cmljdFwiO1xuXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5cdGV4cG9ydHMudG9VdGY4Q29kZVBvaW50cyA9IGV4cG9ydHMudG9VdGY4U3RyaW5nID0gZXhwb3J0cy5fdG9VdGY4U3RyaW5nID0gZXhwb3J0cy5fdG9Fc2NhcGVkVXRmOFN0cmluZyA9IGV4cG9ydHMudG9VdGY4Qnl0ZXMgPSBleHBvcnRzLlV0ZjhFcnJvckZ1bmNzID0gZXhwb3J0cy5VdGY4RXJyb3JSZWFzb24gPSBleHBvcnRzLlVuaWNvZGVOb3JtYWxpemF0aW9uRm9ybSA9IHZvaWQgMDtcblxuXG5cblx0dmFyIGxvZ2dlciA9IG5ldyBsaWIuTG9nZ2VyKF92ZXJzaW9uJGUudmVyc2lvbik7XG5cdC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cblx0dmFyIFVuaWNvZGVOb3JtYWxpemF0aW9uRm9ybTtcblx0KGZ1bmN0aW9uIChVbmljb2RlTm9ybWFsaXphdGlvbkZvcm0pIHtcblx0ICAgIFVuaWNvZGVOb3JtYWxpemF0aW9uRm9ybVtcImN1cnJlbnRcIl0gPSBcIlwiO1xuXHQgICAgVW5pY29kZU5vcm1hbGl6YXRpb25Gb3JtW1wiTkZDXCJdID0gXCJORkNcIjtcblx0ICAgIFVuaWNvZGVOb3JtYWxpemF0aW9uRm9ybVtcIk5GRFwiXSA9IFwiTkZEXCI7XG5cdCAgICBVbmljb2RlTm9ybWFsaXphdGlvbkZvcm1bXCJORktDXCJdID0gXCJORktDXCI7XG5cdCAgICBVbmljb2RlTm9ybWFsaXphdGlvbkZvcm1bXCJORktEXCJdID0gXCJORktEXCI7XG5cdH0pKFVuaWNvZGVOb3JtYWxpemF0aW9uRm9ybSA9IGV4cG9ydHMuVW5pY29kZU5vcm1hbGl6YXRpb25Gb3JtIHx8IChleHBvcnRzLlVuaWNvZGVOb3JtYWxpemF0aW9uRm9ybSA9IHt9KSk7XG5cdDtcblx0dmFyIFV0ZjhFcnJvclJlYXNvbjtcblx0KGZ1bmN0aW9uIChVdGY4RXJyb3JSZWFzb24pIHtcblx0ICAgIC8vIEEgY29udGludWF0aW9uIGJ5dGUgd2FzIHByZXNlbnQgd2hlcmUgdGhlcmUgd2FzIG5vdGhpbmcgdG8gY29udGludWVcblx0ICAgIC8vIC0gb2Zmc2V0ID0gdGhlIGluZGV4IHRoZSBjb2RlcG9pbnQgYmVnYW4gaW5cblx0ICAgIFV0ZjhFcnJvclJlYXNvbltcIlVORVhQRUNURURfQ09OVElOVUVcIl0gPSBcInVuZXhwZWN0ZWQgY29udGludWF0aW9uIGJ5dGVcIjtcblx0ICAgIC8vIEFuIGludmFsaWQgKG5vbi1jb250aW51YXRpb24pIGJ5dGUgdG8gc3RhcnQgYSBVVEYtOCBjb2RlcG9pbnQgd2FzIGZvdW5kXG5cdCAgICAvLyAtIG9mZnNldCA9IHRoZSBpbmRleCB0aGUgY29kZXBvaW50IGJlZ2FuIGluXG5cdCAgICBVdGY4RXJyb3JSZWFzb25bXCJCQURfUFJFRklYXCJdID0gXCJiYWQgY29kZXBvaW50IHByZWZpeFwiO1xuXHQgICAgLy8gVGhlIHN0cmluZyBpcyB0b28gc2hvcnQgdG8gcHJvY2VzcyB0aGUgZXhwZWN0ZWQgY29kZXBvaW50XG5cdCAgICAvLyAtIG9mZnNldCA9IHRoZSBpbmRleCB0aGUgY29kZXBvaW50IGJlZ2FuIGluXG5cdCAgICBVdGY4RXJyb3JSZWFzb25bXCJPVkVSUlVOXCJdID0gXCJzdHJpbmcgb3ZlcnJ1blwiO1xuXHQgICAgLy8gQSBtaXNzaW5nIGNvbnRpbnVhdGlvbiBieXRlIHdhcyBleHBlY3RlZCBidXQgbm90IGZvdW5kXG5cdCAgICAvLyAtIG9mZnNldCA9IHRoZSBpbmRleCB0aGUgY29udGludWF0aW9uIGJ5dGUgd2FzIGV4cGVjdGVkIGF0XG5cdCAgICBVdGY4RXJyb3JSZWFzb25bXCJNSVNTSU5HX0NPTlRJTlVFXCJdID0gXCJtaXNzaW5nIGNvbnRpbnVhdGlvbiBieXRlXCI7XG5cdCAgICAvLyBUaGUgY29tcHV0ZWQgY29kZSBwb2ludCBpcyBvdXRzaWRlIHRoZSByYW5nZSBmb3IgVVRGLThcblx0ICAgIC8vIC0gb2Zmc2V0ICAgICAgID0gc3RhcnQgb2YgdGhpcyBjb2RlcG9pbnRcblx0ICAgIC8vIC0gYmFkQ29kZXBvaW50ID0gdGhlIGNvbXB1dGVkIGNvZGVwb2ludDsgb3V0c2lkZSB0aGUgVVRGLTggcmFuZ2Vcblx0ICAgIFV0ZjhFcnJvclJlYXNvbltcIk9VVF9PRl9SQU5HRVwiXSA9IFwib3V0IG9mIFVURi04IHJhbmdlXCI7XG5cdCAgICAvLyBVVEYtOCBzdHJpbmdzIG1heSBub3QgY29udGFpbiBVVEYtMTYgc3Vycm9nYXRlIHBhaXJzXG5cdCAgICAvLyAtIG9mZnNldCAgICAgICA9IHN0YXJ0IG9mIHRoaXMgY29kZXBvaW50XG5cdCAgICAvLyAtIGJhZENvZGVwb2ludCA9IHRoZSBjb21wdXRlZCBjb2RlcG9pbnQ7IGluc2lkZSB0aGUgVVRGLTE2IHN1cnJvZ2F0ZSByYW5nZVxuXHQgICAgVXRmOEVycm9yUmVhc29uW1wiVVRGMTZfU1VSUk9HQVRFXCJdID0gXCJVVEYtMTYgc3Vycm9nYXRlXCI7XG5cdCAgICAvLyBUaGUgc3RyaW5nIGlzIGFuIG92ZXJsb25nIHJlcHJlc2VudGF0aW9uXG5cdCAgICAvLyAtIG9mZnNldCAgICAgICA9IHN0YXJ0IG9mIHRoaXMgY29kZXBvaW50XG5cdCAgICAvLyAtIGJhZENvZGVwb2ludCA9IHRoZSBjb21wdXRlZCBjb2RlcG9pbnQ7IGFscmVhZHkgYm91bmRzIGNoZWNrZWRcblx0ICAgIFV0ZjhFcnJvclJlYXNvbltcIk9WRVJMT05HXCJdID0gXCJvdmVybG9uZyByZXByZXNlbnRhdGlvblwiO1xuXHR9KShVdGY4RXJyb3JSZWFzb24gPSBleHBvcnRzLlV0ZjhFcnJvclJlYXNvbiB8fCAoZXhwb3J0cy5VdGY4RXJyb3JSZWFzb24gPSB7fSkpO1xuXHQ7XG5cdGZ1bmN0aW9uIGVycm9yRnVuYyhyZWFzb24sIG9mZnNldCwgYnl0ZXMsIG91dHB1dCwgYmFkQ29kZXBvaW50KSB7XG5cdCAgICByZXR1cm4gbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcImludmFsaWQgY29kZXBvaW50IGF0IG9mZnNldCBcIiArIG9mZnNldCArIFwiOyBcIiArIHJlYXNvbiwgXCJieXRlc1wiLCBieXRlcyk7XG5cdH1cblx0ZnVuY3Rpb24gaWdub3JlRnVuYyhyZWFzb24sIG9mZnNldCwgYnl0ZXMsIG91dHB1dCwgYmFkQ29kZXBvaW50KSB7XG5cdCAgICAvLyBJZiB0aGVyZSBpcyBhbiBpbnZhbGlkIHByZWZpeCAoaW5jbHVkaW5nIHN0cmF5IGNvbnRpbnVhdGlvbiksIHNraXAgYW55IGFkZGl0aW9uYWwgY29udGludWF0aW9uIGJ5dGVzXG5cdCAgICBpZiAocmVhc29uID09PSBVdGY4RXJyb3JSZWFzb24uQkFEX1BSRUZJWCB8fCByZWFzb24gPT09IFV0ZjhFcnJvclJlYXNvbi5VTkVYUEVDVEVEX0NPTlRJTlVFKSB7XG5cdCAgICAgICAgdmFyIGkgPSAwO1xuXHQgICAgICAgIGZvciAodmFyIG8gPSBvZmZzZXQgKyAxOyBvIDwgYnl0ZXMubGVuZ3RoOyBvKyspIHtcblx0ICAgICAgICAgICAgaWYgKGJ5dGVzW29dID4+IDYgIT09IDB4MDIpIHtcblx0ICAgICAgICAgICAgICAgIGJyZWFrO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIGkrKztcblx0ICAgICAgICB9XG5cdCAgICAgICAgcmV0dXJuIGk7XG5cdCAgICB9XG5cdCAgICAvLyBUaGlzIGJ5dGUgcnVucyB1cyBwYXN0IHRoZSBlbmQgb2YgdGhlIHN0cmluZywgc28ganVzdCBqdW1wIHRvIHRoZSBlbmRcblx0ICAgIC8vIChidXQgdGhlIGZpcnN0IGJ5dGUgd2FzIHJlYWQgYWxyZWFkeSByZWFkIGFuZCB0aGVyZWZvcmUgc2tpcHBlZClcblx0ICAgIGlmIChyZWFzb24gPT09IFV0ZjhFcnJvclJlYXNvbi5PVkVSUlVOKSB7XG5cdCAgICAgICAgcmV0dXJuIGJ5dGVzLmxlbmd0aCAtIG9mZnNldCAtIDE7XG5cdCAgICB9XG5cdCAgICAvLyBOb3RoaW5nIHRvIHNraXBcblx0ICAgIHJldHVybiAwO1xuXHR9XG5cdGZ1bmN0aW9uIHJlcGxhY2VGdW5jKHJlYXNvbiwgb2Zmc2V0LCBieXRlcywgb3V0cHV0LCBiYWRDb2RlcG9pbnQpIHtcblx0ICAgIC8vIE92ZXJsb25nIHJlcHJlc2VudGF0aW9ucyBhcmUgb3RoZXJ3aXNlIFwidmFsaWRcIiBjb2RlIHBvaW50czsganVzdCBub24tZGVpc3Rpbmd0aXNoZWRcblx0ICAgIGlmIChyZWFzb24gPT09IFV0ZjhFcnJvclJlYXNvbi5PVkVSTE9ORykge1xuXHQgICAgICAgIG91dHB1dC5wdXNoKGJhZENvZGVwb2ludCk7XG5cdCAgICAgICAgcmV0dXJuIDA7XG5cdCAgICB9XG5cdCAgICAvLyBQdXQgdGhlIHJlcGxhY2VtZW50IGNoYXJhY3RlciBpbnRvIHRoZSBvdXRwdXRcblx0ICAgIG91dHB1dC5wdXNoKDB4ZmZmZCk7XG5cdCAgICAvLyBPdGhlcndpc2UsIHByb2Nlc3MgYXMgaWYgaWdub3JpbmcgZXJyb3JzXG5cdCAgICByZXR1cm4gaWdub3JlRnVuYyhyZWFzb24sIG9mZnNldCwgYnl0ZXMsIG91dHB1dCwgYmFkQ29kZXBvaW50KTtcblx0fVxuXHQvLyBDb21tb24gZXJyb3IgaGFuZGluZyBzdHJhdGVnaWVzXG5cdGV4cG9ydHMuVXRmOEVycm9yRnVuY3MgPSBPYmplY3QuZnJlZXplKHtcblx0ICAgIGVycm9yOiBlcnJvckZ1bmMsXG5cdCAgICBpZ25vcmU6IGlnbm9yZUZ1bmMsXG5cdCAgICByZXBsYWNlOiByZXBsYWNlRnVuY1xuXHR9KTtcblx0Ly8gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy8xMzM1NjQ5My9kZWNvZGUtdXRmLTgtd2l0aC1qYXZhc2NyaXB0IzEzNjkxNDk5XG5cdGZ1bmN0aW9uIGdldFV0ZjhDb2RlUG9pbnRzKGJ5dGVzLCBvbkVycm9yKSB7XG5cdCAgICBpZiAob25FcnJvciA9PSBudWxsKSB7XG5cdCAgICAgICAgb25FcnJvciA9IGV4cG9ydHMuVXRmOEVycm9yRnVuY3MuZXJyb3I7XG5cdCAgICB9XG5cdCAgICBieXRlcyA9ICgwLCBsaWIkMS5hcnJheWlmeSkoYnl0ZXMpO1xuXHQgICAgdmFyIHJlc3VsdCA9IFtdO1xuXHQgICAgdmFyIGkgPSAwO1xuXHQgICAgLy8gSW52YWxpZCBieXRlcyBhcmUgaWdub3JlZFxuXHQgICAgd2hpbGUgKGkgPCBieXRlcy5sZW5ndGgpIHtcblx0ICAgICAgICB2YXIgYyA9IGJ5dGVzW2krK107XG5cdCAgICAgICAgLy8gMHh4eCB4eHh4XG5cdCAgICAgICAgaWYgKGMgPj4gNyA9PT0gMCkge1xuXHQgICAgICAgICAgICByZXN1bHQucHVzaChjKTtcblx0ICAgICAgICAgICAgY29udGludWU7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIC8vIE11bHRpYnl0ZTsgaG93IG1hbnkgYnl0ZXMgbGVmdCBmb3IgdGhpcyBjaGFyYWN0ZXI/XG5cdCAgICAgICAgdmFyIGV4dHJhTGVuZ3RoID0gbnVsbDtcblx0ICAgICAgICB2YXIgb3ZlcmxvbmdNYXNrID0gbnVsbDtcblx0ICAgICAgICAvLyAxMTB4IHh4eHggMTB4eCB4eHh4XG5cdCAgICAgICAgaWYgKChjICYgMHhlMCkgPT09IDB4YzApIHtcblx0ICAgICAgICAgICAgZXh0cmFMZW5ndGggPSAxO1xuXHQgICAgICAgICAgICBvdmVybG9uZ01hc2sgPSAweDdmO1xuXHQgICAgICAgICAgICAvLyAxMTEwIHh4eHggMTB4eCB4eHh4IDEweHggeHh4eFxuXHQgICAgICAgIH1cblx0ICAgICAgICBlbHNlIGlmICgoYyAmIDB4ZjApID09PSAweGUwKSB7XG5cdCAgICAgICAgICAgIGV4dHJhTGVuZ3RoID0gMjtcblx0ICAgICAgICAgICAgb3ZlcmxvbmdNYXNrID0gMHg3ZmY7XG5cdCAgICAgICAgICAgIC8vIDExMTEgMHh4eCAxMHh4IHh4eHggMTB4eCB4eHh4IDEweHggeHh4eFxuXHQgICAgICAgIH1cblx0ICAgICAgICBlbHNlIGlmICgoYyAmIDB4ZjgpID09PSAweGYwKSB7XG5cdCAgICAgICAgICAgIGV4dHJhTGVuZ3RoID0gMztcblx0ICAgICAgICAgICAgb3ZlcmxvbmdNYXNrID0gMHhmZmZmO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBlbHNlIHtcblx0ICAgICAgICAgICAgaWYgKChjICYgMHhjMCkgPT09IDB4ODApIHtcblx0ICAgICAgICAgICAgICAgIGkgKz0gb25FcnJvcihVdGY4RXJyb3JSZWFzb24uVU5FWFBFQ1RFRF9DT05USU5VRSwgaSAtIDEsIGJ5dGVzLCByZXN1bHQpO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIGVsc2Uge1xuXHQgICAgICAgICAgICAgICAgaSArPSBvbkVycm9yKFV0ZjhFcnJvclJlYXNvbi5CQURfUFJFRklYLCBpIC0gMSwgYnl0ZXMsIHJlc3VsdCk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgY29udGludWU7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIC8vIERvIHdlIGhhdmUgZW5vdWdoIGJ5dGVzIGluIG91ciBkYXRhP1xuXHQgICAgICAgIGlmIChpIC0gMSArIGV4dHJhTGVuZ3RoID49IGJ5dGVzLmxlbmd0aCkge1xuXHQgICAgICAgICAgICBpICs9IG9uRXJyb3IoVXRmOEVycm9yUmVhc29uLk9WRVJSVU4sIGkgLSAxLCBieXRlcywgcmVzdWx0KTtcblx0ICAgICAgICAgICAgY29udGludWU7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIC8vIFJlbW92ZSB0aGUgbGVuZ3RoIHByZWZpeCBmcm9tIHRoZSBjaGFyXG5cdCAgICAgICAgdmFyIHJlcyA9IGMgJiAoKDEgPDwgKDggLSBleHRyYUxlbmd0aCAtIDEpKSAtIDEpO1xuXHQgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgZXh0cmFMZW5ndGg7IGorKykge1xuXHQgICAgICAgICAgICB2YXIgbmV4dENoYXIgPSBieXRlc1tpXTtcblx0ICAgICAgICAgICAgLy8gSW52YWxpZCBjb250aW51YXRpb24gYnl0ZVxuXHQgICAgICAgICAgICBpZiAoKG5leHRDaGFyICYgMHhjMCkgIT0gMHg4MCkge1xuXHQgICAgICAgICAgICAgICAgaSArPSBvbkVycm9yKFV0ZjhFcnJvclJlYXNvbi5NSVNTSU5HX0NPTlRJTlVFLCBpLCBieXRlcywgcmVzdWx0KTtcblx0ICAgICAgICAgICAgICAgIHJlcyA9IG51bGw7XG5cdCAgICAgICAgICAgICAgICBicmVhaztcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICA7XG5cdCAgICAgICAgICAgIHJlcyA9IChyZXMgPDwgNikgfCAobmV4dENoYXIgJiAweDNmKTtcblx0ICAgICAgICAgICAgaSsrO1xuXHQgICAgICAgIH1cblx0ICAgICAgICAvLyBTZWUgYWJvdmUgbG9vcCBmb3IgaW52YWxpZCBjb250aW51YXRpb24gYnl0ZVxuXHQgICAgICAgIGlmIChyZXMgPT09IG51bGwpIHtcblx0ICAgICAgICAgICAgY29udGludWU7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIC8vIE1heGltdW0gY29kZSBwb2ludFxuXHQgICAgICAgIGlmIChyZXMgPiAweDEwZmZmZikge1xuXHQgICAgICAgICAgICBpICs9IG9uRXJyb3IoVXRmOEVycm9yUmVhc29uLk9VVF9PRl9SQU5HRSwgaSAtIDEgLSBleHRyYUxlbmd0aCwgYnl0ZXMsIHJlc3VsdCwgcmVzKTtcblx0ICAgICAgICAgICAgY29udGludWU7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIC8vIFJlc2VydmVkIGZvciBVVEYtMTYgc3Vycm9nYXRlIGhhbHZlc1xuXHQgICAgICAgIGlmIChyZXMgPj0gMHhkODAwICYmIHJlcyA8PSAweGRmZmYpIHtcblx0ICAgICAgICAgICAgaSArPSBvbkVycm9yKFV0ZjhFcnJvclJlYXNvbi5VVEYxNl9TVVJST0dBVEUsIGkgLSAxIC0gZXh0cmFMZW5ndGgsIGJ5dGVzLCByZXN1bHQsIHJlcyk7XG5cdCAgICAgICAgICAgIGNvbnRpbnVlO1xuXHQgICAgICAgIH1cblx0ICAgICAgICAvLyBDaGVjayBmb3Igb3Zlcmxvbmcgc2VxdWVuY2VzIChtb3JlIGJ5dGVzIHRoYW4gbmVlZGVkKVxuXHQgICAgICAgIGlmIChyZXMgPD0gb3ZlcmxvbmdNYXNrKSB7XG5cdCAgICAgICAgICAgIGkgKz0gb25FcnJvcihVdGY4RXJyb3JSZWFzb24uT1ZFUkxPTkcsIGkgLSAxIC0gZXh0cmFMZW5ndGgsIGJ5dGVzLCByZXN1bHQsIHJlcyk7XG5cdCAgICAgICAgICAgIGNvbnRpbnVlO1xuXHQgICAgICAgIH1cblx0ICAgICAgICByZXN1bHQucHVzaChyZXMpO1xuXHQgICAgfVxuXHQgICAgcmV0dXJuIHJlc3VsdDtcblx0fVxuXHQvLyBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzE4NzI5NDA1L2hvdy10by1jb252ZXJ0LXV0Zjgtc3RyaW5nLXRvLWJ5dGUtYXJyYXlcblx0ZnVuY3Rpb24gdG9VdGY4Qnl0ZXMoc3RyLCBmb3JtKSB7XG5cdCAgICBpZiAoZm9ybSA9PT0gdm9pZCAwKSB7IGZvcm0gPSBVbmljb2RlTm9ybWFsaXphdGlvbkZvcm0uY3VycmVudDsgfVxuXHQgICAgaWYgKGZvcm0gIT0gVW5pY29kZU5vcm1hbGl6YXRpb25Gb3JtLmN1cnJlbnQpIHtcblx0ICAgICAgICBsb2dnZXIuY2hlY2tOb3JtYWxpemUoKTtcblx0ICAgICAgICBzdHIgPSBzdHIubm9ybWFsaXplKGZvcm0pO1xuXHQgICAgfVxuXHQgICAgdmFyIHJlc3VsdCA9IFtdO1xuXHQgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyBpKyspIHtcblx0ICAgICAgICB2YXIgYyA9IHN0ci5jaGFyQ29kZUF0KGkpO1xuXHQgICAgICAgIGlmIChjIDwgMHg4MCkge1xuXHQgICAgICAgICAgICByZXN1bHQucHVzaChjKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgZWxzZSBpZiAoYyA8IDB4ODAwKSB7XG5cdCAgICAgICAgICAgIHJlc3VsdC5wdXNoKChjID4+IDYpIHwgMHhjMCk7XG5cdCAgICAgICAgICAgIHJlc3VsdC5wdXNoKChjICYgMHgzZikgfCAweDgwKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgZWxzZSBpZiAoKGMgJiAweGZjMDApID09IDB4ZDgwMCkge1xuXHQgICAgICAgICAgICBpKys7XG5cdCAgICAgICAgICAgIHZhciBjMiA9IHN0ci5jaGFyQ29kZUF0KGkpO1xuXHQgICAgICAgICAgICBpZiAoaSA+PSBzdHIubGVuZ3RoIHx8IChjMiAmIDB4ZmMwMCkgIT09IDB4ZGMwMCkge1xuXHQgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCB1dGYtOCBzdHJpbmdcIik7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgLy8gU3Vycm9nYXRlIFBhaXJcblx0ICAgICAgICAgICAgdmFyIHBhaXIgPSAweDEwMDAwICsgKChjICYgMHgwM2ZmKSA8PCAxMCkgKyAoYzIgJiAweDAzZmYpO1xuXHQgICAgICAgICAgICByZXN1bHQucHVzaCgocGFpciA+PiAxOCkgfCAweGYwKTtcblx0ICAgICAgICAgICAgcmVzdWx0LnB1c2goKChwYWlyID4+IDEyKSAmIDB4M2YpIHwgMHg4MCk7XG5cdCAgICAgICAgICAgIHJlc3VsdC5wdXNoKCgocGFpciA+PiA2KSAmIDB4M2YpIHwgMHg4MCk7XG5cdCAgICAgICAgICAgIHJlc3VsdC5wdXNoKChwYWlyICYgMHgzZikgfCAweDgwKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgZWxzZSB7XG5cdCAgICAgICAgICAgIHJlc3VsdC5wdXNoKChjID4+IDEyKSB8IDB4ZTApO1xuXHQgICAgICAgICAgICByZXN1bHQucHVzaCgoKGMgPj4gNikgJiAweDNmKSB8IDB4ODApO1xuXHQgICAgICAgICAgICByZXN1bHQucHVzaCgoYyAmIDB4M2YpIHwgMHg4MCk7XG5cdCAgICAgICAgfVxuXHQgICAgfVxuXHQgICAgcmV0dXJuICgwLCBsaWIkMS5hcnJheWlmeSkocmVzdWx0KTtcblx0fVxuXHRleHBvcnRzLnRvVXRmOEJ5dGVzID0gdG9VdGY4Qnl0ZXM7XG5cdDtcblx0ZnVuY3Rpb24gZXNjYXBlQ2hhcih2YWx1ZSkge1xuXHQgICAgdmFyIGhleCA9IChcIjAwMDBcIiArIHZhbHVlLnRvU3RyaW5nKDE2KSk7XG5cdCAgICByZXR1cm4gXCJcXFxcdVwiICsgaGV4LnN1YnN0cmluZyhoZXgubGVuZ3RoIC0gNCk7XG5cdH1cblx0ZnVuY3Rpb24gX3RvRXNjYXBlZFV0ZjhTdHJpbmcoYnl0ZXMsIG9uRXJyb3IpIHtcblx0ICAgIHJldHVybiAnXCInICsgZ2V0VXRmOENvZGVQb2ludHMoYnl0ZXMsIG9uRXJyb3IpLm1hcChmdW5jdGlvbiAoY29kZVBvaW50KSB7XG5cdCAgICAgICAgaWYgKGNvZGVQb2ludCA8IDI1Nikge1xuXHQgICAgICAgICAgICBzd2l0Y2ggKGNvZGVQb2ludCkge1xuXHQgICAgICAgICAgICAgICAgY2FzZSA4OiByZXR1cm4gXCJcXFxcYlwiO1xuXHQgICAgICAgICAgICAgICAgY2FzZSA5OiByZXR1cm4gXCJcXFxcdFwiO1xuXHQgICAgICAgICAgICAgICAgY2FzZSAxMDogcmV0dXJuIFwiXFxcXG5cIjtcblx0ICAgICAgICAgICAgICAgIGNhc2UgMTM6IHJldHVybiBcIlxcXFxyXCI7XG5cdCAgICAgICAgICAgICAgICBjYXNlIDM0OiByZXR1cm4gXCJcXFxcXFxcIlwiO1xuXHQgICAgICAgICAgICAgICAgY2FzZSA5MjogcmV0dXJuIFwiXFxcXFxcXFxcIjtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICBpZiAoY29kZVBvaW50ID49IDMyICYmIGNvZGVQb2ludCA8IDEyNykge1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUoY29kZVBvaW50KTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH1cblx0ICAgICAgICBpZiAoY29kZVBvaW50IDw9IDB4ZmZmZikge1xuXHQgICAgICAgICAgICByZXR1cm4gZXNjYXBlQ2hhcihjb2RlUG9pbnQpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBjb2RlUG9pbnQgLT0gMHgxMDAwMDtcblx0ICAgICAgICByZXR1cm4gZXNjYXBlQ2hhcigoKGNvZGVQb2ludCA+PiAxMCkgJiAweDNmZikgKyAweGQ4MDApICsgZXNjYXBlQ2hhcigoY29kZVBvaW50ICYgMHgzZmYpICsgMHhkYzAwKTtcblx0ICAgIH0pLmpvaW4oXCJcIikgKyAnXCInO1xuXHR9XG5cdGV4cG9ydHMuX3RvRXNjYXBlZFV0ZjhTdHJpbmcgPSBfdG9Fc2NhcGVkVXRmOFN0cmluZztcblx0ZnVuY3Rpb24gX3RvVXRmOFN0cmluZyhjb2RlUG9pbnRzKSB7XG5cdCAgICByZXR1cm4gY29kZVBvaW50cy5tYXAoZnVuY3Rpb24gKGNvZGVQb2ludCkge1xuXHQgICAgICAgIGlmIChjb2RlUG9pbnQgPD0gMHhmZmZmKSB7XG5cdCAgICAgICAgICAgIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlKGNvZGVQb2ludCk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGNvZGVQb2ludCAtPSAweDEwMDAwO1xuXHQgICAgICAgIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlKCgoKGNvZGVQb2ludCA+PiAxMCkgJiAweDNmZikgKyAweGQ4MDApLCAoKGNvZGVQb2ludCAmIDB4M2ZmKSArIDB4ZGMwMCkpO1xuXHQgICAgfSkuam9pbihcIlwiKTtcblx0fVxuXHRleHBvcnRzLl90b1V0ZjhTdHJpbmcgPSBfdG9VdGY4U3RyaW5nO1xuXHRmdW5jdGlvbiB0b1V0ZjhTdHJpbmcoYnl0ZXMsIG9uRXJyb3IpIHtcblx0ICAgIHJldHVybiBfdG9VdGY4U3RyaW5nKGdldFV0ZjhDb2RlUG9pbnRzKGJ5dGVzLCBvbkVycm9yKSk7XG5cdH1cblx0ZXhwb3J0cy50b1V0ZjhTdHJpbmcgPSB0b1V0ZjhTdHJpbmc7XG5cdGZ1bmN0aW9uIHRvVXRmOENvZGVQb2ludHMoc3RyLCBmb3JtKSB7XG5cdCAgICBpZiAoZm9ybSA9PT0gdm9pZCAwKSB7IGZvcm0gPSBVbmljb2RlTm9ybWFsaXphdGlvbkZvcm0uY3VycmVudDsgfVxuXHQgICAgcmV0dXJuIGdldFV0ZjhDb2RlUG9pbnRzKHRvVXRmOEJ5dGVzKHN0ciwgZm9ybSkpO1xuXHR9XG5cdGV4cG9ydHMudG9VdGY4Q29kZVBvaW50cyA9IHRvVXRmOENvZGVQb2ludHM7XG5cblx0fSk7XG5cblx0dmFyIHV0ZjgkMSA9IC8qQF9fUFVSRV9fKi9nZXREZWZhdWx0RXhwb3J0RnJvbUNqcyh1dGY4KTtcblxuXHR2YXIgYnl0ZXMzMiA9IGNyZWF0ZUNvbW1vbmpzTW9kdWxlKGZ1bmN0aW9uIChtb2R1bGUsIGV4cG9ydHMpIHtcblx0XCJ1c2Ugc3RyaWN0XCI7XG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcblx0ZXhwb3J0cy5wYXJzZUJ5dGVzMzJTdHJpbmcgPSBleHBvcnRzLmZvcm1hdEJ5dGVzMzJTdHJpbmcgPSB2b2lkIDA7XG5cblxuXG5cdGZ1bmN0aW9uIGZvcm1hdEJ5dGVzMzJTdHJpbmcodGV4dCkge1xuXHQgICAgLy8gR2V0IHRoZSBieXRlc1xuXHQgICAgdmFyIGJ5dGVzID0gKDAsIHV0ZjgudG9VdGY4Qnl0ZXMpKHRleHQpO1xuXHQgICAgLy8gQ2hlY2sgd2UgaGF2ZSByb29tIGZvciBudWxsLXRlcm1pbmF0aW9uXG5cdCAgICBpZiAoYnl0ZXMubGVuZ3RoID4gMzEpIHtcblx0ICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJieXRlczMyIHN0cmluZyBtdXN0IGJlIGxlc3MgdGhhbiAzMiBieXRlc1wiKTtcblx0ICAgIH1cblx0ICAgIC8vIFplcm8tcGFkIChpbXBsaWNpdGx5IG51bGwtdGVybWluYXRlcylcblx0ICAgIHJldHVybiAoMCwgbGliJDEuaGV4bGlmeSkoKDAsIGxpYiQxLmNvbmNhdCkoW2J5dGVzLCBsaWIkNy5IYXNoWmVyb10pLnNsaWNlKDAsIDMyKSk7XG5cdH1cblx0ZXhwb3J0cy5mb3JtYXRCeXRlczMyU3RyaW5nID0gZm9ybWF0Qnl0ZXMzMlN0cmluZztcblx0ZnVuY3Rpb24gcGFyc2VCeXRlczMyU3RyaW5nKGJ5dGVzKSB7XG5cdCAgICB2YXIgZGF0YSA9ICgwLCBsaWIkMS5hcnJheWlmeSkoYnl0ZXMpO1xuXHQgICAgLy8gTXVzdCBiZSAzMiBieXRlcyB3aXRoIGEgbnVsbC10ZXJtaW5hdGlvblxuXHQgICAgaWYgKGRhdGEubGVuZ3RoICE9PSAzMikge1xuXHQgICAgICAgIHRocm93IG5ldyBFcnJvcihcImludmFsaWQgYnl0ZXMzMiAtIG5vdCAzMiBieXRlcyBsb25nXCIpO1xuXHQgICAgfVxuXHQgICAgaWYgKGRhdGFbMzFdICE9PSAwKSB7XG5cdCAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBieXRlczMyIHN0cmluZyAtIG5vIG51bGwgdGVybWluYXRvclwiKTtcblx0ICAgIH1cblx0ICAgIC8vIEZpbmQgdGhlIG51bGwgdGVybWluYXRpb25cblx0ICAgIHZhciBsZW5ndGggPSAzMTtcblx0ICAgIHdoaWxlIChkYXRhW2xlbmd0aCAtIDFdID09PSAwKSB7XG5cdCAgICAgICAgbGVuZ3RoLS07XG5cdCAgICB9XG5cdCAgICAvLyBEZXRlcm1pbmUgdGhlIHN0cmluZyB2YWx1ZVxuXHQgICAgcmV0dXJuICgwLCB1dGY4LnRvVXRmOFN0cmluZykoZGF0YS5zbGljZSgwLCBsZW5ndGgpKTtcblx0fVxuXHRleHBvcnRzLnBhcnNlQnl0ZXMzMlN0cmluZyA9IHBhcnNlQnl0ZXMzMlN0cmluZztcblxuXHR9KTtcblxuXHR2YXIgYnl0ZXMzMiQxID0gLypAX19QVVJFX18qL2dldERlZmF1bHRFeHBvcnRGcm9tQ2pzKGJ5dGVzMzIpO1xuXG5cdHZhciBpZG5hID0gY3JlYXRlQ29tbW9uanNNb2R1bGUoZnVuY3Rpb24gKG1vZHVsZSwgZXhwb3J0cykge1xuXHRcInVzZSBzdHJpY3RcIjtcblx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuXHRleHBvcnRzLm5hbWVwcmVwID0gZXhwb3J0cy5fbmFtZXByZXBUYWJsZUMgPSBleHBvcnRzLl9uYW1lcHJlcFRhYmxlQjIgPSBleHBvcnRzLl9uYW1lcHJlcFRhYmxlQTEgPSB2b2lkIDA7XG5cblx0ZnVuY3Rpb24gYnl0ZXMyKGRhdGEpIHtcblx0ICAgIGlmICgoZGF0YS5sZW5ndGggJSA0KSAhPT0gMCkge1xuXHQgICAgICAgIHRocm93IG5ldyBFcnJvcihcImJhZCBkYXRhXCIpO1xuXHQgICAgfVxuXHQgICAgdmFyIHJlc3VsdCA9IFtdO1xuXHQgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBkYXRhLmxlbmd0aDsgaSArPSA0KSB7XG5cdCAgICAgICAgcmVzdWx0LnB1c2gocGFyc2VJbnQoZGF0YS5zdWJzdHJpbmcoaSwgaSArIDQpLCAxNikpO1xuXHQgICAgfVxuXHQgICAgcmV0dXJuIHJlc3VsdDtcblx0fVxuXHRmdW5jdGlvbiBjcmVhdGVUYWJsZShkYXRhLCBmdW5jKSB7XG5cdCAgICBpZiAoIWZ1bmMpIHtcblx0ICAgICAgICBmdW5jID0gZnVuY3Rpb24gKHZhbHVlKSB7IHJldHVybiBbcGFyc2VJbnQodmFsdWUsIDE2KV07IH07XG5cdCAgICB9XG5cdCAgICB2YXIgbG8gPSAwO1xuXHQgICAgdmFyIHJlc3VsdCA9IHt9O1xuXHQgICAgZGF0YS5zcGxpdChcIixcIikuZm9yRWFjaChmdW5jdGlvbiAocGFpcikge1xuXHQgICAgICAgIHZhciBjb21wcyA9IHBhaXIuc3BsaXQoXCI6XCIpO1xuXHQgICAgICAgIGxvICs9IHBhcnNlSW50KGNvbXBzWzBdLCAxNik7XG5cdCAgICAgICAgcmVzdWx0W2xvXSA9IGZ1bmMoY29tcHNbMV0pO1xuXHQgICAgfSk7XG5cdCAgICByZXR1cm4gcmVzdWx0O1xuXHR9XG5cdGZ1bmN0aW9uIGNyZWF0ZVJhbmdlVGFibGUoZGF0YSkge1xuXHQgICAgdmFyIGhpID0gMDtcblx0ICAgIHJldHVybiBkYXRhLnNwbGl0KFwiLFwiKS5tYXAoZnVuY3Rpb24gKHYpIHtcblx0ICAgICAgICB2YXIgY29tcHMgPSB2LnNwbGl0KFwiLVwiKTtcblx0ICAgICAgICBpZiAoY29tcHMubGVuZ3RoID09PSAxKSB7XG5cdCAgICAgICAgICAgIGNvbXBzWzFdID0gXCIwXCI7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGVsc2UgaWYgKGNvbXBzWzFdID09PSBcIlwiKSB7XG5cdCAgICAgICAgICAgIGNvbXBzWzFdID0gXCIxXCI7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHZhciBsbyA9IGhpICsgcGFyc2VJbnQoY29tcHNbMF0sIDE2KTtcblx0ICAgICAgICBoaSA9IHBhcnNlSW50KGNvbXBzWzFdLCAxNik7XG5cdCAgICAgICAgcmV0dXJuIHsgbDogbG8sIGg6IGhpIH07XG5cdCAgICB9KTtcblx0fVxuXHRmdW5jdGlvbiBtYXRjaE1hcCh2YWx1ZSwgcmFuZ2VzKSB7XG5cdCAgICB2YXIgbG8gPSAwO1xuXHQgICAgZm9yICh2YXIgaSA9IDA7IGkgPCByYW5nZXMubGVuZ3RoOyBpKyspIHtcblx0ICAgICAgICB2YXIgcmFuZ2UgPSByYW5nZXNbaV07XG5cdCAgICAgICAgbG8gKz0gcmFuZ2UubDtcblx0ICAgICAgICBpZiAodmFsdWUgPj0gbG8gJiYgdmFsdWUgPD0gbG8gKyByYW5nZS5oICYmICgodmFsdWUgLSBsbykgJSAocmFuZ2UuZCB8fCAxKSkgPT09IDApIHtcblx0ICAgICAgICAgICAgaWYgKHJhbmdlLmUgJiYgcmFuZ2UuZS5pbmRleE9mKHZhbHVlIC0gbG8pICE9PSAtMSkge1xuXHQgICAgICAgICAgICAgICAgY29udGludWU7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgcmV0dXJuIHJhbmdlO1xuXHQgICAgICAgIH1cblx0ICAgIH1cblx0ICAgIHJldHVybiBudWxsO1xuXHR9XG5cdHZhciBUYWJsZV9BXzFfcmFuZ2VzID0gY3JlYXRlUmFuZ2VUYWJsZShcIjIyMSwxMy0xYiw1Zi0sNDAtMTAsNTEtZiwxMS0zLDMtMywyLTIsMi00LDgsMiwxNSwyZCwyOC04LDg4LDQ4LDI3LSwzLTUsMTEtMjAsMjctLDgsMjgsMy01LDEyLDE4LGItYSwxYy00LDYtMTYsMi1kLDItMiwyLDFiLTQsMTctOSw4Zi0sMTAsZiwxZi0yLDFjLTM0LDMzLTE0ZSw0LDM2LSwxMy0sNi0yLDFhLWYsNCw5LSwzLSwxNyw4LDItMiw1LSwyLDgtLDMtLDQtOCwyLTMsMyw2LSwxNi02LDItLDctMywzLSwxNyw4LDMsMywzLSwyLDYtMywzLSw0LWEsNSwyLTYsMTAtYiw0LDgsMiw0LDE3LDgsMyw2LSxiLDQsNC0sMi1lLDItNCxiLTEwLDQsOS0sMy0sMTcsOCwzLSw1LSw5LTIsMy0sNC03LDMtMywzLDQtMyxjLTEwLDMsNy0yLDQsNS0yLDMsMiwzLTIsMy0yLDQtMiw5LDQtMyw2LTIsNCw1LTgsMi1lLGQtZCw0LDksNCwxOCxiLDYtMyw4LDQsNS02LDMtOCwzLTMsYi0xMSwzLDksNCwxOCxiLDYtMyw4LDQsNS02LDMtNiwyLDMtMyxiLTExLDMsOSw0LDE4LDExLTMsNy0sNCw1LTgsMi03LDMtMyxiLTExLDMsMTMtMiwxOSxhLDItLDgtMiwyLTMsNywyLDktMTEsNC1iLDNiLTMsMWUtMjQsMywyLSwzLDItLDItNSw1LDgsNCwyLDItLDMsZSw0LSw2LDIsNy0sYi0sMy0yMSw0OSwyMy01LDFjLTMsOSwyNSwxMC0sMi0yZiwyMyw2LDMsOC0yLDUtNSwxYi00NSwyNy05LDJhLSwyLTMsNWItNCw0NS00LDUzLTUsOCw0MCwyLDUtLDgsMiw1LSwyOCwyLDUtLDIwLDIsNS0sOCwyLDUtLDgsOCwxOCwyMCwyLDUtLDgsMjgsMTQtNSwxZC0yMiw1Ni1iLDI3Ny04LDFlLTIsNTItZSxlLDgtYSwxOC04LDE1LWIsZSw0LDMtYiw1ZS0yLGItMTUsMTAsYi01LDU5LTcsMmItNTU1LDlkLTMsNWItNSwxNy0sNy0sMjctLDctLDksMiwyLDIsMjAtLDM2LDEwLGYtLDcsMTQtLDQsYSw1NC0zLDItNiw2LTUsOS0sMWMtMTAsMTMtMWQsMWMtMTQsM2MtLDEwLTYsMzItYiwyNDAtMzAsMjgtMTgsYy0xNCxhMCwxMTUtLDMsNjYtLGItNzYsNSw1LSwxZCwyNCwyLDUtMiwyLDgtLDM1LTIsMTksZi0xMCwxZC0zLDMxMS0zN2YsMWIsNWEtYixkNy0xOSxkLTMsNDEsNTctLDY4LTQsMjktMyw1ZiwyOS0zNywyZS0yLDI1LWMsMmMtMiw0ZS0zLDMwLDc4LTMsNjQtLDIwLDE5YjctNDksNTFhNy01OSw0OGUtMiwzOC03MzgsMmJhNS01YiwyMjJmLSwzYy05NCw4LWIsNi00LDFiLDYsMiwzLDMsNmQtMjAsMTZlLWYsNDEtLDM3LTcsMmUtMiwxMS1mLDUtYiwxOC0sYiwxNCw1LTMsNiw4OC0sMixiZi0yLDctLDctLDctLDQtMiw4LDgtOSw4LTJmZiwyMCw1LWIsMWMtYjQsMjctLDI3LWNiYjEsZjctOSwyOC0yLGI1LTIyMSw1Niw0OCwzLSwyLSwzLSw1LGQsMiw1LDMsNDIsNS0sOSw4LDFkLDUsNiwyLTIsOCwxNTMtMywxMjMtMywzMy0yN2ZkLGE2ZGEtNTEyOCwyMWYtNWRmLDMtZmZmZCwzLWZmZmQsMy1mZmZkLDMtZmZmZCwzLWZmZmQsMy1mZmZkLDMtZmZmZCwzLWZmZmQsMy1mZmZkLDMtZmZmZCwzLWZmZmQsMywyLTFkLDYxLWZmN2RcIik7XG5cdC8vIEBUT0RPOiBNYWtlIHRoaXMgcmVsYXRpdmUuLi5cblx0dmFyIFRhYmxlX0JfMV9mbGFncyA9IFwiYWQsMzRmLDE4MDYsMTgwYiwxODBjLDE4MGQsMjAwYiwyMDBjLDIwMGQsMjA2MCxmZWZmXCIuc3BsaXQoXCIsXCIpLm1hcChmdW5jdGlvbiAodikgeyByZXR1cm4gcGFyc2VJbnQodiwgMTYpOyB9KTtcblx0dmFyIFRhYmxlX0JfMl9yYW5nZXMgPSBbXG5cdCAgICB7IGg6IDI1LCBzOiAzMiwgbDogNjUgfSxcblx0ICAgIHsgaDogMzAsIHM6IDMyLCBlOiBbMjNdLCBsOiAxMjcgfSxcblx0ICAgIHsgaDogNTQsIHM6IDEsIGU6IFs0OF0sIGw6IDY0LCBkOiAyIH0sXG5cdCAgICB7IGg6IDE0LCBzOiAxLCBsOiA1NywgZDogMiB9LFxuXHQgICAgeyBoOiA0NCwgczogMSwgbDogMTcsIGQ6IDIgfSxcblx0ICAgIHsgaDogMTAsIHM6IDEsIGU6IFsyLCA2LCA4XSwgbDogNjEsIGQ6IDIgfSxcblx0ICAgIHsgaDogMTYsIHM6IDEsIGw6IDY4LCBkOiAyIH0sXG5cdCAgICB7IGg6IDg0LCBzOiAxLCBlOiBbMTgsIDI0LCA2Nl0sIGw6IDE5LCBkOiAyIH0sXG5cdCAgICB7IGg6IDI2LCBzOiAzMiwgZTogWzE3XSwgbDogNDM1IH0sXG5cdCAgICB7IGg6IDIyLCBzOiAxLCBsOiA3MSwgZDogMiB9LFxuXHQgICAgeyBoOiAxNSwgczogODAsIGw6IDQwIH0sXG5cdCAgICB7IGg6IDMxLCBzOiAzMiwgbDogMTYgfSxcblx0ICAgIHsgaDogMzIsIHM6IDEsIGw6IDgwLCBkOiAyIH0sXG5cdCAgICB7IGg6IDUyLCBzOiAxLCBsOiA0MiwgZDogMiB9LFxuXHQgICAgeyBoOiAxMiwgczogMSwgbDogNTUsIGQ6IDIgfSxcblx0ICAgIHsgaDogNDAsIHM6IDEsIGU6IFszOF0sIGw6IDE1LCBkOiAyIH0sXG5cdCAgICB7IGg6IDE0LCBzOiAxLCBsOiA0OCwgZDogMiB9LFxuXHQgICAgeyBoOiAzNywgczogNDgsIGw6IDQ5IH0sXG5cdCAgICB7IGg6IDE0OCwgczogMSwgbDogNjM1MSwgZDogMiB9LFxuXHQgICAgeyBoOiA4OCwgczogMSwgbDogMTYwLCBkOiAyIH0sXG5cdCAgICB7IGg6IDE1LCBzOiAxNiwgbDogNzA0IH0sXG5cdCAgICB7IGg6IDI1LCBzOiAyNiwgbDogODU0IH0sXG5cdCAgICB7IGg6IDI1LCBzOiAzMiwgbDogNTU5MTUgfSxcblx0ICAgIHsgaDogMzcsIHM6IDQwLCBsOiAxMjQ3IH0sXG5cdCAgICB7IGg6IDI1LCBzOiAtMTE5NzExLCBsOiA1MzI0OCB9LFxuXHQgICAgeyBoOiAyNSwgczogLTExOTc2MywgbDogNTIgfSxcblx0ICAgIHsgaDogMjUsIHM6IC0xMTk4MTUsIGw6IDUyIH0sXG5cdCAgICB7IGg6IDI1LCBzOiAtMTE5ODY3LCBlOiBbMSwgNCwgNSwgNywgOCwgMTEsIDEyLCAxN10sIGw6IDUyIH0sXG5cdCAgICB7IGg6IDI1LCBzOiAtMTE5OTE5LCBsOiA1MiB9LFxuXHQgICAgeyBoOiAyNCwgczogLTExOTk3MSwgZTogWzIsIDcsIDgsIDE3XSwgbDogNTIgfSxcblx0ICAgIHsgaDogMjQsIHM6IC0xMjAwMjMsIGU6IFsyLCA3LCAxMywgMTUsIDE2LCAxN10sIGw6IDUyIH0sXG5cdCAgICB7IGg6IDI1LCBzOiAtMTIwMDc1LCBsOiA1MiB9LFxuXHQgICAgeyBoOiAyNSwgczogLTEyMDEyNywgbDogNTIgfSxcblx0ICAgIHsgaDogMjUsIHM6IC0xMjAxNzksIGw6IDUyIH0sXG5cdCAgICB7IGg6IDI1LCBzOiAtMTIwMjMxLCBsOiA1MiB9LFxuXHQgICAgeyBoOiAyNSwgczogLTEyMDI4MywgbDogNTIgfSxcblx0ICAgIHsgaDogMjUsIHM6IC0xMjAzMzUsIGw6IDUyIH0sXG5cdCAgICB7IGg6IDI0LCBzOiAtMTE5NTQzLCBlOiBbMTddLCBsOiA1NiB9LFxuXHQgICAgeyBoOiAyNCwgczogLTExOTYwMSwgZTogWzE3XSwgbDogNTggfSxcblx0ICAgIHsgaDogMjQsIHM6IC0xMTk2NTksIGU6IFsxN10sIGw6IDU4IH0sXG5cdCAgICB7IGg6IDI0LCBzOiAtMTE5NzE3LCBlOiBbMTddLCBsOiA1OCB9LFxuXHQgICAgeyBoOiAyNCwgczogLTExOTc3NSwgZTogWzE3XSwgbDogNTggfVxuXHRdO1xuXHR2YXIgVGFibGVfQl8yX2x1dF9hYnMgPSBjcmVhdGVUYWJsZShcImI1OjNiYyxjMzpmZiw3OjczLDI6MjUzLDU6MjU0LDM6MjU2LDE6MjU3LDU6MjU5LDE6MjViLDM6MjYwLDE6MjYzLDI6MjY5LDE6MjY4LDU6MjZmLDE6MjcyLDI6Mjc1LDc6MjgwLDM6MjgzLDU6Mjg4LDM6MjhhLDE6MjhiLDU6MjkyLDNmOjE5NSwxOjFiZiwyOToxOWUsMTI1OjNiOSw4YjozYjIsMTozYjgsMTozYzUsMzozYzYsMTozYzAsMWE6M2JhLDE6M2MxLDE6M2MzLDI6M2I4LDE6M2I1LDFiYzk6M2I5LDFjOjFmNzYsMToxZjc3LGY6MWY3YSwxOjFmN2IsZDoxZjc4LDE6MWY3OSwxOjFmN2MsMToxZjdkLDEwNzo2Myw1OjI1Yiw0OjY4LDE6NjgsMTo2OCwzOjY5LDE6NjksMTo2YywzOjZlLDQ6NzAsMTo3MSwxOjcyLDE6NzIsMTo3Miw3OjdhLDI6M2M5LDI6N2EsMjo2YiwxOmU1LDE6NjIsMTo2MywzOjY1LDE6NjYsMjo2ZCxiOjNiMywxOjNjMCw2OjY0LDFiNTc0OjNiOCwxYTozYzMsMjA6M2I4LDFhOjNjMywyMDozYjgsMWE6M2MzLDIwOjNiOCwxYTozYzMsMjA6M2I4LDFhOjNjM1wiKTtcblx0dmFyIFRhYmxlX0JfMl9sdXRfcmVsID0gY3JlYXRlVGFibGUoXCIxNzk6MSwyOjEsMjoxLDU6MSwyOjEsYTo0ZixhOjEsODoxLDI6MSwyOjEsMzoxLDU6MSwzOjEsNDoxLDI6MSwzOjEsNDoxLDg6MiwxOjEsMjoyLDE6MSwyOjIsMjc6MiwxOTU6MjYsMjoyNSwxOjI1LDE6MjUsMjo0MCwyOjNmLDE6M2YsMzM6MSwxMTotNiwxOi05LDFhYzc6LTNhLDZkOi04LDE6LTgsMTotOCwxOi04LDE6LTgsMTotOCwxOi04LDE6LTgsOTotOCwxOi04LDE6LTgsMTotOCwxOi04LDE6LTgsYjotOCwxOi04LDE6LTgsMTotOCwxOi04LDE6LTgsMTotOCwxOi04LDk6LTgsMTotOCwxOi04LDE6LTgsMTotOCwxOi04LDE6LTgsMTotOCw5Oi04LDE6LTgsMTotOCwxOi04LDE6LTgsMTotOCxjOi04LDI6LTgsMjotOCwyOi04LDk6LTgsMTotOCwxOi04LDE6LTgsMTotOCwxOi04LDE6LTgsMTotOCw0OTotOCwxOi04LDE6LTRhLDE6LTRhLGQ6LTU2LDE6LTU2LDE6LTU2LDE6LTU2LGQ6LTgsMTotOCxmOi04LDE6LTgsMzotN1wiKTtcblx0dmFyIFRhYmxlX0JfMl9jb21wbGV4ID0gY3JlYXRlVGFibGUoXCJkZjowMDczMDA3Myw1MTowMDY5MDMwNywxOTowMkJDMDA2RSxhNzowMDZBMDMwQywxOGE6MDAyMDAzQjksMTY6MDNCOTAzMDgwMzAxLDIwOjAzQzUwMzA4MDMwMSwxZDc6MDU2NTA1ODIsMTkwZjowMDY4MDMzMSwxOjAwNzQwMzA4LDE6MDA3NzAzMEEsMTowMDc5MDMwQSwxOjAwNjEwMkJFLGI2OjAzQzUwMzEzLDI6MDNDNTAzMTMwMzAwLDI6MDNDNTAzMTMwMzAxLDI6MDNDNTAzMTMwMzQyLDJhOjFGMDAwM0I5LDE6MUYwMTAzQjksMToxRjAyMDNCOSwxOjFGMDMwM0I5LDE6MUYwNDAzQjksMToxRjA1MDNCOSwxOjFGMDYwM0I5LDE6MUYwNzAzQjksMToxRjAwMDNCOSwxOjFGMDEwM0I5LDE6MUYwMjAzQjksMToxRjAzMDNCOSwxOjFGMDQwM0I5LDE6MUYwNTAzQjksMToxRjA2MDNCOSwxOjFGMDcwM0I5LDE6MUYyMDAzQjksMToxRjIxMDNCOSwxOjFGMjIwM0I5LDE6MUYyMzAzQjksMToxRjI0MDNCOSwxOjFGMjUwM0I5LDE6MUYyNjAzQjksMToxRjI3MDNCOSwxOjFGMjAwM0I5LDE6MUYyMTAzQjksMToxRjIyMDNCOSwxOjFGMjMwM0I5LDE6MUYyNDAzQjksMToxRjI1MDNCOSwxOjFGMjYwM0I5LDE6MUYyNzAzQjksMToxRjYwMDNCOSwxOjFGNjEwM0I5LDE6MUY2MjAzQjksMToxRjYzMDNCOSwxOjFGNjQwM0I5LDE6MUY2NTAzQjksMToxRjY2MDNCOSwxOjFGNjcwM0I5LDE6MUY2MDAzQjksMToxRjYxMDNCOSwxOjFGNjIwM0I5LDE6MUY2MzAzQjksMToxRjY0MDNCOSwxOjFGNjUwM0I5LDE6MUY2NjAzQjksMToxRjY3MDNCOSwzOjFGNzAwM0I5LDE6MDNCMTAzQjksMTowM0FDMDNCOSwyOjAzQjEwMzQyLDE6MDNCMTAzNDIwM0I5LDU6MDNCMTAzQjksNjoxRjc0MDNCOSwxOjAzQjcwM0I5LDE6MDNBRTAzQjksMjowM0I3MDM0MiwxOjAzQjcwMzQyMDNCOSw1OjAzQjcwM0I5LDY6MDNCOTAzMDgwMzAwLDE6MDNCOTAzMDgwMzAxLDM6MDNCOTAzNDIsMTowM0I5MDMwODAzNDIsYjowM0M1MDMwODAzMDAsMTowM0M1MDMwODAzMDEsMTowM0MxMDMxMywyOjAzQzUwMzQyLDE6MDNDNTAzMDgwMzQyLGI6MUY3QzAzQjksMTowM0M5MDNCOSwxOjAzQ0UwM0I5LDI6MDNDOTAzNDIsMTowM0M5MDM0MjAzQjksNTowM0M5MDNCOSxhYzowMDcyMDA3Myw1YjowMEIwMDA2Myw2OjAwQjAwMDY2LGQ6MDA2RTAwNkYsYTowMDczMDA2RCwxOjAwNzQwMDY1MDA2QywxOjAwNzQwMDZELDEyNGY6MDA2ODAwNzAwMDYxLDI6MDA2MTAwNzUsMjowMDZGMDA3NixiOjAwNzAwMDYxLDE6MDA2RTAwNjEsMTowM0JDMDA2MSwxOjAwNkQwMDYxLDE6MDA2QjAwNjEsMTowMDZCMDA2MiwxOjAwNkQwMDYyLDE6MDA2NzAwNjIsMzowMDcwMDA2NiwxOjAwNkUwMDY2LDE6MDNCQzAwNjYsNDowMDY4MDA3QSwxOjAwNkIwMDY4MDA3QSwxOjAwNkQwMDY4MDA3QSwxOjAwNjcwMDY4MDA3QSwxOjAwNzQwMDY4MDA3QSwxNTowMDcwMDA2MSwxOjAwNkIwMDcwMDA2MSwxOjAwNkQwMDcwMDA2MSwxOjAwNjcwMDcwMDA2MSw4OjAwNzAwMDc2LDE6MDA2RTAwNzYsMTowM0JDMDA3NiwxOjAwNkQwMDc2LDE6MDA2QjAwNzYsMTowMDZEMDA3NiwxOjAwNzAwMDc3LDE6MDA2RTAwNzcsMTowM0JDMDA3NywxOjAwNkQwMDc3LDE6MDA2QjAwNzcsMTowMDZEMDA3NywxOjAwNkIwM0M5LDE6MDA2RDAzQzksMjowMDYyMDA3MSwzOjAwNjMyMjE1MDA2QjAwNjcsMTowMDYzMDA2RjAwMkUsMTowMDY0MDA2MiwxOjAwNjcwMDc5LDI6MDA2ODAwNzAsMjowMDZCMDA2QiwxOjAwNkIwMDZELDk6MDA3MDAwNjgsMjowMDcwMDA3MDAwNkQsMTowMDcwMDA3MiwyOjAwNzMwMDc2LDE6MDA3NzAwNjIsYzcyMzowMDY2MDA2NiwxOjAwNjYwMDY5LDE6MDA2NjAwNkMsMTowMDY2MDA2NjAwNjksMTowMDY2MDA2NjAwNkMsMTowMDczMDA3NCwxOjAwNzMwMDc0LGQ6MDU3NDA1NzYsMTowNTc0MDU2NSwxOjA1NzQwNTZCLDE6MDU3RTA1NzYsMTowNTc0MDU2RFwiLCBieXRlczIpO1xuXHR2YXIgVGFibGVfQ19yYW5nZXMgPSBjcmVhdGVSYW5nZVRhYmxlKFwiODAtMjAsMmEwLSwzOWMsMzIsZjcxLDE4ZSw3ZjItZiwxOS03LDMwLTQsNy01LGY4MS1iLDUsYTgwMC0yMGZmLDRkMS0xZiwxMTAsZmEtNixkMTc0LTcsMmU4NC0sZmZmZi0sZmZmZi0sZmZmZi0sZmZmZi0sZmZmZi0sZmZmZi0sZmZmZi0sZmZmZi0sZmZmZi0sZmZmZi0sZmZmZi0sZmZmZi0sMiwxZi01ZixmZjdmLTIwMDAxXCIpO1xuXHRmdW5jdGlvbiBmbGF0dGVuKHZhbHVlcykge1xuXHQgICAgcmV0dXJuIHZhbHVlcy5yZWR1Y2UoZnVuY3Rpb24gKGFjY3VtLCB2YWx1ZSkge1xuXHQgICAgICAgIHZhbHVlLmZvckVhY2goZnVuY3Rpb24gKHZhbHVlKSB7IGFjY3VtLnB1c2godmFsdWUpOyB9KTtcblx0ICAgICAgICByZXR1cm4gYWNjdW07XG5cdCAgICB9LCBbXSk7XG5cdH1cblx0ZnVuY3Rpb24gX25hbWVwcmVwVGFibGVBMShjb2RlcG9pbnQpIHtcblx0ICAgIHJldHVybiAhIW1hdGNoTWFwKGNvZGVwb2ludCwgVGFibGVfQV8xX3Jhbmdlcyk7XG5cdH1cblx0ZXhwb3J0cy5fbmFtZXByZXBUYWJsZUExID0gX25hbWVwcmVwVGFibGVBMTtcblx0ZnVuY3Rpb24gX25hbWVwcmVwVGFibGVCMihjb2RlcG9pbnQpIHtcblx0ICAgIHZhciByYW5nZSA9IG1hdGNoTWFwKGNvZGVwb2ludCwgVGFibGVfQl8yX3Jhbmdlcyk7XG5cdCAgICBpZiAocmFuZ2UpIHtcblx0ICAgICAgICByZXR1cm4gW2NvZGVwb2ludCArIHJhbmdlLnNdO1xuXHQgICAgfVxuXHQgICAgdmFyIGNvZGVzID0gVGFibGVfQl8yX2x1dF9hYnNbY29kZXBvaW50XTtcblx0ICAgIGlmIChjb2Rlcykge1xuXHQgICAgICAgIHJldHVybiBjb2Rlcztcblx0ICAgIH1cblx0ICAgIHZhciBzaGlmdCA9IFRhYmxlX0JfMl9sdXRfcmVsW2NvZGVwb2ludF07XG5cdCAgICBpZiAoc2hpZnQpIHtcblx0ICAgICAgICByZXR1cm4gW2NvZGVwb2ludCArIHNoaWZ0WzBdXTtcblx0ICAgIH1cblx0ICAgIHZhciBjb21wbGV4ID0gVGFibGVfQl8yX2NvbXBsZXhbY29kZXBvaW50XTtcblx0ICAgIGlmIChjb21wbGV4KSB7XG5cdCAgICAgICAgcmV0dXJuIGNvbXBsZXg7XG5cdCAgICB9XG5cdCAgICByZXR1cm4gbnVsbDtcblx0fVxuXHRleHBvcnRzLl9uYW1lcHJlcFRhYmxlQjIgPSBfbmFtZXByZXBUYWJsZUIyO1xuXHRmdW5jdGlvbiBfbmFtZXByZXBUYWJsZUMoY29kZXBvaW50KSB7XG5cdCAgICByZXR1cm4gISFtYXRjaE1hcChjb2RlcG9pbnQsIFRhYmxlX0NfcmFuZ2VzKTtcblx0fVxuXHRleHBvcnRzLl9uYW1lcHJlcFRhYmxlQyA9IF9uYW1lcHJlcFRhYmxlQztcblx0ZnVuY3Rpb24gbmFtZXByZXAodmFsdWUpIHtcblx0ICAgIC8vIFRoaXMgYWxsb3dzIHBsYXRmb3JtcyB3aXRoIGluY29tcGxldGUgbm9ybWFsaXplIHRvIGJ5cGFzc1xuXHQgICAgLy8gaXQgZm9yIHZlcnkgYmFzaWMgbmFtZXMgd2hpY2ggdGhlIGJ1aWx0LWluIHRvTG93ZXJDYXNlXG5cdCAgICAvLyB3aWxsIGNlcnRhaW5seSBoYW5kbGUgY29ycmVjdGx5XG5cdCAgICBpZiAodmFsdWUubWF0Y2goL15bYS16MC05LV0qJC9pKSAmJiB2YWx1ZS5sZW5ndGggPD0gNTkpIHtcblx0ICAgICAgICByZXR1cm4gdmFsdWUudG9Mb3dlckNhc2UoKTtcblx0ICAgIH1cblx0ICAgIC8vIEdldCB0aGUgY29kZSBwb2ludHMgKGtlZXBpbmcgdGhlIGN1cnJlbnQgbm9ybWFsaXphdGlvbilcblx0ICAgIHZhciBjb2RlcyA9ICgwLCB1dGY4LnRvVXRmOENvZGVQb2ludHMpKHZhbHVlKTtcblx0ICAgIGNvZGVzID0gZmxhdHRlbihjb2Rlcy5tYXAoZnVuY3Rpb24gKGNvZGUpIHtcblx0ICAgICAgICAvLyBTdWJzdGl0dXRlIFRhYmxlIEIuMSAoTWFwcyB0byBOb3RoaW5nKVxuXHQgICAgICAgIGlmIChUYWJsZV9CXzFfZmxhZ3MuaW5kZXhPZihjb2RlKSA+PSAwKSB7XG5cdCAgICAgICAgICAgIHJldHVybiBbXTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgaWYgKGNvZGUgPj0gMHhmZTAwICYmIGNvZGUgPD0gMHhmZTBmKSB7XG5cdCAgICAgICAgICAgIHJldHVybiBbXTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgLy8gU3Vic3RpdHV0ZSBUYWJsZSBCLjIgKENhc2UgRm9sZGluZylcblx0ICAgICAgICB2YXIgY29kZXNUYWJsZUIyID0gX25hbWVwcmVwVGFibGVCMihjb2RlKTtcblx0ICAgICAgICBpZiAoY29kZXNUYWJsZUIyKSB7XG5cdCAgICAgICAgICAgIHJldHVybiBjb2Rlc1RhYmxlQjI7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIC8vIE5vIFN1YnN0aXR1dGlvblxuXHQgICAgICAgIHJldHVybiBbY29kZV07XG5cdCAgICB9KSk7XG5cdCAgICAvLyBOb3JtYWxpemUgdXNpbmcgZm9ybSBLQ1xuXHQgICAgY29kZXMgPSAoMCwgdXRmOC50b1V0ZjhDb2RlUG9pbnRzKSgoMCwgdXRmOC5fdG9VdGY4U3RyaW5nKShjb2RlcyksIHV0ZjguVW5pY29kZU5vcm1hbGl6YXRpb25Gb3JtLk5GS0MpO1xuXHQgICAgLy8gUHJvaGliaXQgVGFibGVzIEMuMS4yLCBDLjIuMiwgQy4zLCBDLjQsIEMuNSwgQy42LCBDLjcsIEMuOCwgQy45XG5cdCAgICBjb2Rlcy5mb3JFYWNoKGZ1bmN0aW9uIChjb2RlKSB7XG5cdCAgICAgICAgaWYgKF9uYW1lcHJlcFRhYmxlQyhjb2RlKSkge1xuXHQgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJTVFJJTkdQUkVQX0NPTlRBSU5TX1BST0hJQklURURcIik7XG5cdCAgICAgICAgfVxuXHQgICAgfSk7XG5cdCAgICAvLyBQcm9oaWJpdCBVbmFzc2lnbmVkIENvZGUgUG9pbnRzIChUYWJsZSBBLjEpXG5cdCAgICBjb2Rlcy5mb3JFYWNoKGZ1bmN0aW9uIChjb2RlKSB7XG5cdCAgICAgICAgaWYgKF9uYW1lcHJlcFRhYmxlQTEoY29kZSkpIHtcblx0ICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiU1RSSU5HUFJFUF9DT05UQUlOU19VTkFTU0lHTkVEXCIpO1xuXHQgICAgICAgIH1cblx0ICAgIH0pO1xuXHQgICAgLy8gSUROQSBleHRyYXNcblx0ICAgIHZhciBuYW1lID0gKDAsIHV0ZjguX3RvVXRmOFN0cmluZykoY29kZXMpO1xuXHQgICAgLy8gSUROQTogNC4yLjMuMVxuXHQgICAgaWYgKG5hbWUuc3Vic3RyaW5nKDAsIDEpID09PSBcIi1cIiB8fCBuYW1lLnN1YnN0cmluZygyLCA0KSA9PT0gXCItLVwiIHx8IG5hbWUuc3Vic3RyaW5nKG5hbWUubGVuZ3RoIC0gMSkgPT09IFwiLVwiKSB7XG5cdCAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBoeXBoZW5cIik7XG5cdCAgICB9XG5cdCAgICAvLyBJRE5BOiA0LjIuNFxuXHQgICAgaWYgKG5hbWUubGVuZ3RoID4gNjMpIHtcblx0ICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJ0b28gbG9uZ1wiKTtcblx0ICAgIH1cblx0ICAgIHJldHVybiBuYW1lO1xuXHR9XG5cdGV4cG9ydHMubmFtZXByZXAgPSBuYW1lcHJlcDtcblxuXHR9KTtcblxuXHR2YXIgaWRuYSQxID0gLypAX19QVVJFX18qL2dldERlZmF1bHRFeHBvcnRGcm9tQ2pzKGlkbmEpO1xuXG5cdHZhciBsaWIkOCA9IGNyZWF0ZUNvbW1vbmpzTW9kdWxlKGZ1bmN0aW9uIChtb2R1bGUsIGV4cG9ydHMpIHtcblx0XCJ1c2Ugc3RyaWN0XCI7XG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcblx0ZXhwb3J0cy5uYW1lcHJlcCA9IGV4cG9ydHMucGFyc2VCeXRlczMyU3RyaW5nID0gZXhwb3J0cy5mb3JtYXRCeXRlczMyU3RyaW5nID0gZXhwb3J0cy5Vbmljb2RlTm9ybWFsaXphdGlvbkZvcm0gPSBleHBvcnRzLlV0ZjhFcnJvclJlYXNvbiA9IGV4cG9ydHMuVXRmOEVycm9yRnVuY3MgPSBleHBvcnRzLnRvVXRmOFN0cmluZyA9IGV4cG9ydHMudG9VdGY4Q29kZVBvaW50cyA9IGV4cG9ydHMudG9VdGY4Qnl0ZXMgPSBleHBvcnRzLl90b0VzY2FwZWRVdGY4U3RyaW5nID0gdm9pZCAwO1xuXG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImZvcm1hdEJ5dGVzMzJTdHJpbmdcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGJ5dGVzMzIuZm9ybWF0Qnl0ZXMzMlN0cmluZzsgfSB9KTtcblx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwicGFyc2VCeXRlczMyU3RyaW5nXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBieXRlczMyLnBhcnNlQnl0ZXMzMlN0cmluZzsgfSB9KTtcblxuXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJuYW1lcHJlcFwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gaWRuYS5uYW1lcHJlcDsgfSB9KTtcblxuXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfdG9Fc2NhcGVkVXRmOFN0cmluZ1wiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdXRmOC5fdG9Fc2NhcGVkVXRmOFN0cmluZzsgfSB9KTtcblx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwidG9VdGY4Qnl0ZXNcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHV0ZjgudG9VdGY4Qnl0ZXM7IH0gfSk7XG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcInRvVXRmOENvZGVQb2ludHNcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHV0ZjgudG9VdGY4Q29kZVBvaW50czsgfSB9KTtcblx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwidG9VdGY4U3RyaW5nXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB1dGY4LnRvVXRmOFN0cmluZzsgfSB9KTtcblx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiVW5pY29kZU5vcm1hbGl6YXRpb25Gb3JtXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB1dGY4LlVuaWNvZGVOb3JtYWxpemF0aW9uRm9ybTsgfSB9KTtcblx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiVXRmOEVycm9yRnVuY3NcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHV0ZjguVXRmOEVycm9yRnVuY3M7IH0gfSk7XG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlV0ZjhFcnJvclJlYXNvblwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdXRmOC5VdGY4RXJyb3JSZWFzb247IH0gfSk7XG5cblx0fSk7XG5cblx0dmFyIGluZGV4JDggPSAvKkBfX1BVUkVfXyovZ2V0RGVmYXVsdEV4cG9ydEZyb21DanMobGliJDgpO1xuXG5cdHZhciBzdHJpbmcgPSBjcmVhdGVDb21tb25qc01vZHVsZShmdW5jdGlvbiAobW9kdWxlLCBleHBvcnRzKSB7XG5cdFwidXNlIHN0cmljdFwiO1xuXHR2YXIgX19leHRlbmRzID0gKGNvbW1vbmpzR2xvYmFsICYmIGNvbW1vbmpzR2xvYmFsLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcblx0ICAgIHZhciBleHRlbmRTdGF0aWNzID0gZnVuY3Rpb24gKGQsIGIpIHtcblx0ICAgICAgICBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG5cdCAgICAgICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcblx0ICAgICAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGIsIHApKSBkW3BdID0gYltwXTsgfTtcblx0ICAgICAgICByZXR1cm4gZXh0ZW5kU3RhdGljcyhkLCBiKTtcblx0ICAgIH07XG5cdCAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcblx0ICAgICAgICBpZiAodHlwZW9mIGIgIT09IFwiZnVuY3Rpb25cIiAmJiBiICE9PSBudWxsKVxuXHQgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2xhc3MgZXh0ZW5kcyB2YWx1ZSBcIiArIFN0cmluZyhiKSArIFwiIGlzIG5vdCBhIGNvbnN0cnVjdG9yIG9yIG51bGxcIik7XG5cdCAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcblx0ICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cblx0ICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG5cdCAgICB9O1xuXHR9KSgpO1xuXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5cdGV4cG9ydHMuU3RyaW5nQ29kZXIgPSB2b2lkIDA7XG5cblxuXHR2YXIgU3RyaW5nQ29kZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG5cdCAgICBfX2V4dGVuZHMoU3RyaW5nQ29kZXIsIF9zdXBlcik7XG5cdCAgICBmdW5jdGlvbiBTdHJpbmdDb2Rlcihsb2NhbE5hbWUpIHtcblx0ICAgICAgICByZXR1cm4gX3N1cGVyLmNhbGwodGhpcywgXCJzdHJpbmdcIiwgbG9jYWxOYW1lKSB8fCB0aGlzO1xuXHQgICAgfVxuXHQgICAgU3RyaW5nQ29kZXIucHJvdG90eXBlLmRlZmF1bHRWYWx1ZSA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICByZXR1cm4gXCJcIjtcblx0ICAgIH07XG5cdCAgICBTdHJpbmdDb2Rlci5wcm90b3R5cGUuZW5jb2RlID0gZnVuY3Rpb24gKHdyaXRlciwgdmFsdWUpIHtcblx0ICAgICAgICByZXR1cm4gX3N1cGVyLnByb3RvdHlwZS5lbmNvZGUuY2FsbCh0aGlzLCB3cml0ZXIsICgwLCBsaWIkOC50b1V0ZjhCeXRlcykodmFsdWUpKTtcblx0ICAgIH07XG5cdCAgICBTdHJpbmdDb2Rlci5wcm90b3R5cGUuZGVjb2RlID0gZnVuY3Rpb24gKHJlYWRlcikge1xuXHQgICAgICAgIHJldHVybiAoMCwgbGliJDgudG9VdGY4U3RyaW5nKShfc3VwZXIucHJvdG90eXBlLmRlY29kZS5jYWxsKHRoaXMsIHJlYWRlcikpO1xuXHQgICAgfTtcblx0ICAgIHJldHVybiBTdHJpbmdDb2Rlcjtcblx0fShieXRlcy5EeW5hbWljQnl0ZXNDb2RlcikpO1xuXHRleHBvcnRzLlN0cmluZ0NvZGVyID0gU3RyaW5nQ29kZXI7XG5cblx0fSk7XG5cblx0dmFyIHN0cmluZyQxID0gLypAX19QVVJFX18qL2dldERlZmF1bHRFeHBvcnRGcm9tQ2pzKHN0cmluZyk7XG5cblx0dmFyIHR1cGxlID0gY3JlYXRlQ29tbW9uanNNb2R1bGUoZnVuY3Rpb24gKG1vZHVsZSwgZXhwb3J0cykge1xuXHRcInVzZSBzdHJpY3RcIjtcblx0dmFyIF9fZXh0ZW5kcyA9IChjb21tb25qc0dsb2JhbCAmJiBjb21tb25qc0dsb2JhbC5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG5cdCAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IGZ1bmN0aW9uIChkLCBiKSB7XG5cdCAgICAgICAgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuXHQgICAgICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG5cdCAgICAgICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChiLCBwKSkgZFtwXSA9IGJbcF07IH07XG5cdCAgICAgICAgcmV0dXJuIGV4dGVuZFN0YXRpY3MoZCwgYik7XG5cdCAgICB9O1xuXHQgICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG5cdCAgICAgICAgaWYgKHR5cGVvZiBiICE9PSBcImZ1bmN0aW9uXCIgJiYgYiAhPT0gbnVsbClcblx0ICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNsYXNzIGV4dGVuZHMgdmFsdWUgXCIgKyBTdHJpbmcoYikgKyBcIiBpcyBub3QgYSBjb25zdHJ1Y3RvciBvciBudWxsXCIpO1xuXHQgICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG5cdCAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG5cdCAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuXHQgICAgfTtcblx0fSkoKTtcblx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuXHRleHBvcnRzLlR1cGxlQ29kZXIgPSB2b2lkIDA7XG5cblxuXHR2YXIgVHVwbGVDb2RlciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcblx0ICAgIF9fZXh0ZW5kcyhUdXBsZUNvZGVyLCBfc3VwZXIpO1xuXHQgICAgZnVuY3Rpb24gVHVwbGVDb2Rlcihjb2RlcnMsIGxvY2FsTmFtZSkge1xuXHQgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cdCAgICAgICAgdmFyIGR5bmFtaWMgPSBmYWxzZTtcblx0ICAgICAgICB2YXIgdHlwZXMgPSBbXTtcblx0ICAgICAgICBjb2RlcnMuZm9yRWFjaChmdW5jdGlvbiAoY29kZXIpIHtcblx0ICAgICAgICAgICAgaWYgKGNvZGVyLmR5bmFtaWMpIHtcblx0ICAgICAgICAgICAgICAgIGR5bmFtaWMgPSB0cnVlO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIHR5cGVzLnB1c2goY29kZXIudHlwZSk7XG5cdCAgICAgICAgfSk7XG5cdCAgICAgICAgdmFyIHR5cGUgPSAoXCJ0dXBsZShcIiArIHR5cGVzLmpvaW4oXCIsXCIpICsgXCIpXCIpO1xuXHQgICAgICAgIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgXCJ0dXBsZVwiLCB0eXBlLCBsb2NhbE5hbWUsIGR5bmFtaWMpIHx8IHRoaXM7XG5cdCAgICAgICAgX3RoaXMuY29kZXJzID0gY29kZXJzO1xuXHQgICAgICAgIHJldHVybiBfdGhpcztcblx0ICAgIH1cblx0ICAgIFR1cGxlQ29kZXIucHJvdG90eXBlLmRlZmF1bHRWYWx1ZSA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICB2YXIgdmFsdWVzID0gW107XG5cdCAgICAgICAgdGhpcy5jb2RlcnMuZm9yRWFjaChmdW5jdGlvbiAoY29kZXIpIHtcblx0ICAgICAgICAgICAgdmFsdWVzLnB1c2goY29kZXIuZGVmYXVsdFZhbHVlKCkpO1xuXHQgICAgICAgIH0pO1xuXHQgICAgICAgIC8vIFdlIG9ubHkgb3V0cHV0IG5hbWVkIHByb3BlcnRpZXMgZm9yIHVuaXF1ZWx5IG5hbWVkIGNvZGVyc1xuXHQgICAgICAgIHZhciB1bmlxdWVOYW1lcyA9IHRoaXMuY29kZXJzLnJlZHVjZShmdW5jdGlvbiAoYWNjdW0sIGNvZGVyKSB7XG5cdCAgICAgICAgICAgIHZhciBuYW1lID0gY29kZXIubG9jYWxOYW1lO1xuXHQgICAgICAgICAgICBpZiAobmFtZSkge1xuXHQgICAgICAgICAgICAgICAgaWYgKCFhY2N1bVtuYW1lXSkge1xuXHQgICAgICAgICAgICAgICAgICAgIGFjY3VtW25hbWVdID0gMDtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgIGFjY3VtW25hbWVdKys7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgcmV0dXJuIGFjY3VtO1xuXHQgICAgICAgIH0sIHt9KTtcblx0ICAgICAgICAvLyBBZGQgbmFtZWQgdmFsdWVzXG5cdCAgICAgICAgdGhpcy5jb2RlcnMuZm9yRWFjaChmdW5jdGlvbiAoY29kZXIsIGluZGV4KSB7XG5cdCAgICAgICAgICAgIHZhciBuYW1lID0gY29kZXIubG9jYWxOYW1lO1xuXHQgICAgICAgICAgICBpZiAoIW5hbWUgfHwgdW5pcXVlTmFtZXNbbmFtZV0gIT09IDEpIHtcblx0ICAgICAgICAgICAgICAgIHJldHVybjtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICBpZiAobmFtZSA9PT0gXCJsZW5ndGhcIikge1xuXHQgICAgICAgICAgICAgICAgbmFtZSA9IFwiX2xlbmd0aFwiO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIGlmICh2YWx1ZXNbbmFtZV0gIT0gbnVsbCkge1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIHZhbHVlc1tuYW1lXSA9IHZhbHVlc1tpbmRleF07XG5cdCAgICAgICAgfSk7XG5cdCAgICAgICAgcmV0dXJuIE9iamVjdC5mcmVlemUodmFsdWVzKTtcblx0ICAgIH07XG5cdCAgICBUdXBsZUNvZGVyLnByb3RvdHlwZS5lbmNvZGUgPSBmdW5jdGlvbiAod3JpdGVyLCB2YWx1ZSkge1xuXHQgICAgICAgIHJldHVybiAoMCwgYXJyYXkucGFjaykod3JpdGVyLCB0aGlzLmNvZGVycywgdmFsdWUpO1xuXHQgICAgfTtcblx0ICAgIFR1cGxlQ29kZXIucHJvdG90eXBlLmRlY29kZSA9IGZ1bmN0aW9uIChyZWFkZXIpIHtcblx0ICAgICAgICByZXR1cm4gcmVhZGVyLmNvZXJjZSh0aGlzLm5hbWUsICgwLCBhcnJheS51bnBhY2spKHJlYWRlciwgdGhpcy5jb2RlcnMpKTtcblx0ICAgIH07XG5cdCAgICByZXR1cm4gVHVwbGVDb2Rlcjtcblx0fShhYnN0cmFjdENvZGVyLkNvZGVyKSk7XG5cdGV4cG9ydHMuVHVwbGVDb2RlciA9IFR1cGxlQ29kZXI7XG5cblx0fSk7XG5cblx0dmFyIHR1cGxlJDEgPSAvKkBfX1BVUkVfXyovZ2V0RGVmYXVsdEV4cG9ydEZyb21DanModHVwbGUpO1xuXG5cdHZhciBhYmlDb2RlciA9IGNyZWF0ZUNvbW1vbmpzTW9kdWxlKGZ1bmN0aW9uIChtb2R1bGUsIGV4cG9ydHMpIHtcblx0XCJ1c2Ugc3RyaWN0XCI7XG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcblx0ZXhwb3J0cy5kZWZhdWx0QWJpQ29kZXIgPSBleHBvcnRzLkFiaUNvZGVyID0gdm9pZCAwO1xuXHQvLyBTZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9ldGhlcmV1bS93aWtpL3dpa2kvRXRoZXJldW0tQ29udHJhY3QtQUJJXG5cblxuXG5cblx0dmFyIGxvZ2dlciA9IG5ldyBsaWIuTG9nZ2VyKF92ZXJzaW9uJDgudmVyc2lvbik7XG5cblxuXG5cblxuXG5cblxuXG5cblxuXHR2YXIgcGFyYW1UeXBlQnl0ZXMgPSBuZXcgUmVnRXhwKC9eYnl0ZXMoWzAtOV0qKSQvKTtcblx0dmFyIHBhcmFtVHlwZU51bWJlciA9IG5ldyBSZWdFeHAoL14odT9pbnQpKFswLTldKikkLyk7XG5cdHZhciBBYmlDb2RlciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcblx0ICAgIGZ1bmN0aW9uIEFiaUNvZGVyKGNvZXJjZUZ1bmMpIHtcblx0ICAgICAgICB2YXIgX25ld1RhcmdldCA9IHRoaXMuY29uc3RydWN0b3I7XG5cdCAgICAgICAgbG9nZ2VyLmNoZWNrTmV3KF9uZXdUYXJnZXQsIEFiaUNvZGVyKTtcblx0ICAgICAgICAoMCwgbGliJDMuZGVmaW5lUmVhZE9ubHkpKHRoaXMsIFwiY29lcmNlRnVuY1wiLCBjb2VyY2VGdW5jIHx8IG51bGwpO1xuXHQgICAgfVxuXHQgICAgQWJpQ29kZXIucHJvdG90eXBlLl9nZXRDb2RlciA9IGZ1bmN0aW9uIChwYXJhbSkge1xuXHQgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cdCAgICAgICAgc3dpdGNoIChwYXJhbS5iYXNlVHlwZSkge1xuXHQgICAgICAgICAgICBjYXNlIFwiYWRkcmVzc1wiOlxuXHQgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBhZGRyZXNzLkFkZHJlc3NDb2RlcihwYXJhbS5uYW1lKTtcblx0ICAgICAgICAgICAgY2FzZSBcImJvb2xcIjpcblx0ICAgICAgICAgICAgICAgIHJldHVybiBuZXcgYm9vbGVhbl8xLkJvb2xlYW5Db2RlcihwYXJhbS5uYW1lKTtcblx0ICAgICAgICAgICAgY2FzZSBcInN0cmluZ1wiOlxuXHQgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBzdHJpbmcuU3RyaW5nQ29kZXIocGFyYW0ubmFtZSk7XG5cdCAgICAgICAgICAgIGNhc2UgXCJieXRlc1wiOlxuXHQgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBieXRlcy5CeXRlc0NvZGVyKHBhcmFtLm5hbWUpO1xuXHQgICAgICAgICAgICBjYXNlIFwiYXJyYXlcIjpcblx0ICAgICAgICAgICAgICAgIHJldHVybiBuZXcgYXJyYXkuQXJyYXlDb2Rlcih0aGlzLl9nZXRDb2RlcihwYXJhbS5hcnJheUNoaWxkcmVuKSwgcGFyYW0uYXJyYXlMZW5ndGgsIHBhcmFtLm5hbWUpO1xuXHQgICAgICAgICAgICBjYXNlIFwidHVwbGVcIjpcblx0ICAgICAgICAgICAgICAgIHJldHVybiBuZXcgdHVwbGUuVHVwbGVDb2RlcigocGFyYW0uY29tcG9uZW50cyB8fCBbXSkubWFwKGZ1bmN0aW9uIChjb21wb25lbnQpIHtcblx0ICAgICAgICAgICAgICAgICAgICByZXR1cm4gX3RoaXMuX2dldENvZGVyKGNvbXBvbmVudCk7XG5cdCAgICAgICAgICAgICAgICB9KSwgcGFyYW0ubmFtZSk7XG5cdCAgICAgICAgICAgIGNhc2UgXCJcIjpcblx0ICAgICAgICAgICAgICAgIHJldHVybiBuZXcgX251bGwuTnVsbENvZGVyKHBhcmFtLm5hbWUpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICAvLyB1P2ludFswLTldKlxuXHQgICAgICAgIHZhciBtYXRjaCA9IHBhcmFtLnR5cGUubWF0Y2gocGFyYW1UeXBlTnVtYmVyKTtcblx0ICAgICAgICBpZiAobWF0Y2gpIHtcblx0ICAgICAgICAgICAgdmFyIHNpemUgPSBwYXJzZUludChtYXRjaFsyXSB8fCBcIjI1NlwiKTtcblx0ICAgICAgICAgICAgaWYgKHNpemUgPT09IDAgfHwgc2l6ZSA+IDI1NiB8fCAoc2l6ZSAlIDgpICE9PSAwKSB7XG5cdCAgICAgICAgICAgICAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwiaW52YWxpZCBcIiArIG1hdGNoWzFdICsgXCIgYml0IGxlbmd0aFwiLCBcInBhcmFtXCIsIHBhcmFtKTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICByZXR1cm4gbmV3IG51bWJlci5OdW1iZXJDb2RlcihzaXplIC8gOCwgKG1hdGNoWzFdID09PSBcImludFwiKSwgcGFyYW0ubmFtZSk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIC8vIGJ5dGVzWzAtOV0rXG5cdCAgICAgICAgbWF0Y2ggPSBwYXJhbS50eXBlLm1hdGNoKHBhcmFtVHlwZUJ5dGVzKTtcblx0ICAgICAgICBpZiAobWF0Y2gpIHtcblx0ICAgICAgICAgICAgdmFyIHNpemUgPSBwYXJzZUludChtYXRjaFsxXSk7XG5cdCAgICAgICAgICAgIGlmIChzaXplID09PSAwIHx8IHNpemUgPiAzMikge1xuXHQgICAgICAgICAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcImludmFsaWQgYnl0ZXMgbGVuZ3RoXCIsIFwicGFyYW1cIiwgcGFyYW0pO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIHJldHVybiBuZXcgZml4ZWRCeXRlcy5GaXhlZEJ5dGVzQ29kZXIoc2l6ZSwgcGFyYW0ubmFtZSk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHJldHVybiBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwiaW52YWxpZCB0eXBlXCIsIFwidHlwZVwiLCBwYXJhbS50eXBlKTtcblx0ICAgIH07XG5cdCAgICBBYmlDb2Rlci5wcm90b3R5cGUuX2dldFdvcmRTaXplID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gMzI7IH07XG5cdCAgICBBYmlDb2Rlci5wcm90b3R5cGUuX2dldFJlYWRlciA9IGZ1bmN0aW9uIChkYXRhLCBhbGxvd0xvb3NlKSB7XG5cdCAgICAgICAgcmV0dXJuIG5ldyBhYnN0cmFjdENvZGVyLlJlYWRlcihkYXRhLCB0aGlzLl9nZXRXb3JkU2l6ZSgpLCB0aGlzLmNvZXJjZUZ1bmMsIGFsbG93TG9vc2UpO1xuXHQgICAgfTtcblx0ICAgIEFiaUNvZGVyLnByb3RvdHlwZS5fZ2V0V3JpdGVyID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIHJldHVybiBuZXcgYWJzdHJhY3RDb2Rlci5Xcml0ZXIodGhpcy5fZ2V0V29yZFNpemUoKSk7XG5cdCAgICB9O1xuXHQgICAgQWJpQ29kZXIucHJvdG90eXBlLmdldERlZmF1bHRWYWx1ZSA9IGZ1bmN0aW9uICh0eXBlcykge1xuXHQgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cdCAgICAgICAgdmFyIGNvZGVycyA9IHR5cGVzLm1hcChmdW5jdGlvbiAodHlwZSkgeyByZXR1cm4gX3RoaXMuX2dldENvZGVyKGZyYWdtZW50cy5QYXJhbVR5cGUuZnJvbSh0eXBlKSk7IH0pO1xuXHQgICAgICAgIHZhciBjb2RlciA9IG5ldyB0dXBsZS5UdXBsZUNvZGVyKGNvZGVycywgXCJfXCIpO1xuXHQgICAgICAgIHJldHVybiBjb2Rlci5kZWZhdWx0VmFsdWUoKTtcblx0ICAgIH07XG5cdCAgICBBYmlDb2Rlci5wcm90b3R5cGUuZW5jb2RlID0gZnVuY3Rpb24gKHR5cGVzLCB2YWx1ZXMpIHtcblx0ICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXHQgICAgICAgIGlmICh0eXBlcy5sZW5ndGggIT09IHZhbHVlcy5sZW5ndGgpIHtcblx0ICAgICAgICAgICAgbG9nZ2VyLnRocm93RXJyb3IoXCJ0eXBlcy92YWx1ZXMgbGVuZ3RoIG1pc21hdGNoXCIsIGxpYi5Mb2dnZXIuZXJyb3JzLklOVkFMSURfQVJHVU1FTlQsIHtcblx0ICAgICAgICAgICAgICAgIGNvdW50OiB7IHR5cGVzOiB0eXBlcy5sZW5ndGgsIHZhbHVlczogdmFsdWVzLmxlbmd0aCB9LFxuXHQgICAgICAgICAgICAgICAgdmFsdWU6IHsgdHlwZXM6IHR5cGVzLCB2YWx1ZXM6IHZhbHVlcyB9XG5cdCAgICAgICAgICAgIH0pO1xuXHQgICAgICAgIH1cblx0ICAgICAgICB2YXIgY29kZXJzID0gdHlwZXMubWFwKGZ1bmN0aW9uICh0eXBlKSB7IHJldHVybiBfdGhpcy5fZ2V0Q29kZXIoZnJhZ21lbnRzLlBhcmFtVHlwZS5mcm9tKHR5cGUpKTsgfSk7XG5cdCAgICAgICAgdmFyIGNvZGVyID0gKG5ldyB0dXBsZS5UdXBsZUNvZGVyKGNvZGVycywgXCJfXCIpKTtcblx0ICAgICAgICB2YXIgd3JpdGVyID0gdGhpcy5fZ2V0V3JpdGVyKCk7XG5cdCAgICAgICAgY29kZXIuZW5jb2RlKHdyaXRlciwgdmFsdWVzKTtcblx0ICAgICAgICByZXR1cm4gd3JpdGVyLmRhdGE7XG5cdCAgICB9O1xuXHQgICAgQWJpQ29kZXIucHJvdG90eXBlLmRlY29kZSA9IGZ1bmN0aW9uICh0eXBlcywgZGF0YSwgbG9vc2UpIHtcblx0ICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXHQgICAgICAgIHZhciBjb2RlcnMgPSB0eXBlcy5tYXAoZnVuY3Rpb24gKHR5cGUpIHsgcmV0dXJuIF90aGlzLl9nZXRDb2RlcihmcmFnbWVudHMuUGFyYW1UeXBlLmZyb20odHlwZSkpOyB9KTtcblx0ICAgICAgICB2YXIgY29kZXIgPSBuZXcgdHVwbGUuVHVwbGVDb2Rlcihjb2RlcnMsIFwiX1wiKTtcblx0ICAgICAgICByZXR1cm4gY29kZXIuZGVjb2RlKHRoaXMuX2dldFJlYWRlcigoMCwgbGliJDEuYXJyYXlpZnkpKGRhdGEpLCBsb29zZSkpO1xuXHQgICAgfTtcblx0ICAgIHJldHVybiBBYmlDb2Rlcjtcblx0fSgpKTtcblx0ZXhwb3J0cy5BYmlDb2RlciA9IEFiaUNvZGVyO1xuXHRleHBvcnRzLmRlZmF1bHRBYmlDb2RlciA9IG5ldyBBYmlDb2RlcigpO1xuXG5cdH0pO1xuXG5cdHZhciBhYmlDb2RlciQxID0gLypAX19QVVJFX18qL2dldERlZmF1bHRFeHBvcnRGcm9tQ2pzKGFiaUNvZGVyKTtcblxuXHR2YXIgaWRfMSA9IGNyZWF0ZUNvbW1vbmpzTW9kdWxlKGZ1bmN0aW9uIChtb2R1bGUsIGV4cG9ydHMpIHtcblx0XCJ1c2Ugc3RyaWN0XCI7XG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcblx0ZXhwb3J0cy5pZCA9IHZvaWQgMDtcblxuXG5cdGZ1bmN0aW9uIGlkKHRleHQpIHtcblx0ICAgIHJldHVybiAoMCwgbGliJDQua2VjY2FrMjU2KSgoMCwgbGliJDgudG9VdGY4Qnl0ZXMpKHRleHQpKTtcblx0fVxuXHRleHBvcnRzLmlkID0gaWQ7XG5cblx0fSk7XG5cblx0dmFyIGlkID0gLypAX19QVVJFX18qL2dldERlZmF1bHRFeHBvcnRGcm9tQ2pzKGlkXzEpO1xuXG5cdHZhciBfdmVyc2lvbiRnID0gY3JlYXRlQ29tbW9uanNNb2R1bGUoZnVuY3Rpb24gKG1vZHVsZSwgZXhwb3J0cykge1xuXHRcInVzZSBzdHJpY3RcIjtcblx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuXHRleHBvcnRzLnZlcnNpb24gPSB2b2lkIDA7XG5cdGV4cG9ydHMudmVyc2lvbiA9IFwiaGFzaC81LjUuMFwiO1xuXG5cdH0pO1xuXG5cdHZhciBfdmVyc2lvbiRoID0gLypAX19QVVJFX18qL2dldERlZmF1bHRFeHBvcnRGcm9tQ2pzKF92ZXJzaW9uJGcpO1xuXG5cdHZhciBuYW1laGFzaF8xID0gY3JlYXRlQ29tbW9uanNNb2R1bGUoZnVuY3Rpb24gKG1vZHVsZSwgZXhwb3J0cykge1xuXHRcInVzZSBzdHJpY3RcIjtcblx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuXHRleHBvcnRzLm5hbWVoYXNoID0gZXhwb3J0cy5pc1ZhbGlkTmFtZSA9IHZvaWQgMDtcblxuXG5cblxuXG5cdHZhciBsb2dnZXIgPSBuZXcgbGliLkxvZ2dlcihfdmVyc2lvbiRnLnZlcnNpb24pO1xuXHR2YXIgWmVyb3MgPSBuZXcgVWludDhBcnJheSgzMik7XG5cdFplcm9zLmZpbGwoMCk7XG5cdHZhciBQYXJ0aXRpb24gPSBuZXcgUmVnRXhwKFwiXigoLiopXFxcXC4pPyhbXi5dKykkXCIpO1xuXHRmdW5jdGlvbiBpc1ZhbGlkTmFtZShuYW1lKSB7XG5cdCAgICB0cnkge1xuXHQgICAgICAgIHZhciBjb21wcyA9IG5hbWUuc3BsaXQoXCIuXCIpO1xuXHQgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY29tcHMubGVuZ3RoOyBpKyspIHtcblx0ICAgICAgICAgICAgaWYgKCgwLCBsaWIkOC5uYW1lcHJlcCkoY29tcHNbaV0pLmxlbmd0aCA9PT0gMCkge1xuXHQgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiZW1wdHlcIik7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9XG5cdCAgICAgICAgcmV0dXJuIHRydWU7XG5cdCAgICB9XG5cdCAgICBjYXRjaCAoZXJyb3IpIHsgfVxuXHQgICAgcmV0dXJuIGZhbHNlO1xuXHR9XG5cdGV4cG9ydHMuaXNWYWxpZE5hbWUgPSBpc1ZhbGlkTmFtZTtcblx0ZnVuY3Rpb24gbmFtZWhhc2gobmFtZSkge1xuXHQgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG5cdCAgICBpZiAodHlwZW9mIChuYW1lKSAhPT0gXCJzdHJpbmdcIikge1xuXHQgICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJpbnZhbGlkIEVOUyBuYW1lOyBub3QgYSBzdHJpbmdcIiwgXCJuYW1lXCIsIG5hbWUpO1xuXHQgICAgfVxuXHQgICAgdmFyIGN1cnJlbnQgPSBuYW1lO1xuXHQgICAgdmFyIHJlc3VsdCA9IFplcm9zO1xuXHQgICAgd2hpbGUgKGN1cnJlbnQubGVuZ3RoKSB7XG5cdCAgICAgICAgdmFyIHBhcnRpdGlvbiA9IGN1cnJlbnQubWF0Y2goUGFydGl0aW9uKTtcblx0ICAgICAgICBpZiAocGFydGl0aW9uID09IG51bGwgfHwgcGFydGl0aW9uWzJdID09PSBcIlwiKSB7XG5cdCAgICAgICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJpbnZhbGlkIEVOUyBhZGRyZXNzOyBtaXNzaW5nIGNvbXBvbmVudFwiLCBcIm5hbWVcIiwgbmFtZSk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHZhciBsYWJlbCA9ICgwLCBsaWIkOC50b1V0ZjhCeXRlcykoKDAsIGxpYiQ4Lm5hbWVwcmVwKShwYXJ0aXRpb25bM10pKTtcblx0ICAgICAgICByZXN1bHQgPSAoMCwgbGliJDQua2VjY2FrMjU2KSgoMCwgbGliJDEuY29uY2F0KShbcmVzdWx0LCAoMCwgbGliJDQua2VjY2FrMjU2KShsYWJlbCldKSk7XG5cdCAgICAgICAgY3VycmVudCA9IHBhcnRpdGlvblsyXSB8fCBcIlwiO1xuXHQgICAgfVxuXHQgICAgcmV0dXJuICgwLCBsaWIkMS5oZXhsaWZ5KShyZXN1bHQpO1xuXHR9XG5cdGV4cG9ydHMubmFtZWhhc2ggPSBuYW1laGFzaDtcblxuXHR9KTtcblxuXHR2YXIgbmFtZWhhc2ggPSAvKkBfX1BVUkVfXyovZ2V0RGVmYXVsdEV4cG9ydEZyb21DanMobmFtZWhhc2hfMSk7XG5cblx0dmFyIG1lc3NhZ2UgPSBjcmVhdGVDb21tb25qc01vZHVsZShmdW5jdGlvbiAobW9kdWxlLCBleHBvcnRzKSB7XG5cdFwidXNlIHN0cmljdFwiO1xuXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5cdGV4cG9ydHMuaGFzaE1lc3NhZ2UgPSBleHBvcnRzLm1lc3NhZ2VQcmVmaXggPSB2b2lkIDA7XG5cblxuXG5cdGV4cG9ydHMubWVzc2FnZVByZWZpeCA9IFwiXFx4MTlFdGhlcmV1bSBTaWduZWQgTWVzc2FnZTpcXG5cIjtcblx0ZnVuY3Rpb24gaGFzaE1lc3NhZ2UobWVzc2FnZSkge1xuXHQgICAgaWYgKHR5cGVvZiAobWVzc2FnZSkgPT09IFwic3RyaW5nXCIpIHtcblx0ICAgICAgICBtZXNzYWdlID0gKDAsIGxpYiQ4LnRvVXRmOEJ5dGVzKShtZXNzYWdlKTtcblx0ICAgIH1cblx0ICAgIHJldHVybiAoMCwgbGliJDQua2VjY2FrMjU2KSgoMCwgbGliJDEuY29uY2F0KShbXG5cdCAgICAgICAgKDAsIGxpYiQ4LnRvVXRmOEJ5dGVzKShleHBvcnRzLm1lc3NhZ2VQcmVmaXgpLFxuXHQgICAgICAgICgwLCBsaWIkOC50b1V0ZjhCeXRlcykoU3RyaW5nKG1lc3NhZ2UubGVuZ3RoKSksXG5cdCAgICAgICAgbWVzc2FnZVxuXHQgICAgXSkpO1xuXHR9XG5cdGV4cG9ydHMuaGFzaE1lc3NhZ2UgPSBoYXNoTWVzc2FnZTtcblxuXHR9KTtcblxuXHR2YXIgbWVzc2FnZSQxID0gLypAX19QVVJFX18qL2dldERlZmF1bHRFeHBvcnRGcm9tQ2pzKG1lc3NhZ2UpO1xuXG5cdHZhciB0eXBlZERhdGEgPSBjcmVhdGVDb21tb25qc01vZHVsZShmdW5jdGlvbiAobW9kdWxlLCBleHBvcnRzKSB7XG5cdFwidXNlIHN0cmljdFwiO1xuXHR2YXIgX19hd2FpdGVyID0gKGNvbW1vbmpzR2xvYmFsICYmIGNvbW1vbmpzR2xvYmFsLl9fYXdhaXRlcikgfHwgZnVuY3Rpb24gKHRoaXNBcmcsIF9hcmd1bWVudHMsIFAsIGdlbmVyYXRvcikge1xuXHQgICAgZnVuY3Rpb24gYWRvcHQodmFsdWUpIHsgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgUCA/IHZhbHVlIDogbmV3IFAoZnVuY3Rpb24gKHJlc29sdmUpIHsgcmVzb2x2ZSh2YWx1ZSk7IH0pOyB9XG5cdCAgICByZXR1cm4gbmV3IChQIHx8IChQID0gUHJvbWlzZSkpKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcblx0ICAgICAgICBmdW5jdGlvbiBmdWxmaWxsZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3IubmV4dCh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG5cdCAgICAgICAgZnVuY3Rpb24gcmVqZWN0ZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3JbXCJ0aHJvd1wiXSh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG5cdCAgICAgICAgZnVuY3Rpb24gc3RlcChyZXN1bHQpIHsgcmVzdWx0LmRvbmUgPyByZXNvbHZlKHJlc3VsdC52YWx1ZSkgOiBhZG9wdChyZXN1bHQudmFsdWUpLnRoZW4oZnVsZmlsbGVkLCByZWplY3RlZCk7IH1cblx0ICAgICAgICBzdGVwKChnZW5lcmF0b3IgPSBnZW5lcmF0b3IuYXBwbHkodGhpc0FyZywgX2FyZ3VtZW50cyB8fCBbXSkpLm5leHQoKSk7XG5cdCAgICB9KTtcblx0fTtcblx0dmFyIF9fZ2VuZXJhdG9yID0gKGNvbW1vbmpzR2xvYmFsICYmIGNvbW1vbmpzR2xvYmFsLl9fZ2VuZXJhdG9yKSB8fCBmdW5jdGlvbiAodGhpc0FyZywgYm9keSkge1xuXHQgICAgdmFyIF8gPSB7IGxhYmVsOiAwLCBzZW50OiBmdW5jdGlvbigpIHsgaWYgKHRbMF0gJiAxKSB0aHJvdyB0WzFdOyByZXR1cm4gdFsxXTsgfSwgdHJ5czogW10sIG9wczogW10gfSwgZiwgeSwgdCwgZztcblx0ICAgIHJldHVybiBnID0geyBuZXh0OiB2ZXJiKDApLCBcInRocm93XCI6IHZlcmIoMSksIFwicmV0dXJuXCI6IHZlcmIoMikgfSwgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIChnW1N5bWJvbC5pdGVyYXRvcl0gPSBmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXM7IH0pLCBnO1xuXHQgICAgZnVuY3Rpb24gdmVyYihuKSB7IHJldHVybiBmdW5jdGlvbiAodikgeyByZXR1cm4gc3RlcChbbiwgdl0pOyB9OyB9XG5cdCAgICBmdW5jdGlvbiBzdGVwKG9wKSB7XG5cdCAgICAgICAgaWYgKGYpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJHZW5lcmF0b3IgaXMgYWxyZWFkeSBleGVjdXRpbmcuXCIpO1xuXHQgICAgICAgIHdoaWxlIChfKSB0cnkge1xuXHQgICAgICAgICAgICBpZiAoZiA9IDEsIHkgJiYgKHQgPSBvcFswXSAmIDIgPyB5W1wicmV0dXJuXCJdIDogb3BbMF0gPyB5W1widGhyb3dcIl0gfHwgKCh0ID0geVtcInJldHVyblwiXSkgJiYgdC5jYWxsKHkpLCAwKSA6IHkubmV4dCkgJiYgISh0ID0gdC5jYWxsKHksIG9wWzFdKSkuZG9uZSkgcmV0dXJuIHQ7XG5cdCAgICAgICAgICAgIGlmICh5ID0gMCwgdCkgb3AgPSBbb3BbMF0gJiAyLCB0LnZhbHVlXTtcblx0ICAgICAgICAgICAgc3dpdGNoIChvcFswXSkge1xuXHQgICAgICAgICAgICAgICAgY2FzZSAwOiBjYXNlIDE6IHQgPSBvcDsgYnJlYWs7XG5cdCAgICAgICAgICAgICAgICBjYXNlIDQ6IF8ubGFiZWwrKzsgcmV0dXJuIHsgdmFsdWU6IG9wWzFdLCBkb25lOiBmYWxzZSB9O1xuXHQgICAgICAgICAgICAgICAgY2FzZSA1OiBfLmxhYmVsKys7IHkgPSBvcFsxXTsgb3AgPSBbMF07IGNvbnRpbnVlO1xuXHQgICAgICAgICAgICAgICAgY2FzZSA3OiBvcCA9IF8ub3BzLnBvcCgpOyBfLnRyeXMucG9wKCk7IGNvbnRpbnVlO1xuXHQgICAgICAgICAgICAgICAgZGVmYXVsdDpcblx0ICAgICAgICAgICAgICAgICAgICBpZiAoISh0ID0gXy50cnlzLCB0ID0gdC5sZW5ndGggPiAwICYmIHRbdC5sZW5ndGggLSAxXSkgJiYgKG9wWzBdID09PSA2IHx8IG9wWzBdID09PSAyKSkgeyBfID0gMDsgY29udGludWU7IH1cblx0ICAgICAgICAgICAgICAgICAgICBpZiAob3BbMF0gPT09IDMgJiYgKCF0IHx8IChvcFsxXSA+IHRbMF0gJiYgb3BbMV0gPCB0WzNdKSkpIHsgXy5sYWJlbCA9IG9wWzFdOyBicmVhazsgfVxuXHQgICAgICAgICAgICAgICAgICAgIGlmIChvcFswXSA9PT0gNiAmJiBfLmxhYmVsIDwgdFsxXSkgeyBfLmxhYmVsID0gdFsxXTsgdCA9IG9wOyBicmVhazsgfVxuXHQgICAgICAgICAgICAgICAgICAgIGlmICh0ICYmIF8ubGFiZWwgPCB0WzJdKSB7IF8ubGFiZWwgPSB0WzJdOyBfLm9wcy5wdXNoKG9wKTsgYnJlYWs7IH1cblx0ICAgICAgICAgICAgICAgICAgICBpZiAodFsyXSkgXy5vcHMucG9wKCk7XG5cdCAgICAgICAgICAgICAgICAgICAgXy50cnlzLnBvcCgpOyBjb250aW51ZTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICBvcCA9IGJvZHkuY2FsbCh0aGlzQXJnLCBfKTtcblx0ICAgICAgICB9IGNhdGNoIChlKSB7IG9wID0gWzYsIGVdOyB5ID0gMDsgfSBmaW5hbGx5IHsgZiA9IHQgPSAwOyB9XG5cdCAgICAgICAgaWYgKG9wWzBdICYgNSkgdGhyb3cgb3BbMV07IHJldHVybiB7IHZhbHVlOiBvcFswXSA/IG9wWzFdIDogdm9pZCAwLCBkb25lOiB0cnVlIH07XG5cdCAgICB9XG5cdH07XG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcblx0ZXhwb3J0cy5UeXBlZERhdGFFbmNvZGVyID0gdm9pZCAwO1xuXG5cblxuXG5cblxuXG5cdHZhciBsb2dnZXIgPSBuZXcgbGliLkxvZ2dlcihfdmVyc2lvbiRnLnZlcnNpb24pO1xuXG5cdHZhciBwYWRkaW5nID0gbmV3IFVpbnQ4QXJyYXkoMzIpO1xuXHRwYWRkaW5nLmZpbGwoMCk7XG5cdHZhciBOZWdhdGl2ZU9uZSA9IGxpYiQyLkJpZ051bWJlci5mcm9tKC0xKTtcblx0dmFyIFplcm8gPSBsaWIkMi5CaWdOdW1iZXIuZnJvbSgwKTtcblx0dmFyIE9uZSA9IGxpYiQyLkJpZ051bWJlci5mcm9tKDEpO1xuXHR2YXIgTWF4VWludDI1NiA9IGxpYiQyLkJpZ051bWJlci5mcm9tKFwiMHhmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmXCIpO1xuXHRmdW5jdGlvbiBoZXhQYWRSaWdodCh2YWx1ZSkge1xuXHQgICAgdmFyIGJ5dGVzID0gKDAsIGxpYiQxLmFycmF5aWZ5KSh2YWx1ZSk7XG5cdCAgICB2YXIgcGFkT2Zmc2V0ID0gYnl0ZXMubGVuZ3RoICUgMzI7XG5cdCAgICBpZiAocGFkT2Zmc2V0KSB7XG5cdCAgICAgICAgcmV0dXJuICgwLCBsaWIkMS5oZXhDb25jYXQpKFtieXRlcywgcGFkZGluZy5zbGljZShwYWRPZmZzZXQpXSk7XG5cdCAgICB9XG5cdCAgICByZXR1cm4gKDAsIGxpYiQxLmhleGxpZnkpKGJ5dGVzKTtcblx0fVxuXHR2YXIgaGV4VHJ1ZSA9ICgwLCBsaWIkMS5oZXhaZXJvUGFkKShPbmUudG9IZXhTdHJpbmcoKSwgMzIpO1xuXHR2YXIgaGV4RmFsc2UgPSAoMCwgbGliJDEuaGV4WmVyb1BhZCkoWmVyby50b0hleFN0cmluZygpLCAzMik7XG5cdHZhciBkb21haW5GaWVsZFR5cGVzID0ge1xuXHQgICAgbmFtZTogXCJzdHJpbmdcIixcblx0ICAgIHZlcnNpb246IFwic3RyaW5nXCIsXG5cdCAgICBjaGFpbklkOiBcInVpbnQyNTZcIixcblx0ICAgIHZlcmlmeWluZ0NvbnRyYWN0OiBcImFkZHJlc3NcIixcblx0ICAgIHNhbHQ6IFwiYnl0ZXMzMlwiXG5cdH07XG5cdHZhciBkb21haW5GaWVsZE5hbWVzID0gW1xuXHQgICAgXCJuYW1lXCIsIFwidmVyc2lvblwiLCBcImNoYWluSWRcIiwgXCJ2ZXJpZnlpbmdDb250cmFjdFwiLCBcInNhbHRcIlxuXHRdO1xuXHRmdW5jdGlvbiBjaGVja1N0cmluZyhrZXkpIHtcblx0ICAgIHJldHVybiBmdW5jdGlvbiAodmFsdWUpIHtcblx0ICAgICAgICBpZiAodHlwZW9mICh2YWx1ZSkgIT09IFwic3RyaW5nXCIpIHtcblx0ICAgICAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcImludmFsaWQgZG9tYWluIHZhbHVlIGZvciBcIiArIEpTT04uc3RyaW5naWZ5KGtleSksIFwiZG9tYWluLlwiICsga2V5LCB2YWx1ZSk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHJldHVybiB2YWx1ZTtcblx0ICAgIH07XG5cdH1cblx0dmFyIGRvbWFpbkNoZWNrcyA9IHtcblx0ICAgIG5hbWU6IGNoZWNrU3RyaW5nKFwibmFtZVwiKSxcblx0ICAgIHZlcnNpb246IGNoZWNrU3RyaW5nKFwidmVyc2lvblwiKSxcblx0ICAgIGNoYWluSWQ6IGZ1bmN0aW9uICh2YWx1ZSkge1xuXHQgICAgICAgIHRyeSB7XG5cdCAgICAgICAgICAgIHJldHVybiBsaWIkMi5CaWdOdW1iZXIuZnJvbSh2YWx1ZSkudG9TdHJpbmcoKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgY2F0Y2ggKGVycm9yKSB7IH1cblx0ICAgICAgICByZXR1cm4gbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcImludmFsaWQgZG9tYWluIHZhbHVlIGZvciBcXFwiY2hhaW5JZFxcXCJcIiwgXCJkb21haW4uY2hhaW5JZFwiLCB2YWx1ZSk7XG5cdCAgICB9LFxuXHQgICAgdmVyaWZ5aW5nQ29udHJhY3Q6IGZ1bmN0aW9uICh2YWx1ZSkge1xuXHQgICAgICAgIHRyeSB7XG5cdCAgICAgICAgICAgIHJldHVybiAoMCwgbGliJDYuZ2V0QWRkcmVzcykodmFsdWUpLnRvTG93ZXJDYXNlKCk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGNhdGNoIChlcnJvcikgeyB9XG5cdCAgICAgICAgcmV0dXJuIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJpbnZhbGlkIGRvbWFpbiB2YWx1ZSBcXFwidmVyaWZ5aW5nQ29udHJhY3RcXFwiXCIsIFwiZG9tYWluLnZlcmlmeWluZ0NvbnRyYWN0XCIsIHZhbHVlKTtcblx0ICAgIH0sXG5cdCAgICBzYWx0OiBmdW5jdGlvbiAodmFsdWUpIHtcblx0ICAgICAgICB0cnkge1xuXHQgICAgICAgICAgICB2YXIgYnl0ZXMgPSAoMCwgbGliJDEuYXJyYXlpZnkpKHZhbHVlKTtcblx0ICAgICAgICAgICAgaWYgKGJ5dGVzLmxlbmd0aCAhPT0gMzIpIHtcblx0ICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImJhZCBsZW5ndGhcIik7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgcmV0dXJuICgwLCBsaWIkMS5oZXhsaWZ5KShieXRlcyk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGNhdGNoIChlcnJvcikgeyB9XG5cdCAgICAgICAgcmV0dXJuIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJpbnZhbGlkIGRvbWFpbiB2YWx1ZSBcXFwic2FsdFxcXCJcIiwgXCJkb21haW4uc2FsdFwiLCB2YWx1ZSk7XG5cdCAgICB9XG5cdH07XG5cdGZ1bmN0aW9uIGdldEJhc2VFbmNvZGVyKHR5cGUpIHtcblx0ICAgIC8vIGludFhYIGFuZCB1aW50WFhcblx0ICAgIHtcblx0ICAgICAgICB2YXIgbWF0Y2ggPSB0eXBlLm1hdGNoKC9eKHU/KWludChcXGQqKSQvKTtcblx0ICAgICAgICBpZiAobWF0Y2gpIHtcblx0ICAgICAgICAgICAgdmFyIHNpZ25lZCA9IChtYXRjaFsxXSA9PT0gXCJcIik7XG5cdCAgICAgICAgICAgIHZhciB3aWR0aCA9IHBhcnNlSW50KG1hdGNoWzJdIHx8IFwiMjU2XCIpO1xuXHQgICAgICAgICAgICBpZiAod2lkdGggJSA4ICE9PSAwIHx8IHdpZHRoID4gMjU2IHx8IChtYXRjaFsyXSAmJiBtYXRjaFsyXSAhPT0gU3RyaW5nKHdpZHRoKSkpIHtcblx0ICAgICAgICAgICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJpbnZhbGlkIG51bWVyaWMgd2lkdGhcIiwgXCJ0eXBlXCIsIHR5cGUpO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIHZhciBib3VuZHNVcHBlcl8xID0gTWF4VWludDI1Ni5tYXNrKHNpZ25lZCA/ICh3aWR0aCAtIDEpIDogd2lkdGgpO1xuXHQgICAgICAgICAgICB2YXIgYm91bmRzTG93ZXJfMSA9IHNpZ25lZCA/IGJvdW5kc1VwcGVyXzEuYWRkKE9uZSkubXVsKE5lZ2F0aXZlT25lKSA6IFplcm87XG5cdCAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAodmFsdWUpIHtcblx0ICAgICAgICAgICAgICAgIHZhciB2ID0gbGliJDIuQmlnTnVtYmVyLmZyb20odmFsdWUpO1xuXHQgICAgICAgICAgICAgICAgaWYgKHYubHQoYm91bmRzTG93ZXJfMSkgfHwgdi5ndChib3VuZHNVcHBlcl8xKSkge1xuXHQgICAgICAgICAgICAgICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJ2YWx1ZSBvdXQtb2YtYm91bmRzIGZvciBcIiArIHR5cGUsIFwidmFsdWVcIiwgdmFsdWUpO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgcmV0dXJuICgwLCBsaWIkMS5oZXhaZXJvUGFkKSh2LnRvVHdvcygyNTYpLnRvSGV4U3RyaW5nKCksIDMyKTtcblx0ICAgICAgICAgICAgfTtcblx0ICAgICAgICB9XG5cdCAgICB9XG5cdCAgICAvLyBieXRlc1hYXG5cdCAgICB7XG5cdCAgICAgICAgdmFyIG1hdGNoID0gdHlwZS5tYXRjaCgvXmJ5dGVzKFxcZCspJC8pO1xuXHQgICAgICAgIGlmIChtYXRjaCkge1xuXHQgICAgICAgICAgICB2YXIgd2lkdGhfMSA9IHBhcnNlSW50KG1hdGNoWzFdKTtcblx0ICAgICAgICAgICAgaWYgKHdpZHRoXzEgPT09IDAgfHwgd2lkdGhfMSA+IDMyIHx8IG1hdGNoWzFdICE9PSBTdHJpbmcod2lkdGhfMSkpIHtcblx0ICAgICAgICAgICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJpbnZhbGlkIGJ5dGVzIHdpZHRoXCIsIFwidHlwZVwiLCB0eXBlKTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKHZhbHVlKSB7XG5cdCAgICAgICAgICAgICAgICB2YXIgYnl0ZXMgPSAoMCwgbGliJDEuYXJyYXlpZnkpKHZhbHVlKTtcblx0ICAgICAgICAgICAgICAgIGlmIChieXRlcy5sZW5ndGggIT09IHdpZHRoXzEpIHtcblx0ICAgICAgICAgICAgICAgICAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwiaW52YWxpZCBsZW5ndGggZm9yIFwiICsgdHlwZSwgXCJ2YWx1ZVwiLCB2YWx1ZSk7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gaGV4UGFkUmlnaHQodmFsdWUpO1xuXHQgICAgICAgICAgICB9O1xuXHQgICAgICAgIH1cblx0ICAgIH1cblx0ICAgIHN3aXRjaCAodHlwZSkge1xuXHQgICAgICAgIGNhc2UgXCJhZGRyZXNzXCI6IHJldHVybiBmdW5jdGlvbiAodmFsdWUpIHtcblx0ICAgICAgICAgICAgcmV0dXJuICgwLCBsaWIkMS5oZXhaZXJvUGFkKSgoMCwgbGliJDYuZ2V0QWRkcmVzcykodmFsdWUpLCAzMik7XG5cdCAgICAgICAgfTtcblx0ICAgICAgICBjYXNlIFwiYm9vbFwiOiByZXR1cm4gZnVuY3Rpb24gKHZhbHVlKSB7XG5cdCAgICAgICAgICAgIHJldHVybiAoKCF2YWx1ZSkgPyBoZXhGYWxzZSA6IGhleFRydWUpO1xuXHQgICAgICAgIH07XG5cdCAgICAgICAgY2FzZSBcImJ5dGVzXCI6IHJldHVybiBmdW5jdGlvbiAodmFsdWUpIHtcblx0ICAgICAgICAgICAgcmV0dXJuICgwLCBsaWIkNC5rZWNjYWsyNTYpKHZhbHVlKTtcblx0ICAgICAgICB9O1xuXHQgICAgICAgIGNhc2UgXCJzdHJpbmdcIjogcmV0dXJuIGZ1bmN0aW9uICh2YWx1ZSkge1xuXHQgICAgICAgICAgICByZXR1cm4gKDAsIGlkXzEuaWQpKHZhbHVlKTtcblx0ICAgICAgICB9O1xuXHQgICAgfVxuXHQgICAgcmV0dXJuIG51bGw7XG5cdH1cblx0ZnVuY3Rpb24gZW5jb2RlVHlwZShuYW1lLCBmaWVsZHMpIHtcblx0ICAgIHJldHVybiBuYW1lICsgXCIoXCIgKyBmaWVsZHMubWFwKGZ1bmN0aW9uIChfYSkge1xuXHQgICAgICAgIHZhciBuYW1lID0gX2EubmFtZSwgdHlwZSA9IF9hLnR5cGU7XG5cdCAgICAgICAgcmV0dXJuICh0eXBlICsgXCIgXCIgKyBuYW1lKTtcblx0ICAgIH0pLmpvaW4oXCIsXCIpICsgXCIpXCI7XG5cdH1cblx0dmFyIFR5cGVkRGF0YUVuY29kZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG5cdCAgICBmdW5jdGlvbiBUeXBlZERhdGFFbmNvZGVyKHR5cGVzKSB7XG5cdCAgICAgICAgKDAsIGxpYiQzLmRlZmluZVJlYWRPbmx5KSh0aGlzLCBcInR5cGVzXCIsIE9iamVjdC5mcmVlemUoKDAsIGxpYiQzLmRlZXBDb3B5KSh0eXBlcykpKTtcblx0ICAgICAgICAoMCwgbGliJDMuZGVmaW5lUmVhZE9ubHkpKHRoaXMsIFwiX2VuY29kZXJDYWNoZVwiLCB7fSk7XG5cdCAgICAgICAgKDAsIGxpYiQzLmRlZmluZVJlYWRPbmx5KSh0aGlzLCBcIl90eXBlc1wiLCB7fSk7XG5cdCAgICAgICAgLy8gTGluayBzdHJ1Y3QgdHlwZXMgdG8gdGhlaXIgZGlyZWN0IGNoaWxkIHN0cnVjdHNcblx0ICAgICAgICB2YXIgbGlua3MgPSB7fTtcblx0ICAgICAgICAvLyBMaW5rIHN0cnVjdHMgdG8gc3RydWN0cyB3aGljaCBjb250YWluIHRoZW0gYXMgYSBjaGlsZFxuXHQgICAgICAgIHZhciBwYXJlbnRzID0ge307XG5cdCAgICAgICAgLy8gTGluayBhbGwgc3VidHlwZXMgd2l0aGluIGEgZ2l2ZW4gc3RydWN0XG5cdCAgICAgICAgdmFyIHN1YnR5cGVzID0ge307XG5cdCAgICAgICAgT2JqZWN0LmtleXModHlwZXMpLmZvckVhY2goZnVuY3Rpb24gKHR5cGUpIHtcblx0ICAgICAgICAgICAgbGlua3NbdHlwZV0gPSB7fTtcblx0ICAgICAgICAgICAgcGFyZW50c1t0eXBlXSA9IFtdO1xuXHQgICAgICAgICAgICBzdWJ0eXBlc1t0eXBlXSA9IHt9O1xuXHQgICAgICAgIH0pO1xuXHQgICAgICAgIHZhciBfbG9vcF8xID0gZnVuY3Rpb24gKG5hbWVfMSkge1xuXHQgICAgICAgICAgICB2YXIgdW5pcXVlTmFtZXMgPSB7fTtcblx0ICAgICAgICAgICAgdHlwZXNbbmFtZV8xXS5mb3JFYWNoKGZ1bmN0aW9uIChmaWVsZCkge1xuXHQgICAgICAgICAgICAgICAgLy8gQ2hlY2sgZWFjaCBmaWVsZCBoYXMgYSB1bmlxdWUgbmFtZVxuXHQgICAgICAgICAgICAgICAgaWYgKHVuaXF1ZU5hbWVzW2ZpZWxkLm5hbWVdKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcImR1cGxpY2F0ZSB2YXJpYWJsZSBuYW1lIFwiICsgSlNPTi5zdHJpbmdpZnkoZmllbGQubmFtZSkgKyBcIiBpbiBcIiArIEpTT04uc3RyaW5naWZ5KG5hbWVfMSksIFwidHlwZXNcIiwgdHlwZXMpO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgdW5pcXVlTmFtZXNbZmllbGQubmFtZV0gPSB0cnVlO1xuXHQgICAgICAgICAgICAgICAgLy8gR2V0IHRoZSBiYXNlIHR5cGUgKGRyb3AgYW55IGFycmF5IHNwZWNpZmllcnMpXG5cdCAgICAgICAgICAgICAgICB2YXIgYmFzZVR5cGUgPSBmaWVsZC50eXBlLm1hdGNoKC9eKFteXFx4NWJdKikoXFx4NWJ8JCkvKVsxXTtcblx0ICAgICAgICAgICAgICAgIGlmIChiYXNlVHlwZSA9PT0gbmFtZV8xKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcImNpcmN1bGFyIHR5cGUgcmVmZXJlbmNlIHRvIFwiICsgSlNPTi5zdHJpbmdpZnkoYmFzZVR5cGUpLCBcInR5cGVzXCIsIHR5cGVzKTtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgIC8vIElzIHRoaXMgYSBiYXNlIGVuY29kaW5nIHR5cGU/XG5cdCAgICAgICAgICAgICAgICB2YXIgZW5jb2RlciA9IGdldEJhc2VFbmNvZGVyKGJhc2VUeXBlKTtcblx0ICAgICAgICAgICAgICAgIGlmIChlbmNvZGVyKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgaWYgKCFwYXJlbnRzW2Jhc2VUeXBlXSkge1xuXHQgICAgICAgICAgICAgICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJ1bmtub3duIHR5cGUgXCIgKyBKU09OLnN0cmluZ2lmeShiYXNlVHlwZSksIFwidHlwZXNcIiwgdHlwZXMpO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgLy8gQWRkIGxpbmthZ2Vcblx0ICAgICAgICAgICAgICAgIHBhcmVudHNbYmFzZVR5cGVdLnB1c2gobmFtZV8xKTtcblx0ICAgICAgICAgICAgICAgIGxpbmtzW25hbWVfMV1bYmFzZVR5cGVdID0gdHJ1ZTtcblx0ICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgfTtcblx0ICAgICAgICBmb3IgKHZhciBuYW1lXzEgaW4gdHlwZXMpIHtcblx0ICAgICAgICAgICAgX2xvb3BfMShuYW1lXzEpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICAvLyBEZWR1Y2UgdGhlIHByaW1hcnkgdHlwZVxuXHQgICAgICAgIHZhciBwcmltYXJ5VHlwZXMgPSBPYmplY3Qua2V5cyhwYXJlbnRzKS5maWx0ZXIoZnVuY3Rpb24gKG4pIHsgcmV0dXJuIChwYXJlbnRzW25dLmxlbmd0aCA9PT0gMCk7IH0pO1xuXHQgICAgICAgIGlmIChwcmltYXJ5VHlwZXMubGVuZ3RoID09PSAwKSB7XG5cdCAgICAgICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJtaXNzaW5nIHByaW1hcnkgdHlwZVwiLCBcInR5cGVzXCIsIHR5cGVzKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgZWxzZSBpZiAocHJpbWFyeVR5cGVzLmxlbmd0aCA+IDEpIHtcblx0ICAgICAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcImFtYmlndW91cyBwcmltYXJ5IHR5cGVzIG9yIHVudXNlZCB0eXBlczogXCIgKyBwcmltYXJ5VHlwZXMubWFwKGZ1bmN0aW9uICh0KSB7IHJldHVybiAoSlNPTi5zdHJpbmdpZnkodCkpOyB9KS5qb2luKFwiLCBcIiksIFwidHlwZXNcIiwgdHlwZXMpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICAoMCwgbGliJDMuZGVmaW5lUmVhZE9ubHkpKHRoaXMsIFwicHJpbWFyeVR5cGVcIiwgcHJpbWFyeVR5cGVzWzBdKTtcblx0ICAgICAgICAvLyBDaGVjayBmb3IgY2lyY3VsYXIgdHlwZSByZWZlcmVuY2VzXG5cdCAgICAgICAgZnVuY3Rpb24gY2hlY2tDaXJjdWxhcih0eXBlLCBmb3VuZCkge1xuXHQgICAgICAgICAgICBpZiAoZm91bmRbdHlwZV0pIHtcblx0ICAgICAgICAgICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJjaXJjdWxhciB0eXBlIHJlZmVyZW5jZSB0byBcIiArIEpTT04uc3RyaW5naWZ5KHR5cGUpLCBcInR5cGVzXCIsIHR5cGVzKTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICBmb3VuZFt0eXBlXSA9IHRydWU7XG5cdCAgICAgICAgICAgIE9iamVjdC5rZXlzKGxpbmtzW3R5cGVdKS5mb3JFYWNoKGZ1bmN0aW9uIChjaGlsZCkge1xuXHQgICAgICAgICAgICAgICAgaWYgKCFwYXJlbnRzW2NoaWxkXSkge1xuXHQgICAgICAgICAgICAgICAgICAgIHJldHVybjtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgIC8vIFJlY3Vyc2l2ZWx5IGNoZWNrIGNoaWxkcmVuXG5cdCAgICAgICAgICAgICAgICBjaGVja0NpcmN1bGFyKGNoaWxkLCBmb3VuZCk7XG5cdCAgICAgICAgICAgICAgICAvLyBNYXJrIGFsbCBhbmNlc3RvcnMgYXMgaGF2aW5nIHRoaXMgZGVjZW5kYW50XG5cdCAgICAgICAgICAgICAgICBPYmplY3Qua2V5cyhmb3VuZCkuZm9yRWFjaChmdW5jdGlvbiAoc3VidHlwZSkge1xuXHQgICAgICAgICAgICAgICAgICAgIHN1YnR5cGVzW3N1YnR5cGVdW2NoaWxkXSA9IHRydWU7XG5cdCAgICAgICAgICAgICAgICB9KTtcblx0ICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgICAgIGRlbGV0ZSBmb3VuZFt0eXBlXTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgY2hlY2tDaXJjdWxhcih0aGlzLnByaW1hcnlUeXBlLCB7fSk7XG5cdCAgICAgICAgLy8gQ29tcHV0ZSBlYWNoIGZ1bGx5IGRlc2NyaWJlIHR5cGVcblx0ICAgICAgICBmb3IgKHZhciBuYW1lXzIgaW4gc3VidHlwZXMpIHtcblx0ICAgICAgICAgICAgdmFyIHN0ID0gT2JqZWN0LmtleXMoc3VidHlwZXNbbmFtZV8yXSk7XG5cdCAgICAgICAgICAgIHN0LnNvcnQoKTtcblx0ICAgICAgICAgICAgdGhpcy5fdHlwZXNbbmFtZV8yXSA9IGVuY29kZVR5cGUobmFtZV8yLCB0eXBlc1tuYW1lXzJdKSArIHN0Lm1hcChmdW5jdGlvbiAodCkgeyByZXR1cm4gZW5jb2RlVHlwZSh0LCB0eXBlc1t0XSk7IH0pLmpvaW4oXCJcIik7XG5cdCAgICAgICAgfVxuXHQgICAgfVxuXHQgICAgVHlwZWREYXRhRW5jb2Rlci5wcm90b3R5cGUuZ2V0RW5jb2RlciA9IGZ1bmN0aW9uICh0eXBlKSB7XG5cdCAgICAgICAgdmFyIGVuY29kZXIgPSB0aGlzLl9lbmNvZGVyQ2FjaGVbdHlwZV07XG5cdCAgICAgICAgaWYgKCFlbmNvZGVyKSB7XG5cdCAgICAgICAgICAgIGVuY29kZXIgPSB0aGlzLl9lbmNvZGVyQ2FjaGVbdHlwZV0gPSB0aGlzLl9nZXRFbmNvZGVyKHR5cGUpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICByZXR1cm4gZW5jb2Rlcjtcblx0ICAgIH07XG5cdCAgICBUeXBlZERhdGFFbmNvZGVyLnByb3RvdHlwZS5fZ2V0RW5jb2RlciA9IGZ1bmN0aW9uICh0eXBlKSB7XG5cdCAgICAgICAgdmFyIF90aGlzID0gdGhpcztcblx0ICAgICAgICAvLyBCYXNpYyBlbmNvZGVyIHR5cGUgKGFkZHJlc3MsIGJvb2wsIHVpbnQyNTYsIGV0Yylcblx0ICAgICAgICB7XG5cdCAgICAgICAgICAgIHZhciBlbmNvZGVyID0gZ2V0QmFzZUVuY29kZXIodHlwZSk7XG5cdCAgICAgICAgICAgIGlmIChlbmNvZGVyKSB7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gZW5jb2Rlcjtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH1cblx0ICAgICAgICAvLyBBcnJheVxuXHQgICAgICAgIHZhciBtYXRjaCA9IHR5cGUubWF0Y2goL14oLiopKFxceDViKFxcZCopXFx4NWQpJC8pO1xuXHQgICAgICAgIGlmIChtYXRjaCkge1xuXHQgICAgICAgICAgICB2YXIgc3VidHlwZV8xID0gbWF0Y2hbMV07XG5cdCAgICAgICAgICAgIHZhciBzdWJFbmNvZGVyXzEgPSB0aGlzLmdldEVuY29kZXIoc3VidHlwZV8xKTtcblx0ICAgICAgICAgICAgdmFyIGxlbmd0aF8xID0gcGFyc2VJbnQobWF0Y2hbM10pO1xuXHQgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKHZhbHVlKSB7XG5cdCAgICAgICAgICAgICAgICBpZiAobGVuZ3RoXzEgPj0gMCAmJiB2YWx1ZS5sZW5ndGggIT09IGxlbmd0aF8xKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcImFycmF5IGxlbmd0aCBtaXNtYXRjaDsgZXhwZWN0ZWQgbGVuZ3RoICR7IGFycmF5TGVuZ3RoIH1cIiwgXCJ2YWx1ZVwiLCB2YWx1ZSk7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICB2YXIgcmVzdWx0ID0gdmFsdWUubWFwKHN1YkVuY29kZXJfMSk7XG5cdCAgICAgICAgICAgICAgICBpZiAoX3RoaXMuX3R5cGVzW3N1YnR5cGVfMV0pIHtcblx0ICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSByZXN1bHQubWFwKGxpYiQ0LmtlY2NhazI1Nik7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gKDAsIGxpYiQ0LmtlY2NhazI1NikoKDAsIGxpYiQxLmhleENvbmNhdCkocmVzdWx0KSk7XG5cdCAgICAgICAgICAgIH07XG5cdCAgICAgICAgfVxuXHQgICAgICAgIC8vIFN0cnVjdFxuXHQgICAgICAgIHZhciBmaWVsZHMgPSB0aGlzLnR5cGVzW3R5cGVdO1xuXHQgICAgICAgIGlmIChmaWVsZHMpIHtcblx0ICAgICAgICAgICAgdmFyIGVuY29kZWRUeXBlXzEgPSAoMCwgaWRfMS5pZCkodGhpcy5fdHlwZXNbdHlwZV0pO1xuXHQgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKHZhbHVlKSB7XG5cdCAgICAgICAgICAgICAgICB2YXIgdmFsdWVzID0gZmllbGRzLm1hcChmdW5jdGlvbiAoX2EpIHtcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgbmFtZSA9IF9hLm5hbWUsIHR5cGUgPSBfYS50eXBlO1xuXHQgICAgICAgICAgICAgICAgICAgIHZhciByZXN1bHQgPSBfdGhpcy5nZXRFbmNvZGVyKHR5cGUpKHZhbHVlW25hbWVdKTtcblx0ICAgICAgICAgICAgICAgICAgICBpZiAoX3RoaXMuX3R5cGVzW3R5cGVdKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAoMCwgbGliJDQua2VjY2FrMjU2KShyZXN1bHQpO1xuXHQgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuXHQgICAgICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgICAgICAgICB2YWx1ZXMudW5zaGlmdChlbmNvZGVkVHlwZV8xKTtcblx0ICAgICAgICAgICAgICAgIHJldHVybiAoMCwgbGliJDEuaGV4Q29uY2F0KSh2YWx1ZXMpO1xuXHQgICAgICAgICAgICB9O1xuXHQgICAgICAgIH1cblx0ICAgICAgICByZXR1cm4gbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcInVua25vd24gdHlwZTogXCIgKyB0eXBlLCBcInR5cGVcIiwgdHlwZSk7XG5cdCAgICB9O1xuXHQgICAgVHlwZWREYXRhRW5jb2Rlci5wcm90b3R5cGUuZW5jb2RlVHlwZSA9IGZ1bmN0aW9uIChuYW1lKSB7XG5cdCAgICAgICAgdmFyIHJlc3VsdCA9IHRoaXMuX3R5cGVzW25hbWVdO1xuXHQgICAgICAgIGlmICghcmVzdWx0KSB7XG5cdCAgICAgICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJ1bmtub3duIHR5cGU6IFwiICsgSlNPTi5zdHJpbmdpZnkobmFtZSksIFwibmFtZVwiLCBuYW1lKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgcmV0dXJuIHJlc3VsdDtcblx0ICAgIH07XG5cdCAgICBUeXBlZERhdGFFbmNvZGVyLnByb3RvdHlwZS5lbmNvZGVEYXRhID0gZnVuY3Rpb24gKHR5cGUsIHZhbHVlKSB7XG5cdCAgICAgICAgcmV0dXJuIHRoaXMuZ2V0RW5jb2Rlcih0eXBlKSh2YWx1ZSk7XG5cdCAgICB9O1xuXHQgICAgVHlwZWREYXRhRW5jb2Rlci5wcm90b3R5cGUuaGFzaFN0cnVjdCA9IGZ1bmN0aW9uIChuYW1lLCB2YWx1ZSkge1xuXHQgICAgICAgIHJldHVybiAoMCwgbGliJDQua2VjY2FrMjU2KSh0aGlzLmVuY29kZURhdGEobmFtZSwgdmFsdWUpKTtcblx0ICAgIH07XG5cdCAgICBUeXBlZERhdGFFbmNvZGVyLnByb3RvdHlwZS5lbmNvZGUgPSBmdW5jdGlvbiAodmFsdWUpIHtcblx0ICAgICAgICByZXR1cm4gdGhpcy5lbmNvZGVEYXRhKHRoaXMucHJpbWFyeVR5cGUsIHZhbHVlKTtcblx0ICAgIH07XG5cdCAgICBUeXBlZERhdGFFbmNvZGVyLnByb3RvdHlwZS5oYXNoID0gZnVuY3Rpb24gKHZhbHVlKSB7XG5cdCAgICAgICAgcmV0dXJuIHRoaXMuaGFzaFN0cnVjdCh0aGlzLnByaW1hcnlUeXBlLCB2YWx1ZSk7XG5cdCAgICB9O1xuXHQgICAgVHlwZWREYXRhRW5jb2Rlci5wcm90b3R5cGUuX3Zpc2l0ID0gZnVuY3Rpb24gKHR5cGUsIHZhbHVlLCBjYWxsYmFjaykge1xuXHQgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cdCAgICAgICAgLy8gQmFzaWMgZW5jb2RlciB0eXBlIChhZGRyZXNzLCBib29sLCB1aW50MjU2LCBldGMpXG5cdCAgICAgICAge1xuXHQgICAgICAgICAgICB2YXIgZW5jb2RlciA9IGdldEJhc2VFbmNvZGVyKHR5cGUpO1xuXHQgICAgICAgICAgICBpZiAoZW5jb2Rlcikge1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKHR5cGUsIHZhbHVlKTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH1cblx0ICAgICAgICAvLyBBcnJheVxuXHQgICAgICAgIHZhciBtYXRjaCA9IHR5cGUubWF0Y2goL14oLiopKFxceDViKFxcZCopXFx4NWQpJC8pO1xuXHQgICAgICAgIGlmIChtYXRjaCkge1xuXHQgICAgICAgICAgICB2YXIgc3VidHlwZV8yID0gbWF0Y2hbMV07XG5cdCAgICAgICAgICAgIHZhciBsZW5ndGhfMiA9IHBhcnNlSW50KG1hdGNoWzNdKTtcblx0ICAgICAgICAgICAgaWYgKGxlbmd0aF8yID49IDAgJiYgdmFsdWUubGVuZ3RoICE9PSBsZW5ndGhfMikge1xuXHQgICAgICAgICAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcImFycmF5IGxlbmd0aCBtaXNtYXRjaDsgZXhwZWN0ZWQgbGVuZ3RoICR7IGFycmF5TGVuZ3RoIH1cIiwgXCJ2YWx1ZVwiLCB2YWx1ZSk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgcmV0dXJuIHZhbHVlLm1hcChmdW5jdGlvbiAodikgeyByZXR1cm4gX3RoaXMuX3Zpc2l0KHN1YnR5cGVfMiwgdiwgY2FsbGJhY2spOyB9KTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgLy8gU3RydWN0XG5cdCAgICAgICAgdmFyIGZpZWxkcyA9IHRoaXMudHlwZXNbdHlwZV07XG5cdCAgICAgICAgaWYgKGZpZWxkcykge1xuXHQgICAgICAgICAgICByZXR1cm4gZmllbGRzLnJlZHVjZShmdW5jdGlvbiAoYWNjdW0sIF9hKSB7XG5cdCAgICAgICAgICAgICAgICB2YXIgbmFtZSA9IF9hLm5hbWUsIHR5cGUgPSBfYS50eXBlO1xuXHQgICAgICAgICAgICAgICAgYWNjdW1bbmFtZV0gPSBfdGhpcy5fdmlzaXQodHlwZSwgdmFsdWVbbmFtZV0sIGNhbGxiYWNrKTtcblx0ICAgICAgICAgICAgICAgIHJldHVybiBhY2N1bTtcblx0ICAgICAgICAgICAgfSwge30pO1xuXHQgICAgICAgIH1cblx0ICAgICAgICByZXR1cm4gbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcInVua25vd24gdHlwZTogXCIgKyB0eXBlLCBcInR5cGVcIiwgdHlwZSk7XG5cdCAgICB9O1xuXHQgICAgVHlwZWREYXRhRW5jb2Rlci5wcm90b3R5cGUudmlzaXQgPSBmdW5jdGlvbiAodmFsdWUsIGNhbGxiYWNrKSB7XG5cdCAgICAgICAgcmV0dXJuIHRoaXMuX3Zpc2l0KHRoaXMucHJpbWFyeVR5cGUsIHZhbHVlLCBjYWxsYmFjayk7XG5cdCAgICB9O1xuXHQgICAgVHlwZWREYXRhRW5jb2Rlci5mcm9tID0gZnVuY3Rpb24gKHR5cGVzKSB7XG5cdCAgICAgICAgcmV0dXJuIG5ldyBUeXBlZERhdGFFbmNvZGVyKHR5cGVzKTtcblx0ICAgIH07XG5cdCAgICBUeXBlZERhdGFFbmNvZGVyLmdldFByaW1hcnlUeXBlID0gZnVuY3Rpb24gKHR5cGVzKSB7XG5cdCAgICAgICAgcmV0dXJuIFR5cGVkRGF0YUVuY29kZXIuZnJvbSh0eXBlcykucHJpbWFyeVR5cGU7XG5cdCAgICB9O1xuXHQgICAgVHlwZWREYXRhRW5jb2Rlci5oYXNoU3RydWN0ID0gZnVuY3Rpb24gKG5hbWUsIHR5cGVzLCB2YWx1ZSkge1xuXHQgICAgICAgIHJldHVybiBUeXBlZERhdGFFbmNvZGVyLmZyb20odHlwZXMpLmhhc2hTdHJ1Y3QobmFtZSwgdmFsdWUpO1xuXHQgICAgfTtcblx0ICAgIFR5cGVkRGF0YUVuY29kZXIuaGFzaERvbWFpbiA9IGZ1bmN0aW9uIChkb21haW4pIHtcblx0ICAgICAgICB2YXIgZG9tYWluRmllbGRzID0gW107XG5cdCAgICAgICAgZm9yICh2YXIgbmFtZV8zIGluIGRvbWFpbikge1xuXHQgICAgICAgICAgICB2YXIgdHlwZSA9IGRvbWFpbkZpZWxkVHlwZXNbbmFtZV8zXTtcblx0ICAgICAgICAgICAgaWYgKCF0eXBlKSB7XG5cdCAgICAgICAgICAgICAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwiaW52YWxpZCB0eXBlZC1kYXRhIGRvbWFpbiBrZXk6IFwiICsgSlNPTi5zdHJpbmdpZnkobmFtZV8zKSwgXCJkb21haW5cIiwgZG9tYWluKTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICBkb21haW5GaWVsZHMucHVzaCh7IG5hbWU6IG5hbWVfMywgdHlwZTogdHlwZSB9KTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgZG9tYWluRmllbGRzLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIGRvbWFpbkZpZWxkTmFtZXMuaW5kZXhPZihhLm5hbWUpIC0gZG9tYWluRmllbGROYW1lcy5pbmRleE9mKGIubmFtZSk7XG5cdCAgICAgICAgfSk7XG5cdCAgICAgICAgcmV0dXJuIFR5cGVkRGF0YUVuY29kZXIuaGFzaFN0cnVjdChcIkVJUDcxMkRvbWFpblwiLCB7IEVJUDcxMkRvbWFpbjogZG9tYWluRmllbGRzIH0sIGRvbWFpbik7XG5cdCAgICB9O1xuXHQgICAgVHlwZWREYXRhRW5jb2Rlci5lbmNvZGUgPSBmdW5jdGlvbiAoZG9tYWluLCB0eXBlcywgdmFsdWUpIHtcblx0ICAgICAgICByZXR1cm4gKDAsIGxpYiQxLmhleENvbmNhdCkoW1xuXHQgICAgICAgICAgICBcIjB4MTkwMVwiLFxuXHQgICAgICAgICAgICBUeXBlZERhdGFFbmNvZGVyLmhhc2hEb21haW4oZG9tYWluKSxcblx0ICAgICAgICAgICAgVHlwZWREYXRhRW5jb2Rlci5mcm9tKHR5cGVzKS5oYXNoKHZhbHVlKVxuXHQgICAgICAgIF0pO1xuXHQgICAgfTtcblx0ICAgIFR5cGVkRGF0YUVuY29kZXIuaGFzaCA9IGZ1bmN0aW9uIChkb21haW4sIHR5cGVzLCB2YWx1ZSkge1xuXHQgICAgICAgIHJldHVybiAoMCwgbGliJDQua2VjY2FrMjU2KShUeXBlZERhdGFFbmNvZGVyLmVuY29kZShkb21haW4sIHR5cGVzLCB2YWx1ZSkpO1xuXHQgICAgfTtcblx0ICAgIC8vIFJlcGxhY2VzIGFsbCBhZGRyZXNzIHR5cGVzIHdpdGggRU5TIG5hbWVzIHdpdGggdGhlaXIgbG9va2VkIHVwIGFkZHJlc3Ncblx0ICAgIFR5cGVkRGF0YUVuY29kZXIucmVzb2x2ZU5hbWVzID0gZnVuY3Rpb24gKGRvbWFpbiwgdHlwZXMsIHZhbHVlLCByZXNvbHZlTmFtZSkge1xuXHQgICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgdmFyIGVuc0NhY2hlLCBlbmNvZGVyLCBfYSwgX2IsIF9pLCBuYW1lXzQsIF9jLCBfZDtcblx0ICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfZSkge1xuXHQgICAgICAgICAgICAgICAgc3dpdGNoIChfZS5sYWJlbCkge1xuXHQgICAgICAgICAgICAgICAgICAgIGNhc2UgMDpcblx0ICAgICAgICAgICAgICAgICAgICAgICAgLy8gTWFrZSBhIGNvcHkgdG8gaXNvbGF0ZSBpdCBmcm9tIHRoZSBvYmplY3QgcGFzc2VkIGluXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGRvbWFpbiA9ICgwLCBsaWIkMy5zaGFsbG93Q29weSkoZG9tYWluKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgZW5zQ2FjaGUgPSB7fTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgLy8gRG8gd2UgbmVlZCB0byBsb29rIHVwIHRoZSBkb21haW4ncyB2ZXJpZnlpbmdDb250cmFjdD9cblx0ICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGRvbWFpbi52ZXJpZnlpbmdDb250cmFjdCAmJiAhKDAsIGxpYiQxLmlzSGV4U3RyaW5nKShkb21haW4udmVyaWZ5aW5nQ29udHJhY3QsIDIwKSkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgZW5zQ2FjaGVbZG9tYWluLnZlcmlmeWluZ0NvbnRyYWN0XSA9IFwiMHhcIjtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgICAgICBlbmNvZGVyID0gVHlwZWREYXRhRW5jb2Rlci5mcm9tKHR5cGVzKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgLy8gR2V0IGEgbGlzdCBvZiBhbGwgdGhlIGFkZHJlc3Nlc1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBlbmNvZGVyLnZpc2l0KHZhbHVlLCBmdW5jdGlvbiAodHlwZSwgdmFsdWUpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0eXBlID09PSBcImFkZHJlc3NcIiAmJiAhKDAsIGxpYiQxLmlzSGV4U3RyaW5nKSh2YWx1ZSwgMjApKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZW5zQ2FjaGVbdmFsdWVdID0gXCIweFwiO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB9KTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgX2EgPSBbXTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChfYiBpbiBlbnNDYWNoZSlcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9hLnB1c2goX2IpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBfaSA9IDA7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIF9lLmxhYmVsID0gMTtcblx0ICAgICAgICAgICAgICAgICAgICBjYXNlIDE6XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGlmICghKF9pIDwgX2EubGVuZ3RoKSkgcmV0dXJuIFszIC8qYnJlYWsqLywgNF07XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIG5hbWVfNCA9IF9hW19pXTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgX2MgPSBlbnNDYWNoZTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgX2QgPSBuYW1lXzQ7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIHJlc29sdmVOYW1lKG5hbWVfNCldO1xuXHQgICAgICAgICAgICAgICAgICAgIGNhc2UgMjpcblx0ICAgICAgICAgICAgICAgICAgICAgICAgX2NbX2RdID0gX2Uuc2VudCgpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBfZS5sYWJlbCA9IDM7XG5cdCAgICAgICAgICAgICAgICAgICAgY2FzZSAzOlxuXHQgICAgICAgICAgICAgICAgICAgICAgICBfaSsrO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzMgLypicmVhayovLCAxXTtcblx0ICAgICAgICAgICAgICAgICAgICBjYXNlIDQ6XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIC8vIFJlcGxhY2UgdGhlIGRvbWFpbiB2ZXJpZnlpbmdDb250cmFjdCBpZiBuZWVkZWRcblx0ICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGRvbWFpbi52ZXJpZnlpbmdDb250cmFjdCAmJiBlbnNDYWNoZVtkb21haW4udmVyaWZ5aW5nQ29udHJhY3RdKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBkb21haW4udmVyaWZ5aW5nQ29udHJhY3QgPSBlbnNDYWNoZVtkb21haW4udmVyaWZ5aW5nQ29udHJhY3RdO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIC8vIFJlcGxhY2UgYWxsIEVOUyBuYW1lcyB3aXRoIHRoZWlyIGFkZHJlc3Ncblx0ICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBlbmNvZGVyLnZpc2l0KHZhbHVlLCBmdW5jdGlvbiAodHlwZSwgdmFsdWUpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0eXBlID09PSBcImFkZHJlc3NcIiAmJiBlbnNDYWNoZVt2YWx1ZV0pIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZW5zQ2FjaGVbdmFsdWVdO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB9KTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIHsgZG9tYWluOiBkb21haW4sIHZhbHVlOiB2YWx1ZSB9XTtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgfSk7XG5cdCAgICB9O1xuXHQgICAgVHlwZWREYXRhRW5jb2Rlci5nZXRQYXlsb2FkID0gZnVuY3Rpb24gKGRvbWFpbiwgdHlwZXMsIHZhbHVlKSB7XG5cdCAgICAgICAgLy8gVmFsaWRhdGUgdGhlIGRvbWFpbiBmaWVsZHNcblx0ICAgICAgICBUeXBlZERhdGFFbmNvZGVyLmhhc2hEb21haW4oZG9tYWluKTtcblx0ICAgICAgICAvLyBEZXJpdmUgdGhlIEVJUDcxMkRvbWFpbiBTdHJ1Y3QgcmVmZXJlbmNlIHR5cGVcblx0ICAgICAgICB2YXIgZG9tYWluVmFsdWVzID0ge307XG5cdCAgICAgICAgdmFyIGRvbWFpblR5cGVzID0gW107XG5cdCAgICAgICAgZG9tYWluRmllbGROYW1lcy5mb3JFYWNoKGZ1bmN0aW9uIChuYW1lKSB7XG5cdCAgICAgICAgICAgIHZhciB2YWx1ZSA9IGRvbWFpbltuYW1lXTtcblx0ICAgICAgICAgICAgaWYgKHZhbHVlID09IG51bGwpIHtcblx0ICAgICAgICAgICAgICAgIHJldHVybjtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICBkb21haW5WYWx1ZXNbbmFtZV0gPSBkb21haW5DaGVja3NbbmFtZV0odmFsdWUpO1xuXHQgICAgICAgICAgICBkb21haW5UeXBlcy5wdXNoKHsgbmFtZTogbmFtZSwgdHlwZTogZG9tYWluRmllbGRUeXBlc1tuYW1lXSB9KTtcblx0ICAgICAgICB9KTtcblx0ICAgICAgICB2YXIgZW5jb2RlciA9IFR5cGVkRGF0YUVuY29kZXIuZnJvbSh0eXBlcyk7XG5cdCAgICAgICAgdmFyIHR5cGVzV2l0aERvbWFpbiA9ICgwLCBsaWIkMy5zaGFsbG93Q29weSkodHlwZXMpO1xuXHQgICAgICAgIGlmICh0eXBlc1dpdGhEb21haW4uRUlQNzEyRG9tYWluKSB7XG5cdCAgICAgICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJ0eXBlcyBtdXN0IG5vdCBjb250YWluIEVJUDcxMkRvbWFpbiB0eXBlXCIsIFwidHlwZXMuRUlQNzEyRG9tYWluXCIsIHR5cGVzKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgZWxzZSB7XG5cdCAgICAgICAgICAgIHR5cGVzV2l0aERvbWFpbi5FSVA3MTJEb21haW4gPSBkb21haW5UeXBlcztcblx0ICAgICAgICB9XG5cdCAgICAgICAgLy8gVmFsaWRhdGUgdGhlIGRhdGEgc3RydWN0dXJlcyBhbmQgdHlwZXNcblx0ICAgICAgICBlbmNvZGVyLmVuY29kZSh2YWx1ZSk7XG5cdCAgICAgICAgcmV0dXJuIHtcblx0ICAgICAgICAgICAgdHlwZXM6IHR5cGVzV2l0aERvbWFpbixcblx0ICAgICAgICAgICAgZG9tYWluOiBkb21haW5WYWx1ZXMsXG5cdCAgICAgICAgICAgIHByaW1hcnlUeXBlOiBlbmNvZGVyLnByaW1hcnlUeXBlLFxuXHQgICAgICAgICAgICBtZXNzYWdlOiBlbmNvZGVyLnZpc2l0KHZhbHVlLCBmdW5jdGlvbiAodHlwZSwgdmFsdWUpIHtcblx0ICAgICAgICAgICAgICAgIC8vIGJ5dGVzXG5cdCAgICAgICAgICAgICAgICBpZiAodHlwZS5tYXRjaCgvXmJ5dGVzKFxcZCopLykpIHtcblx0ICAgICAgICAgICAgICAgICAgICByZXR1cm4gKDAsIGxpYiQxLmhleGxpZnkpKCgwLCBsaWIkMS5hcnJheWlmeSkodmFsdWUpKTtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgIC8vIHVpbnQgb3IgaW50XG5cdCAgICAgICAgICAgICAgICBpZiAodHlwZS5tYXRjaCgvXnU/aW50LykpIHtcblx0ICAgICAgICAgICAgICAgICAgICByZXR1cm4gbGliJDIuQmlnTnVtYmVyLmZyb20odmFsdWUpLnRvU3RyaW5nKCk7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICBzd2l0Y2ggKHR5cGUpIHtcblx0ICAgICAgICAgICAgICAgICAgICBjYXNlIFwiYWRkcmVzc1wiOlxuXHQgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWUudG9Mb3dlckNhc2UoKTtcblx0ICAgICAgICAgICAgICAgICAgICBjYXNlIFwiYm9vbFwiOlxuXHQgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gISF2YWx1ZTtcblx0ICAgICAgICAgICAgICAgICAgICBjYXNlIFwic3RyaW5nXCI6XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgKHZhbHVlKSAhPT0gXCJzdHJpbmdcIikge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcImludmFsaWQgc3RyaW5nXCIsIFwidmFsdWVcIiwgdmFsdWUpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgIHJldHVybiBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwidW5zdXBwb3J0ZWQgdHlwZVwiLCBcInR5cGVcIiwgdHlwZSk7XG5cdCAgICAgICAgICAgIH0pXG5cdCAgICAgICAgfTtcblx0ICAgIH07XG5cdCAgICByZXR1cm4gVHlwZWREYXRhRW5jb2Rlcjtcblx0fSgpKTtcblx0ZXhwb3J0cy5UeXBlZERhdGFFbmNvZGVyID0gVHlwZWREYXRhRW5jb2RlcjtcblxuXHR9KTtcblxuXHR2YXIgdHlwZWREYXRhJDEgPSAvKkBfX1BVUkVfXyovZ2V0RGVmYXVsdEV4cG9ydEZyb21DanModHlwZWREYXRhKTtcblxuXHR2YXIgbGliJDkgPSBjcmVhdGVDb21tb25qc01vZHVsZShmdW5jdGlvbiAobW9kdWxlLCBleHBvcnRzKSB7XG5cdFwidXNlIHN0cmljdFwiO1xuXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5cdGV4cG9ydHMuX1R5cGVkRGF0YUVuY29kZXIgPSBleHBvcnRzLmhhc2hNZXNzYWdlID0gZXhwb3J0cy5tZXNzYWdlUHJlZml4ID0gZXhwb3J0cy5pc1ZhbGlkTmFtZSA9IGV4cG9ydHMubmFtZWhhc2ggPSBleHBvcnRzLmlkID0gdm9pZCAwO1xuXG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImlkXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBpZF8xLmlkOyB9IH0pO1xuXG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImlzVmFsaWROYW1lXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBuYW1laGFzaF8xLmlzVmFsaWROYW1lOyB9IH0pO1xuXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJuYW1laGFzaFwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gbmFtZWhhc2hfMS5uYW1laGFzaDsgfSB9KTtcblxuXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJoYXNoTWVzc2FnZVwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gbWVzc2FnZS5oYXNoTWVzc2FnZTsgfSB9KTtcblx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwibWVzc2FnZVByZWZpeFwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gbWVzc2FnZS5tZXNzYWdlUHJlZml4OyB9IH0pO1xuXG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9UeXBlZERhdGFFbmNvZGVyXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0eXBlZERhdGEuVHlwZWREYXRhRW5jb2RlcjsgfSB9KTtcblxuXHR9KTtcblxuXHR2YXIgaW5kZXgkOSA9IC8qQF9fUFVSRV9fKi9nZXREZWZhdWx0RXhwb3J0RnJvbUNqcyhsaWIkOSk7XG5cblx0dmFyIF9pbnRlcmZhY2UgPSBjcmVhdGVDb21tb25qc01vZHVsZShmdW5jdGlvbiAobW9kdWxlLCBleHBvcnRzKSB7XG5cdFwidXNlIHN0cmljdFwiO1xuXHR2YXIgX19leHRlbmRzID0gKGNvbW1vbmpzR2xvYmFsICYmIGNvbW1vbmpzR2xvYmFsLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcblx0ICAgIHZhciBleHRlbmRTdGF0aWNzID0gZnVuY3Rpb24gKGQsIGIpIHtcblx0ICAgICAgICBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG5cdCAgICAgICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcblx0ICAgICAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGIsIHApKSBkW3BdID0gYltwXTsgfTtcblx0ICAgICAgICByZXR1cm4gZXh0ZW5kU3RhdGljcyhkLCBiKTtcblx0ICAgIH07XG5cdCAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcblx0ICAgICAgICBpZiAodHlwZW9mIGIgIT09IFwiZnVuY3Rpb25cIiAmJiBiICE9PSBudWxsKVxuXHQgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2xhc3MgZXh0ZW5kcyB2YWx1ZSBcIiArIFN0cmluZyhiKSArIFwiIGlzIG5vdCBhIGNvbnN0cnVjdG9yIG9yIG51bGxcIik7XG5cdCAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcblx0ICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cblx0ICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG5cdCAgICB9O1xuXHR9KSgpO1xuXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5cdGV4cG9ydHMuSW50ZXJmYWNlID0gZXhwb3J0cy5JbmRleGVkID0gZXhwb3J0cy5FcnJvckRlc2NyaXB0aW9uID0gZXhwb3J0cy5UcmFuc2FjdGlvbkRlc2NyaXB0aW9uID0gZXhwb3J0cy5Mb2dEZXNjcmlwdGlvbiA9IGV4cG9ydHMuY2hlY2tSZXN1bHRFcnJvcnMgPSB2b2lkIDA7XG5cblxuXG5cblxuXG5cblxuXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJjaGVja1Jlc3VsdEVycm9yc1wiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gYWJzdHJhY3RDb2Rlci5jaGVja1Jlc3VsdEVycm9yczsgfSB9KTtcblxuXG5cblx0dmFyIGxvZ2dlciA9IG5ldyBsaWIuTG9nZ2VyKF92ZXJzaW9uJDgudmVyc2lvbik7XG5cdHZhciBMb2dEZXNjcmlwdGlvbiA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcblx0ICAgIF9fZXh0ZW5kcyhMb2dEZXNjcmlwdGlvbiwgX3N1cGVyKTtcblx0ICAgIGZ1bmN0aW9uIExvZ0Rlc2NyaXB0aW9uKCkge1xuXHQgICAgICAgIHJldHVybiBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcblx0ICAgIH1cblx0ICAgIHJldHVybiBMb2dEZXNjcmlwdGlvbjtcblx0fShsaWIkMy5EZXNjcmlwdGlvbikpO1xuXHRleHBvcnRzLkxvZ0Rlc2NyaXB0aW9uID0gTG9nRGVzY3JpcHRpb247XG5cdHZhciBUcmFuc2FjdGlvbkRlc2NyaXB0aW9uID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuXHQgICAgX19leHRlbmRzKFRyYW5zYWN0aW9uRGVzY3JpcHRpb24sIF9zdXBlcik7XG5cdCAgICBmdW5jdGlvbiBUcmFuc2FjdGlvbkRlc2NyaXB0aW9uKCkge1xuXHQgICAgICAgIHJldHVybiBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcblx0ICAgIH1cblx0ICAgIHJldHVybiBUcmFuc2FjdGlvbkRlc2NyaXB0aW9uO1xuXHR9KGxpYiQzLkRlc2NyaXB0aW9uKSk7XG5cdGV4cG9ydHMuVHJhbnNhY3Rpb25EZXNjcmlwdGlvbiA9IFRyYW5zYWN0aW9uRGVzY3JpcHRpb247XG5cdHZhciBFcnJvckRlc2NyaXB0aW9uID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuXHQgICAgX19leHRlbmRzKEVycm9yRGVzY3JpcHRpb24sIF9zdXBlcik7XG5cdCAgICBmdW5jdGlvbiBFcnJvckRlc2NyaXB0aW9uKCkge1xuXHQgICAgICAgIHJldHVybiBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcblx0ICAgIH1cblx0ICAgIHJldHVybiBFcnJvckRlc2NyaXB0aW9uO1xuXHR9KGxpYiQzLkRlc2NyaXB0aW9uKSk7XG5cdGV4cG9ydHMuRXJyb3JEZXNjcmlwdGlvbiA9IEVycm9yRGVzY3JpcHRpb247XG5cdHZhciBJbmRleGVkID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuXHQgICAgX19leHRlbmRzKEluZGV4ZWQsIF9zdXBlcik7XG5cdCAgICBmdW5jdGlvbiBJbmRleGVkKCkge1xuXHQgICAgICAgIHJldHVybiBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcblx0ICAgIH1cblx0ICAgIEluZGV4ZWQuaXNJbmRleGVkID0gZnVuY3Rpb24gKHZhbHVlKSB7XG5cdCAgICAgICAgcmV0dXJuICEhKHZhbHVlICYmIHZhbHVlLl9pc0luZGV4ZWQpO1xuXHQgICAgfTtcblx0ICAgIHJldHVybiBJbmRleGVkO1xuXHR9KGxpYiQzLkRlc2NyaXB0aW9uKSk7XG5cdGV4cG9ydHMuSW5kZXhlZCA9IEluZGV4ZWQ7XG5cdHZhciBCdWlsdGluRXJyb3JzID0ge1xuXHQgICAgXCIweDA4YzM3OWEwXCI6IHsgc2lnbmF0dXJlOiBcIkVycm9yKHN0cmluZylcIiwgbmFtZTogXCJFcnJvclwiLCBpbnB1dHM6IFtcInN0cmluZ1wiXSwgcmVhc29uOiB0cnVlIH0sXG5cdCAgICBcIjB4NGU0ODdiNzFcIjogeyBzaWduYXR1cmU6IFwiUGFuaWModWludDI1NilcIiwgbmFtZTogXCJQYW5pY1wiLCBpbnB1dHM6IFtcInVpbnQyNTZcIl0gfVxuXHR9O1xuXHRmdW5jdGlvbiB3cmFwQWNjZXNzRXJyb3IocHJvcGVydHksIGVycm9yKSB7XG5cdCAgICB2YXIgd3JhcCA9IG5ldyBFcnJvcihcImRlZmVycmVkIGVycm9yIGR1cmluZyBBQkkgZGVjb2RpbmcgdHJpZ2dlcmVkIGFjY2Vzc2luZyBcIiArIHByb3BlcnR5KTtcblx0ICAgIHdyYXAuZXJyb3IgPSBlcnJvcjtcblx0ICAgIHJldHVybiB3cmFwO1xuXHR9XG5cdC8qXG5cdGZ1bmN0aW9uIGNoZWNrTmFtZXMoZnJhZ21lbnQ6IEZyYWdtZW50LCB0eXBlOiBcImlucHV0XCIgfCBcIm91dHB1dFwiLCBwYXJhbXM6IEFycmF5PFBhcmFtVHlwZT4pOiB2b2lkIHtcblx0ICAgIHBhcmFtcy5yZWR1Y2UoKGFjY3VtLCBwYXJhbSkgPT4ge1xuXHQgICAgICAgIGlmIChwYXJhbS5uYW1lKSB7XG5cdCAgICAgICAgICAgIGlmIChhY2N1bVtwYXJhbS5uYW1lXSkge1xuXHQgICAgICAgICAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihgZHVwbGljYXRlICR7IHR5cGUgfSBwYXJhbWV0ZXIgJHsgSlNPTi5zdHJpbmdpZnkocGFyYW0ubmFtZSkgfSBpbiAkeyBmcmFnbWVudC5mb3JtYXQoXCJmdWxsXCIpIH1gLCBcImZyYWdtZW50XCIsIGZyYWdtZW50KTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICBhY2N1bVtwYXJhbS5uYW1lXSA9IHRydWU7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHJldHVybiBhY2N1bTtcblx0ICAgIH0sIDx7IFsgbmFtZTogc3RyaW5nIF06IGJvb2xlYW4gfT57IH0pO1xuXHR9XG5cdCovXG5cdHZhciBJbnRlcmZhY2UgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG5cdCAgICBmdW5jdGlvbiBJbnRlcmZhY2UoZnJhZ21lbnRzJDEpIHtcblx0ICAgICAgICB2YXIgX25ld1RhcmdldCA9IHRoaXMuY29uc3RydWN0b3I7XG5cdCAgICAgICAgdmFyIF90aGlzID0gdGhpcztcblx0ICAgICAgICBsb2dnZXIuY2hlY2tOZXcoX25ld1RhcmdldCwgSW50ZXJmYWNlKTtcblx0ICAgICAgICB2YXIgYWJpID0gW107XG5cdCAgICAgICAgaWYgKHR5cGVvZiAoZnJhZ21lbnRzJDEpID09PSBcInN0cmluZ1wiKSB7XG5cdCAgICAgICAgICAgIGFiaSA9IEpTT04ucGFyc2UoZnJhZ21lbnRzJDEpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBlbHNlIHtcblx0ICAgICAgICAgICAgYWJpID0gZnJhZ21lbnRzJDE7XG5cdCAgICAgICAgfVxuXHQgICAgICAgICgwLCBsaWIkMy5kZWZpbmVSZWFkT25seSkodGhpcywgXCJmcmFnbWVudHNcIiwgYWJpLm1hcChmdW5jdGlvbiAoZnJhZ21lbnQpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIGZyYWdtZW50cy5GcmFnbWVudC5mcm9tKGZyYWdtZW50KTtcblx0ICAgICAgICB9KS5maWx0ZXIoZnVuY3Rpb24gKGZyYWdtZW50KSB7IHJldHVybiAoZnJhZ21lbnQgIT0gbnVsbCk7IH0pKTtcblx0ICAgICAgICAoMCwgbGliJDMuZGVmaW5lUmVhZE9ubHkpKHRoaXMsIFwiX2FiaUNvZGVyXCIsICgwLCBsaWIkMy5nZXRTdGF0aWMpKF9uZXdUYXJnZXQsIFwiZ2V0QWJpQ29kZXJcIikoKSk7XG5cdCAgICAgICAgKDAsIGxpYiQzLmRlZmluZVJlYWRPbmx5KSh0aGlzLCBcImZ1bmN0aW9uc1wiLCB7fSk7XG5cdCAgICAgICAgKDAsIGxpYiQzLmRlZmluZVJlYWRPbmx5KSh0aGlzLCBcImVycm9yc1wiLCB7fSk7XG5cdCAgICAgICAgKDAsIGxpYiQzLmRlZmluZVJlYWRPbmx5KSh0aGlzLCBcImV2ZW50c1wiLCB7fSk7XG5cdCAgICAgICAgKDAsIGxpYiQzLmRlZmluZVJlYWRPbmx5KSh0aGlzLCBcInN0cnVjdHNcIiwge30pO1xuXHQgICAgICAgIC8vIEFkZCBhbGwgZnJhZ21lbnRzIGJ5IHRoZWlyIHNpZ25hdHVyZVxuXHQgICAgICAgIHRoaXMuZnJhZ21lbnRzLmZvckVhY2goZnVuY3Rpb24gKGZyYWdtZW50KSB7XG5cdCAgICAgICAgICAgIHZhciBidWNrZXQgPSBudWxsO1xuXHQgICAgICAgICAgICBzd2l0Y2ggKGZyYWdtZW50LnR5cGUpIHtcblx0ICAgICAgICAgICAgICAgIGNhc2UgXCJjb25zdHJ1Y3RvclwiOlxuXHQgICAgICAgICAgICAgICAgICAgIGlmIChfdGhpcy5kZXBsb3kpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgbG9nZ2VyLndhcm4oXCJkdXBsaWNhdGUgZGVmaW5pdGlvbiAtIGNvbnN0cnVjdG9yXCIpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG5cdCAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgIC8vY2hlY2tOYW1lcyhmcmFnbWVudCwgXCJpbnB1dFwiLCBmcmFnbWVudC5pbnB1dHMpO1xuXHQgICAgICAgICAgICAgICAgICAgICgwLCBsaWIkMy5kZWZpbmVSZWFkT25seSkoX3RoaXMsIFwiZGVwbG95XCIsIGZyYWdtZW50KTtcblx0ICAgICAgICAgICAgICAgICAgICByZXR1cm47XG5cdCAgICAgICAgICAgICAgICBjYXNlIFwiZnVuY3Rpb25cIjpcblx0ICAgICAgICAgICAgICAgICAgICAvL2NoZWNrTmFtZXMoZnJhZ21lbnQsIFwiaW5wdXRcIiwgZnJhZ21lbnQuaW5wdXRzKTtcblx0ICAgICAgICAgICAgICAgICAgICAvL2NoZWNrTmFtZXMoZnJhZ21lbnQsIFwib3V0cHV0XCIsICg8RnVuY3Rpb25GcmFnbWVudD5mcmFnbWVudCkub3V0cHV0cyk7XG5cdCAgICAgICAgICAgICAgICAgICAgYnVja2V0ID0gX3RoaXMuZnVuY3Rpb25zO1xuXHQgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXHQgICAgICAgICAgICAgICAgY2FzZSBcImV2ZW50XCI6XG5cdCAgICAgICAgICAgICAgICAgICAgLy9jaGVja05hbWVzKGZyYWdtZW50LCBcImlucHV0XCIsIGZyYWdtZW50LmlucHV0cyk7XG5cdCAgICAgICAgICAgICAgICAgICAgYnVja2V0ID0gX3RoaXMuZXZlbnRzO1xuXHQgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXHQgICAgICAgICAgICAgICAgY2FzZSBcImVycm9yXCI6XG5cdCAgICAgICAgICAgICAgICAgICAgYnVja2V0ID0gX3RoaXMuZXJyb3JzO1xuXHQgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXHQgICAgICAgICAgICAgICAgZGVmYXVsdDpcblx0ICAgICAgICAgICAgICAgICAgICByZXR1cm47XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgdmFyIHNpZ25hdHVyZSA9IGZyYWdtZW50LmZvcm1hdCgpO1xuXHQgICAgICAgICAgICBpZiAoYnVja2V0W3NpZ25hdHVyZV0pIHtcblx0ICAgICAgICAgICAgICAgIGxvZ2dlci53YXJuKFwiZHVwbGljYXRlIGRlZmluaXRpb24gLSBcIiArIHNpZ25hdHVyZSk7XG5cdCAgICAgICAgICAgICAgICByZXR1cm47XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgYnVja2V0W3NpZ25hdHVyZV0gPSBmcmFnbWVudDtcblx0ICAgICAgICB9KTtcblx0ICAgICAgICAvLyBJZiB3ZSBkbyBub3QgaGF2ZSBhIGNvbnN0cnVjdG9yIGFkZCBhIGRlZmF1bHRcblx0ICAgICAgICBpZiAoIXRoaXMuZGVwbG95KSB7XG5cdCAgICAgICAgICAgICgwLCBsaWIkMy5kZWZpbmVSZWFkT25seSkodGhpcywgXCJkZXBsb3lcIiwgZnJhZ21lbnRzLkNvbnN0cnVjdG9yRnJhZ21lbnQuZnJvbSh7XG5cdCAgICAgICAgICAgICAgICBwYXlhYmxlOiBmYWxzZSxcblx0ICAgICAgICAgICAgICAgIHR5cGU6IFwiY29uc3RydWN0b3JcIlxuXHQgICAgICAgICAgICB9KSk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgICgwLCBsaWIkMy5kZWZpbmVSZWFkT25seSkodGhpcywgXCJfaXNJbnRlcmZhY2VcIiwgdHJ1ZSk7XG5cdCAgICB9XG5cdCAgICBJbnRlcmZhY2UucHJvdG90eXBlLmZvcm1hdCA9IGZ1bmN0aW9uIChmb3JtYXQpIHtcblx0ICAgICAgICBpZiAoIWZvcm1hdCkge1xuXHQgICAgICAgICAgICBmb3JtYXQgPSBmcmFnbWVudHMuRm9ybWF0VHlwZXMuZnVsbDtcblx0ICAgICAgICB9XG5cdCAgICAgICAgaWYgKGZvcm1hdCA9PT0gZnJhZ21lbnRzLkZvcm1hdFR5cGVzLnNpZ2hhc2gpIHtcblx0ICAgICAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcImludGVyZmFjZSBkb2VzIG5vdCBzdXBwb3J0IGZvcm1hdHRpbmcgc2lnaGFzaFwiLCBcImZvcm1hdFwiLCBmb3JtYXQpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICB2YXIgYWJpID0gdGhpcy5mcmFnbWVudHMubWFwKGZ1bmN0aW9uIChmcmFnbWVudCkgeyByZXR1cm4gZnJhZ21lbnQuZm9ybWF0KGZvcm1hdCk7IH0pO1xuXHQgICAgICAgIC8vIFdlIG5lZWQgdG8gcmUtYnVuZGxlIHRoZSBKU09OIGZyYWdtZW50cyBhIGJpdFxuXHQgICAgICAgIGlmIChmb3JtYXQgPT09IGZyYWdtZW50cy5Gb3JtYXRUeXBlcy5qc29uKSB7XG5cdCAgICAgICAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeShhYmkubWFwKGZ1bmN0aW9uIChqKSB7IHJldHVybiBKU09OLnBhcnNlKGopOyB9KSk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHJldHVybiBhYmk7XG5cdCAgICB9O1xuXHQgICAgLy8gU3ViLWNsYXNzZXMgY2FuIG92ZXJyaWRlIHRoZXNlIHRvIGhhbmRsZSBvdGhlciBibG9ja2NoYWluc1xuXHQgICAgSW50ZXJmYWNlLmdldEFiaUNvZGVyID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIHJldHVybiBhYmlDb2Rlci5kZWZhdWx0QWJpQ29kZXI7XG5cdCAgICB9O1xuXHQgICAgSW50ZXJmYWNlLmdldEFkZHJlc3MgPSBmdW5jdGlvbiAoYWRkcmVzcykge1xuXHQgICAgICAgIHJldHVybiAoMCwgbGliJDYuZ2V0QWRkcmVzcykoYWRkcmVzcyk7XG5cdCAgICB9O1xuXHQgICAgSW50ZXJmYWNlLmdldFNpZ2hhc2ggPSBmdW5jdGlvbiAoZnJhZ21lbnQpIHtcblx0ICAgICAgICByZXR1cm4gKDAsIGxpYiQxLmhleERhdGFTbGljZSkoKDAsIGxpYiQ5LmlkKShmcmFnbWVudC5mb3JtYXQoKSksIDAsIDQpO1xuXHQgICAgfTtcblx0ICAgIEludGVyZmFjZS5nZXRFdmVudFRvcGljID0gZnVuY3Rpb24gKGV2ZW50RnJhZ21lbnQpIHtcblx0ICAgICAgICByZXR1cm4gKDAsIGxpYiQ5LmlkKShldmVudEZyYWdtZW50LmZvcm1hdCgpKTtcblx0ICAgIH07XG5cdCAgICAvLyBGaW5kIGEgZnVuY3Rpb24gZGVmaW5pdGlvbiBieSBhbnkgbWVhbnMgbmVjZXNzYXJ5ICh1bmxlc3MgaXQgaXMgYW1iaWd1b3VzKVxuXHQgICAgSW50ZXJmYWNlLnByb3RvdHlwZS5nZXRGdW5jdGlvbiA9IGZ1bmN0aW9uIChuYW1lT3JTaWduYXR1cmVPclNpZ2hhc2gpIHtcblx0ICAgICAgICBpZiAoKDAsIGxpYiQxLmlzSGV4U3RyaW5nKShuYW1lT3JTaWduYXR1cmVPclNpZ2hhc2gpKSB7XG5cdCAgICAgICAgICAgIGZvciAodmFyIG5hbWVfMSBpbiB0aGlzLmZ1bmN0aW9ucykge1xuXHQgICAgICAgICAgICAgICAgaWYgKG5hbWVPclNpZ25hdHVyZU9yU2lnaGFzaCA9PT0gdGhpcy5nZXRTaWdoYXNoKG5hbWVfMSkpIHtcblx0ICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5mdW5jdGlvbnNbbmFtZV8xXTtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwibm8gbWF0Y2hpbmcgZnVuY3Rpb25cIiwgXCJzaWdoYXNoXCIsIG5hbWVPclNpZ25hdHVyZU9yU2lnaGFzaCk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIC8vIEl0IGlzIGEgYmFyZSBuYW1lLCBsb29rIHVwIHRoZSBmdW5jdGlvbiAod2lsbCByZXR1cm4gbnVsbCBpZiBhbWJpZ3VvdXMpXG5cdCAgICAgICAgaWYgKG5hbWVPclNpZ25hdHVyZU9yU2lnaGFzaC5pbmRleE9mKFwiKFwiKSA9PT0gLTEpIHtcblx0ICAgICAgICAgICAgdmFyIG5hbWVfMiA9IG5hbWVPclNpZ25hdHVyZU9yU2lnaGFzaC50cmltKCk7XG5cdCAgICAgICAgICAgIHZhciBtYXRjaGluZyA9IE9iamVjdC5rZXlzKHRoaXMuZnVuY3Rpb25zKS5maWx0ZXIoZnVuY3Rpb24gKGYpIHsgcmV0dXJuIChmLnNwbGl0KFwiKFwiIC8qIGZpeDopICovKVswXSA9PT0gbmFtZV8yKTsgfSk7XG5cdCAgICAgICAgICAgIGlmIChtYXRjaGluZy5sZW5ndGggPT09IDApIHtcblx0ICAgICAgICAgICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJubyBtYXRjaGluZyBmdW5jdGlvblwiLCBcIm5hbWVcIiwgbmFtZV8yKTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICBlbHNlIGlmIChtYXRjaGluZy5sZW5ndGggPiAxKSB7XG5cdCAgICAgICAgICAgICAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwibXVsdGlwbGUgbWF0Y2hpbmcgZnVuY3Rpb25zXCIsIFwibmFtZVwiLCBuYW1lXzIpO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIHJldHVybiB0aGlzLmZ1bmN0aW9uc1ttYXRjaGluZ1swXV07XG5cdCAgICAgICAgfVxuXHQgICAgICAgIC8vIE5vcm1hbGl6ZSB0aGUgc2lnbmF0dXJlIGFuZCBsb29rdXAgdGhlIGZ1bmN0aW9uXG5cdCAgICAgICAgdmFyIHJlc3VsdCA9IHRoaXMuZnVuY3Rpb25zW2ZyYWdtZW50cy5GdW5jdGlvbkZyYWdtZW50LmZyb21TdHJpbmcobmFtZU9yU2lnbmF0dXJlT3JTaWdoYXNoKS5mb3JtYXQoKV07XG5cdCAgICAgICAgaWYgKCFyZXN1bHQpIHtcblx0ICAgICAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcIm5vIG1hdGNoaW5nIGZ1bmN0aW9uXCIsIFwic2lnbmF0dXJlXCIsIG5hbWVPclNpZ25hdHVyZU9yU2lnaGFzaCk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHJldHVybiByZXN1bHQ7XG5cdCAgICB9O1xuXHQgICAgLy8gRmluZCBhbiBldmVudCBkZWZpbml0aW9uIGJ5IGFueSBtZWFucyBuZWNlc3NhcnkgKHVubGVzcyBpdCBpcyBhbWJpZ3VvdXMpXG5cdCAgICBJbnRlcmZhY2UucHJvdG90eXBlLmdldEV2ZW50ID0gZnVuY3Rpb24gKG5hbWVPclNpZ25hdHVyZU9yVG9waWMpIHtcblx0ICAgICAgICBpZiAoKDAsIGxpYiQxLmlzSGV4U3RyaW5nKShuYW1lT3JTaWduYXR1cmVPclRvcGljKSkge1xuXHQgICAgICAgICAgICB2YXIgdG9waWNoYXNoID0gbmFtZU9yU2lnbmF0dXJlT3JUb3BpYy50b0xvd2VyQ2FzZSgpO1xuXHQgICAgICAgICAgICBmb3IgKHZhciBuYW1lXzMgaW4gdGhpcy5ldmVudHMpIHtcblx0ICAgICAgICAgICAgICAgIGlmICh0b3BpY2hhc2ggPT09IHRoaXMuZ2V0RXZlbnRUb3BpYyhuYW1lXzMpKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZXZlbnRzW25hbWVfM107XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcIm5vIG1hdGNoaW5nIGV2ZW50XCIsIFwidG9waWNoYXNoXCIsIHRvcGljaGFzaCk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIC8vIEl0IGlzIGEgYmFyZSBuYW1lLCBsb29rIHVwIHRoZSBmdW5jdGlvbiAod2lsbCByZXR1cm4gbnVsbCBpZiBhbWJpZ3VvdXMpXG5cdCAgICAgICAgaWYgKG5hbWVPclNpZ25hdHVyZU9yVG9waWMuaW5kZXhPZihcIihcIikgPT09IC0xKSB7XG5cdCAgICAgICAgICAgIHZhciBuYW1lXzQgPSBuYW1lT3JTaWduYXR1cmVPclRvcGljLnRyaW0oKTtcblx0ICAgICAgICAgICAgdmFyIG1hdGNoaW5nID0gT2JqZWN0LmtleXModGhpcy5ldmVudHMpLmZpbHRlcihmdW5jdGlvbiAoZikgeyByZXR1cm4gKGYuc3BsaXQoXCIoXCIgLyogZml4OikgKi8pWzBdID09PSBuYW1lXzQpOyB9KTtcblx0ICAgICAgICAgICAgaWYgKG1hdGNoaW5nLmxlbmd0aCA9PT0gMCkge1xuXHQgICAgICAgICAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcIm5vIG1hdGNoaW5nIGV2ZW50XCIsIFwibmFtZVwiLCBuYW1lXzQpO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIGVsc2UgaWYgKG1hdGNoaW5nLmxlbmd0aCA+IDEpIHtcblx0ICAgICAgICAgICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJtdWx0aXBsZSBtYXRjaGluZyBldmVudHNcIiwgXCJuYW1lXCIsIG5hbWVfNCk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgcmV0dXJuIHRoaXMuZXZlbnRzW21hdGNoaW5nWzBdXTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgLy8gTm9ybWFsaXplIHRoZSBzaWduYXR1cmUgYW5kIGxvb2t1cCB0aGUgZnVuY3Rpb25cblx0ICAgICAgICB2YXIgcmVzdWx0ID0gdGhpcy5ldmVudHNbZnJhZ21lbnRzLkV2ZW50RnJhZ21lbnQuZnJvbVN0cmluZyhuYW1lT3JTaWduYXR1cmVPclRvcGljKS5mb3JtYXQoKV07XG5cdCAgICAgICAgaWYgKCFyZXN1bHQpIHtcblx0ICAgICAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcIm5vIG1hdGNoaW5nIGV2ZW50XCIsIFwic2lnbmF0dXJlXCIsIG5hbWVPclNpZ25hdHVyZU9yVG9waWMpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICByZXR1cm4gcmVzdWx0O1xuXHQgICAgfTtcblx0ICAgIC8vIEZpbmQgYSBmdW5jdGlvbiBkZWZpbml0aW9uIGJ5IGFueSBtZWFucyBuZWNlc3NhcnkgKHVubGVzcyBpdCBpcyBhbWJpZ3VvdXMpXG5cdCAgICBJbnRlcmZhY2UucHJvdG90eXBlLmdldEVycm9yID0gZnVuY3Rpb24gKG5hbWVPclNpZ25hdHVyZU9yU2lnaGFzaCkge1xuXHQgICAgICAgIGlmICgoMCwgbGliJDEuaXNIZXhTdHJpbmcpKG5hbWVPclNpZ25hdHVyZU9yU2lnaGFzaCkpIHtcblx0ICAgICAgICAgICAgdmFyIGdldFNpZ2hhc2ggPSAoMCwgbGliJDMuZ2V0U3RhdGljKSh0aGlzLmNvbnN0cnVjdG9yLCBcImdldFNpZ2hhc2hcIik7XG5cdCAgICAgICAgICAgIGZvciAodmFyIG5hbWVfNSBpbiB0aGlzLmVycm9ycykge1xuXHQgICAgICAgICAgICAgICAgdmFyIGVycm9yID0gdGhpcy5lcnJvcnNbbmFtZV81XTtcblx0ICAgICAgICAgICAgICAgIGlmIChuYW1lT3JTaWduYXR1cmVPclNpZ2hhc2ggPT09IGdldFNpZ2hhc2goZXJyb3IpKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZXJyb3JzW25hbWVfNV07XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcIm5vIG1hdGNoaW5nIGVycm9yXCIsIFwic2lnaGFzaFwiLCBuYW1lT3JTaWduYXR1cmVPclNpZ2hhc2gpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICAvLyBJdCBpcyBhIGJhcmUgbmFtZSwgbG9vayB1cCB0aGUgZnVuY3Rpb24gKHdpbGwgcmV0dXJuIG51bGwgaWYgYW1iaWd1b3VzKVxuXHQgICAgICAgIGlmIChuYW1lT3JTaWduYXR1cmVPclNpZ2hhc2guaW5kZXhPZihcIihcIikgPT09IC0xKSB7XG5cdCAgICAgICAgICAgIHZhciBuYW1lXzYgPSBuYW1lT3JTaWduYXR1cmVPclNpZ2hhc2gudHJpbSgpO1xuXHQgICAgICAgICAgICB2YXIgbWF0Y2hpbmcgPSBPYmplY3Qua2V5cyh0aGlzLmVycm9ycykuZmlsdGVyKGZ1bmN0aW9uIChmKSB7IHJldHVybiAoZi5zcGxpdChcIihcIiAvKiBmaXg6KSAqLylbMF0gPT09IG5hbWVfNik7IH0pO1xuXHQgICAgICAgICAgICBpZiAobWF0Y2hpbmcubGVuZ3RoID09PSAwKSB7XG5cdCAgICAgICAgICAgICAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwibm8gbWF0Y2hpbmcgZXJyb3JcIiwgXCJuYW1lXCIsIG5hbWVfNik7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgZWxzZSBpZiAobWF0Y2hpbmcubGVuZ3RoID4gMSkge1xuXHQgICAgICAgICAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcIm11bHRpcGxlIG1hdGNoaW5nIGVycm9yc1wiLCBcIm5hbWVcIiwgbmFtZV82KTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICByZXR1cm4gdGhpcy5lcnJvcnNbbWF0Y2hpbmdbMF1dO1xuXHQgICAgICAgIH1cblx0ICAgICAgICAvLyBOb3JtYWxpemUgdGhlIHNpZ25hdHVyZSBhbmQgbG9va3VwIHRoZSBmdW5jdGlvblxuXHQgICAgICAgIHZhciByZXN1bHQgPSB0aGlzLmVycm9yc1tmcmFnbWVudHMuRnVuY3Rpb25GcmFnbWVudC5mcm9tU3RyaW5nKG5hbWVPclNpZ25hdHVyZU9yU2lnaGFzaCkuZm9ybWF0KCldO1xuXHQgICAgICAgIGlmICghcmVzdWx0KSB7XG5cdCAgICAgICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJubyBtYXRjaGluZyBlcnJvclwiLCBcInNpZ25hdHVyZVwiLCBuYW1lT3JTaWduYXR1cmVPclNpZ2hhc2gpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICByZXR1cm4gcmVzdWx0O1xuXHQgICAgfTtcblx0ICAgIC8vIEdldCB0aGUgc2lnaGFzaCAodGhlIGJ5dGVzNCBzZWxlY3RvcikgdXNlZCBieSBTb2xpZGl0eSB0byBpZGVudGlmeSBhIGZ1bmN0aW9uXG5cdCAgICBJbnRlcmZhY2UucHJvdG90eXBlLmdldFNpZ2hhc2ggPSBmdW5jdGlvbiAoZnJhZ21lbnQpIHtcblx0ICAgICAgICBpZiAodHlwZW9mIChmcmFnbWVudCkgPT09IFwic3RyaW5nXCIpIHtcblx0ICAgICAgICAgICAgdHJ5IHtcblx0ICAgICAgICAgICAgICAgIGZyYWdtZW50ID0gdGhpcy5nZXRGdW5jdGlvbihmcmFnbWVudCk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG5cdCAgICAgICAgICAgICAgICB0cnkge1xuXHQgICAgICAgICAgICAgICAgICAgIGZyYWdtZW50ID0gdGhpcy5nZXRFcnJvcihmcmFnbWVudCk7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICBjYXRjaCAoXykge1xuXHQgICAgICAgICAgICAgICAgICAgIHRocm93IGVycm9yO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHJldHVybiAoMCwgbGliJDMuZ2V0U3RhdGljKSh0aGlzLmNvbnN0cnVjdG9yLCBcImdldFNpZ2hhc2hcIikoZnJhZ21lbnQpO1xuXHQgICAgfTtcblx0ICAgIC8vIEdldCB0aGUgdG9waWMgKHRoZSBieXRlczMyIGhhc2gpIHVzZWQgYnkgU29saWRpdHkgdG8gaWRlbnRpZnkgYW4gZXZlbnRcblx0ICAgIEludGVyZmFjZS5wcm90b3R5cGUuZ2V0RXZlbnRUb3BpYyA9IGZ1bmN0aW9uIChldmVudEZyYWdtZW50KSB7XG5cdCAgICAgICAgaWYgKHR5cGVvZiAoZXZlbnRGcmFnbWVudCkgPT09IFwic3RyaW5nXCIpIHtcblx0ICAgICAgICAgICAgZXZlbnRGcmFnbWVudCA9IHRoaXMuZ2V0RXZlbnQoZXZlbnRGcmFnbWVudCk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHJldHVybiAoMCwgbGliJDMuZ2V0U3RhdGljKSh0aGlzLmNvbnN0cnVjdG9yLCBcImdldEV2ZW50VG9waWNcIikoZXZlbnRGcmFnbWVudCk7XG5cdCAgICB9O1xuXHQgICAgSW50ZXJmYWNlLnByb3RvdHlwZS5fZGVjb2RlUGFyYW1zID0gZnVuY3Rpb24gKHBhcmFtcywgZGF0YSkge1xuXHQgICAgICAgIHJldHVybiB0aGlzLl9hYmlDb2Rlci5kZWNvZGUocGFyYW1zLCBkYXRhKTtcblx0ICAgIH07XG5cdCAgICBJbnRlcmZhY2UucHJvdG90eXBlLl9lbmNvZGVQYXJhbXMgPSBmdW5jdGlvbiAocGFyYW1zLCB2YWx1ZXMpIHtcblx0ICAgICAgICByZXR1cm4gdGhpcy5fYWJpQ29kZXIuZW5jb2RlKHBhcmFtcywgdmFsdWVzKTtcblx0ICAgIH07XG5cdCAgICBJbnRlcmZhY2UucHJvdG90eXBlLmVuY29kZURlcGxveSA9IGZ1bmN0aW9uICh2YWx1ZXMpIHtcblx0ICAgICAgICByZXR1cm4gdGhpcy5fZW5jb2RlUGFyYW1zKHRoaXMuZGVwbG95LmlucHV0cywgdmFsdWVzIHx8IFtdKTtcblx0ICAgIH07XG5cdCAgICBJbnRlcmZhY2UucHJvdG90eXBlLmRlY29kZUVycm9yUmVzdWx0ID0gZnVuY3Rpb24gKGZyYWdtZW50LCBkYXRhKSB7XG5cdCAgICAgICAgaWYgKHR5cGVvZiAoZnJhZ21lbnQpID09PSBcInN0cmluZ1wiKSB7XG5cdCAgICAgICAgICAgIGZyYWdtZW50ID0gdGhpcy5nZXRFcnJvcihmcmFnbWVudCk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHZhciBieXRlcyA9ICgwLCBsaWIkMS5hcnJheWlmeSkoZGF0YSk7XG5cdCAgICAgICAgaWYgKCgwLCBsaWIkMS5oZXhsaWZ5KShieXRlcy5zbGljZSgwLCA0KSkgIT09IHRoaXMuZ2V0U2lnaGFzaChmcmFnbWVudCkpIHtcblx0ICAgICAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcImRhdGEgc2lnbmF0dXJlIGRvZXMgbm90IG1hdGNoIGVycm9yIFwiICsgZnJhZ21lbnQubmFtZSArIFwiLlwiLCBcImRhdGFcIiwgKDAsIGxpYiQxLmhleGxpZnkpKGJ5dGVzKSk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHJldHVybiB0aGlzLl9kZWNvZGVQYXJhbXMoZnJhZ21lbnQuaW5wdXRzLCBieXRlcy5zbGljZSg0KSk7XG5cdCAgICB9O1xuXHQgICAgSW50ZXJmYWNlLnByb3RvdHlwZS5lbmNvZGVFcnJvclJlc3VsdCA9IGZ1bmN0aW9uIChmcmFnbWVudCwgdmFsdWVzKSB7XG5cdCAgICAgICAgaWYgKHR5cGVvZiAoZnJhZ21lbnQpID09PSBcInN0cmluZ1wiKSB7XG5cdCAgICAgICAgICAgIGZyYWdtZW50ID0gdGhpcy5nZXRFcnJvcihmcmFnbWVudCk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHJldHVybiAoMCwgbGliJDEuaGV4bGlmeSkoKDAsIGxpYiQxLmNvbmNhdCkoW1xuXHQgICAgICAgICAgICB0aGlzLmdldFNpZ2hhc2goZnJhZ21lbnQpLFxuXHQgICAgICAgICAgICB0aGlzLl9lbmNvZGVQYXJhbXMoZnJhZ21lbnQuaW5wdXRzLCB2YWx1ZXMgfHwgW10pXG5cdCAgICAgICAgXSkpO1xuXHQgICAgfTtcblx0ICAgIC8vIERlY29kZSB0aGUgZGF0YSBmb3IgYSBmdW5jdGlvbiBjYWxsIChlLmcuIHR4LmRhdGEpXG5cdCAgICBJbnRlcmZhY2UucHJvdG90eXBlLmRlY29kZUZ1bmN0aW9uRGF0YSA9IGZ1bmN0aW9uIChmdW5jdGlvbkZyYWdtZW50LCBkYXRhKSB7XG5cdCAgICAgICAgaWYgKHR5cGVvZiAoZnVuY3Rpb25GcmFnbWVudCkgPT09IFwic3RyaW5nXCIpIHtcblx0ICAgICAgICAgICAgZnVuY3Rpb25GcmFnbWVudCA9IHRoaXMuZ2V0RnVuY3Rpb24oZnVuY3Rpb25GcmFnbWVudCk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHZhciBieXRlcyA9ICgwLCBsaWIkMS5hcnJheWlmeSkoZGF0YSk7XG5cdCAgICAgICAgaWYgKCgwLCBsaWIkMS5oZXhsaWZ5KShieXRlcy5zbGljZSgwLCA0KSkgIT09IHRoaXMuZ2V0U2lnaGFzaChmdW5jdGlvbkZyYWdtZW50KSkge1xuXHQgICAgICAgICAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwiZGF0YSBzaWduYXR1cmUgZG9lcyBub3QgbWF0Y2ggZnVuY3Rpb24gXCIgKyBmdW5jdGlvbkZyYWdtZW50Lm5hbWUgKyBcIi5cIiwgXCJkYXRhXCIsICgwLCBsaWIkMS5oZXhsaWZ5KShieXRlcykpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICByZXR1cm4gdGhpcy5fZGVjb2RlUGFyYW1zKGZ1bmN0aW9uRnJhZ21lbnQuaW5wdXRzLCBieXRlcy5zbGljZSg0KSk7XG5cdCAgICB9O1xuXHQgICAgLy8gRW5jb2RlIHRoZSBkYXRhIGZvciBhIGZ1bmN0aW9uIGNhbGwgKGUuZy4gdHguZGF0YSlcblx0ICAgIEludGVyZmFjZS5wcm90b3R5cGUuZW5jb2RlRnVuY3Rpb25EYXRhID0gZnVuY3Rpb24gKGZ1bmN0aW9uRnJhZ21lbnQsIHZhbHVlcykge1xuXHQgICAgICAgIGlmICh0eXBlb2YgKGZ1bmN0aW9uRnJhZ21lbnQpID09PSBcInN0cmluZ1wiKSB7XG5cdCAgICAgICAgICAgIGZ1bmN0aW9uRnJhZ21lbnQgPSB0aGlzLmdldEZ1bmN0aW9uKGZ1bmN0aW9uRnJhZ21lbnQpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICByZXR1cm4gKDAsIGxpYiQxLmhleGxpZnkpKCgwLCBsaWIkMS5jb25jYXQpKFtcblx0ICAgICAgICAgICAgdGhpcy5nZXRTaWdoYXNoKGZ1bmN0aW9uRnJhZ21lbnQpLFxuXHQgICAgICAgICAgICB0aGlzLl9lbmNvZGVQYXJhbXMoZnVuY3Rpb25GcmFnbWVudC5pbnB1dHMsIHZhbHVlcyB8fCBbXSlcblx0ICAgICAgICBdKSk7XG5cdCAgICB9O1xuXHQgICAgLy8gRGVjb2RlIHRoZSByZXN1bHQgZnJvbSBhIGZ1bmN0aW9uIGNhbGwgKGUuZy4gZnJvbSBldGhfY2FsbClcblx0ICAgIEludGVyZmFjZS5wcm90b3R5cGUuZGVjb2RlRnVuY3Rpb25SZXN1bHQgPSBmdW5jdGlvbiAoZnVuY3Rpb25GcmFnbWVudCwgZGF0YSkge1xuXHQgICAgICAgIGlmICh0eXBlb2YgKGZ1bmN0aW9uRnJhZ21lbnQpID09PSBcInN0cmluZ1wiKSB7XG5cdCAgICAgICAgICAgIGZ1bmN0aW9uRnJhZ21lbnQgPSB0aGlzLmdldEZ1bmN0aW9uKGZ1bmN0aW9uRnJhZ21lbnQpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICB2YXIgYnl0ZXMgPSAoMCwgbGliJDEuYXJyYXlpZnkpKGRhdGEpO1xuXHQgICAgICAgIHZhciByZWFzb24gPSBudWxsO1xuXHQgICAgICAgIHZhciBlcnJvckFyZ3MgPSBudWxsO1xuXHQgICAgICAgIHZhciBlcnJvck5hbWUgPSBudWxsO1xuXHQgICAgICAgIHZhciBlcnJvclNpZ25hdHVyZSA9IG51bGw7XG5cdCAgICAgICAgc3dpdGNoIChieXRlcy5sZW5ndGggJSB0aGlzLl9hYmlDb2Rlci5fZ2V0V29yZFNpemUoKSkge1xuXHQgICAgICAgICAgICBjYXNlIDA6XG5cdCAgICAgICAgICAgICAgICB0cnkge1xuXHQgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9hYmlDb2Rlci5kZWNvZGUoZnVuY3Rpb25GcmFnbWVudC5vdXRwdXRzLCBieXRlcyk7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHsgfVxuXHQgICAgICAgICAgICAgICAgYnJlYWs7XG5cdCAgICAgICAgICAgIGNhc2UgNDoge1xuXHQgICAgICAgICAgICAgICAgdmFyIHNlbGVjdG9yID0gKDAsIGxpYiQxLmhleGxpZnkpKGJ5dGVzLnNsaWNlKDAsIDQpKTtcblx0ICAgICAgICAgICAgICAgIHZhciBidWlsdGluID0gQnVpbHRpbkVycm9yc1tzZWxlY3Rvcl07XG5cdCAgICAgICAgICAgICAgICBpZiAoYnVpbHRpbikge1xuXHQgICAgICAgICAgICAgICAgICAgIGVycm9yQXJncyA9IHRoaXMuX2FiaUNvZGVyLmRlY29kZShidWlsdGluLmlucHV0cywgYnl0ZXMuc2xpY2UoNCkpO1xuXHQgICAgICAgICAgICAgICAgICAgIGVycm9yTmFtZSA9IGJ1aWx0aW4ubmFtZTtcblx0ICAgICAgICAgICAgICAgICAgICBlcnJvclNpZ25hdHVyZSA9IGJ1aWx0aW4uc2lnbmF0dXJlO1xuXHQgICAgICAgICAgICAgICAgICAgIGlmIChidWlsdGluLnJlYXNvbikge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICByZWFzb24gPSBlcnJvckFyZ3NbMF07XG5cdCAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgZWxzZSB7XG5cdCAgICAgICAgICAgICAgICAgICAgdHJ5IHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGVycm9yID0gdGhpcy5nZXRFcnJvcihzZWxlY3Rvcik7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yQXJncyA9IHRoaXMuX2FiaUNvZGVyLmRlY29kZShlcnJvci5pbnB1dHMsIGJ5dGVzLnNsaWNlKDQpKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3JOYW1lID0gZXJyb3IubmFtZTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3JTaWduYXR1cmUgPSBlcnJvci5mb3JtYXQoKTtcblx0ICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKGVycm9yKTtcblx0ICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICBicmVhaztcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH1cblx0ICAgICAgICByZXR1cm4gbG9nZ2VyLnRocm93RXJyb3IoXCJjYWxsIHJldmVydCBleGNlcHRpb25cIiwgbGliLkxvZ2dlci5lcnJvcnMuQ0FMTF9FWENFUFRJT04sIHtcblx0ICAgICAgICAgICAgbWV0aG9kOiBmdW5jdGlvbkZyYWdtZW50LmZvcm1hdCgpLFxuXHQgICAgICAgICAgICBlcnJvckFyZ3M6IGVycm9yQXJncyxcblx0ICAgICAgICAgICAgZXJyb3JOYW1lOiBlcnJvck5hbWUsXG5cdCAgICAgICAgICAgIGVycm9yU2lnbmF0dXJlOiBlcnJvclNpZ25hdHVyZSxcblx0ICAgICAgICAgICAgcmVhc29uOiByZWFzb25cblx0ICAgICAgICB9KTtcblx0ICAgIH07XG5cdCAgICAvLyBFbmNvZGUgdGhlIHJlc3VsdCBmb3IgYSBmdW5jdGlvbiBjYWxsIChlLmcuIGZvciBldGhfY2FsbClcblx0ICAgIEludGVyZmFjZS5wcm90b3R5cGUuZW5jb2RlRnVuY3Rpb25SZXN1bHQgPSBmdW5jdGlvbiAoZnVuY3Rpb25GcmFnbWVudCwgdmFsdWVzKSB7XG5cdCAgICAgICAgaWYgKHR5cGVvZiAoZnVuY3Rpb25GcmFnbWVudCkgPT09IFwic3RyaW5nXCIpIHtcblx0ICAgICAgICAgICAgZnVuY3Rpb25GcmFnbWVudCA9IHRoaXMuZ2V0RnVuY3Rpb24oZnVuY3Rpb25GcmFnbWVudCk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHJldHVybiAoMCwgbGliJDEuaGV4bGlmeSkodGhpcy5fYWJpQ29kZXIuZW5jb2RlKGZ1bmN0aW9uRnJhZ21lbnQub3V0cHV0cywgdmFsdWVzIHx8IFtdKSk7XG5cdCAgICB9O1xuXHQgICAgLy8gQ3JlYXRlIHRoZSBmaWx0ZXIgZm9yIHRoZSBldmVudCB3aXRoIHNlYXJjaCBjcml0ZXJpYSAoZS5nLiBmb3IgZXRoX2ZpbHRlckxvZylcblx0ICAgIEludGVyZmFjZS5wcm90b3R5cGUuZW5jb2RlRmlsdGVyVG9waWNzID0gZnVuY3Rpb24gKGV2ZW50RnJhZ21lbnQsIHZhbHVlcykge1xuXHQgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cdCAgICAgICAgaWYgKHR5cGVvZiAoZXZlbnRGcmFnbWVudCkgPT09IFwic3RyaW5nXCIpIHtcblx0ICAgICAgICAgICAgZXZlbnRGcmFnbWVudCA9IHRoaXMuZ2V0RXZlbnQoZXZlbnRGcmFnbWVudCk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGlmICh2YWx1ZXMubGVuZ3RoID4gZXZlbnRGcmFnbWVudC5pbnB1dHMubGVuZ3RoKSB7XG5cdCAgICAgICAgICAgIGxvZ2dlci50aHJvd0Vycm9yKFwidG9vIG1hbnkgYXJndW1lbnRzIGZvciBcIiArIGV2ZW50RnJhZ21lbnQuZm9ybWF0KCksIGxpYi5Mb2dnZXIuZXJyb3JzLlVORVhQRUNURURfQVJHVU1FTlQsIHtcblx0ICAgICAgICAgICAgICAgIGFyZ3VtZW50OiBcInZhbHVlc1wiLFxuXHQgICAgICAgICAgICAgICAgdmFsdWU6IHZhbHVlc1xuXHQgICAgICAgICAgICB9KTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgdmFyIHRvcGljcyA9IFtdO1xuXHQgICAgICAgIGlmICghZXZlbnRGcmFnbWVudC5hbm9ueW1vdXMpIHtcblx0ICAgICAgICAgICAgdG9waWNzLnB1c2godGhpcy5nZXRFdmVudFRvcGljKGV2ZW50RnJhZ21lbnQpKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgdmFyIGVuY29kZVRvcGljID0gZnVuY3Rpb24gKHBhcmFtLCB2YWx1ZSkge1xuXHQgICAgICAgICAgICBpZiAocGFyYW0udHlwZSA9PT0gXCJzdHJpbmdcIikge1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuICgwLCBsaWIkOS5pZCkodmFsdWUpO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIGVsc2UgaWYgKHBhcmFtLnR5cGUgPT09IFwiYnl0ZXNcIikge1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuICgwLCBsaWIkNC5rZWNjYWsyNTYpKCgwLCBsaWIkMS5oZXhsaWZ5KSh2YWx1ZSkpO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIC8vIENoZWNrIGFkZHJlc3NlcyBhcmUgdmFsaWRcblx0ICAgICAgICAgICAgaWYgKHBhcmFtLnR5cGUgPT09IFwiYWRkcmVzc1wiKSB7XG5cdCAgICAgICAgICAgICAgICBfdGhpcy5fYWJpQ29kZXIuZW5jb2RlKFtcImFkZHJlc3NcIl0sIFt2YWx1ZV0pO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIHJldHVybiAoMCwgbGliJDEuaGV4WmVyb1BhZCkoKDAsIGxpYiQxLmhleGxpZnkpKHZhbHVlKSwgMzIpO1xuXHQgICAgICAgIH07XG5cdCAgICAgICAgdmFsdWVzLmZvckVhY2goZnVuY3Rpb24gKHZhbHVlLCBpbmRleCkge1xuXHQgICAgICAgICAgICB2YXIgcGFyYW0gPSBldmVudEZyYWdtZW50LmlucHV0c1tpbmRleF07XG5cdCAgICAgICAgICAgIGlmICghcGFyYW0uaW5kZXhlZCkge1xuXHQgICAgICAgICAgICAgICAgaWYgKHZhbHVlICE9IG51bGwpIHtcblx0ICAgICAgICAgICAgICAgICAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwiY2Fubm90IGZpbHRlciBub24taW5kZXhlZCBwYXJhbWV0ZXJzOyBtdXN0IGJlIG51bGxcIiwgKFwiY29udHJhY3QuXCIgKyBwYXJhbS5uYW1lKSwgdmFsdWUpO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgcmV0dXJuO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIGlmICh2YWx1ZSA9PSBudWxsKSB7XG5cdCAgICAgICAgICAgICAgICB0b3BpY3MucHVzaChudWxsKTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICBlbHNlIGlmIChwYXJhbS5iYXNlVHlwZSA9PT0gXCJhcnJheVwiIHx8IHBhcmFtLmJhc2VUeXBlID09PSBcInR1cGxlXCIpIHtcblx0ICAgICAgICAgICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJmaWx0ZXJpbmcgd2l0aCB0dXBsZXMgb3IgYXJyYXlzIG5vdCBzdXBwb3J0ZWRcIiwgKFwiY29udHJhY3QuXCIgKyBwYXJhbS5uYW1lKSwgdmFsdWUpO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIGVsc2UgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG5cdCAgICAgICAgICAgICAgICB0b3BpY3MucHVzaCh2YWx1ZS5tYXAoZnVuY3Rpb24gKHZhbHVlKSB7IHJldHVybiBlbmNvZGVUb3BpYyhwYXJhbSwgdmFsdWUpOyB9KSk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgZWxzZSB7XG5cdCAgICAgICAgICAgICAgICB0b3BpY3MucHVzaChlbmNvZGVUb3BpYyhwYXJhbSwgdmFsdWUpKTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH0pO1xuXHQgICAgICAgIC8vIFRyaW0gb2ZmIHRyYWlsaW5nIG51bGxzXG5cdCAgICAgICAgd2hpbGUgKHRvcGljcy5sZW5ndGggJiYgdG9waWNzW3RvcGljcy5sZW5ndGggLSAxXSA9PT0gbnVsbCkge1xuXHQgICAgICAgICAgICB0b3BpY3MucG9wKCk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHJldHVybiB0b3BpY3M7XG5cdCAgICB9O1xuXHQgICAgSW50ZXJmYWNlLnByb3RvdHlwZS5lbmNvZGVFdmVudExvZyA9IGZ1bmN0aW9uIChldmVudEZyYWdtZW50LCB2YWx1ZXMpIHtcblx0ICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXHQgICAgICAgIGlmICh0eXBlb2YgKGV2ZW50RnJhZ21lbnQpID09PSBcInN0cmluZ1wiKSB7XG5cdCAgICAgICAgICAgIGV2ZW50RnJhZ21lbnQgPSB0aGlzLmdldEV2ZW50KGV2ZW50RnJhZ21lbnQpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICB2YXIgdG9waWNzID0gW107XG5cdCAgICAgICAgdmFyIGRhdGFUeXBlcyA9IFtdO1xuXHQgICAgICAgIHZhciBkYXRhVmFsdWVzID0gW107XG5cdCAgICAgICAgaWYgKCFldmVudEZyYWdtZW50LmFub255bW91cykge1xuXHQgICAgICAgICAgICB0b3BpY3MucHVzaCh0aGlzLmdldEV2ZW50VG9waWMoZXZlbnRGcmFnbWVudCkpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBpZiAodmFsdWVzLmxlbmd0aCAhPT0gZXZlbnRGcmFnbWVudC5pbnB1dHMubGVuZ3RoKSB7XG5cdCAgICAgICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJldmVudCBhcmd1bWVudHMvdmFsdWVzIG1pc21hdGNoXCIsIFwidmFsdWVzXCIsIHZhbHVlcyk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGV2ZW50RnJhZ21lbnQuaW5wdXRzLmZvckVhY2goZnVuY3Rpb24gKHBhcmFtLCBpbmRleCkge1xuXHQgICAgICAgICAgICB2YXIgdmFsdWUgPSB2YWx1ZXNbaW5kZXhdO1xuXHQgICAgICAgICAgICBpZiAocGFyYW0uaW5kZXhlZCkge1xuXHQgICAgICAgICAgICAgICAgaWYgKHBhcmFtLnR5cGUgPT09IFwic3RyaW5nXCIpIHtcblx0ICAgICAgICAgICAgICAgICAgICB0b3BpY3MucHVzaCgoMCwgbGliJDkuaWQpKHZhbHVlKSk7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICBlbHNlIGlmIChwYXJhbS50eXBlID09PSBcImJ5dGVzXCIpIHtcblx0ICAgICAgICAgICAgICAgICAgICB0b3BpY3MucHVzaCgoMCwgbGliJDQua2VjY2FrMjU2KSh2YWx1ZSkpO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgZWxzZSBpZiAocGFyYW0uYmFzZVR5cGUgPT09IFwidHVwbGVcIiB8fCBwYXJhbS5iYXNlVHlwZSA9PT0gXCJhcnJheVwiKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgLy8gQFRPRE9cblx0ICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJub3QgaW1wbGVtZW50ZWRcIik7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICBlbHNlIHtcblx0ICAgICAgICAgICAgICAgICAgICB0b3BpY3MucHVzaChfdGhpcy5fYWJpQ29kZXIuZW5jb2RlKFtwYXJhbS50eXBlXSwgW3ZhbHVlXSkpO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIGVsc2Uge1xuXHQgICAgICAgICAgICAgICAgZGF0YVR5cGVzLnB1c2gocGFyYW0pO1xuXHQgICAgICAgICAgICAgICAgZGF0YVZhbHVlcy5wdXNoKHZhbHVlKTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH0pO1xuXHQgICAgICAgIHJldHVybiB7XG5cdCAgICAgICAgICAgIGRhdGE6IHRoaXMuX2FiaUNvZGVyLmVuY29kZShkYXRhVHlwZXMsIGRhdGFWYWx1ZXMpLFxuXHQgICAgICAgICAgICB0b3BpY3M6IHRvcGljc1xuXHQgICAgICAgIH07XG5cdCAgICB9O1xuXHQgICAgLy8gRGVjb2RlIGEgZmlsdGVyIGZvciB0aGUgZXZlbnQgYW5kIHRoZSBzZWFyY2ggY3JpdGVyaWFcblx0ICAgIEludGVyZmFjZS5wcm90b3R5cGUuZGVjb2RlRXZlbnRMb2cgPSBmdW5jdGlvbiAoZXZlbnRGcmFnbWVudCwgZGF0YSwgdG9waWNzKSB7XG5cdCAgICAgICAgaWYgKHR5cGVvZiAoZXZlbnRGcmFnbWVudCkgPT09IFwic3RyaW5nXCIpIHtcblx0ICAgICAgICAgICAgZXZlbnRGcmFnbWVudCA9IHRoaXMuZ2V0RXZlbnQoZXZlbnRGcmFnbWVudCk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGlmICh0b3BpY3MgIT0gbnVsbCAmJiAhZXZlbnRGcmFnbWVudC5hbm9ueW1vdXMpIHtcblx0ICAgICAgICAgICAgdmFyIHRvcGljSGFzaCA9IHRoaXMuZ2V0RXZlbnRUb3BpYyhldmVudEZyYWdtZW50KTtcblx0ICAgICAgICAgICAgaWYgKCEoMCwgbGliJDEuaXNIZXhTdHJpbmcpKHRvcGljc1swXSwgMzIpIHx8IHRvcGljc1swXS50b0xvd2VyQ2FzZSgpICE9PSB0b3BpY0hhc2gpIHtcblx0ICAgICAgICAgICAgICAgIGxvZ2dlci50aHJvd0Vycm9yKFwiZnJhZ21lbnQvdG9waWMgbWlzbWF0Y2hcIiwgbGliLkxvZ2dlci5lcnJvcnMuSU5WQUxJRF9BUkdVTUVOVCwgeyBhcmd1bWVudDogXCJ0b3BpY3NbMF1cIiwgZXhwZWN0ZWQ6IHRvcGljSGFzaCwgdmFsdWU6IHRvcGljc1swXSB9KTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB0b3BpY3MgPSB0b3BpY3Muc2xpY2UoMSk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHZhciBpbmRleGVkID0gW107XG5cdCAgICAgICAgdmFyIG5vbkluZGV4ZWQgPSBbXTtcblx0ICAgICAgICB2YXIgZHluYW1pYyA9IFtdO1xuXHQgICAgICAgIGV2ZW50RnJhZ21lbnQuaW5wdXRzLmZvckVhY2goZnVuY3Rpb24gKHBhcmFtLCBpbmRleCkge1xuXHQgICAgICAgICAgICBpZiAocGFyYW0uaW5kZXhlZCkge1xuXHQgICAgICAgICAgICAgICAgaWYgKHBhcmFtLnR5cGUgPT09IFwic3RyaW5nXCIgfHwgcGFyYW0udHlwZSA9PT0gXCJieXRlc1wiIHx8IHBhcmFtLmJhc2VUeXBlID09PSBcInR1cGxlXCIgfHwgcGFyYW0uYmFzZVR5cGUgPT09IFwiYXJyYXlcIikge1xuXHQgICAgICAgICAgICAgICAgICAgIGluZGV4ZWQucHVzaChmcmFnbWVudHMuUGFyYW1UeXBlLmZyb21PYmplY3QoeyB0eXBlOiBcImJ5dGVzMzJcIiwgbmFtZTogcGFyYW0ubmFtZSB9KSk7XG5cdCAgICAgICAgICAgICAgICAgICAgZHluYW1pYy5wdXNoKHRydWUpO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgZWxzZSB7XG5cdCAgICAgICAgICAgICAgICAgICAgaW5kZXhlZC5wdXNoKHBhcmFtKTtcblx0ICAgICAgICAgICAgICAgICAgICBkeW5hbWljLnB1c2goZmFsc2UpO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIGVsc2Uge1xuXHQgICAgICAgICAgICAgICAgbm9uSW5kZXhlZC5wdXNoKHBhcmFtKTtcblx0ICAgICAgICAgICAgICAgIGR5bmFtaWMucHVzaChmYWxzZSk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9KTtcblx0ICAgICAgICB2YXIgcmVzdWx0SW5kZXhlZCA9ICh0b3BpY3MgIT0gbnVsbCkgPyB0aGlzLl9hYmlDb2Rlci5kZWNvZGUoaW5kZXhlZCwgKDAsIGxpYiQxLmNvbmNhdCkodG9waWNzKSkgOiBudWxsO1xuXHQgICAgICAgIHZhciByZXN1bHROb25JbmRleGVkID0gdGhpcy5fYWJpQ29kZXIuZGVjb2RlKG5vbkluZGV4ZWQsIGRhdGEsIHRydWUpO1xuXHQgICAgICAgIHZhciByZXN1bHQgPSBbXTtcblx0ICAgICAgICB2YXIgbm9uSW5kZXhlZEluZGV4ID0gMCwgaW5kZXhlZEluZGV4ID0gMDtcblx0ICAgICAgICBldmVudEZyYWdtZW50LmlucHV0cy5mb3JFYWNoKGZ1bmN0aW9uIChwYXJhbSwgaW5kZXgpIHtcblx0ICAgICAgICAgICAgaWYgKHBhcmFtLmluZGV4ZWQpIHtcblx0ICAgICAgICAgICAgICAgIGlmIChyZXN1bHRJbmRleGVkID09IG51bGwpIHtcblx0ICAgICAgICAgICAgICAgICAgICByZXN1bHRbaW5kZXhdID0gbmV3IEluZGV4ZWQoeyBfaXNJbmRleGVkOiB0cnVlLCBoYXNoOiBudWxsIH0pO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgZWxzZSBpZiAoZHluYW1pY1tpbmRleF0pIHtcblx0ICAgICAgICAgICAgICAgICAgICByZXN1bHRbaW5kZXhdID0gbmV3IEluZGV4ZWQoeyBfaXNJbmRleGVkOiB0cnVlLCBoYXNoOiByZXN1bHRJbmRleGVkW2luZGV4ZWRJbmRleCsrXSB9KTtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgIGVsc2Uge1xuXHQgICAgICAgICAgICAgICAgICAgIHRyeSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdFtpbmRleF0gPSByZXN1bHRJbmRleGVkW2luZGV4ZWRJbmRleCsrXTtcblx0ICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdFtpbmRleF0gPSBlcnJvcjtcblx0ICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgZWxzZSB7XG5cdCAgICAgICAgICAgICAgICB0cnkge1xuXHQgICAgICAgICAgICAgICAgICAgIHJlc3VsdFtpbmRleF0gPSByZXN1bHROb25JbmRleGVkW25vbkluZGV4ZWRJbmRleCsrXTtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuXHQgICAgICAgICAgICAgICAgICAgIHJlc3VsdFtpbmRleF0gPSBlcnJvcjtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAvLyBBZGQgdGhlIGtleXdvcmQgYXJndW1lbnQgaWYgbmFtZWQgYW5kIHNhZmVcblx0ICAgICAgICAgICAgaWYgKHBhcmFtLm5hbWUgJiYgcmVzdWx0W3BhcmFtLm5hbWVdID09IG51bGwpIHtcblx0ICAgICAgICAgICAgICAgIHZhciB2YWx1ZV8xID0gcmVzdWx0W2luZGV4XTtcblx0ICAgICAgICAgICAgICAgIC8vIE1ha2UgZXJyb3IgbmFtZWQgdmFsdWVzIHRocm93IG9uIGFjY2Vzc1xuXHQgICAgICAgICAgICAgICAgaWYgKHZhbHVlXzEgaW5zdGFuY2VvZiBFcnJvcikge1xuXHQgICAgICAgICAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShyZXN1bHQsIHBhcmFtLm5hbWUsIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcblx0ICAgICAgICAgICAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHRocm93IHdyYXBBY2Nlc3NFcnJvcihcInByb3BlcnR5IFwiICsgSlNPTi5zdHJpbmdpZnkocGFyYW0ubmFtZSksIHZhbHVlXzEpOyB9XG5cdCAgICAgICAgICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICBlbHNlIHtcblx0ICAgICAgICAgICAgICAgICAgICByZXN1bHRbcGFyYW0ubmFtZV0gPSB2YWx1ZV8xO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfSk7XG5cdCAgICAgICAgdmFyIF9sb29wXzEgPSBmdW5jdGlvbiAoaSkge1xuXHQgICAgICAgICAgICB2YXIgdmFsdWUgPSByZXN1bHRbaV07XG5cdCAgICAgICAgICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIEVycm9yKSB7XG5cdCAgICAgICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkocmVzdWx0LCBpLCB7XG5cdCAgICAgICAgICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcblx0ICAgICAgICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgdGhyb3cgd3JhcEFjY2Vzc0Vycm9yKFwiaW5kZXggXCIgKyBpLCB2YWx1ZSk7IH1cblx0ICAgICAgICAgICAgICAgIH0pO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfTtcblx0ICAgICAgICAvLyBNYWtlIGFsbCBlcnJvciBpbmRleGVkIHZhbHVlcyB0aHJvdyBvbiBhY2Nlc3Ncblx0ICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHJlc3VsdC5sZW5ndGg7IGkrKykge1xuXHQgICAgICAgICAgICBfbG9vcF8xKGkpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICByZXR1cm4gT2JqZWN0LmZyZWV6ZShyZXN1bHQpO1xuXHQgICAgfTtcblx0ICAgIC8vIEdpdmVuIGEgdHJhbnNhY3Rpb24sIGZpbmQgdGhlIG1hdGNoaW5nIGZ1bmN0aW9uIGZyYWdtZW50IChpZiBhbnkpIGFuZFxuXHQgICAgLy8gZGV0ZXJtaW5lIGFsbCBpdHMgcHJvcGVydGllcyBhbmQgY2FsbCBwYXJhbWV0ZXJzXG5cdCAgICBJbnRlcmZhY2UucHJvdG90eXBlLnBhcnNlVHJhbnNhY3Rpb24gPSBmdW5jdGlvbiAodHgpIHtcblx0ICAgICAgICB2YXIgZnJhZ21lbnQgPSB0aGlzLmdldEZ1bmN0aW9uKHR4LmRhdGEuc3Vic3RyaW5nKDAsIDEwKS50b0xvd2VyQ2FzZSgpKTtcblx0ICAgICAgICBpZiAoIWZyYWdtZW50KSB7XG5cdCAgICAgICAgICAgIHJldHVybiBudWxsO1xuXHQgICAgICAgIH1cblx0ICAgICAgICByZXR1cm4gbmV3IFRyYW5zYWN0aW9uRGVzY3JpcHRpb24oe1xuXHQgICAgICAgICAgICBhcmdzOiB0aGlzLl9hYmlDb2Rlci5kZWNvZGUoZnJhZ21lbnQuaW5wdXRzLCBcIjB4XCIgKyB0eC5kYXRhLnN1YnN0cmluZygxMCkpLFxuXHQgICAgICAgICAgICBmdW5jdGlvbkZyYWdtZW50OiBmcmFnbWVudCxcblx0ICAgICAgICAgICAgbmFtZTogZnJhZ21lbnQubmFtZSxcblx0ICAgICAgICAgICAgc2lnbmF0dXJlOiBmcmFnbWVudC5mb3JtYXQoKSxcblx0ICAgICAgICAgICAgc2lnaGFzaDogdGhpcy5nZXRTaWdoYXNoKGZyYWdtZW50KSxcblx0ICAgICAgICAgICAgdmFsdWU6IGxpYiQyLkJpZ051bWJlci5mcm9tKHR4LnZhbHVlIHx8IFwiMFwiKSxcblx0ICAgICAgICB9KTtcblx0ICAgIH07XG5cdCAgICAvLyBAVE9ET1xuXHQgICAgLy9wYXJzZUNhbGxSZXN1bHQoZGF0YTogQnl0ZXNMaWtlKTogPz9cblx0ICAgIC8vIEdpdmVuIGFuIGV2ZW50IGxvZywgZmluZCB0aGUgbWF0Y2hpbmcgZXZlbnQgZnJhZ21lbnQgKGlmIGFueSkgYW5kXG5cdCAgICAvLyBkZXRlcm1pbmUgYWxsIGl0cyBwcm9wZXJ0aWVzIGFuZCB2YWx1ZXNcblx0ICAgIEludGVyZmFjZS5wcm90b3R5cGUucGFyc2VMb2cgPSBmdW5jdGlvbiAobG9nKSB7XG5cdCAgICAgICAgdmFyIGZyYWdtZW50ID0gdGhpcy5nZXRFdmVudChsb2cudG9waWNzWzBdKTtcblx0ICAgICAgICBpZiAoIWZyYWdtZW50IHx8IGZyYWdtZW50LmFub255bW91cykge1xuXHQgICAgICAgICAgICByZXR1cm4gbnVsbDtcblx0ICAgICAgICB9XG5cdCAgICAgICAgLy8gQFRPRE86IElmIGFub255bW91cywgYW5kIHRoZSBvbmx5IG1ldGhvZCwgYW5kIHRoZSBpbnB1dCBjb3VudCBtYXRjaGVzLCBzaG91bGQgd2UgcGFyc2U/XG5cdCAgICAgICAgLy8gICAgICAgIFByb2JhYmx5IG5vdCwgYmVjYXVzZSBqdXN0IGJlY2F1c2UgaXQgaXMgdGhlIG9ubHkgZXZlbnQgaW4gdGhlIEFCSSBkb2VzXG5cdCAgICAgICAgLy8gICAgICAgIG5vdCBtZWFuIHdlIGhhdmUgdGhlIGZ1bGwgQUJJOyBtYXliZSBqdXN0IGEgZnJhZ21lbnQ/XG5cdCAgICAgICAgcmV0dXJuIG5ldyBMb2dEZXNjcmlwdGlvbih7XG5cdCAgICAgICAgICAgIGV2ZW50RnJhZ21lbnQ6IGZyYWdtZW50LFxuXHQgICAgICAgICAgICBuYW1lOiBmcmFnbWVudC5uYW1lLFxuXHQgICAgICAgICAgICBzaWduYXR1cmU6IGZyYWdtZW50LmZvcm1hdCgpLFxuXHQgICAgICAgICAgICB0b3BpYzogdGhpcy5nZXRFdmVudFRvcGljKGZyYWdtZW50KSxcblx0ICAgICAgICAgICAgYXJnczogdGhpcy5kZWNvZGVFdmVudExvZyhmcmFnbWVudCwgbG9nLmRhdGEsIGxvZy50b3BpY3MpXG5cdCAgICAgICAgfSk7XG5cdCAgICB9O1xuXHQgICAgSW50ZXJmYWNlLnByb3RvdHlwZS5wYXJzZUVycm9yID0gZnVuY3Rpb24gKGRhdGEpIHtcblx0ICAgICAgICB2YXIgaGV4RGF0YSA9ICgwLCBsaWIkMS5oZXhsaWZ5KShkYXRhKTtcblx0ICAgICAgICB2YXIgZnJhZ21lbnQgPSB0aGlzLmdldEVycm9yKGhleERhdGEuc3Vic3RyaW5nKDAsIDEwKS50b0xvd2VyQ2FzZSgpKTtcblx0ICAgICAgICBpZiAoIWZyYWdtZW50KSB7XG5cdCAgICAgICAgICAgIHJldHVybiBudWxsO1xuXHQgICAgICAgIH1cblx0ICAgICAgICByZXR1cm4gbmV3IEVycm9yRGVzY3JpcHRpb24oe1xuXHQgICAgICAgICAgICBhcmdzOiB0aGlzLl9hYmlDb2Rlci5kZWNvZGUoZnJhZ21lbnQuaW5wdXRzLCBcIjB4XCIgKyBoZXhEYXRhLnN1YnN0cmluZygxMCkpLFxuXHQgICAgICAgICAgICBlcnJvckZyYWdtZW50OiBmcmFnbWVudCxcblx0ICAgICAgICAgICAgbmFtZTogZnJhZ21lbnQubmFtZSxcblx0ICAgICAgICAgICAgc2lnbmF0dXJlOiBmcmFnbWVudC5mb3JtYXQoKSxcblx0ICAgICAgICAgICAgc2lnaGFzaDogdGhpcy5nZXRTaWdoYXNoKGZyYWdtZW50KSxcblx0ICAgICAgICB9KTtcblx0ICAgIH07XG5cdCAgICAvKlxuXHQgICAgc3RhdGljIGZyb20odmFsdWU6IEFycmF5PEZyYWdtZW50IHwgc3RyaW5nIHwgSnNvbkFiaT4gfCBzdHJpbmcgfCBJbnRlcmZhY2UpIHtcblx0ICAgICAgICBpZiAoSW50ZXJmYWNlLmlzSW50ZXJmYWNlKHZhbHVlKSkge1xuXHQgICAgICAgICAgICByZXR1cm4gdmFsdWU7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGlmICh0eXBlb2YodmFsdWUpID09PSBcInN0cmluZ1wiKSB7XG5cdCAgICAgICAgICAgIHJldHVybiBuZXcgSW50ZXJmYWNlKEpTT04ucGFyc2UodmFsdWUpKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgcmV0dXJuIG5ldyBJbnRlcmZhY2UodmFsdWUpO1xuXHQgICAgfVxuXHQgICAgKi9cblx0ICAgIEludGVyZmFjZS5pc0ludGVyZmFjZSA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuXHQgICAgICAgIHJldHVybiAhISh2YWx1ZSAmJiB2YWx1ZS5faXNJbnRlcmZhY2UpO1xuXHQgICAgfTtcblx0ICAgIHJldHVybiBJbnRlcmZhY2U7XG5cdH0oKSk7XG5cdGV4cG9ydHMuSW50ZXJmYWNlID0gSW50ZXJmYWNlO1xuXG5cdH0pO1xuXG5cdHZhciBfaW50ZXJmYWNlJDEgPSAvKkBfX1BVUkVfXyovZ2V0RGVmYXVsdEV4cG9ydEZyb21DanMoX2ludGVyZmFjZSk7XG5cblx0dmFyIGxpYiRhID0gY3JlYXRlQ29tbW9uanNNb2R1bGUoZnVuY3Rpb24gKG1vZHVsZSwgZXhwb3J0cykge1xuXHRcInVzZSBzdHJpY3RcIjtcblx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuXHRleHBvcnRzLlRyYW5zYWN0aW9uRGVzY3JpcHRpb24gPSBleHBvcnRzLkxvZ0Rlc2NyaXB0aW9uID0gZXhwb3J0cy5jaGVja1Jlc3VsdEVycm9ycyA9IGV4cG9ydHMuSW5kZXhlZCA9IGV4cG9ydHMuSW50ZXJmYWNlID0gZXhwb3J0cy5kZWZhdWx0QWJpQ29kZXIgPSBleHBvcnRzLkFiaUNvZGVyID0gZXhwb3J0cy5Gb3JtYXRUeXBlcyA9IGV4cG9ydHMuUGFyYW1UeXBlID0gZXhwb3J0cy5GdW5jdGlvbkZyYWdtZW50ID0gZXhwb3J0cy5GcmFnbWVudCA9IGV4cG9ydHMuRXZlbnRGcmFnbWVudCA9IGV4cG9ydHMuRXJyb3JGcmFnbWVudCA9IGV4cG9ydHMuQ29uc3RydWN0b3JGcmFnbWVudCA9IHZvaWQgMDtcblxuXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJDb25zdHJ1Y3RvckZyYWdtZW50XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBmcmFnbWVudHMuQ29uc3RydWN0b3JGcmFnbWVudDsgfSB9KTtcblx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiRXJyb3JGcmFnbWVudFwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gZnJhZ21lbnRzLkVycm9yRnJhZ21lbnQ7IH0gfSk7XG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkV2ZW50RnJhZ21lbnRcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGZyYWdtZW50cy5FdmVudEZyYWdtZW50OyB9IH0pO1xuXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJGb3JtYXRUeXBlc1wiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gZnJhZ21lbnRzLkZvcm1hdFR5cGVzOyB9IH0pO1xuXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJGcmFnbWVudFwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gZnJhZ21lbnRzLkZyYWdtZW50OyB9IH0pO1xuXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJGdW5jdGlvbkZyYWdtZW50XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBmcmFnbWVudHMuRnVuY3Rpb25GcmFnbWVudDsgfSB9KTtcblx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiUGFyYW1UeXBlXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBmcmFnbWVudHMuUGFyYW1UeXBlOyB9IH0pO1xuXG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkFiaUNvZGVyXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBhYmlDb2Rlci5BYmlDb2RlcjsgfSB9KTtcblx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiZGVmYXVsdEFiaUNvZGVyXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBhYmlDb2Rlci5kZWZhdWx0QWJpQ29kZXI7IH0gfSk7XG5cblx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiY2hlY2tSZXN1bHRFcnJvcnNcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIF9pbnRlcmZhY2UuY2hlY2tSZXN1bHRFcnJvcnM7IH0gfSk7XG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkluZGV4ZWRcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIF9pbnRlcmZhY2UuSW5kZXhlZDsgfSB9KTtcblx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiSW50ZXJmYWNlXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBfaW50ZXJmYWNlLkludGVyZmFjZTsgfSB9KTtcblx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiTG9nRGVzY3JpcHRpb25cIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIF9pbnRlcmZhY2UuTG9nRGVzY3JpcHRpb247IH0gfSk7XG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlRyYW5zYWN0aW9uRGVzY3JpcHRpb25cIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIF9pbnRlcmZhY2UuVHJhbnNhY3Rpb25EZXNjcmlwdGlvbjsgfSB9KTtcblxuXHR9KTtcblxuXHR2YXIgaW5kZXgkYSA9IC8qQF9fUFVSRV9fKi9nZXREZWZhdWx0RXhwb3J0RnJvbUNqcyhsaWIkYSk7XG5cblx0dmFyIF92ZXJzaW9uJGkgPSBjcmVhdGVDb21tb25qc01vZHVsZShmdW5jdGlvbiAobW9kdWxlLCBleHBvcnRzKSB7XG5cdFwidXNlIHN0cmljdFwiO1xuXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5cdGV4cG9ydHMudmVyc2lvbiA9IHZvaWQgMDtcblx0ZXhwb3J0cy52ZXJzaW9uID0gXCJhYnN0cmFjdC1wcm92aWRlci81LjUuMVwiO1xuXG5cdH0pO1xuXG5cdHZhciBfdmVyc2lvbiRqID0gLypAX19QVVJFX18qL2dldERlZmF1bHRFeHBvcnRGcm9tQ2pzKF92ZXJzaW9uJGkpO1xuXG5cdHZhciBsaWIkYiA9IGNyZWF0ZUNvbW1vbmpzTW9kdWxlKGZ1bmN0aW9uIChtb2R1bGUsIGV4cG9ydHMpIHtcblx0XCJ1c2Ugc3RyaWN0XCI7XG5cdHZhciBfX2V4dGVuZHMgPSAoY29tbW9uanNHbG9iYWwgJiYgY29tbW9uanNHbG9iYWwuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuXHQgICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBmdW5jdGlvbiAoZCwgYikge1xuXHQgICAgICAgIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcblx0ICAgICAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuXHQgICAgICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoYiwgcCkpIGRbcF0gPSBiW3BdOyB9O1xuXHQgICAgICAgIHJldHVybiBleHRlbmRTdGF0aWNzKGQsIGIpO1xuXHQgICAgfTtcblx0ICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuXHQgICAgICAgIGlmICh0eXBlb2YgYiAhPT0gXCJmdW5jdGlvblwiICYmIGIgIT09IG51bGwpXG5cdCAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDbGFzcyBleHRlbmRzIHZhbHVlIFwiICsgU3RyaW5nKGIpICsgXCIgaXMgbm90IGEgY29uc3RydWN0b3Igb3IgbnVsbFwiKTtcblx0ICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuXHQgICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuXHQgICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcblx0ICAgIH07XG5cdH0pKCk7XG5cdHZhciBfX2F3YWl0ZXIgPSAoY29tbW9uanNHbG9iYWwgJiYgY29tbW9uanNHbG9iYWwuX19hd2FpdGVyKSB8fCBmdW5jdGlvbiAodGhpc0FyZywgX2FyZ3VtZW50cywgUCwgZ2VuZXJhdG9yKSB7XG5cdCAgICBmdW5jdGlvbiBhZG9wdCh2YWx1ZSkgeyByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBQID8gdmFsdWUgOiBuZXcgUChmdW5jdGlvbiAocmVzb2x2ZSkgeyByZXNvbHZlKHZhbHVlKTsgfSk7IH1cblx0ICAgIHJldHVybiBuZXcgKFAgfHwgKFAgPSBQcm9taXNlKSkoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuXHQgICAgICAgIGZ1bmN0aW9uIGZ1bGZpbGxlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvci5uZXh0KHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cblx0ICAgICAgICBmdW5jdGlvbiByZWplY3RlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvcltcInRocm93XCJdKHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cblx0ICAgICAgICBmdW5jdGlvbiBzdGVwKHJlc3VsdCkgeyByZXN1bHQuZG9uZSA/IHJlc29sdmUocmVzdWx0LnZhbHVlKSA6IGFkb3B0KHJlc3VsdC52YWx1ZSkudGhlbihmdWxmaWxsZWQsIHJlamVjdGVkKTsgfVxuXHQgICAgICAgIHN0ZXAoKGdlbmVyYXRvciA9IGdlbmVyYXRvci5hcHBseSh0aGlzQXJnLCBfYXJndW1lbnRzIHx8IFtdKSkubmV4dCgpKTtcblx0ICAgIH0pO1xuXHR9O1xuXHR2YXIgX19nZW5lcmF0b3IgPSAoY29tbW9uanNHbG9iYWwgJiYgY29tbW9uanNHbG9iYWwuX19nZW5lcmF0b3IpIHx8IGZ1bmN0aW9uICh0aGlzQXJnLCBib2R5KSB7XG5cdCAgICB2YXIgXyA9IHsgbGFiZWw6IDAsIHNlbnQ6IGZ1bmN0aW9uKCkgeyBpZiAodFswXSAmIDEpIHRocm93IHRbMV07IHJldHVybiB0WzFdOyB9LCB0cnlzOiBbXSwgb3BzOiBbXSB9LCBmLCB5LCB0LCBnO1xuXHQgICAgcmV0dXJuIGcgPSB7IG5leHQ6IHZlcmIoMCksIFwidGhyb3dcIjogdmVyYigxKSwgXCJyZXR1cm5cIjogdmVyYigyKSB9LCB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgKGdbU3ltYm9sLml0ZXJhdG9yXSA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpczsgfSksIGc7XG5cdCAgICBmdW5jdGlvbiB2ZXJiKG4pIHsgcmV0dXJuIGZ1bmN0aW9uICh2KSB7IHJldHVybiBzdGVwKFtuLCB2XSk7IH07IH1cblx0ICAgIGZ1bmN0aW9uIHN0ZXAob3ApIHtcblx0ICAgICAgICBpZiAoZikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkdlbmVyYXRvciBpcyBhbHJlYWR5IGV4ZWN1dGluZy5cIik7XG5cdCAgICAgICAgd2hpbGUgKF8pIHRyeSB7XG5cdCAgICAgICAgICAgIGlmIChmID0gMSwgeSAmJiAodCA9IG9wWzBdICYgMiA/IHlbXCJyZXR1cm5cIl0gOiBvcFswXSA/IHlbXCJ0aHJvd1wiXSB8fCAoKHQgPSB5W1wicmV0dXJuXCJdKSAmJiB0LmNhbGwoeSksIDApIDogeS5uZXh0KSAmJiAhKHQgPSB0LmNhbGwoeSwgb3BbMV0pKS5kb25lKSByZXR1cm4gdDtcblx0ICAgICAgICAgICAgaWYgKHkgPSAwLCB0KSBvcCA9IFtvcFswXSAmIDIsIHQudmFsdWVdO1xuXHQgICAgICAgICAgICBzd2l0Y2ggKG9wWzBdKSB7XG5cdCAgICAgICAgICAgICAgICBjYXNlIDA6IGNhc2UgMTogdCA9IG9wOyBicmVhaztcblx0ICAgICAgICAgICAgICAgIGNhc2UgNDogXy5sYWJlbCsrOyByZXR1cm4geyB2YWx1ZTogb3BbMV0sIGRvbmU6IGZhbHNlIH07XG5cdCAgICAgICAgICAgICAgICBjYXNlIDU6IF8ubGFiZWwrKzsgeSA9IG9wWzFdOyBvcCA9IFswXTsgY29udGludWU7XG5cdCAgICAgICAgICAgICAgICBjYXNlIDc6IG9wID0gXy5vcHMucG9wKCk7IF8udHJ5cy5wb3AoKTsgY29udGludWU7XG5cdCAgICAgICAgICAgICAgICBkZWZhdWx0OlxuXHQgICAgICAgICAgICAgICAgICAgIGlmICghKHQgPSBfLnRyeXMsIHQgPSB0Lmxlbmd0aCA+IDAgJiYgdFt0Lmxlbmd0aCAtIDFdKSAmJiAob3BbMF0gPT09IDYgfHwgb3BbMF0gPT09IDIpKSB7IF8gPSAwOyBjb250aW51ZTsgfVxuXHQgICAgICAgICAgICAgICAgICAgIGlmIChvcFswXSA9PT0gMyAmJiAoIXQgfHwgKG9wWzFdID4gdFswXSAmJiBvcFsxXSA8IHRbM10pKSkgeyBfLmxhYmVsID0gb3BbMV07IGJyZWFrOyB9XG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKG9wWzBdID09PSA2ICYmIF8ubGFiZWwgPCB0WzFdKSB7IF8ubGFiZWwgPSB0WzFdOyB0ID0gb3A7IGJyZWFrOyB9XG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKHQgJiYgXy5sYWJlbCA8IHRbMl0pIHsgXy5sYWJlbCA9IHRbMl07IF8ub3BzLnB1c2gob3ApOyBicmVhazsgfVxuXHQgICAgICAgICAgICAgICAgICAgIGlmICh0WzJdKSBfLm9wcy5wb3AoKTtcblx0ICAgICAgICAgICAgICAgICAgICBfLnRyeXMucG9wKCk7IGNvbnRpbnVlO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIG9wID0gYm9keS5jYWxsKHRoaXNBcmcsIF8pO1xuXHQgICAgICAgIH0gY2F0Y2ggKGUpIHsgb3AgPSBbNiwgZV07IHkgPSAwOyB9IGZpbmFsbHkgeyBmID0gdCA9IDA7IH1cblx0ICAgICAgICBpZiAob3BbMF0gJiA1KSB0aHJvdyBvcFsxXTsgcmV0dXJuIHsgdmFsdWU6IG9wWzBdID8gb3BbMV0gOiB2b2lkIDAsIGRvbmU6IHRydWUgfTtcblx0ICAgIH1cblx0fTtcblx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuXHRleHBvcnRzLlByb3ZpZGVyID0gZXhwb3J0cy5UcmFuc2FjdGlvbk9yZGVyRm9ya0V2ZW50ID0gZXhwb3J0cy5UcmFuc2FjdGlvbkZvcmtFdmVudCA9IGV4cG9ydHMuQmxvY2tGb3JrRXZlbnQgPSBleHBvcnRzLkZvcmtFdmVudCA9IHZvaWQgMDtcblxuXG5cblxuXG5cdHZhciBsb2dnZXIgPSBuZXcgbGliLkxvZ2dlcihfdmVyc2lvbiRpLnZlcnNpb24pO1xuXHQ7XG5cdDtcblx0Ly9leHBvcnQgdHlwZSBDYWxsVHJhbnNhY3Rpb25hYmxlID0ge1xuXHQvLyAgICBjYWxsKHRyYW5zYWN0aW9uOiBUcmFuc2FjdGlvblJlcXVlc3QpOiBQcm9taXNlPFRyYW5zYWN0aW9uUmVzcG9uc2U+O1xuXHQvL307XG5cdHZhciBGb3JrRXZlbnQgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG5cdCAgICBfX2V4dGVuZHMoRm9ya0V2ZW50LCBfc3VwZXIpO1xuXHQgICAgZnVuY3Rpb24gRm9ya0V2ZW50KCkge1xuXHQgICAgICAgIHJldHVybiBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcblx0ICAgIH1cblx0ICAgIEZvcmtFdmVudC5pc0ZvcmtFdmVudCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuXHQgICAgICAgIHJldHVybiAhISh2YWx1ZSAmJiB2YWx1ZS5faXNGb3JrRXZlbnQpO1xuXHQgICAgfTtcblx0ICAgIHJldHVybiBGb3JrRXZlbnQ7XG5cdH0obGliJDMuRGVzY3JpcHRpb24pKTtcblx0ZXhwb3J0cy5Gb3JrRXZlbnQgPSBGb3JrRXZlbnQ7XG5cdHZhciBCbG9ja0ZvcmtFdmVudCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcblx0ICAgIF9fZXh0ZW5kcyhCbG9ja0ZvcmtFdmVudCwgX3N1cGVyKTtcblx0ICAgIGZ1bmN0aW9uIEJsb2NrRm9ya0V2ZW50KGJsb2NrSGFzaCwgZXhwaXJ5KSB7XG5cdCAgICAgICAgdmFyIF90aGlzID0gdGhpcztcblx0ICAgICAgICBpZiAoISgwLCBsaWIkMS5pc0hleFN0cmluZykoYmxvY2tIYXNoLCAzMikpIHtcblx0ICAgICAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcImludmFsaWQgYmxvY2tIYXNoXCIsIFwiYmxvY2tIYXNoXCIsIGJsb2NrSGFzaCk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywge1xuXHQgICAgICAgICAgICBfaXNGb3JrRXZlbnQ6IHRydWUsXG5cdCAgICAgICAgICAgIF9pc0Jsb2NrRm9ya0V2ZW50OiB0cnVlLFxuXHQgICAgICAgICAgICBleHBpcnk6IChleHBpcnkgfHwgMCksXG5cdCAgICAgICAgICAgIGJsb2NrSGFzaDogYmxvY2tIYXNoXG5cdCAgICAgICAgfSkgfHwgdGhpcztcblx0ICAgICAgICByZXR1cm4gX3RoaXM7XG5cdCAgICB9XG5cdCAgICByZXR1cm4gQmxvY2tGb3JrRXZlbnQ7XG5cdH0oRm9ya0V2ZW50KSk7XG5cdGV4cG9ydHMuQmxvY2tGb3JrRXZlbnQgPSBCbG9ja0ZvcmtFdmVudDtcblx0dmFyIFRyYW5zYWN0aW9uRm9ya0V2ZW50ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuXHQgICAgX19leHRlbmRzKFRyYW5zYWN0aW9uRm9ya0V2ZW50LCBfc3VwZXIpO1xuXHQgICAgZnVuY3Rpb24gVHJhbnNhY3Rpb25Gb3JrRXZlbnQoaGFzaCwgZXhwaXJ5KSB7XG5cdCAgICAgICAgdmFyIF90aGlzID0gdGhpcztcblx0ICAgICAgICBpZiAoISgwLCBsaWIkMS5pc0hleFN0cmluZykoaGFzaCwgMzIpKSB7XG5cdCAgICAgICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJpbnZhbGlkIHRyYW5zYWN0aW9uIGhhc2hcIiwgXCJoYXNoXCIsIGhhc2gpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIHtcblx0ICAgICAgICAgICAgX2lzRm9ya0V2ZW50OiB0cnVlLFxuXHQgICAgICAgICAgICBfaXNUcmFuc2FjdGlvbkZvcmtFdmVudDogdHJ1ZSxcblx0ICAgICAgICAgICAgZXhwaXJ5OiAoZXhwaXJ5IHx8IDApLFxuXHQgICAgICAgICAgICBoYXNoOiBoYXNoXG5cdCAgICAgICAgfSkgfHwgdGhpcztcblx0ICAgICAgICByZXR1cm4gX3RoaXM7XG5cdCAgICB9XG5cdCAgICByZXR1cm4gVHJhbnNhY3Rpb25Gb3JrRXZlbnQ7XG5cdH0oRm9ya0V2ZW50KSk7XG5cdGV4cG9ydHMuVHJhbnNhY3Rpb25Gb3JrRXZlbnQgPSBUcmFuc2FjdGlvbkZvcmtFdmVudDtcblx0dmFyIFRyYW5zYWN0aW9uT3JkZXJGb3JrRXZlbnQgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG5cdCAgICBfX2V4dGVuZHMoVHJhbnNhY3Rpb25PcmRlckZvcmtFdmVudCwgX3N1cGVyKTtcblx0ICAgIGZ1bmN0aW9uIFRyYW5zYWN0aW9uT3JkZXJGb3JrRXZlbnQoYmVmb3JlSGFzaCwgYWZ0ZXJIYXNoLCBleHBpcnkpIHtcblx0ICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXHQgICAgICAgIGlmICghKDAsIGxpYiQxLmlzSGV4U3RyaW5nKShiZWZvcmVIYXNoLCAzMikpIHtcblx0ICAgICAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcImludmFsaWQgdHJhbnNhY3Rpb24gaGFzaFwiLCBcImJlZm9yZUhhc2hcIiwgYmVmb3JlSGFzaCk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGlmICghKDAsIGxpYiQxLmlzSGV4U3RyaW5nKShhZnRlckhhc2gsIDMyKSkge1xuXHQgICAgICAgICAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwiaW52YWxpZCB0cmFuc2FjdGlvbiBoYXNoXCIsIFwiYWZ0ZXJIYXNoXCIsIGFmdGVySGFzaCk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywge1xuXHQgICAgICAgICAgICBfaXNGb3JrRXZlbnQ6IHRydWUsXG5cdCAgICAgICAgICAgIF9pc1RyYW5zYWN0aW9uT3JkZXJGb3JrRXZlbnQ6IHRydWUsXG5cdCAgICAgICAgICAgIGV4cGlyeTogKGV4cGlyeSB8fCAwKSxcblx0ICAgICAgICAgICAgYmVmb3JlSGFzaDogYmVmb3JlSGFzaCxcblx0ICAgICAgICAgICAgYWZ0ZXJIYXNoOiBhZnRlckhhc2hcblx0ICAgICAgICB9KSB8fCB0aGlzO1xuXHQgICAgICAgIHJldHVybiBfdGhpcztcblx0ICAgIH1cblx0ICAgIHJldHVybiBUcmFuc2FjdGlvbk9yZGVyRm9ya0V2ZW50O1xuXHR9KEZvcmtFdmVudCkpO1xuXHRleHBvcnRzLlRyYW5zYWN0aW9uT3JkZXJGb3JrRXZlbnQgPSBUcmFuc2FjdGlvbk9yZGVyRm9ya0V2ZW50O1xuXHQvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5cdC8vIEV4cG9ydGVkIEFic3RyYWN0c1xuXHR2YXIgUHJvdmlkZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG5cdCAgICBmdW5jdGlvbiBQcm92aWRlcigpIHtcblx0ICAgICAgICB2YXIgX25ld1RhcmdldCA9IHRoaXMuY29uc3RydWN0b3I7XG5cdCAgICAgICAgbG9nZ2VyLmNoZWNrQWJzdHJhY3QoX25ld1RhcmdldCwgUHJvdmlkZXIpO1xuXHQgICAgICAgICgwLCBsaWIkMy5kZWZpbmVSZWFkT25seSkodGhpcywgXCJfaXNQcm92aWRlclwiLCB0cnVlKTtcblx0ICAgIH1cblx0ICAgIFByb3ZpZGVyLnByb3RvdHlwZS5nZXRGZWVEYXRhID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgdmFyIF9hLCBibG9jaywgZ2FzUHJpY2UsIG1heEZlZVBlckdhcywgbWF4UHJpb3JpdHlGZWVQZXJHYXM7XG5cdCAgICAgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2IpIHtcblx0ICAgICAgICAgICAgICAgIHN3aXRjaCAoX2IubGFiZWwpIHtcblx0ICAgICAgICAgICAgICAgICAgICBjYXNlIDA6IHJldHVybiBbNCAvKnlpZWxkKi8sICgwLCBsaWIkMy5yZXNvbHZlUHJvcGVydGllcykoe1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgYmxvY2s6IHRoaXMuZ2V0QmxvY2soXCJsYXRlc3RcIiksXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBnYXNQcmljZTogdGhpcy5nZXRHYXNQcmljZSgpLmNhdGNoKGZ1bmN0aW9uIChlcnJvcikge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEBUT0RPOiBXaHkgaXMgdGhpcyBub3cgZmFpbGluZyBvbiBDYWxhdmVyYXM/XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9jb25zb2xlLmxvZyhlcnJvcik7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KVxuXHQgICAgICAgICAgICAgICAgICAgICAgICB9KV07XG5cdCAgICAgICAgICAgICAgICAgICAgY2FzZSAxOlxuXHQgICAgICAgICAgICAgICAgICAgICAgICBfYSA9IF9iLnNlbnQoKSwgYmxvY2sgPSBfYS5ibG9jaywgZ2FzUHJpY2UgPSBfYS5nYXNQcmljZTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgbWF4RmVlUGVyR2FzID0gbnVsbCwgbWF4UHJpb3JpdHlGZWVQZXJHYXMgPSBudWxsO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBpZiAoYmxvY2sgJiYgYmxvY2suYmFzZUZlZVBlckdhcykge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gV2UgbWF5IHdhbnQgdG8gY29tcHV0ZSB0aGlzIG1vcmUgYWNjdXJhdGVseSBpbiB0aGUgZnV0dXJlLFxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gdXNpbmcgdGhlIGZvcm11bGEgXCJjaGVjayBpZiB0aGUgYmFzZSBmZWUgaXMgY29ycmVjdFwiLlxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gU2VlOiBodHRwczovL2VpcHMuZXRoZXJldW0ub3JnL0VJUFMvZWlwLTE1NTlcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1heFByaW9yaXR5RmVlUGVyR2FzID0gbGliJDIuQmlnTnVtYmVyLmZyb20oXCIyNTAwMDAwMDAwXCIpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWF4RmVlUGVyR2FzID0gYmxvY2suYmFzZUZlZVBlckdhcy5tdWwoMikuYWRkKG1heFByaW9yaXR5RmVlUGVyR2FzKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgeyBtYXhGZWVQZXJHYXM6IG1heEZlZVBlckdhcywgbWF4UHJpb3JpdHlGZWVQZXJHYXM6IG1heFByaW9yaXR5RmVlUGVyR2FzLCBnYXNQcmljZTogZ2FzUHJpY2UgfV07XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIH0pO1xuXHQgICAgICAgIH0pO1xuXHQgICAgfTtcblx0ICAgIC8vIEFsaWFzIGZvciBcIm9uXCJcblx0ICAgIFByb3ZpZGVyLnByb3RvdHlwZS5hZGRMaXN0ZW5lciA9IGZ1bmN0aW9uIChldmVudE5hbWUsIGxpc3RlbmVyKSB7XG5cdCAgICAgICAgcmV0dXJuIHRoaXMub24oZXZlbnROYW1lLCBsaXN0ZW5lcik7XG5cdCAgICB9O1xuXHQgICAgLy8gQWxpYXMgZm9yIFwib2ZmXCJcblx0ICAgIFByb3ZpZGVyLnByb3RvdHlwZS5yZW1vdmVMaXN0ZW5lciA9IGZ1bmN0aW9uIChldmVudE5hbWUsIGxpc3RlbmVyKSB7XG5cdCAgICAgICAgcmV0dXJuIHRoaXMub2ZmKGV2ZW50TmFtZSwgbGlzdGVuZXIpO1xuXHQgICAgfTtcblx0ICAgIFByb3ZpZGVyLmlzUHJvdmlkZXIgPSBmdW5jdGlvbiAodmFsdWUpIHtcblx0ICAgICAgICByZXR1cm4gISEodmFsdWUgJiYgdmFsdWUuX2lzUHJvdmlkZXIpO1xuXHQgICAgfTtcblx0ICAgIHJldHVybiBQcm92aWRlcjtcblx0fSgpKTtcblx0ZXhwb3J0cy5Qcm92aWRlciA9IFByb3ZpZGVyO1xuXG5cdH0pO1xuXG5cdHZhciBpbmRleCRiID0gLypAX19QVVJFX18qL2dldERlZmF1bHRFeHBvcnRGcm9tQ2pzKGxpYiRiKTtcblxuXHR2YXIgX3ZlcnNpb24kayA9IGNyZWF0ZUNvbW1vbmpzTW9kdWxlKGZ1bmN0aW9uIChtb2R1bGUsIGV4cG9ydHMpIHtcblx0XCJ1c2Ugc3RyaWN0XCI7XG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcblx0ZXhwb3J0cy52ZXJzaW9uID0gdm9pZCAwO1xuXHRleHBvcnRzLnZlcnNpb24gPSBcImFic3RyYWN0LXNpZ25lci81LjUuMFwiO1xuXG5cdH0pO1xuXG5cdHZhciBfdmVyc2lvbiRsID0gLypAX19QVVJFX18qL2dldERlZmF1bHRFeHBvcnRGcm9tQ2pzKF92ZXJzaW9uJGspO1xuXG5cdHZhciBsaWIkYyA9IGNyZWF0ZUNvbW1vbmpzTW9kdWxlKGZ1bmN0aW9uIChtb2R1bGUsIGV4cG9ydHMpIHtcblx0XCJ1c2Ugc3RyaWN0XCI7XG5cdHZhciBfX2V4dGVuZHMgPSAoY29tbW9uanNHbG9iYWwgJiYgY29tbW9uanNHbG9iYWwuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuXHQgICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBmdW5jdGlvbiAoZCwgYikge1xuXHQgICAgICAgIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcblx0ICAgICAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuXHQgICAgICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoYiwgcCkpIGRbcF0gPSBiW3BdOyB9O1xuXHQgICAgICAgIHJldHVybiBleHRlbmRTdGF0aWNzKGQsIGIpO1xuXHQgICAgfTtcblx0ICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuXHQgICAgICAgIGlmICh0eXBlb2YgYiAhPT0gXCJmdW5jdGlvblwiICYmIGIgIT09IG51bGwpXG5cdCAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDbGFzcyBleHRlbmRzIHZhbHVlIFwiICsgU3RyaW5nKGIpICsgXCIgaXMgbm90IGEgY29uc3RydWN0b3Igb3IgbnVsbFwiKTtcblx0ICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuXHQgICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuXHQgICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcblx0ICAgIH07XG5cdH0pKCk7XG5cdHZhciBfX2F3YWl0ZXIgPSAoY29tbW9uanNHbG9iYWwgJiYgY29tbW9uanNHbG9iYWwuX19hd2FpdGVyKSB8fCBmdW5jdGlvbiAodGhpc0FyZywgX2FyZ3VtZW50cywgUCwgZ2VuZXJhdG9yKSB7XG5cdCAgICBmdW5jdGlvbiBhZG9wdCh2YWx1ZSkgeyByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBQID8gdmFsdWUgOiBuZXcgUChmdW5jdGlvbiAocmVzb2x2ZSkgeyByZXNvbHZlKHZhbHVlKTsgfSk7IH1cblx0ICAgIHJldHVybiBuZXcgKFAgfHwgKFAgPSBQcm9taXNlKSkoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuXHQgICAgICAgIGZ1bmN0aW9uIGZ1bGZpbGxlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvci5uZXh0KHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cblx0ICAgICAgICBmdW5jdGlvbiByZWplY3RlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvcltcInRocm93XCJdKHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cblx0ICAgICAgICBmdW5jdGlvbiBzdGVwKHJlc3VsdCkgeyByZXN1bHQuZG9uZSA/IHJlc29sdmUocmVzdWx0LnZhbHVlKSA6IGFkb3B0KHJlc3VsdC52YWx1ZSkudGhlbihmdWxmaWxsZWQsIHJlamVjdGVkKTsgfVxuXHQgICAgICAgIHN0ZXAoKGdlbmVyYXRvciA9IGdlbmVyYXRvci5hcHBseSh0aGlzQXJnLCBfYXJndW1lbnRzIHx8IFtdKSkubmV4dCgpKTtcblx0ICAgIH0pO1xuXHR9O1xuXHR2YXIgX19nZW5lcmF0b3IgPSAoY29tbW9uanNHbG9iYWwgJiYgY29tbW9uanNHbG9iYWwuX19nZW5lcmF0b3IpIHx8IGZ1bmN0aW9uICh0aGlzQXJnLCBib2R5KSB7XG5cdCAgICB2YXIgXyA9IHsgbGFiZWw6IDAsIHNlbnQ6IGZ1bmN0aW9uKCkgeyBpZiAodFswXSAmIDEpIHRocm93IHRbMV07IHJldHVybiB0WzFdOyB9LCB0cnlzOiBbXSwgb3BzOiBbXSB9LCBmLCB5LCB0LCBnO1xuXHQgICAgcmV0dXJuIGcgPSB7IG5leHQ6IHZlcmIoMCksIFwidGhyb3dcIjogdmVyYigxKSwgXCJyZXR1cm5cIjogdmVyYigyKSB9LCB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgKGdbU3ltYm9sLml0ZXJhdG9yXSA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpczsgfSksIGc7XG5cdCAgICBmdW5jdGlvbiB2ZXJiKG4pIHsgcmV0dXJuIGZ1bmN0aW9uICh2KSB7IHJldHVybiBzdGVwKFtuLCB2XSk7IH07IH1cblx0ICAgIGZ1bmN0aW9uIHN0ZXAob3ApIHtcblx0ICAgICAgICBpZiAoZikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkdlbmVyYXRvciBpcyBhbHJlYWR5IGV4ZWN1dGluZy5cIik7XG5cdCAgICAgICAgd2hpbGUgKF8pIHRyeSB7XG5cdCAgICAgICAgICAgIGlmIChmID0gMSwgeSAmJiAodCA9IG9wWzBdICYgMiA/IHlbXCJyZXR1cm5cIl0gOiBvcFswXSA/IHlbXCJ0aHJvd1wiXSB8fCAoKHQgPSB5W1wicmV0dXJuXCJdKSAmJiB0LmNhbGwoeSksIDApIDogeS5uZXh0KSAmJiAhKHQgPSB0LmNhbGwoeSwgb3BbMV0pKS5kb25lKSByZXR1cm4gdDtcblx0ICAgICAgICAgICAgaWYgKHkgPSAwLCB0KSBvcCA9IFtvcFswXSAmIDIsIHQudmFsdWVdO1xuXHQgICAgICAgICAgICBzd2l0Y2ggKG9wWzBdKSB7XG5cdCAgICAgICAgICAgICAgICBjYXNlIDA6IGNhc2UgMTogdCA9IG9wOyBicmVhaztcblx0ICAgICAgICAgICAgICAgIGNhc2UgNDogXy5sYWJlbCsrOyByZXR1cm4geyB2YWx1ZTogb3BbMV0sIGRvbmU6IGZhbHNlIH07XG5cdCAgICAgICAgICAgICAgICBjYXNlIDU6IF8ubGFiZWwrKzsgeSA9IG9wWzFdOyBvcCA9IFswXTsgY29udGludWU7XG5cdCAgICAgICAgICAgICAgICBjYXNlIDc6IG9wID0gXy5vcHMucG9wKCk7IF8udHJ5cy5wb3AoKTsgY29udGludWU7XG5cdCAgICAgICAgICAgICAgICBkZWZhdWx0OlxuXHQgICAgICAgICAgICAgICAgICAgIGlmICghKHQgPSBfLnRyeXMsIHQgPSB0Lmxlbmd0aCA+IDAgJiYgdFt0Lmxlbmd0aCAtIDFdKSAmJiAob3BbMF0gPT09IDYgfHwgb3BbMF0gPT09IDIpKSB7IF8gPSAwOyBjb250aW51ZTsgfVxuXHQgICAgICAgICAgICAgICAgICAgIGlmIChvcFswXSA9PT0gMyAmJiAoIXQgfHwgKG9wWzFdID4gdFswXSAmJiBvcFsxXSA8IHRbM10pKSkgeyBfLmxhYmVsID0gb3BbMV07IGJyZWFrOyB9XG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKG9wWzBdID09PSA2ICYmIF8ubGFiZWwgPCB0WzFdKSB7IF8ubGFiZWwgPSB0WzFdOyB0ID0gb3A7IGJyZWFrOyB9XG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKHQgJiYgXy5sYWJlbCA8IHRbMl0pIHsgXy5sYWJlbCA9IHRbMl07IF8ub3BzLnB1c2gob3ApOyBicmVhazsgfVxuXHQgICAgICAgICAgICAgICAgICAgIGlmICh0WzJdKSBfLm9wcy5wb3AoKTtcblx0ICAgICAgICAgICAgICAgICAgICBfLnRyeXMucG9wKCk7IGNvbnRpbnVlO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIG9wID0gYm9keS5jYWxsKHRoaXNBcmcsIF8pO1xuXHQgICAgICAgIH0gY2F0Y2ggKGUpIHsgb3AgPSBbNiwgZV07IHkgPSAwOyB9IGZpbmFsbHkgeyBmID0gdCA9IDA7IH1cblx0ICAgICAgICBpZiAob3BbMF0gJiA1KSB0aHJvdyBvcFsxXTsgcmV0dXJuIHsgdmFsdWU6IG9wWzBdID8gb3BbMV0gOiB2b2lkIDAsIGRvbmU6IHRydWUgfTtcblx0ICAgIH1cblx0fTtcblx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuXHRleHBvcnRzLlZvaWRTaWduZXIgPSBleHBvcnRzLlNpZ25lciA9IHZvaWQgMDtcblxuXG5cblx0dmFyIGxvZ2dlciA9IG5ldyBsaWIuTG9nZ2VyKF92ZXJzaW9uJGsudmVyc2lvbik7XG5cdHZhciBhbGxvd2VkVHJhbnNhY3Rpb25LZXlzID0gW1xuXHQgICAgXCJhY2Nlc3NMaXN0XCIsIFwiY2hhaW5JZFwiLCBcImN1c3RvbURhdGFcIiwgXCJkYXRhXCIsIFwiZnJvbVwiLCBcImdhc0xpbWl0XCIsIFwiZ2FzUHJpY2VcIiwgXCJtYXhGZWVQZXJHYXNcIiwgXCJtYXhQcmlvcml0eUZlZVBlckdhc1wiLCBcIm5vbmNlXCIsIFwidG9cIiwgXCJ0eXBlXCIsIFwidmFsdWVcIlxuXHRdO1xuXHR2YXIgZm9yd2FyZEVycm9ycyA9IFtcblx0ICAgIGxpYi5Mb2dnZXIuZXJyb3JzLklOU1VGRklDSUVOVF9GVU5EUyxcblx0ICAgIGxpYi5Mb2dnZXIuZXJyb3JzLk5PTkNFX0VYUElSRUQsXG5cdCAgICBsaWIuTG9nZ2VyLmVycm9ycy5SRVBMQUNFTUVOVF9VTkRFUlBSSUNFRCxcblx0XTtcblx0O1xuXHQ7XG5cdHZhciBTaWduZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG5cdCAgICAvLy8vLy8vLy8vLy8vLy8vLy8vXG5cdCAgICAvLyBTdWItY2xhc3NlcyBNVVNUIGNhbGwgc3VwZXJcblx0ICAgIGZ1bmN0aW9uIFNpZ25lcigpIHtcblx0ICAgICAgICB2YXIgX25ld1RhcmdldCA9IHRoaXMuY29uc3RydWN0b3I7XG5cdCAgICAgICAgbG9nZ2VyLmNoZWNrQWJzdHJhY3QoX25ld1RhcmdldCwgU2lnbmVyKTtcblx0ICAgICAgICAoMCwgbGliJDMuZGVmaW5lUmVhZE9ubHkpKHRoaXMsIFwiX2lzU2lnbmVyXCIsIHRydWUpO1xuXHQgICAgfVxuXHQgICAgLy8vLy8vLy8vLy8vLy8vLy8vL1xuXHQgICAgLy8gU3ViLWNsYXNzZXMgTUFZIG92ZXJyaWRlIHRoZXNlXG5cdCAgICBTaWduZXIucHJvdG90eXBlLmdldEJhbGFuY2UgPSBmdW5jdGlvbiAoYmxvY2tUYWcpIHtcblx0ICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcblx0ICAgICAgICAgICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcblx0ICAgICAgICAgICAgICAgICAgICBjYXNlIDA6XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2NoZWNrUHJvdmlkZXIoXCJnZXRCYWxhbmNlXCIpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCB0aGlzLnByb3ZpZGVyLmdldEJhbGFuY2UodGhpcy5nZXRBZGRyZXNzKCksIGJsb2NrVGFnKV07XG5cdCAgICAgICAgICAgICAgICAgICAgY2FzZSAxOiByZXR1cm4gWzIgLypyZXR1cm4qLywgX2Euc2VudCgpXTtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgfSk7XG5cdCAgICB9O1xuXHQgICAgU2lnbmVyLnByb3RvdHlwZS5nZXRUcmFuc2FjdGlvbkNvdW50ID0gZnVuY3Rpb24gKGJsb2NrVGFnKSB7XG5cdCAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG5cdCAgICAgICAgICAgICAgICBzd2l0Y2ggKF9hLmxhYmVsKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgY2FzZSAwOlxuXHQgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9jaGVja1Byb3ZpZGVyKFwiZ2V0VHJhbnNhY3Rpb25Db3VudFwiKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgdGhpcy5wcm92aWRlci5nZXRUcmFuc2FjdGlvbkNvdW50KHRoaXMuZ2V0QWRkcmVzcygpLCBibG9ja1RhZyldO1xuXHQgICAgICAgICAgICAgICAgICAgIGNhc2UgMTogcmV0dXJuIFsyIC8qcmV0dXJuKi8sIF9hLnNlbnQoKV07XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIH0pO1xuXHQgICAgICAgIH0pO1xuXHQgICAgfTtcblx0ICAgIC8vIFBvcHVsYXRlcyBcImZyb21cIiBpZiB1bnNwZWNpZmllZCwgYW5kIGVzdGltYXRlcyB0aGUgZ2FzIGZvciB0aGUgdHJhbnNhY3Rpb25cblx0ICAgIFNpZ25lci5wcm90b3R5cGUuZXN0aW1hdGVHYXMgPSBmdW5jdGlvbiAodHJhbnNhY3Rpb24pIHtcblx0ICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIHZhciB0eDtcblx0ICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuXHQgICAgICAgICAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkge1xuXHQgICAgICAgICAgICAgICAgICAgIGNhc2UgMDpcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fY2hlY2tQcm92aWRlcihcImVzdGltYXRlR2FzXCIpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCAoMCwgbGliJDMucmVzb2x2ZVByb3BlcnRpZXMpKHRoaXMuY2hlY2tUcmFuc2FjdGlvbih0cmFuc2FjdGlvbikpXTtcblx0ICAgICAgICAgICAgICAgICAgICBjYXNlIDE6XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHR4ID0gX2Euc2VudCgpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCB0aGlzLnByb3ZpZGVyLmVzdGltYXRlR2FzKHR4KV07XG5cdCAgICAgICAgICAgICAgICAgICAgY2FzZSAyOiByZXR1cm4gWzIgLypyZXR1cm4qLywgX2Euc2VudCgpXTtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgfSk7XG5cdCAgICB9O1xuXHQgICAgLy8gUG9wdWxhdGVzIFwiZnJvbVwiIGlmIHVuc3BlY2lmaWVkLCBhbmQgY2FsbHMgd2l0aCB0aGUgdHJhbnNhY3Rpb25cblx0ICAgIFNpZ25lci5wcm90b3R5cGUuY2FsbCA9IGZ1bmN0aW9uICh0cmFuc2FjdGlvbiwgYmxvY2tUYWcpIHtcblx0ICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIHZhciB0eDtcblx0ICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuXHQgICAgICAgICAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkge1xuXHQgICAgICAgICAgICAgICAgICAgIGNhc2UgMDpcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fY2hlY2tQcm92aWRlcihcImNhbGxcIik7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sICgwLCBsaWIkMy5yZXNvbHZlUHJvcGVydGllcykodGhpcy5jaGVja1RyYW5zYWN0aW9uKHRyYW5zYWN0aW9uKSldO1xuXHQgICAgICAgICAgICAgICAgICAgIGNhc2UgMTpcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdHggPSBfYS5zZW50KCk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIHRoaXMucHJvdmlkZXIuY2FsbCh0eCwgYmxvY2tUYWcpXTtcblx0ICAgICAgICAgICAgICAgICAgICBjYXNlIDI6IHJldHVybiBbMiAvKnJldHVybiovLCBfYS5zZW50KCldO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB9KTtcblx0ICAgICAgICB9KTtcblx0ICAgIH07XG5cdCAgICAvLyBQb3B1bGF0ZXMgYWxsIGZpZWxkcyBpbiBhIHRyYW5zYWN0aW9uLCBzaWducyBpdCBhbmQgc2VuZHMgaXQgdG8gdGhlIG5ldHdvcmtcblx0ICAgIFNpZ25lci5wcm90b3R5cGUuc2VuZFRyYW5zYWN0aW9uID0gZnVuY3Rpb24gKHRyYW5zYWN0aW9uKSB7XG5cdCAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICB2YXIgdHgsIHNpZ25lZFR4O1xuXHQgICAgICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG5cdCAgICAgICAgICAgICAgICBzd2l0Y2ggKF9hLmxhYmVsKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgY2FzZSAwOlxuXHQgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9jaGVja1Byb3ZpZGVyKFwic2VuZFRyYW5zYWN0aW9uXCIpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCB0aGlzLnBvcHVsYXRlVHJhbnNhY3Rpb24odHJhbnNhY3Rpb24pXTtcblx0ICAgICAgICAgICAgICAgICAgICBjYXNlIDE6XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHR4ID0gX2Euc2VudCgpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCB0aGlzLnNpZ25UcmFuc2FjdGlvbih0eCldO1xuXHQgICAgICAgICAgICAgICAgICAgIGNhc2UgMjpcblx0ICAgICAgICAgICAgICAgICAgICAgICAgc2lnbmVkVHggPSBfYS5zZW50KCk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIHRoaXMucHJvdmlkZXIuc2VuZFRyYW5zYWN0aW9uKHNpZ25lZFR4KV07XG5cdCAgICAgICAgICAgICAgICAgICAgY2FzZSAzOiByZXR1cm4gWzIgLypyZXR1cm4qLywgX2Euc2VudCgpXTtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgfSk7XG5cdCAgICB9O1xuXHQgICAgU2lnbmVyLnByb3RvdHlwZS5nZXRDaGFpbklkID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgdmFyIG5ldHdvcms7XG5cdCAgICAgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcblx0ICAgICAgICAgICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcblx0ICAgICAgICAgICAgICAgICAgICBjYXNlIDA6XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2NoZWNrUHJvdmlkZXIoXCJnZXRDaGFpbklkXCIpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCB0aGlzLnByb3ZpZGVyLmdldE5ldHdvcmsoKV07XG5cdCAgICAgICAgICAgICAgICAgICAgY2FzZSAxOlxuXHQgICAgICAgICAgICAgICAgICAgICAgICBuZXR3b3JrID0gX2Euc2VudCgpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgbmV0d29yay5jaGFpbklkXTtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgfSk7XG5cdCAgICB9O1xuXHQgICAgU2lnbmVyLnByb3RvdHlwZS5nZXRHYXNQcmljZSA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcblx0ICAgICAgICAgICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcblx0ICAgICAgICAgICAgICAgICAgICBjYXNlIDA6XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2NoZWNrUHJvdmlkZXIoXCJnZXRHYXNQcmljZVwiKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgdGhpcy5wcm92aWRlci5nZXRHYXNQcmljZSgpXTtcblx0ICAgICAgICAgICAgICAgICAgICBjYXNlIDE6IHJldHVybiBbMiAvKnJldHVybiovLCBfYS5zZW50KCldO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB9KTtcblx0ICAgICAgICB9KTtcblx0ICAgIH07XG5cdCAgICBTaWduZXIucHJvdG90eXBlLmdldEZlZURhdGEgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG5cdCAgICAgICAgICAgICAgICBzd2l0Y2ggKF9hLmxhYmVsKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgY2FzZSAwOlxuXHQgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9jaGVja1Byb3ZpZGVyKFwiZ2V0RmVlRGF0YVwiKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgdGhpcy5wcm92aWRlci5nZXRGZWVEYXRhKCldO1xuXHQgICAgICAgICAgICAgICAgICAgIGNhc2UgMTogcmV0dXJuIFsyIC8qcmV0dXJuKi8sIF9hLnNlbnQoKV07XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIH0pO1xuXHQgICAgICAgIH0pO1xuXHQgICAgfTtcblx0ICAgIFNpZ25lci5wcm90b3R5cGUucmVzb2x2ZU5hbWUgPSBmdW5jdGlvbiAobmFtZSkge1xuXHQgICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuXHQgICAgICAgICAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkge1xuXHQgICAgICAgICAgICAgICAgICAgIGNhc2UgMDpcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fY2hlY2tQcm92aWRlcihcInJlc29sdmVOYW1lXCIpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCB0aGlzLnByb3ZpZGVyLnJlc29sdmVOYW1lKG5hbWUpXTtcblx0ICAgICAgICAgICAgICAgICAgICBjYXNlIDE6IHJldHVybiBbMiAvKnJldHVybiovLCBfYS5zZW50KCldO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB9KTtcblx0ICAgICAgICB9KTtcblx0ICAgIH07XG5cdCAgICAvLyBDaGVja3MgYSB0cmFuc2FjdGlvbiBkb2VzIG5vdCBjb250YWluIGludmFsaWQga2V5cyBhbmQgaWZcblx0ICAgIC8vIG5vIFwiZnJvbVwiIGlzIHByb3ZpZGVkLCBwb3B1bGF0ZXMgaXQuXG5cdCAgICAvLyAtIGRvZXMgTk9UIHJlcXVpcmUgYSBwcm92aWRlclxuXHQgICAgLy8gLSBhZGRzIFwiZnJvbVwiIGlzIG5vdCBwcmVzZW50XG5cdCAgICAvLyAtIHJldHVybnMgYSBDT1BZIChzYWZlIHRvIG11dGF0ZSB0aGUgcmVzdWx0KVxuXHQgICAgLy8gQnkgZGVmYXVsdCBjYWxsZWQgZnJvbTogKG92ZXJyaWRpbmcgdGhlc2UgcHJldmVudHMgaXQpXG5cdCAgICAvLyAgIC0gY2FsbFxuXHQgICAgLy8gICAtIGVzdGltYXRlR2FzXG5cdCAgICAvLyAgIC0gcG9wdWxhdGVUcmFuc2FjdGlvbiAoYW5kIHRoZXJlZm9yIHNlbmRUcmFuc2FjdGlvbilcblx0ICAgIFNpZ25lci5wcm90b3R5cGUuY2hlY2tUcmFuc2FjdGlvbiA9IGZ1bmN0aW9uICh0cmFuc2FjdGlvbikge1xuXHQgICAgICAgIGZvciAodmFyIGtleSBpbiB0cmFuc2FjdGlvbikge1xuXHQgICAgICAgICAgICBpZiAoYWxsb3dlZFRyYW5zYWN0aW9uS2V5cy5pbmRleE9mKGtleSkgPT09IC0xKSB7XG5cdCAgICAgICAgICAgICAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwiaW52YWxpZCB0cmFuc2FjdGlvbiBrZXk6IFwiICsga2V5LCBcInRyYW5zYWN0aW9uXCIsIHRyYW5zYWN0aW9uKTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH1cblx0ICAgICAgICB2YXIgdHggPSAoMCwgbGliJDMuc2hhbGxvd0NvcHkpKHRyYW5zYWN0aW9uKTtcblx0ICAgICAgICBpZiAodHguZnJvbSA9PSBudWxsKSB7XG5cdCAgICAgICAgICAgIHR4LmZyb20gPSB0aGlzLmdldEFkZHJlc3MoKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgZWxzZSB7XG5cdCAgICAgICAgICAgIC8vIE1ha2Ugc3VyZSBhbnkgcHJvdmlkZWQgYWRkcmVzcyBtYXRjaGVzIHRoaXMgc2lnbmVyXG5cdCAgICAgICAgICAgIHR4LmZyb20gPSBQcm9taXNlLmFsbChbXG5cdCAgICAgICAgICAgICAgICBQcm9taXNlLnJlc29sdmUodHguZnJvbSksXG5cdCAgICAgICAgICAgICAgICB0aGlzLmdldEFkZHJlc3MoKVxuXHQgICAgICAgICAgICBdKS50aGVuKGZ1bmN0aW9uIChyZXN1bHQpIHtcblx0ICAgICAgICAgICAgICAgIGlmIChyZXN1bHRbMF0udG9Mb3dlckNhc2UoKSAhPT0gcmVzdWx0WzFdLnRvTG93ZXJDYXNlKCkpIHtcblx0ICAgICAgICAgICAgICAgICAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwiZnJvbSBhZGRyZXNzIG1pc21hdGNoXCIsIFwidHJhbnNhY3Rpb25cIiwgdHJhbnNhY3Rpb24pO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdFswXTtcblx0ICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHJldHVybiB0eDtcblx0ICAgIH07XG5cdCAgICAvLyBQb3B1bGF0ZXMgQUxMIGtleXMgZm9yIGEgdHJhbnNhY3Rpb24gYW5kIGNoZWNrcyB0aGF0IFwiZnJvbVwiIG1hdGNoZXNcblx0ICAgIC8vIHRoaXMgU2lnbmVyLiBTaG91bGQgYmUgdXNlZCBieSBzZW5kVHJhbnNhY3Rpb24gYnV0IE5PVCBieSBzaWduVHJhbnNhY3Rpb24uXG5cdCAgICAvLyBCeSBkZWZhdWx0IGNhbGxlZCBmcm9tOiAob3ZlcnJpZGluZyB0aGVzZSBwcmV2ZW50cyBpdClcblx0ICAgIC8vICAgLSBzZW5kVHJhbnNhY3Rpb25cblx0ICAgIC8vXG5cdCAgICAvLyBOb3Rlczpcblx0ICAgIC8vICAtIFdlIGFsbG93IGdhc1ByaWNlIGZvciBFSVAtMTU1OSBhcyBsb25nIGFzIGl0IG1hdGNoZXMgbWF4RmVlUGVyR2FzXG5cdCAgICBTaWduZXIucHJvdG90eXBlLnBvcHVsYXRlVHJhbnNhY3Rpb24gPSBmdW5jdGlvbiAodHJhbnNhY3Rpb24pIHtcblx0ICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIHZhciB0eCwgaGFzRWlwMTU1OSwgZmVlRGF0YSwgZ2FzUHJpY2U7XG5cdCAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cdCAgICAgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcblx0ICAgICAgICAgICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcblx0ICAgICAgICAgICAgICAgICAgICBjYXNlIDA6IHJldHVybiBbNCAvKnlpZWxkKi8sICgwLCBsaWIkMy5yZXNvbHZlUHJvcGVydGllcykodGhpcy5jaGVja1RyYW5zYWN0aW9uKHRyYW5zYWN0aW9uKSldO1xuXHQgICAgICAgICAgICAgICAgICAgIGNhc2UgMTpcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdHggPSBfYS5zZW50KCk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0eC50byAhPSBudWxsKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eC50byA9IFByb21pc2UucmVzb2x2ZSh0eC50bykudGhlbihmdW5jdGlvbiAodG8pIHsgcmV0dXJuIF9fYXdhaXRlcihfdGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgYWRkcmVzcztcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMDpcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodG8gPT0gbnVsbCkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgbnVsbF07XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIHRoaXMucmVzb2x2ZU5hbWUodG8pXTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMTpcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhZGRyZXNzID0gX2Euc2VudCgpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChhZGRyZXNzID09IG51bGwpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcInByb3ZpZGVkIEVOUyBuYW1lIHJlc29sdmVzIHRvIG51bGxcIiwgXCJ0eC50b1wiLCB0byk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCBhZGRyZXNzXTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7IH0pO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gUHJldmVudCB0aGlzIGVycm9yIGZyb20gY2F1c2luZyBhbiBVbmhhbmRsZWRQcm9taXNlRXhjZXB0aW9uXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eC50by5jYXRjaChmdW5jdGlvbiAoZXJyb3IpIHsgfSk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICAgICAgaGFzRWlwMTU1OSA9ICh0eC5tYXhGZWVQZXJHYXMgIT0gbnVsbCB8fCB0eC5tYXhQcmlvcml0eUZlZVBlckdhcyAhPSBudWxsKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHR4Lmdhc1ByaWNlICE9IG51bGwgJiYgKHR4LnR5cGUgPT09IDIgfHwgaGFzRWlwMTU1OSkpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJlaXAtMTU1OSB0cmFuc2FjdGlvbiBkbyBub3Qgc3VwcG9ydCBnYXNQcmljZVwiLCBcInRyYW5zYWN0aW9uXCIsIHRyYW5zYWN0aW9uKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmICgodHgudHlwZSA9PT0gMCB8fCB0eC50eXBlID09PSAxKSAmJiBoYXNFaXAxNTU5KSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwicHJlLWVpcC0xNTU5IHRyYW5zYWN0aW9uIGRvIG5vdCBzdXBwb3J0IG1heEZlZVBlckdhcy9tYXhQcmlvcml0eUZlZVBlckdhc1wiLCBcInRyYW5zYWN0aW9uXCIsIHRyYW5zYWN0aW9uKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgICAgICBpZiAoISgodHgudHlwZSA9PT0gMiB8fCB0eC50eXBlID09IG51bGwpICYmICh0eC5tYXhGZWVQZXJHYXMgIT0gbnVsbCAmJiB0eC5tYXhQcmlvcml0eUZlZVBlckdhcyAhPSBudWxsKSkpIHJldHVybiBbMyAvKmJyZWFrKi8sIDJdO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAvLyBGdWxseS1mb3JtZWQgRUlQLTE1NTkgdHJhbnNhY3Rpb24gKHNraXAgZ2V0RmVlRGF0YSlcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdHgudHlwZSA9IDI7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMyAvKmJyZWFrKi8sIDVdO1xuXHQgICAgICAgICAgICAgICAgICAgIGNhc2UgMjpcblx0ICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCEodHgudHlwZSA9PT0gMCB8fCB0eC50eXBlID09PSAxKSkgcmV0dXJuIFszIC8qYnJlYWsqLywgM107XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIC8vIEV4cGxpY2l0IExlZ2FjeSBvciBFSVAtMjkzMCB0cmFuc2FjdGlvblxuXHQgICAgICAgICAgICAgICAgICAgICAgICAvLyBQb3B1bGF0ZSBtaXNzaW5nIGdhc1ByaWNlXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0eC5nYXNQcmljZSA9PSBudWxsKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eC5nYXNQcmljZSA9IHRoaXMuZ2V0R2FzUHJpY2UoKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzMgLypicmVhayovLCA1XTtcblx0ICAgICAgICAgICAgICAgICAgICBjYXNlIDM6IHJldHVybiBbNCAvKnlpZWxkKi8sIHRoaXMuZ2V0RmVlRGF0YSgpXTtcblx0ICAgICAgICAgICAgICAgICAgICBjYXNlIDQ6XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGZlZURhdGEgPSBfYS5zZW50KCk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0eC50eXBlID09IG51bGwpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFdlIG5lZWQgdG8gYXV0by1kZXRlY3QgdGhlIGludGVuZGVkIHR5cGUgb2YgdGhpcyB0cmFuc2FjdGlvbi4uLlxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGZlZURhdGEubWF4RmVlUGVyR2FzICE9IG51bGwgJiYgZmVlRGF0YS5tYXhQcmlvcml0eUZlZVBlckdhcyAhPSBudWxsKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gVGhlIG5ldHdvcmsgc3VwcG9ydHMgRUlQLTE1NTkhXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gVXBncmFkZSB0cmFuc2FjdGlvbiBmcm9tIG51bGwgdG8gZWlwLTE1NTlcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eC50eXBlID0gMjtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodHguZ2FzUHJpY2UgIT0gbnVsbCkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBnYXNQcmljZSA9IHR4Lmdhc1ByaWNlO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWxldGUgdHguZ2FzUHJpY2U7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR4Lm1heEZlZVBlckdhcyA9IGdhc1ByaWNlO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eC5tYXhQcmlvcml0eUZlZVBlckdhcyA9IGdhc1ByaWNlO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gUG9wdWxhdGUgbWlzc2luZyBmZWUgZGF0YVxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodHgubWF4RmVlUGVyR2FzID09IG51bGwpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR4Lm1heEZlZVBlckdhcyA9IGZlZURhdGEubWF4RmVlUGVyR2FzO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0eC5tYXhQcmlvcml0eUZlZVBlckdhcyA9PSBudWxsKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eC5tYXhQcmlvcml0eUZlZVBlckdhcyA9IGZlZURhdGEubWF4UHJpb3JpdHlGZWVQZXJHYXM7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChmZWVEYXRhLmdhc1ByaWNlICE9IG51bGwpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBOZXR3b3JrIGRvZXNuJ3Qgc3VwcG9ydCBFSVAtMTU1OS4uLlxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIC4uLmJ1dCB0aGV5IGFyZSB0cnlpbmcgdG8gdXNlIEVJUC0xNTU5IHByb3BlcnRpZXNcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaGFzRWlwMTU1OSkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsb2dnZXIudGhyb3dFcnJvcihcIm5ldHdvcmsgZG9lcyBub3Qgc3VwcG9ydCBFSVAtMTU1OVwiLCBsaWIuTG9nZ2VyLmVycm9ycy5VTlNVUFBPUlRFRF9PUEVSQVRJT04sIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wZXJhdGlvbjogXCJwb3B1bGF0ZVRyYW5zYWN0aW9uXCJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFBvcHVsYXRlIG1pc3NpbmcgZmVlIGRhdGFcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodHguZ2FzUHJpY2UgPT0gbnVsbCkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eC5nYXNQcmljZSA9IGZlZURhdGEuZ2FzUHJpY2U7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEV4cGxpY2l0bHkgc2V0IHVudHlwZWQgdHJhbnNhY3Rpb24gdG8gbGVnYWN5XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHgudHlwZSA9IDA7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBnZXRGZWVEYXRhIGhhcyBmYWlsZWQgdXMuXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbG9nZ2VyLnRocm93RXJyb3IoXCJmYWlsZWQgdG8gZ2V0IGNvbnNpc3RlbnQgZmVlIGRhdGFcIiwgbGliLkxvZ2dlci5lcnJvcnMuVU5TVVBQT1JURURfT1BFUkFUSU9OLCB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wZXJhdGlvbjogXCJzaWduZXIuZ2V0RmVlRGF0YVwiXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAodHgudHlwZSA9PT0gMikge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gRXhwbGljaXRseSB1c2luZyBFSVAtMTU1OVxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gUG9wdWxhdGUgbWlzc2luZyBmZWUgZGF0YVxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHR4Lm1heEZlZVBlckdhcyA9PSBudWxsKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHgubWF4RmVlUGVyR2FzID0gZmVlRGF0YS5tYXhGZWVQZXJHYXM7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodHgubWF4UHJpb3JpdHlGZWVQZXJHYXMgPT0gbnVsbCkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR4Lm1heFByaW9yaXR5RmVlUGVyR2FzID0gZmVlRGF0YS5tYXhQcmlvcml0eUZlZVBlckdhcztcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgICAgICBfYS5sYWJlbCA9IDU7XG5cdCAgICAgICAgICAgICAgICAgICAgY2FzZSA1OlxuXHQgICAgICAgICAgICAgICAgICAgICAgICBpZiAodHgubm9uY2UgPT0gbnVsbCkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHgubm9uY2UgPSB0aGlzLmdldFRyYW5zYWN0aW9uQ291bnQoXCJwZW5kaW5nXCIpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0eC5nYXNMaW1pdCA9PSBudWxsKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eC5nYXNMaW1pdCA9IHRoaXMuZXN0aW1hdGVHYXModHgpLmNhdGNoKGZ1bmN0aW9uIChlcnJvcikge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChmb3J3YXJkRXJyb3JzLmluZGV4T2YoZXJyb3IuY29kZSkgPj0gMCkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGxvZ2dlci50aHJvd0Vycm9yKFwiY2Fubm90IGVzdGltYXRlIGdhczsgdHJhbnNhY3Rpb24gbWF5IGZhaWwgb3IgbWF5IHJlcXVpcmUgbWFudWFsIGdhcyBsaW1pdFwiLCBsaWIuTG9nZ2VyLmVycm9ycy5VTlBSRURJQ1RBQkxFX0dBU19MSU1JVCwge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlcnJvcjogZXJyb3IsXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR4OiB0eFxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHR4LmNoYWluSWQgPT0gbnVsbCkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHguY2hhaW5JZCA9IHRoaXMuZ2V0Q2hhaW5JZCgpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHguY2hhaW5JZCA9IFByb21pc2UuYWxsKFtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBQcm9taXNlLnJlc29sdmUodHguY2hhaW5JZCksXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5nZXRDaGFpbklkKClcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIF0pLnRoZW4oZnVuY3Rpb24gKHJlc3VsdHMpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocmVzdWx0c1sxXSAhPT0gMCAmJiByZXN1bHRzWzBdICE9PSByZXN1bHRzWzFdKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJjaGFpbklkIGFkZHJlc3MgbWlzbWF0Y2hcIiwgXCJ0cmFuc2FjdGlvblwiLCB0cmFuc2FjdGlvbik7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHRzWzBdO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgKDAsIGxpYiQzLnJlc29sdmVQcm9wZXJ0aWVzKSh0eCldO1xuXHQgICAgICAgICAgICAgICAgICAgIGNhc2UgNjogcmV0dXJuIFsyIC8qcmV0dXJuKi8sIF9hLnNlbnQoKV07XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIH0pO1xuXHQgICAgICAgIH0pO1xuXHQgICAgfTtcblx0ICAgIC8vLy8vLy8vLy8vLy8vLy8vLy9cblx0ICAgIC8vIFN1Yi1jbGFzc2VzIFNIT1VMRCBsZWF2ZSB0aGVzZSBhbG9uZVxuXHQgICAgU2lnbmVyLnByb3RvdHlwZS5fY2hlY2tQcm92aWRlciA9IGZ1bmN0aW9uIChvcGVyYXRpb24pIHtcblx0ICAgICAgICBpZiAoIXRoaXMucHJvdmlkZXIpIHtcblx0ICAgICAgICAgICAgbG9nZ2VyLnRocm93RXJyb3IoXCJtaXNzaW5nIHByb3ZpZGVyXCIsIGxpYi5Mb2dnZXIuZXJyb3JzLlVOU1VQUE9SVEVEX09QRVJBVElPTiwge1xuXHQgICAgICAgICAgICAgICAgb3BlcmF0aW9uOiAob3BlcmF0aW9uIHx8IFwiX2NoZWNrUHJvdmlkZXJcIilcblx0ICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgfVxuXHQgICAgfTtcblx0ICAgIFNpZ25lci5pc1NpZ25lciA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuXHQgICAgICAgIHJldHVybiAhISh2YWx1ZSAmJiB2YWx1ZS5faXNTaWduZXIpO1xuXHQgICAgfTtcblx0ICAgIHJldHVybiBTaWduZXI7XG5cdH0oKSk7XG5cdGV4cG9ydHMuU2lnbmVyID0gU2lnbmVyO1xuXHR2YXIgVm9pZFNpZ25lciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcblx0ICAgIF9fZXh0ZW5kcyhWb2lkU2lnbmVyLCBfc3VwZXIpO1xuXHQgICAgZnVuY3Rpb24gVm9pZFNpZ25lcihhZGRyZXNzLCBwcm92aWRlcikge1xuXHQgICAgICAgIHZhciBfbmV3VGFyZ2V0ID0gdGhpcy5jb25zdHJ1Y3Rvcjtcblx0ICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXHQgICAgICAgIGxvZ2dlci5jaGVja05ldyhfbmV3VGFyZ2V0LCBWb2lkU2lnbmVyKTtcblx0ICAgICAgICBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMpIHx8IHRoaXM7XG5cdCAgICAgICAgKDAsIGxpYiQzLmRlZmluZVJlYWRPbmx5KShfdGhpcywgXCJhZGRyZXNzXCIsIGFkZHJlc3MpO1xuXHQgICAgICAgICgwLCBsaWIkMy5kZWZpbmVSZWFkT25seSkoX3RoaXMsIFwicHJvdmlkZXJcIiwgcHJvdmlkZXIgfHwgbnVsbCk7XG5cdCAgICAgICAgcmV0dXJuIF90aGlzO1xuXHQgICAgfVxuXHQgICAgVm9pZFNpZ25lci5wcm90b3R5cGUuZ2V0QWRkcmVzcyA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHRoaXMuYWRkcmVzcyk7XG5cdCAgICB9O1xuXHQgICAgVm9pZFNpZ25lci5wcm90b3R5cGUuX2ZhaWwgPSBmdW5jdGlvbiAobWVzc2FnZSwgb3BlcmF0aW9uKSB7XG5cdCAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpLnRoZW4oZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICBsb2dnZXIudGhyb3dFcnJvcihtZXNzYWdlLCBsaWIuTG9nZ2VyLmVycm9ycy5VTlNVUFBPUlRFRF9PUEVSQVRJT04sIHsgb3BlcmF0aW9uOiBvcGVyYXRpb24gfSk7XG5cdCAgICAgICAgfSk7XG5cdCAgICB9O1xuXHQgICAgVm9pZFNpZ25lci5wcm90b3R5cGUuc2lnbk1lc3NhZ2UgPSBmdW5jdGlvbiAobWVzc2FnZSkge1xuXHQgICAgICAgIHJldHVybiB0aGlzLl9mYWlsKFwiVm9pZFNpZ25lciBjYW5ub3Qgc2lnbiBtZXNzYWdlc1wiLCBcInNpZ25NZXNzYWdlXCIpO1xuXHQgICAgfTtcblx0ICAgIFZvaWRTaWduZXIucHJvdG90eXBlLnNpZ25UcmFuc2FjdGlvbiA9IGZ1bmN0aW9uICh0cmFuc2FjdGlvbikge1xuXHQgICAgICAgIHJldHVybiB0aGlzLl9mYWlsKFwiVm9pZFNpZ25lciBjYW5ub3Qgc2lnbiB0cmFuc2FjdGlvbnNcIiwgXCJzaWduVHJhbnNhY3Rpb25cIik7XG5cdCAgICB9O1xuXHQgICAgVm9pZFNpZ25lci5wcm90b3R5cGUuX3NpZ25UeXBlZERhdGEgPSBmdW5jdGlvbiAoZG9tYWluLCB0eXBlcywgdmFsdWUpIHtcblx0ICAgICAgICByZXR1cm4gdGhpcy5fZmFpbChcIlZvaWRTaWduZXIgY2Fubm90IHNpZ24gdHlwZWQgZGF0YVwiLCBcInNpZ25UeXBlZERhdGFcIik7XG5cdCAgICB9O1xuXHQgICAgVm9pZFNpZ25lci5wcm90b3R5cGUuY29ubmVjdCA9IGZ1bmN0aW9uIChwcm92aWRlcikge1xuXHQgICAgICAgIHJldHVybiBuZXcgVm9pZFNpZ25lcih0aGlzLmFkZHJlc3MsIHByb3ZpZGVyKTtcblx0ICAgIH07XG5cdCAgICByZXR1cm4gVm9pZFNpZ25lcjtcblx0fShTaWduZXIpKTtcblx0ZXhwb3J0cy5Wb2lkU2lnbmVyID0gVm9pZFNpZ25lcjtcblxuXHR9KTtcblxuXHR2YXIgaW5kZXgkYyA9IC8qQF9fUFVSRV9fKi9nZXREZWZhdWx0RXhwb3J0RnJvbUNqcyhsaWIkYyk7XG5cblx0dmFyIG1pbmltYWxpc3RpY0Fzc2VydCA9IGFzc2VydDtcblxuXHRmdW5jdGlvbiBhc3NlcnQodmFsLCBtc2cpIHtcblx0ICBpZiAoIXZhbClcblx0ICAgIHRocm93IG5ldyBFcnJvcihtc2cgfHwgJ0Fzc2VydGlvbiBmYWlsZWQnKTtcblx0fVxuXG5cdGFzc2VydC5lcXVhbCA9IGZ1bmN0aW9uIGFzc2VydEVxdWFsKGwsIHIsIG1zZykge1xuXHQgIGlmIChsICE9IHIpXG5cdCAgICB0aHJvdyBuZXcgRXJyb3IobXNnIHx8ICgnQXNzZXJ0aW9uIGZhaWxlZDogJyArIGwgKyAnICE9ICcgKyByKSk7XG5cdH07XG5cblx0dmFyIHV0aWxzXzEgPSBjcmVhdGVDb21tb25qc01vZHVsZShmdW5jdGlvbiAobW9kdWxlLCBleHBvcnRzKSB7XG5cdCd1c2Ugc3RyaWN0JztcblxuXHR2YXIgdXRpbHMgPSBleHBvcnRzO1xuXG5cdGZ1bmN0aW9uIHRvQXJyYXkobXNnLCBlbmMpIHtcblx0ICBpZiAoQXJyYXkuaXNBcnJheShtc2cpKVxuXHQgICAgcmV0dXJuIG1zZy5zbGljZSgpO1xuXHQgIGlmICghbXNnKVxuXHQgICAgcmV0dXJuIFtdO1xuXHQgIHZhciByZXMgPSBbXTtcblx0ICBpZiAodHlwZW9mIG1zZyAhPT0gJ3N0cmluZycpIHtcblx0ICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbXNnLmxlbmd0aDsgaSsrKVxuXHQgICAgICByZXNbaV0gPSBtc2dbaV0gfCAwO1xuXHQgICAgcmV0dXJuIHJlcztcblx0ICB9XG5cdCAgaWYgKGVuYyA9PT0gJ2hleCcpIHtcblx0ICAgIG1zZyA9IG1zZy5yZXBsYWNlKC9bXmEtejAtOV0rL2lnLCAnJyk7XG5cdCAgICBpZiAobXNnLmxlbmd0aCAlIDIgIT09IDApXG5cdCAgICAgIG1zZyA9ICcwJyArIG1zZztcblx0ICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbXNnLmxlbmd0aDsgaSArPSAyKVxuXHQgICAgICByZXMucHVzaChwYXJzZUludChtc2dbaV0gKyBtc2dbaSArIDFdLCAxNikpO1xuXHQgIH0gZWxzZSB7XG5cdCAgICBmb3IgKHZhciBpID0gMDsgaSA8IG1zZy5sZW5ndGg7IGkrKykge1xuXHQgICAgICB2YXIgYyA9IG1zZy5jaGFyQ29kZUF0KGkpO1xuXHQgICAgICB2YXIgaGkgPSBjID4+IDg7XG5cdCAgICAgIHZhciBsbyA9IGMgJiAweGZmO1xuXHQgICAgICBpZiAoaGkpXG5cdCAgICAgICAgcmVzLnB1c2goaGksIGxvKTtcblx0ICAgICAgZWxzZVxuXHQgICAgICAgIHJlcy5wdXNoKGxvKTtcblx0ICAgIH1cblx0ICB9XG5cdCAgcmV0dXJuIHJlcztcblx0fVxuXHR1dGlscy50b0FycmF5ID0gdG9BcnJheTtcblxuXHRmdW5jdGlvbiB6ZXJvMih3b3JkKSB7XG5cdCAgaWYgKHdvcmQubGVuZ3RoID09PSAxKVxuXHQgICAgcmV0dXJuICcwJyArIHdvcmQ7XG5cdCAgZWxzZVxuXHQgICAgcmV0dXJuIHdvcmQ7XG5cdH1cblx0dXRpbHMuemVybzIgPSB6ZXJvMjtcblxuXHRmdW5jdGlvbiB0b0hleChtc2cpIHtcblx0ICB2YXIgcmVzID0gJyc7XG5cdCAgZm9yICh2YXIgaSA9IDA7IGkgPCBtc2cubGVuZ3RoOyBpKyspXG5cdCAgICByZXMgKz0gemVybzIobXNnW2ldLnRvU3RyaW5nKDE2KSk7XG5cdCAgcmV0dXJuIHJlcztcblx0fVxuXHR1dGlscy50b0hleCA9IHRvSGV4O1xuXG5cdHV0aWxzLmVuY29kZSA9IGZ1bmN0aW9uIGVuY29kZShhcnIsIGVuYykge1xuXHQgIGlmIChlbmMgPT09ICdoZXgnKVxuXHQgICAgcmV0dXJuIHRvSGV4KGFycik7XG5cdCAgZWxzZVxuXHQgICAgcmV0dXJuIGFycjtcblx0fTtcblx0fSk7XG5cblx0dmFyIHV0aWxzXzEkMSA9IGNyZWF0ZUNvbW1vbmpzTW9kdWxlKGZ1bmN0aW9uIChtb2R1bGUsIGV4cG9ydHMpIHtcblx0J3VzZSBzdHJpY3QnO1xuXG5cdHZhciB1dGlscyA9IGV4cG9ydHM7XG5cblxuXG5cblx0dXRpbHMuYXNzZXJ0ID0gbWluaW1hbGlzdGljQXNzZXJ0O1xuXHR1dGlscy50b0FycmF5ID0gdXRpbHNfMS50b0FycmF5O1xuXHR1dGlscy56ZXJvMiA9IHV0aWxzXzEuemVybzI7XG5cdHV0aWxzLnRvSGV4ID0gdXRpbHNfMS50b0hleDtcblx0dXRpbHMuZW5jb2RlID0gdXRpbHNfMS5lbmNvZGU7XG5cblx0Ly8gUmVwcmVzZW50IG51bSBpbiBhIHctTkFGIGZvcm1cblx0ZnVuY3Rpb24gZ2V0TkFGKG51bSwgdywgYml0cykge1xuXHQgIHZhciBuYWYgPSBuZXcgQXJyYXkoTWF0aC5tYXgobnVtLmJpdExlbmd0aCgpLCBiaXRzKSArIDEpO1xuXHQgIG5hZi5maWxsKDApO1xuXG5cdCAgdmFyIHdzID0gMSA8PCAodyArIDEpO1xuXHQgIHZhciBrID0gbnVtLmNsb25lKCk7XG5cblx0ICBmb3IgKHZhciBpID0gMDsgaSA8IG5hZi5sZW5ndGg7IGkrKykge1xuXHQgICAgdmFyIHo7XG5cdCAgICB2YXIgbW9kID0gay5hbmRsbih3cyAtIDEpO1xuXHQgICAgaWYgKGsuaXNPZGQoKSkge1xuXHQgICAgICBpZiAobW9kID4gKHdzID4+IDEpIC0gMSlcblx0ICAgICAgICB6ID0gKHdzID4+IDEpIC0gbW9kO1xuXHQgICAgICBlbHNlXG5cdCAgICAgICAgeiA9IG1vZDtcblx0ICAgICAgay5pc3Vibih6KTtcblx0ICAgIH0gZWxzZSB7XG5cdCAgICAgIHogPSAwO1xuXHQgICAgfVxuXG5cdCAgICBuYWZbaV0gPSB6O1xuXHQgICAgay5pdXNocm4oMSk7XG5cdCAgfVxuXG5cdCAgcmV0dXJuIG5hZjtcblx0fVxuXHR1dGlscy5nZXROQUYgPSBnZXROQUY7XG5cblx0Ly8gUmVwcmVzZW50IGsxLCBrMiBpbiBhIEpvaW50IFNwYXJzZSBGb3JtXG5cdGZ1bmN0aW9uIGdldEpTRihrMSwgazIpIHtcblx0ICB2YXIganNmID0gW1xuXHQgICAgW10sXG5cdCAgICBbXSxcblx0ICBdO1xuXG5cdCAgazEgPSBrMS5jbG9uZSgpO1xuXHQgIGsyID0gazIuY2xvbmUoKTtcblx0ICB2YXIgZDEgPSAwO1xuXHQgIHZhciBkMiA9IDA7XG5cdCAgdmFyIG04O1xuXHQgIHdoaWxlIChrMS5jbXBuKC1kMSkgPiAwIHx8IGsyLmNtcG4oLWQyKSA+IDApIHtcblx0ICAgIC8vIEZpcnN0IHBoYXNlXG5cdCAgICB2YXIgbTE0ID0gKGsxLmFuZGxuKDMpICsgZDEpICYgMztcblx0ICAgIHZhciBtMjQgPSAoazIuYW5kbG4oMykgKyBkMikgJiAzO1xuXHQgICAgaWYgKG0xNCA9PT0gMylcblx0ICAgICAgbTE0ID0gLTE7XG5cdCAgICBpZiAobTI0ID09PSAzKVxuXHQgICAgICBtMjQgPSAtMTtcblx0ICAgIHZhciB1MTtcblx0ICAgIGlmICgobTE0ICYgMSkgPT09IDApIHtcblx0ICAgICAgdTEgPSAwO1xuXHQgICAgfSBlbHNlIHtcblx0ICAgICAgbTggPSAoazEuYW5kbG4oNykgKyBkMSkgJiA3O1xuXHQgICAgICBpZiAoKG04ID09PSAzIHx8IG04ID09PSA1KSAmJiBtMjQgPT09IDIpXG5cdCAgICAgICAgdTEgPSAtbTE0O1xuXHQgICAgICBlbHNlXG5cdCAgICAgICAgdTEgPSBtMTQ7XG5cdCAgICB9XG5cdCAgICBqc2ZbMF0ucHVzaCh1MSk7XG5cblx0ICAgIHZhciB1Mjtcblx0ICAgIGlmICgobTI0ICYgMSkgPT09IDApIHtcblx0ICAgICAgdTIgPSAwO1xuXHQgICAgfSBlbHNlIHtcblx0ICAgICAgbTggPSAoazIuYW5kbG4oNykgKyBkMikgJiA3O1xuXHQgICAgICBpZiAoKG04ID09PSAzIHx8IG04ID09PSA1KSAmJiBtMTQgPT09IDIpXG5cdCAgICAgICAgdTIgPSAtbTI0O1xuXHQgICAgICBlbHNlXG5cdCAgICAgICAgdTIgPSBtMjQ7XG5cdCAgICB9XG5cdCAgICBqc2ZbMV0ucHVzaCh1Mik7XG5cblx0ICAgIC8vIFNlY29uZCBwaGFzZVxuXHQgICAgaWYgKDIgKiBkMSA9PT0gdTEgKyAxKVxuXHQgICAgICBkMSA9IDEgLSBkMTtcblx0ICAgIGlmICgyICogZDIgPT09IHUyICsgMSlcblx0ICAgICAgZDIgPSAxIC0gZDI7XG5cdCAgICBrMS5pdXNocm4oMSk7XG5cdCAgICBrMi5pdXNocm4oMSk7XG5cdCAgfVxuXG5cdCAgcmV0dXJuIGpzZjtcblx0fVxuXHR1dGlscy5nZXRKU0YgPSBnZXRKU0Y7XG5cblx0ZnVuY3Rpb24gY2FjaGVkUHJvcGVydHkob2JqLCBuYW1lLCBjb21wdXRlcikge1xuXHQgIHZhciBrZXkgPSAnXycgKyBuYW1lO1xuXHQgIG9iai5wcm90b3R5cGVbbmFtZV0gPSBmdW5jdGlvbiBjYWNoZWRQcm9wZXJ0eSgpIHtcblx0ICAgIHJldHVybiB0aGlzW2tleV0gIT09IHVuZGVmaW5lZCA/IHRoaXNba2V5XSA6XG5cdCAgICAgIHRoaXNba2V5XSA9IGNvbXB1dGVyLmNhbGwodGhpcyk7XG5cdCAgfTtcblx0fVxuXHR1dGlscy5jYWNoZWRQcm9wZXJ0eSA9IGNhY2hlZFByb3BlcnR5O1xuXG5cdGZ1bmN0aW9uIHBhcnNlQnl0ZXMoYnl0ZXMpIHtcblx0ICByZXR1cm4gdHlwZW9mIGJ5dGVzID09PSAnc3RyaW5nJyA/IHV0aWxzLnRvQXJyYXkoYnl0ZXMsICdoZXgnKSA6XG5cdCAgICBieXRlcztcblx0fVxuXHR1dGlscy5wYXJzZUJ5dGVzID0gcGFyc2VCeXRlcztcblxuXHRmdW5jdGlvbiBpbnRGcm9tTEUoYnl0ZXMpIHtcblx0ICByZXR1cm4gbmV3IGJuKGJ5dGVzLCAnaGV4JywgJ2xlJyk7XG5cdH1cblx0dXRpbHMuaW50RnJvbUxFID0gaW50RnJvbUxFO1xuXHR9KTtcblxuXHQndXNlIHN0cmljdCc7XG5cblxuXG5cdHZhciBnZXROQUYgPSB1dGlsc18xJDEuZ2V0TkFGO1xuXHR2YXIgZ2V0SlNGID0gdXRpbHNfMSQxLmdldEpTRjtcblx0dmFyIGFzc2VydCQxID0gdXRpbHNfMSQxLmFzc2VydDtcblxuXHRmdW5jdGlvbiBCYXNlQ3VydmUodHlwZSwgY29uZikge1xuXHQgIHRoaXMudHlwZSA9IHR5cGU7XG5cdCAgdGhpcy5wID0gbmV3IGJuKGNvbmYucCwgMTYpO1xuXG5cdCAgLy8gVXNlIE1vbnRnb21lcnksIHdoZW4gdGhlcmUgaXMgbm8gZmFzdCByZWR1Y3Rpb24gZm9yIHRoZSBwcmltZVxuXHQgIHRoaXMucmVkID0gY29uZi5wcmltZSA/IGJuLnJlZChjb25mLnByaW1lKSA6IGJuLm1vbnQodGhpcy5wKTtcblxuXHQgIC8vIFVzZWZ1bCBmb3IgbWFueSBjdXJ2ZXNcblx0ICB0aGlzLnplcm8gPSBuZXcgYm4oMCkudG9SZWQodGhpcy5yZWQpO1xuXHQgIHRoaXMub25lID0gbmV3IGJuKDEpLnRvUmVkKHRoaXMucmVkKTtcblx0ICB0aGlzLnR3byA9IG5ldyBibigyKS50b1JlZCh0aGlzLnJlZCk7XG5cblx0ICAvLyBDdXJ2ZSBjb25maWd1cmF0aW9uLCBvcHRpb25hbFxuXHQgIHRoaXMubiA9IGNvbmYubiAmJiBuZXcgYm4oY29uZi5uLCAxNik7XG5cdCAgdGhpcy5nID0gY29uZi5nICYmIHRoaXMucG9pbnRGcm9tSlNPTihjb25mLmcsIGNvbmYuZ1JlZCk7XG5cblx0ICAvLyBUZW1wb3JhcnkgYXJyYXlzXG5cdCAgdGhpcy5fd25hZlQxID0gbmV3IEFycmF5KDQpO1xuXHQgIHRoaXMuX3duYWZUMiA9IG5ldyBBcnJheSg0KTtcblx0ICB0aGlzLl93bmFmVDMgPSBuZXcgQXJyYXkoNCk7XG5cdCAgdGhpcy5fd25hZlQ0ID0gbmV3IEFycmF5KDQpO1xuXG5cdCAgdGhpcy5fYml0TGVuZ3RoID0gdGhpcy5uID8gdGhpcy5uLmJpdExlbmd0aCgpIDogMDtcblxuXHQgIC8vIEdlbmVyYWxpemVkIEdyZWcgTWF4d2VsbCdzIHRyaWNrXG5cdCAgdmFyIGFkanVzdENvdW50ID0gdGhpcy5uICYmIHRoaXMucC5kaXYodGhpcy5uKTtcblx0ICBpZiAoIWFkanVzdENvdW50IHx8IGFkanVzdENvdW50LmNtcG4oMTAwKSA+IDApIHtcblx0ICAgIHRoaXMucmVkTiA9IG51bGw7XG5cdCAgfSBlbHNlIHtcblx0ICAgIHRoaXMuX21heHdlbGxUcmljayA9IHRydWU7XG5cdCAgICB0aGlzLnJlZE4gPSB0aGlzLm4udG9SZWQodGhpcy5yZWQpO1xuXHQgIH1cblx0fVxuXHR2YXIgYmFzZSA9IEJhc2VDdXJ2ZTtcblxuXHRCYXNlQ3VydmUucHJvdG90eXBlLnBvaW50ID0gZnVuY3Rpb24gcG9pbnQoKSB7XG5cdCAgdGhyb3cgbmV3IEVycm9yKCdOb3QgaW1wbGVtZW50ZWQnKTtcblx0fTtcblxuXHRCYXNlQ3VydmUucHJvdG90eXBlLnZhbGlkYXRlID0gZnVuY3Rpb24gdmFsaWRhdGUoKSB7XG5cdCAgdGhyb3cgbmV3IEVycm9yKCdOb3QgaW1wbGVtZW50ZWQnKTtcblx0fTtcblxuXHRCYXNlQ3VydmUucHJvdG90eXBlLl9maXhlZE5hZk11bCA9IGZ1bmN0aW9uIF9maXhlZE5hZk11bChwLCBrKSB7XG5cdCAgYXNzZXJ0JDEocC5wcmVjb21wdXRlZCk7XG5cdCAgdmFyIGRvdWJsZXMgPSBwLl9nZXREb3VibGVzKCk7XG5cblx0ICB2YXIgbmFmID0gZ2V0TkFGKGssIDEsIHRoaXMuX2JpdExlbmd0aCk7XG5cdCAgdmFyIEkgPSAoMSA8PCAoZG91Ymxlcy5zdGVwICsgMSkpIC0gKGRvdWJsZXMuc3RlcCAlIDIgPT09IDAgPyAyIDogMSk7XG5cdCAgSSAvPSAzO1xuXG5cdCAgLy8gVHJhbnNsYXRlIGludG8gbW9yZSB3aW5kb3dlZCBmb3JtXG5cdCAgdmFyIHJlcHIgPSBbXTtcblx0ICB2YXIgajtcblx0ICB2YXIgbmFmVztcblx0ICBmb3IgKGogPSAwOyBqIDwgbmFmLmxlbmd0aDsgaiArPSBkb3VibGVzLnN0ZXApIHtcblx0ICAgIG5hZlcgPSAwO1xuXHQgICAgZm9yICh2YXIgbCA9IGogKyBkb3VibGVzLnN0ZXAgLSAxOyBsID49IGo7IGwtLSlcblx0ICAgICAgbmFmVyA9IChuYWZXIDw8IDEpICsgbmFmW2xdO1xuXHQgICAgcmVwci5wdXNoKG5hZlcpO1xuXHQgIH1cblxuXHQgIHZhciBhID0gdGhpcy5qcG9pbnQobnVsbCwgbnVsbCwgbnVsbCk7XG5cdCAgdmFyIGIgPSB0aGlzLmpwb2ludChudWxsLCBudWxsLCBudWxsKTtcblx0ICBmb3IgKHZhciBpID0gSTsgaSA+IDA7IGktLSkge1xuXHQgICAgZm9yIChqID0gMDsgaiA8IHJlcHIubGVuZ3RoOyBqKyspIHtcblx0ICAgICAgbmFmVyA9IHJlcHJbal07XG5cdCAgICAgIGlmIChuYWZXID09PSBpKVxuXHQgICAgICAgIGIgPSBiLm1peGVkQWRkKGRvdWJsZXMucG9pbnRzW2pdKTtcblx0ICAgICAgZWxzZSBpZiAobmFmVyA9PT0gLWkpXG5cdCAgICAgICAgYiA9IGIubWl4ZWRBZGQoZG91Ymxlcy5wb2ludHNbal0ubmVnKCkpO1xuXHQgICAgfVxuXHQgICAgYSA9IGEuYWRkKGIpO1xuXHQgIH1cblx0ICByZXR1cm4gYS50b1AoKTtcblx0fTtcblxuXHRCYXNlQ3VydmUucHJvdG90eXBlLl93bmFmTXVsID0gZnVuY3Rpb24gX3duYWZNdWwocCwgaykge1xuXHQgIHZhciB3ID0gNDtcblxuXHQgIC8vIFByZWNvbXB1dGUgd2luZG93XG5cdCAgdmFyIG5hZlBvaW50cyA9IHAuX2dldE5BRlBvaW50cyh3KTtcblx0ICB3ID0gbmFmUG9pbnRzLnduZDtcblx0ICB2YXIgd25kID0gbmFmUG9pbnRzLnBvaW50cztcblxuXHQgIC8vIEdldCBOQUYgZm9ybVxuXHQgIHZhciBuYWYgPSBnZXROQUYoaywgdywgdGhpcy5fYml0TGVuZ3RoKTtcblxuXHQgIC8vIEFkZCBgdGhpc2AqKE4rMSkgZm9yIGV2ZXJ5IHctTkFGIGluZGV4XG5cdCAgdmFyIGFjYyA9IHRoaXMuanBvaW50KG51bGwsIG51bGwsIG51bGwpO1xuXHQgIGZvciAodmFyIGkgPSBuYWYubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcblx0ICAgIC8vIENvdW50IHplcm9lc1xuXHQgICAgZm9yICh2YXIgbCA9IDA7IGkgPj0gMCAmJiBuYWZbaV0gPT09IDA7IGktLSlcblx0ICAgICAgbCsrO1xuXHQgICAgaWYgKGkgPj0gMClcblx0ICAgICAgbCsrO1xuXHQgICAgYWNjID0gYWNjLmRibHAobCk7XG5cblx0ICAgIGlmIChpIDwgMClcblx0ICAgICAgYnJlYWs7XG5cdCAgICB2YXIgeiA9IG5hZltpXTtcblx0ICAgIGFzc2VydCQxKHogIT09IDApO1xuXHQgICAgaWYgKHAudHlwZSA9PT0gJ2FmZmluZScpIHtcblx0ICAgICAgLy8gSiArLSBQXG5cdCAgICAgIGlmICh6ID4gMClcblx0ICAgICAgICBhY2MgPSBhY2MubWl4ZWRBZGQod25kWyh6IC0gMSkgPj4gMV0pO1xuXHQgICAgICBlbHNlXG5cdCAgICAgICAgYWNjID0gYWNjLm1peGVkQWRkKHduZFsoLXogLSAxKSA+PiAxXS5uZWcoKSk7XG5cdCAgICB9IGVsc2Uge1xuXHQgICAgICAvLyBKICstIEpcblx0ICAgICAgaWYgKHogPiAwKVxuXHQgICAgICAgIGFjYyA9IGFjYy5hZGQod25kWyh6IC0gMSkgPj4gMV0pO1xuXHQgICAgICBlbHNlXG5cdCAgICAgICAgYWNjID0gYWNjLmFkZCh3bmRbKC16IC0gMSkgPj4gMV0ubmVnKCkpO1xuXHQgICAgfVxuXHQgIH1cblx0ICByZXR1cm4gcC50eXBlID09PSAnYWZmaW5lJyA/IGFjYy50b1AoKSA6IGFjYztcblx0fTtcblxuXHRCYXNlQ3VydmUucHJvdG90eXBlLl93bmFmTXVsQWRkID0gZnVuY3Rpb24gX3duYWZNdWxBZGQoZGVmVyxcblx0ICBwb2ludHMsXG5cdCAgY29lZmZzLFxuXHQgIGxlbixcblx0ICBqYWNvYmlhblJlc3VsdCkge1xuXHQgIHZhciB3bmRXaWR0aCA9IHRoaXMuX3duYWZUMTtcblx0ICB2YXIgd25kID0gdGhpcy5fd25hZlQyO1xuXHQgIHZhciBuYWYgPSB0aGlzLl93bmFmVDM7XG5cblx0ICAvLyBGaWxsIGFsbCBhcnJheXNcblx0ICB2YXIgbWF4ID0gMDtcblx0ICB2YXIgaTtcblx0ICB2YXIgajtcblx0ICB2YXIgcDtcblx0ICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcblx0ICAgIHAgPSBwb2ludHNbaV07XG5cdCAgICB2YXIgbmFmUG9pbnRzID0gcC5fZ2V0TkFGUG9pbnRzKGRlZlcpO1xuXHQgICAgd25kV2lkdGhbaV0gPSBuYWZQb2ludHMud25kO1xuXHQgICAgd25kW2ldID0gbmFmUG9pbnRzLnBvaW50cztcblx0ICB9XG5cblx0ICAvLyBDb21iIHNtYWxsIHdpbmRvdyBOQUZzXG5cdCAgZm9yIChpID0gbGVuIC0gMTsgaSA+PSAxOyBpIC09IDIpIHtcblx0ICAgIHZhciBhID0gaSAtIDE7XG5cdCAgICB2YXIgYiA9IGk7XG5cdCAgICBpZiAod25kV2lkdGhbYV0gIT09IDEgfHwgd25kV2lkdGhbYl0gIT09IDEpIHtcblx0ICAgICAgbmFmW2FdID0gZ2V0TkFGKGNvZWZmc1thXSwgd25kV2lkdGhbYV0sIHRoaXMuX2JpdExlbmd0aCk7XG5cdCAgICAgIG5hZltiXSA9IGdldE5BRihjb2VmZnNbYl0sIHduZFdpZHRoW2JdLCB0aGlzLl9iaXRMZW5ndGgpO1xuXHQgICAgICBtYXggPSBNYXRoLm1heChuYWZbYV0ubGVuZ3RoLCBtYXgpO1xuXHQgICAgICBtYXggPSBNYXRoLm1heChuYWZbYl0ubGVuZ3RoLCBtYXgpO1xuXHQgICAgICBjb250aW51ZTtcblx0ICAgIH1cblxuXHQgICAgdmFyIGNvbWIgPSBbXG5cdCAgICAgIHBvaW50c1thXSwgLyogMSAqL1xuXHQgICAgICBudWxsLCAvKiAzICovXG5cdCAgICAgIG51bGwsIC8qIDUgKi9cblx0ICAgICAgcG9pbnRzW2JdLCAvKiA3ICovXG5cdCAgICBdO1xuXG5cdCAgICAvLyBUcnkgdG8gYXZvaWQgUHJvamVjdGl2ZSBwb2ludHMsIGlmIHBvc3NpYmxlXG5cdCAgICBpZiAocG9pbnRzW2FdLnkuY21wKHBvaW50c1tiXS55KSA9PT0gMCkge1xuXHQgICAgICBjb21iWzFdID0gcG9pbnRzW2FdLmFkZChwb2ludHNbYl0pO1xuXHQgICAgICBjb21iWzJdID0gcG9pbnRzW2FdLnRvSigpLm1peGVkQWRkKHBvaW50c1tiXS5uZWcoKSk7XG5cdCAgICB9IGVsc2UgaWYgKHBvaW50c1thXS55LmNtcChwb2ludHNbYl0ueS5yZWROZWcoKSkgPT09IDApIHtcblx0ICAgICAgY29tYlsxXSA9IHBvaW50c1thXS50b0ooKS5taXhlZEFkZChwb2ludHNbYl0pO1xuXHQgICAgICBjb21iWzJdID0gcG9pbnRzW2FdLmFkZChwb2ludHNbYl0ubmVnKCkpO1xuXHQgICAgfSBlbHNlIHtcblx0ICAgICAgY29tYlsxXSA9IHBvaW50c1thXS50b0ooKS5taXhlZEFkZChwb2ludHNbYl0pO1xuXHQgICAgICBjb21iWzJdID0gcG9pbnRzW2FdLnRvSigpLm1peGVkQWRkKHBvaW50c1tiXS5uZWcoKSk7XG5cdCAgICB9XG5cblx0ICAgIHZhciBpbmRleCA9IFtcblx0ICAgICAgLTMsIC8qIC0xIC0xICovXG5cdCAgICAgIC0xLCAvKiAtMSAwICovXG5cdCAgICAgIC01LCAvKiAtMSAxICovXG5cdCAgICAgIC03LCAvKiAwIC0xICovXG5cdCAgICAgIDAsIC8qIDAgMCAqL1xuXHQgICAgICA3LCAvKiAwIDEgKi9cblx0ICAgICAgNSwgLyogMSAtMSAqL1xuXHQgICAgICAxLCAvKiAxIDAgKi9cblx0ICAgICAgMywgIC8qIDEgMSAqL1xuXHQgICAgXTtcblxuXHQgICAgdmFyIGpzZiA9IGdldEpTRihjb2VmZnNbYV0sIGNvZWZmc1tiXSk7XG5cdCAgICBtYXggPSBNYXRoLm1heChqc2ZbMF0ubGVuZ3RoLCBtYXgpO1xuXHQgICAgbmFmW2FdID0gbmV3IEFycmF5KG1heCk7XG5cdCAgICBuYWZbYl0gPSBuZXcgQXJyYXkobWF4KTtcblx0ICAgIGZvciAoaiA9IDA7IGogPCBtYXg7IGorKykge1xuXHQgICAgICB2YXIgamEgPSBqc2ZbMF1bal0gfCAwO1xuXHQgICAgICB2YXIgamIgPSBqc2ZbMV1bal0gfCAwO1xuXG5cdCAgICAgIG5hZlthXVtqXSA9IGluZGV4WyhqYSArIDEpICogMyArIChqYiArIDEpXTtcblx0ICAgICAgbmFmW2JdW2pdID0gMDtcblx0ICAgICAgd25kW2FdID0gY29tYjtcblx0ICAgIH1cblx0ICB9XG5cblx0ICB2YXIgYWNjID0gdGhpcy5qcG9pbnQobnVsbCwgbnVsbCwgbnVsbCk7XG5cdCAgdmFyIHRtcCA9IHRoaXMuX3duYWZUNDtcblx0ICBmb3IgKGkgPSBtYXg7IGkgPj0gMDsgaS0tKSB7XG5cdCAgICB2YXIgayA9IDA7XG5cblx0ICAgIHdoaWxlIChpID49IDApIHtcblx0ICAgICAgdmFyIHplcm8gPSB0cnVlO1xuXHQgICAgICBmb3IgKGogPSAwOyBqIDwgbGVuOyBqKyspIHtcblx0ICAgICAgICB0bXBbal0gPSBuYWZbal1baV0gfCAwO1xuXHQgICAgICAgIGlmICh0bXBbal0gIT09IDApXG5cdCAgICAgICAgICB6ZXJvID0gZmFsc2U7XG5cdCAgICAgIH1cblx0ICAgICAgaWYgKCF6ZXJvKVxuXHQgICAgICAgIGJyZWFrO1xuXHQgICAgICBrKys7XG5cdCAgICAgIGktLTtcblx0ICAgIH1cblx0ICAgIGlmIChpID49IDApXG5cdCAgICAgIGsrKztcblx0ICAgIGFjYyA9IGFjYy5kYmxwKGspO1xuXHQgICAgaWYgKGkgPCAwKVxuXHQgICAgICBicmVhaztcblxuXHQgICAgZm9yIChqID0gMDsgaiA8IGxlbjsgaisrKSB7XG5cdCAgICAgIHZhciB6ID0gdG1wW2pdO1xuXHQgICAgICBwO1xuXHQgICAgICBpZiAoeiA9PT0gMClcblx0ICAgICAgICBjb250aW51ZTtcblx0ICAgICAgZWxzZSBpZiAoeiA+IDApXG5cdCAgICAgICAgcCA9IHduZFtqXVsoeiAtIDEpID4+IDFdO1xuXHQgICAgICBlbHNlIGlmICh6IDwgMClcblx0ICAgICAgICBwID0gd25kW2pdWygteiAtIDEpID4+IDFdLm5lZygpO1xuXG5cdCAgICAgIGlmIChwLnR5cGUgPT09ICdhZmZpbmUnKVxuXHQgICAgICAgIGFjYyA9IGFjYy5taXhlZEFkZChwKTtcblx0ICAgICAgZWxzZVxuXHQgICAgICAgIGFjYyA9IGFjYy5hZGQocCk7XG5cdCAgICB9XG5cdCAgfVxuXHQgIC8vIFplcm9pZnkgcmVmZXJlbmNlc1xuXHQgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkrKylcblx0ICAgIHduZFtpXSA9IG51bGw7XG5cblx0ICBpZiAoamFjb2JpYW5SZXN1bHQpXG5cdCAgICByZXR1cm4gYWNjO1xuXHQgIGVsc2Vcblx0ICAgIHJldHVybiBhY2MudG9QKCk7XG5cdH07XG5cblx0ZnVuY3Rpb24gQmFzZVBvaW50KGN1cnZlLCB0eXBlKSB7XG5cdCAgdGhpcy5jdXJ2ZSA9IGN1cnZlO1xuXHQgIHRoaXMudHlwZSA9IHR5cGU7XG5cdCAgdGhpcy5wcmVjb21wdXRlZCA9IG51bGw7XG5cdH1cblx0QmFzZUN1cnZlLkJhc2VQb2ludCA9IEJhc2VQb2ludDtcblxuXHRCYXNlUG9pbnQucHJvdG90eXBlLmVxID0gZnVuY3Rpb24gZXEoLypvdGhlciovKSB7XG5cdCAgdGhyb3cgbmV3IEVycm9yKCdOb3QgaW1wbGVtZW50ZWQnKTtcblx0fTtcblxuXHRCYXNlUG9pbnQucHJvdG90eXBlLnZhbGlkYXRlID0gZnVuY3Rpb24gdmFsaWRhdGUoKSB7XG5cdCAgcmV0dXJuIHRoaXMuY3VydmUudmFsaWRhdGUodGhpcyk7XG5cdH07XG5cblx0QmFzZUN1cnZlLnByb3RvdHlwZS5kZWNvZGVQb2ludCA9IGZ1bmN0aW9uIGRlY29kZVBvaW50KGJ5dGVzLCBlbmMpIHtcblx0ICBieXRlcyA9IHV0aWxzXzEkMS50b0FycmF5KGJ5dGVzLCBlbmMpO1xuXG5cdCAgdmFyIGxlbiA9IHRoaXMucC5ieXRlTGVuZ3RoKCk7XG5cblx0ICAvLyB1bmNvbXByZXNzZWQsIGh5YnJpZC1vZGQsIGh5YnJpZC1ldmVuXG5cdCAgaWYgKChieXRlc1swXSA9PT0gMHgwNCB8fCBieXRlc1swXSA9PT0gMHgwNiB8fCBieXRlc1swXSA9PT0gMHgwNykgJiZcblx0ICAgICAgYnl0ZXMubGVuZ3RoIC0gMSA9PT0gMiAqIGxlbikge1xuXHQgICAgaWYgKGJ5dGVzWzBdID09PSAweDA2KVxuXHQgICAgICBhc3NlcnQkMShieXRlc1tieXRlcy5sZW5ndGggLSAxXSAlIDIgPT09IDApO1xuXHQgICAgZWxzZSBpZiAoYnl0ZXNbMF0gPT09IDB4MDcpXG5cdCAgICAgIGFzc2VydCQxKGJ5dGVzW2J5dGVzLmxlbmd0aCAtIDFdICUgMiA9PT0gMSk7XG5cblx0ICAgIHZhciByZXMgPSAgdGhpcy5wb2ludChieXRlcy5zbGljZSgxLCAxICsgbGVuKSxcblx0ICAgICAgYnl0ZXMuc2xpY2UoMSArIGxlbiwgMSArIDIgKiBsZW4pKTtcblxuXHQgICAgcmV0dXJuIHJlcztcblx0ICB9IGVsc2UgaWYgKChieXRlc1swXSA9PT0gMHgwMiB8fCBieXRlc1swXSA9PT0gMHgwMykgJiZcblx0ICAgICAgICAgICAgICBieXRlcy5sZW5ndGggLSAxID09PSBsZW4pIHtcblx0ICAgIHJldHVybiB0aGlzLnBvaW50RnJvbVgoYnl0ZXMuc2xpY2UoMSwgMSArIGxlbiksIGJ5dGVzWzBdID09PSAweDAzKTtcblx0ICB9XG5cdCAgdGhyb3cgbmV3IEVycm9yKCdVbmtub3duIHBvaW50IGZvcm1hdCcpO1xuXHR9O1xuXG5cdEJhc2VQb2ludC5wcm90b3R5cGUuZW5jb2RlQ29tcHJlc3NlZCA9IGZ1bmN0aW9uIGVuY29kZUNvbXByZXNzZWQoZW5jKSB7XG5cdCAgcmV0dXJuIHRoaXMuZW5jb2RlKGVuYywgdHJ1ZSk7XG5cdH07XG5cblx0QmFzZVBvaW50LnByb3RvdHlwZS5fZW5jb2RlID0gZnVuY3Rpb24gX2VuY29kZShjb21wYWN0KSB7XG5cdCAgdmFyIGxlbiA9IHRoaXMuY3VydmUucC5ieXRlTGVuZ3RoKCk7XG5cdCAgdmFyIHggPSB0aGlzLmdldFgoKS50b0FycmF5KCdiZScsIGxlbik7XG5cblx0ICBpZiAoY29tcGFjdClcblx0ICAgIHJldHVybiBbIHRoaXMuZ2V0WSgpLmlzRXZlbigpID8gMHgwMiA6IDB4MDMgXS5jb25jYXQoeCk7XG5cblx0ICByZXR1cm4gWyAweDA0IF0uY29uY2F0KHgsIHRoaXMuZ2V0WSgpLnRvQXJyYXkoJ2JlJywgbGVuKSk7XG5cdH07XG5cblx0QmFzZVBvaW50LnByb3RvdHlwZS5lbmNvZGUgPSBmdW5jdGlvbiBlbmNvZGUoZW5jLCBjb21wYWN0KSB7XG5cdCAgcmV0dXJuIHV0aWxzXzEkMS5lbmNvZGUodGhpcy5fZW5jb2RlKGNvbXBhY3QpLCBlbmMpO1xuXHR9O1xuXG5cdEJhc2VQb2ludC5wcm90b3R5cGUucHJlY29tcHV0ZSA9IGZ1bmN0aW9uIHByZWNvbXB1dGUocG93ZXIpIHtcblx0ICBpZiAodGhpcy5wcmVjb21wdXRlZClcblx0ICAgIHJldHVybiB0aGlzO1xuXG5cdCAgdmFyIHByZWNvbXB1dGVkID0ge1xuXHQgICAgZG91YmxlczogbnVsbCxcblx0ICAgIG5hZjogbnVsbCxcblx0ICAgIGJldGE6IG51bGwsXG5cdCAgfTtcblx0ICBwcmVjb21wdXRlZC5uYWYgPSB0aGlzLl9nZXROQUZQb2ludHMoOCk7XG5cdCAgcHJlY29tcHV0ZWQuZG91YmxlcyA9IHRoaXMuX2dldERvdWJsZXMoNCwgcG93ZXIpO1xuXHQgIHByZWNvbXB1dGVkLmJldGEgPSB0aGlzLl9nZXRCZXRhKCk7XG5cdCAgdGhpcy5wcmVjb21wdXRlZCA9IHByZWNvbXB1dGVkO1xuXG5cdCAgcmV0dXJuIHRoaXM7XG5cdH07XG5cblx0QmFzZVBvaW50LnByb3RvdHlwZS5faGFzRG91YmxlcyA9IGZ1bmN0aW9uIF9oYXNEb3VibGVzKGspIHtcblx0ICBpZiAoIXRoaXMucHJlY29tcHV0ZWQpXG5cdCAgICByZXR1cm4gZmFsc2U7XG5cblx0ICB2YXIgZG91YmxlcyA9IHRoaXMucHJlY29tcHV0ZWQuZG91Ymxlcztcblx0ICBpZiAoIWRvdWJsZXMpXG5cdCAgICByZXR1cm4gZmFsc2U7XG5cblx0ICByZXR1cm4gZG91Ymxlcy5wb2ludHMubGVuZ3RoID49IE1hdGguY2VpbCgoay5iaXRMZW5ndGgoKSArIDEpIC8gZG91Ymxlcy5zdGVwKTtcblx0fTtcblxuXHRCYXNlUG9pbnQucHJvdG90eXBlLl9nZXREb3VibGVzID0gZnVuY3Rpb24gX2dldERvdWJsZXMoc3RlcCwgcG93ZXIpIHtcblx0ICBpZiAodGhpcy5wcmVjb21wdXRlZCAmJiB0aGlzLnByZWNvbXB1dGVkLmRvdWJsZXMpXG5cdCAgICByZXR1cm4gdGhpcy5wcmVjb21wdXRlZC5kb3VibGVzO1xuXG5cdCAgdmFyIGRvdWJsZXMgPSBbIHRoaXMgXTtcblx0ICB2YXIgYWNjID0gdGhpcztcblx0ICBmb3IgKHZhciBpID0gMDsgaSA8IHBvd2VyOyBpICs9IHN0ZXApIHtcblx0ICAgIGZvciAodmFyIGogPSAwOyBqIDwgc3RlcDsgaisrKVxuXHQgICAgICBhY2MgPSBhY2MuZGJsKCk7XG5cdCAgICBkb3VibGVzLnB1c2goYWNjKTtcblx0ICB9XG5cdCAgcmV0dXJuIHtcblx0ICAgIHN0ZXA6IHN0ZXAsXG5cdCAgICBwb2ludHM6IGRvdWJsZXMsXG5cdCAgfTtcblx0fTtcblxuXHRCYXNlUG9pbnQucHJvdG90eXBlLl9nZXROQUZQb2ludHMgPSBmdW5jdGlvbiBfZ2V0TkFGUG9pbnRzKHduZCkge1xuXHQgIGlmICh0aGlzLnByZWNvbXB1dGVkICYmIHRoaXMucHJlY29tcHV0ZWQubmFmKVxuXHQgICAgcmV0dXJuIHRoaXMucHJlY29tcHV0ZWQubmFmO1xuXG5cdCAgdmFyIHJlcyA9IFsgdGhpcyBdO1xuXHQgIHZhciBtYXggPSAoMSA8PCB3bmQpIC0gMTtcblx0ICB2YXIgZGJsID0gbWF4ID09PSAxID8gbnVsbCA6IHRoaXMuZGJsKCk7XG5cdCAgZm9yICh2YXIgaSA9IDE7IGkgPCBtYXg7IGkrKylcblx0ICAgIHJlc1tpXSA9IHJlc1tpIC0gMV0uYWRkKGRibCk7XG5cdCAgcmV0dXJuIHtcblx0ICAgIHduZDogd25kLFxuXHQgICAgcG9pbnRzOiByZXMsXG5cdCAgfTtcblx0fTtcblxuXHRCYXNlUG9pbnQucHJvdG90eXBlLl9nZXRCZXRhID0gZnVuY3Rpb24gX2dldEJldGEoKSB7XG5cdCAgcmV0dXJuIG51bGw7XG5cdH07XG5cblx0QmFzZVBvaW50LnByb3RvdHlwZS5kYmxwID0gZnVuY3Rpb24gZGJscChrKSB7XG5cdCAgdmFyIHIgPSB0aGlzO1xuXHQgIGZvciAodmFyIGkgPSAwOyBpIDwgazsgaSsrKVxuXHQgICAgciA9IHIuZGJsKCk7XG5cdCAgcmV0dXJuIHI7XG5cdH07XG5cblx0dmFyIGluaGVyaXRzX2Jyb3dzZXIgPSBjcmVhdGVDb21tb25qc01vZHVsZShmdW5jdGlvbiAobW9kdWxlKSB7XG5cdGlmICh0eXBlb2YgT2JqZWN0LmNyZWF0ZSA9PT0gJ2Z1bmN0aW9uJykge1xuXHQgIC8vIGltcGxlbWVudGF0aW9uIGZyb20gc3RhbmRhcmQgbm9kZS5qcyAndXRpbCcgbW9kdWxlXG5cdCAgbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBpbmhlcml0cyhjdG9yLCBzdXBlckN0b3IpIHtcblx0ICAgIGlmIChzdXBlckN0b3IpIHtcblx0ICAgICAgY3Rvci5zdXBlcl8gPSBzdXBlckN0b3I7XG5cdCAgICAgIGN0b3IucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckN0b3IucHJvdG90eXBlLCB7XG5cdCAgICAgICAgY29uc3RydWN0b3I6IHtcblx0ICAgICAgICAgIHZhbHVlOiBjdG9yLFxuXHQgICAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG5cdCAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcblx0ICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuXHQgICAgICAgIH1cblx0ICAgICAgfSk7XG5cdCAgICB9XG5cdCAgfTtcblx0fSBlbHNlIHtcblx0ICAvLyBvbGQgc2Nob29sIHNoaW0gZm9yIG9sZCBicm93c2Vyc1xuXHQgIG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaW5oZXJpdHMoY3Rvciwgc3VwZXJDdG9yKSB7XG5cdCAgICBpZiAoc3VwZXJDdG9yKSB7XG5cdCAgICAgIGN0b3Iuc3VwZXJfID0gc3VwZXJDdG9yO1xuXHQgICAgICB2YXIgVGVtcEN0b3IgPSBmdW5jdGlvbiAoKSB7fTtcblx0ICAgICAgVGVtcEN0b3IucHJvdG90eXBlID0gc3VwZXJDdG9yLnByb3RvdHlwZTtcblx0ICAgICAgY3Rvci5wcm90b3R5cGUgPSBuZXcgVGVtcEN0b3IoKTtcblx0ICAgICAgY3Rvci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBjdG9yO1xuXHQgICAgfVxuXHQgIH07XG5cdH1cblx0fSk7XG5cblx0J3VzZSBzdHJpY3QnO1xuXG5cblxuXG5cblxuXHR2YXIgYXNzZXJ0JDIgPSB1dGlsc18xJDEuYXNzZXJ0O1xuXG5cdGZ1bmN0aW9uIFNob3J0Q3VydmUoY29uZikge1xuXHQgIGJhc2UuY2FsbCh0aGlzLCAnc2hvcnQnLCBjb25mKTtcblxuXHQgIHRoaXMuYSA9IG5ldyBibihjb25mLmEsIDE2KS50b1JlZCh0aGlzLnJlZCk7XG5cdCAgdGhpcy5iID0gbmV3IGJuKGNvbmYuYiwgMTYpLnRvUmVkKHRoaXMucmVkKTtcblx0ICB0aGlzLnRpbnYgPSB0aGlzLnR3by5yZWRJbnZtKCk7XG5cblx0ICB0aGlzLnplcm9BID0gdGhpcy5hLmZyb21SZWQoKS5jbXBuKDApID09PSAwO1xuXHQgIHRoaXMudGhyZWVBID0gdGhpcy5hLmZyb21SZWQoKS5zdWIodGhpcy5wKS5jbXBuKC0zKSA9PT0gMDtcblxuXHQgIC8vIElmIHRoZSBjdXJ2ZSBpcyBlbmRvbW9ycGhpYywgcHJlY2FsY3VsYXRlIGJldGEgYW5kIGxhbWJkYVxuXHQgIHRoaXMuZW5kbyA9IHRoaXMuX2dldEVuZG9tb3JwaGlzbShjb25mKTtcblx0ICB0aGlzLl9lbmRvV25hZlQxID0gbmV3IEFycmF5KDQpO1xuXHQgIHRoaXMuX2VuZG9XbmFmVDIgPSBuZXcgQXJyYXkoNCk7XG5cdH1cblx0aW5oZXJpdHNfYnJvd3NlcihTaG9ydEN1cnZlLCBiYXNlKTtcblx0dmFyIHNob3J0XzEgPSBTaG9ydEN1cnZlO1xuXG5cdFNob3J0Q3VydmUucHJvdG90eXBlLl9nZXRFbmRvbW9ycGhpc20gPSBmdW5jdGlvbiBfZ2V0RW5kb21vcnBoaXNtKGNvbmYpIHtcblx0ICAvLyBObyBlZmZpY2llbnQgZW5kb21vcnBoaXNtXG5cdCAgaWYgKCF0aGlzLnplcm9BIHx8ICF0aGlzLmcgfHwgIXRoaXMubiB8fCB0aGlzLnAubW9kbigzKSAhPT0gMSlcblx0ICAgIHJldHVybjtcblxuXHQgIC8vIENvbXB1dGUgYmV0YSBhbmQgbGFtYmRhLCB0aGF0IGxhbWJkYSAqIFAgPSAoYmV0YSAqIFB4OyBQeSlcblx0ICB2YXIgYmV0YTtcblx0ICB2YXIgbGFtYmRhO1xuXHQgIGlmIChjb25mLmJldGEpIHtcblx0ICAgIGJldGEgPSBuZXcgYm4oY29uZi5iZXRhLCAxNikudG9SZWQodGhpcy5yZWQpO1xuXHQgIH0gZWxzZSB7XG5cdCAgICB2YXIgYmV0YXMgPSB0aGlzLl9nZXRFbmRvUm9vdHModGhpcy5wKTtcblx0ICAgIC8vIENob29zZSB0aGUgc21hbGxlc3QgYmV0YVxuXHQgICAgYmV0YSA9IGJldGFzWzBdLmNtcChiZXRhc1sxXSkgPCAwID8gYmV0YXNbMF0gOiBiZXRhc1sxXTtcblx0ICAgIGJldGEgPSBiZXRhLnRvUmVkKHRoaXMucmVkKTtcblx0ICB9XG5cdCAgaWYgKGNvbmYubGFtYmRhKSB7XG5cdCAgICBsYW1iZGEgPSBuZXcgYm4oY29uZi5sYW1iZGEsIDE2KTtcblx0ICB9IGVsc2Uge1xuXHQgICAgLy8gQ2hvb3NlIHRoZSBsYW1iZGEgdGhhdCBpcyBtYXRjaGluZyBzZWxlY3RlZCBiZXRhXG5cdCAgICB2YXIgbGFtYmRhcyA9IHRoaXMuX2dldEVuZG9Sb290cyh0aGlzLm4pO1xuXHQgICAgaWYgKHRoaXMuZy5tdWwobGFtYmRhc1swXSkueC5jbXAodGhpcy5nLngucmVkTXVsKGJldGEpKSA9PT0gMCkge1xuXHQgICAgICBsYW1iZGEgPSBsYW1iZGFzWzBdO1xuXHQgICAgfSBlbHNlIHtcblx0ICAgICAgbGFtYmRhID0gbGFtYmRhc1sxXTtcblx0ICAgICAgYXNzZXJ0JDIodGhpcy5nLm11bChsYW1iZGEpLnguY21wKHRoaXMuZy54LnJlZE11bChiZXRhKSkgPT09IDApO1xuXHQgICAgfVxuXHQgIH1cblxuXHQgIC8vIEdldCBiYXNpcyB2ZWN0b3JzLCB1c2VkIGZvciBiYWxhbmNlZCBsZW5ndGgtdHdvIHJlcHJlc2VudGF0aW9uXG5cdCAgdmFyIGJhc2lzO1xuXHQgIGlmIChjb25mLmJhc2lzKSB7XG5cdCAgICBiYXNpcyA9IGNvbmYuYmFzaXMubWFwKGZ1bmN0aW9uKHZlYykge1xuXHQgICAgICByZXR1cm4ge1xuXHQgICAgICAgIGE6IG5ldyBibih2ZWMuYSwgMTYpLFxuXHQgICAgICAgIGI6IG5ldyBibih2ZWMuYiwgMTYpLFxuXHQgICAgICB9O1xuXHQgICAgfSk7XG5cdCAgfSBlbHNlIHtcblx0ICAgIGJhc2lzID0gdGhpcy5fZ2V0RW5kb0Jhc2lzKGxhbWJkYSk7XG5cdCAgfVxuXG5cdCAgcmV0dXJuIHtcblx0ICAgIGJldGE6IGJldGEsXG5cdCAgICBsYW1iZGE6IGxhbWJkYSxcblx0ICAgIGJhc2lzOiBiYXNpcyxcblx0ICB9O1xuXHR9O1xuXG5cdFNob3J0Q3VydmUucHJvdG90eXBlLl9nZXRFbmRvUm9vdHMgPSBmdW5jdGlvbiBfZ2V0RW5kb1Jvb3RzKG51bSkge1xuXHQgIC8vIEZpbmQgcm9vdHMgb2YgZm9yIHheMiArIHggKyAxIGluIEZcblx0ICAvLyBSb290ID0gKC0xICstIFNxcnQoLTMpKSAvIDJcblx0ICAvL1xuXHQgIHZhciByZWQgPSBudW0gPT09IHRoaXMucCA/IHRoaXMucmVkIDogYm4ubW9udChudW0pO1xuXHQgIHZhciB0aW52ID0gbmV3IGJuKDIpLnRvUmVkKHJlZCkucmVkSW52bSgpO1xuXHQgIHZhciBudGludiA9IHRpbnYucmVkTmVnKCk7XG5cblx0ICB2YXIgcyA9IG5ldyBibigzKS50b1JlZChyZWQpLnJlZE5lZygpLnJlZFNxcnQoKS5yZWRNdWwodGludik7XG5cblx0ICB2YXIgbDEgPSBudGludi5yZWRBZGQocykuZnJvbVJlZCgpO1xuXHQgIHZhciBsMiA9IG50aW52LnJlZFN1YihzKS5mcm9tUmVkKCk7XG5cdCAgcmV0dXJuIFsgbDEsIGwyIF07XG5cdH07XG5cblx0U2hvcnRDdXJ2ZS5wcm90b3R5cGUuX2dldEVuZG9CYXNpcyA9IGZ1bmN0aW9uIF9nZXRFbmRvQmFzaXMobGFtYmRhKSB7XG5cdCAgLy8gYXByeFNxcnQgPj0gc3FydCh0aGlzLm4pXG5cdCAgdmFyIGFwcnhTcXJ0ID0gdGhpcy5uLnVzaHJuKE1hdGguZmxvb3IodGhpcy5uLmJpdExlbmd0aCgpIC8gMikpO1xuXG5cdCAgLy8gMy43NFxuXHQgIC8vIFJ1biBFR0NELCB1bnRpbCByKEwgKyAxKSA8IGFwcnhTcXJ0XG5cdCAgdmFyIHUgPSBsYW1iZGE7XG5cdCAgdmFyIHYgPSB0aGlzLm4uY2xvbmUoKTtcblx0ICB2YXIgeDEgPSBuZXcgYm4oMSk7XG5cdCAgdmFyIHkxID0gbmV3IGJuKDApO1xuXHQgIHZhciB4MiA9IG5ldyBibigwKTtcblx0ICB2YXIgeTIgPSBuZXcgYm4oMSk7XG5cblx0ICAvLyBOT1RFOiBhbGwgdmVjdG9ycyBhcmUgcm9vdHMgb2Y6IGEgKyBiICogbGFtYmRhID0gMCAobW9kIG4pXG5cdCAgdmFyIGEwO1xuXHQgIHZhciBiMDtcblx0ICAvLyBGaXJzdCB2ZWN0b3Jcblx0ICB2YXIgYTE7XG5cdCAgdmFyIGIxO1xuXHQgIC8vIFNlY29uZCB2ZWN0b3Jcblx0ICB2YXIgYTI7XG5cdCAgdmFyIGIyO1xuXG5cdCAgdmFyIHByZXZSO1xuXHQgIHZhciBpID0gMDtcblx0ICB2YXIgcjtcblx0ICB2YXIgeDtcblx0ICB3aGlsZSAodS5jbXBuKDApICE9PSAwKSB7XG5cdCAgICB2YXIgcSA9IHYuZGl2KHUpO1xuXHQgICAgciA9IHYuc3ViKHEubXVsKHUpKTtcblx0ICAgIHggPSB4Mi5zdWIocS5tdWwoeDEpKTtcblx0ICAgIHZhciB5ID0geTIuc3ViKHEubXVsKHkxKSk7XG5cblx0ICAgIGlmICghYTEgJiYgci5jbXAoYXByeFNxcnQpIDwgMCkge1xuXHQgICAgICBhMCA9IHByZXZSLm5lZygpO1xuXHQgICAgICBiMCA9IHgxO1xuXHQgICAgICBhMSA9IHIubmVnKCk7XG5cdCAgICAgIGIxID0geDtcblx0ICAgIH0gZWxzZSBpZiAoYTEgJiYgKytpID09PSAyKSB7XG5cdCAgICAgIGJyZWFrO1xuXHQgICAgfVxuXHQgICAgcHJldlIgPSByO1xuXG5cdCAgICB2ID0gdTtcblx0ICAgIHUgPSByO1xuXHQgICAgeDIgPSB4MTtcblx0ICAgIHgxID0geDtcblx0ICAgIHkyID0geTE7XG5cdCAgICB5MSA9IHk7XG5cdCAgfVxuXHQgIGEyID0gci5uZWcoKTtcblx0ICBiMiA9IHg7XG5cblx0ICB2YXIgbGVuMSA9IGExLnNxcigpLmFkZChiMS5zcXIoKSk7XG5cdCAgdmFyIGxlbjIgPSBhMi5zcXIoKS5hZGQoYjIuc3FyKCkpO1xuXHQgIGlmIChsZW4yLmNtcChsZW4xKSA+PSAwKSB7XG5cdCAgICBhMiA9IGEwO1xuXHQgICAgYjIgPSBiMDtcblx0ICB9XG5cblx0ICAvLyBOb3JtYWxpemUgc2lnbnNcblx0ICBpZiAoYTEubmVnYXRpdmUpIHtcblx0ICAgIGExID0gYTEubmVnKCk7XG5cdCAgICBiMSA9IGIxLm5lZygpO1xuXHQgIH1cblx0ICBpZiAoYTIubmVnYXRpdmUpIHtcblx0ICAgIGEyID0gYTIubmVnKCk7XG5cdCAgICBiMiA9IGIyLm5lZygpO1xuXHQgIH1cblxuXHQgIHJldHVybiBbXG5cdCAgICB7IGE6IGExLCBiOiBiMSB9LFxuXHQgICAgeyBhOiBhMiwgYjogYjIgfSxcblx0ICBdO1xuXHR9O1xuXG5cdFNob3J0Q3VydmUucHJvdG90eXBlLl9lbmRvU3BsaXQgPSBmdW5jdGlvbiBfZW5kb1NwbGl0KGspIHtcblx0ICB2YXIgYmFzaXMgPSB0aGlzLmVuZG8uYmFzaXM7XG5cdCAgdmFyIHYxID0gYmFzaXNbMF07XG5cdCAgdmFyIHYyID0gYmFzaXNbMV07XG5cblx0ICB2YXIgYzEgPSB2Mi5iLm11bChrKS5kaXZSb3VuZCh0aGlzLm4pO1xuXHQgIHZhciBjMiA9IHYxLmIubmVnKCkubXVsKGspLmRpdlJvdW5kKHRoaXMubik7XG5cblx0ICB2YXIgcDEgPSBjMS5tdWwodjEuYSk7XG5cdCAgdmFyIHAyID0gYzIubXVsKHYyLmEpO1xuXHQgIHZhciBxMSA9IGMxLm11bCh2MS5iKTtcblx0ICB2YXIgcTIgPSBjMi5tdWwodjIuYik7XG5cblx0ICAvLyBDYWxjdWxhdGUgYW5zd2VyXG5cdCAgdmFyIGsxID0gay5zdWIocDEpLnN1YihwMik7XG5cdCAgdmFyIGsyID0gcTEuYWRkKHEyKS5uZWcoKTtcblx0ICByZXR1cm4geyBrMTogazEsIGsyOiBrMiB9O1xuXHR9O1xuXG5cdFNob3J0Q3VydmUucHJvdG90eXBlLnBvaW50RnJvbVggPSBmdW5jdGlvbiBwb2ludEZyb21YKHgsIG9kZCkge1xuXHQgIHggPSBuZXcgYm4oeCwgMTYpO1xuXHQgIGlmICgheC5yZWQpXG5cdCAgICB4ID0geC50b1JlZCh0aGlzLnJlZCk7XG5cblx0ICB2YXIgeTIgPSB4LnJlZFNxcigpLnJlZE11bCh4KS5yZWRJQWRkKHgucmVkTXVsKHRoaXMuYSkpLnJlZElBZGQodGhpcy5iKTtcblx0ICB2YXIgeSA9IHkyLnJlZFNxcnQoKTtcblx0ICBpZiAoeS5yZWRTcXIoKS5yZWRTdWIoeTIpLmNtcCh0aGlzLnplcm8pICE9PSAwKVxuXHQgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIHBvaW50Jyk7XG5cblx0ICAvLyBYWFggSXMgdGhlcmUgYW55IHdheSB0byB0ZWxsIGlmIHRoZSBudW1iZXIgaXMgb2RkIHdpdGhvdXQgY29udmVydGluZyBpdFxuXHQgIC8vIHRvIG5vbi1yZWQgZm9ybT9cblx0ICB2YXIgaXNPZGQgPSB5LmZyb21SZWQoKS5pc09kZCgpO1xuXHQgIGlmIChvZGQgJiYgIWlzT2RkIHx8ICFvZGQgJiYgaXNPZGQpXG5cdCAgICB5ID0geS5yZWROZWcoKTtcblxuXHQgIHJldHVybiB0aGlzLnBvaW50KHgsIHkpO1xuXHR9O1xuXG5cdFNob3J0Q3VydmUucHJvdG90eXBlLnZhbGlkYXRlID0gZnVuY3Rpb24gdmFsaWRhdGUocG9pbnQpIHtcblx0ICBpZiAocG9pbnQuaW5mKVxuXHQgICAgcmV0dXJuIHRydWU7XG5cblx0ICB2YXIgeCA9IHBvaW50Lng7XG5cdCAgdmFyIHkgPSBwb2ludC55O1xuXG5cdCAgdmFyIGF4ID0gdGhpcy5hLnJlZE11bCh4KTtcblx0ICB2YXIgcmhzID0geC5yZWRTcXIoKS5yZWRNdWwoeCkucmVkSUFkZChheCkucmVkSUFkZCh0aGlzLmIpO1xuXHQgIHJldHVybiB5LnJlZFNxcigpLnJlZElTdWIocmhzKS5jbXBuKDApID09PSAwO1xuXHR9O1xuXG5cdFNob3J0Q3VydmUucHJvdG90eXBlLl9lbmRvV25hZk11bEFkZCA9XG5cdCAgICBmdW5jdGlvbiBfZW5kb1duYWZNdWxBZGQocG9pbnRzLCBjb2VmZnMsIGphY29iaWFuUmVzdWx0KSB7XG5cdCAgICAgIHZhciBucG9pbnRzID0gdGhpcy5fZW5kb1duYWZUMTtcblx0ICAgICAgdmFyIG5jb2VmZnMgPSB0aGlzLl9lbmRvV25hZlQyO1xuXHQgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBvaW50cy5sZW5ndGg7IGkrKykge1xuXHQgICAgICAgIHZhciBzcGxpdCA9IHRoaXMuX2VuZG9TcGxpdChjb2VmZnNbaV0pO1xuXHQgICAgICAgIHZhciBwID0gcG9pbnRzW2ldO1xuXHQgICAgICAgIHZhciBiZXRhID0gcC5fZ2V0QmV0YSgpO1xuXG5cdCAgICAgICAgaWYgKHNwbGl0LmsxLm5lZ2F0aXZlKSB7XG5cdCAgICAgICAgICBzcGxpdC5rMS5pbmVnKCk7XG5cdCAgICAgICAgICBwID0gcC5uZWcodHJ1ZSk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGlmIChzcGxpdC5rMi5uZWdhdGl2ZSkge1xuXHQgICAgICAgICAgc3BsaXQuazIuaW5lZygpO1xuXHQgICAgICAgICAgYmV0YSA9IGJldGEubmVnKHRydWUpO1xuXHQgICAgICAgIH1cblxuXHQgICAgICAgIG5wb2ludHNbaSAqIDJdID0gcDtcblx0ICAgICAgICBucG9pbnRzW2kgKiAyICsgMV0gPSBiZXRhO1xuXHQgICAgICAgIG5jb2VmZnNbaSAqIDJdID0gc3BsaXQuazE7XG5cdCAgICAgICAgbmNvZWZmc1tpICogMiArIDFdID0gc3BsaXQuazI7XG5cdCAgICAgIH1cblx0ICAgICAgdmFyIHJlcyA9IHRoaXMuX3duYWZNdWxBZGQoMSwgbnBvaW50cywgbmNvZWZmcywgaSAqIDIsIGphY29iaWFuUmVzdWx0KTtcblxuXHQgICAgICAvLyBDbGVhbi11cCByZWZlcmVuY2VzIHRvIHBvaW50cyBhbmQgY29lZmZpY2llbnRzXG5cdCAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgaSAqIDI7IGorKykge1xuXHQgICAgICAgIG5wb2ludHNbal0gPSBudWxsO1xuXHQgICAgICAgIG5jb2VmZnNbal0gPSBudWxsO1xuXHQgICAgICB9XG5cdCAgICAgIHJldHVybiByZXM7XG5cdCAgICB9O1xuXG5cdGZ1bmN0aW9uIFBvaW50KGN1cnZlLCB4LCB5LCBpc1JlZCkge1xuXHQgIGJhc2UuQmFzZVBvaW50LmNhbGwodGhpcywgY3VydmUsICdhZmZpbmUnKTtcblx0ICBpZiAoeCA9PT0gbnVsbCAmJiB5ID09PSBudWxsKSB7XG5cdCAgICB0aGlzLnggPSBudWxsO1xuXHQgICAgdGhpcy55ID0gbnVsbDtcblx0ICAgIHRoaXMuaW5mID0gdHJ1ZTtcblx0ICB9IGVsc2Uge1xuXHQgICAgdGhpcy54ID0gbmV3IGJuKHgsIDE2KTtcblx0ICAgIHRoaXMueSA9IG5ldyBibih5LCAxNik7XG5cdCAgICAvLyBGb3JjZSByZWRnb21lcnkgcmVwcmVzZW50YXRpb24gd2hlbiBsb2FkaW5nIGZyb20gSlNPTlxuXHQgICAgaWYgKGlzUmVkKSB7XG5cdCAgICAgIHRoaXMueC5mb3JjZVJlZCh0aGlzLmN1cnZlLnJlZCk7XG5cdCAgICAgIHRoaXMueS5mb3JjZVJlZCh0aGlzLmN1cnZlLnJlZCk7XG5cdCAgICB9XG5cdCAgICBpZiAoIXRoaXMueC5yZWQpXG5cdCAgICAgIHRoaXMueCA9IHRoaXMueC50b1JlZCh0aGlzLmN1cnZlLnJlZCk7XG5cdCAgICBpZiAoIXRoaXMueS5yZWQpXG5cdCAgICAgIHRoaXMueSA9IHRoaXMueS50b1JlZCh0aGlzLmN1cnZlLnJlZCk7XG5cdCAgICB0aGlzLmluZiA9IGZhbHNlO1xuXHQgIH1cblx0fVxuXHRpbmhlcml0c19icm93c2VyKFBvaW50LCBiYXNlLkJhc2VQb2ludCk7XG5cblx0U2hvcnRDdXJ2ZS5wcm90b3R5cGUucG9pbnQgPSBmdW5jdGlvbiBwb2ludCh4LCB5LCBpc1JlZCkge1xuXHQgIHJldHVybiBuZXcgUG9pbnQodGhpcywgeCwgeSwgaXNSZWQpO1xuXHR9O1xuXG5cdFNob3J0Q3VydmUucHJvdG90eXBlLnBvaW50RnJvbUpTT04gPSBmdW5jdGlvbiBwb2ludEZyb21KU09OKG9iaiwgcmVkKSB7XG5cdCAgcmV0dXJuIFBvaW50LmZyb21KU09OKHRoaXMsIG9iaiwgcmVkKTtcblx0fTtcblxuXHRQb2ludC5wcm90b3R5cGUuX2dldEJldGEgPSBmdW5jdGlvbiBfZ2V0QmV0YSgpIHtcblx0ICBpZiAoIXRoaXMuY3VydmUuZW5kbylcblx0ICAgIHJldHVybjtcblxuXHQgIHZhciBwcmUgPSB0aGlzLnByZWNvbXB1dGVkO1xuXHQgIGlmIChwcmUgJiYgcHJlLmJldGEpXG5cdCAgICByZXR1cm4gcHJlLmJldGE7XG5cblx0ICB2YXIgYmV0YSA9IHRoaXMuY3VydmUucG9pbnQodGhpcy54LnJlZE11bCh0aGlzLmN1cnZlLmVuZG8uYmV0YSksIHRoaXMueSk7XG5cdCAgaWYgKHByZSkge1xuXHQgICAgdmFyIGN1cnZlID0gdGhpcy5jdXJ2ZTtcblx0ICAgIHZhciBlbmRvTXVsID0gZnVuY3Rpb24ocCkge1xuXHQgICAgICByZXR1cm4gY3VydmUucG9pbnQocC54LnJlZE11bChjdXJ2ZS5lbmRvLmJldGEpLCBwLnkpO1xuXHQgICAgfTtcblx0ICAgIHByZS5iZXRhID0gYmV0YTtcblx0ICAgIGJldGEucHJlY29tcHV0ZWQgPSB7XG5cdCAgICAgIGJldGE6IG51bGwsXG5cdCAgICAgIG5hZjogcHJlLm5hZiAmJiB7XG5cdCAgICAgICAgd25kOiBwcmUubmFmLnduZCxcblx0ICAgICAgICBwb2ludHM6IHByZS5uYWYucG9pbnRzLm1hcChlbmRvTXVsKSxcblx0ICAgICAgfSxcblx0ICAgICAgZG91YmxlczogcHJlLmRvdWJsZXMgJiYge1xuXHQgICAgICAgIHN0ZXA6IHByZS5kb3VibGVzLnN0ZXAsXG5cdCAgICAgICAgcG9pbnRzOiBwcmUuZG91Ymxlcy5wb2ludHMubWFwKGVuZG9NdWwpLFxuXHQgICAgICB9LFxuXHQgICAgfTtcblx0ICB9XG5cdCAgcmV0dXJuIGJldGE7XG5cdH07XG5cblx0UG9pbnQucHJvdG90eXBlLnRvSlNPTiA9IGZ1bmN0aW9uIHRvSlNPTigpIHtcblx0ICBpZiAoIXRoaXMucHJlY29tcHV0ZWQpXG5cdCAgICByZXR1cm4gWyB0aGlzLngsIHRoaXMueSBdO1xuXG5cdCAgcmV0dXJuIFsgdGhpcy54LCB0aGlzLnksIHRoaXMucHJlY29tcHV0ZWQgJiYge1xuXHQgICAgZG91YmxlczogdGhpcy5wcmVjb21wdXRlZC5kb3VibGVzICYmIHtcblx0ICAgICAgc3RlcDogdGhpcy5wcmVjb21wdXRlZC5kb3VibGVzLnN0ZXAsXG5cdCAgICAgIHBvaW50czogdGhpcy5wcmVjb21wdXRlZC5kb3VibGVzLnBvaW50cy5zbGljZSgxKSxcblx0ICAgIH0sXG5cdCAgICBuYWY6IHRoaXMucHJlY29tcHV0ZWQubmFmICYmIHtcblx0ICAgICAgd25kOiB0aGlzLnByZWNvbXB1dGVkLm5hZi53bmQsXG5cdCAgICAgIHBvaW50czogdGhpcy5wcmVjb21wdXRlZC5uYWYucG9pbnRzLnNsaWNlKDEpLFxuXHQgICAgfSxcblx0ICB9IF07XG5cdH07XG5cblx0UG9pbnQuZnJvbUpTT04gPSBmdW5jdGlvbiBmcm9tSlNPTihjdXJ2ZSwgb2JqLCByZWQpIHtcblx0ICBpZiAodHlwZW9mIG9iaiA9PT0gJ3N0cmluZycpXG5cdCAgICBvYmogPSBKU09OLnBhcnNlKG9iaik7XG5cdCAgdmFyIHJlcyA9IGN1cnZlLnBvaW50KG9ialswXSwgb2JqWzFdLCByZWQpO1xuXHQgIGlmICghb2JqWzJdKVxuXHQgICAgcmV0dXJuIHJlcztcblxuXHQgIGZ1bmN0aW9uIG9iajJwb2ludChvYmopIHtcblx0ICAgIHJldHVybiBjdXJ2ZS5wb2ludChvYmpbMF0sIG9ialsxXSwgcmVkKTtcblx0ICB9XG5cblx0ICB2YXIgcHJlID0gb2JqWzJdO1xuXHQgIHJlcy5wcmVjb21wdXRlZCA9IHtcblx0ICAgIGJldGE6IG51bGwsXG5cdCAgICBkb3VibGVzOiBwcmUuZG91YmxlcyAmJiB7XG5cdCAgICAgIHN0ZXA6IHByZS5kb3VibGVzLnN0ZXAsXG5cdCAgICAgIHBvaW50czogWyByZXMgXS5jb25jYXQocHJlLmRvdWJsZXMucG9pbnRzLm1hcChvYmoycG9pbnQpKSxcblx0ICAgIH0sXG5cdCAgICBuYWY6IHByZS5uYWYgJiYge1xuXHQgICAgICB3bmQ6IHByZS5uYWYud25kLFxuXHQgICAgICBwb2ludHM6IFsgcmVzIF0uY29uY2F0KHByZS5uYWYucG9pbnRzLm1hcChvYmoycG9pbnQpKSxcblx0ICAgIH0sXG5cdCAgfTtcblx0ICByZXR1cm4gcmVzO1xuXHR9O1xuXG5cdFBvaW50LnByb3RvdHlwZS5pbnNwZWN0ID0gZnVuY3Rpb24gaW5zcGVjdCgpIHtcblx0ICBpZiAodGhpcy5pc0luZmluaXR5KCkpXG5cdCAgICByZXR1cm4gJzxFQyBQb2ludCBJbmZpbml0eT4nO1xuXHQgIHJldHVybiAnPEVDIFBvaW50IHg6ICcgKyB0aGlzLnguZnJvbVJlZCgpLnRvU3RyaW5nKDE2LCAyKSArXG5cdCAgICAgICcgeTogJyArIHRoaXMueS5mcm9tUmVkKCkudG9TdHJpbmcoMTYsIDIpICsgJz4nO1xuXHR9O1xuXG5cdFBvaW50LnByb3RvdHlwZS5pc0luZmluaXR5ID0gZnVuY3Rpb24gaXNJbmZpbml0eSgpIHtcblx0ICByZXR1cm4gdGhpcy5pbmY7XG5cdH07XG5cblx0UG9pbnQucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uIGFkZChwKSB7XG5cdCAgLy8gTyArIFAgPSBQXG5cdCAgaWYgKHRoaXMuaW5mKVxuXHQgICAgcmV0dXJuIHA7XG5cblx0ICAvLyBQICsgTyA9IFBcblx0ICBpZiAocC5pbmYpXG5cdCAgICByZXR1cm4gdGhpcztcblxuXHQgIC8vIFAgKyBQID0gMlBcblx0ICBpZiAodGhpcy5lcShwKSlcblx0ICAgIHJldHVybiB0aGlzLmRibCgpO1xuXG5cdCAgLy8gUCArICgtUCkgPSBPXG5cdCAgaWYgKHRoaXMubmVnKCkuZXEocCkpXG5cdCAgICByZXR1cm4gdGhpcy5jdXJ2ZS5wb2ludChudWxsLCBudWxsKTtcblxuXHQgIC8vIFAgKyBRID0gT1xuXHQgIGlmICh0aGlzLnguY21wKHAueCkgPT09IDApXG5cdCAgICByZXR1cm4gdGhpcy5jdXJ2ZS5wb2ludChudWxsLCBudWxsKTtcblxuXHQgIHZhciBjID0gdGhpcy55LnJlZFN1YihwLnkpO1xuXHQgIGlmIChjLmNtcG4oMCkgIT09IDApXG5cdCAgICBjID0gYy5yZWRNdWwodGhpcy54LnJlZFN1YihwLngpLnJlZEludm0oKSk7XG5cdCAgdmFyIG54ID0gYy5yZWRTcXIoKS5yZWRJU3ViKHRoaXMueCkucmVkSVN1YihwLngpO1xuXHQgIHZhciBueSA9IGMucmVkTXVsKHRoaXMueC5yZWRTdWIobngpKS5yZWRJU3ViKHRoaXMueSk7XG5cdCAgcmV0dXJuIHRoaXMuY3VydmUucG9pbnQobngsIG55KTtcblx0fTtcblxuXHRQb2ludC5wcm90b3R5cGUuZGJsID0gZnVuY3Rpb24gZGJsKCkge1xuXHQgIGlmICh0aGlzLmluZilcblx0ICAgIHJldHVybiB0aGlzO1xuXG5cdCAgLy8gMlAgPSBPXG5cdCAgdmFyIHlzMSA9IHRoaXMueS5yZWRBZGQodGhpcy55KTtcblx0ICBpZiAoeXMxLmNtcG4oMCkgPT09IDApXG5cdCAgICByZXR1cm4gdGhpcy5jdXJ2ZS5wb2ludChudWxsLCBudWxsKTtcblxuXHQgIHZhciBhID0gdGhpcy5jdXJ2ZS5hO1xuXG5cdCAgdmFyIHgyID0gdGhpcy54LnJlZFNxcigpO1xuXHQgIHZhciBkeWludiA9IHlzMS5yZWRJbnZtKCk7XG5cdCAgdmFyIGMgPSB4Mi5yZWRBZGQoeDIpLnJlZElBZGQoeDIpLnJlZElBZGQoYSkucmVkTXVsKGR5aW52KTtcblxuXHQgIHZhciBueCA9IGMucmVkU3FyKCkucmVkSVN1Yih0aGlzLngucmVkQWRkKHRoaXMueCkpO1xuXHQgIHZhciBueSA9IGMucmVkTXVsKHRoaXMueC5yZWRTdWIobngpKS5yZWRJU3ViKHRoaXMueSk7XG5cdCAgcmV0dXJuIHRoaXMuY3VydmUucG9pbnQobngsIG55KTtcblx0fTtcblxuXHRQb2ludC5wcm90b3R5cGUuZ2V0WCA9IGZ1bmN0aW9uIGdldFgoKSB7XG5cdCAgcmV0dXJuIHRoaXMueC5mcm9tUmVkKCk7XG5cdH07XG5cblx0UG9pbnQucHJvdG90eXBlLmdldFkgPSBmdW5jdGlvbiBnZXRZKCkge1xuXHQgIHJldHVybiB0aGlzLnkuZnJvbVJlZCgpO1xuXHR9O1xuXG5cdFBvaW50LnByb3RvdHlwZS5tdWwgPSBmdW5jdGlvbiBtdWwoaykge1xuXHQgIGsgPSBuZXcgYm4oaywgMTYpO1xuXHQgIGlmICh0aGlzLmlzSW5maW5pdHkoKSlcblx0ICAgIHJldHVybiB0aGlzO1xuXHQgIGVsc2UgaWYgKHRoaXMuX2hhc0RvdWJsZXMoaykpXG5cdCAgICByZXR1cm4gdGhpcy5jdXJ2ZS5fZml4ZWROYWZNdWwodGhpcywgayk7XG5cdCAgZWxzZSBpZiAodGhpcy5jdXJ2ZS5lbmRvKVxuXHQgICAgcmV0dXJuIHRoaXMuY3VydmUuX2VuZG9XbmFmTXVsQWRkKFsgdGhpcyBdLCBbIGsgXSk7XG5cdCAgZWxzZVxuXHQgICAgcmV0dXJuIHRoaXMuY3VydmUuX3duYWZNdWwodGhpcywgayk7XG5cdH07XG5cblx0UG9pbnQucHJvdG90eXBlLm11bEFkZCA9IGZ1bmN0aW9uIG11bEFkZChrMSwgcDIsIGsyKSB7XG5cdCAgdmFyIHBvaW50cyA9IFsgdGhpcywgcDIgXTtcblx0ICB2YXIgY29lZmZzID0gWyBrMSwgazIgXTtcblx0ICBpZiAodGhpcy5jdXJ2ZS5lbmRvKVxuXHQgICAgcmV0dXJuIHRoaXMuY3VydmUuX2VuZG9XbmFmTXVsQWRkKHBvaW50cywgY29lZmZzKTtcblx0ICBlbHNlXG5cdCAgICByZXR1cm4gdGhpcy5jdXJ2ZS5fd25hZk11bEFkZCgxLCBwb2ludHMsIGNvZWZmcywgMik7XG5cdH07XG5cblx0UG9pbnQucHJvdG90eXBlLmptdWxBZGQgPSBmdW5jdGlvbiBqbXVsQWRkKGsxLCBwMiwgazIpIHtcblx0ICB2YXIgcG9pbnRzID0gWyB0aGlzLCBwMiBdO1xuXHQgIHZhciBjb2VmZnMgPSBbIGsxLCBrMiBdO1xuXHQgIGlmICh0aGlzLmN1cnZlLmVuZG8pXG5cdCAgICByZXR1cm4gdGhpcy5jdXJ2ZS5fZW5kb1duYWZNdWxBZGQocG9pbnRzLCBjb2VmZnMsIHRydWUpO1xuXHQgIGVsc2Vcblx0ICAgIHJldHVybiB0aGlzLmN1cnZlLl93bmFmTXVsQWRkKDEsIHBvaW50cywgY29lZmZzLCAyLCB0cnVlKTtcblx0fTtcblxuXHRQb2ludC5wcm90b3R5cGUuZXEgPSBmdW5jdGlvbiBlcShwKSB7XG5cdCAgcmV0dXJuIHRoaXMgPT09IHAgfHxcblx0ICAgICAgICAgdGhpcy5pbmYgPT09IHAuaW5mICYmXG5cdCAgICAgICAgICAgICAodGhpcy5pbmYgfHwgdGhpcy54LmNtcChwLngpID09PSAwICYmIHRoaXMueS5jbXAocC55KSA9PT0gMCk7XG5cdH07XG5cblx0UG9pbnQucHJvdG90eXBlLm5lZyA9IGZ1bmN0aW9uIG5lZyhfcHJlY29tcHV0ZSkge1xuXHQgIGlmICh0aGlzLmluZilcblx0ICAgIHJldHVybiB0aGlzO1xuXG5cdCAgdmFyIHJlcyA9IHRoaXMuY3VydmUucG9pbnQodGhpcy54LCB0aGlzLnkucmVkTmVnKCkpO1xuXHQgIGlmIChfcHJlY29tcHV0ZSAmJiB0aGlzLnByZWNvbXB1dGVkKSB7XG5cdCAgICB2YXIgcHJlID0gdGhpcy5wcmVjb21wdXRlZDtcblx0ICAgIHZhciBuZWdhdGUgPSBmdW5jdGlvbihwKSB7XG5cdCAgICAgIHJldHVybiBwLm5lZygpO1xuXHQgICAgfTtcblx0ICAgIHJlcy5wcmVjb21wdXRlZCA9IHtcblx0ICAgICAgbmFmOiBwcmUubmFmICYmIHtcblx0ICAgICAgICB3bmQ6IHByZS5uYWYud25kLFxuXHQgICAgICAgIHBvaW50czogcHJlLm5hZi5wb2ludHMubWFwKG5lZ2F0ZSksXG5cdCAgICAgIH0sXG5cdCAgICAgIGRvdWJsZXM6IHByZS5kb3VibGVzICYmIHtcblx0ICAgICAgICBzdGVwOiBwcmUuZG91Ymxlcy5zdGVwLFxuXHQgICAgICAgIHBvaW50czogcHJlLmRvdWJsZXMucG9pbnRzLm1hcChuZWdhdGUpLFxuXHQgICAgICB9LFxuXHQgICAgfTtcblx0ICB9XG5cdCAgcmV0dXJuIHJlcztcblx0fTtcblxuXHRQb2ludC5wcm90b3R5cGUudG9KID0gZnVuY3Rpb24gdG9KKCkge1xuXHQgIGlmICh0aGlzLmluZilcblx0ICAgIHJldHVybiB0aGlzLmN1cnZlLmpwb2ludChudWxsLCBudWxsLCBudWxsKTtcblxuXHQgIHZhciByZXMgPSB0aGlzLmN1cnZlLmpwb2ludCh0aGlzLngsIHRoaXMueSwgdGhpcy5jdXJ2ZS5vbmUpO1xuXHQgIHJldHVybiByZXM7XG5cdH07XG5cblx0ZnVuY3Rpb24gSlBvaW50KGN1cnZlLCB4LCB5LCB6KSB7XG5cdCAgYmFzZS5CYXNlUG9pbnQuY2FsbCh0aGlzLCBjdXJ2ZSwgJ2phY29iaWFuJyk7XG5cdCAgaWYgKHggPT09IG51bGwgJiYgeSA9PT0gbnVsbCAmJiB6ID09PSBudWxsKSB7XG5cdCAgICB0aGlzLnggPSB0aGlzLmN1cnZlLm9uZTtcblx0ICAgIHRoaXMueSA9IHRoaXMuY3VydmUub25lO1xuXHQgICAgdGhpcy56ID0gbmV3IGJuKDApO1xuXHQgIH0gZWxzZSB7XG5cdCAgICB0aGlzLnggPSBuZXcgYm4oeCwgMTYpO1xuXHQgICAgdGhpcy55ID0gbmV3IGJuKHksIDE2KTtcblx0ICAgIHRoaXMueiA9IG5ldyBibih6LCAxNik7XG5cdCAgfVxuXHQgIGlmICghdGhpcy54LnJlZClcblx0ICAgIHRoaXMueCA9IHRoaXMueC50b1JlZCh0aGlzLmN1cnZlLnJlZCk7XG5cdCAgaWYgKCF0aGlzLnkucmVkKVxuXHQgICAgdGhpcy55ID0gdGhpcy55LnRvUmVkKHRoaXMuY3VydmUucmVkKTtcblx0ICBpZiAoIXRoaXMuei5yZWQpXG5cdCAgICB0aGlzLnogPSB0aGlzLnoudG9SZWQodGhpcy5jdXJ2ZS5yZWQpO1xuXG5cdCAgdGhpcy56T25lID0gdGhpcy56ID09PSB0aGlzLmN1cnZlLm9uZTtcblx0fVxuXHRpbmhlcml0c19icm93c2VyKEpQb2ludCwgYmFzZS5CYXNlUG9pbnQpO1xuXG5cdFNob3J0Q3VydmUucHJvdG90eXBlLmpwb2ludCA9IGZ1bmN0aW9uIGpwb2ludCh4LCB5LCB6KSB7XG5cdCAgcmV0dXJuIG5ldyBKUG9pbnQodGhpcywgeCwgeSwgeik7XG5cdH07XG5cblx0SlBvaW50LnByb3RvdHlwZS50b1AgPSBmdW5jdGlvbiB0b1AoKSB7XG5cdCAgaWYgKHRoaXMuaXNJbmZpbml0eSgpKVxuXHQgICAgcmV0dXJuIHRoaXMuY3VydmUucG9pbnQobnVsbCwgbnVsbCk7XG5cblx0ICB2YXIgemludiA9IHRoaXMuei5yZWRJbnZtKCk7XG5cdCAgdmFyIHppbnYyID0gemludi5yZWRTcXIoKTtcblx0ICB2YXIgYXggPSB0aGlzLngucmVkTXVsKHppbnYyKTtcblx0ICB2YXIgYXkgPSB0aGlzLnkucmVkTXVsKHppbnYyKS5yZWRNdWwoemludik7XG5cblx0ICByZXR1cm4gdGhpcy5jdXJ2ZS5wb2ludChheCwgYXkpO1xuXHR9O1xuXG5cdEpQb2ludC5wcm90b3R5cGUubmVnID0gZnVuY3Rpb24gbmVnKCkge1xuXHQgIHJldHVybiB0aGlzLmN1cnZlLmpwb2ludCh0aGlzLngsIHRoaXMueS5yZWROZWcoKSwgdGhpcy56KTtcblx0fTtcblxuXHRKUG9pbnQucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uIGFkZChwKSB7XG5cdCAgLy8gTyArIFAgPSBQXG5cdCAgaWYgKHRoaXMuaXNJbmZpbml0eSgpKVxuXHQgICAgcmV0dXJuIHA7XG5cblx0ICAvLyBQICsgTyA9IFBcblx0ICBpZiAocC5pc0luZmluaXR5KCkpXG5cdCAgICByZXR1cm4gdGhpcztcblxuXHQgIC8vIDEyTSArIDRTICsgN0Fcblx0ICB2YXIgcHoyID0gcC56LnJlZFNxcigpO1xuXHQgIHZhciB6MiA9IHRoaXMuei5yZWRTcXIoKTtcblx0ICB2YXIgdTEgPSB0aGlzLngucmVkTXVsKHB6Mik7XG5cdCAgdmFyIHUyID0gcC54LnJlZE11bCh6Mik7XG5cdCAgdmFyIHMxID0gdGhpcy55LnJlZE11bChwejIucmVkTXVsKHAueikpO1xuXHQgIHZhciBzMiA9IHAueS5yZWRNdWwoejIucmVkTXVsKHRoaXMueikpO1xuXG5cdCAgdmFyIGggPSB1MS5yZWRTdWIodTIpO1xuXHQgIHZhciByID0gczEucmVkU3ViKHMyKTtcblx0ICBpZiAoaC5jbXBuKDApID09PSAwKSB7XG5cdCAgICBpZiAoci5jbXBuKDApICE9PSAwKVxuXHQgICAgICByZXR1cm4gdGhpcy5jdXJ2ZS5qcG9pbnQobnVsbCwgbnVsbCwgbnVsbCk7XG5cdCAgICBlbHNlXG5cdCAgICAgIHJldHVybiB0aGlzLmRibCgpO1xuXHQgIH1cblxuXHQgIHZhciBoMiA9IGgucmVkU3FyKCk7XG5cdCAgdmFyIGgzID0gaDIucmVkTXVsKGgpO1xuXHQgIHZhciB2ID0gdTEucmVkTXVsKGgyKTtcblxuXHQgIHZhciBueCA9IHIucmVkU3FyKCkucmVkSUFkZChoMykucmVkSVN1Yih2KS5yZWRJU3ViKHYpO1xuXHQgIHZhciBueSA9IHIucmVkTXVsKHYucmVkSVN1YihueCkpLnJlZElTdWIoczEucmVkTXVsKGgzKSk7XG5cdCAgdmFyIG56ID0gdGhpcy56LnJlZE11bChwLnopLnJlZE11bChoKTtcblxuXHQgIHJldHVybiB0aGlzLmN1cnZlLmpwb2ludChueCwgbnksIG56KTtcblx0fTtcblxuXHRKUG9pbnQucHJvdG90eXBlLm1peGVkQWRkID0gZnVuY3Rpb24gbWl4ZWRBZGQocCkge1xuXHQgIC8vIE8gKyBQID0gUFxuXHQgIGlmICh0aGlzLmlzSW5maW5pdHkoKSlcblx0ICAgIHJldHVybiBwLnRvSigpO1xuXG5cdCAgLy8gUCArIE8gPSBQXG5cdCAgaWYgKHAuaXNJbmZpbml0eSgpKVxuXHQgICAgcmV0dXJuIHRoaXM7XG5cblx0ICAvLyA4TSArIDNTICsgN0Fcblx0ICB2YXIgejIgPSB0aGlzLnoucmVkU3FyKCk7XG5cdCAgdmFyIHUxID0gdGhpcy54O1xuXHQgIHZhciB1MiA9IHAueC5yZWRNdWwoejIpO1xuXHQgIHZhciBzMSA9IHRoaXMueTtcblx0ICB2YXIgczIgPSBwLnkucmVkTXVsKHoyKS5yZWRNdWwodGhpcy56KTtcblxuXHQgIHZhciBoID0gdTEucmVkU3ViKHUyKTtcblx0ICB2YXIgciA9IHMxLnJlZFN1YihzMik7XG5cdCAgaWYgKGguY21wbigwKSA9PT0gMCkge1xuXHQgICAgaWYgKHIuY21wbigwKSAhPT0gMClcblx0ICAgICAgcmV0dXJuIHRoaXMuY3VydmUuanBvaW50KG51bGwsIG51bGwsIG51bGwpO1xuXHQgICAgZWxzZVxuXHQgICAgICByZXR1cm4gdGhpcy5kYmwoKTtcblx0ICB9XG5cblx0ICB2YXIgaDIgPSBoLnJlZFNxcigpO1xuXHQgIHZhciBoMyA9IGgyLnJlZE11bChoKTtcblx0ICB2YXIgdiA9IHUxLnJlZE11bChoMik7XG5cblx0ICB2YXIgbnggPSByLnJlZFNxcigpLnJlZElBZGQoaDMpLnJlZElTdWIodikucmVkSVN1Yih2KTtcblx0ICB2YXIgbnkgPSByLnJlZE11bCh2LnJlZElTdWIobngpKS5yZWRJU3ViKHMxLnJlZE11bChoMykpO1xuXHQgIHZhciBueiA9IHRoaXMuei5yZWRNdWwoaCk7XG5cblx0ICByZXR1cm4gdGhpcy5jdXJ2ZS5qcG9pbnQobngsIG55LCBueik7XG5cdH07XG5cblx0SlBvaW50LnByb3RvdHlwZS5kYmxwID0gZnVuY3Rpb24gZGJscChwb3cpIHtcblx0ICBpZiAocG93ID09PSAwKVxuXHQgICAgcmV0dXJuIHRoaXM7XG5cdCAgaWYgKHRoaXMuaXNJbmZpbml0eSgpKVxuXHQgICAgcmV0dXJuIHRoaXM7XG5cdCAgaWYgKCFwb3cpXG5cdCAgICByZXR1cm4gdGhpcy5kYmwoKTtcblxuXHQgIHZhciBpO1xuXHQgIGlmICh0aGlzLmN1cnZlLnplcm9BIHx8IHRoaXMuY3VydmUudGhyZWVBKSB7XG5cdCAgICB2YXIgciA9IHRoaXM7XG5cdCAgICBmb3IgKGkgPSAwOyBpIDwgcG93OyBpKyspXG5cdCAgICAgIHIgPSByLmRibCgpO1xuXHQgICAgcmV0dXJuIHI7XG5cdCAgfVxuXG5cdCAgLy8gMU0gKyAyUyArIDFBICsgTiAqICg0UyArIDVNICsgOEEpXG5cdCAgLy8gTiA9IDEgPT4gNk0gKyA2UyArIDlBXG5cdCAgdmFyIGEgPSB0aGlzLmN1cnZlLmE7XG5cdCAgdmFyIHRpbnYgPSB0aGlzLmN1cnZlLnRpbnY7XG5cblx0ICB2YXIganggPSB0aGlzLng7XG5cdCAgdmFyIGp5ID0gdGhpcy55O1xuXHQgIHZhciBqeiA9IHRoaXMuejtcblx0ICB2YXIgano0ID0ganoucmVkU3FyKCkucmVkU3FyKCk7XG5cblx0ICAvLyBSZXVzZSByZXN1bHRzXG5cdCAgdmFyIGp5ZCA9IGp5LnJlZEFkZChqeSk7XG5cdCAgZm9yIChpID0gMDsgaSA8IHBvdzsgaSsrKSB7XG5cdCAgICB2YXIgangyID0gangucmVkU3FyKCk7XG5cdCAgICB2YXIganlkMiA9IGp5ZC5yZWRTcXIoKTtcblx0ICAgIHZhciBqeWQ0ID0ganlkMi5yZWRTcXIoKTtcblx0ICAgIHZhciBjID0gangyLnJlZEFkZChqeDIpLnJlZElBZGQoangyKS5yZWRJQWRkKGEucmVkTXVsKGp6NCkpO1xuXG5cdCAgICB2YXIgdDEgPSBqeC5yZWRNdWwoanlkMik7XG5cdCAgICB2YXIgbnggPSBjLnJlZFNxcigpLnJlZElTdWIodDEucmVkQWRkKHQxKSk7XG5cdCAgICB2YXIgdDIgPSB0MS5yZWRJU3ViKG54KTtcblx0ICAgIHZhciBkbnkgPSBjLnJlZE11bCh0Mik7XG5cdCAgICBkbnkgPSBkbnkucmVkSUFkZChkbnkpLnJlZElTdWIoanlkNCk7XG5cdCAgICB2YXIgbnogPSBqeWQucmVkTXVsKGp6KTtcblx0ICAgIGlmIChpICsgMSA8IHBvdylcblx0ICAgICAgano0ID0gano0LnJlZE11bChqeWQ0KTtcblxuXHQgICAganggPSBueDtcblx0ICAgIGp6ID0gbno7XG5cdCAgICBqeWQgPSBkbnk7XG5cdCAgfVxuXG5cdCAgcmV0dXJuIHRoaXMuY3VydmUuanBvaW50KGp4LCBqeWQucmVkTXVsKHRpbnYpLCBqeik7XG5cdH07XG5cblx0SlBvaW50LnByb3RvdHlwZS5kYmwgPSBmdW5jdGlvbiBkYmwoKSB7XG5cdCAgaWYgKHRoaXMuaXNJbmZpbml0eSgpKVxuXHQgICAgcmV0dXJuIHRoaXM7XG5cblx0ICBpZiAodGhpcy5jdXJ2ZS56ZXJvQSlcblx0ICAgIHJldHVybiB0aGlzLl96ZXJvRGJsKCk7XG5cdCAgZWxzZSBpZiAodGhpcy5jdXJ2ZS50aHJlZUEpXG5cdCAgICByZXR1cm4gdGhpcy5fdGhyZWVEYmwoKTtcblx0ICBlbHNlXG5cdCAgICByZXR1cm4gdGhpcy5fZGJsKCk7XG5cdH07XG5cblx0SlBvaW50LnByb3RvdHlwZS5femVyb0RibCA9IGZ1bmN0aW9uIF96ZXJvRGJsKCkge1xuXHQgIHZhciBueDtcblx0ICB2YXIgbnk7XG5cdCAgdmFyIG56O1xuXHQgIC8vIFogPSAxXG5cdCAgaWYgKHRoaXMuek9uZSkge1xuXHQgICAgLy8gaHlwZXJlbGxpcHRpYy5vcmcvRUZEL2cxcC9hdXRvLXNob3J0dy1qYWNvYmlhbi0wLmh0bWxcblx0ICAgIC8vICAgICAjZG91YmxpbmctbWRibC0yMDA3LWJsXG5cdCAgICAvLyAxTSArIDVTICsgMTRBXG5cblx0ICAgIC8vIFhYID0gWDFeMlxuXHQgICAgdmFyIHh4ID0gdGhpcy54LnJlZFNxcigpO1xuXHQgICAgLy8gWVkgPSBZMV4yXG5cdCAgICB2YXIgeXkgPSB0aGlzLnkucmVkU3FyKCk7XG5cdCAgICAvLyBZWVlZID0gWVleMlxuXHQgICAgdmFyIHl5eXkgPSB5eS5yZWRTcXIoKTtcblx0ICAgIC8vIFMgPSAyICogKChYMSArIFlZKV4yIC0gWFggLSBZWVlZKVxuXHQgICAgdmFyIHMgPSB0aGlzLngucmVkQWRkKHl5KS5yZWRTcXIoKS5yZWRJU3ViKHh4KS5yZWRJU3ViKHl5eXkpO1xuXHQgICAgcyA9IHMucmVkSUFkZChzKTtcblx0ICAgIC8vIE0gPSAzICogWFggKyBhOyBhID0gMFxuXHQgICAgdmFyIG0gPSB4eC5yZWRBZGQoeHgpLnJlZElBZGQoeHgpO1xuXHQgICAgLy8gVCA9IE0gXiAyIC0gMipTXG5cdCAgICB2YXIgdCA9IG0ucmVkU3FyKCkucmVkSVN1YihzKS5yZWRJU3ViKHMpO1xuXG5cdCAgICAvLyA4ICogWVlZWVxuXHQgICAgdmFyIHl5eXk4ID0geXl5eS5yZWRJQWRkKHl5eXkpO1xuXHQgICAgeXl5eTggPSB5eXl5OC5yZWRJQWRkKHl5eXk4KTtcblx0ICAgIHl5eXk4ID0geXl5eTgucmVkSUFkZCh5eXl5OCk7XG5cblx0ICAgIC8vIFgzID0gVFxuXHQgICAgbnggPSB0O1xuXHQgICAgLy8gWTMgPSBNICogKFMgLSBUKSAtIDggKiBZWVlZXG5cdCAgICBueSA9IG0ucmVkTXVsKHMucmVkSVN1Yih0KSkucmVkSVN1Yih5eXl5OCk7XG5cdCAgICAvLyBaMyA9IDIqWTFcblx0ICAgIG56ID0gdGhpcy55LnJlZEFkZCh0aGlzLnkpO1xuXHQgIH0gZWxzZSB7XG5cdCAgICAvLyBoeXBlcmVsbGlwdGljLm9yZy9FRkQvZzFwL2F1dG8tc2hvcnR3LWphY29iaWFuLTAuaHRtbFxuXHQgICAgLy8gICAgICNkb3VibGluZy1kYmwtMjAwOS1sXG5cdCAgICAvLyAyTSArIDVTICsgMTNBXG5cblx0ICAgIC8vIEEgPSBYMV4yXG5cdCAgICB2YXIgYSA9IHRoaXMueC5yZWRTcXIoKTtcblx0ICAgIC8vIEIgPSBZMV4yXG5cdCAgICB2YXIgYiA9IHRoaXMueS5yZWRTcXIoKTtcblx0ICAgIC8vIEMgPSBCXjJcblx0ICAgIHZhciBjID0gYi5yZWRTcXIoKTtcblx0ICAgIC8vIEQgPSAyICogKChYMSArIEIpXjIgLSBBIC0gQylcblx0ICAgIHZhciBkID0gdGhpcy54LnJlZEFkZChiKS5yZWRTcXIoKS5yZWRJU3ViKGEpLnJlZElTdWIoYyk7XG5cdCAgICBkID0gZC5yZWRJQWRkKGQpO1xuXHQgICAgLy8gRSA9IDMgKiBBXG5cdCAgICB2YXIgZSA9IGEucmVkQWRkKGEpLnJlZElBZGQoYSk7XG5cdCAgICAvLyBGID0gRV4yXG5cdCAgICB2YXIgZiA9IGUucmVkU3FyKCk7XG5cblx0ICAgIC8vIDggKiBDXG5cdCAgICB2YXIgYzggPSBjLnJlZElBZGQoYyk7XG5cdCAgICBjOCA9IGM4LnJlZElBZGQoYzgpO1xuXHQgICAgYzggPSBjOC5yZWRJQWRkKGM4KTtcblxuXHQgICAgLy8gWDMgPSBGIC0gMiAqIERcblx0ICAgIG54ID0gZi5yZWRJU3ViKGQpLnJlZElTdWIoZCk7XG5cdCAgICAvLyBZMyA9IEUgKiAoRCAtIFgzKSAtIDggKiBDXG5cdCAgICBueSA9IGUucmVkTXVsKGQucmVkSVN1YihueCkpLnJlZElTdWIoYzgpO1xuXHQgICAgLy8gWjMgPSAyICogWTEgKiBaMVxuXHQgICAgbnogPSB0aGlzLnkucmVkTXVsKHRoaXMueik7XG5cdCAgICBueiA9IG56LnJlZElBZGQobnopO1xuXHQgIH1cblxuXHQgIHJldHVybiB0aGlzLmN1cnZlLmpwb2ludChueCwgbnksIG56KTtcblx0fTtcblxuXHRKUG9pbnQucHJvdG90eXBlLl90aHJlZURibCA9IGZ1bmN0aW9uIF90aHJlZURibCgpIHtcblx0ICB2YXIgbng7XG5cdCAgdmFyIG55O1xuXHQgIHZhciBuejtcblx0ICAvLyBaID0gMVxuXHQgIGlmICh0aGlzLnpPbmUpIHtcblx0ICAgIC8vIGh5cGVyZWxsaXB0aWMub3JnL0VGRC9nMXAvYXV0by1zaG9ydHctamFjb2JpYW4tMy5odG1sXG5cdCAgICAvLyAgICAgI2RvdWJsaW5nLW1kYmwtMjAwNy1ibFxuXHQgICAgLy8gMU0gKyA1UyArIDE1QVxuXG5cdCAgICAvLyBYWCA9IFgxXjJcblx0ICAgIHZhciB4eCA9IHRoaXMueC5yZWRTcXIoKTtcblx0ICAgIC8vIFlZID0gWTFeMlxuXHQgICAgdmFyIHl5ID0gdGhpcy55LnJlZFNxcigpO1xuXHQgICAgLy8gWVlZWSA9IFlZXjJcblx0ICAgIHZhciB5eXl5ID0geXkucmVkU3FyKCk7XG5cdCAgICAvLyBTID0gMiAqICgoWDEgKyBZWSleMiAtIFhYIC0gWVlZWSlcblx0ICAgIHZhciBzID0gdGhpcy54LnJlZEFkZCh5eSkucmVkU3FyKCkucmVkSVN1Yih4eCkucmVkSVN1Yih5eXl5KTtcblx0ICAgIHMgPSBzLnJlZElBZGQocyk7XG5cdCAgICAvLyBNID0gMyAqIFhYICsgYVxuXHQgICAgdmFyIG0gPSB4eC5yZWRBZGQoeHgpLnJlZElBZGQoeHgpLnJlZElBZGQodGhpcy5jdXJ2ZS5hKTtcblx0ICAgIC8vIFQgPSBNXjIgLSAyICogU1xuXHQgICAgdmFyIHQgPSBtLnJlZFNxcigpLnJlZElTdWIocykucmVkSVN1YihzKTtcblx0ICAgIC8vIFgzID0gVFxuXHQgICAgbnggPSB0O1xuXHQgICAgLy8gWTMgPSBNICogKFMgLSBUKSAtIDggKiBZWVlZXG5cdCAgICB2YXIgeXl5eTggPSB5eXl5LnJlZElBZGQoeXl5eSk7XG5cdCAgICB5eXl5OCA9IHl5eXk4LnJlZElBZGQoeXl5eTgpO1xuXHQgICAgeXl5eTggPSB5eXl5OC5yZWRJQWRkKHl5eXk4KTtcblx0ICAgIG55ID0gbS5yZWRNdWwocy5yZWRJU3ViKHQpKS5yZWRJU3ViKHl5eXk4KTtcblx0ICAgIC8vIFozID0gMiAqIFkxXG5cdCAgICBueiA9IHRoaXMueS5yZWRBZGQodGhpcy55KTtcblx0ICB9IGVsc2Uge1xuXHQgICAgLy8gaHlwZXJlbGxpcHRpYy5vcmcvRUZEL2cxcC9hdXRvLXNob3J0dy1qYWNvYmlhbi0zLmh0bWwjZG91YmxpbmctZGJsLTIwMDEtYlxuXHQgICAgLy8gM00gKyA1U1xuXG5cdCAgICAvLyBkZWx0YSA9IFoxXjJcblx0ICAgIHZhciBkZWx0YSA9IHRoaXMuei5yZWRTcXIoKTtcblx0ICAgIC8vIGdhbW1hID0gWTFeMlxuXHQgICAgdmFyIGdhbW1hID0gdGhpcy55LnJlZFNxcigpO1xuXHQgICAgLy8gYmV0YSA9IFgxICogZ2FtbWFcblx0ICAgIHZhciBiZXRhID0gdGhpcy54LnJlZE11bChnYW1tYSk7XG5cdCAgICAvLyBhbHBoYSA9IDMgKiAoWDEgLSBkZWx0YSkgKiAoWDEgKyBkZWx0YSlcblx0ICAgIHZhciBhbHBoYSA9IHRoaXMueC5yZWRTdWIoZGVsdGEpLnJlZE11bCh0aGlzLngucmVkQWRkKGRlbHRhKSk7XG5cdCAgICBhbHBoYSA9IGFscGhhLnJlZEFkZChhbHBoYSkucmVkSUFkZChhbHBoYSk7XG5cdCAgICAvLyBYMyA9IGFscGhhXjIgLSA4ICogYmV0YVxuXHQgICAgdmFyIGJldGE0ID0gYmV0YS5yZWRJQWRkKGJldGEpO1xuXHQgICAgYmV0YTQgPSBiZXRhNC5yZWRJQWRkKGJldGE0KTtcblx0ICAgIHZhciBiZXRhOCA9IGJldGE0LnJlZEFkZChiZXRhNCk7XG5cdCAgICBueCA9IGFscGhhLnJlZFNxcigpLnJlZElTdWIoYmV0YTgpO1xuXHQgICAgLy8gWjMgPSAoWTEgKyBaMSleMiAtIGdhbW1hIC0gZGVsdGFcblx0ICAgIG56ID0gdGhpcy55LnJlZEFkZCh0aGlzLnopLnJlZFNxcigpLnJlZElTdWIoZ2FtbWEpLnJlZElTdWIoZGVsdGEpO1xuXHQgICAgLy8gWTMgPSBhbHBoYSAqICg0ICogYmV0YSAtIFgzKSAtIDggKiBnYW1tYV4yXG5cdCAgICB2YXIgZ2dhbW1hOCA9IGdhbW1hLnJlZFNxcigpO1xuXHQgICAgZ2dhbW1hOCA9IGdnYW1tYTgucmVkSUFkZChnZ2FtbWE4KTtcblx0ICAgIGdnYW1tYTggPSBnZ2FtbWE4LnJlZElBZGQoZ2dhbW1hOCk7XG5cdCAgICBnZ2FtbWE4ID0gZ2dhbW1hOC5yZWRJQWRkKGdnYW1tYTgpO1xuXHQgICAgbnkgPSBhbHBoYS5yZWRNdWwoYmV0YTQucmVkSVN1YihueCkpLnJlZElTdWIoZ2dhbW1hOCk7XG5cdCAgfVxuXG5cdCAgcmV0dXJuIHRoaXMuY3VydmUuanBvaW50KG54LCBueSwgbnopO1xuXHR9O1xuXG5cdEpQb2ludC5wcm90b3R5cGUuX2RibCA9IGZ1bmN0aW9uIF9kYmwoKSB7XG5cdCAgdmFyIGEgPSB0aGlzLmN1cnZlLmE7XG5cblx0ICAvLyA0TSArIDZTICsgMTBBXG5cdCAgdmFyIGp4ID0gdGhpcy54O1xuXHQgIHZhciBqeSA9IHRoaXMueTtcblx0ICB2YXIganogPSB0aGlzLno7XG5cdCAgdmFyIGp6NCA9IGp6LnJlZFNxcigpLnJlZFNxcigpO1xuXG5cdCAgdmFyIGp4MiA9IGp4LnJlZFNxcigpO1xuXHQgIHZhciBqeTIgPSBqeS5yZWRTcXIoKTtcblxuXHQgIHZhciBjID0gangyLnJlZEFkZChqeDIpLnJlZElBZGQoangyKS5yZWRJQWRkKGEucmVkTXVsKGp6NCkpO1xuXG5cdCAgdmFyIGp4ZDQgPSBqeC5yZWRBZGQoangpO1xuXHQgIGp4ZDQgPSBqeGQ0LnJlZElBZGQoanhkNCk7XG5cdCAgdmFyIHQxID0ganhkNC5yZWRNdWwoankyKTtcblx0ICB2YXIgbnggPSBjLnJlZFNxcigpLnJlZElTdWIodDEucmVkQWRkKHQxKSk7XG5cdCAgdmFyIHQyID0gdDEucmVkSVN1YihueCk7XG5cblx0ICB2YXIganlkOCA9IGp5Mi5yZWRTcXIoKTtcblx0ICBqeWQ4ID0ganlkOC5yZWRJQWRkKGp5ZDgpO1xuXHQgIGp5ZDggPSBqeWQ4LnJlZElBZGQoanlkOCk7XG5cdCAganlkOCA9IGp5ZDgucmVkSUFkZChqeWQ4KTtcblx0ICB2YXIgbnkgPSBjLnJlZE11bCh0MikucmVkSVN1YihqeWQ4KTtcblx0ICB2YXIgbnogPSBqeS5yZWRBZGQoankpLnJlZE11bChqeik7XG5cblx0ICByZXR1cm4gdGhpcy5jdXJ2ZS5qcG9pbnQobngsIG55LCBueik7XG5cdH07XG5cblx0SlBvaW50LnByb3RvdHlwZS50cnBsID0gZnVuY3Rpb24gdHJwbCgpIHtcblx0ICBpZiAoIXRoaXMuY3VydmUuemVyb0EpXG5cdCAgICByZXR1cm4gdGhpcy5kYmwoKS5hZGQodGhpcyk7XG5cblx0ICAvLyBoeXBlcmVsbGlwdGljLm9yZy9FRkQvZzFwL2F1dG8tc2hvcnR3LWphY29iaWFuLTAuaHRtbCN0cmlwbGluZy10cGwtMjAwNy1ibFxuXHQgIC8vIDVNICsgMTBTICsgLi4uXG5cblx0ICAvLyBYWCA9IFgxXjJcblx0ICB2YXIgeHggPSB0aGlzLngucmVkU3FyKCk7XG5cdCAgLy8gWVkgPSBZMV4yXG5cdCAgdmFyIHl5ID0gdGhpcy55LnJlZFNxcigpO1xuXHQgIC8vIFpaID0gWjFeMlxuXHQgIHZhciB6eiA9IHRoaXMuei5yZWRTcXIoKTtcblx0ICAvLyBZWVlZID0gWVleMlxuXHQgIHZhciB5eXl5ID0geXkucmVkU3FyKCk7XG5cdCAgLy8gTSA9IDMgKiBYWCArIGEgKiBaWjI7IGEgPSAwXG5cdCAgdmFyIG0gPSB4eC5yZWRBZGQoeHgpLnJlZElBZGQoeHgpO1xuXHQgIC8vIE1NID0gTV4yXG5cdCAgdmFyIG1tID0gbS5yZWRTcXIoKTtcblx0ICAvLyBFID0gNiAqICgoWDEgKyBZWSleMiAtIFhYIC0gWVlZWSkgLSBNTVxuXHQgIHZhciBlID0gdGhpcy54LnJlZEFkZCh5eSkucmVkU3FyKCkucmVkSVN1Yih4eCkucmVkSVN1Yih5eXl5KTtcblx0ICBlID0gZS5yZWRJQWRkKGUpO1xuXHQgIGUgPSBlLnJlZEFkZChlKS5yZWRJQWRkKGUpO1xuXHQgIGUgPSBlLnJlZElTdWIobW0pO1xuXHQgIC8vIEVFID0gRV4yXG5cdCAgdmFyIGVlID0gZS5yZWRTcXIoKTtcblx0ICAvLyBUID0gMTYqWVlZWVxuXHQgIHZhciB0ID0geXl5eS5yZWRJQWRkKHl5eXkpO1xuXHQgIHQgPSB0LnJlZElBZGQodCk7XG5cdCAgdCA9IHQucmVkSUFkZCh0KTtcblx0ICB0ID0gdC5yZWRJQWRkKHQpO1xuXHQgIC8vIFUgPSAoTSArIEUpXjIgLSBNTSAtIEVFIC0gVFxuXHQgIHZhciB1ID0gbS5yZWRJQWRkKGUpLnJlZFNxcigpLnJlZElTdWIobW0pLnJlZElTdWIoZWUpLnJlZElTdWIodCk7XG5cdCAgLy8gWDMgPSA0ICogKFgxICogRUUgLSA0ICogWVkgKiBVKVxuXHQgIHZhciB5eXU0ID0geXkucmVkTXVsKHUpO1xuXHQgIHl5dTQgPSB5eXU0LnJlZElBZGQoeXl1NCk7XG5cdCAgeXl1NCA9IHl5dTQucmVkSUFkZCh5eXU0KTtcblx0ICB2YXIgbnggPSB0aGlzLngucmVkTXVsKGVlKS5yZWRJU3ViKHl5dTQpO1xuXHQgIG54ID0gbngucmVkSUFkZChueCk7XG5cdCAgbnggPSBueC5yZWRJQWRkKG54KTtcblx0ICAvLyBZMyA9IDggKiBZMSAqIChVICogKFQgLSBVKSAtIEUgKiBFRSlcblx0ICB2YXIgbnkgPSB0aGlzLnkucmVkTXVsKHUucmVkTXVsKHQucmVkSVN1Yih1KSkucmVkSVN1YihlLnJlZE11bChlZSkpKTtcblx0ICBueSA9IG55LnJlZElBZGQobnkpO1xuXHQgIG55ID0gbnkucmVkSUFkZChueSk7XG5cdCAgbnkgPSBueS5yZWRJQWRkKG55KTtcblx0ICAvLyBaMyA9IChaMSArIEUpXjIgLSBaWiAtIEVFXG5cdCAgdmFyIG56ID0gdGhpcy56LnJlZEFkZChlKS5yZWRTcXIoKS5yZWRJU3ViKHp6KS5yZWRJU3ViKGVlKTtcblxuXHQgIHJldHVybiB0aGlzLmN1cnZlLmpwb2ludChueCwgbnksIG56KTtcblx0fTtcblxuXHRKUG9pbnQucHJvdG90eXBlLm11bCA9IGZ1bmN0aW9uIG11bChrLCBrYmFzZSkge1xuXHQgIGsgPSBuZXcgYm4oaywga2Jhc2UpO1xuXG5cdCAgcmV0dXJuIHRoaXMuY3VydmUuX3duYWZNdWwodGhpcywgayk7XG5cdH07XG5cblx0SlBvaW50LnByb3RvdHlwZS5lcSA9IGZ1bmN0aW9uIGVxKHApIHtcblx0ICBpZiAocC50eXBlID09PSAnYWZmaW5lJylcblx0ICAgIHJldHVybiB0aGlzLmVxKHAudG9KKCkpO1xuXG5cdCAgaWYgKHRoaXMgPT09IHApXG5cdCAgICByZXR1cm4gdHJ1ZTtcblxuXHQgIC8vIHgxICogejJeMiA9PSB4MiAqIHoxXjJcblx0ICB2YXIgejIgPSB0aGlzLnoucmVkU3FyKCk7XG5cdCAgdmFyIHB6MiA9IHAuei5yZWRTcXIoKTtcblx0ICBpZiAodGhpcy54LnJlZE11bChwejIpLnJlZElTdWIocC54LnJlZE11bCh6MikpLmNtcG4oMCkgIT09IDApXG5cdCAgICByZXR1cm4gZmFsc2U7XG5cblx0ICAvLyB5MSAqIHoyXjMgPT0geTIgKiB6MV4zXG5cdCAgdmFyIHozID0gejIucmVkTXVsKHRoaXMueik7XG5cdCAgdmFyIHB6MyA9IHB6Mi5yZWRNdWwocC56KTtcblx0ICByZXR1cm4gdGhpcy55LnJlZE11bChwejMpLnJlZElTdWIocC55LnJlZE11bCh6MykpLmNtcG4oMCkgPT09IDA7XG5cdH07XG5cblx0SlBvaW50LnByb3RvdHlwZS5lcVhUb1AgPSBmdW5jdGlvbiBlcVhUb1AoeCkge1xuXHQgIHZhciB6cyA9IHRoaXMuei5yZWRTcXIoKTtcblx0ICB2YXIgcnggPSB4LnRvUmVkKHRoaXMuY3VydmUucmVkKS5yZWRNdWwoenMpO1xuXHQgIGlmICh0aGlzLnguY21wKHJ4KSA9PT0gMClcblx0ICAgIHJldHVybiB0cnVlO1xuXG5cdCAgdmFyIHhjID0geC5jbG9uZSgpO1xuXHQgIHZhciB0ID0gdGhpcy5jdXJ2ZS5yZWROLnJlZE11bCh6cyk7XG5cdCAgZm9yICg7Oykge1xuXHQgICAgeGMuaWFkZCh0aGlzLmN1cnZlLm4pO1xuXHQgICAgaWYgKHhjLmNtcCh0aGlzLmN1cnZlLnApID49IDApXG5cdCAgICAgIHJldHVybiBmYWxzZTtcblxuXHQgICAgcngucmVkSUFkZCh0KTtcblx0ICAgIGlmICh0aGlzLnguY21wKHJ4KSA9PT0gMClcblx0ICAgICAgcmV0dXJuIHRydWU7XG5cdCAgfVxuXHR9O1xuXG5cdEpQb2ludC5wcm90b3R5cGUuaW5zcGVjdCA9IGZ1bmN0aW9uIGluc3BlY3QoKSB7XG5cdCAgaWYgKHRoaXMuaXNJbmZpbml0eSgpKVxuXHQgICAgcmV0dXJuICc8RUMgSlBvaW50IEluZmluaXR5Pic7XG5cdCAgcmV0dXJuICc8RUMgSlBvaW50IHg6ICcgKyB0aGlzLngudG9TdHJpbmcoMTYsIDIpICtcblx0ICAgICAgJyB5OiAnICsgdGhpcy55LnRvU3RyaW5nKDE2LCAyKSArXG5cdCAgICAgICcgejogJyArIHRoaXMuei50b1N0cmluZygxNiwgMikgKyAnPic7XG5cdH07XG5cblx0SlBvaW50LnByb3RvdHlwZS5pc0luZmluaXR5ID0gZnVuY3Rpb24gaXNJbmZpbml0eSgpIHtcblx0ICAvLyBYWFggVGhpcyBjb2RlIGFzc3VtZXMgdGhhdCB6ZXJvIGlzIGFsd2F5cyB6ZXJvIGluIHJlZFxuXHQgIHJldHVybiB0aGlzLnouY21wbigwKSA9PT0gMDtcblx0fTtcblxuXHR2YXIgY3VydmVfMSA9IGNyZWF0ZUNvbW1vbmpzTW9kdWxlKGZ1bmN0aW9uIChtb2R1bGUsIGV4cG9ydHMpIHtcblx0J3VzZSBzdHJpY3QnO1xuXG5cdHZhciBjdXJ2ZSA9IGV4cG9ydHM7XG5cblx0Y3VydmUuYmFzZSA9IGJhc2U7XG5cdGN1cnZlLnNob3J0ID0gc2hvcnRfMTtcblx0Y3VydmUubW9udCA9IC8qUmljTW9vOmV0aGVyczpyZXF1aXJlKC4vbW9udCkqLyhudWxsKTtcblx0Y3VydmUuZWR3YXJkcyA9IC8qUmljTW9vOmV0aGVyczpyZXF1aXJlKC4vZWR3YXJkcykqLyhudWxsKTtcblx0fSk7XG5cblx0J3VzZSBzdHJpY3QnO1xuXG5cblxuXG5cdHZhciBpbmhlcml0c18xID0gaW5oZXJpdHNfYnJvd3NlcjtcblxuXHRmdW5jdGlvbiBpc1N1cnJvZ2F0ZVBhaXIobXNnLCBpKSB7XG5cdCAgaWYgKChtc2cuY2hhckNvZGVBdChpKSAmIDB4RkMwMCkgIT09IDB4RDgwMCkge1xuXHQgICAgcmV0dXJuIGZhbHNlO1xuXHQgIH1cblx0ICBpZiAoaSA8IDAgfHwgaSArIDEgPj0gbXNnLmxlbmd0aCkge1xuXHQgICAgcmV0dXJuIGZhbHNlO1xuXHQgIH1cblx0ICByZXR1cm4gKG1zZy5jaGFyQ29kZUF0KGkgKyAxKSAmIDB4RkMwMCkgPT09IDB4REMwMDtcblx0fVxuXG5cdGZ1bmN0aW9uIHRvQXJyYXkobXNnLCBlbmMpIHtcblx0ICBpZiAoQXJyYXkuaXNBcnJheShtc2cpKVxuXHQgICAgcmV0dXJuIG1zZy5zbGljZSgpO1xuXHQgIGlmICghbXNnKVxuXHQgICAgcmV0dXJuIFtdO1xuXHQgIHZhciByZXMgPSBbXTtcblx0ICBpZiAodHlwZW9mIG1zZyA9PT0gJ3N0cmluZycpIHtcblx0ICAgIGlmICghZW5jKSB7XG5cdCAgICAgIC8vIEluc3BpcmVkIGJ5IHN0cmluZ1RvVXRmOEJ5dGVBcnJheSgpIGluIGNsb3N1cmUtbGlicmFyeSBieSBHb29nbGVcblx0ICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2dvb2dsZS9jbG9zdXJlLWxpYnJhcnkvYmxvYi84NTk4ZDg3MjQyYWY1OWFhYzIzMzI3MDc0MmM4OTg0ZTJiMmJkYmUwL2Nsb3N1cmUvZ29vZy9jcnlwdC9jcnlwdC5qcyNMMTE3LUwxNDNcblx0ICAgICAgLy8gQXBhY2hlIExpY2Vuc2UgMi4wXG5cdCAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9nb29nbGUvY2xvc3VyZS1saWJyYXJ5L2Jsb2IvbWFzdGVyL0xJQ0VOU0Vcblx0ICAgICAgdmFyIHAgPSAwO1xuXHQgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG1zZy5sZW5ndGg7IGkrKykge1xuXHQgICAgICAgIHZhciBjID0gbXNnLmNoYXJDb2RlQXQoaSk7XG5cdCAgICAgICAgaWYgKGMgPCAxMjgpIHtcblx0ICAgICAgICAgIHJlc1twKytdID0gYztcblx0ICAgICAgICB9IGVsc2UgaWYgKGMgPCAyMDQ4KSB7XG5cdCAgICAgICAgICByZXNbcCsrXSA9IChjID4+IDYpIHwgMTkyO1xuXHQgICAgICAgICAgcmVzW3ArK10gPSAoYyAmIDYzKSB8IDEyODtcblx0ICAgICAgICB9IGVsc2UgaWYgKGlzU3Vycm9nYXRlUGFpcihtc2csIGkpKSB7XG5cdCAgICAgICAgICBjID0gMHgxMDAwMCArICgoYyAmIDB4MDNGRikgPDwgMTApICsgKG1zZy5jaGFyQ29kZUF0KCsraSkgJiAweDAzRkYpO1xuXHQgICAgICAgICAgcmVzW3ArK10gPSAoYyA+PiAxOCkgfCAyNDA7XG5cdCAgICAgICAgICByZXNbcCsrXSA9ICgoYyA+PiAxMikgJiA2MykgfCAxMjg7XG5cdCAgICAgICAgICByZXNbcCsrXSA9ICgoYyA+PiA2KSAmIDYzKSB8IDEyODtcblx0ICAgICAgICAgIHJlc1twKytdID0gKGMgJiA2MykgfCAxMjg7XG5cdCAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgIHJlc1twKytdID0gKGMgPj4gMTIpIHwgMjI0O1xuXHQgICAgICAgICAgcmVzW3ArK10gPSAoKGMgPj4gNikgJiA2MykgfCAxMjg7XG5cdCAgICAgICAgICByZXNbcCsrXSA9IChjICYgNjMpIHwgMTI4O1xuXHQgICAgICAgIH1cblx0ICAgICAgfVxuXHQgICAgfSBlbHNlIGlmIChlbmMgPT09ICdoZXgnKSB7XG5cdCAgICAgIG1zZyA9IG1zZy5yZXBsYWNlKC9bXmEtejAtOV0rL2lnLCAnJyk7XG5cdCAgICAgIGlmIChtc2cubGVuZ3RoICUgMiAhPT0gMClcblx0ICAgICAgICBtc2cgPSAnMCcgKyBtc2c7XG5cdCAgICAgIGZvciAoaSA9IDA7IGkgPCBtc2cubGVuZ3RoOyBpICs9IDIpXG5cdCAgICAgICAgcmVzLnB1c2gocGFyc2VJbnQobXNnW2ldICsgbXNnW2kgKyAxXSwgMTYpKTtcblx0ICAgIH1cblx0ICB9IGVsc2Uge1xuXHQgICAgZm9yIChpID0gMDsgaSA8IG1zZy5sZW5ndGg7IGkrKylcblx0ICAgICAgcmVzW2ldID0gbXNnW2ldIHwgMDtcblx0ICB9XG5cdCAgcmV0dXJuIHJlcztcblx0fVxuXHR2YXIgdG9BcnJheV8xID0gdG9BcnJheTtcblxuXHRmdW5jdGlvbiB0b0hleChtc2cpIHtcblx0ICB2YXIgcmVzID0gJyc7XG5cdCAgZm9yICh2YXIgaSA9IDA7IGkgPCBtc2cubGVuZ3RoOyBpKyspXG5cdCAgICByZXMgKz0gemVybzIobXNnW2ldLnRvU3RyaW5nKDE2KSk7XG5cdCAgcmV0dXJuIHJlcztcblx0fVxuXHR2YXIgdG9IZXhfMSA9IHRvSGV4O1xuXG5cdGZ1bmN0aW9uIGh0b25sKHcpIHtcblx0ICB2YXIgcmVzID0gKHcgPj4+IDI0KSB8XG5cdCAgICAgICAgICAgICgodyA+Pj4gOCkgJiAweGZmMDApIHxcblx0ICAgICAgICAgICAgKCh3IDw8IDgpICYgMHhmZjAwMDApIHxcblx0ICAgICAgICAgICAgKCh3ICYgMHhmZikgPDwgMjQpO1xuXHQgIHJldHVybiByZXMgPj4+IDA7XG5cdH1cblx0dmFyIGh0b25sXzEgPSBodG9ubDtcblxuXHRmdW5jdGlvbiB0b0hleDMyKG1zZywgZW5kaWFuKSB7XG5cdCAgdmFyIHJlcyA9ICcnO1xuXHQgIGZvciAodmFyIGkgPSAwOyBpIDwgbXNnLmxlbmd0aDsgaSsrKSB7XG5cdCAgICB2YXIgdyA9IG1zZ1tpXTtcblx0ICAgIGlmIChlbmRpYW4gPT09ICdsaXR0bGUnKVxuXHQgICAgICB3ID0gaHRvbmwodyk7XG5cdCAgICByZXMgKz0gemVybzgody50b1N0cmluZygxNikpO1xuXHQgIH1cblx0ICByZXR1cm4gcmVzO1xuXHR9XG5cdHZhciB0b0hleDMyXzEgPSB0b0hleDMyO1xuXG5cdGZ1bmN0aW9uIHplcm8yKHdvcmQpIHtcblx0ICBpZiAod29yZC5sZW5ndGggPT09IDEpXG5cdCAgICByZXR1cm4gJzAnICsgd29yZDtcblx0ICBlbHNlXG5cdCAgICByZXR1cm4gd29yZDtcblx0fVxuXHR2YXIgemVybzJfMSA9IHplcm8yO1xuXG5cdGZ1bmN0aW9uIHplcm84KHdvcmQpIHtcblx0ICBpZiAod29yZC5sZW5ndGggPT09IDcpXG5cdCAgICByZXR1cm4gJzAnICsgd29yZDtcblx0ICBlbHNlIGlmICh3b3JkLmxlbmd0aCA9PT0gNilcblx0ICAgIHJldHVybiAnMDAnICsgd29yZDtcblx0ICBlbHNlIGlmICh3b3JkLmxlbmd0aCA9PT0gNSlcblx0ICAgIHJldHVybiAnMDAwJyArIHdvcmQ7XG5cdCAgZWxzZSBpZiAod29yZC5sZW5ndGggPT09IDQpXG5cdCAgICByZXR1cm4gJzAwMDAnICsgd29yZDtcblx0ICBlbHNlIGlmICh3b3JkLmxlbmd0aCA9PT0gMylcblx0ICAgIHJldHVybiAnMDAwMDAnICsgd29yZDtcblx0ICBlbHNlIGlmICh3b3JkLmxlbmd0aCA9PT0gMilcblx0ICAgIHJldHVybiAnMDAwMDAwJyArIHdvcmQ7XG5cdCAgZWxzZSBpZiAod29yZC5sZW5ndGggPT09IDEpXG5cdCAgICByZXR1cm4gJzAwMDAwMDAnICsgd29yZDtcblx0ICBlbHNlXG5cdCAgICByZXR1cm4gd29yZDtcblx0fVxuXHR2YXIgemVybzhfMSA9IHplcm84O1xuXG5cdGZ1bmN0aW9uIGpvaW4zMihtc2csIHN0YXJ0LCBlbmQsIGVuZGlhbikge1xuXHQgIHZhciBsZW4gPSBlbmQgLSBzdGFydDtcblx0ICBtaW5pbWFsaXN0aWNBc3NlcnQobGVuICUgNCA9PT0gMCk7XG5cdCAgdmFyIHJlcyA9IG5ldyBBcnJheShsZW4gLyA0KTtcblx0ICBmb3IgKHZhciBpID0gMCwgayA9IHN0YXJ0OyBpIDwgcmVzLmxlbmd0aDsgaSsrLCBrICs9IDQpIHtcblx0ICAgIHZhciB3O1xuXHQgICAgaWYgKGVuZGlhbiA9PT0gJ2JpZycpXG5cdCAgICAgIHcgPSAobXNnW2tdIDw8IDI0KSB8IChtc2dbayArIDFdIDw8IDE2KSB8IChtc2dbayArIDJdIDw8IDgpIHwgbXNnW2sgKyAzXTtcblx0ICAgIGVsc2Vcblx0ICAgICAgdyA9IChtc2dbayArIDNdIDw8IDI0KSB8IChtc2dbayArIDJdIDw8IDE2KSB8IChtc2dbayArIDFdIDw8IDgpIHwgbXNnW2tdO1xuXHQgICAgcmVzW2ldID0gdyA+Pj4gMDtcblx0ICB9XG5cdCAgcmV0dXJuIHJlcztcblx0fVxuXHR2YXIgam9pbjMyXzEgPSBqb2luMzI7XG5cblx0ZnVuY3Rpb24gc3BsaXQzMihtc2csIGVuZGlhbikge1xuXHQgIHZhciByZXMgPSBuZXcgQXJyYXkobXNnLmxlbmd0aCAqIDQpO1xuXHQgIGZvciAodmFyIGkgPSAwLCBrID0gMDsgaSA8IG1zZy5sZW5ndGg7IGkrKywgayArPSA0KSB7XG5cdCAgICB2YXIgbSA9IG1zZ1tpXTtcblx0ICAgIGlmIChlbmRpYW4gPT09ICdiaWcnKSB7XG5cdCAgICAgIHJlc1trXSA9IG0gPj4+IDI0O1xuXHQgICAgICByZXNbayArIDFdID0gKG0gPj4+IDE2KSAmIDB4ZmY7XG5cdCAgICAgIHJlc1trICsgMl0gPSAobSA+Pj4gOCkgJiAweGZmO1xuXHQgICAgICByZXNbayArIDNdID0gbSAmIDB4ZmY7XG5cdCAgICB9IGVsc2Uge1xuXHQgICAgICByZXNbayArIDNdID0gbSA+Pj4gMjQ7XG5cdCAgICAgIHJlc1trICsgMl0gPSAobSA+Pj4gMTYpICYgMHhmZjtcblx0ICAgICAgcmVzW2sgKyAxXSA9IChtID4+PiA4KSAmIDB4ZmY7XG5cdCAgICAgIHJlc1trXSA9IG0gJiAweGZmO1xuXHQgICAgfVxuXHQgIH1cblx0ICByZXR1cm4gcmVzO1xuXHR9XG5cdHZhciBzcGxpdDMyXzEgPSBzcGxpdDMyO1xuXG5cdGZ1bmN0aW9uIHJvdHIzMih3LCBiKSB7XG5cdCAgcmV0dXJuICh3ID4+PiBiKSB8ICh3IDw8ICgzMiAtIGIpKTtcblx0fVxuXHR2YXIgcm90cjMyXzEgPSByb3RyMzI7XG5cblx0ZnVuY3Rpb24gcm90bDMyKHcsIGIpIHtcblx0ICByZXR1cm4gKHcgPDwgYikgfCAodyA+Pj4gKDMyIC0gYikpO1xuXHR9XG5cdHZhciByb3RsMzJfMSA9IHJvdGwzMjtcblxuXHRmdW5jdGlvbiBzdW0zMihhLCBiKSB7XG5cdCAgcmV0dXJuIChhICsgYikgPj4+IDA7XG5cdH1cblx0dmFyIHN1bTMyXzEgPSBzdW0zMjtcblxuXHRmdW5jdGlvbiBzdW0zMl8zKGEsIGIsIGMpIHtcblx0ICByZXR1cm4gKGEgKyBiICsgYykgPj4+IDA7XG5cdH1cblx0dmFyIHN1bTMyXzNfMSA9IHN1bTMyXzM7XG5cblx0ZnVuY3Rpb24gc3VtMzJfNChhLCBiLCBjLCBkKSB7XG5cdCAgcmV0dXJuIChhICsgYiArIGMgKyBkKSA+Pj4gMDtcblx0fVxuXHR2YXIgc3VtMzJfNF8xID0gc3VtMzJfNDtcblxuXHRmdW5jdGlvbiBzdW0zMl81KGEsIGIsIGMsIGQsIGUpIHtcblx0ICByZXR1cm4gKGEgKyBiICsgYyArIGQgKyBlKSA+Pj4gMDtcblx0fVxuXHR2YXIgc3VtMzJfNV8xID0gc3VtMzJfNTtcblxuXHRmdW5jdGlvbiBzdW02NChidWYsIHBvcywgYWgsIGFsKSB7XG5cdCAgdmFyIGJoID0gYnVmW3Bvc107XG5cdCAgdmFyIGJsID0gYnVmW3BvcyArIDFdO1xuXG5cdCAgdmFyIGxvID0gKGFsICsgYmwpID4+PiAwO1xuXHQgIHZhciBoaSA9IChsbyA8IGFsID8gMSA6IDApICsgYWggKyBiaDtcblx0ICBidWZbcG9zXSA9IGhpID4+PiAwO1xuXHQgIGJ1Zltwb3MgKyAxXSA9IGxvO1xuXHR9XG5cdHZhciBzdW02NF8xID0gc3VtNjQ7XG5cblx0ZnVuY3Rpb24gc3VtNjRfaGkoYWgsIGFsLCBiaCwgYmwpIHtcblx0ICB2YXIgbG8gPSAoYWwgKyBibCkgPj4+IDA7XG5cdCAgdmFyIGhpID0gKGxvIDwgYWwgPyAxIDogMCkgKyBhaCArIGJoO1xuXHQgIHJldHVybiBoaSA+Pj4gMDtcblx0fVxuXHR2YXIgc3VtNjRfaGlfMSA9IHN1bTY0X2hpO1xuXG5cdGZ1bmN0aW9uIHN1bTY0X2xvKGFoLCBhbCwgYmgsIGJsKSB7XG5cdCAgdmFyIGxvID0gYWwgKyBibDtcblx0ICByZXR1cm4gbG8gPj4+IDA7XG5cdH1cblx0dmFyIHN1bTY0X2xvXzEgPSBzdW02NF9sbztcblxuXHRmdW5jdGlvbiBzdW02NF80X2hpKGFoLCBhbCwgYmgsIGJsLCBjaCwgY2wsIGRoLCBkbCkge1xuXHQgIHZhciBjYXJyeSA9IDA7XG5cdCAgdmFyIGxvID0gYWw7XG5cdCAgbG8gPSAobG8gKyBibCkgPj4+IDA7XG5cdCAgY2FycnkgKz0gbG8gPCBhbCA/IDEgOiAwO1xuXHQgIGxvID0gKGxvICsgY2wpID4+PiAwO1xuXHQgIGNhcnJ5ICs9IGxvIDwgY2wgPyAxIDogMDtcblx0ICBsbyA9IChsbyArIGRsKSA+Pj4gMDtcblx0ICBjYXJyeSArPSBsbyA8IGRsID8gMSA6IDA7XG5cblx0ICB2YXIgaGkgPSBhaCArIGJoICsgY2ggKyBkaCArIGNhcnJ5O1xuXHQgIHJldHVybiBoaSA+Pj4gMDtcblx0fVxuXHR2YXIgc3VtNjRfNF9oaV8xID0gc3VtNjRfNF9oaTtcblxuXHRmdW5jdGlvbiBzdW02NF80X2xvKGFoLCBhbCwgYmgsIGJsLCBjaCwgY2wsIGRoLCBkbCkge1xuXHQgIHZhciBsbyA9IGFsICsgYmwgKyBjbCArIGRsO1xuXHQgIHJldHVybiBsbyA+Pj4gMDtcblx0fVxuXHR2YXIgc3VtNjRfNF9sb18xID0gc3VtNjRfNF9sbztcblxuXHRmdW5jdGlvbiBzdW02NF81X2hpKGFoLCBhbCwgYmgsIGJsLCBjaCwgY2wsIGRoLCBkbCwgZWgsIGVsKSB7XG5cdCAgdmFyIGNhcnJ5ID0gMDtcblx0ICB2YXIgbG8gPSBhbDtcblx0ICBsbyA9IChsbyArIGJsKSA+Pj4gMDtcblx0ICBjYXJyeSArPSBsbyA8IGFsID8gMSA6IDA7XG5cdCAgbG8gPSAobG8gKyBjbCkgPj4+IDA7XG5cdCAgY2FycnkgKz0gbG8gPCBjbCA/IDEgOiAwO1xuXHQgIGxvID0gKGxvICsgZGwpID4+PiAwO1xuXHQgIGNhcnJ5ICs9IGxvIDwgZGwgPyAxIDogMDtcblx0ICBsbyA9IChsbyArIGVsKSA+Pj4gMDtcblx0ICBjYXJyeSArPSBsbyA8IGVsID8gMSA6IDA7XG5cblx0ICB2YXIgaGkgPSBhaCArIGJoICsgY2ggKyBkaCArIGVoICsgY2Fycnk7XG5cdCAgcmV0dXJuIGhpID4+PiAwO1xuXHR9XG5cdHZhciBzdW02NF81X2hpXzEgPSBzdW02NF81X2hpO1xuXG5cdGZ1bmN0aW9uIHN1bTY0XzVfbG8oYWgsIGFsLCBiaCwgYmwsIGNoLCBjbCwgZGgsIGRsLCBlaCwgZWwpIHtcblx0ICB2YXIgbG8gPSBhbCArIGJsICsgY2wgKyBkbCArIGVsO1xuXG5cdCAgcmV0dXJuIGxvID4+PiAwO1xuXHR9XG5cdHZhciBzdW02NF81X2xvXzEgPSBzdW02NF81X2xvO1xuXG5cdGZ1bmN0aW9uIHJvdHI2NF9oaShhaCwgYWwsIG51bSkge1xuXHQgIHZhciByID0gKGFsIDw8ICgzMiAtIG51bSkpIHwgKGFoID4+PiBudW0pO1xuXHQgIHJldHVybiByID4+PiAwO1xuXHR9XG5cdHZhciByb3RyNjRfaGlfMSA9IHJvdHI2NF9oaTtcblxuXHRmdW5jdGlvbiByb3RyNjRfbG8oYWgsIGFsLCBudW0pIHtcblx0ICB2YXIgciA9IChhaCA8PCAoMzIgLSBudW0pKSB8IChhbCA+Pj4gbnVtKTtcblx0ICByZXR1cm4gciA+Pj4gMDtcblx0fVxuXHR2YXIgcm90cjY0X2xvXzEgPSByb3RyNjRfbG87XG5cblx0ZnVuY3Rpb24gc2hyNjRfaGkoYWgsIGFsLCBudW0pIHtcblx0ICByZXR1cm4gYWggPj4+IG51bTtcblx0fVxuXHR2YXIgc2hyNjRfaGlfMSA9IHNocjY0X2hpO1xuXG5cdGZ1bmN0aW9uIHNocjY0X2xvKGFoLCBhbCwgbnVtKSB7XG5cdCAgdmFyIHIgPSAoYWggPDwgKDMyIC0gbnVtKSkgfCAoYWwgPj4+IG51bSk7XG5cdCAgcmV0dXJuIHIgPj4+IDA7XG5cdH1cblx0dmFyIHNocjY0X2xvXzEgPSBzaHI2NF9sbztcblxuXHR2YXIgdXRpbHMgPSB7XG5cdFx0aW5oZXJpdHM6IGluaGVyaXRzXzEsXG5cdFx0dG9BcnJheTogdG9BcnJheV8xLFxuXHRcdHRvSGV4OiB0b0hleF8xLFxuXHRcdGh0b25sOiBodG9ubF8xLFxuXHRcdHRvSGV4MzI6IHRvSGV4MzJfMSxcblx0XHR6ZXJvMjogemVybzJfMSxcblx0XHR6ZXJvODogemVybzhfMSxcblx0XHRqb2luMzI6IGpvaW4zMl8xLFxuXHRcdHNwbGl0MzI6IHNwbGl0MzJfMSxcblx0XHRyb3RyMzI6IHJvdHIzMl8xLFxuXHRcdHJvdGwzMjogcm90bDMyXzEsXG5cdFx0c3VtMzI6IHN1bTMyXzEsXG5cdFx0c3VtMzJfMzogc3VtMzJfM18xLFxuXHRcdHN1bTMyXzQ6IHN1bTMyXzRfMSxcblx0XHRzdW0zMl81OiBzdW0zMl81XzEsXG5cdFx0c3VtNjQ6IHN1bTY0XzEsXG5cdFx0c3VtNjRfaGk6IHN1bTY0X2hpXzEsXG5cdFx0c3VtNjRfbG86IHN1bTY0X2xvXzEsXG5cdFx0c3VtNjRfNF9oaTogc3VtNjRfNF9oaV8xLFxuXHRcdHN1bTY0XzRfbG86IHN1bTY0XzRfbG9fMSxcblx0XHRzdW02NF81X2hpOiBzdW02NF81X2hpXzEsXG5cdFx0c3VtNjRfNV9sbzogc3VtNjRfNV9sb18xLFxuXHRcdHJvdHI2NF9oaTogcm90cjY0X2hpXzEsXG5cdFx0cm90cjY0X2xvOiByb3RyNjRfbG9fMSxcblx0XHRzaHI2NF9oaTogc2hyNjRfaGlfMSxcblx0XHRzaHI2NF9sbzogc2hyNjRfbG9fMVxuXHR9O1xuXG5cdCd1c2Ugc3RyaWN0JztcblxuXG5cblxuXHRmdW5jdGlvbiBCbG9ja0hhc2goKSB7XG5cdCAgdGhpcy5wZW5kaW5nID0gbnVsbDtcblx0ICB0aGlzLnBlbmRpbmdUb3RhbCA9IDA7XG5cdCAgdGhpcy5ibG9ja1NpemUgPSB0aGlzLmNvbnN0cnVjdG9yLmJsb2NrU2l6ZTtcblx0ICB0aGlzLm91dFNpemUgPSB0aGlzLmNvbnN0cnVjdG9yLm91dFNpemU7XG5cdCAgdGhpcy5obWFjU3RyZW5ndGggPSB0aGlzLmNvbnN0cnVjdG9yLmhtYWNTdHJlbmd0aDtcblx0ICB0aGlzLnBhZExlbmd0aCA9IHRoaXMuY29uc3RydWN0b3IucGFkTGVuZ3RoIC8gODtcblx0ICB0aGlzLmVuZGlhbiA9ICdiaWcnO1xuXG5cdCAgdGhpcy5fZGVsdGE4ID0gdGhpcy5ibG9ja1NpemUgLyA4O1xuXHQgIHRoaXMuX2RlbHRhMzIgPSB0aGlzLmJsb2NrU2l6ZSAvIDMyO1xuXHR9XG5cdHZhciBCbG9ja0hhc2hfMSA9IEJsb2NrSGFzaDtcblxuXHRCbG9ja0hhc2gucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uIHVwZGF0ZShtc2csIGVuYykge1xuXHQgIC8vIENvbnZlcnQgbWVzc2FnZSB0byBhcnJheSwgcGFkIGl0LCBhbmQgam9pbiBpbnRvIDMyYml0IGJsb2Nrc1xuXHQgIG1zZyA9IHV0aWxzLnRvQXJyYXkobXNnLCBlbmMpO1xuXHQgIGlmICghdGhpcy5wZW5kaW5nKVxuXHQgICAgdGhpcy5wZW5kaW5nID0gbXNnO1xuXHQgIGVsc2Vcblx0ICAgIHRoaXMucGVuZGluZyA9IHRoaXMucGVuZGluZy5jb25jYXQobXNnKTtcblx0ICB0aGlzLnBlbmRpbmdUb3RhbCArPSBtc2cubGVuZ3RoO1xuXG5cdCAgLy8gRW5vdWdoIGRhdGEsIHRyeSB1cGRhdGluZ1xuXHQgIGlmICh0aGlzLnBlbmRpbmcubGVuZ3RoID49IHRoaXMuX2RlbHRhOCkge1xuXHQgICAgbXNnID0gdGhpcy5wZW5kaW5nO1xuXG5cdCAgICAvLyBQcm9jZXNzIHBlbmRpbmcgZGF0YSBpbiBibG9ja3Ncblx0ICAgIHZhciByID0gbXNnLmxlbmd0aCAlIHRoaXMuX2RlbHRhODtcblx0ICAgIHRoaXMucGVuZGluZyA9IG1zZy5zbGljZShtc2cubGVuZ3RoIC0gciwgbXNnLmxlbmd0aCk7XG5cdCAgICBpZiAodGhpcy5wZW5kaW5nLmxlbmd0aCA9PT0gMClcblx0ICAgICAgdGhpcy5wZW5kaW5nID0gbnVsbDtcblxuXHQgICAgbXNnID0gdXRpbHMuam9pbjMyKG1zZywgMCwgbXNnLmxlbmd0aCAtIHIsIHRoaXMuZW5kaWFuKTtcblx0ICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbXNnLmxlbmd0aDsgaSArPSB0aGlzLl9kZWx0YTMyKVxuXHQgICAgICB0aGlzLl91cGRhdGUobXNnLCBpLCBpICsgdGhpcy5fZGVsdGEzMik7XG5cdCAgfVxuXG5cdCAgcmV0dXJuIHRoaXM7XG5cdH07XG5cblx0QmxvY2tIYXNoLnByb3RvdHlwZS5kaWdlc3QgPSBmdW5jdGlvbiBkaWdlc3QoZW5jKSB7XG5cdCAgdGhpcy51cGRhdGUodGhpcy5fcGFkKCkpO1xuXHQgIG1pbmltYWxpc3RpY0Fzc2VydCh0aGlzLnBlbmRpbmcgPT09IG51bGwpO1xuXG5cdCAgcmV0dXJuIHRoaXMuX2RpZ2VzdChlbmMpO1xuXHR9O1xuXG5cdEJsb2NrSGFzaC5wcm90b3R5cGUuX3BhZCA9IGZ1bmN0aW9uIHBhZCgpIHtcblx0ICB2YXIgbGVuID0gdGhpcy5wZW5kaW5nVG90YWw7XG5cdCAgdmFyIGJ5dGVzID0gdGhpcy5fZGVsdGE4O1xuXHQgIHZhciBrID0gYnl0ZXMgLSAoKGxlbiArIHRoaXMucGFkTGVuZ3RoKSAlIGJ5dGVzKTtcblx0ICB2YXIgcmVzID0gbmV3IEFycmF5KGsgKyB0aGlzLnBhZExlbmd0aCk7XG5cdCAgcmVzWzBdID0gMHg4MDtcblx0ICBmb3IgKHZhciBpID0gMTsgaSA8IGs7IGkrKylcblx0ICAgIHJlc1tpXSA9IDA7XG5cblx0ICAvLyBBcHBlbmQgbGVuZ3RoXG5cdCAgbGVuIDw8PSAzO1xuXHQgIGlmICh0aGlzLmVuZGlhbiA9PT0gJ2JpZycpIHtcblx0ICAgIGZvciAodmFyIHQgPSA4OyB0IDwgdGhpcy5wYWRMZW5ndGg7IHQrKylcblx0ICAgICAgcmVzW2krK10gPSAwO1xuXG5cdCAgICByZXNbaSsrXSA9IDA7XG5cdCAgICByZXNbaSsrXSA9IDA7XG5cdCAgICByZXNbaSsrXSA9IDA7XG5cdCAgICByZXNbaSsrXSA9IDA7XG5cdCAgICByZXNbaSsrXSA9IChsZW4gPj4+IDI0KSAmIDB4ZmY7XG5cdCAgICByZXNbaSsrXSA9IChsZW4gPj4+IDE2KSAmIDB4ZmY7XG5cdCAgICByZXNbaSsrXSA9IChsZW4gPj4+IDgpICYgMHhmZjtcblx0ICAgIHJlc1tpKytdID0gbGVuICYgMHhmZjtcblx0ICB9IGVsc2Uge1xuXHQgICAgcmVzW2krK10gPSBsZW4gJiAweGZmO1xuXHQgICAgcmVzW2krK10gPSAobGVuID4+PiA4KSAmIDB4ZmY7XG5cdCAgICByZXNbaSsrXSA9IChsZW4gPj4+IDE2KSAmIDB4ZmY7XG5cdCAgICByZXNbaSsrXSA9IChsZW4gPj4+IDI0KSAmIDB4ZmY7XG5cdCAgICByZXNbaSsrXSA9IDA7XG5cdCAgICByZXNbaSsrXSA9IDA7XG5cdCAgICByZXNbaSsrXSA9IDA7XG5cdCAgICByZXNbaSsrXSA9IDA7XG5cblx0ICAgIGZvciAodCA9IDg7IHQgPCB0aGlzLnBhZExlbmd0aDsgdCsrKVxuXHQgICAgICByZXNbaSsrXSA9IDA7XG5cdCAgfVxuXG5cdCAgcmV0dXJuIHJlcztcblx0fTtcblxuXHR2YXIgY29tbW9uID0ge1xuXHRcdEJsb2NrSGFzaDogQmxvY2tIYXNoXzFcblx0fTtcblxuXHQndXNlIHN0cmljdCc7XG5cblxuXHR2YXIgcm90cjMyJDEgPSB1dGlscy5yb3RyMzI7XG5cblx0ZnVuY3Rpb24gZnRfMShzLCB4LCB5LCB6KSB7XG5cdCAgaWYgKHMgPT09IDApXG5cdCAgICByZXR1cm4gY2gzMih4LCB5LCB6KTtcblx0ICBpZiAocyA9PT0gMSB8fCBzID09PSAzKVxuXHQgICAgcmV0dXJuIHAzMih4LCB5LCB6KTtcblx0ICBpZiAocyA9PT0gMilcblx0ICAgIHJldHVybiBtYWozMih4LCB5LCB6KTtcblx0fVxuXHR2YXIgZnRfMV8xID0gZnRfMTtcblxuXHRmdW5jdGlvbiBjaDMyKHgsIHksIHopIHtcblx0ICByZXR1cm4gKHggJiB5KSBeICgofngpICYgeik7XG5cdH1cblx0dmFyIGNoMzJfMSA9IGNoMzI7XG5cblx0ZnVuY3Rpb24gbWFqMzIoeCwgeSwgeikge1xuXHQgIHJldHVybiAoeCAmIHkpIF4gKHggJiB6KSBeICh5ICYgeik7XG5cdH1cblx0dmFyIG1hajMyXzEgPSBtYWozMjtcblxuXHRmdW5jdGlvbiBwMzIoeCwgeSwgeikge1xuXHQgIHJldHVybiB4IF4geSBeIHo7XG5cdH1cblx0dmFyIHAzMl8xID0gcDMyO1xuXG5cdGZ1bmN0aW9uIHMwXzI1Nih4KSB7XG5cdCAgcmV0dXJuIHJvdHIzMiQxKHgsIDIpIF4gcm90cjMyJDEoeCwgMTMpIF4gcm90cjMyJDEoeCwgMjIpO1xuXHR9XG5cdHZhciBzMF8yNTZfMSA9IHMwXzI1NjtcblxuXHRmdW5jdGlvbiBzMV8yNTYoeCkge1xuXHQgIHJldHVybiByb3RyMzIkMSh4LCA2KSBeIHJvdHIzMiQxKHgsIDExKSBeIHJvdHIzMiQxKHgsIDI1KTtcblx0fVxuXHR2YXIgczFfMjU2XzEgPSBzMV8yNTY7XG5cblx0ZnVuY3Rpb24gZzBfMjU2KHgpIHtcblx0ICByZXR1cm4gcm90cjMyJDEoeCwgNykgXiByb3RyMzIkMSh4LCAxOCkgXiAoeCA+Pj4gMyk7XG5cdH1cblx0dmFyIGcwXzI1Nl8xID0gZzBfMjU2O1xuXG5cdGZ1bmN0aW9uIGcxXzI1Nih4KSB7XG5cdCAgcmV0dXJuIHJvdHIzMiQxKHgsIDE3KSBeIHJvdHIzMiQxKHgsIDE5KSBeICh4ID4+PiAxMCk7XG5cdH1cblx0dmFyIGcxXzI1Nl8xID0gZzFfMjU2O1xuXG5cdHZhciBjb21tb24kMSA9IHtcblx0XHRmdF8xOiBmdF8xXzEsXG5cdFx0Y2gzMjogY2gzMl8xLFxuXHRcdG1hajMyOiBtYWozMl8xLFxuXHRcdHAzMjogcDMyXzEsXG5cdFx0czBfMjU2OiBzMF8yNTZfMSxcblx0XHRzMV8yNTY6IHMxXzI1Nl8xLFxuXHRcdGcwXzI1NjogZzBfMjU2XzEsXG5cdFx0ZzFfMjU2OiBnMV8yNTZfMVxuXHR9O1xuXG5cdCd1c2Ugc3RyaWN0JztcblxuXG5cblxuXG5cdHZhciByb3RsMzIkMSA9IHV0aWxzLnJvdGwzMjtcblx0dmFyIHN1bTMyJDEgPSB1dGlscy5zdW0zMjtcblx0dmFyIHN1bTMyXzUkMSA9IHV0aWxzLnN1bTMyXzU7XG5cdHZhciBmdF8xJDEgPSBjb21tb24kMS5mdF8xO1xuXHR2YXIgQmxvY2tIYXNoJDEgPSBjb21tb24uQmxvY2tIYXNoO1xuXG5cdHZhciBzaGExX0sgPSBbXG5cdCAgMHg1QTgyNzk5OSwgMHg2RUQ5RUJBMSxcblx0ICAweDhGMUJCQ0RDLCAweENBNjJDMUQ2XG5cdF07XG5cblx0ZnVuY3Rpb24gU0hBMSgpIHtcblx0ICBpZiAoISh0aGlzIGluc3RhbmNlb2YgU0hBMSkpXG5cdCAgICByZXR1cm4gbmV3IFNIQTEoKTtcblxuXHQgIEJsb2NrSGFzaCQxLmNhbGwodGhpcyk7XG5cdCAgdGhpcy5oID0gW1xuXHQgICAgMHg2NzQ1MjMwMSwgMHhlZmNkYWI4OSwgMHg5OGJhZGNmZSxcblx0ICAgIDB4MTAzMjU0NzYsIDB4YzNkMmUxZjAgXTtcblx0ICB0aGlzLlcgPSBuZXcgQXJyYXkoODApO1xuXHR9XG5cblx0dXRpbHMuaW5oZXJpdHMoU0hBMSwgQmxvY2tIYXNoJDEpO1xuXHR2YXIgXzEgPSBTSEExO1xuXG5cdFNIQTEuYmxvY2tTaXplID0gNTEyO1xuXHRTSEExLm91dFNpemUgPSAxNjA7XG5cdFNIQTEuaG1hY1N0cmVuZ3RoID0gODA7XG5cdFNIQTEucGFkTGVuZ3RoID0gNjQ7XG5cblx0U0hBMS5wcm90b3R5cGUuX3VwZGF0ZSA9IGZ1bmN0aW9uIF91cGRhdGUobXNnLCBzdGFydCkge1xuXHQgIHZhciBXID0gdGhpcy5XO1xuXG5cdCAgZm9yICh2YXIgaSA9IDA7IGkgPCAxNjsgaSsrKVxuXHQgICAgV1tpXSA9IG1zZ1tzdGFydCArIGldO1xuXG5cdCAgZm9yKDsgaSA8IFcubGVuZ3RoOyBpKyspXG5cdCAgICBXW2ldID0gcm90bDMyJDEoV1tpIC0gM10gXiBXW2kgLSA4XSBeIFdbaSAtIDE0XSBeIFdbaSAtIDE2XSwgMSk7XG5cblx0ICB2YXIgYSA9IHRoaXMuaFswXTtcblx0ICB2YXIgYiA9IHRoaXMuaFsxXTtcblx0ICB2YXIgYyA9IHRoaXMuaFsyXTtcblx0ICB2YXIgZCA9IHRoaXMuaFszXTtcblx0ICB2YXIgZSA9IHRoaXMuaFs0XTtcblxuXHQgIGZvciAoaSA9IDA7IGkgPCBXLmxlbmd0aDsgaSsrKSB7XG5cdCAgICB2YXIgcyA9IH5+KGkgLyAyMCk7XG5cdCAgICB2YXIgdCA9IHN1bTMyXzUkMShyb3RsMzIkMShhLCA1KSwgZnRfMSQxKHMsIGIsIGMsIGQpLCBlLCBXW2ldLCBzaGExX0tbc10pO1xuXHQgICAgZSA9IGQ7XG5cdCAgICBkID0gYztcblx0ICAgIGMgPSByb3RsMzIkMShiLCAzMCk7XG5cdCAgICBiID0gYTtcblx0ICAgIGEgPSB0O1xuXHQgIH1cblxuXHQgIHRoaXMuaFswXSA9IHN1bTMyJDEodGhpcy5oWzBdLCBhKTtcblx0ICB0aGlzLmhbMV0gPSBzdW0zMiQxKHRoaXMuaFsxXSwgYik7XG5cdCAgdGhpcy5oWzJdID0gc3VtMzIkMSh0aGlzLmhbMl0sIGMpO1xuXHQgIHRoaXMuaFszXSA9IHN1bTMyJDEodGhpcy5oWzNdLCBkKTtcblx0ICB0aGlzLmhbNF0gPSBzdW0zMiQxKHRoaXMuaFs0XSwgZSk7XG5cdH07XG5cblx0U0hBMS5wcm90b3R5cGUuX2RpZ2VzdCA9IGZ1bmN0aW9uIGRpZ2VzdChlbmMpIHtcblx0ICBpZiAoZW5jID09PSAnaGV4Jylcblx0ICAgIHJldHVybiB1dGlscy50b0hleDMyKHRoaXMuaCwgJ2JpZycpO1xuXHQgIGVsc2Vcblx0ICAgIHJldHVybiB1dGlscy5zcGxpdDMyKHRoaXMuaCwgJ2JpZycpO1xuXHR9O1xuXG5cdCd1c2Ugc3RyaWN0JztcblxuXG5cblxuXG5cblx0dmFyIHN1bTMyJDIgPSB1dGlscy5zdW0zMjtcblx0dmFyIHN1bTMyXzQkMSA9IHV0aWxzLnN1bTMyXzQ7XG5cdHZhciBzdW0zMl81JDIgPSB1dGlscy5zdW0zMl81O1xuXHR2YXIgY2gzMiQxID0gY29tbW9uJDEuY2gzMjtcblx0dmFyIG1hajMyJDEgPSBjb21tb24kMS5tYWozMjtcblx0dmFyIHMwXzI1NiQxID0gY29tbW9uJDEuczBfMjU2O1xuXHR2YXIgczFfMjU2JDEgPSBjb21tb24kMS5zMV8yNTY7XG5cdHZhciBnMF8yNTYkMSA9IGNvbW1vbiQxLmcwXzI1Njtcblx0dmFyIGcxXzI1NiQxID0gY29tbW9uJDEuZzFfMjU2O1xuXG5cdHZhciBCbG9ja0hhc2gkMiA9IGNvbW1vbi5CbG9ja0hhc2g7XG5cblx0dmFyIHNoYTI1Nl9LID0gW1xuXHQgIDB4NDI4YTJmOTgsIDB4NzEzNzQ0OTEsIDB4YjVjMGZiY2YsIDB4ZTliNWRiYTUsXG5cdCAgMHgzOTU2YzI1YiwgMHg1OWYxMTFmMSwgMHg5MjNmODJhNCwgMHhhYjFjNWVkNSxcblx0ICAweGQ4MDdhYTk4LCAweDEyODM1YjAxLCAweDI0MzE4NWJlLCAweDU1MGM3ZGMzLFxuXHQgIDB4NzJiZTVkNzQsIDB4ODBkZWIxZmUsIDB4OWJkYzA2YTcsIDB4YzE5YmYxNzQsXG5cdCAgMHhlNDliNjljMSwgMHhlZmJlNDc4NiwgMHgwZmMxOWRjNiwgMHgyNDBjYTFjYyxcblx0ICAweDJkZTkyYzZmLCAweDRhNzQ4NGFhLCAweDVjYjBhOWRjLCAweDc2Zjk4OGRhLFxuXHQgIDB4OTgzZTUxNTIsIDB4YTgzMWM2NmQsIDB4YjAwMzI3YzgsIDB4YmY1OTdmYzcsXG5cdCAgMHhjNmUwMGJmMywgMHhkNWE3OTE0NywgMHgwNmNhNjM1MSwgMHgxNDI5Mjk2Nyxcblx0ICAweDI3YjcwYTg1LCAweDJlMWIyMTM4LCAweDRkMmM2ZGZjLCAweDUzMzgwZDEzLFxuXHQgIDB4NjUwYTczNTQsIDB4NzY2YTBhYmIsIDB4ODFjMmM5MmUsIDB4OTI3MjJjODUsXG5cdCAgMHhhMmJmZThhMSwgMHhhODFhNjY0YiwgMHhjMjRiOGI3MCwgMHhjNzZjNTFhMyxcblx0ICAweGQxOTJlODE5LCAweGQ2OTkwNjI0LCAweGY0MGUzNTg1LCAweDEwNmFhMDcwLFxuXHQgIDB4MTlhNGMxMTYsIDB4MWUzNzZjMDgsIDB4Mjc0ODc3NGMsIDB4MzRiMGJjYjUsXG5cdCAgMHgzOTFjMGNiMywgMHg0ZWQ4YWE0YSwgMHg1YjljY2E0ZiwgMHg2ODJlNmZmMyxcblx0ICAweDc0OGY4MmVlLCAweDc4YTU2MzZmLCAweDg0Yzg3ODE0LCAweDhjYzcwMjA4LFxuXHQgIDB4OTBiZWZmZmEsIDB4YTQ1MDZjZWIsIDB4YmVmOWEzZjcsIDB4YzY3MTc4ZjJcblx0XTtcblxuXHRmdW5jdGlvbiBTSEEyNTYoKSB7XG5cdCAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIFNIQTI1NikpXG5cdCAgICByZXR1cm4gbmV3IFNIQTI1NigpO1xuXG5cdCAgQmxvY2tIYXNoJDIuY2FsbCh0aGlzKTtcblx0ICB0aGlzLmggPSBbXG5cdCAgICAweDZhMDllNjY3LCAweGJiNjdhZTg1LCAweDNjNmVmMzcyLCAweGE1NGZmNTNhLFxuXHQgICAgMHg1MTBlNTI3ZiwgMHg5YjA1Njg4YywgMHgxZjgzZDlhYiwgMHg1YmUwY2QxOVxuXHQgIF07XG5cdCAgdGhpcy5rID0gc2hhMjU2X0s7XG5cdCAgdGhpcy5XID0gbmV3IEFycmF5KDY0KTtcblx0fVxuXHR1dGlscy5pbmhlcml0cyhTSEEyNTYsIEJsb2NrSGFzaCQyKTtcblx0dmFyIF8yNTYgPSBTSEEyNTY7XG5cblx0U0hBMjU2LmJsb2NrU2l6ZSA9IDUxMjtcblx0U0hBMjU2Lm91dFNpemUgPSAyNTY7XG5cdFNIQTI1Ni5obWFjU3RyZW5ndGggPSAxOTI7XG5cdFNIQTI1Ni5wYWRMZW5ndGggPSA2NDtcblxuXHRTSEEyNTYucHJvdG90eXBlLl91cGRhdGUgPSBmdW5jdGlvbiBfdXBkYXRlKG1zZywgc3RhcnQpIHtcblx0ICB2YXIgVyA9IHRoaXMuVztcblxuXHQgIGZvciAodmFyIGkgPSAwOyBpIDwgMTY7IGkrKylcblx0ICAgIFdbaV0gPSBtc2dbc3RhcnQgKyBpXTtcblx0ICBmb3IgKDsgaSA8IFcubGVuZ3RoOyBpKyspXG5cdCAgICBXW2ldID0gc3VtMzJfNCQxKGcxXzI1NiQxKFdbaSAtIDJdKSwgV1tpIC0gN10sIGcwXzI1NiQxKFdbaSAtIDE1XSksIFdbaSAtIDE2XSk7XG5cblx0ICB2YXIgYSA9IHRoaXMuaFswXTtcblx0ICB2YXIgYiA9IHRoaXMuaFsxXTtcblx0ICB2YXIgYyA9IHRoaXMuaFsyXTtcblx0ICB2YXIgZCA9IHRoaXMuaFszXTtcblx0ICB2YXIgZSA9IHRoaXMuaFs0XTtcblx0ICB2YXIgZiA9IHRoaXMuaFs1XTtcblx0ICB2YXIgZyA9IHRoaXMuaFs2XTtcblx0ICB2YXIgaCA9IHRoaXMuaFs3XTtcblxuXHQgIG1pbmltYWxpc3RpY0Fzc2VydCh0aGlzLmsubGVuZ3RoID09PSBXLmxlbmd0aCk7XG5cdCAgZm9yIChpID0gMDsgaSA8IFcubGVuZ3RoOyBpKyspIHtcblx0ICAgIHZhciBUMSA9IHN1bTMyXzUkMihoLCBzMV8yNTYkMShlKSwgY2gzMiQxKGUsIGYsIGcpLCB0aGlzLmtbaV0sIFdbaV0pO1xuXHQgICAgdmFyIFQyID0gc3VtMzIkMihzMF8yNTYkMShhKSwgbWFqMzIkMShhLCBiLCBjKSk7XG5cdCAgICBoID0gZztcblx0ICAgIGcgPSBmO1xuXHQgICAgZiA9IGU7XG5cdCAgICBlID0gc3VtMzIkMihkLCBUMSk7XG5cdCAgICBkID0gYztcblx0ICAgIGMgPSBiO1xuXHQgICAgYiA9IGE7XG5cdCAgICBhID0gc3VtMzIkMihUMSwgVDIpO1xuXHQgIH1cblxuXHQgIHRoaXMuaFswXSA9IHN1bTMyJDIodGhpcy5oWzBdLCBhKTtcblx0ICB0aGlzLmhbMV0gPSBzdW0zMiQyKHRoaXMuaFsxXSwgYik7XG5cdCAgdGhpcy5oWzJdID0gc3VtMzIkMih0aGlzLmhbMl0sIGMpO1xuXHQgIHRoaXMuaFszXSA9IHN1bTMyJDIodGhpcy5oWzNdLCBkKTtcblx0ICB0aGlzLmhbNF0gPSBzdW0zMiQyKHRoaXMuaFs0XSwgZSk7XG5cdCAgdGhpcy5oWzVdID0gc3VtMzIkMih0aGlzLmhbNV0sIGYpO1xuXHQgIHRoaXMuaFs2XSA9IHN1bTMyJDIodGhpcy5oWzZdLCBnKTtcblx0ICB0aGlzLmhbN10gPSBzdW0zMiQyKHRoaXMuaFs3XSwgaCk7XG5cdH07XG5cblx0U0hBMjU2LnByb3RvdHlwZS5fZGlnZXN0ID0gZnVuY3Rpb24gZGlnZXN0KGVuYykge1xuXHQgIGlmIChlbmMgPT09ICdoZXgnKVxuXHQgICAgcmV0dXJuIHV0aWxzLnRvSGV4MzIodGhpcy5oLCAnYmlnJyk7XG5cdCAgZWxzZVxuXHQgICAgcmV0dXJuIHV0aWxzLnNwbGl0MzIodGhpcy5oLCAnYmlnJyk7XG5cdH07XG5cblx0J3VzZSBzdHJpY3QnO1xuXG5cblxuXG5cdGZ1bmN0aW9uIFNIQTIyNCgpIHtcblx0ICBpZiAoISh0aGlzIGluc3RhbmNlb2YgU0hBMjI0KSlcblx0ICAgIHJldHVybiBuZXcgU0hBMjI0KCk7XG5cblx0ICBfMjU2LmNhbGwodGhpcyk7XG5cdCAgdGhpcy5oID0gW1xuXHQgICAgMHhjMTA1OWVkOCwgMHgzNjdjZDUwNywgMHgzMDcwZGQxNywgMHhmNzBlNTkzOSxcblx0ICAgIDB4ZmZjMDBiMzEsIDB4Njg1ODE1MTEsIDB4NjRmOThmYTcsIDB4YmVmYTRmYTQgXTtcblx0fVxuXHR1dGlscy5pbmhlcml0cyhTSEEyMjQsIF8yNTYpO1xuXHR2YXIgXzIyNCA9IFNIQTIyNDtcblxuXHRTSEEyMjQuYmxvY2tTaXplID0gNTEyO1xuXHRTSEEyMjQub3V0U2l6ZSA9IDIyNDtcblx0U0hBMjI0LmhtYWNTdHJlbmd0aCA9IDE5Mjtcblx0U0hBMjI0LnBhZExlbmd0aCA9IDY0O1xuXG5cdFNIQTIyNC5wcm90b3R5cGUuX2RpZ2VzdCA9IGZ1bmN0aW9uIGRpZ2VzdChlbmMpIHtcblx0ICAvLyBKdXN0IHRydW5jYXRlIG91dHB1dFxuXHQgIGlmIChlbmMgPT09ICdoZXgnKVxuXHQgICAgcmV0dXJuIHV0aWxzLnRvSGV4MzIodGhpcy5oLnNsaWNlKDAsIDcpLCAnYmlnJyk7XG5cdCAgZWxzZVxuXHQgICAgcmV0dXJuIHV0aWxzLnNwbGl0MzIodGhpcy5oLnNsaWNlKDAsIDcpLCAnYmlnJyk7XG5cdH07XG5cblx0J3VzZSBzdHJpY3QnO1xuXG5cblxuXG5cblx0dmFyIHJvdHI2NF9oaSQxID0gdXRpbHMucm90cjY0X2hpO1xuXHR2YXIgcm90cjY0X2xvJDEgPSB1dGlscy5yb3RyNjRfbG87XG5cdHZhciBzaHI2NF9oaSQxID0gdXRpbHMuc2hyNjRfaGk7XG5cdHZhciBzaHI2NF9sbyQxID0gdXRpbHMuc2hyNjRfbG87XG5cdHZhciBzdW02NCQxID0gdXRpbHMuc3VtNjQ7XG5cdHZhciBzdW02NF9oaSQxID0gdXRpbHMuc3VtNjRfaGk7XG5cdHZhciBzdW02NF9sbyQxID0gdXRpbHMuc3VtNjRfbG87XG5cdHZhciBzdW02NF80X2hpJDEgPSB1dGlscy5zdW02NF80X2hpO1xuXHR2YXIgc3VtNjRfNF9sbyQxID0gdXRpbHMuc3VtNjRfNF9sbztcblx0dmFyIHN1bTY0XzVfaGkkMSA9IHV0aWxzLnN1bTY0XzVfaGk7XG5cdHZhciBzdW02NF81X2xvJDEgPSB1dGlscy5zdW02NF81X2xvO1xuXG5cdHZhciBCbG9ja0hhc2gkMyA9IGNvbW1vbi5CbG9ja0hhc2g7XG5cblx0dmFyIHNoYTUxMl9LID0gW1xuXHQgIDB4NDI4YTJmOTgsIDB4ZDcyOGFlMjIsIDB4NzEzNzQ0OTEsIDB4MjNlZjY1Y2QsXG5cdCAgMHhiNWMwZmJjZiwgMHhlYzRkM2IyZiwgMHhlOWI1ZGJhNSwgMHg4MTg5ZGJiYyxcblx0ICAweDM5NTZjMjViLCAweGYzNDhiNTM4LCAweDU5ZjExMWYxLCAweGI2MDVkMDE5LFxuXHQgIDB4OTIzZjgyYTQsIDB4YWYxOTRmOWIsIDB4YWIxYzVlZDUsIDB4ZGE2ZDgxMTgsXG5cdCAgMHhkODA3YWE5OCwgMHhhMzAzMDI0MiwgMHgxMjgzNWIwMSwgMHg0NTcwNmZiZSxcblx0ICAweDI0MzE4NWJlLCAweDRlZTRiMjhjLCAweDU1MGM3ZGMzLCAweGQ1ZmZiNGUyLFxuXHQgIDB4NzJiZTVkNzQsIDB4ZjI3Yjg5NmYsIDB4ODBkZWIxZmUsIDB4M2IxNjk2YjEsXG5cdCAgMHg5YmRjMDZhNywgMHgyNWM3MTIzNSwgMHhjMTliZjE3NCwgMHhjZjY5MjY5NCxcblx0ICAweGU0OWI2OWMxLCAweDllZjE0YWQyLCAweGVmYmU0Nzg2LCAweDM4NGYyNWUzLFxuXHQgIDB4MGZjMTlkYzYsIDB4OGI4Y2Q1YjUsIDB4MjQwY2ExY2MsIDB4NzdhYzljNjUsXG5cdCAgMHgyZGU5MmM2ZiwgMHg1OTJiMDI3NSwgMHg0YTc0ODRhYSwgMHg2ZWE2ZTQ4Myxcblx0ICAweDVjYjBhOWRjLCAweGJkNDFmYmQ0LCAweDc2Zjk4OGRhLCAweDgzMTE1M2I1LFxuXHQgIDB4OTgzZTUxNTIsIDB4ZWU2NmRmYWIsIDB4YTgzMWM2NmQsIDB4MmRiNDMyMTAsXG5cdCAgMHhiMDAzMjdjOCwgMHg5OGZiMjEzZiwgMHhiZjU5N2ZjNywgMHhiZWVmMGVlNCxcblx0ICAweGM2ZTAwYmYzLCAweDNkYTg4ZmMyLCAweGQ1YTc5MTQ3LCAweDkzMGFhNzI1LFxuXHQgIDB4MDZjYTYzNTEsIDB4ZTAwMzgyNmYsIDB4MTQyOTI5NjcsIDB4MGEwZTZlNzAsXG5cdCAgMHgyN2I3MGE4NSwgMHg0NmQyMmZmYywgMHgyZTFiMjEzOCwgMHg1YzI2YzkyNixcblx0ICAweDRkMmM2ZGZjLCAweDVhYzQyYWVkLCAweDUzMzgwZDEzLCAweDlkOTViM2RmLFxuXHQgIDB4NjUwYTczNTQsIDB4OGJhZjYzZGUsIDB4NzY2YTBhYmIsIDB4M2M3N2IyYTgsXG5cdCAgMHg4MWMyYzkyZSwgMHg0N2VkYWVlNiwgMHg5MjcyMmM4NSwgMHgxNDgyMzUzYixcblx0ICAweGEyYmZlOGExLCAweDRjZjEwMzY0LCAweGE4MWE2NjRiLCAweGJjNDIzMDAxLFxuXHQgIDB4YzI0YjhiNzAsIDB4ZDBmODk3OTEsIDB4Yzc2YzUxYTMsIDB4MDY1NGJlMzAsXG5cdCAgMHhkMTkyZTgxOSwgMHhkNmVmNTIxOCwgMHhkNjk5MDYyNCwgMHg1NTY1YTkxMCxcblx0ICAweGY0MGUzNTg1LCAweDU3NzEyMDJhLCAweDEwNmFhMDcwLCAweDMyYmJkMWI4LFxuXHQgIDB4MTlhNGMxMTYsIDB4YjhkMmQwYzgsIDB4MWUzNzZjMDgsIDB4NTE0MWFiNTMsXG5cdCAgMHgyNzQ4Nzc0YywgMHhkZjhlZWI5OSwgMHgzNGIwYmNiNSwgMHhlMTliNDhhOCxcblx0ICAweDM5MWMwY2IzLCAweGM1Yzk1YTYzLCAweDRlZDhhYTRhLCAweGUzNDE4YWNiLFxuXHQgIDB4NWI5Y2NhNGYsIDB4Nzc2M2UzNzMsIDB4NjgyZTZmZjMsIDB4ZDZiMmI4YTMsXG5cdCAgMHg3NDhmODJlZSwgMHg1ZGVmYjJmYywgMHg3OGE1NjM2ZiwgMHg0MzE3MmY2MCxcblx0ICAweDg0Yzg3ODE0LCAweGExZjBhYjcyLCAweDhjYzcwMjA4LCAweDFhNjQzOWVjLFxuXHQgIDB4OTBiZWZmZmEsIDB4MjM2MzFlMjgsIDB4YTQ1MDZjZWIsIDB4ZGU4MmJkZTksXG5cdCAgMHhiZWY5YTNmNywgMHhiMmM2NzkxNSwgMHhjNjcxNzhmMiwgMHhlMzcyNTMyYixcblx0ICAweGNhMjczZWNlLCAweGVhMjY2MTljLCAweGQxODZiOGM3LCAweDIxYzBjMjA3LFxuXHQgIDB4ZWFkYTdkZDYsIDB4Y2RlMGViMWUsIDB4ZjU3ZDRmN2YsIDB4ZWU2ZWQxNzgsXG5cdCAgMHgwNmYwNjdhYSwgMHg3MjE3NmZiYSwgMHgwYTYzN2RjNSwgMHhhMmM4OThhNixcblx0ICAweDExM2Y5ODA0LCAweGJlZjkwZGFlLCAweDFiNzEwYjM1LCAweDEzMWM0NzFiLFxuXHQgIDB4MjhkYjc3ZjUsIDB4MjMwNDdkODQsIDB4MzJjYWFiN2IsIDB4NDBjNzI0OTMsXG5cdCAgMHgzYzllYmUwYSwgMHgxNWM5YmViYywgMHg0MzFkNjdjNCwgMHg5YzEwMGQ0Yyxcblx0ICAweDRjYzVkNGJlLCAweGNiM2U0MmI2LCAweDU5N2YyOTljLCAweGZjNjU3ZTJhLFxuXHQgIDB4NWZjYjZmYWIsIDB4M2FkNmZhZWMsIDB4NmM0NDE5OGMsIDB4NGE0NzU4MTdcblx0XTtcblxuXHRmdW5jdGlvbiBTSEE1MTIoKSB7XG5cdCAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIFNIQTUxMikpXG5cdCAgICByZXR1cm4gbmV3IFNIQTUxMigpO1xuXG5cdCAgQmxvY2tIYXNoJDMuY2FsbCh0aGlzKTtcblx0ICB0aGlzLmggPSBbXG5cdCAgICAweDZhMDllNjY3LCAweGYzYmNjOTA4LFxuXHQgICAgMHhiYjY3YWU4NSwgMHg4NGNhYTczYixcblx0ICAgIDB4M2M2ZWYzNzIsIDB4ZmU5NGY4MmIsXG5cdCAgICAweGE1NGZmNTNhLCAweDVmMWQzNmYxLFxuXHQgICAgMHg1MTBlNTI3ZiwgMHhhZGU2ODJkMSxcblx0ICAgIDB4OWIwNTY4OGMsIDB4MmIzZTZjMWYsXG5cdCAgICAweDFmODNkOWFiLCAweGZiNDFiZDZiLFxuXHQgICAgMHg1YmUwY2QxOSwgMHgxMzdlMjE3OSBdO1xuXHQgIHRoaXMuayA9IHNoYTUxMl9LO1xuXHQgIHRoaXMuVyA9IG5ldyBBcnJheSgxNjApO1xuXHR9XG5cdHV0aWxzLmluaGVyaXRzKFNIQTUxMiwgQmxvY2tIYXNoJDMpO1xuXHR2YXIgXzUxMiA9IFNIQTUxMjtcblxuXHRTSEE1MTIuYmxvY2tTaXplID0gMTAyNDtcblx0U0hBNTEyLm91dFNpemUgPSA1MTI7XG5cdFNIQTUxMi5obWFjU3RyZW5ndGggPSAxOTI7XG5cdFNIQTUxMi5wYWRMZW5ndGggPSAxMjg7XG5cblx0U0hBNTEyLnByb3RvdHlwZS5fcHJlcGFyZUJsb2NrID0gZnVuY3Rpb24gX3ByZXBhcmVCbG9jayhtc2csIHN0YXJ0KSB7XG5cdCAgdmFyIFcgPSB0aGlzLlc7XG5cblx0ICAvLyAzMiB4IDMyYml0IHdvcmRzXG5cdCAgZm9yICh2YXIgaSA9IDA7IGkgPCAzMjsgaSsrKVxuXHQgICAgV1tpXSA9IG1zZ1tzdGFydCArIGldO1xuXHQgIGZvciAoOyBpIDwgVy5sZW5ndGg7IGkgKz0gMikge1xuXHQgICAgdmFyIGMwX2hpID0gZzFfNTEyX2hpKFdbaSAtIDRdLCBXW2kgLSAzXSk7ICAvLyBpIC0gMlxuXHQgICAgdmFyIGMwX2xvID0gZzFfNTEyX2xvKFdbaSAtIDRdLCBXW2kgLSAzXSk7XG5cdCAgICB2YXIgYzFfaGkgPSBXW2kgLSAxNF07ICAvLyBpIC0gN1xuXHQgICAgdmFyIGMxX2xvID0gV1tpIC0gMTNdO1xuXHQgICAgdmFyIGMyX2hpID0gZzBfNTEyX2hpKFdbaSAtIDMwXSwgV1tpIC0gMjldKTsgIC8vIGkgLSAxNVxuXHQgICAgdmFyIGMyX2xvID0gZzBfNTEyX2xvKFdbaSAtIDMwXSwgV1tpIC0gMjldKTtcblx0ICAgIHZhciBjM19oaSA9IFdbaSAtIDMyXTsgIC8vIGkgLSAxNlxuXHQgICAgdmFyIGMzX2xvID0gV1tpIC0gMzFdO1xuXG5cdCAgICBXW2ldID0gc3VtNjRfNF9oaSQxKFxuXHQgICAgICBjMF9oaSwgYzBfbG8sXG5cdCAgICAgIGMxX2hpLCBjMV9sbyxcblx0ICAgICAgYzJfaGksIGMyX2xvLFxuXHQgICAgICBjM19oaSwgYzNfbG8pO1xuXHQgICAgV1tpICsgMV0gPSBzdW02NF80X2xvJDEoXG5cdCAgICAgIGMwX2hpLCBjMF9sbyxcblx0ICAgICAgYzFfaGksIGMxX2xvLFxuXHQgICAgICBjMl9oaSwgYzJfbG8sXG5cdCAgICAgIGMzX2hpLCBjM19sbyk7XG5cdCAgfVxuXHR9O1xuXG5cdFNIQTUxMi5wcm90b3R5cGUuX3VwZGF0ZSA9IGZ1bmN0aW9uIF91cGRhdGUobXNnLCBzdGFydCkge1xuXHQgIHRoaXMuX3ByZXBhcmVCbG9jayhtc2csIHN0YXJ0KTtcblxuXHQgIHZhciBXID0gdGhpcy5XO1xuXG5cdCAgdmFyIGFoID0gdGhpcy5oWzBdO1xuXHQgIHZhciBhbCA9IHRoaXMuaFsxXTtcblx0ICB2YXIgYmggPSB0aGlzLmhbMl07XG5cdCAgdmFyIGJsID0gdGhpcy5oWzNdO1xuXHQgIHZhciBjaCA9IHRoaXMuaFs0XTtcblx0ICB2YXIgY2wgPSB0aGlzLmhbNV07XG5cdCAgdmFyIGRoID0gdGhpcy5oWzZdO1xuXHQgIHZhciBkbCA9IHRoaXMuaFs3XTtcblx0ICB2YXIgZWggPSB0aGlzLmhbOF07XG5cdCAgdmFyIGVsID0gdGhpcy5oWzldO1xuXHQgIHZhciBmaCA9IHRoaXMuaFsxMF07XG5cdCAgdmFyIGZsID0gdGhpcy5oWzExXTtcblx0ICB2YXIgZ2ggPSB0aGlzLmhbMTJdO1xuXHQgIHZhciBnbCA9IHRoaXMuaFsxM107XG5cdCAgdmFyIGhoID0gdGhpcy5oWzE0XTtcblx0ICB2YXIgaGwgPSB0aGlzLmhbMTVdO1xuXG5cdCAgbWluaW1hbGlzdGljQXNzZXJ0KHRoaXMuay5sZW5ndGggPT09IFcubGVuZ3RoKTtcblx0ICBmb3IgKHZhciBpID0gMDsgaSA8IFcubGVuZ3RoOyBpICs9IDIpIHtcblx0ICAgIHZhciBjMF9oaSA9IGhoO1xuXHQgICAgdmFyIGMwX2xvID0gaGw7XG5cdCAgICB2YXIgYzFfaGkgPSBzMV81MTJfaGkoZWgsIGVsKTtcblx0ICAgIHZhciBjMV9sbyA9IHMxXzUxMl9sbyhlaCwgZWwpO1xuXHQgICAgdmFyIGMyX2hpID0gY2g2NF9oaShlaCwgZWwsIGZoLCBmbCwgZ2gsIGdsKTtcblx0ICAgIHZhciBjMl9sbyA9IGNoNjRfbG8oZWgsIGVsLCBmaCwgZmwsIGdoLCBnbCk7XG5cdCAgICB2YXIgYzNfaGkgPSB0aGlzLmtbaV07XG5cdCAgICB2YXIgYzNfbG8gPSB0aGlzLmtbaSArIDFdO1xuXHQgICAgdmFyIGM0X2hpID0gV1tpXTtcblx0ICAgIHZhciBjNF9sbyA9IFdbaSArIDFdO1xuXG5cdCAgICB2YXIgVDFfaGkgPSBzdW02NF81X2hpJDEoXG5cdCAgICAgIGMwX2hpLCBjMF9sbyxcblx0ICAgICAgYzFfaGksIGMxX2xvLFxuXHQgICAgICBjMl9oaSwgYzJfbG8sXG5cdCAgICAgIGMzX2hpLCBjM19sbyxcblx0ICAgICAgYzRfaGksIGM0X2xvKTtcblx0ICAgIHZhciBUMV9sbyA9IHN1bTY0XzVfbG8kMShcblx0ICAgICAgYzBfaGksIGMwX2xvLFxuXHQgICAgICBjMV9oaSwgYzFfbG8sXG5cdCAgICAgIGMyX2hpLCBjMl9sbyxcblx0ICAgICAgYzNfaGksIGMzX2xvLFxuXHQgICAgICBjNF9oaSwgYzRfbG8pO1xuXG5cdCAgICBjMF9oaSA9IHMwXzUxMl9oaShhaCwgYWwpO1xuXHQgICAgYzBfbG8gPSBzMF81MTJfbG8oYWgsIGFsKTtcblx0ICAgIGMxX2hpID0gbWFqNjRfaGkoYWgsIGFsLCBiaCwgYmwsIGNoLCBjbCk7XG5cdCAgICBjMV9sbyA9IG1hajY0X2xvKGFoLCBhbCwgYmgsIGJsLCBjaCwgY2wpO1xuXG5cdCAgICB2YXIgVDJfaGkgPSBzdW02NF9oaSQxKGMwX2hpLCBjMF9sbywgYzFfaGksIGMxX2xvKTtcblx0ICAgIHZhciBUMl9sbyA9IHN1bTY0X2xvJDEoYzBfaGksIGMwX2xvLCBjMV9oaSwgYzFfbG8pO1xuXG5cdCAgICBoaCA9IGdoO1xuXHQgICAgaGwgPSBnbDtcblxuXHQgICAgZ2ggPSBmaDtcblx0ICAgIGdsID0gZmw7XG5cblx0ICAgIGZoID0gZWg7XG5cdCAgICBmbCA9IGVsO1xuXG5cdCAgICBlaCA9IHN1bTY0X2hpJDEoZGgsIGRsLCBUMV9oaSwgVDFfbG8pO1xuXHQgICAgZWwgPSBzdW02NF9sbyQxKGRsLCBkbCwgVDFfaGksIFQxX2xvKTtcblxuXHQgICAgZGggPSBjaDtcblx0ICAgIGRsID0gY2w7XG5cblx0ICAgIGNoID0gYmg7XG5cdCAgICBjbCA9IGJsO1xuXG5cdCAgICBiaCA9IGFoO1xuXHQgICAgYmwgPSBhbDtcblxuXHQgICAgYWggPSBzdW02NF9oaSQxKFQxX2hpLCBUMV9sbywgVDJfaGksIFQyX2xvKTtcblx0ICAgIGFsID0gc3VtNjRfbG8kMShUMV9oaSwgVDFfbG8sIFQyX2hpLCBUMl9sbyk7XG5cdCAgfVxuXG5cdCAgc3VtNjQkMSh0aGlzLmgsIDAsIGFoLCBhbCk7XG5cdCAgc3VtNjQkMSh0aGlzLmgsIDIsIGJoLCBibCk7XG5cdCAgc3VtNjQkMSh0aGlzLmgsIDQsIGNoLCBjbCk7XG5cdCAgc3VtNjQkMSh0aGlzLmgsIDYsIGRoLCBkbCk7XG5cdCAgc3VtNjQkMSh0aGlzLmgsIDgsIGVoLCBlbCk7XG5cdCAgc3VtNjQkMSh0aGlzLmgsIDEwLCBmaCwgZmwpO1xuXHQgIHN1bTY0JDEodGhpcy5oLCAxMiwgZ2gsIGdsKTtcblx0ICBzdW02NCQxKHRoaXMuaCwgMTQsIGhoLCBobCk7XG5cdH07XG5cblx0U0hBNTEyLnByb3RvdHlwZS5fZGlnZXN0ID0gZnVuY3Rpb24gZGlnZXN0KGVuYykge1xuXHQgIGlmIChlbmMgPT09ICdoZXgnKVxuXHQgICAgcmV0dXJuIHV0aWxzLnRvSGV4MzIodGhpcy5oLCAnYmlnJyk7XG5cdCAgZWxzZVxuXHQgICAgcmV0dXJuIHV0aWxzLnNwbGl0MzIodGhpcy5oLCAnYmlnJyk7XG5cdH07XG5cblx0ZnVuY3Rpb24gY2g2NF9oaSh4aCwgeGwsIHloLCB5bCwgemgpIHtcblx0ICB2YXIgciA9ICh4aCAmIHloKSBeICgofnhoKSAmIHpoKTtcblx0ICBpZiAociA8IDApXG5cdCAgICByICs9IDB4MTAwMDAwMDAwO1xuXHQgIHJldHVybiByO1xuXHR9XG5cblx0ZnVuY3Rpb24gY2g2NF9sbyh4aCwgeGwsIHloLCB5bCwgemgsIHpsKSB7XG5cdCAgdmFyIHIgPSAoeGwgJiB5bCkgXiAoKH54bCkgJiB6bCk7XG5cdCAgaWYgKHIgPCAwKVxuXHQgICAgciArPSAweDEwMDAwMDAwMDtcblx0ICByZXR1cm4gcjtcblx0fVxuXG5cdGZ1bmN0aW9uIG1hajY0X2hpKHhoLCB4bCwgeWgsIHlsLCB6aCkge1xuXHQgIHZhciByID0gKHhoICYgeWgpIF4gKHhoICYgemgpIF4gKHloICYgemgpO1xuXHQgIGlmIChyIDwgMClcblx0ICAgIHIgKz0gMHgxMDAwMDAwMDA7XG5cdCAgcmV0dXJuIHI7XG5cdH1cblxuXHRmdW5jdGlvbiBtYWo2NF9sbyh4aCwgeGwsIHloLCB5bCwgemgsIHpsKSB7XG5cdCAgdmFyIHIgPSAoeGwgJiB5bCkgXiAoeGwgJiB6bCkgXiAoeWwgJiB6bCk7XG5cdCAgaWYgKHIgPCAwKVxuXHQgICAgciArPSAweDEwMDAwMDAwMDtcblx0ICByZXR1cm4gcjtcblx0fVxuXG5cdGZ1bmN0aW9uIHMwXzUxMl9oaSh4aCwgeGwpIHtcblx0ICB2YXIgYzBfaGkgPSByb3RyNjRfaGkkMSh4aCwgeGwsIDI4KTtcblx0ICB2YXIgYzFfaGkgPSByb3RyNjRfaGkkMSh4bCwgeGgsIDIpOyAgLy8gMzRcblx0ICB2YXIgYzJfaGkgPSByb3RyNjRfaGkkMSh4bCwgeGgsIDcpOyAgLy8gMzlcblxuXHQgIHZhciByID0gYzBfaGkgXiBjMV9oaSBeIGMyX2hpO1xuXHQgIGlmIChyIDwgMClcblx0ICAgIHIgKz0gMHgxMDAwMDAwMDA7XG5cdCAgcmV0dXJuIHI7XG5cdH1cblxuXHRmdW5jdGlvbiBzMF81MTJfbG8oeGgsIHhsKSB7XG5cdCAgdmFyIGMwX2xvID0gcm90cjY0X2xvJDEoeGgsIHhsLCAyOCk7XG5cdCAgdmFyIGMxX2xvID0gcm90cjY0X2xvJDEoeGwsIHhoLCAyKTsgIC8vIDM0XG5cdCAgdmFyIGMyX2xvID0gcm90cjY0X2xvJDEoeGwsIHhoLCA3KTsgIC8vIDM5XG5cblx0ICB2YXIgciA9IGMwX2xvIF4gYzFfbG8gXiBjMl9sbztcblx0ICBpZiAociA8IDApXG5cdCAgICByICs9IDB4MTAwMDAwMDAwO1xuXHQgIHJldHVybiByO1xuXHR9XG5cblx0ZnVuY3Rpb24gczFfNTEyX2hpKHhoLCB4bCkge1xuXHQgIHZhciBjMF9oaSA9IHJvdHI2NF9oaSQxKHhoLCB4bCwgMTQpO1xuXHQgIHZhciBjMV9oaSA9IHJvdHI2NF9oaSQxKHhoLCB4bCwgMTgpO1xuXHQgIHZhciBjMl9oaSA9IHJvdHI2NF9oaSQxKHhsLCB4aCwgOSk7ICAvLyA0MVxuXG5cdCAgdmFyIHIgPSBjMF9oaSBeIGMxX2hpIF4gYzJfaGk7XG5cdCAgaWYgKHIgPCAwKVxuXHQgICAgciArPSAweDEwMDAwMDAwMDtcblx0ICByZXR1cm4gcjtcblx0fVxuXG5cdGZ1bmN0aW9uIHMxXzUxMl9sbyh4aCwgeGwpIHtcblx0ICB2YXIgYzBfbG8gPSByb3RyNjRfbG8kMSh4aCwgeGwsIDE0KTtcblx0ICB2YXIgYzFfbG8gPSByb3RyNjRfbG8kMSh4aCwgeGwsIDE4KTtcblx0ICB2YXIgYzJfbG8gPSByb3RyNjRfbG8kMSh4bCwgeGgsIDkpOyAgLy8gNDFcblxuXHQgIHZhciByID0gYzBfbG8gXiBjMV9sbyBeIGMyX2xvO1xuXHQgIGlmIChyIDwgMClcblx0ICAgIHIgKz0gMHgxMDAwMDAwMDA7XG5cdCAgcmV0dXJuIHI7XG5cdH1cblxuXHRmdW5jdGlvbiBnMF81MTJfaGkoeGgsIHhsKSB7XG5cdCAgdmFyIGMwX2hpID0gcm90cjY0X2hpJDEoeGgsIHhsLCAxKTtcblx0ICB2YXIgYzFfaGkgPSByb3RyNjRfaGkkMSh4aCwgeGwsIDgpO1xuXHQgIHZhciBjMl9oaSA9IHNocjY0X2hpJDEoeGgsIHhsLCA3KTtcblxuXHQgIHZhciByID0gYzBfaGkgXiBjMV9oaSBeIGMyX2hpO1xuXHQgIGlmIChyIDwgMClcblx0ICAgIHIgKz0gMHgxMDAwMDAwMDA7XG5cdCAgcmV0dXJuIHI7XG5cdH1cblxuXHRmdW5jdGlvbiBnMF81MTJfbG8oeGgsIHhsKSB7XG5cdCAgdmFyIGMwX2xvID0gcm90cjY0X2xvJDEoeGgsIHhsLCAxKTtcblx0ICB2YXIgYzFfbG8gPSByb3RyNjRfbG8kMSh4aCwgeGwsIDgpO1xuXHQgIHZhciBjMl9sbyA9IHNocjY0X2xvJDEoeGgsIHhsLCA3KTtcblxuXHQgIHZhciByID0gYzBfbG8gXiBjMV9sbyBeIGMyX2xvO1xuXHQgIGlmIChyIDwgMClcblx0ICAgIHIgKz0gMHgxMDAwMDAwMDA7XG5cdCAgcmV0dXJuIHI7XG5cdH1cblxuXHRmdW5jdGlvbiBnMV81MTJfaGkoeGgsIHhsKSB7XG5cdCAgdmFyIGMwX2hpID0gcm90cjY0X2hpJDEoeGgsIHhsLCAxOSk7XG5cdCAgdmFyIGMxX2hpID0gcm90cjY0X2hpJDEoeGwsIHhoLCAyOSk7ICAvLyA2MVxuXHQgIHZhciBjMl9oaSA9IHNocjY0X2hpJDEoeGgsIHhsLCA2KTtcblxuXHQgIHZhciByID0gYzBfaGkgXiBjMV9oaSBeIGMyX2hpO1xuXHQgIGlmIChyIDwgMClcblx0ICAgIHIgKz0gMHgxMDAwMDAwMDA7XG5cdCAgcmV0dXJuIHI7XG5cdH1cblxuXHRmdW5jdGlvbiBnMV81MTJfbG8oeGgsIHhsKSB7XG5cdCAgdmFyIGMwX2xvID0gcm90cjY0X2xvJDEoeGgsIHhsLCAxOSk7XG5cdCAgdmFyIGMxX2xvID0gcm90cjY0X2xvJDEoeGwsIHhoLCAyOSk7ICAvLyA2MVxuXHQgIHZhciBjMl9sbyA9IHNocjY0X2xvJDEoeGgsIHhsLCA2KTtcblxuXHQgIHZhciByID0gYzBfbG8gXiBjMV9sbyBeIGMyX2xvO1xuXHQgIGlmIChyIDwgMClcblx0ICAgIHIgKz0gMHgxMDAwMDAwMDA7XG5cdCAgcmV0dXJuIHI7XG5cdH1cblxuXHQndXNlIHN0cmljdCc7XG5cblxuXG5cblxuXHRmdW5jdGlvbiBTSEEzODQoKSB7XG5cdCAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIFNIQTM4NCkpXG5cdCAgICByZXR1cm4gbmV3IFNIQTM4NCgpO1xuXG5cdCAgXzUxMi5jYWxsKHRoaXMpO1xuXHQgIHRoaXMuaCA9IFtcblx0ICAgIDB4Y2JiYjlkNWQsIDB4YzEwNTllZDgsXG5cdCAgICAweDYyOWEyOTJhLCAweDM2N2NkNTA3LFxuXHQgICAgMHg5MTU5MDE1YSwgMHgzMDcwZGQxNyxcblx0ICAgIDB4MTUyZmVjZDgsIDB4ZjcwZTU5MzksXG5cdCAgICAweDY3MzMyNjY3LCAweGZmYzAwYjMxLFxuXHQgICAgMHg4ZWI0NGE4NywgMHg2ODU4MTUxMSxcblx0ICAgIDB4ZGIwYzJlMGQsIDB4NjRmOThmYTcsXG5cdCAgICAweDQ3YjU0ODFkLCAweGJlZmE0ZmE0IF07XG5cdH1cblx0dXRpbHMuaW5oZXJpdHMoU0hBMzg0LCBfNTEyKTtcblx0dmFyIF8zODQgPSBTSEEzODQ7XG5cblx0U0hBMzg0LmJsb2NrU2l6ZSA9IDEwMjQ7XG5cdFNIQTM4NC5vdXRTaXplID0gMzg0O1xuXHRTSEEzODQuaG1hY1N0cmVuZ3RoID0gMTkyO1xuXHRTSEEzODQucGFkTGVuZ3RoID0gMTI4O1xuXG5cdFNIQTM4NC5wcm90b3R5cGUuX2RpZ2VzdCA9IGZ1bmN0aW9uIGRpZ2VzdChlbmMpIHtcblx0ICBpZiAoZW5jID09PSAnaGV4Jylcblx0ICAgIHJldHVybiB1dGlscy50b0hleDMyKHRoaXMuaC5zbGljZSgwLCAxMiksICdiaWcnKTtcblx0ICBlbHNlXG5cdCAgICByZXR1cm4gdXRpbHMuc3BsaXQzMih0aGlzLmguc2xpY2UoMCwgMTIpLCAnYmlnJyk7XG5cdH07XG5cblx0J3VzZSBzdHJpY3QnO1xuXG5cdHZhciBzaGExID0gXzE7XG5cdHZhciBzaGEyMjQgPSBfMjI0O1xuXHR2YXIgc2hhMjU2ID0gXzI1Njtcblx0dmFyIHNoYTM4NCA9IF8zODQ7XG5cdHZhciBzaGE1MTIgPSBfNTEyO1xuXG5cdHZhciBzaGEgPSB7XG5cdFx0c2hhMTogc2hhMSxcblx0XHRzaGEyMjQ6IHNoYTIyNCxcblx0XHRzaGEyNTY6IHNoYTI1Nixcblx0XHRzaGEzODQ6IHNoYTM4NCxcblx0XHRzaGE1MTI6IHNoYTUxMlxuXHR9O1xuXG5cdCd1c2Ugc3RyaWN0JztcblxuXG5cblxuXHR2YXIgcm90bDMyJDIgPSB1dGlscy5yb3RsMzI7XG5cdHZhciBzdW0zMiQzID0gdXRpbHMuc3VtMzI7XG5cdHZhciBzdW0zMl8zJDEgPSB1dGlscy5zdW0zMl8zO1xuXHR2YXIgc3VtMzJfNCQyID0gdXRpbHMuc3VtMzJfNDtcblx0dmFyIEJsb2NrSGFzaCQ0ID0gY29tbW9uLkJsb2NrSGFzaDtcblxuXHRmdW5jdGlvbiBSSVBFTUQxNjAoKSB7XG5cdCAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIFJJUEVNRDE2MCkpXG5cdCAgICByZXR1cm4gbmV3IFJJUEVNRDE2MCgpO1xuXG5cdCAgQmxvY2tIYXNoJDQuY2FsbCh0aGlzKTtcblxuXHQgIHRoaXMuaCA9IFsgMHg2NzQ1MjMwMSwgMHhlZmNkYWI4OSwgMHg5OGJhZGNmZSwgMHgxMDMyNTQ3NiwgMHhjM2QyZTFmMCBdO1xuXHQgIHRoaXMuZW5kaWFuID0gJ2xpdHRsZSc7XG5cdH1cblx0dXRpbHMuaW5oZXJpdHMoUklQRU1EMTYwLCBCbG9ja0hhc2gkNCk7XG5cdHZhciByaXBlbWQxNjAgPSBSSVBFTUQxNjA7XG5cblx0UklQRU1EMTYwLmJsb2NrU2l6ZSA9IDUxMjtcblx0UklQRU1EMTYwLm91dFNpemUgPSAxNjA7XG5cdFJJUEVNRDE2MC5obWFjU3RyZW5ndGggPSAxOTI7XG5cdFJJUEVNRDE2MC5wYWRMZW5ndGggPSA2NDtcblxuXHRSSVBFTUQxNjAucHJvdG90eXBlLl91cGRhdGUgPSBmdW5jdGlvbiB1cGRhdGUobXNnLCBzdGFydCkge1xuXHQgIHZhciBBID0gdGhpcy5oWzBdO1xuXHQgIHZhciBCID0gdGhpcy5oWzFdO1xuXHQgIHZhciBDID0gdGhpcy5oWzJdO1xuXHQgIHZhciBEID0gdGhpcy5oWzNdO1xuXHQgIHZhciBFID0gdGhpcy5oWzRdO1xuXHQgIHZhciBBaCA9IEE7XG5cdCAgdmFyIEJoID0gQjtcblx0ICB2YXIgQ2ggPSBDO1xuXHQgIHZhciBEaCA9IEQ7XG5cdCAgdmFyIEVoID0gRTtcblx0ICBmb3IgKHZhciBqID0gMDsgaiA8IDgwOyBqKyspIHtcblx0ICAgIHZhciBUID0gc3VtMzIkMyhcblx0ICAgICAgcm90bDMyJDIoXG5cdCAgICAgICAgc3VtMzJfNCQyKEEsIGYoaiwgQiwgQywgRCksIG1zZ1tyW2pdICsgc3RhcnRdLCBLKGopKSxcblx0ICAgICAgICBzW2pdKSxcblx0ICAgICAgRSk7XG5cdCAgICBBID0gRTtcblx0ICAgIEUgPSBEO1xuXHQgICAgRCA9IHJvdGwzMiQyKEMsIDEwKTtcblx0ICAgIEMgPSBCO1xuXHQgICAgQiA9IFQ7XG5cdCAgICBUID0gc3VtMzIkMyhcblx0ICAgICAgcm90bDMyJDIoXG5cdCAgICAgICAgc3VtMzJfNCQyKEFoLCBmKDc5IC0gaiwgQmgsIENoLCBEaCksIG1zZ1tyaFtqXSArIHN0YXJ0XSwgS2goaikpLFxuXHQgICAgICAgIHNoW2pdKSxcblx0ICAgICAgRWgpO1xuXHQgICAgQWggPSBFaDtcblx0ICAgIEVoID0gRGg7XG5cdCAgICBEaCA9IHJvdGwzMiQyKENoLCAxMCk7XG5cdCAgICBDaCA9IEJoO1xuXHQgICAgQmggPSBUO1xuXHQgIH1cblx0ICBUID0gc3VtMzJfMyQxKHRoaXMuaFsxXSwgQywgRGgpO1xuXHQgIHRoaXMuaFsxXSA9IHN1bTMyXzMkMSh0aGlzLmhbMl0sIEQsIEVoKTtcblx0ICB0aGlzLmhbMl0gPSBzdW0zMl8zJDEodGhpcy5oWzNdLCBFLCBBaCk7XG5cdCAgdGhpcy5oWzNdID0gc3VtMzJfMyQxKHRoaXMuaFs0XSwgQSwgQmgpO1xuXHQgIHRoaXMuaFs0XSA9IHN1bTMyXzMkMSh0aGlzLmhbMF0sIEIsIENoKTtcblx0ICB0aGlzLmhbMF0gPSBUO1xuXHR9O1xuXG5cdFJJUEVNRDE2MC5wcm90b3R5cGUuX2RpZ2VzdCA9IGZ1bmN0aW9uIGRpZ2VzdChlbmMpIHtcblx0ICBpZiAoZW5jID09PSAnaGV4Jylcblx0ICAgIHJldHVybiB1dGlscy50b0hleDMyKHRoaXMuaCwgJ2xpdHRsZScpO1xuXHQgIGVsc2Vcblx0ICAgIHJldHVybiB1dGlscy5zcGxpdDMyKHRoaXMuaCwgJ2xpdHRsZScpO1xuXHR9O1xuXG5cdGZ1bmN0aW9uIGYoaiwgeCwgeSwgeikge1xuXHQgIGlmIChqIDw9IDE1KVxuXHQgICAgcmV0dXJuIHggXiB5IF4gejtcblx0ICBlbHNlIGlmIChqIDw9IDMxKVxuXHQgICAgcmV0dXJuICh4ICYgeSkgfCAoKH54KSAmIHopO1xuXHQgIGVsc2UgaWYgKGogPD0gNDcpXG5cdCAgICByZXR1cm4gKHggfCAofnkpKSBeIHo7XG5cdCAgZWxzZSBpZiAoaiA8PSA2Mylcblx0ICAgIHJldHVybiAoeCAmIHopIHwgKHkgJiAofnopKTtcblx0ICBlbHNlXG5cdCAgICByZXR1cm4geCBeICh5IHwgKH56KSk7XG5cdH1cblxuXHRmdW5jdGlvbiBLKGopIHtcblx0ICBpZiAoaiA8PSAxNSlcblx0ICAgIHJldHVybiAweDAwMDAwMDAwO1xuXHQgIGVsc2UgaWYgKGogPD0gMzEpXG5cdCAgICByZXR1cm4gMHg1YTgyNzk5OTtcblx0ICBlbHNlIGlmIChqIDw9IDQ3KVxuXHQgICAgcmV0dXJuIDB4NmVkOWViYTE7XG5cdCAgZWxzZSBpZiAoaiA8PSA2Mylcblx0ICAgIHJldHVybiAweDhmMWJiY2RjO1xuXHQgIGVsc2Vcblx0ICAgIHJldHVybiAweGE5NTNmZDRlO1xuXHR9XG5cblx0ZnVuY3Rpb24gS2goaikge1xuXHQgIGlmIChqIDw9IDE1KVxuXHQgICAgcmV0dXJuIDB4NTBhMjhiZTY7XG5cdCAgZWxzZSBpZiAoaiA8PSAzMSlcblx0ICAgIHJldHVybiAweDVjNGRkMTI0O1xuXHQgIGVsc2UgaWYgKGogPD0gNDcpXG5cdCAgICByZXR1cm4gMHg2ZDcwM2VmMztcblx0ICBlbHNlIGlmIChqIDw9IDYzKVxuXHQgICAgcmV0dXJuIDB4N2E2ZDc2ZTk7XG5cdCAgZWxzZVxuXHQgICAgcmV0dXJuIDB4MDAwMDAwMDA7XG5cdH1cblxuXHR2YXIgciA9IFtcblx0ICAwLCAxLCAyLCAzLCA0LCA1LCA2LCA3LCA4LCA5LCAxMCwgMTEsIDEyLCAxMywgMTQsIDE1LFxuXHQgIDcsIDQsIDEzLCAxLCAxMCwgNiwgMTUsIDMsIDEyLCAwLCA5LCA1LCAyLCAxNCwgMTEsIDgsXG5cdCAgMywgMTAsIDE0LCA0LCA5LCAxNSwgOCwgMSwgMiwgNywgMCwgNiwgMTMsIDExLCA1LCAxMixcblx0ICAxLCA5LCAxMSwgMTAsIDAsIDgsIDEyLCA0LCAxMywgMywgNywgMTUsIDE0LCA1LCA2LCAyLFxuXHQgIDQsIDAsIDUsIDksIDcsIDEyLCAyLCAxMCwgMTQsIDEsIDMsIDgsIDExLCA2LCAxNSwgMTNcblx0XTtcblxuXHR2YXIgcmggPSBbXG5cdCAgNSwgMTQsIDcsIDAsIDksIDIsIDExLCA0LCAxMywgNiwgMTUsIDgsIDEsIDEwLCAzLCAxMixcblx0ICA2LCAxMSwgMywgNywgMCwgMTMsIDUsIDEwLCAxNCwgMTUsIDgsIDEyLCA0LCA5LCAxLCAyLFxuXHQgIDE1LCA1LCAxLCAzLCA3LCAxNCwgNiwgOSwgMTEsIDgsIDEyLCAyLCAxMCwgMCwgNCwgMTMsXG5cdCAgOCwgNiwgNCwgMSwgMywgMTEsIDE1LCAwLCA1LCAxMiwgMiwgMTMsIDksIDcsIDEwLCAxNCxcblx0ICAxMiwgMTUsIDEwLCA0LCAxLCA1LCA4LCA3LCA2LCAyLCAxMywgMTQsIDAsIDMsIDksIDExXG5cdF07XG5cblx0dmFyIHMgPSBbXG5cdCAgMTEsIDE0LCAxNSwgMTIsIDUsIDgsIDcsIDksIDExLCAxMywgMTQsIDE1LCA2LCA3LCA5LCA4LFxuXHQgIDcsIDYsIDgsIDEzLCAxMSwgOSwgNywgMTUsIDcsIDEyLCAxNSwgOSwgMTEsIDcsIDEzLCAxMixcblx0ICAxMSwgMTMsIDYsIDcsIDE0LCA5LCAxMywgMTUsIDE0LCA4LCAxMywgNiwgNSwgMTIsIDcsIDUsXG5cdCAgMTEsIDEyLCAxNCwgMTUsIDE0LCAxNSwgOSwgOCwgOSwgMTQsIDUsIDYsIDgsIDYsIDUsIDEyLFxuXHQgIDksIDE1LCA1LCAxMSwgNiwgOCwgMTMsIDEyLCA1LCAxMiwgMTMsIDE0LCAxMSwgOCwgNSwgNlxuXHRdO1xuXG5cdHZhciBzaCA9IFtcblx0ICA4LCA5LCA5LCAxMSwgMTMsIDE1LCAxNSwgNSwgNywgNywgOCwgMTEsIDE0LCAxNCwgMTIsIDYsXG5cdCAgOSwgMTMsIDE1LCA3LCAxMiwgOCwgOSwgMTEsIDcsIDcsIDEyLCA3LCA2LCAxNSwgMTMsIDExLFxuXHQgIDksIDcsIDE1LCAxMSwgOCwgNiwgNiwgMTQsIDEyLCAxMywgNSwgMTQsIDEzLCAxMywgNywgNSxcblx0ICAxNSwgNSwgOCwgMTEsIDE0LCAxNCwgNiwgMTQsIDYsIDksIDEyLCA5LCAxMiwgNSwgMTUsIDgsXG5cdCAgOCwgNSwgMTIsIDksIDEyLCA1LCAxNCwgNiwgOCwgMTMsIDYsIDUsIDE1LCAxMywgMTEsIDExXG5cdF07XG5cblx0dmFyIHJpcGVtZCA9IHtcblx0XHRyaXBlbWQxNjA6IHJpcGVtZDE2MFxuXHR9O1xuXG5cdCd1c2Ugc3RyaWN0JztcblxuXG5cblxuXHRmdW5jdGlvbiBIbWFjKGhhc2gsIGtleSwgZW5jKSB7XG5cdCAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIEhtYWMpKVxuXHQgICAgcmV0dXJuIG5ldyBIbWFjKGhhc2gsIGtleSwgZW5jKTtcblx0ICB0aGlzLkhhc2ggPSBoYXNoO1xuXHQgIHRoaXMuYmxvY2tTaXplID0gaGFzaC5ibG9ja1NpemUgLyA4O1xuXHQgIHRoaXMub3V0U2l6ZSA9IGhhc2gub3V0U2l6ZSAvIDg7XG5cdCAgdGhpcy5pbm5lciA9IG51bGw7XG5cdCAgdGhpcy5vdXRlciA9IG51bGw7XG5cblx0ICB0aGlzLl9pbml0KHV0aWxzLnRvQXJyYXkoa2V5LCBlbmMpKTtcblx0fVxuXHR2YXIgaG1hYyA9IEhtYWM7XG5cblx0SG1hYy5wcm90b3R5cGUuX2luaXQgPSBmdW5jdGlvbiBpbml0KGtleSkge1xuXHQgIC8vIFNob3J0ZW4ga2V5LCBpZiBuZWVkZWRcblx0ICBpZiAoa2V5Lmxlbmd0aCA+IHRoaXMuYmxvY2tTaXplKVxuXHQgICAga2V5ID0gbmV3IHRoaXMuSGFzaCgpLnVwZGF0ZShrZXkpLmRpZ2VzdCgpO1xuXHQgIG1pbmltYWxpc3RpY0Fzc2VydChrZXkubGVuZ3RoIDw9IHRoaXMuYmxvY2tTaXplKTtcblxuXHQgIC8vIEFkZCBwYWRkaW5nIHRvIGtleVxuXHQgIGZvciAodmFyIGkgPSBrZXkubGVuZ3RoOyBpIDwgdGhpcy5ibG9ja1NpemU7IGkrKylcblx0ICAgIGtleS5wdXNoKDApO1xuXG5cdCAgZm9yIChpID0gMDsgaSA8IGtleS5sZW5ndGg7IGkrKylcblx0ICAgIGtleVtpXSBePSAweDM2O1xuXHQgIHRoaXMuaW5uZXIgPSBuZXcgdGhpcy5IYXNoKCkudXBkYXRlKGtleSk7XG5cblx0ICAvLyAweDM2IF4gMHg1YyA9IDB4NmFcblx0ICBmb3IgKGkgPSAwOyBpIDwga2V5Lmxlbmd0aDsgaSsrKVxuXHQgICAga2V5W2ldIF49IDB4NmE7XG5cdCAgdGhpcy5vdXRlciA9IG5ldyB0aGlzLkhhc2goKS51cGRhdGUoa2V5KTtcblx0fTtcblxuXHRIbWFjLnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiB1cGRhdGUobXNnLCBlbmMpIHtcblx0ICB0aGlzLmlubmVyLnVwZGF0ZShtc2csIGVuYyk7XG5cdCAgcmV0dXJuIHRoaXM7XG5cdH07XG5cblx0SG1hYy5wcm90b3R5cGUuZGlnZXN0ID0gZnVuY3Rpb24gZGlnZXN0KGVuYykge1xuXHQgIHRoaXMub3V0ZXIudXBkYXRlKHRoaXMuaW5uZXIuZGlnZXN0KCkpO1xuXHQgIHJldHVybiB0aGlzLm91dGVyLmRpZ2VzdChlbmMpO1xuXHR9O1xuXG5cdHZhciBoYXNoXzEgPSBjcmVhdGVDb21tb25qc01vZHVsZShmdW5jdGlvbiAobW9kdWxlLCBleHBvcnRzKSB7XG5cdHZhciBoYXNoID0gZXhwb3J0cztcblxuXHRoYXNoLnV0aWxzID0gdXRpbHM7XG5cdGhhc2guY29tbW9uID0gY29tbW9uO1xuXHRoYXNoLnNoYSA9IHNoYTtcblx0aGFzaC5yaXBlbWQgPSByaXBlbWQ7XG5cdGhhc2guaG1hYyA9IGhtYWM7XG5cblx0Ly8gUHJveHkgaGFzaCBmdW5jdGlvbnMgdG8gdGhlIG1haW4gb2JqZWN0XG5cdGhhc2guc2hhMSA9IGhhc2guc2hhLnNoYTE7XG5cdGhhc2guc2hhMjU2ID0gaGFzaC5zaGEuc2hhMjU2O1xuXHRoYXNoLnNoYTIyNCA9IGhhc2guc2hhLnNoYTIyNDtcblx0aGFzaC5zaGEzODQgPSBoYXNoLnNoYS5zaGEzODQ7XG5cdGhhc2guc2hhNTEyID0gaGFzaC5zaGEuc2hhNTEyO1xuXHRoYXNoLnJpcGVtZDE2MCA9IGhhc2gucmlwZW1kLnJpcGVtZDE2MDtcblx0fSk7XG5cblx0dmFyIGN1cnZlc18xID0gY3JlYXRlQ29tbW9uanNNb2R1bGUoZnVuY3Rpb24gKG1vZHVsZSwgZXhwb3J0cykge1xuXHQndXNlIHN0cmljdCc7XG5cblx0dmFyIGN1cnZlcyA9IGV4cG9ydHM7XG5cblxuXG5cblxuXHR2YXIgYXNzZXJ0ID0gdXRpbHNfMSQxLmFzc2VydDtcblxuXHRmdW5jdGlvbiBQcmVzZXRDdXJ2ZShvcHRpb25zKSB7XG5cdCAgaWYgKG9wdGlvbnMudHlwZSA9PT0gJ3Nob3J0Jylcblx0ICAgIHRoaXMuY3VydmUgPSBuZXcgY3VydmVfMS5zaG9ydChvcHRpb25zKTtcblx0ICBlbHNlIGlmIChvcHRpb25zLnR5cGUgPT09ICdlZHdhcmRzJylcblx0ICAgIHRoaXMuY3VydmUgPSBuZXcgY3VydmVfMS5lZHdhcmRzKG9wdGlvbnMpO1xuXHQgIGVsc2Vcblx0ICAgIHRoaXMuY3VydmUgPSBuZXcgY3VydmVfMS5tb250KG9wdGlvbnMpO1xuXHQgIHRoaXMuZyA9IHRoaXMuY3VydmUuZztcblx0ICB0aGlzLm4gPSB0aGlzLmN1cnZlLm47XG5cdCAgdGhpcy5oYXNoID0gb3B0aW9ucy5oYXNoO1xuXG5cdCAgYXNzZXJ0KHRoaXMuZy52YWxpZGF0ZSgpLCAnSW52YWxpZCBjdXJ2ZScpO1xuXHQgIGFzc2VydCh0aGlzLmcubXVsKHRoaXMubikuaXNJbmZpbml0eSgpLCAnSW52YWxpZCBjdXJ2ZSwgRypOICE9IE8nKTtcblx0fVxuXHRjdXJ2ZXMuUHJlc2V0Q3VydmUgPSBQcmVzZXRDdXJ2ZTtcblxuXHRmdW5jdGlvbiBkZWZpbmVDdXJ2ZShuYW1lLCBvcHRpb25zKSB7XG5cdCAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGN1cnZlcywgbmFtZSwge1xuXHQgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuXHQgICAgZW51bWVyYWJsZTogdHJ1ZSxcblx0ICAgIGdldDogZnVuY3Rpb24oKSB7XG5cdCAgICAgIHZhciBjdXJ2ZSA9IG5ldyBQcmVzZXRDdXJ2ZShvcHRpb25zKTtcblx0ICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGN1cnZlcywgbmFtZSwge1xuXHQgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcblx0ICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuXHQgICAgICAgIHZhbHVlOiBjdXJ2ZSxcblx0ICAgICAgfSk7XG5cdCAgICAgIHJldHVybiBjdXJ2ZTtcblx0ICAgIH0sXG5cdCAgfSk7XG5cdH1cblxuXHRkZWZpbmVDdXJ2ZSgncDE5MicsIHtcblx0ICB0eXBlOiAnc2hvcnQnLFxuXHQgIHByaW1lOiAncDE5MicsXG5cdCAgcDogJ2ZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZlIGZmZmZmZmZmIGZmZmZmZmZmJyxcblx0ICBhOiAnZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmUgZmZmZmZmZmYgZmZmZmZmZmMnLFxuXHQgIGI6ICc2NDIxMDUxOSBlNTljODBlNyAwZmE3ZTlhYiA3MjI0MzA0OSBmZWI4ZGVlYyBjMTQ2YjliMScsXG5cdCAgbjogJ2ZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZmIDk5ZGVmODM2IDE0NmJjOWIxIGI0ZDIyODMxJyxcblx0ICBoYXNoOiBoYXNoXzEuc2hhMjU2LFxuXHQgIGdSZWQ6IGZhbHNlLFxuXHQgIGc6IFtcblx0ICAgICcxODhkYTgwZSBiMDMwOTBmNiA3Y2JmMjBlYiA0M2ExODgwMCBmNGZmMGFmZCA4MmZmMTAxMicsXG5cdCAgICAnMDcxOTJiOTUgZmZjOGRhNzggNjMxMDExZWQgNmIyNGNkZDUgNzNmOTc3YTEgMWU3OTQ4MTEnLFxuXHQgIF0sXG5cdH0pO1xuXG5cdGRlZmluZUN1cnZlKCdwMjI0Jywge1xuXHQgIHR5cGU6ICdzaG9ydCcsXG5cdCAgcHJpbWU6ICdwMjI0Jyxcblx0ICBwOiAnZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgMDAwMDAwMDAgMDAwMDAwMDAgMDAwMDAwMDEnLFxuXHQgIGE6ICdmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZSBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZScsXG5cdCAgYjogJ2I0MDUwYTg1IDBjMDRiM2FiIGY1NDEzMjU2IDUwNDRiMGI3IGQ3YmZkOGJhIDI3MGIzOTQzIDIzNTVmZmI0Jyxcblx0ICBuOiAnZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgZmZmZjE2YTIgZTBiOGYwM2UgMTNkZDI5NDUgNWM1YzJhM2QnLFxuXHQgIGhhc2g6IGhhc2hfMS5zaGEyNTYsXG5cdCAgZ1JlZDogZmFsc2UsXG5cdCAgZzogW1xuXHQgICAgJ2I3MGUwY2JkIDZiYjRiZjdmIDMyMTM5MGI5IDRhMDNjMWQzIDU2YzIxMTIyIDM0MzI4MGQ2IDExNWMxZDIxJyxcblx0ICAgICdiZDM3NjM4OCBiNWY3MjNmYiA0YzIyZGZlNiBjZDQzNzVhMCA1YTA3NDc2NCA0NGQ1ODE5OSA4NTAwN2UzNCcsXG5cdCAgXSxcblx0fSk7XG5cblx0ZGVmaW5lQ3VydmUoJ3AyNTYnLCB7XG5cdCAgdHlwZTogJ3Nob3J0Jyxcblx0ICBwcmltZTogbnVsbCxcblx0ICBwOiAnZmZmZmZmZmYgMDAwMDAwMDEgMDAwMDAwMDAgMDAwMDAwMDAgMDAwMDAwMDAgZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYnLFxuXHQgIGE6ICdmZmZmZmZmZiAwMDAwMDAwMSAwMDAwMDAwMCAwMDAwMDAwMCAwMDAwMDAwMCBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmYycsXG5cdCAgYjogJzVhYzYzNWQ4IGFhM2E5M2U3IGIzZWJiZDU1IDc2OTg4NmJjIDY1MWQwNmIwIGNjNTNiMGY2IDNiY2UzYzNlIDI3ZDI2MDRiJyxcblx0ICBuOiAnZmZmZmZmZmYgMDAwMDAwMDAgZmZmZmZmZmYgZmZmZmZmZmYgYmNlNmZhYWQgYTcxNzllODQgZjNiOWNhYzIgZmM2MzI1NTEnLFxuXHQgIGhhc2g6IGhhc2hfMS5zaGEyNTYsXG5cdCAgZ1JlZDogZmFsc2UsXG5cdCAgZzogW1xuXHQgICAgJzZiMTdkMWYyIGUxMmM0MjQ3IGY4YmNlNmU1IDYzYTQ0MGYyIDc3MDM3ZDgxIDJkZWIzM2EwIGY0YTEzOTQ1IGQ4OThjMjk2Jyxcblx0ICAgICc0ZmUzNDJlMiBmZTFhN2Y5YiA4ZWU3ZWI0YSA3YzBmOWUxNiAyYmNlMzM1NyA2YjMxNWVjZSBjYmI2NDA2OCAzN2JmNTFmNScsXG5cdCAgXSxcblx0fSk7XG5cblx0ZGVmaW5lQ3VydmUoJ3AzODQnLCB7XG5cdCAgdHlwZTogJ3Nob3J0Jyxcblx0ICBwcmltZTogbnVsbCxcblx0ICBwOiAnZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgJyArXG5cdCAgICAgJ2ZmZmZmZmZlIGZmZmZmZmZmIDAwMDAwMDAwIDAwMDAwMDAwIGZmZmZmZmZmJyxcblx0ICBhOiAnZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgJyArXG5cdCAgICAgJ2ZmZmZmZmZlIGZmZmZmZmZmIDAwMDAwMDAwIDAwMDAwMDAwIGZmZmZmZmZjJyxcblx0ICBiOiAnYjMzMTJmYTcgZTIzZWU3ZTQgOTg4ZTA1NmIgZTNmODJkMTkgMTgxZDljNmUgZmU4MTQxMTIgMDMxNDA4OGYgJyArXG5cdCAgICAgJzUwMTM4NzVhIGM2NTYzOThkIDhhMmVkMTlkIDJhODVjOGVkIGQzZWMyYWVmJyxcblx0ICBuOiAnZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgYzc2MzRkODEgJyArXG5cdCAgICAgJ2Y0MzcyZGRmIDU4MWEwZGIyIDQ4YjBhNzdhIGVjZWMxOTZhIGNjYzUyOTczJyxcblx0ICBoYXNoOiBoYXNoXzEuc2hhMzg0LFxuXHQgIGdSZWQ6IGZhbHNlLFxuXHQgIGc6IFtcblx0ICAgICdhYTg3Y2EyMiBiZThiMDUzNyA4ZWIxYzcxZSBmMzIwYWQ3NCA2ZTFkM2I2MiA4YmE3OWI5OCA1OWY3NDFlMCA4MjU0MmEzOCAnICtcblx0ICAgICc1NTAyZjI1ZCBiZjU1Mjk2YyAzYTU0NWUzOCA3Mjc2MGFiNycsXG5cdCAgICAnMzYxN2RlNGEgOTYyNjJjNmYgNWQ5ZTk4YmYgOTI5MmRjMjkgZjhmNDFkYmQgMjg5YTE0N2MgZTlkYTMxMTMgYjVmMGI4YzAgJyArXG5cdCAgICAnMGE2MGIxY2UgMWQ3ZTgxOWQgN2E0MzFkN2MgOTBlYTBlNWYnLFxuXHQgIF0sXG5cdH0pO1xuXG5cdGRlZmluZUN1cnZlKCdwNTIxJywge1xuXHQgIHR5cGU6ICdzaG9ydCcsXG5cdCAgcHJpbWU6IG51bGwsXG5cdCAgcDogJzAwMDAwMWZmIGZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZmICcgK1xuXHQgICAgICdmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiAnICtcblx0ICAgICAnZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYnLFxuXHQgIGE6ICcwMDAwMDFmZiBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiAnICtcblx0ICAgICAnZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgJyArXG5cdCAgICAgJ2ZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZjJyxcblx0ICBiOiAnMDAwMDAwNTEgOTUzZWI5NjEgOGUxYzlhMWYgOTI5YTIxYTAgYjY4NTQwZWUgYTJkYTcyNWIgJyArXG5cdCAgICAgJzk5YjMxNWYzIGI4YjQ4OTkxIDhlZjEwOWUxIDU2MTkzOTUxIGVjN2U5MzdiIDE2NTJjMGJkICcgK1xuXHQgICAgICczYmIxYmYwNyAzNTczZGY4OCAzZDJjMzRmMSBlZjQ1MWZkNCA2YjUwM2YwMCcsXG5cdCAgbjogJzAwMDAwMWZmIGZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZmICcgK1xuXHQgICAgICdmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmYSA1MTg2ODc4MyBiZjJmOTY2YiA3ZmNjMDE0OCAnICtcblx0ICAgICAnZjcwOWE1ZDAgM2JiNWM5YjggODk5YzQ3YWUgYmI2ZmI3MWUgOTEzODY0MDknLFxuXHQgIGhhc2g6IGhhc2hfMS5zaGE1MTIsXG5cdCAgZ1JlZDogZmFsc2UsXG5cdCAgZzogW1xuXHQgICAgJzAwMDAwMGM2IDg1OGUwNmI3IDA0MDRlOWNkIDllM2VjYjY2IDIzOTViNDQyIDljNjQ4MTM5ICcgK1xuXHQgICAgJzA1M2ZiNTIxIGY4MjhhZjYwIDZiNGQzZGJhIGExNGI1ZTc3IGVmZTc1OTI4IGZlMWRjMTI3ICcgK1xuXHQgICAgJ2EyZmZhOGRlIDMzNDhiM2MxIDg1NmE0MjliIGY5N2U3ZTMxIGMyZTViZDY2Jyxcblx0ICAgICcwMDAwMDExOCAzOTI5NmE3OCA5YTNiYzAwNCA1YzhhNWZiNCAyYzdkMWJkOSA5OGY1NDQ0OSAnICtcblx0ICAgICc1NzliNDQ2OCAxN2FmYmQxNyAyNzNlNjYyYyA5N2VlNzI5OSA1ZWY0MjY0MCBjNTUwYjkwMSAnICtcblx0ICAgICczZmFkMDc2MSAzNTNjNzA4NiBhMjcyYzI0MCA4OGJlOTQ3NiA5ZmQxNjY1MCcsXG5cdCAgXSxcblx0fSk7XG5cblx0ZGVmaW5lQ3VydmUoJ2N1cnZlMjU1MTknLCB7XG5cdCAgdHlwZTogJ21vbnQnLFxuXHQgIHByaW1lOiAncDI1NTE5Jyxcblx0ICBwOiAnN2ZmZmZmZmZmZmZmZmZmZiBmZmZmZmZmZmZmZmZmZmZmIGZmZmZmZmZmZmZmZmZmZmYgZmZmZmZmZmZmZmZmZmZlZCcsXG5cdCAgYTogJzc2ZDA2Jyxcblx0ICBiOiAnMScsXG5cdCAgbjogJzEwMDAwMDAwMDAwMDAwMDAgMDAwMDAwMDAwMDAwMDAwMCAxNGRlZjlkZWEyZjc5Y2Q2IDU4MTI2MzFhNWNmNWQzZWQnLFxuXHQgIGhhc2g6IGhhc2hfMS5zaGEyNTYsXG5cdCAgZ1JlZDogZmFsc2UsXG5cdCAgZzogW1xuXHQgICAgJzknLFxuXHQgIF0sXG5cdH0pO1xuXG5cdGRlZmluZUN1cnZlKCdlZDI1NTE5Jywge1xuXHQgIHR5cGU6ICdlZHdhcmRzJyxcblx0ICBwcmltZTogJ3AyNTUxOScsXG5cdCAgcDogJzdmZmZmZmZmZmZmZmZmZmYgZmZmZmZmZmZmZmZmZmZmZiBmZmZmZmZmZmZmZmZmZmZmIGZmZmZmZmZmZmZmZmZmZWQnLFxuXHQgIGE6ICctMScsXG5cdCAgYzogJzEnLFxuXHQgIC8vIC0xMjE2NjUgKiAoMTIxNjY2XigtMSkpIChtb2QgUClcblx0ICBkOiAnNTIwMzZjZWUyYjZmZmU3MyA4Y2M3NDA3OTc3NzllODk4IDAwNzAwYTRkNDE0MWQ4YWIgNzVlYjRkY2ExMzU5NzhhMycsXG5cdCAgbjogJzEwMDAwMDAwMDAwMDAwMDAgMDAwMDAwMDAwMDAwMDAwMCAxNGRlZjlkZWEyZjc5Y2Q2IDU4MTI2MzFhNWNmNWQzZWQnLFxuXHQgIGhhc2g6IGhhc2hfMS5zaGEyNTYsXG5cdCAgZ1JlZDogZmFsc2UsXG5cdCAgZzogW1xuXHQgICAgJzIxNjkzNmQzY2Q2ZTUzZmVjMGE0ZTIzMWZkZDZkYzVjNjkyY2M3NjA5NTI1YTdiMmM5NTYyZDYwOGYyNWQ1MWEnLFxuXG5cdCAgICAvLyA0LzVcblx0ICAgICc2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjU4Jyxcblx0ICBdLFxuXHR9KTtcblxuXHR2YXIgcHJlO1xuXHR0cnkge1xuXHQgIHByZSA9IC8qUmljTW9vOmV0aGVyczpyZXF1aXJlKC4vcHJlY29tcHV0ZWQvc2VjcDI1NmsxKSovKG51bGwpLmNyYXNoKCk7XG5cdH0gY2F0Y2ggKGUpIHtcblx0ICBwcmUgPSB1bmRlZmluZWQ7XG5cdH1cblxuXHRkZWZpbmVDdXJ2ZSgnc2VjcDI1NmsxJywge1xuXHQgIHR5cGU6ICdzaG9ydCcsXG5cdCAgcHJpbWU6ICdrMjU2Jyxcblx0ICBwOiAnZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmUgZmZmZmZjMmYnLFxuXHQgIGE6ICcwJyxcblx0ICBiOiAnNycsXG5cdCAgbjogJ2ZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZlIGJhYWVkY2U2IGFmNDhhMDNiIGJmZDI1ZThjIGQwMzY0MTQxJyxcblx0ICBoOiAnMScsXG5cdCAgaGFzaDogaGFzaF8xLnNoYTI1NixcblxuXHQgIC8vIFByZWNvbXB1dGVkIGVuZG9tb3JwaGlzbVxuXHQgIGJldGE6ICc3YWU5NmEyYjY1N2MwNzEwNmU2NDQ3OWVhYzM0MzRlOTljZjA0OTc1MTJmNTg5OTVjMTM5NmMyODcxOTUwMWVlJyxcblx0ICBsYW1iZGE6ICc1MzYzYWQ0Y2MwNWMzMGUwYTUyNjFjMDI4ODEyNjQ1YTEyMmUyMmVhMjA4MTY2NzhkZjAyOTY3YzFiMjNiZDcyJyxcblx0ICBiYXNpczogW1xuXHQgICAge1xuXHQgICAgICBhOiAnMzA4NmQyMjFhN2Q0NmJjZGU4NmM5MGU0OTI4NGViMTUnLFxuXHQgICAgICBiOiAnLWU0NDM3ZWQ2MDEwZTg4Mjg2ZjU0N2ZhOTBhYmZlNGMzJyxcblx0ICAgIH0sXG5cdCAgICB7XG5cdCAgICAgIGE6ICcxMTRjYTUwZjdhOGUyZjNmNjU3YzExMDhkOWQ0NGNmZDgnLFxuXHQgICAgICBiOiAnMzA4NmQyMjFhN2Q0NmJjZGU4NmM5MGU0OTI4NGViMTUnLFxuXHQgICAgfSxcblx0ICBdLFxuXG5cdCAgZ1JlZDogZmFsc2UsXG5cdCAgZzogW1xuXHQgICAgJzc5YmU2NjdlZjlkY2JiYWM1NWEwNjI5NWNlODcwYjA3MDI5YmZjZGIyZGNlMjhkOTU5ZjI4MTViMTZmODE3OTgnLFxuXHQgICAgJzQ4M2FkYTc3MjZhM2M0NjU1ZGE0ZmJmYzBlMTEwOGE4ZmQxN2I0NDhhNjg1NTQxOTljNDdkMDhmZmIxMGQ0YjgnLFxuXHQgICAgcHJlLFxuXHQgIF0sXG5cdH0pO1xuXHR9KTtcblxuXHQndXNlIHN0cmljdCc7XG5cblxuXG5cblxuXHRmdW5jdGlvbiBIbWFjRFJCRyhvcHRpb25zKSB7XG5cdCAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIEhtYWNEUkJHKSlcblx0ICAgIHJldHVybiBuZXcgSG1hY0RSQkcob3B0aW9ucyk7XG5cdCAgdGhpcy5oYXNoID0gb3B0aW9ucy5oYXNoO1xuXHQgIHRoaXMucHJlZFJlc2lzdCA9ICEhb3B0aW9ucy5wcmVkUmVzaXN0O1xuXG5cdCAgdGhpcy5vdXRMZW4gPSB0aGlzLmhhc2gub3V0U2l6ZTtcblx0ICB0aGlzLm1pbkVudHJvcHkgPSBvcHRpb25zLm1pbkVudHJvcHkgfHwgdGhpcy5oYXNoLmhtYWNTdHJlbmd0aDtcblxuXHQgIHRoaXMuX3Jlc2VlZCA9IG51bGw7XG5cdCAgdGhpcy5yZXNlZWRJbnRlcnZhbCA9IG51bGw7XG5cdCAgdGhpcy5LID0gbnVsbDtcblx0ICB0aGlzLlYgPSBudWxsO1xuXG5cdCAgdmFyIGVudHJvcHkgPSB1dGlsc18xLnRvQXJyYXkob3B0aW9ucy5lbnRyb3B5LCBvcHRpb25zLmVudHJvcHlFbmMgfHwgJ2hleCcpO1xuXHQgIHZhciBub25jZSA9IHV0aWxzXzEudG9BcnJheShvcHRpb25zLm5vbmNlLCBvcHRpb25zLm5vbmNlRW5jIHx8ICdoZXgnKTtcblx0ICB2YXIgcGVycyA9IHV0aWxzXzEudG9BcnJheShvcHRpb25zLnBlcnMsIG9wdGlvbnMucGVyc0VuYyB8fCAnaGV4Jyk7XG5cdCAgbWluaW1hbGlzdGljQXNzZXJ0KGVudHJvcHkubGVuZ3RoID49ICh0aGlzLm1pbkVudHJvcHkgLyA4KSxcblx0ICAgICAgICAgJ05vdCBlbm91Z2ggZW50cm9weS4gTWluaW11bSBpczogJyArIHRoaXMubWluRW50cm9weSArICcgYml0cycpO1xuXHQgIHRoaXMuX2luaXQoZW50cm9weSwgbm9uY2UsIHBlcnMpO1xuXHR9XG5cdHZhciBobWFjRHJiZyA9IEhtYWNEUkJHO1xuXG5cdEhtYWNEUkJHLnByb3RvdHlwZS5faW5pdCA9IGZ1bmN0aW9uIGluaXQoZW50cm9weSwgbm9uY2UsIHBlcnMpIHtcblx0ICB2YXIgc2VlZCA9IGVudHJvcHkuY29uY2F0KG5vbmNlKS5jb25jYXQocGVycyk7XG5cblx0ICB0aGlzLksgPSBuZXcgQXJyYXkodGhpcy5vdXRMZW4gLyA4KTtcblx0ICB0aGlzLlYgPSBuZXcgQXJyYXkodGhpcy5vdXRMZW4gLyA4KTtcblx0ICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuVi5sZW5ndGg7IGkrKykge1xuXHQgICAgdGhpcy5LW2ldID0gMHgwMDtcblx0ICAgIHRoaXMuVltpXSA9IDB4MDE7XG5cdCAgfVxuXG5cdCAgdGhpcy5fdXBkYXRlKHNlZWQpO1xuXHQgIHRoaXMuX3Jlc2VlZCA9IDE7XG5cdCAgdGhpcy5yZXNlZWRJbnRlcnZhbCA9IDB4MTAwMDAwMDAwMDAwMDsgIC8vIDJeNDhcblx0fTtcblxuXHRIbWFjRFJCRy5wcm90b3R5cGUuX2htYWMgPSBmdW5jdGlvbiBobWFjKCkge1xuXHQgIHJldHVybiBuZXcgaGFzaF8xLmhtYWModGhpcy5oYXNoLCB0aGlzLkspO1xuXHR9O1xuXG5cdEhtYWNEUkJHLnByb3RvdHlwZS5fdXBkYXRlID0gZnVuY3Rpb24gdXBkYXRlKHNlZWQpIHtcblx0ICB2YXIga21hYyA9IHRoaXMuX2htYWMoKVxuXHQgICAgICAgICAgICAgICAgIC51cGRhdGUodGhpcy5WKVxuXHQgICAgICAgICAgICAgICAgIC51cGRhdGUoWyAweDAwIF0pO1xuXHQgIGlmIChzZWVkKVxuXHQgICAga21hYyA9IGttYWMudXBkYXRlKHNlZWQpO1xuXHQgIHRoaXMuSyA9IGttYWMuZGlnZXN0KCk7XG5cdCAgdGhpcy5WID0gdGhpcy5faG1hYygpLnVwZGF0ZSh0aGlzLlYpLmRpZ2VzdCgpO1xuXHQgIGlmICghc2VlZClcblx0ICAgIHJldHVybjtcblxuXHQgIHRoaXMuSyA9IHRoaXMuX2htYWMoKVxuXHQgICAgICAgICAgICAgICAudXBkYXRlKHRoaXMuVilcblx0ICAgICAgICAgICAgICAgLnVwZGF0ZShbIDB4MDEgXSlcblx0ICAgICAgICAgICAgICAgLnVwZGF0ZShzZWVkKVxuXHQgICAgICAgICAgICAgICAuZGlnZXN0KCk7XG5cdCAgdGhpcy5WID0gdGhpcy5faG1hYygpLnVwZGF0ZSh0aGlzLlYpLmRpZ2VzdCgpO1xuXHR9O1xuXG5cdEhtYWNEUkJHLnByb3RvdHlwZS5yZXNlZWQgPSBmdW5jdGlvbiByZXNlZWQoZW50cm9weSwgZW50cm9weUVuYywgYWRkLCBhZGRFbmMpIHtcblx0ICAvLyBPcHRpb25hbCBlbnRyb3B5IGVuY1xuXHQgIGlmICh0eXBlb2YgZW50cm9weUVuYyAhPT0gJ3N0cmluZycpIHtcblx0ICAgIGFkZEVuYyA9IGFkZDtcblx0ICAgIGFkZCA9IGVudHJvcHlFbmM7XG5cdCAgICBlbnRyb3B5RW5jID0gbnVsbDtcblx0ICB9XG5cblx0ICBlbnRyb3B5ID0gdXRpbHNfMS50b0FycmF5KGVudHJvcHksIGVudHJvcHlFbmMpO1xuXHQgIGFkZCA9IHV0aWxzXzEudG9BcnJheShhZGQsIGFkZEVuYyk7XG5cblx0ICBtaW5pbWFsaXN0aWNBc3NlcnQoZW50cm9weS5sZW5ndGggPj0gKHRoaXMubWluRW50cm9weSAvIDgpLFxuXHQgICAgICAgICAnTm90IGVub3VnaCBlbnRyb3B5LiBNaW5pbXVtIGlzOiAnICsgdGhpcy5taW5FbnRyb3B5ICsgJyBiaXRzJyk7XG5cblx0ICB0aGlzLl91cGRhdGUoZW50cm9weS5jb25jYXQoYWRkIHx8IFtdKSk7XG5cdCAgdGhpcy5fcmVzZWVkID0gMTtcblx0fTtcblxuXHRIbWFjRFJCRy5wcm90b3R5cGUuZ2VuZXJhdGUgPSBmdW5jdGlvbiBnZW5lcmF0ZShsZW4sIGVuYywgYWRkLCBhZGRFbmMpIHtcblx0ICBpZiAodGhpcy5fcmVzZWVkID4gdGhpcy5yZXNlZWRJbnRlcnZhbClcblx0ICAgIHRocm93IG5ldyBFcnJvcignUmVzZWVkIGlzIHJlcXVpcmVkJyk7XG5cblx0ICAvLyBPcHRpb25hbCBlbmNvZGluZ1xuXHQgIGlmICh0eXBlb2YgZW5jICE9PSAnc3RyaW5nJykge1xuXHQgICAgYWRkRW5jID0gYWRkO1xuXHQgICAgYWRkID0gZW5jO1xuXHQgICAgZW5jID0gbnVsbDtcblx0ICB9XG5cblx0ICAvLyBPcHRpb25hbCBhZGRpdGlvbmFsIGRhdGFcblx0ICBpZiAoYWRkKSB7XG5cdCAgICBhZGQgPSB1dGlsc18xLnRvQXJyYXkoYWRkLCBhZGRFbmMgfHwgJ2hleCcpO1xuXHQgICAgdGhpcy5fdXBkYXRlKGFkZCk7XG5cdCAgfVxuXG5cdCAgdmFyIHRlbXAgPSBbXTtcblx0ICB3aGlsZSAodGVtcC5sZW5ndGggPCBsZW4pIHtcblx0ICAgIHRoaXMuViA9IHRoaXMuX2htYWMoKS51cGRhdGUodGhpcy5WKS5kaWdlc3QoKTtcblx0ICAgIHRlbXAgPSB0ZW1wLmNvbmNhdCh0aGlzLlYpO1xuXHQgIH1cblxuXHQgIHZhciByZXMgPSB0ZW1wLnNsaWNlKDAsIGxlbik7XG5cdCAgdGhpcy5fdXBkYXRlKGFkZCk7XG5cdCAgdGhpcy5fcmVzZWVkKys7XG5cdCAgcmV0dXJuIHV0aWxzXzEuZW5jb2RlKHJlcywgZW5jKTtcblx0fTtcblxuXHQndXNlIHN0cmljdCc7XG5cblxuXG5cdHZhciBhc3NlcnQkMyA9IHV0aWxzXzEkMS5hc3NlcnQ7XG5cblx0ZnVuY3Rpb24gS2V5UGFpcihlYywgb3B0aW9ucykge1xuXHQgIHRoaXMuZWMgPSBlYztcblx0ICB0aGlzLnByaXYgPSBudWxsO1xuXHQgIHRoaXMucHViID0gbnVsbDtcblxuXHQgIC8vIEtleVBhaXIoZWMsIHsgcHJpdjogLi4uLCBwdWI6IC4uLiB9KVxuXHQgIGlmIChvcHRpb25zLnByaXYpXG5cdCAgICB0aGlzLl9pbXBvcnRQcml2YXRlKG9wdGlvbnMucHJpdiwgb3B0aW9ucy5wcml2RW5jKTtcblx0ICBpZiAob3B0aW9ucy5wdWIpXG5cdCAgICB0aGlzLl9pbXBvcnRQdWJsaWMob3B0aW9ucy5wdWIsIG9wdGlvbnMucHViRW5jKTtcblx0fVxuXHR2YXIga2V5ID0gS2V5UGFpcjtcblxuXHRLZXlQYWlyLmZyb21QdWJsaWMgPSBmdW5jdGlvbiBmcm9tUHVibGljKGVjLCBwdWIsIGVuYykge1xuXHQgIGlmIChwdWIgaW5zdGFuY2VvZiBLZXlQYWlyKVxuXHQgICAgcmV0dXJuIHB1YjtcblxuXHQgIHJldHVybiBuZXcgS2V5UGFpcihlYywge1xuXHQgICAgcHViOiBwdWIsXG5cdCAgICBwdWJFbmM6IGVuYyxcblx0ICB9KTtcblx0fTtcblxuXHRLZXlQYWlyLmZyb21Qcml2YXRlID0gZnVuY3Rpb24gZnJvbVByaXZhdGUoZWMsIHByaXYsIGVuYykge1xuXHQgIGlmIChwcml2IGluc3RhbmNlb2YgS2V5UGFpcilcblx0ICAgIHJldHVybiBwcml2O1xuXG5cdCAgcmV0dXJuIG5ldyBLZXlQYWlyKGVjLCB7XG5cdCAgICBwcml2OiBwcml2LFxuXHQgICAgcHJpdkVuYzogZW5jLFxuXHQgIH0pO1xuXHR9O1xuXG5cdEtleVBhaXIucHJvdG90eXBlLnZhbGlkYXRlID0gZnVuY3Rpb24gdmFsaWRhdGUoKSB7XG5cdCAgdmFyIHB1YiA9IHRoaXMuZ2V0UHVibGljKCk7XG5cblx0ICBpZiAocHViLmlzSW5maW5pdHkoKSlcblx0ICAgIHJldHVybiB7IHJlc3VsdDogZmFsc2UsIHJlYXNvbjogJ0ludmFsaWQgcHVibGljIGtleScgfTtcblx0ICBpZiAoIXB1Yi52YWxpZGF0ZSgpKVxuXHQgICAgcmV0dXJuIHsgcmVzdWx0OiBmYWxzZSwgcmVhc29uOiAnUHVibGljIGtleSBpcyBub3QgYSBwb2ludCcgfTtcblx0ICBpZiAoIXB1Yi5tdWwodGhpcy5lYy5jdXJ2ZS5uKS5pc0luZmluaXR5KCkpXG5cdCAgICByZXR1cm4geyByZXN1bHQ6IGZhbHNlLCByZWFzb246ICdQdWJsaWMga2V5ICogTiAhPSBPJyB9O1xuXG5cdCAgcmV0dXJuIHsgcmVzdWx0OiB0cnVlLCByZWFzb246IG51bGwgfTtcblx0fTtcblxuXHRLZXlQYWlyLnByb3RvdHlwZS5nZXRQdWJsaWMgPSBmdW5jdGlvbiBnZXRQdWJsaWMoY29tcGFjdCwgZW5jKSB7XG5cdCAgLy8gY29tcGFjdCBpcyBvcHRpb25hbCBhcmd1bWVudFxuXHQgIGlmICh0eXBlb2YgY29tcGFjdCA9PT0gJ3N0cmluZycpIHtcblx0ICAgIGVuYyA9IGNvbXBhY3Q7XG5cdCAgICBjb21wYWN0ID0gbnVsbDtcblx0ICB9XG5cblx0ICBpZiAoIXRoaXMucHViKVxuXHQgICAgdGhpcy5wdWIgPSB0aGlzLmVjLmcubXVsKHRoaXMucHJpdik7XG5cblx0ICBpZiAoIWVuYylcblx0ICAgIHJldHVybiB0aGlzLnB1YjtcblxuXHQgIHJldHVybiB0aGlzLnB1Yi5lbmNvZGUoZW5jLCBjb21wYWN0KTtcblx0fTtcblxuXHRLZXlQYWlyLnByb3RvdHlwZS5nZXRQcml2YXRlID0gZnVuY3Rpb24gZ2V0UHJpdmF0ZShlbmMpIHtcblx0ICBpZiAoZW5jID09PSAnaGV4Jylcblx0ICAgIHJldHVybiB0aGlzLnByaXYudG9TdHJpbmcoMTYsIDIpO1xuXHQgIGVsc2Vcblx0ICAgIHJldHVybiB0aGlzLnByaXY7XG5cdH07XG5cblx0S2V5UGFpci5wcm90b3R5cGUuX2ltcG9ydFByaXZhdGUgPSBmdW5jdGlvbiBfaW1wb3J0UHJpdmF0ZShrZXksIGVuYykge1xuXHQgIHRoaXMucHJpdiA9IG5ldyBibihrZXksIGVuYyB8fCAxNik7XG5cblx0ICAvLyBFbnN1cmUgdGhhdCB0aGUgcHJpdiB3b24ndCBiZSBiaWdnZXIgdGhhbiBuLCBvdGhlcndpc2Ugd2UgbWF5IGZhaWxcblx0ICAvLyBpbiBmaXhlZCBtdWx0aXBsaWNhdGlvbiBtZXRob2Rcblx0ICB0aGlzLnByaXYgPSB0aGlzLnByaXYudW1vZCh0aGlzLmVjLmN1cnZlLm4pO1xuXHR9O1xuXG5cdEtleVBhaXIucHJvdG90eXBlLl9pbXBvcnRQdWJsaWMgPSBmdW5jdGlvbiBfaW1wb3J0UHVibGljKGtleSwgZW5jKSB7XG5cdCAgaWYgKGtleS54IHx8IGtleS55KSB7XG5cdCAgICAvLyBNb250Z29tZXJ5IHBvaW50cyBvbmx5IGhhdmUgYW4gYHhgIGNvb3JkaW5hdGUuXG5cdCAgICAvLyBXZWllcnN0cmFzcy9FZHdhcmRzIHBvaW50cyBvbiB0aGUgb3RoZXIgaGFuZCBoYXZlIGJvdGggYHhgIGFuZFxuXHQgICAgLy8gYHlgIGNvb3JkaW5hdGVzLlxuXHQgICAgaWYgKHRoaXMuZWMuY3VydmUudHlwZSA9PT0gJ21vbnQnKSB7XG5cdCAgICAgIGFzc2VydCQzKGtleS54LCAnTmVlZCB4IGNvb3JkaW5hdGUnKTtcblx0ICAgIH0gZWxzZSBpZiAodGhpcy5lYy5jdXJ2ZS50eXBlID09PSAnc2hvcnQnIHx8XG5cdCAgICAgICAgICAgICAgIHRoaXMuZWMuY3VydmUudHlwZSA9PT0gJ2Vkd2FyZHMnKSB7XG5cdCAgICAgIGFzc2VydCQzKGtleS54ICYmIGtleS55LCAnTmVlZCBib3RoIHggYW5kIHkgY29vcmRpbmF0ZScpO1xuXHQgICAgfVxuXHQgICAgdGhpcy5wdWIgPSB0aGlzLmVjLmN1cnZlLnBvaW50KGtleS54LCBrZXkueSk7XG5cdCAgICByZXR1cm47XG5cdCAgfVxuXHQgIHRoaXMucHViID0gdGhpcy5lYy5jdXJ2ZS5kZWNvZGVQb2ludChrZXksIGVuYyk7XG5cdH07XG5cblx0Ly8gRUNESFxuXHRLZXlQYWlyLnByb3RvdHlwZS5kZXJpdmUgPSBmdW5jdGlvbiBkZXJpdmUocHViKSB7XG5cdCAgaWYoIXB1Yi52YWxpZGF0ZSgpKSB7XG5cdCAgICBhc3NlcnQkMyhwdWIudmFsaWRhdGUoKSwgJ3B1YmxpYyBwb2ludCBub3QgdmFsaWRhdGVkJyk7XG5cdCAgfVxuXHQgIHJldHVybiBwdWIubXVsKHRoaXMucHJpdikuZ2V0WCgpO1xuXHR9O1xuXG5cdC8vIEVDRFNBXG5cdEtleVBhaXIucHJvdG90eXBlLnNpZ24gPSBmdW5jdGlvbiBzaWduKG1zZywgZW5jLCBvcHRpb25zKSB7XG5cdCAgcmV0dXJuIHRoaXMuZWMuc2lnbihtc2csIHRoaXMsIGVuYywgb3B0aW9ucyk7XG5cdH07XG5cblx0S2V5UGFpci5wcm90b3R5cGUudmVyaWZ5ID0gZnVuY3Rpb24gdmVyaWZ5KG1zZywgc2lnbmF0dXJlKSB7XG5cdCAgcmV0dXJuIHRoaXMuZWMudmVyaWZ5KG1zZywgc2lnbmF0dXJlLCB0aGlzKTtcblx0fTtcblxuXHRLZXlQYWlyLnByb3RvdHlwZS5pbnNwZWN0ID0gZnVuY3Rpb24gaW5zcGVjdCgpIHtcblx0ICByZXR1cm4gJzxLZXkgcHJpdjogJyArICh0aGlzLnByaXYgJiYgdGhpcy5wcml2LnRvU3RyaW5nKDE2LCAyKSkgK1xuXHQgICAgICAgICAnIHB1YjogJyArICh0aGlzLnB1YiAmJiB0aGlzLnB1Yi5pbnNwZWN0KCkpICsgJyA+Jztcblx0fTtcblxuXHQndXNlIHN0cmljdCc7XG5cblxuXG5cblx0dmFyIGFzc2VydCQ0ID0gdXRpbHNfMSQxLmFzc2VydDtcblxuXHRmdW5jdGlvbiBTaWduYXR1cmUob3B0aW9ucywgZW5jKSB7XG5cdCAgaWYgKG9wdGlvbnMgaW5zdGFuY2VvZiBTaWduYXR1cmUpXG5cdCAgICByZXR1cm4gb3B0aW9ucztcblxuXHQgIGlmICh0aGlzLl9pbXBvcnRERVIob3B0aW9ucywgZW5jKSlcblx0ICAgIHJldHVybjtcblxuXHQgIGFzc2VydCQ0KG9wdGlvbnMuciAmJiBvcHRpb25zLnMsICdTaWduYXR1cmUgd2l0aG91dCByIG9yIHMnKTtcblx0ICB0aGlzLnIgPSBuZXcgYm4ob3B0aW9ucy5yLCAxNik7XG5cdCAgdGhpcy5zID0gbmV3IGJuKG9wdGlvbnMucywgMTYpO1xuXHQgIGlmIChvcHRpb25zLnJlY292ZXJ5UGFyYW0gPT09IHVuZGVmaW5lZClcblx0ICAgIHRoaXMucmVjb3ZlcnlQYXJhbSA9IG51bGw7XG5cdCAgZWxzZVxuXHQgICAgdGhpcy5yZWNvdmVyeVBhcmFtID0gb3B0aW9ucy5yZWNvdmVyeVBhcmFtO1xuXHR9XG5cdHZhciBzaWduYXR1cmUgPSBTaWduYXR1cmU7XG5cblx0ZnVuY3Rpb24gUG9zaXRpb24oKSB7XG5cdCAgdGhpcy5wbGFjZSA9IDA7XG5cdH1cblxuXHRmdW5jdGlvbiBnZXRMZW5ndGgoYnVmLCBwKSB7XG5cdCAgdmFyIGluaXRpYWwgPSBidWZbcC5wbGFjZSsrXTtcblx0ICBpZiAoIShpbml0aWFsICYgMHg4MCkpIHtcblx0ICAgIHJldHVybiBpbml0aWFsO1xuXHQgIH1cblx0ICB2YXIgb2N0ZXRMZW4gPSBpbml0aWFsICYgMHhmO1xuXG5cdCAgLy8gSW5kZWZpbml0ZSBsZW5ndGggb3Igb3ZlcmZsb3dcblx0ICBpZiAob2N0ZXRMZW4gPT09IDAgfHwgb2N0ZXRMZW4gPiA0KSB7XG5cdCAgICByZXR1cm4gZmFsc2U7XG5cdCAgfVxuXG5cdCAgdmFyIHZhbCA9IDA7XG5cdCAgZm9yICh2YXIgaSA9IDAsIG9mZiA9IHAucGxhY2U7IGkgPCBvY3RldExlbjsgaSsrLCBvZmYrKykge1xuXHQgICAgdmFsIDw8PSA4O1xuXHQgICAgdmFsIHw9IGJ1ZltvZmZdO1xuXHQgICAgdmFsID4+Pj0gMDtcblx0ICB9XG5cblx0ICAvLyBMZWFkaW5nIHplcm9lc1xuXHQgIGlmICh2YWwgPD0gMHg3Zikge1xuXHQgICAgcmV0dXJuIGZhbHNlO1xuXHQgIH1cblxuXHQgIHAucGxhY2UgPSBvZmY7XG5cdCAgcmV0dXJuIHZhbDtcblx0fVxuXG5cdGZ1bmN0aW9uIHJtUGFkZGluZyhidWYpIHtcblx0ICB2YXIgaSA9IDA7XG5cdCAgdmFyIGxlbiA9IGJ1Zi5sZW5ndGggLSAxO1xuXHQgIHdoaWxlICghYnVmW2ldICYmICEoYnVmW2kgKyAxXSAmIDB4ODApICYmIGkgPCBsZW4pIHtcblx0ICAgIGkrKztcblx0ICB9XG5cdCAgaWYgKGkgPT09IDApIHtcblx0ICAgIHJldHVybiBidWY7XG5cdCAgfVxuXHQgIHJldHVybiBidWYuc2xpY2UoaSk7XG5cdH1cblxuXHRTaWduYXR1cmUucHJvdG90eXBlLl9pbXBvcnRERVIgPSBmdW5jdGlvbiBfaW1wb3J0REVSKGRhdGEsIGVuYykge1xuXHQgIGRhdGEgPSB1dGlsc18xJDEudG9BcnJheShkYXRhLCBlbmMpO1xuXHQgIHZhciBwID0gbmV3IFBvc2l0aW9uKCk7XG5cdCAgaWYgKGRhdGFbcC5wbGFjZSsrXSAhPT0gMHgzMCkge1xuXHQgICAgcmV0dXJuIGZhbHNlO1xuXHQgIH1cblx0ICB2YXIgbGVuID0gZ2V0TGVuZ3RoKGRhdGEsIHApO1xuXHQgIGlmIChsZW4gPT09IGZhbHNlKSB7XG5cdCAgICByZXR1cm4gZmFsc2U7XG5cdCAgfVxuXHQgIGlmICgobGVuICsgcC5wbGFjZSkgIT09IGRhdGEubGVuZ3RoKSB7XG5cdCAgICByZXR1cm4gZmFsc2U7XG5cdCAgfVxuXHQgIGlmIChkYXRhW3AucGxhY2UrK10gIT09IDB4MDIpIHtcblx0ICAgIHJldHVybiBmYWxzZTtcblx0ICB9XG5cdCAgdmFyIHJsZW4gPSBnZXRMZW5ndGgoZGF0YSwgcCk7XG5cdCAgaWYgKHJsZW4gPT09IGZhbHNlKSB7XG5cdCAgICByZXR1cm4gZmFsc2U7XG5cdCAgfVxuXHQgIHZhciByID0gZGF0YS5zbGljZShwLnBsYWNlLCBybGVuICsgcC5wbGFjZSk7XG5cdCAgcC5wbGFjZSArPSBybGVuO1xuXHQgIGlmIChkYXRhW3AucGxhY2UrK10gIT09IDB4MDIpIHtcblx0ICAgIHJldHVybiBmYWxzZTtcblx0ICB9XG5cdCAgdmFyIHNsZW4gPSBnZXRMZW5ndGgoZGF0YSwgcCk7XG5cdCAgaWYgKHNsZW4gPT09IGZhbHNlKSB7XG5cdCAgICByZXR1cm4gZmFsc2U7XG5cdCAgfVxuXHQgIGlmIChkYXRhLmxlbmd0aCAhPT0gc2xlbiArIHAucGxhY2UpIHtcblx0ICAgIHJldHVybiBmYWxzZTtcblx0ICB9XG5cdCAgdmFyIHMgPSBkYXRhLnNsaWNlKHAucGxhY2UsIHNsZW4gKyBwLnBsYWNlKTtcblx0ICBpZiAoclswXSA9PT0gMCkge1xuXHQgICAgaWYgKHJbMV0gJiAweDgwKSB7XG5cdCAgICAgIHIgPSByLnNsaWNlKDEpO1xuXHQgICAgfSBlbHNlIHtcblx0ICAgICAgLy8gTGVhZGluZyB6ZXJvZXNcblx0ICAgICAgcmV0dXJuIGZhbHNlO1xuXHQgICAgfVxuXHQgIH1cblx0ICBpZiAoc1swXSA9PT0gMCkge1xuXHQgICAgaWYgKHNbMV0gJiAweDgwKSB7XG5cdCAgICAgIHMgPSBzLnNsaWNlKDEpO1xuXHQgICAgfSBlbHNlIHtcblx0ICAgICAgLy8gTGVhZGluZyB6ZXJvZXNcblx0ICAgICAgcmV0dXJuIGZhbHNlO1xuXHQgICAgfVxuXHQgIH1cblxuXHQgIHRoaXMuciA9IG5ldyBibihyKTtcblx0ICB0aGlzLnMgPSBuZXcgYm4ocyk7XG5cdCAgdGhpcy5yZWNvdmVyeVBhcmFtID0gbnVsbDtcblxuXHQgIHJldHVybiB0cnVlO1xuXHR9O1xuXG5cdGZ1bmN0aW9uIGNvbnN0cnVjdExlbmd0aChhcnIsIGxlbikge1xuXHQgIGlmIChsZW4gPCAweDgwKSB7XG5cdCAgICBhcnIucHVzaChsZW4pO1xuXHQgICAgcmV0dXJuO1xuXHQgIH1cblx0ICB2YXIgb2N0ZXRzID0gMSArIChNYXRoLmxvZyhsZW4pIC8gTWF0aC5MTjIgPj4+IDMpO1xuXHQgIGFyci5wdXNoKG9jdGV0cyB8IDB4ODApO1xuXHQgIHdoaWxlICgtLW9jdGV0cykge1xuXHQgICAgYXJyLnB1c2goKGxlbiA+Pj4gKG9jdGV0cyA8PCAzKSkgJiAweGZmKTtcblx0ICB9XG5cdCAgYXJyLnB1c2gobGVuKTtcblx0fVxuXG5cdFNpZ25hdHVyZS5wcm90b3R5cGUudG9ERVIgPSBmdW5jdGlvbiB0b0RFUihlbmMpIHtcblx0ICB2YXIgciA9IHRoaXMuci50b0FycmF5KCk7XG5cdCAgdmFyIHMgPSB0aGlzLnMudG9BcnJheSgpO1xuXG5cdCAgLy8gUGFkIHZhbHVlc1xuXHQgIGlmIChyWzBdICYgMHg4MClcblx0ICAgIHIgPSBbIDAgXS5jb25jYXQocik7XG5cdCAgLy8gUGFkIHZhbHVlc1xuXHQgIGlmIChzWzBdICYgMHg4MClcblx0ICAgIHMgPSBbIDAgXS5jb25jYXQocyk7XG5cblx0ICByID0gcm1QYWRkaW5nKHIpO1xuXHQgIHMgPSBybVBhZGRpbmcocyk7XG5cblx0ICB3aGlsZSAoIXNbMF0gJiYgIShzWzFdICYgMHg4MCkpIHtcblx0ICAgIHMgPSBzLnNsaWNlKDEpO1xuXHQgIH1cblx0ICB2YXIgYXJyID0gWyAweDAyIF07XG5cdCAgY29uc3RydWN0TGVuZ3RoKGFyciwgci5sZW5ndGgpO1xuXHQgIGFyciA9IGFyci5jb25jYXQocik7XG5cdCAgYXJyLnB1c2goMHgwMik7XG5cdCAgY29uc3RydWN0TGVuZ3RoKGFyciwgcy5sZW5ndGgpO1xuXHQgIHZhciBiYWNrSGFsZiA9IGFyci5jb25jYXQocyk7XG5cdCAgdmFyIHJlcyA9IFsgMHgzMCBdO1xuXHQgIGNvbnN0cnVjdExlbmd0aChyZXMsIGJhY2tIYWxmLmxlbmd0aCk7XG5cdCAgcmVzID0gcmVzLmNvbmNhdChiYWNrSGFsZik7XG5cdCAgcmV0dXJuIHV0aWxzXzEkMS5lbmNvZGUocmVzLCBlbmMpO1xuXHR9O1xuXG5cdCd1c2Ugc3RyaWN0JztcblxuXG5cblxuXG5cdHZhciByYW5kID0gLypSaWNNb286ZXRoZXJzOnJlcXVpcmUoYnJvcmFuZCkqLyhmdW5jdGlvbigpIHsgdGhyb3cgbmV3IEVycm9yKCd1bnN1cHBvcnRlZCcpOyB9KTtcblx0dmFyIGFzc2VydCQ1ID0gdXRpbHNfMSQxLmFzc2VydDtcblxuXG5cblxuXHRmdW5jdGlvbiBFQyhvcHRpb25zKSB7XG5cdCAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIEVDKSlcblx0ICAgIHJldHVybiBuZXcgRUMob3B0aW9ucyk7XG5cblx0ICAvLyBTaG9ydGN1dCBgZWxsaXB0aWMuZWMoY3VydmUtbmFtZSlgXG5cdCAgaWYgKHR5cGVvZiBvcHRpb25zID09PSAnc3RyaW5nJykge1xuXHQgICAgYXNzZXJ0JDUoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGN1cnZlc18xLCBvcHRpb25zKSxcblx0ICAgICAgJ1Vua25vd24gY3VydmUgJyArIG9wdGlvbnMpO1xuXG5cdCAgICBvcHRpb25zID0gY3VydmVzXzFbb3B0aW9uc107XG5cdCAgfVxuXG5cdCAgLy8gU2hvcnRjdXQgZm9yIGBlbGxpcHRpYy5lYyhlbGxpcHRpYy5jdXJ2ZXMuY3VydmVOYW1lKWBcblx0ICBpZiAob3B0aW9ucyBpbnN0YW5jZW9mIGN1cnZlc18xLlByZXNldEN1cnZlKVxuXHQgICAgb3B0aW9ucyA9IHsgY3VydmU6IG9wdGlvbnMgfTtcblxuXHQgIHRoaXMuY3VydmUgPSBvcHRpb25zLmN1cnZlLmN1cnZlO1xuXHQgIHRoaXMubiA9IHRoaXMuY3VydmUubjtcblx0ICB0aGlzLm5oID0gdGhpcy5uLnVzaHJuKDEpO1xuXHQgIHRoaXMuZyA9IHRoaXMuY3VydmUuZztcblxuXHQgIC8vIFBvaW50IG9uIGN1cnZlXG5cdCAgdGhpcy5nID0gb3B0aW9ucy5jdXJ2ZS5nO1xuXHQgIHRoaXMuZy5wcmVjb21wdXRlKG9wdGlvbnMuY3VydmUubi5iaXRMZW5ndGgoKSArIDEpO1xuXG5cdCAgLy8gSGFzaCBmb3IgZnVuY3Rpb24gZm9yIERSQkdcblx0ICB0aGlzLmhhc2ggPSBvcHRpb25zLmhhc2ggfHwgb3B0aW9ucy5jdXJ2ZS5oYXNoO1xuXHR9XG5cdHZhciBlYyA9IEVDO1xuXG5cdEVDLnByb3RvdHlwZS5rZXlQYWlyID0gZnVuY3Rpb24ga2V5UGFpcihvcHRpb25zKSB7XG5cdCAgcmV0dXJuIG5ldyBrZXkodGhpcywgb3B0aW9ucyk7XG5cdH07XG5cblx0RUMucHJvdG90eXBlLmtleUZyb21Qcml2YXRlID0gZnVuY3Rpb24ga2V5RnJvbVByaXZhdGUocHJpdiwgZW5jKSB7XG5cdCAgcmV0dXJuIGtleS5mcm9tUHJpdmF0ZSh0aGlzLCBwcml2LCBlbmMpO1xuXHR9O1xuXG5cdEVDLnByb3RvdHlwZS5rZXlGcm9tUHVibGljID0gZnVuY3Rpb24ga2V5RnJvbVB1YmxpYyhwdWIsIGVuYykge1xuXHQgIHJldHVybiBrZXkuZnJvbVB1YmxpYyh0aGlzLCBwdWIsIGVuYyk7XG5cdH07XG5cblx0RUMucHJvdG90eXBlLmdlbktleVBhaXIgPSBmdW5jdGlvbiBnZW5LZXlQYWlyKG9wdGlvbnMpIHtcblx0ICBpZiAoIW9wdGlvbnMpXG5cdCAgICBvcHRpb25zID0ge307XG5cblx0ICAvLyBJbnN0YW50aWF0ZSBIbWFjX0RSQkdcblx0ICB2YXIgZHJiZyA9IG5ldyBobWFjRHJiZyh7XG5cdCAgICBoYXNoOiB0aGlzLmhhc2gsXG5cdCAgICBwZXJzOiBvcHRpb25zLnBlcnMsXG5cdCAgICBwZXJzRW5jOiBvcHRpb25zLnBlcnNFbmMgfHwgJ3V0ZjgnLFxuXHQgICAgZW50cm9weTogb3B0aW9ucy5lbnRyb3B5IHx8IHJhbmQodGhpcy5oYXNoLmhtYWNTdHJlbmd0aCksXG5cdCAgICBlbnRyb3B5RW5jOiBvcHRpb25zLmVudHJvcHkgJiYgb3B0aW9ucy5lbnRyb3B5RW5jIHx8ICd1dGY4Jyxcblx0ICAgIG5vbmNlOiB0aGlzLm4udG9BcnJheSgpLFxuXHQgIH0pO1xuXG5cdCAgdmFyIGJ5dGVzID0gdGhpcy5uLmJ5dGVMZW5ndGgoKTtcblx0ICB2YXIgbnMyID0gdGhpcy5uLnN1YihuZXcgYm4oMikpO1xuXHQgIGZvciAoOzspIHtcblx0ICAgIHZhciBwcml2ID0gbmV3IGJuKGRyYmcuZ2VuZXJhdGUoYnl0ZXMpKTtcblx0ICAgIGlmIChwcml2LmNtcChuczIpID4gMClcblx0ICAgICAgY29udGludWU7XG5cblx0ICAgIHByaXYuaWFkZG4oMSk7XG5cdCAgICByZXR1cm4gdGhpcy5rZXlGcm9tUHJpdmF0ZShwcml2KTtcblx0ICB9XG5cdH07XG5cblx0RUMucHJvdG90eXBlLl90cnVuY2F0ZVRvTiA9IGZ1bmN0aW9uIF90cnVuY2F0ZVRvTihtc2csIHRydW5jT25seSkge1xuXHQgIHZhciBkZWx0YSA9IG1zZy5ieXRlTGVuZ3RoKCkgKiA4IC0gdGhpcy5uLmJpdExlbmd0aCgpO1xuXHQgIGlmIChkZWx0YSA+IDApXG5cdCAgICBtc2cgPSBtc2cudXNocm4oZGVsdGEpO1xuXHQgIGlmICghdHJ1bmNPbmx5ICYmIG1zZy5jbXAodGhpcy5uKSA+PSAwKVxuXHQgICAgcmV0dXJuIG1zZy5zdWIodGhpcy5uKTtcblx0ICBlbHNlXG5cdCAgICByZXR1cm4gbXNnO1xuXHR9O1xuXG5cdEVDLnByb3RvdHlwZS5zaWduID0gZnVuY3Rpb24gc2lnbihtc2csIGtleSwgZW5jLCBvcHRpb25zKSB7XG5cdCAgaWYgKHR5cGVvZiBlbmMgPT09ICdvYmplY3QnKSB7XG5cdCAgICBvcHRpb25zID0gZW5jO1xuXHQgICAgZW5jID0gbnVsbDtcblx0ICB9XG5cdCAgaWYgKCFvcHRpb25zKVxuXHQgICAgb3B0aW9ucyA9IHt9O1xuXG5cdCAga2V5ID0gdGhpcy5rZXlGcm9tUHJpdmF0ZShrZXksIGVuYyk7XG5cdCAgbXNnID0gdGhpcy5fdHJ1bmNhdGVUb04obmV3IGJuKG1zZywgMTYpKTtcblxuXHQgIC8vIFplcm8tZXh0ZW5kIGtleSB0byBwcm92aWRlIGVub3VnaCBlbnRyb3B5XG5cdCAgdmFyIGJ5dGVzID0gdGhpcy5uLmJ5dGVMZW5ndGgoKTtcblx0ICB2YXIgYmtleSA9IGtleS5nZXRQcml2YXRlKCkudG9BcnJheSgnYmUnLCBieXRlcyk7XG5cblx0ICAvLyBaZXJvLWV4dGVuZCBub25jZSB0byBoYXZlIHRoZSBzYW1lIGJ5dGUgc2l6ZSBhcyBOXG5cdCAgdmFyIG5vbmNlID0gbXNnLnRvQXJyYXkoJ2JlJywgYnl0ZXMpO1xuXG5cdCAgLy8gSW5zdGFudGlhdGUgSG1hY19EUkJHXG5cdCAgdmFyIGRyYmcgPSBuZXcgaG1hY0RyYmcoe1xuXHQgICAgaGFzaDogdGhpcy5oYXNoLFxuXHQgICAgZW50cm9weTogYmtleSxcblx0ICAgIG5vbmNlOiBub25jZSxcblx0ICAgIHBlcnM6IG9wdGlvbnMucGVycyxcblx0ICAgIHBlcnNFbmM6IG9wdGlvbnMucGVyc0VuYyB8fCAndXRmOCcsXG5cdCAgfSk7XG5cblx0ICAvLyBOdW1iZXIgb2YgYnl0ZXMgdG8gZ2VuZXJhdGVcblx0ICB2YXIgbnMxID0gdGhpcy5uLnN1YihuZXcgYm4oMSkpO1xuXG5cdCAgZm9yICh2YXIgaXRlciA9IDA7IDsgaXRlcisrKSB7XG5cdCAgICB2YXIgayA9IG9wdGlvbnMuayA/XG5cdCAgICAgIG9wdGlvbnMuayhpdGVyKSA6XG5cdCAgICAgIG5ldyBibihkcmJnLmdlbmVyYXRlKHRoaXMubi5ieXRlTGVuZ3RoKCkpKTtcblx0ICAgIGsgPSB0aGlzLl90cnVuY2F0ZVRvTihrLCB0cnVlKTtcblx0ICAgIGlmIChrLmNtcG4oMSkgPD0gMCB8fCBrLmNtcChuczEpID49IDApXG5cdCAgICAgIGNvbnRpbnVlO1xuXG5cdCAgICB2YXIga3AgPSB0aGlzLmcubXVsKGspO1xuXHQgICAgaWYgKGtwLmlzSW5maW5pdHkoKSlcblx0ICAgICAgY29udGludWU7XG5cblx0ICAgIHZhciBrcFggPSBrcC5nZXRYKCk7XG5cdCAgICB2YXIgciA9IGtwWC51bW9kKHRoaXMubik7XG5cdCAgICBpZiAoci5jbXBuKDApID09PSAwKVxuXHQgICAgICBjb250aW51ZTtcblxuXHQgICAgdmFyIHMgPSBrLmludm0odGhpcy5uKS5tdWwoci5tdWwoa2V5LmdldFByaXZhdGUoKSkuaWFkZChtc2cpKTtcblx0ICAgIHMgPSBzLnVtb2QodGhpcy5uKTtcblx0ICAgIGlmIChzLmNtcG4oMCkgPT09IDApXG5cdCAgICAgIGNvbnRpbnVlO1xuXG5cdCAgICB2YXIgcmVjb3ZlcnlQYXJhbSA9IChrcC5nZXRZKCkuaXNPZGQoKSA/IDEgOiAwKSB8XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIChrcFguY21wKHIpICE9PSAwID8gMiA6IDApO1xuXG5cdCAgICAvLyBVc2UgY29tcGxlbWVudCBvZiBgc2AsIGlmIGl0IGlzID4gYG4gLyAyYFxuXHQgICAgaWYgKG9wdGlvbnMuY2Fub25pY2FsICYmIHMuY21wKHRoaXMubmgpID4gMCkge1xuXHQgICAgICBzID0gdGhpcy5uLnN1YihzKTtcblx0ICAgICAgcmVjb3ZlcnlQYXJhbSBePSAxO1xuXHQgICAgfVxuXG5cdCAgICByZXR1cm4gbmV3IHNpZ25hdHVyZSh7IHI6IHIsIHM6IHMsIHJlY292ZXJ5UGFyYW06IHJlY292ZXJ5UGFyYW0gfSk7XG5cdCAgfVxuXHR9O1xuXG5cdEVDLnByb3RvdHlwZS52ZXJpZnkgPSBmdW5jdGlvbiB2ZXJpZnkobXNnLCBzaWduYXR1cmUkMSwga2V5LCBlbmMpIHtcblx0ICBtc2cgPSB0aGlzLl90cnVuY2F0ZVRvTihuZXcgYm4obXNnLCAxNikpO1xuXHQgIGtleSA9IHRoaXMua2V5RnJvbVB1YmxpYyhrZXksIGVuYyk7XG5cdCAgc2lnbmF0dXJlJDEgPSBuZXcgc2lnbmF0dXJlKHNpZ25hdHVyZSQxLCAnaGV4Jyk7XG5cblx0ICAvLyBQZXJmb3JtIHByaW1pdGl2ZSB2YWx1ZXMgdmFsaWRhdGlvblxuXHQgIHZhciByID0gc2lnbmF0dXJlJDEucjtcblx0ICB2YXIgcyA9IHNpZ25hdHVyZSQxLnM7XG5cdCAgaWYgKHIuY21wbigxKSA8IDAgfHwgci5jbXAodGhpcy5uKSA+PSAwKVxuXHQgICAgcmV0dXJuIGZhbHNlO1xuXHQgIGlmIChzLmNtcG4oMSkgPCAwIHx8IHMuY21wKHRoaXMubikgPj0gMClcblx0ICAgIHJldHVybiBmYWxzZTtcblxuXHQgIC8vIFZhbGlkYXRlIHNpZ25hdHVyZVxuXHQgIHZhciBzaW52ID0gcy5pbnZtKHRoaXMubik7XG5cdCAgdmFyIHUxID0gc2ludi5tdWwobXNnKS51bW9kKHRoaXMubik7XG5cdCAgdmFyIHUyID0gc2ludi5tdWwocikudW1vZCh0aGlzLm4pO1xuXHQgIHZhciBwO1xuXG5cdCAgaWYgKCF0aGlzLmN1cnZlLl9tYXh3ZWxsVHJpY2spIHtcblx0ICAgIHAgPSB0aGlzLmcubXVsQWRkKHUxLCBrZXkuZ2V0UHVibGljKCksIHUyKTtcblx0ICAgIGlmIChwLmlzSW5maW5pdHkoKSlcblx0ICAgICAgcmV0dXJuIGZhbHNlO1xuXG5cdCAgICByZXR1cm4gcC5nZXRYKCkudW1vZCh0aGlzLm4pLmNtcChyKSA9PT0gMDtcblx0ICB9XG5cblx0ICAvLyBOT1RFOiBHcmVnIE1heHdlbGwncyB0cmljaywgaW5zcGlyZWQgYnk6XG5cdCAgLy8gaHR0cHM6Ly9naXQuaW8vdmFkM0tcblxuXHQgIHAgPSB0aGlzLmcuam11bEFkZCh1MSwga2V5LmdldFB1YmxpYygpLCB1Mik7XG5cdCAgaWYgKHAuaXNJbmZpbml0eSgpKVxuXHQgICAgcmV0dXJuIGZhbHNlO1xuXG5cdCAgLy8gQ29tcGFyZSBgcC54YCBvZiBKYWNvYmlhbiBwb2ludCB3aXRoIGByYCxcblx0ICAvLyB0aGlzIHdpbGwgZG8gYHAueCA9PSByICogcC56XjJgIGluc3RlYWQgb2YgbXVsdGlwbHlpbmcgYHAueGAgYnkgdGhlXG5cdCAgLy8gaW52ZXJzZSBvZiBgcC56XjJgXG5cdCAgcmV0dXJuIHAuZXFYVG9QKHIpO1xuXHR9O1xuXG5cdEVDLnByb3RvdHlwZS5yZWNvdmVyUHViS2V5ID0gZnVuY3Rpb24obXNnLCBzaWduYXR1cmUkMSwgaiwgZW5jKSB7XG5cdCAgYXNzZXJ0JDUoKDMgJiBqKSA9PT0gaiwgJ1RoZSByZWNvdmVyeSBwYXJhbSBpcyBtb3JlIHRoYW4gdHdvIGJpdHMnKTtcblx0ICBzaWduYXR1cmUkMSA9IG5ldyBzaWduYXR1cmUoc2lnbmF0dXJlJDEsIGVuYyk7XG5cblx0ICB2YXIgbiA9IHRoaXMubjtcblx0ICB2YXIgZSA9IG5ldyBibihtc2cpO1xuXHQgIHZhciByID0gc2lnbmF0dXJlJDEucjtcblx0ICB2YXIgcyA9IHNpZ25hdHVyZSQxLnM7XG5cblx0ICAvLyBBIHNldCBMU0Igc2lnbmlmaWVzIHRoYXQgdGhlIHktY29vcmRpbmF0ZSBpcyBvZGRcblx0ICB2YXIgaXNZT2RkID0gaiAmIDE7XG5cdCAgdmFyIGlzU2Vjb25kS2V5ID0gaiA+PiAxO1xuXHQgIGlmIChyLmNtcCh0aGlzLmN1cnZlLnAudW1vZCh0aGlzLmN1cnZlLm4pKSA+PSAwICYmIGlzU2Vjb25kS2V5KVxuXHQgICAgdGhyb3cgbmV3IEVycm9yKCdVbmFibGUgdG8gZmluZCBzZW5jb25kIGtleSBjYW5kaW5hdGUnKTtcblxuXHQgIC8vIDEuMS4gTGV0IHggPSByICsgam4uXG5cdCAgaWYgKGlzU2Vjb25kS2V5KVxuXHQgICAgciA9IHRoaXMuY3VydmUucG9pbnRGcm9tWChyLmFkZCh0aGlzLmN1cnZlLm4pLCBpc1lPZGQpO1xuXHQgIGVsc2Vcblx0ICAgIHIgPSB0aGlzLmN1cnZlLnBvaW50RnJvbVgociwgaXNZT2RkKTtcblxuXHQgIHZhciBySW52ID0gc2lnbmF0dXJlJDEuci5pbnZtKG4pO1xuXHQgIHZhciBzMSA9IG4uc3ViKGUpLm11bChySW52KS51bW9kKG4pO1xuXHQgIHZhciBzMiA9IHMubXVsKHJJbnYpLnVtb2Qobik7XG5cblx0ICAvLyAxLjYuMSBDb21wdXRlIFEgPSByXi0xIChzUiAtICBlRylcblx0ICAvLyAgICAgICAgICAgICAgIFEgPSByXi0xIChzUiArIC1lRylcblx0ICByZXR1cm4gdGhpcy5nLm11bEFkZChzMSwgciwgczIpO1xuXHR9O1xuXG5cdEVDLnByb3RvdHlwZS5nZXRLZXlSZWNvdmVyeVBhcmFtID0gZnVuY3Rpb24oZSwgc2lnbmF0dXJlJDEsIFEsIGVuYykge1xuXHQgIHNpZ25hdHVyZSQxID0gbmV3IHNpZ25hdHVyZShzaWduYXR1cmUkMSwgZW5jKTtcblx0ICBpZiAoc2lnbmF0dXJlJDEucmVjb3ZlcnlQYXJhbSAhPT0gbnVsbClcblx0ICAgIHJldHVybiBzaWduYXR1cmUkMS5yZWNvdmVyeVBhcmFtO1xuXG5cdCAgZm9yICh2YXIgaSA9IDA7IGkgPCA0OyBpKyspIHtcblx0ICAgIHZhciBRcHJpbWU7XG5cdCAgICB0cnkge1xuXHQgICAgICBRcHJpbWUgPSB0aGlzLnJlY292ZXJQdWJLZXkoZSwgc2lnbmF0dXJlJDEsIGkpO1xuXHQgICAgfSBjYXRjaCAoZSkge1xuXHQgICAgICBjb250aW51ZTtcblx0ICAgIH1cblxuXHQgICAgaWYgKFFwcmltZS5lcShRKSlcblx0ICAgICAgcmV0dXJuIGk7XG5cdCAgfVxuXHQgIHRocm93IG5ldyBFcnJvcignVW5hYmxlIHRvIGZpbmQgdmFsaWQgcmVjb3ZlcnkgZmFjdG9yJyk7XG5cdH07XG5cblx0dmFyIGVsbGlwdGljXzEgPSBjcmVhdGVDb21tb25qc01vZHVsZShmdW5jdGlvbiAobW9kdWxlLCBleHBvcnRzKSB7XG5cdCd1c2Ugc3RyaWN0JztcblxuXHR2YXIgZWxsaXB0aWMgPSBleHBvcnRzO1xuXG5cdGVsbGlwdGljLnZlcnNpb24gPSAvKlJpY01vbzpldGhlcnMqL3sgdmVyc2lvbjogXCI2LjUuNFwiIH0udmVyc2lvbjtcblx0ZWxsaXB0aWMudXRpbHMgPSB1dGlsc18xJDE7XG5cdGVsbGlwdGljLnJhbmQgPSAvKlJpY01vbzpldGhlcnM6cmVxdWlyZShicm9yYW5kKSovKGZ1bmN0aW9uKCkgeyB0aHJvdyBuZXcgRXJyb3IoJ3Vuc3VwcG9ydGVkJyk7IH0pO1xuXHRlbGxpcHRpYy5jdXJ2ZSA9IGN1cnZlXzE7XG5cdGVsbGlwdGljLmN1cnZlcyA9IGN1cnZlc18xO1xuXG5cdC8vIFByb3RvY29sc1xuXHRlbGxpcHRpYy5lYyA9IGVjO1xuXHRlbGxpcHRpYy5lZGRzYSA9IC8qUmljTW9vOmV0aGVyczpyZXF1aXJlKC4vZWxsaXB0aWMvZWRkc2EpKi8obnVsbCk7XG5cdH0pO1xuXG5cdHZhciBlbGxpcHRpYyA9IGNyZWF0ZUNvbW1vbmpzTW9kdWxlKGZ1bmN0aW9uIChtb2R1bGUsIGV4cG9ydHMpIHtcblx0XCJ1c2Ugc3RyaWN0XCI7XG5cdHZhciBfX2ltcG9ydERlZmF1bHQgPSAoY29tbW9uanNHbG9iYWwgJiYgY29tbW9uanNHbG9iYWwuX19pbXBvcnREZWZhdWx0KSB8fCBmdW5jdGlvbiAobW9kKSB7XG5cdCAgICByZXR1cm4gKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgPyBtb2QgOiB7IFwiZGVmYXVsdFwiOiBtb2QgfTtcblx0fTtcblx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuXHRleHBvcnRzLkVDID0gdm9pZCAwO1xuXHR2YXIgZWxsaXB0aWNfMSQxID0gX19pbXBvcnREZWZhdWx0KGVsbGlwdGljXzEpO1xuXHR2YXIgRUMgPSBlbGxpcHRpY18xJDEuZGVmYXVsdC5lYztcblx0ZXhwb3J0cy5FQyA9IEVDO1xuXG5cdH0pO1xuXG5cdHZhciBlbGxpcHRpYyQxID0gLypAX19QVVJFX18qL2dldERlZmF1bHRFeHBvcnRGcm9tQ2pzKGVsbGlwdGljKTtcblxuXHR2YXIgX3ZlcnNpb24kbSA9IGNyZWF0ZUNvbW1vbmpzTW9kdWxlKGZ1bmN0aW9uIChtb2R1bGUsIGV4cG9ydHMpIHtcblx0XCJ1c2Ugc3RyaWN0XCI7XG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcblx0ZXhwb3J0cy52ZXJzaW9uID0gdm9pZCAwO1xuXHRleHBvcnRzLnZlcnNpb24gPSBcInNpZ25pbmcta2V5LzUuNS4wXCI7XG5cblx0fSk7XG5cblx0dmFyIF92ZXJzaW9uJG4gPSAvKkBfX1BVUkVfXyovZ2V0RGVmYXVsdEV4cG9ydEZyb21DanMoX3ZlcnNpb24kbSk7XG5cblx0dmFyIGxpYiRkID0gY3JlYXRlQ29tbW9uanNNb2R1bGUoZnVuY3Rpb24gKG1vZHVsZSwgZXhwb3J0cykge1xuXHRcInVzZSBzdHJpY3RcIjtcblx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuXHRleHBvcnRzLmNvbXB1dGVQdWJsaWNLZXkgPSBleHBvcnRzLnJlY292ZXJQdWJsaWNLZXkgPSBleHBvcnRzLlNpZ25pbmdLZXkgPSB2b2lkIDA7XG5cblxuXG5cblxuXHR2YXIgbG9nZ2VyID0gbmV3IGxpYi5Mb2dnZXIoX3ZlcnNpb24kbS52ZXJzaW9uKTtcblx0dmFyIF9jdXJ2ZSA9IG51bGw7XG5cdGZ1bmN0aW9uIGdldEN1cnZlKCkge1xuXHQgICAgaWYgKCFfY3VydmUpIHtcblx0ICAgICAgICBfY3VydmUgPSBuZXcgZWxsaXB0aWMuRUMoXCJzZWNwMjU2azFcIik7XG5cdCAgICB9XG5cdCAgICByZXR1cm4gX2N1cnZlO1xuXHR9XG5cdHZhciBTaWduaW5nS2V5ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuXHQgICAgZnVuY3Rpb24gU2lnbmluZ0tleShwcml2YXRlS2V5KSB7XG5cdCAgICAgICAgKDAsIGxpYiQzLmRlZmluZVJlYWRPbmx5KSh0aGlzLCBcImN1cnZlXCIsIFwic2VjcDI1NmsxXCIpO1xuXHQgICAgICAgICgwLCBsaWIkMy5kZWZpbmVSZWFkT25seSkodGhpcywgXCJwcml2YXRlS2V5XCIsICgwLCBsaWIkMS5oZXhsaWZ5KShwcml2YXRlS2V5KSk7XG5cdCAgICAgICAgdmFyIGtleVBhaXIgPSBnZXRDdXJ2ZSgpLmtleUZyb21Qcml2YXRlKCgwLCBsaWIkMS5hcnJheWlmeSkodGhpcy5wcml2YXRlS2V5KSk7XG5cdCAgICAgICAgKDAsIGxpYiQzLmRlZmluZVJlYWRPbmx5KSh0aGlzLCBcInB1YmxpY0tleVwiLCBcIjB4XCIgKyBrZXlQYWlyLmdldFB1YmxpYyhmYWxzZSwgXCJoZXhcIikpO1xuXHQgICAgICAgICgwLCBsaWIkMy5kZWZpbmVSZWFkT25seSkodGhpcywgXCJjb21wcmVzc2VkUHVibGljS2V5XCIsIFwiMHhcIiArIGtleVBhaXIuZ2V0UHVibGljKHRydWUsIFwiaGV4XCIpKTtcblx0ICAgICAgICAoMCwgbGliJDMuZGVmaW5lUmVhZE9ubHkpKHRoaXMsIFwiX2lzU2lnbmluZ0tleVwiLCB0cnVlKTtcblx0ICAgIH1cblx0ICAgIFNpZ25pbmdLZXkucHJvdG90eXBlLl9hZGRQb2ludCA9IGZ1bmN0aW9uIChvdGhlcikge1xuXHQgICAgICAgIHZhciBwMCA9IGdldEN1cnZlKCkua2V5RnJvbVB1YmxpYygoMCwgbGliJDEuYXJyYXlpZnkpKHRoaXMucHVibGljS2V5KSk7XG5cdCAgICAgICAgdmFyIHAxID0gZ2V0Q3VydmUoKS5rZXlGcm9tUHVibGljKCgwLCBsaWIkMS5hcnJheWlmeSkob3RoZXIpKTtcblx0ICAgICAgICByZXR1cm4gXCIweFwiICsgcDAucHViLmFkZChwMS5wdWIpLmVuY29kZUNvbXByZXNzZWQoXCJoZXhcIik7XG5cdCAgICB9O1xuXHQgICAgU2lnbmluZ0tleS5wcm90b3R5cGUuc2lnbkRpZ2VzdCA9IGZ1bmN0aW9uIChkaWdlc3QpIHtcblx0ICAgICAgICB2YXIga2V5UGFpciA9IGdldEN1cnZlKCkua2V5RnJvbVByaXZhdGUoKDAsIGxpYiQxLmFycmF5aWZ5KSh0aGlzLnByaXZhdGVLZXkpKTtcblx0ICAgICAgICB2YXIgZGlnZXN0Qnl0ZXMgPSAoMCwgbGliJDEuYXJyYXlpZnkpKGRpZ2VzdCk7XG5cdCAgICAgICAgaWYgKGRpZ2VzdEJ5dGVzLmxlbmd0aCAhPT0gMzIpIHtcblx0ICAgICAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcImJhZCBkaWdlc3QgbGVuZ3RoXCIsIFwiZGlnZXN0XCIsIGRpZ2VzdCk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHZhciBzaWduYXR1cmUgPSBrZXlQYWlyLnNpZ24oZGlnZXN0Qnl0ZXMsIHsgY2Fub25pY2FsOiB0cnVlIH0pO1xuXHQgICAgICAgIHJldHVybiAoMCwgbGliJDEuc3BsaXRTaWduYXR1cmUpKHtcblx0ICAgICAgICAgICAgcmVjb3ZlcnlQYXJhbTogc2lnbmF0dXJlLnJlY292ZXJ5UGFyYW0sXG5cdCAgICAgICAgICAgIHI6ICgwLCBsaWIkMS5oZXhaZXJvUGFkKShcIjB4XCIgKyBzaWduYXR1cmUuci50b1N0cmluZygxNiksIDMyKSxcblx0ICAgICAgICAgICAgczogKDAsIGxpYiQxLmhleFplcm9QYWQpKFwiMHhcIiArIHNpZ25hdHVyZS5zLnRvU3RyaW5nKDE2KSwgMzIpLFxuXHQgICAgICAgIH0pO1xuXHQgICAgfTtcblx0ICAgIFNpZ25pbmdLZXkucHJvdG90eXBlLmNvbXB1dGVTaGFyZWRTZWNyZXQgPSBmdW5jdGlvbiAob3RoZXJLZXkpIHtcblx0ICAgICAgICB2YXIga2V5UGFpciA9IGdldEN1cnZlKCkua2V5RnJvbVByaXZhdGUoKDAsIGxpYiQxLmFycmF5aWZ5KSh0aGlzLnByaXZhdGVLZXkpKTtcblx0ICAgICAgICB2YXIgb3RoZXJLZXlQYWlyID0gZ2V0Q3VydmUoKS5rZXlGcm9tUHVibGljKCgwLCBsaWIkMS5hcnJheWlmeSkoY29tcHV0ZVB1YmxpY0tleShvdGhlcktleSkpKTtcblx0ICAgICAgICByZXR1cm4gKDAsIGxpYiQxLmhleFplcm9QYWQpKFwiMHhcIiArIGtleVBhaXIuZGVyaXZlKG90aGVyS2V5UGFpci5nZXRQdWJsaWMoKSkudG9TdHJpbmcoMTYpLCAzMik7XG5cdCAgICB9O1xuXHQgICAgU2lnbmluZ0tleS5pc1NpZ25pbmdLZXkgPSBmdW5jdGlvbiAodmFsdWUpIHtcblx0ICAgICAgICByZXR1cm4gISEodmFsdWUgJiYgdmFsdWUuX2lzU2lnbmluZ0tleSk7XG5cdCAgICB9O1xuXHQgICAgcmV0dXJuIFNpZ25pbmdLZXk7XG5cdH0oKSk7XG5cdGV4cG9ydHMuU2lnbmluZ0tleSA9IFNpZ25pbmdLZXk7XG5cdGZ1bmN0aW9uIHJlY292ZXJQdWJsaWNLZXkoZGlnZXN0LCBzaWduYXR1cmUpIHtcblx0ICAgIHZhciBzaWcgPSAoMCwgbGliJDEuc3BsaXRTaWduYXR1cmUpKHNpZ25hdHVyZSk7XG5cdCAgICB2YXIgcnMgPSB7IHI6ICgwLCBsaWIkMS5hcnJheWlmeSkoc2lnLnIpLCBzOiAoMCwgbGliJDEuYXJyYXlpZnkpKHNpZy5zKSB9O1xuXHQgICAgcmV0dXJuIFwiMHhcIiArIGdldEN1cnZlKCkucmVjb3ZlclB1YktleSgoMCwgbGliJDEuYXJyYXlpZnkpKGRpZ2VzdCksIHJzLCBzaWcucmVjb3ZlcnlQYXJhbSkuZW5jb2RlKFwiaGV4XCIsIGZhbHNlKTtcblx0fVxuXHRleHBvcnRzLnJlY292ZXJQdWJsaWNLZXkgPSByZWNvdmVyUHVibGljS2V5O1xuXHRmdW5jdGlvbiBjb21wdXRlUHVibGljS2V5KGtleSwgY29tcHJlc3NlZCkge1xuXHQgICAgdmFyIGJ5dGVzID0gKDAsIGxpYiQxLmFycmF5aWZ5KShrZXkpO1xuXHQgICAgaWYgKGJ5dGVzLmxlbmd0aCA9PT0gMzIpIHtcblx0ICAgICAgICB2YXIgc2lnbmluZ0tleSA9IG5ldyBTaWduaW5nS2V5KGJ5dGVzKTtcblx0ICAgICAgICBpZiAoY29tcHJlc3NlZCkge1xuXHQgICAgICAgICAgICByZXR1cm4gXCIweFwiICsgZ2V0Q3VydmUoKS5rZXlGcm9tUHJpdmF0ZShieXRlcykuZ2V0UHVibGljKHRydWUsIFwiaGV4XCIpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICByZXR1cm4gc2lnbmluZ0tleS5wdWJsaWNLZXk7XG5cdCAgICB9XG5cdCAgICBlbHNlIGlmIChieXRlcy5sZW5ndGggPT09IDMzKSB7XG5cdCAgICAgICAgaWYgKGNvbXByZXNzZWQpIHtcblx0ICAgICAgICAgICAgcmV0dXJuICgwLCBsaWIkMS5oZXhsaWZ5KShieXRlcyk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHJldHVybiBcIjB4XCIgKyBnZXRDdXJ2ZSgpLmtleUZyb21QdWJsaWMoYnl0ZXMpLmdldFB1YmxpYyhmYWxzZSwgXCJoZXhcIik7XG5cdCAgICB9XG5cdCAgICBlbHNlIGlmIChieXRlcy5sZW5ndGggPT09IDY1KSB7XG5cdCAgICAgICAgaWYgKCFjb21wcmVzc2VkKSB7XG5cdCAgICAgICAgICAgIHJldHVybiAoMCwgbGliJDEuaGV4bGlmeSkoYnl0ZXMpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICByZXR1cm4gXCIweFwiICsgZ2V0Q3VydmUoKS5rZXlGcm9tUHVibGljKGJ5dGVzKS5nZXRQdWJsaWModHJ1ZSwgXCJoZXhcIik7XG5cdCAgICB9XG5cdCAgICByZXR1cm4gbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcImludmFsaWQgcHVibGljIG9yIHByaXZhdGUga2V5XCIsIFwia2V5XCIsIFwiW1JFREFDVEVEXVwiKTtcblx0fVxuXHRleHBvcnRzLmNvbXB1dGVQdWJsaWNLZXkgPSBjb21wdXRlUHVibGljS2V5O1xuXG5cdH0pO1xuXG5cdHZhciBpbmRleCRkID0gLypAX19QVVJFX18qL2dldERlZmF1bHRFeHBvcnRGcm9tQ2pzKGxpYiRkKTtcblxuXHR2YXIgX3ZlcnNpb24kbyA9IGNyZWF0ZUNvbW1vbmpzTW9kdWxlKGZ1bmN0aW9uIChtb2R1bGUsIGV4cG9ydHMpIHtcblx0XCJ1c2Ugc3RyaWN0XCI7XG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcblx0ZXhwb3J0cy52ZXJzaW9uID0gdm9pZCAwO1xuXHRleHBvcnRzLnZlcnNpb24gPSBcInRyYW5zYWN0aW9ucy81LjUuMFwiO1xuXG5cdH0pO1xuXG5cdHZhciBfdmVyc2lvbiRwID0gLypAX19QVVJFX18qL2dldERlZmF1bHRFeHBvcnRGcm9tQ2pzKF92ZXJzaW9uJG8pO1xuXG5cdHZhciBsaWIkZSA9IGNyZWF0ZUNvbW1vbmpzTW9kdWxlKGZ1bmN0aW9uIChtb2R1bGUsIGV4cG9ydHMpIHtcblx0XCJ1c2Ugc3RyaWN0XCI7XG5cdHZhciBfX2NyZWF0ZUJpbmRpbmcgPSAoY29tbW9uanNHbG9iYWwgJiYgY29tbW9uanNHbG9iYWwuX19jcmVhdGVCaW5kaW5nKSB8fCAoT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuXHQgICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcblx0ICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBrMiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gbVtrXTsgfSB9KTtcblx0fSkgOiAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcblx0ICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG5cdCAgICBvW2syXSA9IG1ba107XG5cdH0pKTtcblx0dmFyIF9fc2V0TW9kdWxlRGVmYXVsdCA9IChjb21tb25qc0dsb2JhbCAmJiBjb21tb25qc0dsb2JhbC5fX3NldE1vZHVsZURlZmF1bHQpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIHYpIHtcblx0ICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBcImRlZmF1bHRcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCB2YWx1ZTogdiB9KTtcblx0fSkgOiBmdW5jdGlvbihvLCB2KSB7XG5cdCAgICBvW1wiZGVmYXVsdFwiXSA9IHY7XG5cdH0pO1xuXHR2YXIgX19pbXBvcnRTdGFyID0gKGNvbW1vbmpzR2xvYmFsICYmIGNvbW1vbmpzR2xvYmFsLl9faW1wb3J0U3RhcikgfHwgZnVuY3Rpb24gKG1vZCkge1xuXHQgICAgaWYgKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgcmV0dXJuIG1vZDtcblx0ICAgIHZhciByZXN1bHQgPSB7fTtcblx0ICAgIGlmIChtb2QgIT0gbnVsbCkgZm9yICh2YXIgayBpbiBtb2QpIGlmIChrICE9PSBcImRlZmF1bHRcIiAmJiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwobW9kLCBrKSkgX19jcmVhdGVCaW5kaW5nKHJlc3VsdCwgbW9kLCBrKTtcblx0ICAgIF9fc2V0TW9kdWxlRGVmYXVsdChyZXN1bHQsIG1vZCk7XG5cdCAgICByZXR1cm4gcmVzdWx0O1xuXHR9O1xuXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5cdGV4cG9ydHMucGFyc2UgPSBleHBvcnRzLnNlcmlhbGl6ZSA9IGV4cG9ydHMuYWNjZXNzTGlzdGlmeSA9IGV4cG9ydHMucmVjb3ZlckFkZHJlc3MgPSBleHBvcnRzLmNvbXB1dGVBZGRyZXNzID0gZXhwb3J0cy5UcmFuc2FjdGlvblR5cGVzID0gdm9pZCAwO1xuXG5cblxuXG5cblxuXHR2YXIgUkxQID0gX19pbXBvcnRTdGFyKGxpYiQ1KTtcblxuXG5cblx0dmFyIGxvZ2dlciA9IG5ldyBsaWIuTG9nZ2VyKF92ZXJzaW9uJG8udmVyc2lvbik7XG5cdHZhciBUcmFuc2FjdGlvblR5cGVzO1xuXHQoZnVuY3Rpb24gKFRyYW5zYWN0aW9uVHlwZXMpIHtcblx0ICAgIFRyYW5zYWN0aW9uVHlwZXNbVHJhbnNhY3Rpb25UeXBlc1tcImxlZ2FjeVwiXSA9IDBdID0gXCJsZWdhY3lcIjtcblx0ICAgIFRyYW5zYWN0aW9uVHlwZXNbVHJhbnNhY3Rpb25UeXBlc1tcImVpcDI5MzBcIl0gPSAxXSA9IFwiZWlwMjkzMFwiO1xuXHQgICAgVHJhbnNhY3Rpb25UeXBlc1tUcmFuc2FjdGlvblR5cGVzW1wiZWlwMTU1OVwiXSA9IDJdID0gXCJlaXAxNTU5XCI7XG5cdH0pKFRyYW5zYWN0aW9uVHlwZXMgPSBleHBvcnRzLlRyYW5zYWN0aW9uVHlwZXMgfHwgKGV4cG9ydHMuVHJhbnNhY3Rpb25UeXBlcyA9IHt9KSk7XG5cdDtcblx0Ly8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXHRmdW5jdGlvbiBoYW5kbGVBZGRyZXNzKHZhbHVlKSB7XG5cdCAgICBpZiAodmFsdWUgPT09IFwiMHhcIikge1xuXHQgICAgICAgIHJldHVybiBudWxsO1xuXHQgICAgfVxuXHQgICAgcmV0dXJuICgwLCBsaWIkNi5nZXRBZGRyZXNzKSh2YWx1ZSk7XG5cdH1cblx0ZnVuY3Rpb24gaGFuZGxlTnVtYmVyKHZhbHVlKSB7XG5cdCAgICBpZiAodmFsdWUgPT09IFwiMHhcIikge1xuXHQgICAgICAgIHJldHVybiBsaWIkNy5aZXJvO1xuXHQgICAgfVxuXHQgICAgcmV0dXJuIGxpYiQyLkJpZ051bWJlci5mcm9tKHZhbHVlKTtcblx0fVxuXHQvLyBMZWdhY3kgVHJhbnNhY3Rpb24gRmllbGRzXG5cdHZhciB0cmFuc2FjdGlvbkZpZWxkcyA9IFtcblx0ICAgIHsgbmFtZTogXCJub25jZVwiLCBtYXhMZW5ndGg6IDMyLCBudW1lcmljOiB0cnVlIH0sXG5cdCAgICB7IG5hbWU6IFwiZ2FzUHJpY2VcIiwgbWF4TGVuZ3RoOiAzMiwgbnVtZXJpYzogdHJ1ZSB9LFxuXHQgICAgeyBuYW1lOiBcImdhc0xpbWl0XCIsIG1heExlbmd0aDogMzIsIG51bWVyaWM6IHRydWUgfSxcblx0ICAgIHsgbmFtZTogXCJ0b1wiLCBsZW5ndGg6IDIwIH0sXG5cdCAgICB7IG5hbWU6IFwidmFsdWVcIiwgbWF4TGVuZ3RoOiAzMiwgbnVtZXJpYzogdHJ1ZSB9LFxuXHQgICAgeyBuYW1lOiBcImRhdGFcIiB9LFxuXHRdO1xuXHR2YXIgYWxsb3dlZFRyYW5zYWN0aW9uS2V5cyA9IHtcblx0ICAgIGNoYWluSWQ6IHRydWUsIGRhdGE6IHRydWUsIGdhc0xpbWl0OiB0cnVlLCBnYXNQcmljZTogdHJ1ZSwgbm9uY2U6IHRydWUsIHRvOiB0cnVlLCB0eXBlOiB0cnVlLCB2YWx1ZTogdHJ1ZVxuXHR9O1xuXHRmdW5jdGlvbiBjb21wdXRlQWRkcmVzcyhrZXkpIHtcblx0ICAgIHZhciBwdWJsaWNLZXkgPSAoMCwgbGliJGQuY29tcHV0ZVB1YmxpY0tleSkoa2V5KTtcblx0ICAgIHJldHVybiAoMCwgbGliJDYuZ2V0QWRkcmVzcykoKDAsIGxpYiQxLmhleERhdGFTbGljZSkoKDAsIGxpYiQ0LmtlY2NhazI1NikoKDAsIGxpYiQxLmhleERhdGFTbGljZSkocHVibGljS2V5LCAxKSksIDEyKSk7XG5cdH1cblx0ZXhwb3J0cy5jb21wdXRlQWRkcmVzcyA9IGNvbXB1dGVBZGRyZXNzO1xuXHRmdW5jdGlvbiByZWNvdmVyQWRkcmVzcyhkaWdlc3QsIHNpZ25hdHVyZSkge1xuXHQgICAgcmV0dXJuIGNvbXB1dGVBZGRyZXNzKCgwLCBsaWIkZC5yZWNvdmVyUHVibGljS2V5KSgoMCwgbGliJDEuYXJyYXlpZnkpKGRpZ2VzdCksIHNpZ25hdHVyZSkpO1xuXHR9XG5cdGV4cG9ydHMucmVjb3ZlckFkZHJlc3MgPSByZWNvdmVyQWRkcmVzcztcblx0ZnVuY3Rpb24gZm9ybWF0TnVtYmVyKHZhbHVlLCBuYW1lKSB7XG5cdCAgICB2YXIgcmVzdWx0ID0gKDAsIGxpYiQxLnN0cmlwWmVyb3MpKGxpYiQyLkJpZ051bWJlci5mcm9tKHZhbHVlKS50b0hleFN0cmluZygpKTtcblx0ICAgIGlmIChyZXN1bHQubGVuZ3RoID4gMzIpIHtcblx0ICAgICAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwiaW52YWxpZCBsZW5ndGggZm9yIFwiICsgbmFtZSwgKFwidHJhbnNhY3Rpb246XCIgKyBuYW1lKSwgdmFsdWUpO1xuXHQgICAgfVxuXHQgICAgcmV0dXJuIHJlc3VsdDtcblx0fVxuXHRmdW5jdGlvbiBhY2Nlc3NTZXRpZnkoYWRkciwgc3RvcmFnZUtleXMpIHtcblx0ICAgIHJldHVybiB7XG5cdCAgICAgICAgYWRkcmVzczogKDAsIGxpYiQ2LmdldEFkZHJlc3MpKGFkZHIpLFxuXHQgICAgICAgIHN0b3JhZ2VLZXlzOiAoc3RvcmFnZUtleXMgfHwgW10pLm1hcChmdW5jdGlvbiAoc3RvcmFnZUtleSwgaW5kZXgpIHtcblx0ICAgICAgICAgICAgaWYgKCgwLCBsaWIkMS5oZXhEYXRhTGVuZ3RoKShzdG9yYWdlS2V5KSAhPT0gMzIpIHtcblx0ICAgICAgICAgICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJpbnZhbGlkIGFjY2VzcyBsaXN0IHN0b3JhZ2VLZXlcIiwgXCJhY2Nlc3NMaXN0W1wiICsgYWRkciArIFwiOlwiICsgaW5kZXggKyBcIl1cIiwgc3RvcmFnZUtleSk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgcmV0dXJuIHN0b3JhZ2VLZXkudG9Mb3dlckNhc2UoKTtcblx0ICAgICAgICB9KVxuXHQgICAgfTtcblx0fVxuXHRmdW5jdGlvbiBhY2Nlc3NMaXN0aWZ5KHZhbHVlKSB7XG5cdCAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcblx0ICAgICAgICByZXR1cm4gdmFsdWUubWFwKGZ1bmN0aW9uIChzZXQsIGluZGV4KSB7XG5cdCAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KHNldCkpIHtcblx0ICAgICAgICAgICAgICAgIGlmIChzZXQubGVuZ3RoID4gMikge1xuXHQgICAgICAgICAgICAgICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJhY2Nlc3MgbGlzdCBleHBlY3RlZCB0byBiZSBbIGFkZHJlc3MsIHN0b3JhZ2VLZXlzW10gXVwiLCBcInZhbHVlW1wiICsgaW5kZXggKyBcIl1cIiwgc2V0KTtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgIHJldHVybiBhY2Nlc3NTZXRpZnkoc2V0WzBdLCBzZXRbMV0pO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIHJldHVybiBhY2Nlc3NTZXRpZnkoc2V0LmFkZHJlc3MsIHNldC5zdG9yYWdlS2V5cyk7XG5cdCAgICAgICAgfSk7XG5cdCAgICB9XG5cdCAgICB2YXIgcmVzdWx0ID0gT2JqZWN0LmtleXModmFsdWUpLm1hcChmdW5jdGlvbiAoYWRkcikge1xuXHQgICAgICAgIHZhciBzdG9yYWdlS2V5cyA9IHZhbHVlW2FkZHJdLnJlZHVjZShmdW5jdGlvbiAoYWNjdW0sIHN0b3JhZ2VLZXkpIHtcblx0ICAgICAgICAgICAgYWNjdW1bc3RvcmFnZUtleV0gPSB0cnVlO1xuXHQgICAgICAgICAgICByZXR1cm4gYWNjdW07XG5cdCAgICAgICAgfSwge30pO1xuXHQgICAgICAgIHJldHVybiBhY2Nlc3NTZXRpZnkoYWRkciwgT2JqZWN0LmtleXMoc3RvcmFnZUtleXMpLnNvcnQoKSk7XG5cdCAgICB9KTtcblx0ICAgIHJlc3VsdC5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7IHJldHVybiAoYS5hZGRyZXNzLmxvY2FsZUNvbXBhcmUoYi5hZGRyZXNzKSk7IH0pO1xuXHQgICAgcmV0dXJuIHJlc3VsdDtcblx0fVxuXHRleHBvcnRzLmFjY2Vzc0xpc3RpZnkgPSBhY2Nlc3NMaXN0aWZ5O1xuXHRmdW5jdGlvbiBmb3JtYXRBY2Nlc3NMaXN0KHZhbHVlKSB7XG5cdCAgICByZXR1cm4gYWNjZXNzTGlzdGlmeSh2YWx1ZSkubWFwKGZ1bmN0aW9uIChzZXQpIHsgcmV0dXJuIFtzZXQuYWRkcmVzcywgc2V0LnN0b3JhZ2VLZXlzXTsgfSk7XG5cdH1cblx0ZnVuY3Rpb24gX3NlcmlhbGl6ZUVpcDE1NTkodHJhbnNhY3Rpb24sIHNpZ25hdHVyZSkge1xuXHQgICAgLy8gSWYgdGhlcmUgaXMgYW4gZXhwbGljaXQgZ2FzUHJpY2UsIG1ha2Ugc3VyZSBpdCBtYXRjaGVzIHRoZVxuXHQgICAgLy8gRUlQLTE1NTkgZmVlczsgb3RoZXJ3aXNlIHRoZXkgbWF5IG5vdCB1bmRlcnN0YW5kIHdoYXQgdGhleVxuXHQgICAgLy8gdGhpbmsgdGhleSBhcmUgc2V0dGluZyBpbiB0ZXJtcyBvZiBmZWUuXG5cdCAgICBpZiAodHJhbnNhY3Rpb24uZ2FzUHJpY2UgIT0gbnVsbCkge1xuXHQgICAgICAgIHZhciBnYXNQcmljZSA9IGxpYiQyLkJpZ051bWJlci5mcm9tKHRyYW5zYWN0aW9uLmdhc1ByaWNlKTtcblx0ICAgICAgICB2YXIgbWF4RmVlUGVyR2FzID0gbGliJDIuQmlnTnVtYmVyLmZyb20odHJhbnNhY3Rpb24ubWF4RmVlUGVyR2FzIHx8IDApO1xuXHQgICAgICAgIGlmICghZ2FzUHJpY2UuZXEobWF4RmVlUGVyR2FzKSkge1xuXHQgICAgICAgICAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwibWlzbWF0Y2ggRUlQLTE1NTkgZ2FzUHJpY2UgIT0gbWF4RmVlUGVyR2FzXCIsIFwidHhcIiwge1xuXHQgICAgICAgICAgICAgICAgZ2FzUHJpY2U6IGdhc1ByaWNlLFxuXHQgICAgICAgICAgICAgICAgbWF4RmVlUGVyR2FzOiBtYXhGZWVQZXJHYXNcblx0ICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgfVxuXHQgICAgfVxuXHQgICAgdmFyIGZpZWxkcyA9IFtcblx0ICAgICAgICBmb3JtYXROdW1iZXIodHJhbnNhY3Rpb24uY2hhaW5JZCB8fCAwLCBcImNoYWluSWRcIiksXG5cdCAgICAgICAgZm9ybWF0TnVtYmVyKHRyYW5zYWN0aW9uLm5vbmNlIHx8IDAsIFwibm9uY2VcIiksXG5cdCAgICAgICAgZm9ybWF0TnVtYmVyKHRyYW5zYWN0aW9uLm1heFByaW9yaXR5RmVlUGVyR2FzIHx8IDAsIFwibWF4UHJpb3JpdHlGZWVQZXJHYXNcIiksXG5cdCAgICAgICAgZm9ybWF0TnVtYmVyKHRyYW5zYWN0aW9uLm1heEZlZVBlckdhcyB8fCAwLCBcIm1heEZlZVBlckdhc1wiKSxcblx0ICAgICAgICBmb3JtYXROdW1iZXIodHJhbnNhY3Rpb24uZ2FzTGltaXQgfHwgMCwgXCJnYXNMaW1pdFwiKSxcblx0ICAgICAgICAoKHRyYW5zYWN0aW9uLnRvICE9IG51bGwpID8gKDAsIGxpYiQ2LmdldEFkZHJlc3MpKHRyYW5zYWN0aW9uLnRvKSA6IFwiMHhcIiksXG5cdCAgICAgICAgZm9ybWF0TnVtYmVyKHRyYW5zYWN0aW9uLnZhbHVlIHx8IDAsIFwidmFsdWVcIiksXG5cdCAgICAgICAgKHRyYW5zYWN0aW9uLmRhdGEgfHwgXCIweFwiKSxcblx0ICAgICAgICAoZm9ybWF0QWNjZXNzTGlzdCh0cmFuc2FjdGlvbi5hY2Nlc3NMaXN0IHx8IFtdKSlcblx0ICAgIF07XG5cdCAgICBpZiAoc2lnbmF0dXJlKSB7XG5cdCAgICAgICAgdmFyIHNpZyA9ICgwLCBsaWIkMS5zcGxpdFNpZ25hdHVyZSkoc2lnbmF0dXJlKTtcblx0ICAgICAgICBmaWVsZHMucHVzaChmb3JtYXROdW1iZXIoc2lnLnJlY292ZXJ5UGFyYW0sIFwicmVjb3ZlcnlQYXJhbVwiKSk7XG5cdCAgICAgICAgZmllbGRzLnB1c2goKDAsIGxpYiQxLnN0cmlwWmVyb3MpKHNpZy5yKSk7XG5cdCAgICAgICAgZmllbGRzLnB1c2goKDAsIGxpYiQxLnN0cmlwWmVyb3MpKHNpZy5zKSk7XG5cdCAgICB9XG5cdCAgICByZXR1cm4gKDAsIGxpYiQxLmhleENvbmNhdCkoW1wiMHgwMlwiLCBSTFAuZW5jb2RlKGZpZWxkcyldKTtcblx0fVxuXHRmdW5jdGlvbiBfc2VyaWFsaXplRWlwMjkzMCh0cmFuc2FjdGlvbiwgc2lnbmF0dXJlKSB7XG5cdCAgICB2YXIgZmllbGRzID0gW1xuXHQgICAgICAgIGZvcm1hdE51bWJlcih0cmFuc2FjdGlvbi5jaGFpbklkIHx8IDAsIFwiY2hhaW5JZFwiKSxcblx0ICAgICAgICBmb3JtYXROdW1iZXIodHJhbnNhY3Rpb24ubm9uY2UgfHwgMCwgXCJub25jZVwiKSxcblx0ICAgICAgICBmb3JtYXROdW1iZXIodHJhbnNhY3Rpb24uZ2FzUHJpY2UgfHwgMCwgXCJnYXNQcmljZVwiKSxcblx0ICAgICAgICBmb3JtYXROdW1iZXIodHJhbnNhY3Rpb24uZ2FzTGltaXQgfHwgMCwgXCJnYXNMaW1pdFwiKSxcblx0ICAgICAgICAoKHRyYW5zYWN0aW9uLnRvICE9IG51bGwpID8gKDAsIGxpYiQ2LmdldEFkZHJlc3MpKHRyYW5zYWN0aW9uLnRvKSA6IFwiMHhcIiksXG5cdCAgICAgICAgZm9ybWF0TnVtYmVyKHRyYW5zYWN0aW9uLnZhbHVlIHx8IDAsIFwidmFsdWVcIiksXG5cdCAgICAgICAgKHRyYW5zYWN0aW9uLmRhdGEgfHwgXCIweFwiKSxcblx0ICAgICAgICAoZm9ybWF0QWNjZXNzTGlzdCh0cmFuc2FjdGlvbi5hY2Nlc3NMaXN0IHx8IFtdKSlcblx0ICAgIF07XG5cdCAgICBpZiAoc2lnbmF0dXJlKSB7XG5cdCAgICAgICAgdmFyIHNpZyA9ICgwLCBsaWIkMS5zcGxpdFNpZ25hdHVyZSkoc2lnbmF0dXJlKTtcblx0ICAgICAgICBmaWVsZHMucHVzaChmb3JtYXROdW1iZXIoc2lnLnJlY292ZXJ5UGFyYW0sIFwicmVjb3ZlcnlQYXJhbVwiKSk7XG5cdCAgICAgICAgZmllbGRzLnB1c2goKDAsIGxpYiQxLnN0cmlwWmVyb3MpKHNpZy5yKSk7XG5cdCAgICAgICAgZmllbGRzLnB1c2goKDAsIGxpYiQxLnN0cmlwWmVyb3MpKHNpZy5zKSk7XG5cdCAgICB9XG5cdCAgICByZXR1cm4gKDAsIGxpYiQxLmhleENvbmNhdCkoW1wiMHgwMVwiLCBSTFAuZW5jb2RlKGZpZWxkcyldKTtcblx0fVxuXHQvLyBMZWdhY3kgVHJhbnNhY3Rpb25zIGFuZCBFSVAtMTU1XG5cdGZ1bmN0aW9uIF9zZXJpYWxpemUodHJhbnNhY3Rpb24sIHNpZ25hdHVyZSkge1xuXHQgICAgKDAsIGxpYiQzLmNoZWNrUHJvcGVydGllcykodHJhbnNhY3Rpb24sIGFsbG93ZWRUcmFuc2FjdGlvbktleXMpO1xuXHQgICAgdmFyIHJhdyA9IFtdO1xuXHQgICAgdHJhbnNhY3Rpb25GaWVsZHMuZm9yRWFjaChmdW5jdGlvbiAoZmllbGRJbmZvKSB7XG5cdCAgICAgICAgdmFyIHZhbHVlID0gdHJhbnNhY3Rpb25bZmllbGRJbmZvLm5hbWVdIHx8IChbXSk7XG5cdCAgICAgICAgdmFyIG9wdGlvbnMgPSB7fTtcblx0ICAgICAgICBpZiAoZmllbGRJbmZvLm51bWVyaWMpIHtcblx0ICAgICAgICAgICAgb3B0aW9ucy5oZXhQYWQgPSBcImxlZnRcIjtcblx0ICAgICAgICB9XG5cdCAgICAgICAgdmFsdWUgPSAoMCwgbGliJDEuYXJyYXlpZnkpKCgwLCBsaWIkMS5oZXhsaWZ5KSh2YWx1ZSwgb3B0aW9ucykpO1xuXHQgICAgICAgIC8vIEZpeGVkLXdpZHRoIGZpZWxkXG5cdCAgICAgICAgaWYgKGZpZWxkSW5mby5sZW5ndGggJiYgdmFsdWUubGVuZ3RoICE9PSBmaWVsZEluZm8ubGVuZ3RoICYmIHZhbHVlLmxlbmd0aCA+IDApIHtcblx0ICAgICAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcImludmFsaWQgbGVuZ3RoIGZvciBcIiArIGZpZWxkSW5mby5uYW1lLCAoXCJ0cmFuc2FjdGlvbjpcIiArIGZpZWxkSW5mby5uYW1lKSwgdmFsdWUpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICAvLyBWYXJpYWJsZS13aWR0aCAod2l0aCBhIG1heGltdW0pXG5cdCAgICAgICAgaWYgKGZpZWxkSW5mby5tYXhMZW5ndGgpIHtcblx0ICAgICAgICAgICAgdmFsdWUgPSAoMCwgbGliJDEuc3RyaXBaZXJvcykodmFsdWUpO1xuXHQgICAgICAgICAgICBpZiAodmFsdWUubGVuZ3RoID4gZmllbGRJbmZvLm1heExlbmd0aCkge1xuXHQgICAgICAgICAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcImludmFsaWQgbGVuZ3RoIGZvciBcIiArIGZpZWxkSW5mby5uYW1lLCAoXCJ0cmFuc2FjdGlvbjpcIiArIGZpZWxkSW5mby5uYW1lKSwgdmFsdWUpO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHJhdy5wdXNoKCgwLCBsaWIkMS5oZXhsaWZ5KSh2YWx1ZSkpO1xuXHQgICAgfSk7XG5cdCAgICB2YXIgY2hhaW5JZCA9IDA7XG5cdCAgICBpZiAodHJhbnNhY3Rpb24uY2hhaW5JZCAhPSBudWxsKSB7XG5cdCAgICAgICAgLy8gQSBjaGFpbklkIHdhcyBwcm92aWRlZDsgaWYgbm9uLXplcm8gd2UnbGwgdXNlIEVJUC0xNTVcblx0ICAgICAgICBjaGFpbklkID0gdHJhbnNhY3Rpb24uY2hhaW5JZDtcblx0ICAgICAgICBpZiAodHlwZW9mIChjaGFpbklkKSAhPT0gXCJudW1iZXJcIikge1xuXHQgICAgICAgICAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwiaW52YWxpZCB0cmFuc2FjdGlvbi5jaGFpbklkXCIsIFwidHJhbnNhY3Rpb25cIiwgdHJhbnNhY3Rpb24pO1xuXHQgICAgICAgIH1cblx0ICAgIH1cblx0ICAgIGVsc2UgaWYgKHNpZ25hdHVyZSAmJiAhKDAsIGxpYiQxLmlzQnl0ZXNMaWtlKShzaWduYXR1cmUpICYmIHNpZ25hdHVyZS52ID4gMjgpIHtcblx0ICAgICAgICAvLyBObyBjaGFpbklkIHByb3ZpZGVkLCBidXQgdGhlIHNpZ25hdHVyZSBpcyBzaWduaW5nIHdpdGggRUlQLTE1NTsgZGVyaXZlIGNoYWluSWRcblx0ICAgICAgICBjaGFpbklkID0gTWF0aC5mbG9vcigoc2lnbmF0dXJlLnYgLSAzNSkgLyAyKTtcblx0ICAgIH1cblx0ICAgIC8vIFdlIGhhdmUgYW4gRUlQLTE1NSB0cmFuc2FjdGlvbiAoY2hhaW5JZCB3YXMgc3BlY2lmaWVkIGFuZCBub24temVybylcblx0ICAgIGlmIChjaGFpbklkICE9PSAwKSB7XG5cdCAgICAgICAgcmF3LnB1c2goKDAsIGxpYiQxLmhleGxpZnkpKGNoYWluSWQpKTsgLy8gQFRPRE86IGhleFZhbHVlP1xuXHQgICAgICAgIHJhdy5wdXNoKFwiMHhcIik7XG5cdCAgICAgICAgcmF3LnB1c2goXCIweFwiKTtcblx0ICAgIH1cblx0ICAgIC8vIFJlcXVlc3RpbmcgYW4gdW5zaWduZWQgdHJhbnNhY3Rpb25cblx0ICAgIGlmICghc2lnbmF0dXJlKSB7XG5cdCAgICAgICAgcmV0dXJuIFJMUC5lbmNvZGUocmF3KTtcblx0ICAgIH1cblx0ICAgIC8vIFRoZSBzcGxpdFNpZ25hdHVyZSB3aWxsIGVuc3VyZSB0aGUgdHJhbnNhY3Rpb24gaGFzIGEgcmVjb3ZlcnlQYXJhbSBpbiB0aGVcblx0ICAgIC8vIGNhc2UgdGhhdCB0aGUgc2lnblRyYW5zYWN0aW9uIGZ1bmN0aW9uIG9ubHkgYWRkcyBhIHYuXG5cdCAgICB2YXIgc2lnID0gKDAsIGxpYiQxLnNwbGl0U2lnbmF0dXJlKShzaWduYXR1cmUpO1xuXHQgICAgLy8gV2UgcHVzaGVkIGEgY2hhaW5JZCBhbmQgbnVsbCByLCBzIG9uIGZvciBoYXNoaW5nIG9ubHk7IHJlbW92ZSB0aG9zZVxuXHQgICAgdmFyIHYgPSAyNyArIHNpZy5yZWNvdmVyeVBhcmFtO1xuXHQgICAgaWYgKGNoYWluSWQgIT09IDApIHtcblx0ICAgICAgICByYXcucG9wKCk7XG5cdCAgICAgICAgcmF3LnBvcCgpO1xuXHQgICAgICAgIHJhdy5wb3AoKTtcblx0ICAgICAgICB2ICs9IGNoYWluSWQgKiAyICsgODtcblx0ICAgICAgICAvLyBJZiBhbiBFSVAtMTU1IHYgKGRpcmVjdGx5IG9yIGluZGlyZWN0bHk7IG1heWJlIF92cykgd2FzIHByb3ZpZGVkLCBjaGVjayBpdCFcblx0ICAgICAgICBpZiAoc2lnLnYgPiAyOCAmJiBzaWcudiAhPT0gdikge1xuXHQgICAgICAgICAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwidHJhbnNhY3Rpb24uY2hhaW5JZC9zaWduYXR1cmUudiBtaXNtYXRjaFwiLCBcInNpZ25hdHVyZVwiLCBzaWduYXR1cmUpO1xuXHQgICAgICAgIH1cblx0ICAgIH1cblx0ICAgIGVsc2UgaWYgKHNpZy52ICE9PSB2KSB7XG5cdCAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcInRyYW5zYWN0aW9uLmNoYWluSWQvc2lnbmF0dXJlLnYgbWlzbWF0Y2hcIiwgXCJzaWduYXR1cmVcIiwgc2lnbmF0dXJlKTtcblx0ICAgIH1cblx0ICAgIHJhdy5wdXNoKCgwLCBsaWIkMS5oZXhsaWZ5KSh2KSk7XG5cdCAgICByYXcucHVzaCgoMCwgbGliJDEuc3RyaXBaZXJvcykoKDAsIGxpYiQxLmFycmF5aWZ5KShzaWcucikpKTtcblx0ICAgIHJhdy5wdXNoKCgwLCBsaWIkMS5zdHJpcFplcm9zKSgoMCwgbGliJDEuYXJyYXlpZnkpKHNpZy5zKSkpO1xuXHQgICAgcmV0dXJuIFJMUC5lbmNvZGUocmF3KTtcblx0fVxuXHRmdW5jdGlvbiBzZXJpYWxpemUodHJhbnNhY3Rpb24sIHNpZ25hdHVyZSkge1xuXHQgICAgLy8gTGVnYWN5IGFuZCBFSVAtMTU1IFRyYW5zYWN0aW9uc1xuXHQgICAgaWYgKHRyYW5zYWN0aW9uLnR5cGUgPT0gbnVsbCB8fCB0cmFuc2FjdGlvbi50eXBlID09PSAwKSB7XG5cdCAgICAgICAgaWYgKHRyYW5zYWN0aW9uLmFjY2Vzc0xpc3QgIT0gbnVsbCkge1xuXHQgICAgICAgICAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwidW50eXBlZCB0cmFuc2FjdGlvbnMgZG8gbm90IHN1cHBvcnQgYWNjZXNzTGlzdDsgaW5jbHVkZSB0eXBlOiAxXCIsIFwidHJhbnNhY3Rpb25cIiwgdHJhbnNhY3Rpb24pO1xuXHQgICAgICAgIH1cblx0ICAgICAgICByZXR1cm4gX3NlcmlhbGl6ZSh0cmFuc2FjdGlvbiwgc2lnbmF0dXJlKTtcblx0ICAgIH1cblx0ICAgIC8vIFR5cGVkIFRyYW5zYWN0aW9ucyAoRUlQLTI3MTgpXG5cdCAgICBzd2l0Y2ggKHRyYW5zYWN0aW9uLnR5cGUpIHtcblx0ICAgICAgICBjYXNlIDE6XG5cdCAgICAgICAgICAgIHJldHVybiBfc2VyaWFsaXplRWlwMjkzMCh0cmFuc2FjdGlvbiwgc2lnbmF0dXJlKTtcblx0ICAgICAgICBjYXNlIDI6XG5cdCAgICAgICAgICAgIHJldHVybiBfc2VyaWFsaXplRWlwMTU1OSh0cmFuc2FjdGlvbiwgc2lnbmF0dXJlKTtcblx0ICAgICAgICBkZWZhdWx0OlxuXHQgICAgICAgICAgICBicmVhaztcblx0ICAgIH1cblx0ICAgIHJldHVybiBsb2dnZXIudGhyb3dFcnJvcihcInVuc3VwcG9ydGVkIHRyYW5zYWN0aW9uIHR5cGU6IFwiICsgdHJhbnNhY3Rpb24udHlwZSwgbGliLkxvZ2dlci5lcnJvcnMuVU5TVVBQT1JURURfT1BFUkFUSU9OLCB7XG5cdCAgICAgICAgb3BlcmF0aW9uOiBcInNlcmlhbGl6ZVRyYW5zYWN0aW9uXCIsXG5cdCAgICAgICAgdHJhbnNhY3Rpb25UeXBlOiB0cmFuc2FjdGlvbi50eXBlXG5cdCAgICB9KTtcblx0fVxuXHRleHBvcnRzLnNlcmlhbGl6ZSA9IHNlcmlhbGl6ZTtcblx0ZnVuY3Rpb24gX3BhcnNlRWlwU2lnbmF0dXJlKHR4LCBmaWVsZHMsIHNlcmlhbGl6ZSkge1xuXHQgICAgdHJ5IHtcblx0ICAgICAgICB2YXIgcmVjaWQgPSBoYW5kbGVOdW1iZXIoZmllbGRzWzBdKS50b051bWJlcigpO1xuXHQgICAgICAgIGlmIChyZWNpZCAhPT0gMCAmJiByZWNpZCAhPT0gMSkge1xuXHQgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJiYWQgcmVjaWRcIik7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHR4LnYgPSByZWNpZDtcblx0ICAgIH1cblx0ICAgIGNhdGNoIChlcnJvcikge1xuXHQgICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJpbnZhbGlkIHYgZm9yIHRyYW5zYWN0aW9uIHR5cGU6IDFcIiwgXCJ2XCIsIGZpZWxkc1swXSk7XG5cdCAgICB9XG5cdCAgICB0eC5yID0gKDAsIGxpYiQxLmhleFplcm9QYWQpKGZpZWxkc1sxXSwgMzIpO1xuXHQgICAgdHgucyA9ICgwLCBsaWIkMS5oZXhaZXJvUGFkKShmaWVsZHNbMl0sIDMyKTtcblx0ICAgIHRyeSB7XG5cdCAgICAgICAgdmFyIGRpZ2VzdCA9ICgwLCBsaWIkNC5rZWNjYWsyNTYpKHNlcmlhbGl6ZSh0eCkpO1xuXHQgICAgICAgIHR4LmZyb20gPSByZWNvdmVyQWRkcmVzcyhkaWdlc3QsIHsgcjogdHguciwgczogdHgucywgcmVjb3ZlcnlQYXJhbTogdHgudiB9KTtcblx0ICAgIH1cblx0ICAgIGNhdGNoIChlcnJvcikge1xuXHQgICAgICAgIGNvbnNvbGUubG9nKGVycm9yKTtcblx0ICAgIH1cblx0fVxuXHRmdW5jdGlvbiBfcGFyc2VFaXAxNTU5KHBheWxvYWQpIHtcblx0ICAgIHZhciB0cmFuc2FjdGlvbiA9IFJMUC5kZWNvZGUocGF5bG9hZC5zbGljZSgxKSk7XG5cdCAgICBpZiAodHJhbnNhY3Rpb24ubGVuZ3RoICE9PSA5ICYmIHRyYW5zYWN0aW9uLmxlbmd0aCAhPT0gMTIpIHtcblx0ICAgICAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwiaW52YWxpZCBjb21wb25lbnQgY291bnQgZm9yIHRyYW5zYWN0aW9uIHR5cGU6IDJcIiwgXCJwYXlsb2FkXCIsICgwLCBsaWIkMS5oZXhsaWZ5KShwYXlsb2FkKSk7XG5cdCAgICB9XG5cdCAgICB2YXIgbWF4UHJpb3JpdHlGZWVQZXJHYXMgPSBoYW5kbGVOdW1iZXIodHJhbnNhY3Rpb25bMl0pO1xuXHQgICAgdmFyIG1heEZlZVBlckdhcyA9IGhhbmRsZU51bWJlcih0cmFuc2FjdGlvblszXSk7XG5cdCAgICB2YXIgdHggPSB7XG5cdCAgICAgICAgdHlwZTogMixcblx0ICAgICAgICBjaGFpbklkOiBoYW5kbGVOdW1iZXIodHJhbnNhY3Rpb25bMF0pLnRvTnVtYmVyKCksXG5cdCAgICAgICAgbm9uY2U6IGhhbmRsZU51bWJlcih0cmFuc2FjdGlvblsxXSkudG9OdW1iZXIoKSxcblx0ICAgICAgICBtYXhQcmlvcml0eUZlZVBlckdhczogbWF4UHJpb3JpdHlGZWVQZXJHYXMsXG5cdCAgICAgICAgbWF4RmVlUGVyR2FzOiBtYXhGZWVQZXJHYXMsXG5cdCAgICAgICAgZ2FzUHJpY2U6IG51bGwsXG5cdCAgICAgICAgZ2FzTGltaXQ6IGhhbmRsZU51bWJlcih0cmFuc2FjdGlvbls0XSksXG5cdCAgICAgICAgdG86IGhhbmRsZUFkZHJlc3ModHJhbnNhY3Rpb25bNV0pLFxuXHQgICAgICAgIHZhbHVlOiBoYW5kbGVOdW1iZXIodHJhbnNhY3Rpb25bNl0pLFxuXHQgICAgICAgIGRhdGE6IHRyYW5zYWN0aW9uWzddLFxuXHQgICAgICAgIGFjY2Vzc0xpc3Q6IGFjY2Vzc0xpc3RpZnkodHJhbnNhY3Rpb25bOF0pLFxuXHQgICAgfTtcblx0ICAgIC8vIFVuc2lnbmVkIEVJUC0xNTU5IFRyYW5zYWN0aW9uXG5cdCAgICBpZiAodHJhbnNhY3Rpb24ubGVuZ3RoID09PSA5KSB7XG5cdCAgICAgICAgcmV0dXJuIHR4O1xuXHQgICAgfVxuXHQgICAgdHguaGFzaCA9ICgwLCBsaWIkNC5rZWNjYWsyNTYpKHBheWxvYWQpO1xuXHQgICAgX3BhcnNlRWlwU2lnbmF0dXJlKHR4LCB0cmFuc2FjdGlvbi5zbGljZSg5KSwgX3NlcmlhbGl6ZUVpcDE1NTkpO1xuXHQgICAgcmV0dXJuIHR4O1xuXHR9XG5cdGZ1bmN0aW9uIF9wYXJzZUVpcDI5MzAocGF5bG9hZCkge1xuXHQgICAgdmFyIHRyYW5zYWN0aW9uID0gUkxQLmRlY29kZShwYXlsb2FkLnNsaWNlKDEpKTtcblx0ICAgIGlmICh0cmFuc2FjdGlvbi5sZW5ndGggIT09IDggJiYgdHJhbnNhY3Rpb24ubGVuZ3RoICE9PSAxMSkge1xuXHQgICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJpbnZhbGlkIGNvbXBvbmVudCBjb3VudCBmb3IgdHJhbnNhY3Rpb24gdHlwZTogMVwiLCBcInBheWxvYWRcIiwgKDAsIGxpYiQxLmhleGxpZnkpKHBheWxvYWQpKTtcblx0ICAgIH1cblx0ICAgIHZhciB0eCA9IHtcblx0ICAgICAgICB0eXBlOiAxLFxuXHQgICAgICAgIGNoYWluSWQ6IGhhbmRsZU51bWJlcih0cmFuc2FjdGlvblswXSkudG9OdW1iZXIoKSxcblx0ICAgICAgICBub25jZTogaGFuZGxlTnVtYmVyKHRyYW5zYWN0aW9uWzFdKS50b051bWJlcigpLFxuXHQgICAgICAgIGdhc1ByaWNlOiBoYW5kbGVOdW1iZXIodHJhbnNhY3Rpb25bMl0pLFxuXHQgICAgICAgIGdhc0xpbWl0OiBoYW5kbGVOdW1iZXIodHJhbnNhY3Rpb25bM10pLFxuXHQgICAgICAgIHRvOiBoYW5kbGVBZGRyZXNzKHRyYW5zYWN0aW9uWzRdKSxcblx0ICAgICAgICB2YWx1ZTogaGFuZGxlTnVtYmVyKHRyYW5zYWN0aW9uWzVdKSxcblx0ICAgICAgICBkYXRhOiB0cmFuc2FjdGlvbls2XSxcblx0ICAgICAgICBhY2Nlc3NMaXN0OiBhY2Nlc3NMaXN0aWZ5KHRyYW5zYWN0aW9uWzddKVxuXHQgICAgfTtcblx0ICAgIC8vIFVuc2lnbmVkIEVJUC0yOTMwIFRyYW5zYWN0aW9uXG5cdCAgICBpZiAodHJhbnNhY3Rpb24ubGVuZ3RoID09PSA4KSB7XG5cdCAgICAgICAgcmV0dXJuIHR4O1xuXHQgICAgfVxuXHQgICAgdHguaGFzaCA9ICgwLCBsaWIkNC5rZWNjYWsyNTYpKHBheWxvYWQpO1xuXHQgICAgX3BhcnNlRWlwU2lnbmF0dXJlKHR4LCB0cmFuc2FjdGlvbi5zbGljZSg4KSwgX3NlcmlhbGl6ZUVpcDI5MzApO1xuXHQgICAgcmV0dXJuIHR4O1xuXHR9XG5cdC8vIExlZ2FjeSBUcmFuc2FjdGlvbnMgYW5kIEVJUC0xNTVcblx0ZnVuY3Rpb24gX3BhcnNlKHJhd1RyYW5zYWN0aW9uKSB7XG5cdCAgICB2YXIgdHJhbnNhY3Rpb24gPSBSTFAuZGVjb2RlKHJhd1RyYW5zYWN0aW9uKTtcblx0ICAgIGlmICh0cmFuc2FjdGlvbi5sZW5ndGggIT09IDkgJiYgdHJhbnNhY3Rpb24ubGVuZ3RoICE9PSA2KSB7XG5cdCAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcImludmFsaWQgcmF3IHRyYW5zYWN0aW9uXCIsIFwicmF3VHJhbnNhY3Rpb25cIiwgcmF3VHJhbnNhY3Rpb24pO1xuXHQgICAgfVxuXHQgICAgdmFyIHR4ID0ge1xuXHQgICAgICAgIG5vbmNlOiBoYW5kbGVOdW1iZXIodHJhbnNhY3Rpb25bMF0pLnRvTnVtYmVyKCksXG5cdCAgICAgICAgZ2FzUHJpY2U6IGhhbmRsZU51bWJlcih0cmFuc2FjdGlvblsxXSksXG5cdCAgICAgICAgZ2FzTGltaXQ6IGhhbmRsZU51bWJlcih0cmFuc2FjdGlvblsyXSksXG5cdCAgICAgICAgdG86IGhhbmRsZUFkZHJlc3ModHJhbnNhY3Rpb25bM10pLFxuXHQgICAgICAgIHZhbHVlOiBoYW5kbGVOdW1iZXIodHJhbnNhY3Rpb25bNF0pLFxuXHQgICAgICAgIGRhdGE6IHRyYW5zYWN0aW9uWzVdLFxuXHQgICAgICAgIGNoYWluSWQ6IDBcblx0ICAgIH07XG5cdCAgICAvLyBMZWdhY3kgdW5zaWduZWQgdHJhbnNhY3Rpb25cblx0ICAgIGlmICh0cmFuc2FjdGlvbi5sZW5ndGggPT09IDYpIHtcblx0ICAgICAgICByZXR1cm4gdHg7XG5cdCAgICB9XG5cdCAgICB0cnkge1xuXHQgICAgICAgIHR4LnYgPSBsaWIkMi5CaWdOdW1iZXIuZnJvbSh0cmFuc2FjdGlvbls2XSkudG9OdW1iZXIoKTtcblx0ICAgIH1cblx0ICAgIGNhdGNoIChlcnJvcikge1xuXHQgICAgICAgIGNvbnNvbGUubG9nKGVycm9yKTtcblx0ICAgICAgICByZXR1cm4gdHg7XG5cdCAgICB9XG5cdCAgICB0eC5yID0gKDAsIGxpYiQxLmhleFplcm9QYWQpKHRyYW5zYWN0aW9uWzddLCAzMik7XG5cdCAgICB0eC5zID0gKDAsIGxpYiQxLmhleFplcm9QYWQpKHRyYW5zYWN0aW9uWzhdLCAzMik7XG5cdCAgICBpZiAobGliJDIuQmlnTnVtYmVyLmZyb20odHgucikuaXNaZXJvKCkgJiYgbGliJDIuQmlnTnVtYmVyLmZyb20odHgucykuaXNaZXJvKCkpIHtcblx0ICAgICAgICAvLyBFSVAtMTU1IHVuc2lnbmVkIHRyYW5zYWN0aW9uXG5cdCAgICAgICAgdHguY2hhaW5JZCA9IHR4LnY7XG5cdCAgICAgICAgdHgudiA9IDA7XG5cdCAgICB9XG5cdCAgICBlbHNlIHtcblx0ICAgICAgICAvLyBTaWduZWQgVHJhbnNhY3Rpb25cblx0ICAgICAgICB0eC5jaGFpbklkID0gTWF0aC5mbG9vcigodHgudiAtIDM1KSAvIDIpO1xuXHQgICAgICAgIGlmICh0eC5jaGFpbklkIDwgMCkge1xuXHQgICAgICAgICAgICB0eC5jaGFpbklkID0gMDtcblx0ICAgICAgICB9XG5cdCAgICAgICAgdmFyIHJlY292ZXJ5UGFyYW0gPSB0eC52IC0gMjc7XG5cdCAgICAgICAgdmFyIHJhdyA9IHRyYW5zYWN0aW9uLnNsaWNlKDAsIDYpO1xuXHQgICAgICAgIGlmICh0eC5jaGFpbklkICE9PSAwKSB7XG5cdCAgICAgICAgICAgIHJhdy5wdXNoKCgwLCBsaWIkMS5oZXhsaWZ5KSh0eC5jaGFpbklkKSk7XG5cdCAgICAgICAgICAgIHJhdy5wdXNoKFwiMHhcIik7XG5cdCAgICAgICAgICAgIHJhdy5wdXNoKFwiMHhcIik7XG5cdCAgICAgICAgICAgIHJlY292ZXJ5UGFyYW0gLT0gdHguY2hhaW5JZCAqIDIgKyA4O1xuXHQgICAgICAgIH1cblx0ICAgICAgICB2YXIgZGlnZXN0ID0gKDAsIGxpYiQ0LmtlY2NhazI1NikoUkxQLmVuY29kZShyYXcpKTtcblx0ICAgICAgICB0cnkge1xuXHQgICAgICAgICAgICB0eC5mcm9tID0gcmVjb3ZlckFkZHJlc3MoZGlnZXN0LCB7IHI6ICgwLCBsaWIkMS5oZXhsaWZ5KSh0eC5yKSwgczogKDAsIGxpYiQxLmhleGxpZnkpKHR4LnMpLCByZWNvdmVyeVBhcmFtOiByZWNvdmVyeVBhcmFtIH0pO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBjYXRjaCAoZXJyb3IpIHtcblx0ICAgICAgICAgICAgY29uc29sZS5sb2coZXJyb3IpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICB0eC5oYXNoID0gKDAsIGxpYiQ0LmtlY2NhazI1NikocmF3VHJhbnNhY3Rpb24pO1xuXHQgICAgfVxuXHQgICAgdHgudHlwZSA9IG51bGw7XG5cdCAgICByZXR1cm4gdHg7XG5cdH1cblx0ZnVuY3Rpb24gcGFyc2UocmF3VHJhbnNhY3Rpb24pIHtcblx0ICAgIHZhciBwYXlsb2FkID0gKDAsIGxpYiQxLmFycmF5aWZ5KShyYXdUcmFuc2FjdGlvbik7XG5cdCAgICAvLyBMZWdhY3kgYW5kIEVJUC0xNTUgVHJhbnNhY3Rpb25zXG5cdCAgICBpZiAocGF5bG9hZFswXSA+IDB4N2YpIHtcblx0ICAgICAgICByZXR1cm4gX3BhcnNlKHBheWxvYWQpO1xuXHQgICAgfVxuXHQgICAgLy8gVHlwZWQgVHJhbnNhY3Rpb24gKEVJUC0yNzE4KVxuXHQgICAgc3dpdGNoIChwYXlsb2FkWzBdKSB7XG5cdCAgICAgICAgY2FzZSAxOlxuXHQgICAgICAgICAgICByZXR1cm4gX3BhcnNlRWlwMjkzMChwYXlsb2FkKTtcblx0ICAgICAgICBjYXNlIDI6XG5cdCAgICAgICAgICAgIHJldHVybiBfcGFyc2VFaXAxNTU5KHBheWxvYWQpO1xuXHQgICAgICAgIGRlZmF1bHQ6XG5cdCAgICAgICAgICAgIGJyZWFrO1xuXHQgICAgfVxuXHQgICAgcmV0dXJuIGxvZ2dlci50aHJvd0Vycm9yKFwidW5zdXBwb3J0ZWQgdHJhbnNhY3Rpb24gdHlwZTogXCIgKyBwYXlsb2FkWzBdLCBsaWIuTG9nZ2VyLmVycm9ycy5VTlNVUFBPUlRFRF9PUEVSQVRJT04sIHtcblx0ICAgICAgICBvcGVyYXRpb246IFwicGFyc2VUcmFuc2FjdGlvblwiLFxuXHQgICAgICAgIHRyYW5zYWN0aW9uVHlwZTogcGF5bG9hZFswXVxuXHQgICAgfSk7XG5cdH1cblx0ZXhwb3J0cy5wYXJzZSA9IHBhcnNlO1xuXG5cdH0pO1xuXG5cdHZhciBpbmRleCRlID0gLypAX19QVVJFX18qL2dldERlZmF1bHRFeHBvcnRGcm9tQ2pzKGxpYiRlKTtcblxuXHR2YXIgX3ZlcnNpb24kcSA9IGNyZWF0ZUNvbW1vbmpzTW9kdWxlKGZ1bmN0aW9uIChtb2R1bGUsIGV4cG9ydHMpIHtcblx0XCJ1c2Ugc3RyaWN0XCI7XG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcblx0ZXhwb3J0cy52ZXJzaW9uID0gdm9pZCAwO1xuXHRleHBvcnRzLnZlcnNpb24gPSBcImNvbnRyYWN0cy81LjUuMFwiO1xuXG5cdH0pO1xuXG5cdHZhciBfdmVyc2lvbiRyID0gLypAX19QVVJFX18qL2dldERlZmF1bHRFeHBvcnRGcm9tQ2pzKF92ZXJzaW9uJHEpO1xuXG5cdHZhciBsaWIkZiA9IGNyZWF0ZUNvbW1vbmpzTW9kdWxlKGZ1bmN0aW9uIChtb2R1bGUsIGV4cG9ydHMpIHtcblx0XCJ1c2Ugc3RyaWN0XCI7XG5cdHZhciBfX2V4dGVuZHMgPSAoY29tbW9uanNHbG9iYWwgJiYgY29tbW9uanNHbG9iYWwuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuXHQgICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBmdW5jdGlvbiAoZCwgYikge1xuXHQgICAgICAgIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcblx0ICAgICAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuXHQgICAgICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoYiwgcCkpIGRbcF0gPSBiW3BdOyB9O1xuXHQgICAgICAgIHJldHVybiBleHRlbmRTdGF0aWNzKGQsIGIpO1xuXHQgICAgfTtcblx0ICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuXHQgICAgICAgIGlmICh0eXBlb2YgYiAhPT0gXCJmdW5jdGlvblwiICYmIGIgIT09IG51bGwpXG5cdCAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDbGFzcyBleHRlbmRzIHZhbHVlIFwiICsgU3RyaW5nKGIpICsgXCIgaXMgbm90IGEgY29uc3RydWN0b3Igb3IgbnVsbFwiKTtcblx0ICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuXHQgICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuXHQgICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcblx0ICAgIH07XG5cdH0pKCk7XG5cdHZhciBfX2F3YWl0ZXIgPSAoY29tbW9uanNHbG9iYWwgJiYgY29tbW9uanNHbG9iYWwuX19hd2FpdGVyKSB8fCBmdW5jdGlvbiAodGhpc0FyZywgX2FyZ3VtZW50cywgUCwgZ2VuZXJhdG9yKSB7XG5cdCAgICBmdW5jdGlvbiBhZG9wdCh2YWx1ZSkgeyByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBQID8gdmFsdWUgOiBuZXcgUChmdW5jdGlvbiAocmVzb2x2ZSkgeyByZXNvbHZlKHZhbHVlKTsgfSk7IH1cblx0ICAgIHJldHVybiBuZXcgKFAgfHwgKFAgPSBQcm9taXNlKSkoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuXHQgICAgICAgIGZ1bmN0aW9uIGZ1bGZpbGxlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvci5uZXh0KHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cblx0ICAgICAgICBmdW5jdGlvbiByZWplY3RlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvcltcInRocm93XCJdKHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cblx0ICAgICAgICBmdW5jdGlvbiBzdGVwKHJlc3VsdCkgeyByZXN1bHQuZG9uZSA/IHJlc29sdmUocmVzdWx0LnZhbHVlKSA6IGFkb3B0KHJlc3VsdC52YWx1ZSkudGhlbihmdWxmaWxsZWQsIHJlamVjdGVkKTsgfVxuXHQgICAgICAgIHN0ZXAoKGdlbmVyYXRvciA9IGdlbmVyYXRvci5hcHBseSh0aGlzQXJnLCBfYXJndW1lbnRzIHx8IFtdKSkubmV4dCgpKTtcblx0ICAgIH0pO1xuXHR9O1xuXHR2YXIgX19nZW5lcmF0b3IgPSAoY29tbW9uanNHbG9iYWwgJiYgY29tbW9uanNHbG9iYWwuX19nZW5lcmF0b3IpIHx8IGZ1bmN0aW9uICh0aGlzQXJnLCBib2R5KSB7XG5cdCAgICB2YXIgXyA9IHsgbGFiZWw6IDAsIHNlbnQ6IGZ1bmN0aW9uKCkgeyBpZiAodFswXSAmIDEpIHRocm93IHRbMV07IHJldHVybiB0WzFdOyB9LCB0cnlzOiBbXSwgb3BzOiBbXSB9LCBmLCB5LCB0LCBnO1xuXHQgICAgcmV0dXJuIGcgPSB7IG5leHQ6IHZlcmIoMCksIFwidGhyb3dcIjogdmVyYigxKSwgXCJyZXR1cm5cIjogdmVyYigyKSB9LCB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgKGdbU3ltYm9sLml0ZXJhdG9yXSA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpczsgfSksIGc7XG5cdCAgICBmdW5jdGlvbiB2ZXJiKG4pIHsgcmV0dXJuIGZ1bmN0aW9uICh2KSB7IHJldHVybiBzdGVwKFtuLCB2XSk7IH07IH1cblx0ICAgIGZ1bmN0aW9uIHN0ZXAob3ApIHtcblx0ICAgICAgICBpZiAoZikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkdlbmVyYXRvciBpcyBhbHJlYWR5IGV4ZWN1dGluZy5cIik7XG5cdCAgICAgICAgd2hpbGUgKF8pIHRyeSB7XG5cdCAgICAgICAgICAgIGlmIChmID0gMSwgeSAmJiAodCA9IG9wWzBdICYgMiA/IHlbXCJyZXR1cm5cIl0gOiBvcFswXSA/IHlbXCJ0aHJvd1wiXSB8fCAoKHQgPSB5W1wicmV0dXJuXCJdKSAmJiB0LmNhbGwoeSksIDApIDogeS5uZXh0KSAmJiAhKHQgPSB0LmNhbGwoeSwgb3BbMV0pKS5kb25lKSByZXR1cm4gdDtcblx0ICAgICAgICAgICAgaWYgKHkgPSAwLCB0KSBvcCA9IFtvcFswXSAmIDIsIHQudmFsdWVdO1xuXHQgICAgICAgICAgICBzd2l0Y2ggKG9wWzBdKSB7XG5cdCAgICAgICAgICAgICAgICBjYXNlIDA6IGNhc2UgMTogdCA9IG9wOyBicmVhaztcblx0ICAgICAgICAgICAgICAgIGNhc2UgNDogXy5sYWJlbCsrOyByZXR1cm4geyB2YWx1ZTogb3BbMV0sIGRvbmU6IGZhbHNlIH07XG5cdCAgICAgICAgICAgICAgICBjYXNlIDU6IF8ubGFiZWwrKzsgeSA9IG9wWzFdOyBvcCA9IFswXTsgY29udGludWU7XG5cdCAgICAgICAgICAgICAgICBjYXNlIDc6IG9wID0gXy5vcHMucG9wKCk7IF8udHJ5cy5wb3AoKTsgY29udGludWU7XG5cdCAgICAgICAgICAgICAgICBkZWZhdWx0OlxuXHQgICAgICAgICAgICAgICAgICAgIGlmICghKHQgPSBfLnRyeXMsIHQgPSB0Lmxlbmd0aCA+IDAgJiYgdFt0Lmxlbmd0aCAtIDFdKSAmJiAob3BbMF0gPT09IDYgfHwgb3BbMF0gPT09IDIpKSB7IF8gPSAwOyBjb250aW51ZTsgfVxuXHQgICAgICAgICAgICAgICAgICAgIGlmIChvcFswXSA9PT0gMyAmJiAoIXQgfHwgKG9wWzFdID4gdFswXSAmJiBvcFsxXSA8IHRbM10pKSkgeyBfLmxhYmVsID0gb3BbMV07IGJyZWFrOyB9XG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKG9wWzBdID09PSA2ICYmIF8ubGFiZWwgPCB0WzFdKSB7IF8ubGFiZWwgPSB0WzFdOyB0ID0gb3A7IGJyZWFrOyB9XG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKHQgJiYgXy5sYWJlbCA8IHRbMl0pIHsgXy5sYWJlbCA9IHRbMl07IF8ub3BzLnB1c2gob3ApOyBicmVhazsgfVxuXHQgICAgICAgICAgICAgICAgICAgIGlmICh0WzJdKSBfLm9wcy5wb3AoKTtcblx0ICAgICAgICAgICAgICAgICAgICBfLnRyeXMucG9wKCk7IGNvbnRpbnVlO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIG9wID0gYm9keS5jYWxsKHRoaXNBcmcsIF8pO1xuXHQgICAgICAgIH0gY2F0Y2ggKGUpIHsgb3AgPSBbNiwgZV07IHkgPSAwOyB9IGZpbmFsbHkgeyBmID0gdCA9IDA7IH1cblx0ICAgICAgICBpZiAob3BbMF0gJiA1KSB0aHJvdyBvcFsxXTsgcmV0dXJuIHsgdmFsdWU6IG9wWzBdID8gb3BbMV0gOiB2b2lkIDAsIGRvbmU6IHRydWUgfTtcblx0ICAgIH1cblx0fTtcblx0dmFyIF9fc3ByZWFkQXJyYXkgPSAoY29tbW9uanNHbG9iYWwgJiYgY29tbW9uanNHbG9iYWwuX19zcHJlYWRBcnJheSkgfHwgZnVuY3Rpb24gKHRvLCBmcm9tLCBwYWNrKSB7XG5cdCAgICBpZiAocGFjayB8fCBhcmd1bWVudHMubGVuZ3RoID09PSAyKSBmb3IgKHZhciBpID0gMCwgbCA9IGZyb20ubGVuZ3RoLCBhcjsgaSA8IGw7IGkrKykge1xuXHQgICAgICAgIGlmIChhciB8fCAhKGkgaW4gZnJvbSkpIHtcblx0ICAgICAgICAgICAgaWYgKCFhcikgYXIgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChmcm9tLCAwLCBpKTtcblx0ICAgICAgICAgICAgYXJbaV0gPSBmcm9tW2ldO1xuXHQgICAgICAgIH1cblx0ICAgIH1cblx0ICAgIHJldHVybiB0by5jb25jYXQoYXIgfHwgQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoZnJvbSkpO1xuXHR9O1xuXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5cdGV4cG9ydHMuQ29udHJhY3RGYWN0b3J5ID0gZXhwb3J0cy5Db250cmFjdCA9IGV4cG9ydHMuQmFzZUNvbnRyYWN0ID0gdm9pZCAwO1xuXG5cblxuXG5cblxuXG5cblxuXG5cdHZhciBsb2dnZXIgPSBuZXcgbGliLkxvZ2dlcihfdmVyc2lvbiRxLnZlcnNpb24pO1xuXHQ7XG5cdDtcblx0Ly8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXHR2YXIgYWxsb3dlZFRyYW5zYWN0aW9uS2V5cyA9IHtcblx0ICAgIGNoYWluSWQ6IHRydWUsIGRhdGE6IHRydWUsIGZyb206IHRydWUsIGdhc0xpbWl0OiB0cnVlLCBnYXNQcmljZTogdHJ1ZSwgbm9uY2U6IHRydWUsIHRvOiB0cnVlLCB2YWx1ZTogdHJ1ZSxcblx0ICAgIHR5cGU6IHRydWUsIGFjY2Vzc0xpc3Q6IHRydWUsXG5cdCAgICBtYXhGZWVQZXJHYXM6IHRydWUsIG1heFByaW9yaXR5RmVlUGVyR2FzOiB0cnVlLFxuXHQgICAgY3VzdG9tRGF0YTogdHJ1ZVxuXHR9O1xuXHRmdW5jdGlvbiByZXNvbHZlTmFtZShyZXNvbHZlciwgbmFtZU9yUHJvbWlzZSkge1xuXHQgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIHZhciBuYW1lLCBhZGRyZXNzO1xuXHQgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcblx0ICAgICAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkge1xuXHQgICAgICAgICAgICAgICAgY2FzZSAwOiByZXR1cm4gWzQgLyp5aWVsZCovLCBuYW1lT3JQcm9taXNlXTtcblx0ICAgICAgICAgICAgICAgIGNhc2UgMTpcblx0ICAgICAgICAgICAgICAgICAgICBuYW1lID0gX2Euc2VudCgpO1xuXHQgICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgKG5hbWUpICE9PSBcInN0cmluZ1wiKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJpbnZhbGlkIGFkZHJlc3Mgb3IgRU5TIG5hbWVcIiwgXCJuYW1lXCIsIG5hbWUpO1xuXHQgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICAvLyBJZiBpdCBpcyBhbHJlYWR5IGFuIGFkZHJlc3MsIGp1c3QgdXNlIGl0IChhZnRlciBhZGRpbmcgY2hlY2tzdW0pXG5cdCAgICAgICAgICAgICAgICAgICAgdHJ5IHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sICgwLCBsaWIkNi5nZXRBZGRyZXNzKShuYW1lKV07XG5cdCAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgIGNhdGNoIChlcnJvcikgeyB9XG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKCFyZXNvbHZlcikge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBsb2dnZXIudGhyb3dFcnJvcihcImEgcHJvdmlkZXIgb3Igc2lnbmVyIGlzIG5lZWRlZCB0byByZXNvbHZlIEVOUyBuYW1lc1wiLCBsaWIuTG9nZ2VyLmVycm9ycy5VTlNVUFBPUlRFRF9PUEVSQVRJT04sIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wZXJhdGlvbjogXCJyZXNvbHZlTmFtZVwiXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuXHQgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCByZXNvbHZlci5yZXNvbHZlTmFtZShuYW1lKV07XG5cdCAgICAgICAgICAgICAgICBjYXNlIDI6XG5cdCAgICAgICAgICAgICAgICAgICAgYWRkcmVzcyA9IF9hLnNlbnQoKTtcblx0ICAgICAgICAgICAgICAgICAgICBpZiAoYWRkcmVzcyA9PSBudWxsKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJyZXNvbHZlciBvciBhZGRyIGlzIG5vdCBjb25maWd1cmVkIGZvciBFTlMgbmFtZVwiLCBcIm5hbWVcIiwgbmFtZSk7XG5cdCAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCBhZGRyZXNzXTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH0pO1xuXHQgICAgfSk7XG5cdH1cblx0Ly8gUmVjdXJzaXZlbHkgcmVwbGFjZXMgRU5TIG5hbWVzIHdpdGggcHJvbWlzZXMgdG8gcmVzb2x2ZSB0aGUgbmFtZSBhbmQgcmVzb2x2ZXMgYWxsIHByb3BlcnRpZXNcblx0ZnVuY3Rpb24gcmVzb2x2ZUFkZHJlc3NlcyhyZXNvbHZlciwgdmFsdWUsIHBhcmFtVHlwZSkge1xuXHQgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcblx0ICAgICAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkge1xuXHQgICAgICAgICAgICAgICAgY2FzZSAwOlxuXHQgICAgICAgICAgICAgICAgICAgIGlmICghQXJyYXkuaXNBcnJheShwYXJhbVR5cGUpKSByZXR1cm4gWzMgLypicmVhayovLCAyXTtcblx0ICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCBQcm9taXNlLmFsbChwYXJhbVR5cGUubWFwKGZ1bmN0aW9uIChwYXJhbVR5cGUsIGluZGV4KSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzb2x2ZUFkZHJlc3NlcyhyZXNvbHZlciwgKChBcnJheS5pc0FycmF5KHZhbHVlKSkgPyB2YWx1ZVtpbmRleF0gOiB2YWx1ZVtwYXJhbVR5cGUubmFtZV0pLCBwYXJhbVR5cGUpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB9KSldO1xuXHQgICAgICAgICAgICAgICAgY2FzZSAxOiByZXR1cm4gWzIgLypyZXR1cm4qLywgX2Euc2VudCgpXTtcblx0ICAgICAgICAgICAgICAgIGNhc2UgMjpcblx0ICAgICAgICAgICAgICAgICAgICBpZiAoIShwYXJhbVR5cGUudHlwZSA9PT0gXCJhZGRyZXNzXCIpKSByZXR1cm4gWzMgLypicmVhayovLCA0XTtcblx0ICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCByZXNvbHZlTmFtZShyZXNvbHZlciwgdmFsdWUpXTtcblx0ICAgICAgICAgICAgICAgIGNhc2UgMzogcmV0dXJuIFsyIC8qcmV0dXJuKi8sIF9hLnNlbnQoKV07XG5cdCAgICAgICAgICAgICAgICBjYXNlIDQ6XG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKCEocGFyYW1UeXBlLnR5cGUgPT09IFwidHVwbGVcIikpIHJldHVybiBbMyAvKmJyZWFrKi8sIDZdO1xuXHQgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIHJlc29sdmVBZGRyZXNzZXMocmVzb2x2ZXIsIHZhbHVlLCBwYXJhbVR5cGUuY29tcG9uZW50cyldO1xuXHQgICAgICAgICAgICAgICAgY2FzZSA1OiByZXR1cm4gWzIgLypyZXR1cm4qLywgX2Euc2VudCgpXTtcblx0ICAgICAgICAgICAgICAgIGNhc2UgNjpcblx0ICAgICAgICAgICAgICAgICAgICBpZiAoIShwYXJhbVR5cGUuYmFzZVR5cGUgPT09IFwiYXJyYXlcIikpIHJldHVybiBbMyAvKmJyZWFrKi8sIDhdO1xuXHQgICAgICAgICAgICAgICAgICAgIGlmICghQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIFByb21pc2UucmVqZWN0KGxvZ2dlci5tYWtlRXJyb3IoXCJpbnZhbGlkIHZhbHVlIGZvciBhcnJheVwiLCBsaWIuTG9nZ2VyLmVycm9ycy5JTlZBTElEX0FSR1VNRU5ULCB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXJndW1lbnQ6IFwidmFsdWVcIixcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogdmFsdWVcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pKV07XG5cdCAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIFByb21pc2UuYWxsKHZhbHVlLm1hcChmdW5jdGlvbiAodikgeyByZXR1cm4gcmVzb2x2ZUFkZHJlc3NlcyhyZXNvbHZlciwgdiwgcGFyYW1UeXBlLmFycmF5Q2hpbGRyZW4pOyB9KSldO1xuXHQgICAgICAgICAgICAgICAgY2FzZSA3OiByZXR1cm4gWzIgLypyZXR1cm4qLywgX2Euc2VudCgpXTtcblx0ICAgICAgICAgICAgICAgIGNhc2UgODogcmV0dXJuIFsyIC8qcmV0dXJuKi8sIHZhbHVlXTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH0pO1xuXHQgICAgfSk7XG5cdH1cblx0ZnVuY3Rpb24gcG9wdWxhdGVUcmFuc2FjdGlvbihjb250cmFjdCwgZnJhZ21lbnQsIGFyZ3MpIHtcblx0ICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICB2YXIgb3ZlcnJpZGVzLCByZXNvbHZlZCwgZGF0YSwgdHgsIHJvLCBpbnRyaW5zaWMsIGJ5dGVzLCBpLCByb1ZhbHVlLCBsZWZ0b3ZlcnM7XG5cdCAgICAgICAgdmFyIF90aGlzID0gdGhpcztcblx0ICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG5cdCAgICAgICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcblx0ICAgICAgICAgICAgICAgIGNhc2UgMDpcblx0ICAgICAgICAgICAgICAgICAgICBvdmVycmlkZXMgPSB7fTtcblx0ICAgICAgICAgICAgICAgICAgICBpZiAoYXJncy5sZW5ndGggPT09IGZyYWdtZW50LmlucHV0cy5sZW5ndGggKyAxICYmIHR5cGVvZiAoYXJnc1thcmdzLmxlbmd0aCAtIDFdKSA9PT0gXCJvYmplY3RcIikge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBvdmVycmlkZXMgPSAoMCwgbGliJDMuc2hhbGxvd0NvcHkpKGFyZ3MucG9wKCkpO1xuXHQgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICAvLyBNYWtlIHN1cmUgdGhlIHBhcmFtZXRlciBjb3VudCBtYXRjaGVzXG5cdCAgICAgICAgICAgICAgICAgICAgbG9nZ2VyLmNoZWNrQXJndW1lbnRDb3VudChhcmdzLmxlbmd0aCwgZnJhZ21lbnQuaW5wdXRzLmxlbmd0aCwgXCJwYXNzZWQgdG8gY29udHJhY3RcIik7XG5cdCAgICAgICAgICAgICAgICAgICAgLy8gUG9wdWxhdGUgXCJmcm9tXCIgb3ZlcnJpZGUgKGFsbG93IHByb21pc2VzKVxuXHQgICAgICAgICAgICAgICAgICAgIGlmIChjb250cmFjdC5zaWduZXIpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG92ZXJyaWRlcy5mcm9tKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBDb250cmFjdHMgd2l0aCBhIFNpZ25lciBhcmUgZnJvbSB0aGUgU2lnbmVyJ3MgZnJhbWUtb2YtcmVmZXJlbmNlO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gYnV0IHdlIGFsbG93IG92ZXJyaWRpbmcgXCJmcm9tXCIgaWYgaXQgbWF0Y2hlcyB0aGUgc2lnbmVyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBvdmVycmlkZXMuZnJvbSA9ICgwLCBsaWIkMy5yZXNvbHZlUHJvcGVydGllcykoe1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG92ZXJyaWRlOiByZXNvbHZlTmFtZShjb250cmFjdC5zaWduZXIsIG92ZXJyaWRlcy5mcm9tKSxcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzaWduZXI6IGNvbnRyYWN0LnNpZ25lci5nZXRBZGRyZXNzKClcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pLnRoZW4oZnVuY3Rpb24gKGNoZWNrKSB7IHJldHVybiBfX2F3YWl0ZXIoX3RoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoKDAsIGxpYiQ2LmdldEFkZHJlc3MpKGNoZWNrLnNpZ25lcikgIT09IGNoZWNrLm92ZXJyaWRlKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsb2dnZXIudGhyb3dFcnJvcihcIkNvbnRyYWN0IHdpdGggYSBTaWduZXIgY2Fubm90IG92ZXJyaWRlIGZyb21cIiwgbGliLkxvZ2dlci5lcnJvcnMuVU5TVVBQT1JURURfT1BFUkFUSU9OLCB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3BlcmF0aW9uOiBcIm92ZXJyaWRlcy5mcm9tXCJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCBjaGVjay5vdmVycmlkZV07XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTsgfSk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBvdmVycmlkZXMuZnJvbSA9IGNvbnRyYWN0LnNpZ25lci5nZXRBZGRyZXNzKCk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAob3ZlcnJpZGVzLmZyb20pIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgb3ZlcnJpZGVzLmZyb20gPSByZXNvbHZlTmFtZShjb250cmFjdC5wcm92aWRlciwgb3ZlcnJpZGVzLmZyb20pO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAvL30gZWxzZSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIC8vIENvbnRyYWN0cyB3aXRob3V0IGEgc2lnbmVyIGNhbiBvdmVycmlkZSBcImZyb21cIiwgYW5kIGlmXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIC8vIHVuc3BlY2lmaWVkIHRoZSB6ZXJvIGFkZHJlc3MgaXMgdXNlZFxuXHQgICAgICAgICAgICAgICAgICAgICAgICAvL292ZXJyaWRlcy5mcm9tID0gQWRkcmVzc1plcm87XG5cdCAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sICgwLCBsaWIkMy5yZXNvbHZlUHJvcGVydGllcykoe1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXJnczogcmVzb2x2ZUFkZHJlc3Nlcyhjb250cmFjdC5zaWduZXIgfHwgY29udHJhY3QucHJvdmlkZXIsIGFyZ3MsIGZyYWdtZW50LmlucHV0cyksXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBhZGRyZXNzOiBjb250cmFjdC5yZXNvbHZlZEFkZHJlc3MsXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBvdmVycmlkZXM6ICgoMCwgbGliJDMucmVzb2x2ZVByb3BlcnRpZXMpKG92ZXJyaWRlcykgfHwge30pXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH0pXTtcblx0ICAgICAgICAgICAgICAgIGNhc2UgMTpcblx0ICAgICAgICAgICAgICAgICAgICByZXNvbHZlZCA9IF9hLnNlbnQoKTtcblx0ICAgICAgICAgICAgICAgICAgICBkYXRhID0gY29udHJhY3QuaW50ZXJmYWNlLmVuY29kZUZ1bmN0aW9uRGF0YShmcmFnbWVudCwgcmVzb2x2ZWQuYXJncyk7XG5cdCAgICAgICAgICAgICAgICAgICAgdHggPSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGRhdGE6IGRhdGEsXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHRvOiByZXNvbHZlZC5hZGRyZXNzXG5cdCAgICAgICAgICAgICAgICAgICAgfTtcblx0ICAgICAgICAgICAgICAgICAgICBybyA9IHJlc29sdmVkLm92ZXJyaWRlcztcblx0ICAgICAgICAgICAgICAgICAgICAvLyBQb3B1bGF0ZSBzaW1wbGUgb3ZlcnJpZGVzXG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKHJvLm5vbmNlICE9IG51bGwpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdHgubm9uY2UgPSBsaWIkMi5CaWdOdW1iZXIuZnJvbShyby5ub25jZSkudG9OdW1iZXIoKTtcblx0ICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKHJvLmdhc0xpbWl0ICE9IG51bGwpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdHguZ2FzTGltaXQgPSBsaWIkMi5CaWdOdW1iZXIuZnJvbShyby5nYXNMaW1pdCk7XG5cdCAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgIGlmIChyby5nYXNQcmljZSAhPSBudWxsKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHR4Lmdhc1ByaWNlID0gbGliJDIuQmlnTnVtYmVyLmZyb20ocm8uZ2FzUHJpY2UpO1xuXHQgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICBpZiAocm8ubWF4RmVlUGVyR2FzICE9IG51bGwpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdHgubWF4RmVlUGVyR2FzID0gbGliJDIuQmlnTnVtYmVyLmZyb20ocm8ubWF4RmVlUGVyR2FzKTtcblx0ICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKHJvLm1heFByaW9yaXR5RmVlUGVyR2FzICE9IG51bGwpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdHgubWF4UHJpb3JpdHlGZWVQZXJHYXMgPSBsaWIkMi5CaWdOdW1iZXIuZnJvbShyby5tYXhQcmlvcml0eUZlZVBlckdhcyk7XG5cdCAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgIGlmIChyby5mcm9tICE9IG51bGwpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdHguZnJvbSA9IHJvLmZyb207XG5cdCAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgIGlmIChyby50eXBlICE9IG51bGwpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdHgudHlwZSA9IHJvLnR5cGU7XG5cdCAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgIGlmIChyby5hY2Nlc3NMaXN0ICE9IG51bGwpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdHguYWNjZXNzTGlzdCA9ICgwLCBsaWIkZS5hY2Nlc3NMaXN0aWZ5KShyby5hY2Nlc3NMaXN0KTtcblx0ICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgLy8gSWYgdGhlcmUgd2FzIG5vIFwiZ2FzTGltaXRcIiBvdmVycmlkZSwgYnV0IHRoZSBBQkkgc3BlY2lmaWVzIGEgZGVmYXVsdCwgdXNlIGl0XG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKHR4Lmdhc0xpbWl0ID09IG51bGwgJiYgZnJhZ21lbnQuZ2FzICE9IG51bGwpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgaW50cmluc2ljID0gMjEwMDA7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGJ5dGVzID0gKDAsIGxpYiQxLmFycmF5aWZ5KShkYXRhKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IGJ5dGVzLmxlbmd0aDsgaSsrKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbnRyaW5zaWMgKz0gNDtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChieXRlc1tpXSkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGludHJpbnNpYyArPSA2NDtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgICAgICB0eC5nYXNMaW1pdCA9IGxpYiQyLkJpZ051bWJlci5mcm9tKGZyYWdtZW50LmdhcykuYWRkKGludHJpbnNpYyk7XG5cdCAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgIC8vIFBvcHVsYXRlIFwidmFsdWVcIiBvdmVycmlkZVxuXHQgICAgICAgICAgICAgICAgICAgIGlmIChyby52YWx1ZSkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICByb1ZhbHVlID0gbGliJDIuQmlnTnVtYmVyLmZyb20ocm8udmFsdWUpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXJvVmFsdWUuaXNaZXJvKCkgJiYgIWZyYWdtZW50LnBheWFibGUpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxvZ2dlci50aHJvd0Vycm9yKFwibm9uLXBheWFibGUgbWV0aG9kIGNhbm5vdCBvdmVycmlkZSB2YWx1ZVwiLCBsaWIuTG9nZ2VyLmVycm9ycy5VTlNVUFBPUlRFRF9PUEVSQVRJT04sIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcGVyYXRpb246IFwib3ZlcnJpZGVzLnZhbHVlXCIsXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IG92ZXJyaWRlcy52YWx1ZVxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICAgICAgdHgudmFsdWUgPSByb1ZhbHVlO1xuXHQgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICBpZiAocm8uY3VzdG9tRGF0YSkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB0eC5jdXN0b21EYXRhID0gKDAsIGxpYiQzLnNoYWxsb3dDb3B5KShyby5jdXN0b21EYXRhKTtcblx0ICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgLy8gUmVtb3ZlIHRoZSBvdmVycmlkZXNcblx0ICAgICAgICAgICAgICAgICAgICBkZWxldGUgb3ZlcnJpZGVzLm5vbmNlO1xuXHQgICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBvdmVycmlkZXMuZ2FzTGltaXQ7XG5cdCAgICAgICAgICAgICAgICAgICAgZGVsZXRlIG92ZXJyaWRlcy5nYXNQcmljZTtcblx0ICAgICAgICAgICAgICAgICAgICBkZWxldGUgb3ZlcnJpZGVzLmZyb207XG5cdCAgICAgICAgICAgICAgICAgICAgZGVsZXRlIG92ZXJyaWRlcy52YWx1ZTtcblx0ICAgICAgICAgICAgICAgICAgICBkZWxldGUgb3ZlcnJpZGVzLnR5cGU7XG5cdCAgICAgICAgICAgICAgICAgICAgZGVsZXRlIG92ZXJyaWRlcy5hY2Nlc3NMaXN0O1xuXHQgICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBvdmVycmlkZXMubWF4RmVlUGVyR2FzO1xuXHQgICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBvdmVycmlkZXMubWF4UHJpb3JpdHlGZWVQZXJHYXM7XG5cdCAgICAgICAgICAgICAgICAgICAgZGVsZXRlIG92ZXJyaWRlcy5jdXN0b21EYXRhO1xuXHQgICAgICAgICAgICAgICAgICAgIGxlZnRvdmVycyA9IE9iamVjdC5rZXlzKG92ZXJyaWRlcykuZmlsdGVyKGZ1bmN0aW9uIChrZXkpIHsgcmV0dXJuIChvdmVycmlkZXNba2V5XSAhPSBudWxsKTsgfSk7XG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKGxlZnRvdmVycy5sZW5ndGgpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgbG9nZ2VyLnRocm93RXJyb3IoXCJjYW5ub3Qgb3ZlcnJpZGUgXCIgKyBsZWZ0b3ZlcnMubWFwKGZ1bmN0aW9uIChsKSB7IHJldHVybiBKU09OLnN0cmluZ2lmeShsKTsgfSkuam9pbihcIixcIiksIGxpYi5Mb2dnZXIuZXJyb3JzLlVOU1VQUE9SVEVEX09QRVJBVElPTiwge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3BlcmF0aW9uOiBcIm92ZXJyaWRlc1wiLFxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3ZlcnJpZGVzOiBsZWZ0b3ZlcnNcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCB0eF07XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9KTtcblx0ICAgIH0pO1xuXHR9XG5cdGZ1bmN0aW9uIGJ1aWxkUG9wdWxhdGUoY29udHJhY3QsIGZyYWdtZW50KSB7XG5cdCAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIHZhciBhcmdzID0gW107XG5cdCAgICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcblx0ICAgICAgICAgICAgYXJnc1tfaV0gPSBhcmd1bWVudHNbX2ldO1xuXHQgICAgICAgIH1cblx0ICAgICAgICByZXR1cm4gcG9wdWxhdGVUcmFuc2FjdGlvbihjb250cmFjdCwgZnJhZ21lbnQsIGFyZ3MpO1xuXHQgICAgfTtcblx0fVxuXHRmdW5jdGlvbiBidWlsZEVzdGltYXRlKGNvbnRyYWN0LCBmcmFnbWVudCkge1xuXHQgICAgdmFyIHNpZ25lck9yUHJvdmlkZXIgPSAoY29udHJhY3Quc2lnbmVyIHx8IGNvbnRyYWN0LnByb3ZpZGVyKTtcblx0ICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgdmFyIGFyZ3MgPSBbXTtcblx0ICAgICAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xuXHQgICAgICAgICAgICBhcmdzW19pXSA9IGFyZ3VtZW50c1tfaV07XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgdmFyIHR4O1xuXHQgICAgICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG5cdCAgICAgICAgICAgICAgICBzd2l0Y2ggKF9hLmxhYmVsKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgY2FzZSAwOlxuXHQgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXNpZ25lck9yUHJvdmlkZXIpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxvZ2dlci50aHJvd0Vycm9yKFwiZXN0aW1hdGUgcmVxdWlyZSBhIHByb3ZpZGVyIG9yIHNpZ25lclwiLCBsaWIuTG9nZ2VyLmVycm9ycy5VTlNVUFBPUlRFRF9PUEVSQVRJT04sIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcGVyYXRpb246IFwiZXN0aW1hdGVHYXNcIlxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgcG9wdWxhdGVUcmFuc2FjdGlvbihjb250cmFjdCwgZnJhZ21lbnQsIGFyZ3MpXTtcblx0ICAgICAgICAgICAgICAgICAgICBjYXNlIDE6XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHR4ID0gX2Euc2VudCgpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCBzaWduZXJPclByb3ZpZGVyLmVzdGltYXRlR2FzKHR4KV07XG5cdCAgICAgICAgICAgICAgICAgICAgY2FzZSAyOiByZXR1cm4gWzIgLypyZXR1cm4qLywgX2Euc2VudCgpXTtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgfSk7XG5cdCAgICB9O1xuXHR9XG5cdGZ1bmN0aW9uIGFkZENvbnRyYWN0V2FpdChjb250cmFjdCwgdHgpIHtcblx0ICAgIHZhciB3YWl0ID0gdHgud2FpdC5iaW5kKHR4KTtcblx0ICAgIHR4LndhaXQgPSBmdW5jdGlvbiAoY29uZmlybWF0aW9ucykge1xuXHQgICAgICAgIHJldHVybiB3YWl0KGNvbmZpcm1hdGlvbnMpLnRoZW4oZnVuY3Rpb24gKHJlY2VpcHQpIHtcblx0ICAgICAgICAgICAgcmVjZWlwdC5ldmVudHMgPSByZWNlaXB0LmxvZ3MubWFwKGZ1bmN0aW9uIChsb2cpIHtcblx0ICAgICAgICAgICAgICAgIHZhciBldmVudCA9ICgwLCBsaWIkMy5kZWVwQ29weSkobG9nKTtcblx0ICAgICAgICAgICAgICAgIHZhciBwYXJzZWQgPSBudWxsO1xuXHQgICAgICAgICAgICAgICAgdHJ5IHtcblx0ICAgICAgICAgICAgICAgICAgICBwYXJzZWQgPSBjb250cmFjdC5pbnRlcmZhY2UucGFyc2VMb2cobG9nKTtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgIGNhdGNoIChlKSB7IH1cblx0ICAgICAgICAgICAgICAgIC8vIFN1Y2Nlc3NmdWxseSBwYXJzZWQgdGhlIGV2ZW50IGxvZzsgaW5jbHVkZSBpdFxuXHQgICAgICAgICAgICAgICAgaWYgKHBhcnNlZCkge1xuXHQgICAgICAgICAgICAgICAgICAgIGV2ZW50LmFyZ3MgPSBwYXJzZWQuYXJncztcblx0ICAgICAgICAgICAgICAgICAgICBldmVudC5kZWNvZGUgPSBmdW5jdGlvbiAoZGF0YSwgdG9waWNzKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjb250cmFjdC5pbnRlcmZhY2UuZGVjb2RlRXZlbnRMb2cocGFyc2VkLmV2ZW50RnJhZ21lbnQsIGRhdGEsIHRvcGljcyk7XG5cdCAgICAgICAgICAgICAgICAgICAgfTtcblx0ICAgICAgICAgICAgICAgICAgICBldmVudC5ldmVudCA9IHBhcnNlZC5uYW1lO1xuXHQgICAgICAgICAgICAgICAgICAgIGV2ZW50LmV2ZW50U2lnbmF0dXJlID0gcGFyc2VkLnNpZ25hdHVyZTtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgIC8vIFVzZWZ1bCBvcGVyYXRpb25zXG5cdCAgICAgICAgICAgICAgICBldmVudC5yZW1vdmVMaXN0ZW5lciA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGNvbnRyYWN0LnByb3ZpZGVyOyB9O1xuXHQgICAgICAgICAgICAgICAgZXZlbnQuZ2V0QmxvY2sgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNvbnRyYWN0LnByb3ZpZGVyLmdldEJsb2NrKHJlY2VpcHQuYmxvY2tIYXNoKTtcblx0ICAgICAgICAgICAgICAgIH07XG5cdCAgICAgICAgICAgICAgICBldmVudC5nZXRUcmFuc2FjdGlvbiA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgICAgICAgICByZXR1cm4gY29udHJhY3QucHJvdmlkZXIuZ2V0VHJhbnNhY3Rpb24ocmVjZWlwdC50cmFuc2FjdGlvbkhhc2gpO1xuXHQgICAgICAgICAgICAgICAgfTtcblx0ICAgICAgICAgICAgICAgIGV2ZW50LmdldFRyYW5zYWN0aW9uUmVjZWlwdCA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHJlY2VpcHQpO1xuXHQgICAgICAgICAgICAgICAgfTtcblx0ICAgICAgICAgICAgICAgIHJldHVybiBldmVudDtcblx0ICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgICAgIHJldHVybiByZWNlaXB0O1xuXHQgICAgICAgIH0pO1xuXHQgICAgfTtcblx0fVxuXHRmdW5jdGlvbiBidWlsZENhbGwoY29udHJhY3QsIGZyYWdtZW50LCBjb2xsYXBzZVNpbXBsZSkge1xuXHQgICAgdmFyIHNpZ25lck9yUHJvdmlkZXIgPSAoY29udHJhY3Quc2lnbmVyIHx8IGNvbnRyYWN0LnByb3ZpZGVyKTtcblx0ICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgdmFyIGFyZ3MgPSBbXTtcblx0ICAgICAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xuXHQgICAgICAgICAgICBhcmdzW19pXSA9IGFyZ3VtZW50c1tfaV07XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgdmFyIGJsb2NrVGFnLCBvdmVycmlkZXMsIHR4LCByZXN1bHQsIHZhbHVlO1xuXHQgICAgICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG5cdCAgICAgICAgICAgICAgICBzd2l0Y2ggKF9hLmxhYmVsKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgY2FzZSAwOlxuXHQgICAgICAgICAgICAgICAgICAgICAgICBibG9ja1RhZyA9IHVuZGVmaW5lZDtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCEoYXJncy5sZW5ndGggPT09IGZyYWdtZW50LmlucHV0cy5sZW5ndGggKyAxICYmIHR5cGVvZiAoYXJnc1thcmdzLmxlbmd0aCAtIDFdKSA9PT0gXCJvYmplY3RcIikpIHJldHVybiBbMyAvKmJyZWFrKi8sIDNdO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBvdmVycmlkZXMgPSAoMCwgbGliJDMuc2hhbGxvd0NvcHkpKGFyZ3MucG9wKCkpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIShvdmVycmlkZXMuYmxvY2tUYWcgIT0gbnVsbCkpIHJldHVybiBbMyAvKmJyZWFrKi8sIDJdO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCBvdmVycmlkZXMuYmxvY2tUYWddO1xuXHQgICAgICAgICAgICAgICAgICAgIGNhc2UgMTpcblx0ICAgICAgICAgICAgICAgICAgICAgICAgYmxvY2tUYWcgPSBfYS5zZW50KCk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIF9hLmxhYmVsID0gMjtcblx0ICAgICAgICAgICAgICAgICAgICBjYXNlIDI6XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBvdmVycmlkZXMuYmxvY2tUYWc7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGFyZ3MucHVzaChvdmVycmlkZXMpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBfYS5sYWJlbCA9IDM7XG5cdCAgICAgICAgICAgICAgICAgICAgY2FzZSAzOlxuXHQgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIShjb250cmFjdC5kZXBsb3lUcmFuc2FjdGlvbiAhPSBudWxsKSkgcmV0dXJuIFszIC8qYnJlYWsqLywgNV07XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIGNvbnRyYWN0Ll9kZXBsb3llZChibG9ja1RhZyldO1xuXHQgICAgICAgICAgICAgICAgICAgIGNhc2UgNDpcblx0ICAgICAgICAgICAgICAgICAgICAgICAgX2Euc2VudCgpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBfYS5sYWJlbCA9IDU7XG5cdCAgICAgICAgICAgICAgICAgICAgY2FzZSA1OiByZXR1cm4gWzQgLyp5aWVsZCovLCBwb3B1bGF0ZVRyYW5zYWN0aW9uKGNvbnRyYWN0LCBmcmFnbWVudCwgYXJncyldO1xuXHQgICAgICAgICAgICAgICAgICAgIGNhc2UgNjpcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdHggPSBfYS5zZW50KCk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIHNpZ25lck9yUHJvdmlkZXIuY2FsbCh0eCwgYmxvY2tUYWcpXTtcblx0ICAgICAgICAgICAgICAgICAgICBjYXNlIDc6XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IF9hLnNlbnQoKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdHJ5IHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlID0gY29udHJhY3QuaW50ZXJmYWNlLmRlY29kZUZ1bmN0aW9uUmVzdWx0KGZyYWdtZW50LCByZXN1bHQpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNvbGxhcHNlU2ltcGxlICYmIGZyYWdtZW50Lm91dHB1dHMubGVuZ3RoID09PSAxKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZVswXTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCB2YWx1ZV07XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZXJyb3IuY29kZSA9PT0gbGliLkxvZ2dlci5lcnJvcnMuQ0FMTF9FWENFUFRJT04pIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlcnJvci5hZGRyZXNzID0gY29udHJhY3QuYWRkcmVzcztcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlcnJvci5hcmdzID0gYXJncztcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlcnJvci50cmFuc2FjdGlvbiA9IHR4O1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi9dO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB9KTtcblx0ICAgICAgICB9KTtcblx0ICAgIH07XG5cdH1cblx0ZnVuY3Rpb24gYnVpbGRTZW5kKGNvbnRyYWN0LCBmcmFnbWVudCkge1xuXHQgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICB2YXIgYXJncyA9IFtdO1xuXHQgICAgICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG5cdCAgICAgICAgICAgIGFyZ3NbX2ldID0gYXJndW1lbnRzW19pXTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICB2YXIgdHhSZXF1ZXN0LCB0eDtcblx0ICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuXHQgICAgICAgICAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkge1xuXHQgICAgICAgICAgICAgICAgICAgIGNhc2UgMDpcblx0ICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFjb250cmFjdC5zaWduZXIpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxvZ2dlci50aHJvd0Vycm9yKFwic2VuZGluZyBhIHRyYW5zYWN0aW9uIHJlcXVpcmVzIGEgc2lnbmVyXCIsIGxpYi5Mb2dnZXIuZXJyb3JzLlVOU1VQUE9SVEVEX09QRVJBVElPTiwge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wZXJhdGlvbjogXCJzZW5kVHJhbnNhY3Rpb25cIlxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCEoY29udHJhY3QuZGVwbG95VHJhbnNhY3Rpb24gIT0gbnVsbCkpIHJldHVybiBbMyAvKmJyZWFrKi8sIDJdO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCBjb250cmFjdC5fZGVwbG95ZWQoKV07XG5cdCAgICAgICAgICAgICAgICAgICAgY2FzZSAxOlxuXHQgICAgICAgICAgICAgICAgICAgICAgICBfYS5zZW50KCk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIF9hLmxhYmVsID0gMjtcblx0ICAgICAgICAgICAgICAgICAgICBjYXNlIDI6IHJldHVybiBbNCAvKnlpZWxkKi8sIHBvcHVsYXRlVHJhbnNhY3Rpb24oY29udHJhY3QsIGZyYWdtZW50LCBhcmdzKV07XG5cdCAgICAgICAgICAgICAgICAgICAgY2FzZSAzOlxuXHQgICAgICAgICAgICAgICAgICAgICAgICB0eFJlcXVlc3QgPSBfYS5zZW50KCk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIGNvbnRyYWN0LnNpZ25lci5zZW5kVHJhbnNhY3Rpb24odHhSZXF1ZXN0KV07XG5cdCAgICAgICAgICAgICAgICAgICAgY2FzZSA0OlxuXHQgICAgICAgICAgICAgICAgICAgICAgICB0eCA9IF9hLnNlbnQoKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgLy8gVHdlYWsgdGhlIHR4LndhaXQgc28gdGhlIHJlY2VpcHQgaGFzIGV4dHJhIHByb3BlcnRpZXNcblx0ICAgICAgICAgICAgICAgICAgICAgICAgYWRkQ29udHJhY3RXYWl0KGNvbnRyYWN0LCB0eCk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCB0eF07XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIH0pO1xuXHQgICAgICAgIH0pO1xuXHQgICAgfTtcblx0fVxuXHRmdW5jdGlvbiBidWlsZERlZmF1bHQoY29udHJhY3QsIGZyYWdtZW50LCBjb2xsYXBzZVNpbXBsZSkge1xuXHQgICAgaWYgKGZyYWdtZW50LmNvbnN0YW50KSB7XG5cdCAgICAgICAgcmV0dXJuIGJ1aWxkQ2FsbChjb250cmFjdCwgZnJhZ21lbnQsIGNvbGxhcHNlU2ltcGxlKTtcblx0ICAgIH1cblx0ICAgIHJldHVybiBidWlsZFNlbmQoY29udHJhY3QsIGZyYWdtZW50KTtcblx0fVxuXHRmdW5jdGlvbiBnZXRFdmVudFRhZyhmaWx0ZXIpIHtcblx0ICAgIGlmIChmaWx0ZXIuYWRkcmVzcyAmJiAoZmlsdGVyLnRvcGljcyA9PSBudWxsIHx8IGZpbHRlci50b3BpY3MubGVuZ3RoID09PSAwKSkge1xuXHQgICAgICAgIHJldHVybiBcIipcIjtcblx0ICAgIH1cblx0ICAgIHJldHVybiAoZmlsdGVyLmFkZHJlc3MgfHwgXCIqXCIpICsgXCJAXCIgKyAoZmlsdGVyLnRvcGljcyA/IGZpbHRlci50b3BpY3MubWFwKGZ1bmN0aW9uICh0b3BpYykge1xuXHQgICAgICAgIGlmIChBcnJheS5pc0FycmF5KHRvcGljKSkge1xuXHQgICAgICAgICAgICByZXR1cm4gdG9waWMuam9pbihcInxcIik7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHJldHVybiB0b3BpYztcblx0ICAgIH0pLmpvaW4oXCI6XCIpIDogXCJcIik7XG5cdH1cblx0dmFyIFJ1bm5pbmdFdmVudCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcblx0ICAgIGZ1bmN0aW9uIFJ1bm5pbmdFdmVudCh0YWcsIGZpbHRlcikge1xuXHQgICAgICAgICgwLCBsaWIkMy5kZWZpbmVSZWFkT25seSkodGhpcywgXCJ0YWdcIiwgdGFnKTtcblx0ICAgICAgICAoMCwgbGliJDMuZGVmaW5lUmVhZE9ubHkpKHRoaXMsIFwiZmlsdGVyXCIsIGZpbHRlcik7XG5cdCAgICAgICAgdGhpcy5fbGlzdGVuZXJzID0gW107XG5cdCAgICB9XG5cdCAgICBSdW5uaW5nRXZlbnQucHJvdG90eXBlLmFkZExpc3RlbmVyID0gZnVuY3Rpb24gKGxpc3RlbmVyLCBvbmNlKSB7XG5cdCAgICAgICAgdGhpcy5fbGlzdGVuZXJzLnB1c2goeyBsaXN0ZW5lcjogbGlzdGVuZXIsIG9uY2U6IG9uY2UgfSk7XG5cdCAgICB9O1xuXHQgICAgUnVubmluZ0V2ZW50LnByb3RvdHlwZS5yZW1vdmVMaXN0ZW5lciA9IGZ1bmN0aW9uIChsaXN0ZW5lcikge1xuXHQgICAgICAgIHZhciBkb25lID0gZmFsc2U7XG5cdCAgICAgICAgdGhpcy5fbGlzdGVuZXJzID0gdGhpcy5fbGlzdGVuZXJzLmZpbHRlcihmdW5jdGlvbiAoaXRlbSkge1xuXHQgICAgICAgICAgICBpZiAoZG9uZSB8fCBpdGVtLmxpc3RlbmVyICE9PSBsaXN0ZW5lcikge1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgZG9uZSA9IHRydWU7XG5cdCAgICAgICAgICAgIHJldHVybiBmYWxzZTtcblx0ICAgICAgICB9KTtcblx0ICAgIH07XG5cdCAgICBSdW5uaW5nRXZlbnQucHJvdG90eXBlLnJlbW92ZUFsbExpc3RlbmVycyA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICB0aGlzLl9saXN0ZW5lcnMgPSBbXTtcblx0ICAgIH07XG5cdCAgICBSdW5uaW5nRXZlbnQucHJvdG90eXBlLmxpc3RlbmVycyA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICByZXR1cm4gdGhpcy5fbGlzdGVuZXJzLm1hcChmdW5jdGlvbiAoaSkgeyByZXR1cm4gaS5saXN0ZW5lcjsgfSk7XG5cdCAgICB9O1xuXHQgICAgUnVubmluZ0V2ZW50LnByb3RvdHlwZS5saXN0ZW5lckNvdW50ID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIHJldHVybiB0aGlzLl9saXN0ZW5lcnMubGVuZ3RoO1xuXHQgICAgfTtcblx0ICAgIFJ1bm5pbmdFdmVudC5wcm90b3R5cGUucnVuID0gZnVuY3Rpb24gKGFyZ3MpIHtcblx0ICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXHQgICAgICAgIHZhciBsaXN0ZW5lckNvdW50ID0gdGhpcy5saXN0ZW5lckNvdW50KCk7XG5cdCAgICAgICAgdGhpcy5fbGlzdGVuZXJzID0gdGhpcy5fbGlzdGVuZXJzLmZpbHRlcihmdW5jdGlvbiAoaXRlbSkge1xuXHQgICAgICAgICAgICB2YXIgYXJnc0NvcHkgPSBhcmdzLnNsaWNlKCk7XG5cdCAgICAgICAgICAgIC8vIENhbGwgdGhlIGNhbGxiYWNrIGluIHRoZSBuZXh0IGV2ZW50IGxvb3Bcblx0ICAgICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgICAgICBpdGVtLmxpc3RlbmVyLmFwcGx5KF90aGlzLCBhcmdzQ29weSk7XG5cdCAgICAgICAgICAgIH0sIDApO1xuXHQgICAgICAgICAgICAvLyBSZXNjaGVkdWxlIGl0IGlmIGl0IG5vdCBcIm9uY2VcIlxuXHQgICAgICAgICAgICByZXR1cm4gIShpdGVtLm9uY2UpO1xuXHQgICAgICAgIH0pO1xuXHQgICAgICAgIHJldHVybiBsaXN0ZW5lckNvdW50O1xuXHQgICAgfTtcblx0ICAgIFJ1bm5pbmdFdmVudC5wcm90b3R5cGUucHJlcGFyZUV2ZW50ID0gZnVuY3Rpb24gKGV2ZW50KSB7XG5cdCAgICB9O1xuXHQgICAgLy8gUmV0dXJucyB0aGUgYXJyYXkgdGhhdCB3aWxsIGJlIGFwcGxpZWQgdG8gYW4gZW1pdFxuXHQgICAgUnVubmluZ0V2ZW50LnByb3RvdHlwZS5nZXRFbWl0ID0gZnVuY3Rpb24gKGV2ZW50KSB7XG5cdCAgICAgICAgcmV0dXJuIFtldmVudF07XG5cdCAgICB9O1xuXHQgICAgcmV0dXJuIFJ1bm5pbmdFdmVudDtcblx0fSgpKTtcblx0dmFyIEVycm9yUnVubmluZ0V2ZW50ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuXHQgICAgX19leHRlbmRzKEVycm9yUnVubmluZ0V2ZW50LCBfc3VwZXIpO1xuXHQgICAgZnVuY3Rpb24gRXJyb3JSdW5uaW5nRXZlbnQoKSB7XG5cdCAgICAgICAgcmV0dXJuIF9zdXBlci5jYWxsKHRoaXMsIFwiZXJyb3JcIiwgbnVsbCkgfHwgdGhpcztcblx0ICAgIH1cblx0ICAgIHJldHVybiBFcnJvclJ1bm5pbmdFdmVudDtcblx0fShSdW5uaW5nRXZlbnQpKTtcblx0Ly8gQFRPRE8gRnJhZ21lbnQgc2hvdWxkIGluaGVyaXQgV2lsZGNhcmQ/IGFuZCBqdXN0IG92ZXJyaWRlIGdldEVtaXQ/XG5cdC8vICAgICAgIG9yIGhhdmUgYSBjb21tb24gYWJzdHJhY3Qgc3VwZXIgY2xhc3MsIHdpdGggZW5vdWdoIGNvbnN0cnVjdG9yXG5cdC8vICAgICAgIG9wdGlvbnMgdG8gY29uZmlndXJlIGJvdGguXG5cdC8vIEEgRnJhZ21lbnQgRXZlbnQgd2lsbCBwb3B1bGF0ZSBhbGwgdGhlIHByb3BlcnRpZXMgdGhhdCBXaWxkY2FyZFxuXHQvLyB3aWxsLCBhbmQgYWRkaXRpb25hbGx5IGRlcmVmZXJlbmNlIHRoZSBhcmd1bWVudHMgd2hlbiBlbWl0dGluZ1xuXHR2YXIgRnJhZ21lbnRSdW5uaW5nRXZlbnQgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG5cdCAgICBfX2V4dGVuZHMoRnJhZ21lbnRSdW5uaW5nRXZlbnQsIF9zdXBlcik7XG5cdCAgICBmdW5jdGlvbiBGcmFnbWVudFJ1bm5pbmdFdmVudChhZGRyZXNzLCBjb250cmFjdEludGVyZmFjZSwgZnJhZ21lbnQsIHRvcGljcykge1xuXHQgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cdCAgICAgICAgdmFyIGZpbHRlciA9IHtcblx0ICAgICAgICAgICAgYWRkcmVzczogYWRkcmVzc1xuXHQgICAgICAgIH07XG5cdCAgICAgICAgdmFyIHRvcGljID0gY29udHJhY3RJbnRlcmZhY2UuZ2V0RXZlbnRUb3BpYyhmcmFnbWVudCk7XG5cdCAgICAgICAgaWYgKHRvcGljcykge1xuXHQgICAgICAgICAgICBpZiAodG9waWMgIT09IHRvcGljc1swXSkge1xuXHQgICAgICAgICAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcInRvcGljIG1pc21hdGNoXCIsIFwidG9waWNzXCIsIHRvcGljcyk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgZmlsdGVyLnRvcGljcyA9IHRvcGljcy5zbGljZSgpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBlbHNlIHtcblx0ICAgICAgICAgICAgZmlsdGVyLnRvcGljcyA9IFt0b3BpY107XG5cdCAgICAgICAgfVxuXHQgICAgICAgIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgZ2V0RXZlbnRUYWcoZmlsdGVyKSwgZmlsdGVyKSB8fCB0aGlzO1xuXHQgICAgICAgICgwLCBsaWIkMy5kZWZpbmVSZWFkT25seSkoX3RoaXMsIFwiYWRkcmVzc1wiLCBhZGRyZXNzKTtcblx0ICAgICAgICAoMCwgbGliJDMuZGVmaW5lUmVhZE9ubHkpKF90aGlzLCBcImludGVyZmFjZVwiLCBjb250cmFjdEludGVyZmFjZSk7XG5cdCAgICAgICAgKDAsIGxpYiQzLmRlZmluZVJlYWRPbmx5KShfdGhpcywgXCJmcmFnbWVudFwiLCBmcmFnbWVudCk7XG5cdCAgICAgICAgcmV0dXJuIF90aGlzO1xuXHQgICAgfVxuXHQgICAgRnJhZ21lbnRSdW5uaW5nRXZlbnQucHJvdG90eXBlLnByZXBhcmVFdmVudCA9IGZ1bmN0aW9uIChldmVudCkge1xuXHQgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cdCAgICAgICAgX3N1cGVyLnByb3RvdHlwZS5wcmVwYXJlRXZlbnQuY2FsbCh0aGlzLCBldmVudCk7XG5cdCAgICAgICAgZXZlbnQuZXZlbnQgPSB0aGlzLmZyYWdtZW50Lm5hbWU7XG5cdCAgICAgICAgZXZlbnQuZXZlbnRTaWduYXR1cmUgPSB0aGlzLmZyYWdtZW50LmZvcm1hdCgpO1xuXHQgICAgICAgIGV2ZW50LmRlY29kZSA9IGZ1bmN0aW9uIChkYXRhLCB0b3BpY3MpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIF90aGlzLmludGVyZmFjZS5kZWNvZGVFdmVudExvZyhfdGhpcy5mcmFnbWVudCwgZGF0YSwgdG9waWNzKTtcblx0ICAgICAgICB9O1xuXHQgICAgICAgIHRyeSB7XG5cdCAgICAgICAgICAgIGV2ZW50LmFyZ3MgPSB0aGlzLmludGVyZmFjZS5kZWNvZGVFdmVudExvZyh0aGlzLmZyYWdtZW50LCBldmVudC5kYXRhLCBldmVudC50b3BpY3MpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBjYXRjaCAoZXJyb3IpIHtcblx0ICAgICAgICAgICAgZXZlbnQuYXJncyA9IG51bGw7XG5cdCAgICAgICAgICAgIGV2ZW50LmRlY29kZUVycm9yID0gZXJyb3I7XG5cdCAgICAgICAgfVxuXHQgICAgfTtcblx0ICAgIEZyYWdtZW50UnVubmluZ0V2ZW50LnByb3RvdHlwZS5nZXRFbWl0ID0gZnVuY3Rpb24gKGV2ZW50KSB7XG5cdCAgICAgICAgdmFyIGVycm9ycyA9ICgwLCBsaWIkYS5jaGVja1Jlc3VsdEVycm9ycykoZXZlbnQuYXJncyk7XG5cdCAgICAgICAgaWYgKGVycm9ycy5sZW5ndGgpIHtcblx0ICAgICAgICAgICAgdGhyb3cgZXJyb3JzWzBdLmVycm9yO1xuXHQgICAgICAgIH1cblx0ICAgICAgICB2YXIgYXJncyA9IChldmVudC5hcmdzIHx8IFtdKS5zbGljZSgpO1xuXHQgICAgICAgIGFyZ3MucHVzaChldmVudCk7XG5cdCAgICAgICAgcmV0dXJuIGFyZ3M7XG5cdCAgICB9O1xuXHQgICAgcmV0dXJuIEZyYWdtZW50UnVubmluZ0V2ZW50O1xuXHR9KFJ1bm5pbmdFdmVudCkpO1xuXHQvLyBBIFdpbGRjYXJkIEV2ZW50IHdpbGwgYXR0ZW1wdCB0byBwb3B1bGF0ZTpcblx0Ly8gIC0gZXZlbnQgICAgICAgICAgICBUaGUgbmFtZSBvZiB0aGUgZXZlbnQgbmFtZVxuXHQvLyAgLSBldmVudFNpZ25hdHVyZSAgIFRoZSBmdWxsIHNpZ25hdHVyZSBvZiB0aGUgZXZlbnRcblx0Ly8gIC0gZGVjb2RlICAgICAgICAgICBBIGZ1bmN0aW9uIHRvIGRlY29kZSBkYXRhIGFuZCB0b3BpY3Ncblx0Ly8gIC0gYXJncyAgICAgICAgICAgICBUaGUgZGVjb2RlZCBkYXRhIGFuZCB0b3BpY3Ncblx0dmFyIFdpbGRjYXJkUnVubmluZ0V2ZW50ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuXHQgICAgX19leHRlbmRzKFdpbGRjYXJkUnVubmluZ0V2ZW50LCBfc3VwZXIpO1xuXHQgICAgZnVuY3Rpb24gV2lsZGNhcmRSdW5uaW5nRXZlbnQoYWRkcmVzcywgY29udHJhY3RJbnRlcmZhY2UpIHtcblx0ICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBcIipcIiwgeyBhZGRyZXNzOiBhZGRyZXNzIH0pIHx8IHRoaXM7XG5cdCAgICAgICAgKDAsIGxpYiQzLmRlZmluZVJlYWRPbmx5KShfdGhpcywgXCJhZGRyZXNzXCIsIGFkZHJlc3MpO1xuXHQgICAgICAgICgwLCBsaWIkMy5kZWZpbmVSZWFkT25seSkoX3RoaXMsIFwiaW50ZXJmYWNlXCIsIGNvbnRyYWN0SW50ZXJmYWNlKTtcblx0ICAgICAgICByZXR1cm4gX3RoaXM7XG5cdCAgICB9XG5cdCAgICBXaWxkY2FyZFJ1bm5pbmdFdmVudC5wcm90b3R5cGUucHJlcGFyZUV2ZW50ID0gZnVuY3Rpb24gKGV2ZW50KSB7XG5cdCAgICAgICAgdmFyIF90aGlzID0gdGhpcztcblx0ICAgICAgICBfc3VwZXIucHJvdG90eXBlLnByZXBhcmVFdmVudC5jYWxsKHRoaXMsIGV2ZW50KTtcblx0ICAgICAgICB0cnkge1xuXHQgICAgICAgICAgICB2YXIgcGFyc2VkXzEgPSB0aGlzLmludGVyZmFjZS5wYXJzZUxvZyhldmVudCk7XG5cdCAgICAgICAgICAgIGV2ZW50LmV2ZW50ID0gcGFyc2VkXzEubmFtZTtcblx0ICAgICAgICAgICAgZXZlbnQuZXZlbnRTaWduYXR1cmUgPSBwYXJzZWRfMS5zaWduYXR1cmU7XG5cdCAgICAgICAgICAgIGV2ZW50LmRlY29kZSA9IGZ1bmN0aW9uIChkYXRhLCB0b3BpY3MpIHtcblx0ICAgICAgICAgICAgICAgIHJldHVybiBfdGhpcy5pbnRlcmZhY2UuZGVjb2RlRXZlbnRMb2cocGFyc2VkXzEuZXZlbnRGcmFnbWVudCwgZGF0YSwgdG9waWNzKTtcblx0ICAgICAgICAgICAgfTtcblx0ICAgICAgICAgICAgZXZlbnQuYXJncyA9IHBhcnNlZF8xLmFyZ3M7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGNhdGNoIChlcnJvcikge1xuXHQgICAgICAgICAgICAvLyBObyBtYXRjaGluZyBldmVudFxuXHQgICAgICAgIH1cblx0ICAgIH07XG5cdCAgICByZXR1cm4gV2lsZGNhcmRSdW5uaW5nRXZlbnQ7XG5cdH0oUnVubmluZ0V2ZW50KSk7XG5cdHZhciBCYXNlQ29udHJhY3QgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG5cdCAgICBmdW5jdGlvbiBCYXNlQ29udHJhY3QoYWRkcmVzc09yTmFtZSwgY29udHJhY3RJbnRlcmZhY2UsIHNpZ25lck9yUHJvdmlkZXIpIHtcblx0ICAgICAgICB2YXIgX25ld1RhcmdldCA9IHRoaXMuY29uc3RydWN0b3I7XG5cdCAgICAgICAgdmFyIF90aGlzID0gdGhpcztcblx0ICAgICAgICBsb2dnZXIuY2hlY2tOZXcoX25ld1RhcmdldCwgQ29udHJhY3QpO1xuXHQgICAgICAgIC8vIEBUT0RPOiBNYXliZSBzdGlsbCBjaGVjayB0aGUgYWRkcmVzc09yTmFtZSBsb29rcyBsaWtlIGEgdmFsaWQgYWRkcmVzcyBvciBuYW1lP1xuXHQgICAgICAgIC8vYWRkcmVzcyA9IGdldEFkZHJlc3MoYWRkcmVzcyk7XG5cdCAgICAgICAgKDAsIGxpYiQzLmRlZmluZVJlYWRPbmx5KSh0aGlzLCBcImludGVyZmFjZVwiLCAoMCwgbGliJDMuZ2V0U3RhdGljKShfbmV3VGFyZ2V0LCBcImdldEludGVyZmFjZVwiKShjb250cmFjdEludGVyZmFjZSkpO1xuXHQgICAgICAgIGlmIChzaWduZXJPclByb3ZpZGVyID09IG51bGwpIHtcblx0ICAgICAgICAgICAgKDAsIGxpYiQzLmRlZmluZVJlYWRPbmx5KSh0aGlzLCBcInByb3ZpZGVyXCIsIG51bGwpO1xuXHQgICAgICAgICAgICAoMCwgbGliJDMuZGVmaW5lUmVhZE9ubHkpKHRoaXMsIFwic2lnbmVyXCIsIG51bGwpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBlbHNlIGlmIChsaWIkYy5TaWduZXIuaXNTaWduZXIoc2lnbmVyT3JQcm92aWRlcikpIHtcblx0ICAgICAgICAgICAgKDAsIGxpYiQzLmRlZmluZVJlYWRPbmx5KSh0aGlzLCBcInByb3ZpZGVyXCIsIHNpZ25lck9yUHJvdmlkZXIucHJvdmlkZXIgfHwgbnVsbCk7XG5cdCAgICAgICAgICAgICgwLCBsaWIkMy5kZWZpbmVSZWFkT25seSkodGhpcywgXCJzaWduZXJcIiwgc2lnbmVyT3JQcm92aWRlcik7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGVsc2UgaWYgKGxpYiRiLlByb3ZpZGVyLmlzUHJvdmlkZXIoc2lnbmVyT3JQcm92aWRlcikpIHtcblx0ICAgICAgICAgICAgKDAsIGxpYiQzLmRlZmluZVJlYWRPbmx5KSh0aGlzLCBcInByb3ZpZGVyXCIsIHNpZ25lck9yUHJvdmlkZXIpO1xuXHQgICAgICAgICAgICAoMCwgbGliJDMuZGVmaW5lUmVhZE9ubHkpKHRoaXMsIFwic2lnbmVyXCIsIG51bGwpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBlbHNlIHtcblx0ICAgICAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcImludmFsaWQgc2lnbmVyIG9yIHByb3ZpZGVyXCIsIFwic2lnbmVyT3JQcm92aWRlclwiLCBzaWduZXJPclByb3ZpZGVyKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgKDAsIGxpYiQzLmRlZmluZVJlYWRPbmx5KSh0aGlzLCBcImNhbGxTdGF0aWNcIiwge30pO1xuXHQgICAgICAgICgwLCBsaWIkMy5kZWZpbmVSZWFkT25seSkodGhpcywgXCJlc3RpbWF0ZUdhc1wiLCB7fSk7XG5cdCAgICAgICAgKDAsIGxpYiQzLmRlZmluZVJlYWRPbmx5KSh0aGlzLCBcImZ1bmN0aW9uc1wiLCB7fSk7XG5cdCAgICAgICAgKDAsIGxpYiQzLmRlZmluZVJlYWRPbmx5KSh0aGlzLCBcInBvcHVsYXRlVHJhbnNhY3Rpb25cIiwge30pO1xuXHQgICAgICAgICgwLCBsaWIkMy5kZWZpbmVSZWFkT25seSkodGhpcywgXCJmaWx0ZXJzXCIsIHt9KTtcblx0ICAgICAgICB7XG5cdCAgICAgICAgICAgIHZhciB1bmlxdWVGaWx0ZXJzXzEgPSB7fTtcblx0ICAgICAgICAgICAgT2JqZWN0LmtleXModGhpcy5pbnRlcmZhY2UuZXZlbnRzKS5mb3JFYWNoKGZ1bmN0aW9uIChldmVudFNpZ25hdHVyZSkge1xuXHQgICAgICAgICAgICAgICAgdmFyIGV2ZW50ID0gX3RoaXMuaW50ZXJmYWNlLmV2ZW50c1tldmVudFNpZ25hdHVyZV07XG5cdCAgICAgICAgICAgICAgICAoMCwgbGliJDMuZGVmaW5lUmVhZE9ubHkpKF90aGlzLmZpbHRlcnMsIGV2ZW50U2lnbmF0dXJlLCBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIGFyZ3MgPSBbXTtcblx0ICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBhcmdzW19pXSA9IGFyZ3VtZW50c1tfaV07XG5cdCAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGFkZHJlc3M6IF90aGlzLmFkZHJlc3MsXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHRvcGljczogX3RoaXMuaW50ZXJmYWNlLmVuY29kZUZpbHRlclRvcGljcyhldmVudCwgYXJncylcblx0ICAgICAgICAgICAgICAgICAgICB9O1xuXHQgICAgICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgICAgICAgICBpZiAoIXVuaXF1ZUZpbHRlcnNfMVtldmVudC5uYW1lXSkge1xuXHQgICAgICAgICAgICAgICAgICAgIHVuaXF1ZUZpbHRlcnNfMVtldmVudC5uYW1lXSA9IFtdO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgdW5pcXVlRmlsdGVyc18xW2V2ZW50Lm5hbWVdLnB1c2goZXZlbnRTaWduYXR1cmUpO1xuXHQgICAgICAgICAgICB9KTtcblx0ICAgICAgICAgICAgT2JqZWN0LmtleXModW5pcXVlRmlsdGVyc18xKS5mb3JFYWNoKGZ1bmN0aW9uIChuYW1lKSB7XG5cdCAgICAgICAgICAgICAgICB2YXIgZmlsdGVycyA9IHVuaXF1ZUZpbHRlcnNfMVtuYW1lXTtcblx0ICAgICAgICAgICAgICAgIGlmIChmaWx0ZXJzLmxlbmd0aCA9PT0gMSkge1xuXHQgICAgICAgICAgICAgICAgICAgICgwLCBsaWIkMy5kZWZpbmVSZWFkT25seSkoX3RoaXMuZmlsdGVycywgbmFtZSwgX3RoaXMuZmlsdGVyc1tmaWx0ZXJzWzBdXSk7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICBlbHNlIHtcblx0ICAgICAgICAgICAgICAgICAgICBsb2dnZXIud2FybihcIkR1cGxpY2F0ZSBkZWZpbml0aW9uIG9mIFwiICsgbmFtZSArIFwiIChcIiArIGZpbHRlcnMuam9pbihcIiwgXCIpICsgXCIpXCIpO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB9KTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgKDAsIGxpYiQzLmRlZmluZVJlYWRPbmx5KSh0aGlzLCBcIl9ydW5uaW5nRXZlbnRzXCIsIHt9KTtcblx0ICAgICAgICAoMCwgbGliJDMuZGVmaW5lUmVhZE9ubHkpKHRoaXMsIFwiX3dyYXBwZWRFbWl0c1wiLCB7fSk7XG5cdCAgICAgICAgaWYgKGFkZHJlc3NPck5hbWUgPT0gbnVsbCkge1xuXHQgICAgICAgICAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwiaW52YWxpZCBjb250cmFjdCBhZGRyZXNzIG9yIEVOUyBuYW1lXCIsIFwiYWRkcmVzc09yTmFtZVwiLCBhZGRyZXNzT3JOYW1lKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgKDAsIGxpYiQzLmRlZmluZVJlYWRPbmx5KSh0aGlzLCBcImFkZHJlc3NcIiwgYWRkcmVzc09yTmFtZSk7XG5cdCAgICAgICAgaWYgKHRoaXMucHJvdmlkZXIpIHtcblx0ICAgICAgICAgICAgKDAsIGxpYiQzLmRlZmluZVJlYWRPbmx5KSh0aGlzLCBcInJlc29sdmVkQWRkcmVzc1wiLCByZXNvbHZlTmFtZSh0aGlzLnByb3ZpZGVyLCBhZGRyZXNzT3JOYW1lKSk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGVsc2Uge1xuXHQgICAgICAgICAgICB0cnkge1xuXHQgICAgICAgICAgICAgICAgKDAsIGxpYiQzLmRlZmluZVJlYWRPbmx5KSh0aGlzLCBcInJlc29sdmVkQWRkcmVzc1wiLCBQcm9taXNlLnJlc29sdmUoKDAsIGxpYiQ2LmdldEFkZHJlc3MpKGFkZHJlc3NPck5hbWUpKSk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG5cdCAgICAgICAgICAgICAgICAvLyBXaXRob3V0IGEgcHJvdmlkZXIsIHdlIGNhbm5vdCB1c2UgRU5TIG5hbWVzXG5cdCAgICAgICAgICAgICAgICBsb2dnZXIudGhyb3dFcnJvcihcInByb3ZpZGVyIGlzIHJlcXVpcmVkIHRvIHVzZSBFTlMgbmFtZSBhcyBjb250cmFjdCBhZGRyZXNzXCIsIGxpYi5Mb2dnZXIuZXJyb3JzLlVOU1VQUE9SVEVEX09QRVJBVElPTiwge1xuXHQgICAgICAgICAgICAgICAgICAgIG9wZXJhdGlvbjogXCJuZXcgQ29udHJhY3RcIlxuXHQgICAgICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9XG5cdCAgICAgICAgdmFyIHVuaXF1ZU5hbWVzID0ge307XG5cdCAgICAgICAgdmFyIHVuaXF1ZVNpZ25hdHVyZXMgPSB7fTtcblx0ICAgICAgICBPYmplY3Qua2V5cyh0aGlzLmludGVyZmFjZS5mdW5jdGlvbnMpLmZvckVhY2goZnVuY3Rpb24gKHNpZ25hdHVyZSkge1xuXHQgICAgICAgICAgICB2YXIgZnJhZ21lbnQgPSBfdGhpcy5pbnRlcmZhY2UuZnVuY3Rpb25zW3NpZ25hdHVyZV07XG5cdCAgICAgICAgICAgIC8vIENoZWNrIHRoYXQgdGhlIHNpZ25hdHVyZSBpcyB1bmlxdWU7IGlmIG5vdCB0aGUgQUJJIGdlbmVyYXRpb24gaGFzXG5cdCAgICAgICAgICAgIC8vIG5vdCBiZWVuIGNsZWFuZWQgb3IgbWF5IGJlIGluY29ycmVjdGx5IGdlbmVyYXRlZFxuXHQgICAgICAgICAgICBpZiAodW5pcXVlU2lnbmF0dXJlc1tzaWduYXR1cmVdKSB7XG5cdCAgICAgICAgICAgICAgICBsb2dnZXIud2FybihcIkR1cGxpY2F0ZSBBQkkgZW50cnkgZm9yIFwiICsgSlNPTi5zdHJpbmdpZnkoc2lnbmF0dXJlKSk7XG5cdCAgICAgICAgICAgICAgICByZXR1cm47XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgdW5pcXVlU2lnbmF0dXJlc1tzaWduYXR1cmVdID0gdHJ1ZTtcblx0ICAgICAgICAgICAgLy8gVHJhY2sgdW5pcXVlIG5hbWVzOyB3ZSBvbmx5IGV4cG9zZSBiYXJlIG5hbWVkIGZ1bmN0aW9ucyBpZiB0aGV5XG5cdCAgICAgICAgICAgIC8vIGFyZSBhbWJpZ3VvdXNcblx0ICAgICAgICAgICAge1xuXHQgICAgICAgICAgICAgICAgdmFyIG5hbWVfMSA9IGZyYWdtZW50Lm5hbWU7XG5cdCAgICAgICAgICAgICAgICBpZiAoIXVuaXF1ZU5hbWVzW1wiJVwiICsgbmFtZV8xXSkge1xuXHQgICAgICAgICAgICAgICAgICAgIHVuaXF1ZU5hbWVzW1wiJVwiICsgbmFtZV8xXSA9IFtdO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgdW5pcXVlTmFtZXNbXCIlXCIgKyBuYW1lXzFdLnB1c2goc2lnbmF0dXJlKTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICBpZiAoX3RoaXNbc2lnbmF0dXJlXSA9PSBudWxsKSB7XG5cdCAgICAgICAgICAgICAgICAoMCwgbGliJDMuZGVmaW5lUmVhZE9ubHkpKF90aGlzLCBzaWduYXR1cmUsIGJ1aWxkRGVmYXVsdChfdGhpcywgZnJhZ21lbnQsIHRydWUpKTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAvLyBXZSBkbyBub3QgY29sbGFwc2Ugc2ltcGxlIGNhbGxzIG9uIHRoaXMgYnVja2V0LCB3aGljaCBhbGxvd3Ncblx0ICAgICAgICAgICAgLy8gZnJhbWV3b3JrcyB0byBzYWZlbHkgdXNlIHRoaXMgd2l0aG91dCBpbnRyb3NwZWN0aW9uIGFzIHdlbGwgYXNcblx0ICAgICAgICAgICAgLy8gYWxsb3dzIGRlY29kaW5nIGVycm9yIHJlY292ZXJ5LlxuXHQgICAgICAgICAgICBpZiAoX3RoaXMuZnVuY3Rpb25zW3NpZ25hdHVyZV0gPT0gbnVsbCkge1xuXHQgICAgICAgICAgICAgICAgKDAsIGxpYiQzLmRlZmluZVJlYWRPbmx5KShfdGhpcy5mdW5jdGlvbnMsIHNpZ25hdHVyZSwgYnVpbGREZWZhdWx0KF90aGlzLCBmcmFnbWVudCwgZmFsc2UpKTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICBpZiAoX3RoaXMuY2FsbFN0YXRpY1tzaWduYXR1cmVdID09IG51bGwpIHtcblx0ICAgICAgICAgICAgICAgICgwLCBsaWIkMy5kZWZpbmVSZWFkT25seSkoX3RoaXMuY2FsbFN0YXRpYywgc2lnbmF0dXJlLCBidWlsZENhbGwoX3RoaXMsIGZyYWdtZW50LCB0cnVlKSk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgaWYgKF90aGlzLnBvcHVsYXRlVHJhbnNhY3Rpb25bc2lnbmF0dXJlXSA9PSBudWxsKSB7XG5cdCAgICAgICAgICAgICAgICAoMCwgbGliJDMuZGVmaW5lUmVhZE9ubHkpKF90aGlzLnBvcHVsYXRlVHJhbnNhY3Rpb24sIHNpZ25hdHVyZSwgYnVpbGRQb3B1bGF0ZShfdGhpcywgZnJhZ21lbnQpKTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICBpZiAoX3RoaXMuZXN0aW1hdGVHYXNbc2lnbmF0dXJlXSA9PSBudWxsKSB7XG5cdCAgICAgICAgICAgICAgICAoMCwgbGliJDMuZGVmaW5lUmVhZE9ubHkpKF90aGlzLmVzdGltYXRlR2FzLCBzaWduYXR1cmUsIGJ1aWxkRXN0aW1hdGUoX3RoaXMsIGZyYWdtZW50KSk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9KTtcblx0ICAgICAgICBPYmplY3Qua2V5cyh1bmlxdWVOYW1lcykuZm9yRWFjaChmdW5jdGlvbiAobmFtZSkge1xuXHQgICAgICAgICAgICAvLyBBbWJpZ3VvdXMgbmFtZXMgdG8gbm90IGdldCBhdHRhY2hlZCBhcyBiYXJlIG5hbWVzXG5cdCAgICAgICAgICAgIHZhciBzaWduYXR1cmVzID0gdW5pcXVlTmFtZXNbbmFtZV07XG5cdCAgICAgICAgICAgIGlmIChzaWduYXR1cmVzLmxlbmd0aCA+IDEpIHtcblx0ICAgICAgICAgICAgICAgIHJldHVybjtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAvLyBTdHJpcCBvZmYgdGhlIGxlYWRpbmcgXCIlXCIgdXNlZCBmb3IgcHJvdG90eXBlIHByb3RlY3Rpb25cblx0ICAgICAgICAgICAgbmFtZSA9IG5hbWUuc3Vic3RyaW5nKDEpO1xuXHQgICAgICAgICAgICB2YXIgc2lnbmF0dXJlID0gc2lnbmF0dXJlc1swXTtcblx0ICAgICAgICAgICAgLy8gSWYgb3ZlcndyaXRpbmcgYSBtZW1iZXIgcHJvcGVydHkgdGhhdCBpcyBudWxsLCBzd2FsbG93IHRoZSBlcnJvclxuXHQgICAgICAgICAgICB0cnkge1xuXHQgICAgICAgICAgICAgICAgaWYgKF90aGlzW25hbWVdID09IG51bGwpIHtcblx0ICAgICAgICAgICAgICAgICAgICAoMCwgbGliJDMuZGVmaW5lUmVhZE9ubHkpKF90aGlzLCBuYW1lLCBfdGhpc1tzaWduYXR1cmVdKTtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICBjYXRjaCAoZSkgeyB9XG5cdCAgICAgICAgICAgIGlmIChfdGhpcy5mdW5jdGlvbnNbbmFtZV0gPT0gbnVsbCkge1xuXHQgICAgICAgICAgICAgICAgKDAsIGxpYiQzLmRlZmluZVJlYWRPbmx5KShfdGhpcy5mdW5jdGlvbnMsIG5hbWUsIF90aGlzLmZ1bmN0aW9uc1tzaWduYXR1cmVdKTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICBpZiAoX3RoaXMuY2FsbFN0YXRpY1tuYW1lXSA9PSBudWxsKSB7XG5cdCAgICAgICAgICAgICAgICAoMCwgbGliJDMuZGVmaW5lUmVhZE9ubHkpKF90aGlzLmNhbGxTdGF0aWMsIG5hbWUsIF90aGlzLmNhbGxTdGF0aWNbc2lnbmF0dXJlXSk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgaWYgKF90aGlzLnBvcHVsYXRlVHJhbnNhY3Rpb25bbmFtZV0gPT0gbnVsbCkge1xuXHQgICAgICAgICAgICAgICAgKDAsIGxpYiQzLmRlZmluZVJlYWRPbmx5KShfdGhpcy5wb3B1bGF0ZVRyYW5zYWN0aW9uLCBuYW1lLCBfdGhpcy5wb3B1bGF0ZVRyYW5zYWN0aW9uW3NpZ25hdHVyZV0pO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIGlmIChfdGhpcy5lc3RpbWF0ZUdhc1tuYW1lXSA9PSBudWxsKSB7XG5cdCAgICAgICAgICAgICAgICAoMCwgbGliJDMuZGVmaW5lUmVhZE9ubHkpKF90aGlzLmVzdGltYXRlR2FzLCBuYW1lLCBfdGhpcy5lc3RpbWF0ZUdhc1tzaWduYXR1cmVdKTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH0pO1xuXHQgICAgfVxuXHQgICAgQmFzZUNvbnRyYWN0LmdldENvbnRyYWN0QWRkcmVzcyA9IGZ1bmN0aW9uICh0cmFuc2FjdGlvbikge1xuXHQgICAgICAgIHJldHVybiAoMCwgbGliJDYuZ2V0Q29udHJhY3RBZGRyZXNzKSh0cmFuc2FjdGlvbik7XG5cdCAgICB9O1xuXHQgICAgQmFzZUNvbnRyYWN0LmdldEludGVyZmFjZSA9IGZ1bmN0aW9uIChjb250cmFjdEludGVyZmFjZSkge1xuXHQgICAgICAgIGlmIChsaWIkYS5JbnRlcmZhY2UuaXNJbnRlcmZhY2UoY29udHJhY3RJbnRlcmZhY2UpKSB7XG5cdCAgICAgICAgICAgIHJldHVybiBjb250cmFjdEludGVyZmFjZTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgcmV0dXJuIG5ldyBsaWIkYS5JbnRlcmZhY2UoY29udHJhY3RJbnRlcmZhY2UpO1xuXHQgICAgfTtcblx0ICAgIC8vIEBUT0RPOiBBbGxvdyB0aW1lb3V0P1xuXHQgICAgQmFzZUNvbnRyYWN0LnByb3RvdHlwZS5kZXBsb3llZCA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICByZXR1cm4gdGhpcy5fZGVwbG95ZWQoKTtcblx0ICAgIH07XG5cdCAgICBCYXNlQ29udHJhY3QucHJvdG90eXBlLl9kZXBsb3llZCA9IGZ1bmN0aW9uIChibG9ja1RhZykge1xuXHQgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cdCAgICAgICAgaWYgKCF0aGlzLl9kZXBsb3llZFByb21pc2UpIHtcblx0ICAgICAgICAgICAgLy8gSWYgd2Ugd2VyZSBqdXN0IGRlcGxveWVkLCB3ZSBrbm93IHRoZSB0cmFuc2FjdGlvbiB3ZSBzaG91bGQgb2NjdXIgaW5cblx0ICAgICAgICAgICAgaWYgKHRoaXMuZGVwbG95VHJhbnNhY3Rpb24pIHtcblx0ICAgICAgICAgICAgICAgIHRoaXMuX2RlcGxveWVkUHJvbWlzZSA9IHRoaXMuZGVwbG95VHJhbnNhY3Rpb24ud2FpdCgpLnRoZW4oZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICAgICAgICAgIHJldHVybiBfdGhpcztcblx0ICAgICAgICAgICAgICAgIH0pO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIGVsc2Uge1xuXHQgICAgICAgICAgICAgICAgLy8gQFRPRE86IE9uY2Ugd2UgYWxsb3cgYSB0aW1lb3V0IHRvIGJlIHBhc3NlZCBpbiwgd2Ugd2lsbCB3YWl0XG5cdCAgICAgICAgICAgICAgICAvLyB1cCB0byB0aGF0IG1hbnkgYmxvY2tzIGZvciBnZXRDb2RlXG5cdCAgICAgICAgICAgICAgICAvLyBPdGhlcndpc2UsIHBvbGwgZm9yIG91ciBjb2RlIHRvIGJlIGRlcGxveWVkXG5cdCAgICAgICAgICAgICAgICB0aGlzLl9kZXBsb3llZFByb21pc2UgPSB0aGlzLnByb3ZpZGVyLmdldENvZGUodGhpcy5hZGRyZXNzLCBibG9ja1RhZykudGhlbihmdW5jdGlvbiAoY29kZSkge1xuXHQgICAgICAgICAgICAgICAgICAgIGlmIChjb2RlID09PSBcIjB4XCIpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgbG9nZ2VyLnRocm93RXJyb3IoXCJjb250cmFjdCBub3QgZGVwbG95ZWRcIiwgbGliLkxvZ2dlci5lcnJvcnMuVU5TVVBQT1JURURfT1BFUkFUSU9OLCB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250cmFjdEFkZHJlc3M6IF90aGlzLmFkZHJlc3MsXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcGVyYXRpb246IFwiZ2V0RGVwbG95ZWRcIlxuXHQgICAgICAgICAgICAgICAgICAgICAgICB9KTtcblx0ICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF90aGlzO1xuXHQgICAgICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9XG5cdCAgICAgICAgcmV0dXJuIHRoaXMuX2RlcGxveWVkUHJvbWlzZTtcblx0ICAgIH07XG5cdCAgICAvLyBAVE9ETzpcblx0ICAgIC8vIGVzdGltYXRlRmFsbGJhY2sob3ZlcnJpZGVzPzogVHJhbnNhY3Rpb25SZXF1ZXN0KTogUHJvbWlzZTxCaWdOdW1iZXI+XG5cdCAgICAvLyBAVE9ETzpcblx0ICAgIC8vIGVzdGltYXRlRGVwbG95KGJ5dGVjb2RlOiBzdHJpbmcsIC4uLmFyZ3MpOiBQcm9taXNlPEJpZ051bWJlcj5cblx0ICAgIEJhc2VDb250cmFjdC5wcm90b3R5cGUuZmFsbGJhY2sgPSBmdW5jdGlvbiAob3ZlcnJpZGVzKSB7XG5cdCAgICAgICAgdmFyIF90aGlzID0gdGhpcztcblx0ICAgICAgICBpZiAoIXRoaXMuc2lnbmVyKSB7XG5cdCAgICAgICAgICAgIGxvZ2dlci50aHJvd0Vycm9yKFwic2VuZGluZyBhIHRyYW5zYWN0aW9ucyByZXF1aXJlIGEgc2lnbmVyXCIsIGxpYi5Mb2dnZXIuZXJyb3JzLlVOU1VQUE9SVEVEX09QRVJBVElPTiwgeyBvcGVyYXRpb246IFwic2VuZFRyYW5zYWN0aW9uKGZhbGxiYWNrKVwiIH0pO1xuXHQgICAgICAgIH1cblx0ICAgICAgICB2YXIgdHggPSAoMCwgbGliJDMuc2hhbGxvd0NvcHkpKG92ZXJyaWRlcyB8fCB7fSk7XG5cdCAgICAgICAgW1wiZnJvbVwiLCBcInRvXCJdLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuXHQgICAgICAgICAgICBpZiAodHhba2V5XSA9PSBudWxsKSB7XG5cdCAgICAgICAgICAgICAgICByZXR1cm47XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgbG9nZ2VyLnRocm93RXJyb3IoXCJjYW5ub3Qgb3ZlcnJpZGUgXCIgKyBrZXksIGxpYi5Mb2dnZXIuZXJyb3JzLlVOU1VQUE9SVEVEX09QRVJBVElPTiwgeyBvcGVyYXRpb246IGtleSB9KTtcblx0ICAgICAgICB9KTtcblx0ICAgICAgICB0eC50byA9IHRoaXMucmVzb2x2ZWRBZGRyZXNzO1xuXHQgICAgICAgIHJldHVybiB0aGlzLmRlcGxveWVkKCkudGhlbihmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIHJldHVybiBfdGhpcy5zaWduZXIuc2VuZFRyYW5zYWN0aW9uKHR4KTtcblx0ICAgICAgICB9KTtcblx0ICAgIH07XG5cdCAgICAvLyBSZWNvbm5lY3QgdG8gYSBkaWZmZXJlbnQgc2lnbmVyIG9yIHByb3ZpZGVyXG5cdCAgICBCYXNlQ29udHJhY3QucHJvdG90eXBlLmNvbm5lY3QgPSBmdW5jdGlvbiAoc2lnbmVyT3JQcm92aWRlcikge1xuXHQgICAgICAgIGlmICh0eXBlb2YgKHNpZ25lck9yUHJvdmlkZXIpID09PSBcInN0cmluZ1wiKSB7XG5cdCAgICAgICAgICAgIHNpZ25lck9yUHJvdmlkZXIgPSBuZXcgbGliJGMuVm9pZFNpZ25lcihzaWduZXJPclByb3ZpZGVyLCB0aGlzLnByb3ZpZGVyKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgdmFyIGNvbnRyYWN0ID0gbmV3ICh0aGlzLmNvbnN0cnVjdG9yKSh0aGlzLmFkZHJlc3MsIHRoaXMuaW50ZXJmYWNlLCBzaWduZXJPclByb3ZpZGVyKTtcblx0ICAgICAgICBpZiAodGhpcy5kZXBsb3lUcmFuc2FjdGlvbikge1xuXHQgICAgICAgICAgICAoMCwgbGliJDMuZGVmaW5lUmVhZE9ubHkpKGNvbnRyYWN0LCBcImRlcGxveVRyYW5zYWN0aW9uXCIsIHRoaXMuZGVwbG95VHJhbnNhY3Rpb24pO1xuXHQgICAgICAgIH1cblx0ICAgICAgICByZXR1cm4gY29udHJhY3Q7XG5cdCAgICB9O1xuXHQgICAgLy8gUmUtYXR0YWNoIHRvIGEgZGlmZmVyZW50IG9uLWNoYWluIGluc3RhbmNlIG9mIHRoaXMgY29udHJhY3Rcblx0ICAgIEJhc2VDb250cmFjdC5wcm90b3R5cGUuYXR0YWNoID0gZnVuY3Rpb24gKGFkZHJlc3NPck5hbWUpIHtcblx0ICAgICAgICByZXR1cm4gbmV3ICh0aGlzLmNvbnN0cnVjdG9yKShhZGRyZXNzT3JOYW1lLCB0aGlzLmludGVyZmFjZSwgdGhpcy5zaWduZXIgfHwgdGhpcy5wcm92aWRlcik7XG5cdCAgICB9O1xuXHQgICAgQmFzZUNvbnRyYWN0LmlzSW5kZXhlZCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuXHQgICAgICAgIHJldHVybiBsaWIkYS5JbmRleGVkLmlzSW5kZXhlZCh2YWx1ZSk7XG5cdCAgICB9O1xuXHQgICAgQmFzZUNvbnRyYWN0LnByb3RvdHlwZS5fbm9ybWFsaXplUnVubmluZ0V2ZW50ID0gZnVuY3Rpb24gKHJ1bm5pbmdFdmVudCkge1xuXHQgICAgICAgIC8vIEFscmVhZHkgaGF2ZSBhbiBpbnN0YW5jZSBvZiB0aGlzIGV2ZW50IHJ1bm5pbmc7IHdlIGNhbiByZS11c2UgaXRcblx0ICAgICAgICBpZiAodGhpcy5fcnVubmluZ0V2ZW50c1tydW5uaW5nRXZlbnQudGFnXSkge1xuXHQgICAgICAgICAgICByZXR1cm4gdGhpcy5fcnVubmluZ0V2ZW50c1tydW5uaW5nRXZlbnQudGFnXTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgcmV0dXJuIHJ1bm5pbmdFdmVudDtcblx0ICAgIH07XG5cdCAgICBCYXNlQ29udHJhY3QucHJvdG90eXBlLl9nZXRSdW5uaW5nRXZlbnQgPSBmdW5jdGlvbiAoZXZlbnROYW1lKSB7XG5cdCAgICAgICAgaWYgKHR5cGVvZiAoZXZlbnROYW1lKSA9PT0gXCJzdHJpbmdcIikge1xuXHQgICAgICAgICAgICAvLyBMaXN0ZW4gZm9yIFwiZXJyb3JcIiBldmVudHMgKGlmIHlvdXIgY29udHJhY3QgaGFzIGFuIGVycm9yIGV2ZW50LCBpbmNsdWRlXG5cdCAgICAgICAgICAgIC8vIHRoZSBmdWxsIHNpZ25hdHVyZSB0byBieXBhc3MgdGhpcyBzcGVjaWFsIGV2ZW50IGtleXdvcmQpXG5cdCAgICAgICAgICAgIGlmIChldmVudE5hbWUgPT09IFwiZXJyb3JcIikge1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX25vcm1hbGl6ZVJ1bm5pbmdFdmVudChuZXcgRXJyb3JSdW5uaW5nRXZlbnQoKSk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgLy8gTGlzdGVuIGZvciBhbnkgZXZlbnQgdGhhdCBpcyByZWdpc3RlcmVkXG5cdCAgICAgICAgICAgIGlmIChldmVudE5hbWUgPT09IFwiZXZlbnRcIikge1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX25vcm1hbGl6ZVJ1bm5pbmdFdmVudChuZXcgUnVubmluZ0V2ZW50KFwiZXZlbnRcIiwgbnVsbCkpO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIC8vIExpc3RlbiBmb3IgYW55IGV2ZW50XG5cdCAgICAgICAgICAgIGlmIChldmVudE5hbWUgPT09IFwiKlwiKSB7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fbm9ybWFsaXplUnVubmluZ0V2ZW50KG5ldyBXaWxkY2FyZFJ1bm5pbmdFdmVudCh0aGlzLmFkZHJlc3MsIHRoaXMuaW50ZXJmYWNlKSk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgLy8gR2V0IHRoZSBldmVudCBGcmFnbWVudCAodGhyb3dzIGlmIGFtYmlndW91cy91bmtub3duIGV2ZW50KVxuXHQgICAgICAgICAgICB2YXIgZnJhZ21lbnQgPSB0aGlzLmludGVyZmFjZS5nZXRFdmVudChldmVudE5hbWUpO1xuXHQgICAgICAgICAgICByZXR1cm4gdGhpcy5fbm9ybWFsaXplUnVubmluZ0V2ZW50KG5ldyBGcmFnbWVudFJ1bm5pbmdFdmVudCh0aGlzLmFkZHJlc3MsIHRoaXMuaW50ZXJmYWNlLCBmcmFnbWVudCkpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICAvLyBXZSBoYXZlIHRvcGljcyB0byBmaWx0ZXIgYnkuLi5cblx0ICAgICAgICBpZiAoZXZlbnROYW1lLnRvcGljcyAmJiBldmVudE5hbWUudG9waWNzLmxlbmd0aCA+IDApIHtcblx0ICAgICAgICAgICAgLy8gSXMgaXQgYSBrbm93biB0b3BpY2hhc2g/ICh0aHJvd3MgaWYgbm8gbWF0Y2hpbmcgdG9waWNoYXNoKVxuXHQgICAgICAgICAgICB0cnkge1xuXHQgICAgICAgICAgICAgICAgdmFyIHRvcGljID0gZXZlbnROYW1lLnRvcGljc1swXTtcblx0ICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgKHRvcGljKSAhPT0gXCJzdHJpbmdcIikge1xuXHQgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImludmFsaWQgdG9waWNcIik7IC8vIEBUT0RPOiBNYXkgaGFwcGVuIGZvciBhbm9ueW1vdXMgZXZlbnRzXG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICB2YXIgZnJhZ21lbnQgPSB0aGlzLmludGVyZmFjZS5nZXRFdmVudCh0b3BpYyk7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fbm9ybWFsaXplUnVubmluZ0V2ZW50KG5ldyBGcmFnbWVudFJ1bm5pbmdFdmVudCh0aGlzLmFkZHJlc3MsIHRoaXMuaW50ZXJmYWNlLCBmcmFnbWVudCwgZXZlbnROYW1lLnRvcGljcykpO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIGNhdGNoIChlcnJvcikgeyB9XG5cdCAgICAgICAgICAgIC8vIEZpbHRlciBieSB0aGUgdW5rbm93biB0b3BpY2hhc2hcblx0ICAgICAgICAgICAgdmFyIGZpbHRlciA9IHtcblx0ICAgICAgICAgICAgICAgIGFkZHJlc3M6IHRoaXMuYWRkcmVzcyxcblx0ICAgICAgICAgICAgICAgIHRvcGljczogZXZlbnROYW1lLnRvcGljc1xuXHQgICAgICAgICAgICB9O1xuXHQgICAgICAgICAgICByZXR1cm4gdGhpcy5fbm9ybWFsaXplUnVubmluZ0V2ZW50KG5ldyBSdW5uaW5nRXZlbnQoZ2V0RXZlbnRUYWcoZmlsdGVyKSwgZmlsdGVyKSk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHJldHVybiB0aGlzLl9ub3JtYWxpemVSdW5uaW5nRXZlbnQobmV3IFdpbGRjYXJkUnVubmluZ0V2ZW50KHRoaXMuYWRkcmVzcywgdGhpcy5pbnRlcmZhY2UpKTtcblx0ICAgIH07XG5cdCAgICBCYXNlQ29udHJhY3QucHJvdG90eXBlLl9jaGVja1J1bm5pbmdFdmVudHMgPSBmdW5jdGlvbiAocnVubmluZ0V2ZW50KSB7XG5cdCAgICAgICAgaWYgKHJ1bm5pbmdFdmVudC5saXN0ZW5lckNvdW50KCkgPT09IDApIHtcblx0ICAgICAgICAgICAgZGVsZXRlIHRoaXMuX3J1bm5pbmdFdmVudHNbcnVubmluZ0V2ZW50LnRhZ107XG5cdCAgICAgICAgICAgIC8vIElmIHdlIGhhdmUgYSBwb2xsZXIgZm9yIHRoaXMsIHJlbW92ZSBpdFxuXHQgICAgICAgICAgICB2YXIgZW1pdCA9IHRoaXMuX3dyYXBwZWRFbWl0c1tydW5uaW5nRXZlbnQudGFnXTtcblx0ICAgICAgICAgICAgaWYgKGVtaXQgJiYgcnVubmluZ0V2ZW50LmZpbHRlcikge1xuXHQgICAgICAgICAgICAgICAgdGhpcy5wcm92aWRlci5vZmYocnVubmluZ0V2ZW50LmZpbHRlciwgZW1pdCk7XG5cdCAgICAgICAgICAgICAgICBkZWxldGUgdGhpcy5fd3JhcHBlZEVtaXRzW3J1bm5pbmdFdmVudC50YWddO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfVxuXHQgICAgfTtcblx0ICAgIC8vIFN1YmNsYXNzZXMgY2FuIG92ZXJyaWRlIHRoaXMgdG8gZ3JhY2VmdWxseSByZWNvdmVyXG5cdCAgICAvLyBmcm9tIHBhcnNlIGVycm9ycyBpZiB0aGV5IHdpc2hcblx0ICAgIEJhc2VDb250cmFjdC5wcm90b3R5cGUuX3dyYXBFdmVudCA9IGZ1bmN0aW9uIChydW5uaW5nRXZlbnQsIGxvZywgbGlzdGVuZXIpIHtcblx0ICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXHQgICAgICAgIHZhciBldmVudCA9ICgwLCBsaWIkMy5kZWVwQ29weSkobG9nKTtcblx0ICAgICAgICBldmVudC5yZW1vdmVMaXN0ZW5lciA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgaWYgKCFsaXN0ZW5lcikge1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIHJ1bm5pbmdFdmVudC5yZW1vdmVMaXN0ZW5lcihsaXN0ZW5lcik7XG5cdCAgICAgICAgICAgIF90aGlzLl9jaGVja1J1bm5pbmdFdmVudHMocnVubmluZ0V2ZW50KTtcblx0ICAgICAgICB9O1xuXHQgICAgICAgIGV2ZW50LmdldEJsb2NrID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gX3RoaXMucHJvdmlkZXIuZ2V0QmxvY2sobG9nLmJsb2NrSGFzaCk7IH07XG5cdCAgICAgICAgZXZlbnQuZ2V0VHJhbnNhY3Rpb24gPSBmdW5jdGlvbiAoKSB7IHJldHVybiBfdGhpcy5wcm92aWRlci5nZXRUcmFuc2FjdGlvbihsb2cudHJhbnNhY3Rpb25IYXNoKTsgfTtcblx0ICAgICAgICBldmVudC5nZXRUcmFuc2FjdGlvblJlY2VpcHQgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBfdGhpcy5wcm92aWRlci5nZXRUcmFuc2FjdGlvblJlY2VpcHQobG9nLnRyYW5zYWN0aW9uSGFzaCk7IH07XG5cdCAgICAgICAgLy8gVGhpcyBtYXkgdGhyb3cgaWYgdGhlIHRvcGljcyBhbmQgZGF0YSBtaXNtYXRjaCB0aGUgc2lnbmF0dXJlXG5cdCAgICAgICAgcnVubmluZ0V2ZW50LnByZXBhcmVFdmVudChldmVudCk7XG5cdCAgICAgICAgcmV0dXJuIGV2ZW50O1xuXHQgICAgfTtcblx0ICAgIEJhc2VDb250cmFjdC5wcm90b3R5cGUuX2FkZEV2ZW50TGlzdGVuZXIgPSBmdW5jdGlvbiAocnVubmluZ0V2ZW50LCBsaXN0ZW5lciwgb25jZSkge1xuXHQgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cdCAgICAgICAgaWYgKCF0aGlzLnByb3ZpZGVyKSB7XG5cdCAgICAgICAgICAgIGxvZ2dlci50aHJvd0Vycm9yKFwiZXZlbnRzIHJlcXVpcmUgYSBwcm92aWRlciBvciBhIHNpZ25lciB3aXRoIGEgcHJvdmlkZXJcIiwgbGliLkxvZ2dlci5lcnJvcnMuVU5TVVBQT1JURURfT1BFUkFUSU9OLCB7IG9wZXJhdGlvbjogXCJvbmNlXCIgfSk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHJ1bm5pbmdFdmVudC5hZGRMaXN0ZW5lcihsaXN0ZW5lciwgb25jZSk7XG5cdCAgICAgICAgLy8gVHJhY2sgdGhpcyBydW5uaW5nIGV2ZW50IGFuZCBpdHMgbGlzdGVuZXJzIChtYXkgYWxyZWFkeSBiZSB0aGVyZTsgYnV0IG5vIGhhcmQgaW4gdXBkYXRpbmcpXG5cdCAgICAgICAgdGhpcy5fcnVubmluZ0V2ZW50c1tydW5uaW5nRXZlbnQudGFnXSA9IHJ1bm5pbmdFdmVudDtcblx0ICAgICAgICAvLyBJZiB3ZSBhcmUgbm90IHBvbGxpbmcgdGhlIHByb3ZpZGVyLCBzdGFydCBwb2xsaW5nXG5cdCAgICAgICAgaWYgKCF0aGlzLl93cmFwcGVkRW1pdHNbcnVubmluZ0V2ZW50LnRhZ10pIHtcblx0ICAgICAgICAgICAgdmFyIHdyYXBwZWRFbWl0ID0gZnVuY3Rpb24gKGxvZykge1xuXHQgICAgICAgICAgICAgICAgdmFyIGV2ZW50ID0gX3RoaXMuX3dyYXBFdmVudChydW5uaW5nRXZlbnQsIGxvZywgbGlzdGVuZXIpO1xuXHQgICAgICAgICAgICAgICAgLy8gVHJ5IHRvIGVtaXQgdGhlIHJlc3VsdCBmb3IgdGhlIHBhcmFtZXRlcml6ZWQgZXZlbnQuLi5cblx0ICAgICAgICAgICAgICAgIGlmIChldmVudC5kZWNvZGVFcnJvciA9PSBudWxsKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgdHJ5IHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGFyZ3MgPSBydW5uaW5nRXZlbnQuZ2V0RW1pdChldmVudCk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLmVtaXQuYXBwbHkoX3RoaXMsIF9fc3ByZWFkQXJyYXkoW3J1bm5pbmdFdmVudC5maWx0ZXJdLCBhcmdzLCBmYWxzZSkpO1xuXHQgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgZXZlbnQuZGVjb2RlRXJyb3IgPSBlcnJvci5lcnJvcjtcblx0ICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAvLyBBbHdheXMgZW1pdCBcImV2ZW50XCIgZm9yIGZyYWdtZW50LWJhc2UgZXZlbnRzXG5cdCAgICAgICAgICAgICAgICBpZiAocnVubmluZ0V2ZW50LmZpbHRlciAhPSBudWxsKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgX3RoaXMuZW1pdChcImV2ZW50XCIsIGV2ZW50KTtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgIC8vIEVtaXQgXCJlcnJvclwiIGlmIHRoZXJlIHdhcyBhbiBlcnJvclxuXHQgICAgICAgICAgICAgICAgaWYgKGV2ZW50LmRlY29kZUVycm9yICE9IG51bGwpIHtcblx0ICAgICAgICAgICAgICAgICAgICBfdGhpcy5lbWl0KFwiZXJyb3JcIiwgZXZlbnQuZGVjb2RlRXJyb3IsIGV2ZW50KTtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgfTtcblx0ICAgICAgICAgICAgdGhpcy5fd3JhcHBlZEVtaXRzW3J1bm5pbmdFdmVudC50YWddID0gd3JhcHBlZEVtaXQ7XG5cdCAgICAgICAgICAgIC8vIFNwZWNpYWwgZXZlbnRzLCBsaWtlIFwiZXJyb3JcIiBkbyBub3QgaGF2ZSBhIGZpbHRlclxuXHQgICAgICAgICAgICBpZiAocnVubmluZ0V2ZW50LmZpbHRlciAhPSBudWxsKSB7XG5cdCAgICAgICAgICAgICAgICB0aGlzLnByb3ZpZGVyLm9uKHJ1bm5pbmdFdmVudC5maWx0ZXIsIHdyYXBwZWRFbWl0KTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH1cblx0ICAgIH07XG5cdCAgICBCYXNlQ29udHJhY3QucHJvdG90eXBlLnF1ZXJ5RmlsdGVyID0gZnVuY3Rpb24gKGV2ZW50LCBmcm9tQmxvY2tPckJsb2NraGFzaCwgdG9CbG9jaykge1xuXHQgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cdCAgICAgICAgdmFyIHJ1bm5pbmdFdmVudCA9IHRoaXMuX2dldFJ1bm5pbmdFdmVudChldmVudCk7XG5cdCAgICAgICAgdmFyIGZpbHRlciA9ICgwLCBsaWIkMy5zaGFsbG93Q29weSkocnVubmluZ0V2ZW50LmZpbHRlcik7XG5cdCAgICAgICAgaWYgKHR5cGVvZiAoZnJvbUJsb2NrT3JCbG9ja2hhc2gpID09PSBcInN0cmluZ1wiICYmICgwLCBsaWIkMS5pc0hleFN0cmluZykoZnJvbUJsb2NrT3JCbG9ja2hhc2gsIDMyKSkge1xuXHQgICAgICAgICAgICBpZiAodG9CbG9jayAhPSBudWxsKSB7XG5cdCAgICAgICAgICAgICAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwiY2Fubm90IHNwZWNpZnkgdG9CbG9jayB3aXRoIGJsb2NraGFzaFwiLCBcInRvQmxvY2tcIiwgdG9CbG9jayk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgZmlsdGVyLmJsb2NrSGFzaCA9IGZyb21CbG9ja09yQmxvY2toYXNoO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBlbHNlIHtcblx0ICAgICAgICAgICAgZmlsdGVyLmZyb21CbG9jayA9ICgoZnJvbUJsb2NrT3JCbG9ja2hhc2ggIT0gbnVsbCkgPyBmcm9tQmxvY2tPckJsb2NraGFzaCA6IDApO1xuXHQgICAgICAgICAgICBmaWx0ZXIudG9CbG9jayA9ICgodG9CbG9jayAhPSBudWxsKSA/IHRvQmxvY2sgOiBcImxhdGVzdFwiKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgcmV0dXJuIHRoaXMucHJvdmlkZXIuZ2V0TG9ncyhmaWx0ZXIpLnRoZW4oZnVuY3Rpb24gKGxvZ3MpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIGxvZ3MubWFwKGZ1bmN0aW9uIChsb2cpIHsgcmV0dXJuIF90aGlzLl93cmFwRXZlbnQocnVubmluZ0V2ZW50LCBsb2csIG51bGwpOyB9KTtcblx0ICAgICAgICB9KTtcblx0ICAgIH07XG5cdCAgICBCYXNlQ29udHJhY3QucHJvdG90eXBlLm9uID0gZnVuY3Rpb24gKGV2ZW50LCBsaXN0ZW5lcikge1xuXHQgICAgICAgIHRoaXMuX2FkZEV2ZW50TGlzdGVuZXIodGhpcy5fZ2V0UnVubmluZ0V2ZW50KGV2ZW50KSwgbGlzdGVuZXIsIGZhbHNlKTtcblx0ICAgICAgICByZXR1cm4gdGhpcztcblx0ICAgIH07XG5cdCAgICBCYXNlQ29udHJhY3QucHJvdG90eXBlLm9uY2UgPSBmdW5jdGlvbiAoZXZlbnQsIGxpc3RlbmVyKSB7XG5cdCAgICAgICAgdGhpcy5fYWRkRXZlbnRMaXN0ZW5lcih0aGlzLl9nZXRSdW5uaW5nRXZlbnQoZXZlbnQpLCBsaXN0ZW5lciwgdHJ1ZSk7XG5cdCAgICAgICAgcmV0dXJuIHRoaXM7XG5cdCAgICB9O1xuXHQgICAgQmFzZUNvbnRyYWN0LnByb3RvdHlwZS5lbWl0ID0gZnVuY3Rpb24gKGV2ZW50TmFtZSkge1xuXHQgICAgICAgIHZhciBhcmdzID0gW107XG5cdCAgICAgICAgZm9yICh2YXIgX2kgPSAxOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcblx0ICAgICAgICAgICAgYXJnc1tfaSAtIDFdID0gYXJndW1lbnRzW19pXTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgaWYgKCF0aGlzLnByb3ZpZGVyKSB7XG5cdCAgICAgICAgICAgIHJldHVybiBmYWxzZTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgdmFyIHJ1bm5pbmdFdmVudCA9IHRoaXMuX2dldFJ1bm5pbmdFdmVudChldmVudE5hbWUpO1xuXHQgICAgICAgIHZhciByZXN1bHQgPSAocnVubmluZ0V2ZW50LnJ1bihhcmdzKSA+IDApO1xuXHQgICAgICAgIC8vIE1heSBoYXZlIGRyYWluZWQgYWxsIHRoZSBcIm9uY2VcIiBldmVudHM7IGNoZWNrIGZvciBsaXZpbmcgZXZlbnRzXG5cdCAgICAgICAgdGhpcy5fY2hlY2tSdW5uaW5nRXZlbnRzKHJ1bm5pbmdFdmVudCk7XG5cdCAgICAgICAgcmV0dXJuIHJlc3VsdDtcblx0ICAgIH07XG5cdCAgICBCYXNlQ29udHJhY3QucHJvdG90eXBlLmxpc3RlbmVyQ291bnQgPSBmdW5jdGlvbiAoZXZlbnROYW1lKSB7XG5cdCAgICAgICAgdmFyIF90aGlzID0gdGhpcztcblx0ICAgICAgICBpZiAoIXRoaXMucHJvdmlkZXIpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIDA7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGlmIChldmVudE5hbWUgPT0gbnVsbCkge1xuXHQgICAgICAgICAgICByZXR1cm4gT2JqZWN0LmtleXModGhpcy5fcnVubmluZ0V2ZW50cykucmVkdWNlKGZ1bmN0aW9uIChhY2N1bSwga2V5KSB7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gYWNjdW0gKyBfdGhpcy5fcnVubmluZ0V2ZW50c1trZXldLmxpc3RlbmVyQ291bnQoKTtcblx0ICAgICAgICAgICAgfSwgMCk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHJldHVybiB0aGlzLl9nZXRSdW5uaW5nRXZlbnQoZXZlbnROYW1lKS5saXN0ZW5lckNvdW50KCk7XG5cdCAgICB9O1xuXHQgICAgQmFzZUNvbnRyYWN0LnByb3RvdHlwZS5saXN0ZW5lcnMgPSBmdW5jdGlvbiAoZXZlbnROYW1lKSB7XG5cdCAgICAgICAgaWYgKCF0aGlzLnByb3ZpZGVyKSB7XG5cdCAgICAgICAgICAgIHJldHVybiBbXTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgaWYgKGV2ZW50TmFtZSA9PSBudWxsKSB7XG5cdCAgICAgICAgICAgIHZhciByZXN1bHRfMSA9IFtdO1xuXHQgICAgICAgICAgICBmb3IgKHZhciB0YWcgaW4gdGhpcy5fcnVubmluZ0V2ZW50cykge1xuXHQgICAgICAgICAgICAgICAgdGhpcy5fcnVubmluZ0V2ZW50c1t0YWddLmxpc3RlbmVycygpLmZvckVhY2goZnVuY3Rpb24gKGxpc3RlbmVyKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgcmVzdWx0XzEucHVzaChsaXN0ZW5lcik7XG5cdCAgICAgICAgICAgICAgICB9KTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICByZXR1cm4gcmVzdWx0XzE7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHJldHVybiB0aGlzLl9nZXRSdW5uaW5nRXZlbnQoZXZlbnROYW1lKS5saXN0ZW5lcnMoKTtcblx0ICAgIH07XG5cdCAgICBCYXNlQ29udHJhY3QucHJvdG90eXBlLnJlbW92ZUFsbExpc3RlbmVycyA9IGZ1bmN0aW9uIChldmVudE5hbWUpIHtcblx0ICAgICAgICBpZiAoIXRoaXMucHJvdmlkZXIpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGlmIChldmVudE5hbWUgPT0gbnVsbCkge1xuXHQgICAgICAgICAgICBmb3IgKHZhciB0YWcgaW4gdGhpcy5fcnVubmluZ0V2ZW50cykge1xuXHQgICAgICAgICAgICAgICAgdmFyIHJ1bm5pbmdFdmVudF8xID0gdGhpcy5fcnVubmluZ0V2ZW50c1t0YWddO1xuXHQgICAgICAgICAgICAgICAgcnVubmluZ0V2ZW50XzEucmVtb3ZlQWxsTGlzdGVuZXJzKCk7XG5cdCAgICAgICAgICAgICAgICB0aGlzLl9jaGVja1J1bm5pbmdFdmVudHMocnVubmluZ0V2ZW50XzEpO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIHJldHVybiB0aGlzO1xuXHQgICAgICAgIH1cblx0ICAgICAgICAvLyBEZWxldGUgYW55IGxpc3RlbmVyc1xuXHQgICAgICAgIHZhciBydW5uaW5nRXZlbnQgPSB0aGlzLl9nZXRSdW5uaW5nRXZlbnQoZXZlbnROYW1lKTtcblx0ICAgICAgICBydW5uaW5nRXZlbnQucmVtb3ZlQWxsTGlzdGVuZXJzKCk7XG5cdCAgICAgICAgdGhpcy5fY2hlY2tSdW5uaW5nRXZlbnRzKHJ1bm5pbmdFdmVudCk7XG5cdCAgICAgICAgcmV0dXJuIHRoaXM7XG5cdCAgICB9O1xuXHQgICAgQmFzZUNvbnRyYWN0LnByb3RvdHlwZS5vZmYgPSBmdW5jdGlvbiAoZXZlbnROYW1lLCBsaXN0ZW5lcikge1xuXHQgICAgICAgIGlmICghdGhpcy5wcm92aWRlcikge1xuXHQgICAgICAgICAgICByZXR1cm4gdGhpcztcblx0ICAgICAgICB9XG5cdCAgICAgICAgdmFyIHJ1bm5pbmdFdmVudCA9IHRoaXMuX2dldFJ1bm5pbmdFdmVudChldmVudE5hbWUpO1xuXHQgICAgICAgIHJ1bm5pbmdFdmVudC5yZW1vdmVMaXN0ZW5lcihsaXN0ZW5lcik7XG5cdCAgICAgICAgdGhpcy5fY2hlY2tSdW5uaW5nRXZlbnRzKHJ1bm5pbmdFdmVudCk7XG5cdCAgICAgICAgcmV0dXJuIHRoaXM7XG5cdCAgICB9O1xuXHQgICAgQmFzZUNvbnRyYWN0LnByb3RvdHlwZS5yZW1vdmVMaXN0ZW5lciA9IGZ1bmN0aW9uIChldmVudE5hbWUsIGxpc3RlbmVyKSB7XG5cdCAgICAgICAgcmV0dXJuIHRoaXMub2ZmKGV2ZW50TmFtZSwgbGlzdGVuZXIpO1xuXHQgICAgfTtcblx0ICAgIHJldHVybiBCYXNlQ29udHJhY3Q7XG5cdH0oKSk7XG5cdGV4cG9ydHMuQmFzZUNvbnRyYWN0ID0gQmFzZUNvbnRyYWN0O1xuXHR2YXIgQ29udHJhY3QgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG5cdCAgICBfX2V4dGVuZHMoQ29udHJhY3QsIF9zdXBlcik7XG5cdCAgICBmdW5jdGlvbiBDb250cmFjdCgpIHtcblx0ICAgICAgICByZXR1cm4gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG5cdCAgICB9XG5cdCAgICByZXR1cm4gQ29udHJhY3Q7XG5cdH0oQmFzZUNvbnRyYWN0KSk7XG5cdGV4cG9ydHMuQ29udHJhY3QgPSBDb250cmFjdDtcblx0dmFyIENvbnRyYWN0RmFjdG9yeSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcblx0ICAgIGZ1bmN0aW9uIENvbnRyYWN0RmFjdG9yeShjb250cmFjdEludGVyZmFjZSwgYnl0ZWNvZGUsIHNpZ25lcikge1xuXHQgICAgICAgIHZhciBfbmV3VGFyZ2V0ID0gdGhpcy5jb25zdHJ1Y3Rvcjtcblx0ICAgICAgICB2YXIgYnl0ZWNvZGVIZXggPSBudWxsO1xuXHQgICAgICAgIGlmICh0eXBlb2YgKGJ5dGVjb2RlKSA9PT0gXCJzdHJpbmdcIikge1xuXHQgICAgICAgICAgICBieXRlY29kZUhleCA9IGJ5dGVjb2RlO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBlbHNlIGlmICgoMCwgbGliJDEuaXNCeXRlcykoYnl0ZWNvZGUpKSB7XG5cdCAgICAgICAgICAgIGJ5dGVjb2RlSGV4ID0gKDAsIGxpYiQxLmhleGxpZnkpKGJ5dGVjb2RlKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgZWxzZSBpZiAoYnl0ZWNvZGUgJiYgdHlwZW9mIChieXRlY29kZS5vYmplY3QpID09PSBcInN0cmluZ1wiKSB7XG5cdCAgICAgICAgICAgIC8vIEFsbG93IHRoZSBieXRlY29kZSBvYmplY3QgZnJvbSB0aGUgU29saWRpdHkgY29tcGlsZXJcblx0ICAgICAgICAgICAgYnl0ZWNvZGVIZXggPSBieXRlY29kZS5vYmplY3Q7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGVsc2Uge1xuXHQgICAgICAgICAgICAvLyBDcmFzaCBpbiB0aGUgbmV4dCB2ZXJpZmljYXRpb24gc3RlcFxuXHQgICAgICAgICAgICBieXRlY29kZUhleCA9IFwiIVwiO1xuXHQgICAgICAgIH1cblx0ICAgICAgICAvLyBNYWtlIHN1cmUgaXQgaXMgMHggcHJlZml4ZWRcblx0ICAgICAgICBpZiAoYnl0ZWNvZGVIZXguc3Vic3RyaW5nKDAsIDIpICE9PSBcIjB4XCIpIHtcblx0ICAgICAgICAgICAgYnl0ZWNvZGVIZXggPSBcIjB4XCIgKyBieXRlY29kZUhleDtcblx0ICAgICAgICB9XG5cdCAgICAgICAgLy8gTWFrZSBzdXJlIHRoZSBmaW5hbCByZXN1bHQgaXMgdmFsaWQgYnl0ZWNvZGVcblx0ICAgICAgICBpZiAoISgwLCBsaWIkMS5pc0hleFN0cmluZykoYnl0ZWNvZGVIZXgpIHx8IChieXRlY29kZUhleC5sZW5ndGggJSAyKSkge1xuXHQgICAgICAgICAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwiaW52YWxpZCBieXRlY29kZVwiLCBcImJ5dGVjb2RlXCIsIGJ5dGVjb2RlKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgLy8gSWYgd2UgaGF2ZSBhIHNpZ25lciwgbWFrZSBzdXJlIGl0IGlzIHZhbGlkXG5cdCAgICAgICAgaWYgKHNpZ25lciAmJiAhbGliJGMuU2lnbmVyLmlzU2lnbmVyKHNpZ25lcikpIHtcblx0ICAgICAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcImludmFsaWQgc2lnbmVyXCIsIFwic2lnbmVyXCIsIHNpZ25lcik7XG5cdCAgICAgICAgfVxuXHQgICAgICAgICgwLCBsaWIkMy5kZWZpbmVSZWFkT25seSkodGhpcywgXCJieXRlY29kZVwiLCBieXRlY29kZUhleCk7XG5cdCAgICAgICAgKDAsIGxpYiQzLmRlZmluZVJlYWRPbmx5KSh0aGlzLCBcImludGVyZmFjZVwiLCAoMCwgbGliJDMuZ2V0U3RhdGljKShfbmV3VGFyZ2V0LCBcImdldEludGVyZmFjZVwiKShjb250cmFjdEludGVyZmFjZSkpO1xuXHQgICAgICAgICgwLCBsaWIkMy5kZWZpbmVSZWFkT25seSkodGhpcywgXCJzaWduZXJcIiwgc2lnbmVyIHx8IG51bGwpO1xuXHQgICAgfVxuXHQgICAgLy8gQFRPRE86IEZ1dHVyZTsgcmVuYW1lIHRvIHBvcHVsYXRlVHJhbnNhY3Rpb24/XG5cdCAgICBDb250cmFjdEZhY3RvcnkucHJvdG90eXBlLmdldERlcGxveVRyYW5zYWN0aW9uID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIHZhciBhcmdzID0gW107XG5cdCAgICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcblx0ICAgICAgICAgICAgYXJnc1tfaV0gPSBhcmd1bWVudHNbX2ldO1xuXHQgICAgICAgIH1cblx0ICAgICAgICB2YXIgdHggPSB7fTtcblx0ICAgICAgICAvLyBJZiB3ZSBoYXZlIDEgYWRkaXRpb25hbCBhcmd1bWVudCwgd2UgYWxsb3cgdHJhbnNhY3Rpb24gb3ZlcnJpZGVzXG5cdCAgICAgICAgaWYgKGFyZ3MubGVuZ3RoID09PSB0aGlzLmludGVyZmFjZS5kZXBsb3kuaW5wdXRzLmxlbmd0aCArIDEgJiYgdHlwZW9mIChhcmdzW2FyZ3MubGVuZ3RoIC0gMV0pID09PSBcIm9iamVjdFwiKSB7XG5cdCAgICAgICAgICAgIHR4ID0gKDAsIGxpYiQzLnNoYWxsb3dDb3B5KShhcmdzLnBvcCgpKTtcblx0ICAgICAgICAgICAgZm9yICh2YXIga2V5IGluIHR4KSB7XG5cdCAgICAgICAgICAgICAgICBpZiAoIWFsbG93ZWRUcmFuc2FjdGlvbktleXNba2V5XSkge1xuXHQgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcInVua25vd24gdHJhbnNhY3Rpb24gb3ZlcnJpZGUgXCIgKyBrZXkpO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfVxuXHQgICAgICAgIC8vIERvIG5vdCBhbGxvdyB0aGVzZSB0byBiZSBvdmVycmlkZGVuIGluIGEgZGVwbG95bWVudCB0cmFuc2FjdGlvblxuXHQgICAgICAgIFtcImRhdGFcIiwgXCJmcm9tXCIsIFwidG9cIl0uZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG5cdCAgICAgICAgICAgIGlmICh0eFtrZXldID09IG51bGwpIHtcblx0ICAgICAgICAgICAgICAgIHJldHVybjtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICBsb2dnZXIudGhyb3dFcnJvcihcImNhbm5vdCBvdmVycmlkZSBcIiArIGtleSwgbGliLkxvZ2dlci5lcnJvcnMuVU5TVVBQT1JURURfT1BFUkFUSU9OLCB7IG9wZXJhdGlvbjoga2V5IH0pO1xuXHQgICAgICAgIH0pO1xuXHQgICAgICAgIGlmICh0eC52YWx1ZSkge1xuXHQgICAgICAgICAgICB2YXIgdmFsdWUgPSBsaWIkMi5CaWdOdW1iZXIuZnJvbSh0eC52YWx1ZSk7XG5cdCAgICAgICAgICAgIGlmICghdmFsdWUuaXNaZXJvKCkgJiYgIXRoaXMuaW50ZXJmYWNlLmRlcGxveS5wYXlhYmxlKSB7XG5cdCAgICAgICAgICAgICAgICBsb2dnZXIudGhyb3dFcnJvcihcIm5vbi1wYXlhYmxlIGNvbnN0cnVjdG9yIGNhbm5vdCBvdmVycmlkZSB2YWx1ZVwiLCBsaWIuTG9nZ2VyLmVycm9ycy5VTlNVUFBPUlRFRF9PUEVSQVRJT04sIHtcblx0ICAgICAgICAgICAgICAgICAgICBvcGVyYXRpb246IFwib3ZlcnJpZGVzLnZhbHVlXCIsXG5cdCAgICAgICAgICAgICAgICAgICAgdmFsdWU6IHR4LnZhbHVlXG5cdCAgICAgICAgICAgICAgICB9KTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH1cblx0ICAgICAgICAvLyBNYWtlIHN1cmUgdGhlIGNhbGwgbWF0Y2hlcyB0aGUgY29uc3RydWN0b3Igc2lnbmF0dXJlXG5cdCAgICAgICAgbG9nZ2VyLmNoZWNrQXJndW1lbnRDb3VudChhcmdzLmxlbmd0aCwgdGhpcy5pbnRlcmZhY2UuZGVwbG95LmlucHV0cy5sZW5ndGgsIFwiIGluIENvbnRyYWN0IGNvbnN0cnVjdG9yXCIpO1xuXHQgICAgICAgIC8vIFNldCB0aGUgZGF0YSB0byB0aGUgYnl0ZWNvZGUgKyB0aGUgZW5jb2RlZCBjb25zdHJ1Y3RvciBhcmd1bWVudHNcblx0ICAgICAgICB0eC5kYXRhID0gKDAsIGxpYiQxLmhleGxpZnkpKCgwLCBsaWIkMS5jb25jYXQpKFtcblx0ICAgICAgICAgICAgdGhpcy5ieXRlY29kZSxcblx0ICAgICAgICAgICAgdGhpcy5pbnRlcmZhY2UuZW5jb2RlRGVwbG95KGFyZ3MpXG5cdCAgICAgICAgXSkpO1xuXHQgICAgICAgIHJldHVybiB0eDtcblx0ICAgIH07XG5cdCAgICBDb250cmFjdEZhY3RvcnkucHJvdG90eXBlLmRlcGxveSA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICB2YXIgYXJncyA9IFtdO1xuXHQgICAgICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG5cdCAgICAgICAgICAgIGFyZ3NbX2ldID0gYXJndW1lbnRzW19pXTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICB2YXIgb3ZlcnJpZGVzLCBwYXJhbXMsIHVuc2lnbmVkVHgsIHR4LCBhZGRyZXNzLCBjb250cmFjdDtcblx0ICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuXHQgICAgICAgICAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkge1xuXHQgICAgICAgICAgICAgICAgICAgIGNhc2UgMDpcblx0ICAgICAgICAgICAgICAgICAgICAgICAgb3ZlcnJpZGVzID0ge307XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIC8vIElmIDEgZXh0cmEgcGFyYW1ldGVyIHdhcyBwYXNzZWQgaW4sIGl0IGNvbnRhaW5zIG92ZXJyaWRlc1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBpZiAoYXJncy5sZW5ndGggPT09IHRoaXMuaW50ZXJmYWNlLmRlcGxveS5pbnB1dHMubGVuZ3RoICsgMSkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3ZlcnJpZGVzID0gYXJncy5wb3AoKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgICAgICAvLyBNYWtlIHN1cmUgdGhlIGNhbGwgbWF0Y2hlcyB0aGUgY29uc3RydWN0b3Igc2lnbmF0dXJlXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGxvZ2dlci5jaGVja0FyZ3VtZW50Q291bnQoYXJncy5sZW5ndGgsIHRoaXMuaW50ZXJmYWNlLmRlcGxveS5pbnB1dHMubGVuZ3RoLCBcIiBpbiBDb250cmFjdCBjb25zdHJ1Y3RvclwiKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgcmVzb2x2ZUFkZHJlc3Nlcyh0aGlzLnNpZ25lciwgYXJncywgdGhpcy5pbnRlcmZhY2UuZGVwbG95LmlucHV0cyldO1xuXHQgICAgICAgICAgICAgICAgICAgIGNhc2UgMTpcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcGFyYW1zID0gX2Euc2VudCgpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBwYXJhbXMucHVzaChvdmVycmlkZXMpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB1bnNpZ25lZFR4ID0gdGhpcy5nZXREZXBsb3lUcmFuc2FjdGlvbi5hcHBseSh0aGlzLCBwYXJhbXMpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCB0aGlzLnNpZ25lci5zZW5kVHJhbnNhY3Rpb24odW5zaWduZWRUeCldO1xuXHQgICAgICAgICAgICAgICAgICAgIGNhc2UgMjpcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdHggPSBfYS5zZW50KCk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGFkZHJlc3MgPSAoMCwgbGliJDMuZ2V0U3RhdGljKSh0aGlzLmNvbnN0cnVjdG9yLCBcImdldENvbnRyYWN0QWRkcmVzc1wiKSh0eCk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRyYWN0ID0gKDAsIGxpYiQzLmdldFN0YXRpYykodGhpcy5jb25zdHJ1Y3RvciwgXCJnZXRDb250cmFjdFwiKShhZGRyZXNzLCB0aGlzLmludGVyZmFjZSwgdGhpcy5zaWduZXIpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAvLyBBZGQgdGhlIG1vZGlmaWVkIHdhaXQgdGhhdCB3cmFwcyBldmVudHNcblx0ICAgICAgICAgICAgICAgICAgICAgICAgYWRkQ29udHJhY3RXYWl0KGNvbnRyYWN0LCB0eCk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICgwLCBsaWIkMy5kZWZpbmVSZWFkT25seSkoY29udHJhY3QsIFwiZGVwbG95VHJhbnNhY3Rpb25cIiwgdHgpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgY29udHJhY3RdO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB9KTtcblx0ICAgICAgICB9KTtcblx0ICAgIH07XG5cdCAgICBDb250cmFjdEZhY3RvcnkucHJvdG90eXBlLmF0dGFjaCA9IGZ1bmN0aW9uIChhZGRyZXNzKSB7XG5cdCAgICAgICAgcmV0dXJuICh0aGlzLmNvbnN0cnVjdG9yKS5nZXRDb250cmFjdChhZGRyZXNzLCB0aGlzLmludGVyZmFjZSwgdGhpcy5zaWduZXIpO1xuXHQgICAgfTtcblx0ICAgIENvbnRyYWN0RmFjdG9yeS5wcm90b3R5cGUuY29ubmVjdCA9IGZ1bmN0aW9uIChzaWduZXIpIHtcblx0ICAgICAgICByZXR1cm4gbmV3ICh0aGlzLmNvbnN0cnVjdG9yKSh0aGlzLmludGVyZmFjZSwgdGhpcy5ieXRlY29kZSwgc2lnbmVyKTtcblx0ICAgIH07XG5cdCAgICBDb250cmFjdEZhY3RvcnkuZnJvbVNvbGlkaXR5ID0gZnVuY3Rpb24gKGNvbXBpbGVyT3V0cHV0LCBzaWduZXIpIHtcblx0ICAgICAgICBpZiAoY29tcGlsZXJPdXRwdXQgPT0gbnVsbCkge1xuXHQgICAgICAgICAgICBsb2dnZXIudGhyb3dFcnJvcihcIm1pc3NpbmcgY29tcGlsZXIgb3V0cHV0XCIsIGxpYi5Mb2dnZXIuZXJyb3JzLk1JU1NJTkdfQVJHVU1FTlQsIHsgYXJndW1lbnQ6IFwiY29tcGlsZXJPdXRwdXRcIiB9KTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgaWYgKHR5cGVvZiAoY29tcGlsZXJPdXRwdXQpID09PSBcInN0cmluZ1wiKSB7XG5cdCAgICAgICAgICAgIGNvbXBpbGVyT3V0cHV0ID0gSlNPTi5wYXJzZShjb21waWxlck91dHB1dCk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHZhciBhYmkgPSBjb21waWxlck91dHB1dC5hYmk7XG5cdCAgICAgICAgdmFyIGJ5dGVjb2RlID0gbnVsbDtcblx0ICAgICAgICBpZiAoY29tcGlsZXJPdXRwdXQuYnl0ZWNvZGUpIHtcblx0ICAgICAgICAgICAgYnl0ZWNvZGUgPSBjb21waWxlck91dHB1dC5ieXRlY29kZTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgZWxzZSBpZiAoY29tcGlsZXJPdXRwdXQuZXZtICYmIGNvbXBpbGVyT3V0cHV0LmV2bS5ieXRlY29kZSkge1xuXHQgICAgICAgICAgICBieXRlY29kZSA9IGNvbXBpbGVyT3V0cHV0LmV2bS5ieXRlY29kZTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgcmV0dXJuIG5ldyB0aGlzKGFiaSwgYnl0ZWNvZGUsIHNpZ25lcik7XG5cdCAgICB9O1xuXHQgICAgQ29udHJhY3RGYWN0b3J5LmdldEludGVyZmFjZSA9IGZ1bmN0aW9uIChjb250cmFjdEludGVyZmFjZSkge1xuXHQgICAgICAgIHJldHVybiBDb250cmFjdC5nZXRJbnRlcmZhY2UoY29udHJhY3RJbnRlcmZhY2UpO1xuXHQgICAgfTtcblx0ICAgIENvbnRyYWN0RmFjdG9yeS5nZXRDb250cmFjdEFkZHJlc3MgPSBmdW5jdGlvbiAodHgpIHtcblx0ICAgICAgICByZXR1cm4gKDAsIGxpYiQ2LmdldENvbnRyYWN0QWRkcmVzcykodHgpO1xuXHQgICAgfTtcblx0ICAgIENvbnRyYWN0RmFjdG9yeS5nZXRDb250cmFjdCA9IGZ1bmN0aW9uIChhZGRyZXNzLCBjb250cmFjdEludGVyZmFjZSwgc2lnbmVyKSB7XG5cdCAgICAgICAgcmV0dXJuIG5ldyBDb250cmFjdChhZGRyZXNzLCBjb250cmFjdEludGVyZmFjZSwgc2lnbmVyKTtcblx0ICAgIH07XG5cdCAgICByZXR1cm4gQ29udHJhY3RGYWN0b3J5O1xuXHR9KCkpO1xuXHRleHBvcnRzLkNvbnRyYWN0RmFjdG9yeSA9IENvbnRyYWN0RmFjdG9yeTtcblxuXHR9KTtcblxuXHR2YXIgaW5kZXgkZiA9IC8qQF9fUFVSRV9fKi9nZXREZWZhdWx0RXhwb3J0RnJvbUNqcyhsaWIkZik7XG5cblx0dmFyIGxpYiRnID0gY3JlYXRlQ29tbW9uanNNb2R1bGUoZnVuY3Rpb24gKG1vZHVsZSwgZXhwb3J0cykge1xuXHRcInVzZSBzdHJpY3RcIjtcblx0LyoqXG5cdCAqIHZhciBiYXNleCA9IHJlcXVpcmUoXCJiYXNlLXhcIik7XG5cdCAqXG5cdCAqIFRoaXMgaW1wbGVtZW50YXRpb24gaXMgaGVhdmlseSBiYXNlZCBvbiBiYXNlLXguIFRoZSBtYWluIHJlYXNvbiB0b1xuXHQgKiBkZXZpYXRlIHdhcyB0byBwcmV2ZW50IHRoZSBkZXBlbmRlbmN5IG9mIEJ1ZmZlci5cblx0ICpcblx0ICogQ29udHJpYnV0b3JzOlxuXHQgKlxuXHQgKiBiYXNlLXggZW5jb2Rpbmdcblx0ICogRm9ya2VkIGZyb20gaHR0cHM6Ly9naXRodWIuY29tL2NyeXB0b2NvaW5qcy9iczU4XG5cdCAqIE9yaWdpbmFsbHkgd3JpdHRlbiBieSBNaWtlIEhlYXJuIGZvciBCaXRjb2luSlxuXHQgKiBDb3B5cmlnaHQgKGMpIDIwMTEgR29vZ2xlIEluY1xuXHQgKiBQb3J0ZWQgdG8gSmF2YVNjcmlwdCBieSBTdGVmYW4gVGhvbWFzXG5cdCAqIE1lcmdlZCBCdWZmZXIgcmVmYWN0b3JpbmdzIGZyb20gYmFzZTU4LW5hdGl2ZSBieSBTdGVwaGVuIFBhaXJcblx0ICogQ29weXJpZ2h0IChjKSAyMDEzIEJpdFBheSBJbmNcblx0ICpcblx0ICogVGhlIE1JVCBMaWNlbnNlIChNSVQpXG5cdCAqXG5cdCAqIENvcHlyaWdodCBiYXNlLXggY29udHJpYnV0b3JzIChjKSAyMDE2XG5cdCAqXG5cdCAqIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG5cdCAqIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSxcblx0ICogdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvblxuXHQgKiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSxcblx0ICogYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlXG5cdCAqIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG5cdCAqXG5cdCAqIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluXG5cdCAqIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuXG5cdCAqIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1Jcblx0ICogSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG5cdCAqIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuXHQgKiBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG5cdCAqIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HXG5cdCAqIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1Ncblx0ICogSU4gVEhFIFNPRlRXQVJFLlxuXHQgKlxuXHQgKi9cblx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuXHRleHBvcnRzLkJhc2U1OCA9IGV4cG9ydHMuQmFzZTMyID0gZXhwb3J0cy5CYXNlWCA9IHZvaWQgMDtcblxuXG5cdHZhciBCYXNlWCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcblx0ICAgIGZ1bmN0aW9uIEJhc2VYKGFscGhhYmV0KSB7XG5cdCAgICAgICAgKDAsIGxpYiQzLmRlZmluZVJlYWRPbmx5KSh0aGlzLCBcImFscGhhYmV0XCIsIGFscGhhYmV0KTtcblx0ICAgICAgICAoMCwgbGliJDMuZGVmaW5lUmVhZE9ubHkpKHRoaXMsIFwiYmFzZVwiLCBhbHBoYWJldC5sZW5ndGgpO1xuXHQgICAgICAgICgwLCBsaWIkMy5kZWZpbmVSZWFkT25seSkodGhpcywgXCJfYWxwaGFiZXRNYXBcIiwge30pO1xuXHQgICAgICAgICgwLCBsaWIkMy5kZWZpbmVSZWFkT25seSkodGhpcywgXCJfbGVhZGVyXCIsIGFscGhhYmV0LmNoYXJBdCgwKSk7XG5cdCAgICAgICAgLy8gcHJlLWNvbXB1dGUgbG9va3VwIHRhYmxlXG5cdCAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhbHBoYWJldC5sZW5ndGg7IGkrKykge1xuXHQgICAgICAgICAgICB0aGlzLl9hbHBoYWJldE1hcFthbHBoYWJldC5jaGFyQXQoaSldID0gaTtcblx0ICAgICAgICB9XG5cdCAgICB9XG5cdCAgICBCYXNlWC5wcm90b3R5cGUuZW5jb2RlID0gZnVuY3Rpb24gKHZhbHVlKSB7XG5cdCAgICAgICAgdmFyIHNvdXJjZSA9ICgwLCBsaWIkMS5hcnJheWlmeSkodmFsdWUpO1xuXHQgICAgICAgIGlmIChzb3VyY2UubGVuZ3RoID09PSAwKSB7XG5cdCAgICAgICAgICAgIHJldHVybiBcIlwiO1xuXHQgICAgICAgIH1cblx0ICAgICAgICB2YXIgZGlnaXRzID0gWzBdO1xuXHQgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc291cmNlLmxlbmd0aDsgKytpKSB7XG5cdCAgICAgICAgICAgIHZhciBjYXJyeSA9IHNvdXJjZVtpXTtcblx0ICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBkaWdpdHMubGVuZ3RoOyArK2opIHtcblx0ICAgICAgICAgICAgICAgIGNhcnJ5ICs9IGRpZ2l0c1tqXSA8PCA4O1xuXHQgICAgICAgICAgICAgICAgZGlnaXRzW2pdID0gY2FycnkgJSB0aGlzLmJhc2U7XG5cdCAgICAgICAgICAgICAgICBjYXJyeSA9IChjYXJyeSAvIHRoaXMuYmFzZSkgfCAwO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIHdoaWxlIChjYXJyeSA+IDApIHtcblx0ICAgICAgICAgICAgICAgIGRpZ2l0cy5wdXNoKGNhcnJ5ICUgdGhpcy5iYXNlKTtcblx0ICAgICAgICAgICAgICAgIGNhcnJ5ID0gKGNhcnJ5IC8gdGhpcy5iYXNlKSB8IDA7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9XG5cdCAgICAgICAgdmFyIHN0cmluZyA9IFwiXCI7XG5cdCAgICAgICAgLy8gZGVhbCB3aXRoIGxlYWRpbmcgemVyb3Ncblx0ICAgICAgICBmb3IgKHZhciBrID0gMDsgc291cmNlW2tdID09PSAwICYmIGsgPCBzb3VyY2UubGVuZ3RoIC0gMTsgKytrKSB7XG5cdCAgICAgICAgICAgIHN0cmluZyArPSB0aGlzLl9sZWFkZXI7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIC8vIGNvbnZlcnQgZGlnaXRzIHRvIGEgc3RyaW5nXG5cdCAgICAgICAgZm9yICh2YXIgcSA9IGRpZ2l0cy5sZW5ndGggLSAxOyBxID49IDA7IC0tcSkge1xuXHQgICAgICAgICAgICBzdHJpbmcgKz0gdGhpcy5hbHBoYWJldFtkaWdpdHNbcV1dO1xuXHQgICAgICAgIH1cblx0ICAgICAgICByZXR1cm4gc3RyaW5nO1xuXHQgICAgfTtcblx0ICAgIEJhc2VYLnByb3RvdHlwZS5kZWNvZGUgPSBmdW5jdGlvbiAodmFsdWUpIHtcblx0ICAgICAgICBpZiAodHlwZW9mICh2YWx1ZSkgIT09IFwic3RyaW5nXCIpIHtcblx0ICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkV4cGVjdGVkIFN0cmluZ1wiKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgdmFyIGJ5dGVzID0gW107XG5cdCAgICAgICAgaWYgKHZhbHVlLmxlbmd0aCA9PT0gMCkge1xuXHQgICAgICAgICAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoYnl0ZXMpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBieXRlcy5wdXNoKDApO1xuXHQgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdmFsdWUubGVuZ3RoOyBpKyspIHtcblx0ICAgICAgICAgICAgdmFyIGJ5dGUgPSB0aGlzLl9hbHBoYWJldE1hcFt2YWx1ZVtpXV07XG5cdCAgICAgICAgICAgIGlmIChieXRlID09PSB1bmRlZmluZWQpIHtcblx0ICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIk5vbi1iYXNlXCIgKyB0aGlzLmJhc2UgKyBcIiBjaGFyYWN0ZXJcIik7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgdmFyIGNhcnJ5ID0gYnl0ZTtcblx0ICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBieXRlcy5sZW5ndGg7ICsraikge1xuXHQgICAgICAgICAgICAgICAgY2FycnkgKz0gYnl0ZXNbal0gKiB0aGlzLmJhc2U7XG5cdCAgICAgICAgICAgICAgICBieXRlc1tqXSA9IGNhcnJ5ICYgMHhmZjtcblx0ICAgICAgICAgICAgICAgIGNhcnJ5ID4+PSA4O1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIHdoaWxlIChjYXJyeSA+IDApIHtcblx0ICAgICAgICAgICAgICAgIGJ5dGVzLnB1c2goY2FycnkgJiAweGZmKTtcblx0ICAgICAgICAgICAgICAgIGNhcnJ5ID4+PSA4O1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfVxuXHQgICAgICAgIC8vIGRlYWwgd2l0aCBsZWFkaW5nIHplcm9zXG5cdCAgICAgICAgZm9yICh2YXIgayA9IDA7IHZhbHVlW2tdID09PSB0aGlzLl9sZWFkZXIgJiYgayA8IHZhbHVlLmxlbmd0aCAtIDE7ICsraykge1xuXHQgICAgICAgICAgICBieXRlcy5wdXNoKDApO1xuXHQgICAgICAgIH1cblx0ICAgICAgICByZXR1cm4gKDAsIGxpYiQxLmFycmF5aWZ5KShuZXcgVWludDhBcnJheShieXRlcy5yZXZlcnNlKCkpKTtcblx0ICAgIH07XG5cdCAgICByZXR1cm4gQmFzZVg7XG5cdH0oKSk7XG5cdGV4cG9ydHMuQmFzZVggPSBCYXNlWDtcblx0dmFyIEJhc2UzMiA9IG5ldyBCYXNlWChcImFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MjM0NTY3XCIpO1xuXHRleHBvcnRzLkJhc2UzMiA9IEJhc2UzMjtcblx0dmFyIEJhc2U1OCA9IG5ldyBCYXNlWChcIjEyMzQ1Njc4OUFCQ0RFRkdISktMTU5QUVJTVFVWV1hZWmFiY2RlZmdoaWprbW5vcHFyc3R1dnd4eXpcIik7XG5cdGV4cG9ydHMuQmFzZTU4ID0gQmFzZTU4O1xuXHQvL2NvbnNvbGUubG9nKEJhc2U1OC5kZWNvZGUoXCJRbWQyVjc3N281WHZKYllNZU1iOGsyblU1ZjhkM2NpVVE1WXBZdVdoenY4aURqXCIpKVxuXHQvL2NvbnNvbGUubG9nKEJhc2U1OC5lbmNvZGUoQmFzZTU4LmRlY29kZShcIlFtZDJWNzc3bzVYdkpiWU1lTWI4azJuVTVmOGQzY2lVUTVZcFl1V2h6djhpRGpcIikpKVxuXG5cdH0pO1xuXG5cdHZhciBpbmRleCRnID0gLypAX19QVVJFX18qL2dldERlZmF1bHRFeHBvcnRGcm9tQ2pzKGxpYiRnKTtcblxuXHR2YXIgdHlwZXMgPSBjcmVhdGVDb21tb25qc01vZHVsZShmdW5jdGlvbiAobW9kdWxlLCBleHBvcnRzKSB7XG5cdFwidXNlIHN0cmljdFwiO1xuXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5cdGV4cG9ydHMuU3VwcG9ydGVkQWxnb3JpdGhtID0gdm9pZCAwO1xuXHR2YXIgU3VwcG9ydGVkQWxnb3JpdGhtO1xuXHQoZnVuY3Rpb24gKFN1cHBvcnRlZEFsZ29yaXRobSkge1xuXHQgICAgU3VwcG9ydGVkQWxnb3JpdGhtW1wic2hhMjU2XCJdID0gXCJzaGEyNTZcIjtcblx0ICAgIFN1cHBvcnRlZEFsZ29yaXRobVtcInNoYTUxMlwiXSA9IFwic2hhNTEyXCI7XG5cdH0pKFN1cHBvcnRlZEFsZ29yaXRobSA9IGV4cG9ydHMuU3VwcG9ydGVkQWxnb3JpdGhtIHx8IChleHBvcnRzLlN1cHBvcnRlZEFsZ29yaXRobSA9IHt9KSk7XG5cdDtcblxuXHR9KTtcblxuXHR2YXIgdHlwZXMkMSA9IC8qQF9fUFVSRV9fKi9nZXREZWZhdWx0RXhwb3J0RnJvbUNqcyh0eXBlcyk7XG5cblx0dmFyIF92ZXJzaW9uJHMgPSBjcmVhdGVDb21tb25qc01vZHVsZShmdW5jdGlvbiAobW9kdWxlLCBleHBvcnRzKSB7XG5cdFwidXNlIHN0cmljdFwiO1xuXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5cdGV4cG9ydHMudmVyc2lvbiA9IHZvaWQgMDtcblx0ZXhwb3J0cy52ZXJzaW9uID0gXCJzaGEyLzUuNS4wXCI7XG5cblx0fSk7XG5cblx0dmFyIF92ZXJzaW9uJHQgPSAvKkBfX1BVUkVfXyovZ2V0RGVmYXVsdEV4cG9ydEZyb21DanMoX3ZlcnNpb24kcyk7XG5cblx0dmFyIGJyb3dzZXJTaGEyID0gY3JlYXRlQ29tbW9uanNNb2R1bGUoZnVuY3Rpb24gKG1vZHVsZSwgZXhwb3J0cykge1xuXHRcInVzZSBzdHJpY3RcIjtcblx0dmFyIF9faW1wb3J0RGVmYXVsdCA9IChjb21tb25qc0dsb2JhbCAmJiBjb21tb25qc0dsb2JhbC5fX2ltcG9ydERlZmF1bHQpIHx8IGZ1bmN0aW9uIChtb2QpIHtcblx0ICAgIHJldHVybiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSA/IG1vZCA6IHsgXCJkZWZhdWx0XCI6IG1vZCB9O1xuXHR9O1xuXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5cdGV4cG9ydHMuY29tcHV0ZUhtYWMgPSBleHBvcnRzLnNoYTUxMiA9IGV4cG9ydHMuc2hhMjU2ID0gZXhwb3J0cy5yaXBlbWQxNjAgPSB2b2lkIDA7XG5cdHZhciBoYXNoX2pzXzEgPSBfX2ltcG9ydERlZmF1bHQoaGFzaF8xKTtcblx0Ly9jb25zdCBfcmlwZW1kMTYwID0gX2hhc2gucmlwZW1kMTYwO1xuXG5cblxuXG5cdHZhciBsb2dnZXIgPSBuZXcgbGliLkxvZ2dlcihfdmVyc2lvbiRzLnZlcnNpb24pO1xuXHRmdW5jdGlvbiByaXBlbWQxNjAoZGF0YSkge1xuXHQgICAgcmV0dXJuIFwiMHhcIiArIChoYXNoX2pzXzEuZGVmYXVsdC5yaXBlbWQxNjAoKS51cGRhdGUoKDAsIGxpYiQxLmFycmF5aWZ5KShkYXRhKSkuZGlnZXN0KFwiaGV4XCIpKTtcblx0fVxuXHRleHBvcnRzLnJpcGVtZDE2MCA9IHJpcGVtZDE2MDtcblx0ZnVuY3Rpb24gc2hhMjU2KGRhdGEpIHtcblx0ICAgIHJldHVybiBcIjB4XCIgKyAoaGFzaF9qc18xLmRlZmF1bHQuc2hhMjU2KCkudXBkYXRlKCgwLCBsaWIkMS5hcnJheWlmeSkoZGF0YSkpLmRpZ2VzdChcImhleFwiKSk7XG5cdH1cblx0ZXhwb3J0cy5zaGEyNTYgPSBzaGEyNTY7XG5cdGZ1bmN0aW9uIHNoYTUxMihkYXRhKSB7XG5cdCAgICByZXR1cm4gXCIweFwiICsgKGhhc2hfanNfMS5kZWZhdWx0LnNoYTUxMigpLnVwZGF0ZSgoMCwgbGliJDEuYXJyYXlpZnkpKGRhdGEpKS5kaWdlc3QoXCJoZXhcIikpO1xuXHR9XG5cdGV4cG9ydHMuc2hhNTEyID0gc2hhNTEyO1xuXHRmdW5jdGlvbiBjb21wdXRlSG1hYyhhbGdvcml0aG0sIGtleSwgZGF0YSkge1xuXHQgICAgaWYgKCF0eXBlcy5TdXBwb3J0ZWRBbGdvcml0aG1bYWxnb3JpdGhtXSkge1xuXHQgICAgICAgIGxvZ2dlci50aHJvd0Vycm9yKFwidW5zdXBwb3J0ZWQgYWxnb3JpdGhtIFwiICsgYWxnb3JpdGhtLCBsaWIuTG9nZ2VyLmVycm9ycy5VTlNVUFBPUlRFRF9PUEVSQVRJT04sIHtcblx0ICAgICAgICAgICAgb3BlcmF0aW9uOiBcImhtYWNcIixcblx0ICAgICAgICAgICAgYWxnb3JpdGhtOiBhbGdvcml0aG1cblx0ICAgICAgICB9KTtcblx0ICAgIH1cblx0ICAgIHJldHVybiBcIjB4XCIgKyBoYXNoX2pzXzEuZGVmYXVsdC5obWFjKGhhc2hfanNfMS5kZWZhdWx0W2FsZ29yaXRobV0sICgwLCBsaWIkMS5hcnJheWlmeSkoa2V5KSkudXBkYXRlKCgwLCBsaWIkMS5hcnJheWlmeSkoZGF0YSkpLmRpZ2VzdChcImhleFwiKTtcblx0fVxuXHRleHBvcnRzLmNvbXB1dGVIbWFjID0gY29tcHV0ZUhtYWM7XG5cblx0fSk7XG5cblx0dmFyIGJyb3dzZXJTaGEyJDEgPSAvKkBfX1BVUkVfXyovZ2V0RGVmYXVsdEV4cG9ydEZyb21DanMoYnJvd3NlclNoYTIpO1xuXG5cdHZhciBsaWIkaCA9IGNyZWF0ZUNvbW1vbmpzTW9kdWxlKGZ1bmN0aW9uIChtb2R1bGUsIGV4cG9ydHMpIHtcblx0XCJ1c2Ugc3RyaWN0XCI7XG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcblx0ZXhwb3J0cy5TdXBwb3J0ZWRBbGdvcml0aG0gPSBleHBvcnRzLnNoYTUxMiA9IGV4cG9ydHMuc2hhMjU2ID0gZXhwb3J0cy5yaXBlbWQxNjAgPSBleHBvcnRzLmNvbXB1dGVIbWFjID0gdm9pZCAwO1xuXG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImNvbXB1dGVIbWFjXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBicm93c2VyU2hhMi5jb21wdXRlSG1hYzsgfSB9KTtcblx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwicmlwZW1kMTYwXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBicm93c2VyU2hhMi5yaXBlbWQxNjA7IH0gfSk7XG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcInNoYTI1NlwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gYnJvd3NlclNoYTIuc2hhMjU2OyB9IH0pO1xuXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJzaGE1MTJcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGJyb3dzZXJTaGEyLnNoYTUxMjsgfSB9KTtcblxuXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJTdXBwb3J0ZWRBbGdvcml0aG1cIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHR5cGVzLlN1cHBvcnRlZEFsZ29yaXRobTsgfSB9KTtcblxuXHR9KTtcblxuXHR2YXIgaW5kZXgkaCA9IC8qQF9fUFVSRV9fKi9nZXREZWZhdWx0RXhwb3J0RnJvbUNqcyhsaWIkaCk7XG5cblx0dmFyIGJyb3dzZXJQYmtkZjIgPSBjcmVhdGVDb21tb25qc01vZHVsZShmdW5jdGlvbiAobW9kdWxlLCBleHBvcnRzKSB7XG5cdFwidXNlIHN0cmljdFwiO1xuXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5cdGV4cG9ydHMucGJrZGYyID0gdm9pZCAwO1xuXG5cblx0ZnVuY3Rpb24gcGJrZGYyKHBhc3N3b3JkLCBzYWx0LCBpdGVyYXRpb25zLCBrZXlsZW4sIGhhc2hBbGdvcml0aG0pIHtcblx0ICAgIHBhc3N3b3JkID0gKDAsIGxpYiQxLmFycmF5aWZ5KShwYXNzd29yZCk7XG5cdCAgICBzYWx0ID0gKDAsIGxpYiQxLmFycmF5aWZ5KShzYWx0KTtcblx0ICAgIHZhciBoTGVuO1xuXHQgICAgdmFyIGwgPSAxO1xuXHQgICAgdmFyIERLID0gbmV3IFVpbnQ4QXJyYXkoa2V5bGVuKTtcblx0ICAgIHZhciBibG9jazEgPSBuZXcgVWludDhBcnJheShzYWx0Lmxlbmd0aCArIDQpO1xuXHQgICAgYmxvY2sxLnNldChzYWx0KTtcblx0ICAgIC8vc2FsdC5jb3B5KGJsb2NrMSwgMCwgMCwgc2FsdC5sZW5ndGgpXG5cdCAgICB2YXIgcjtcblx0ICAgIHZhciBUO1xuXHQgICAgZm9yICh2YXIgaSA9IDE7IGkgPD0gbDsgaSsrKSB7XG5cdCAgICAgICAgLy9ibG9jazEud3JpdGVVSW50MzJCRShpLCBzYWx0Lmxlbmd0aClcblx0ICAgICAgICBibG9jazFbc2FsdC5sZW5ndGhdID0gKGkgPj4gMjQpICYgMHhmZjtcblx0ICAgICAgICBibG9jazFbc2FsdC5sZW5ndGggKyAxXSA9IChpID4+IDE2KSAmIDB4ZmY7XG5cdCAgICAgICAgYmxvY2sxW3NhbHQubGVuZ3RoICsgMl0gPSAoaSA+PiA4KSAmIDB4ZmY7XG5cdCAgICAgICAgYmxvY2sxW3NhbHQubGVuZ3RoICsgM10gPSBpICYgMHhmZjtcblx0ICAgICAgICAvL2xldCBVID0gY3JlYXRlSG1hYyhwYXNzd29yZCkudXBkYXRlKGJsb2NrMSkuZGlnZXN0KCk7XG5cdCAgICAgICAgdmFyIFUgPSAoMCwgbGliJDEuYXJyYXlpZnkpKCgwLCBsaWIkaC5jb21wdXRlSG1hYykoaGFzaEFsZ29yaXRobSwgcGFzc3dvcmQsIGJsb2NrMSkpO1xuXHQgICAgICAgIGlmICghaExlbikge1xuXHQgICAgICAgICAgICBoTGVuID0gVS5sZW5ndGg7XG5cdCAgICAgICAgICAgIFQgPSBuZXcgVWludDhBcnJheShoTGVuKTtcblx0ICAgICAgICAgICAgbCA9IE1hdGguY2VpbChrZXlsZW4gLyBoTGVuKTtcblx0ICAgICAgICAgICAgciA9IGtleWxlbiAtIChsIC0gMSkgKiBoTGVuO1xuXHQgICAgICAgIH1cblx0ICAgICAgICAvL1UuY29weShULCAwLCAwLCBoTGVuKVxuXHQgICAgICAgIFQuc2V0KFUpO1xuXHQgICAgICAgIGZvciAodmFyIGogPSAxOyBqIDwgaXRlcmF0aW9uczsgaisrKSB7XG5cdCAgICAgICAgICAgIC8vVSA9IGNyZWF0ZUhtYWMocGFzc3dvcmQpLnVwZGF0ZShVKS5kaWdlc3QoKTtcblx0ICAgICAgICAgICAgVSA9ICgwLCBsaWIkMS5hcnJheWlmeSkoKDAsIGxpYiRoLmNvbXB1dGVIbWFjKShoYXNoQWxnb3JpdGhtLCBwYXNzd29yZCwgVSkpO1xuXHQgICAgICAgICAgICBmb3IgKHZhciBrID0gMDsgayA8IGhMZW47IGsrKylcblx0ICAgICAgICAgICAgICAgIFRba10gXj0gVVtrXTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgdmFyIGRlc3RQb3MgPSAoaSAtIDEpICogaExlbjtcblx0ICAgICAgICB2YXIgbGVuID0gKGkgPT09IGwgPyByIDogaExlbik7XG5cdCAgICAgICAgLy9ULmNvcHkoREssIGRlc3RQb3MsIDAsIGxlbilcblx0ICAgICAgICBESy5zZXQoKDAsIGxpYiQxLmFycmF5aWZ5KShUKS5zbGljZSgwLCBsZW4pLCBkZXN0UG9zKTtcblx0ICAgIH1cblx0ICAgIHJldHVybiAoMCwgbGliJDEuaGV4bGlmeSkoREspO1xuXHR9XG5cdGV4cG9ydHMucGJrZGYyID0gcGJrZGYyO1xuXG5cdH0pO1xuXG5cdHZhciBicm93c2VyUGJrZGYyJDEgPSAvKkBfX1BVUkVfXyovZ2V0RGVmYXVsdEV4cG9ydEZyb21DanMoYnJvd3NlclBia2RmMik7XG5cblx0dmFyIGxpYiRpID0gY3JlYXRlQ29tbW9uanNNb2R1bGUoZnVuY3Rpb24gKG1vZHVsZSwgZXhwb3J0cykge1xuXHRcInVzZSBzdHJpY3RcIjtcblx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuXHRleHBvcnRzLnBia2RmMiA9IHZvaWQgMDtcblxuXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJwYmtkZjJcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGJyb3dzZXJQYmtkZjIucGJrZGYyOyB9IH0pO1xuXG5cdH0pO1xuXG5cdHZhciBpbmRleCRpID0gLypAX19QVVJFX18qL2dldERlZmF1bHRFeHBvcnRGcm9tQ2pzKGxpYiRpKTtcblxuXHR2YXIgX3ZlcnNpb24kdSA9IGNyZWF0ZUNvbW1vbmpzTW9kdWxlKGZ1bmN0aW9uIChtb2R1bGUsIGV4cG9ydHMpIHtcblx0XCJ1c2Ugc3RyaWN0XCI7XG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcblx0ZXhwb3J0cy52ZXJzaW9uID0gdm9pZCAwO1xuXHRleHBvcnRzLnZlcnNpb24gPSBcIndvcmRsaXN0cy81LjUuMFwiO1xuXG5cdH0pO1xuXG5cdHZhciBfdmVyc2lvbiR2ID0gLypAX19QVVJFX18qL2dldERlZmF1bHRFeHBvcnRGcm9tQ2pzKF92ZXJzaW9uJHUpO1xuXG5cdHZhciB3b3JkbGlzdCA9IGNyZWF0ZUNvbW1vbmpzTW9kdWxlKGZ1bmN0aW9uIChtb2R1bGUsIGV4cG9ydHMpIHtcblx0XCJ1c2Ugc3RyaWN0XCI7XG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcblx0ZXhwb3J0cy5Xb3JkbGlzdCA9IGV4cG9ydHMubG9nZ2VyID0gdm9pZCAwO1xuXHQvLyBUaGlzIGdldHMgb3ZlcnJpZGRlbiBieSByb2xsdXBcblx0dmFyIGV4cG9ydFdvcmRsaXN0ID0gZmFsc2U7XG5cblxuXG5cblx0ZXhwb3J0cy5sb2dnZXIgPSBuZXcgbGliLkxvZ2dlcihfdmVyc2lvbiR1LnZlcnNpb24pO1xuXHR2YXIgV29yZGxpc3QgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG5cdCAgICBmdW5jdGlvbiBXb3JkbGlzdChsb2NhbGUpIHtcblx0ICAgICAgICB2YXIgX25ld1RhcmdldCA9IHRoaXMuY29uc3RydWN0b3I7XG5cdCAgICAgICAgZXhwb3J0cy5sb2dnZXIuY2hlY2tBYnN0cmFjdChfbmV3VGFyZ2V0LCBXb3JkbGlzdCk7XG5cdCAgICAgICAgKDAsIGxpYiQzLmRlZmluZVJlYWRPbmx5KSh0aGlzLCBcImxvY2FsZVwiLCBsb2NhbGUpO1xuXHQgICAgfVxuXHQgICAgLy8gU3ViY2xhc3NlcyBtYXkgb3ZlcnJpZGUgdGhpc1xuXHQgICAgV29yZGxpc3QucHJvdG90eXBlLnNwbGl0ID0gZnVuY3Rpb24gKG1uZW1vbmljKSB7XG5cdCAgICAgICAgcmV0dXJuIG1uZW1vbmljLnRvTG93ZXJDYXNlKCkuc3BsaXQoLyArL2cpO1xuXHQgICAgfTtcblx0ICAgIC8vIFN1YmNsYXNzZXMgbWF5IG92ZXJyaWRlIHRoaXNcblx0ICAgIFdvcmRsaXN0LnByb3RvdHlwZS5qb2luID0gZnVuY3Rpb24gKHdvcmRzKSB7XG5cdCAgICAgICAgcmV0dXJuIHdvcmRzLmpvaW4oXCIgXCIpO1xuXHQgICAgfTtcblx0ICAgIFdvcmRsaXN0LmNoZWNrID0gZnVuY3Rpb24gKHdvcmRsaXN0KSB7XG5cdCAgICAgICAgdmFyIHdvcmRzID0gW107XG5cdCAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCAyMDQ4OyBpKyspIHtcblx0ICAgICAgICAgICAgdmFyIHdvcmQgPSB3b3JkbGlzdC5nZXRXb3JkKGkpO1xuXHQgICAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cblx0ICAgICAgICAgICAgaWYgKGkgIT09IHdvcmRsaXN0LmdldFdvcmRJbmRleCh3b3JkKSkge1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuIFwiMHhcIjtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB3b3Jkcy5wdXNoKHdvcmQpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICByZXR1cm4gKDAsIGxpYiQ5LmlkKSh3b3Jkcy5qb2luKFwiXFxuXCIpICsgXCJcXG5cIik7XG5cdCAgICB9O1xuXHQgICAgV29yZGxpc3QucmVnaXN0ZXIgPSBmdW5jdGlvbiAobGFuZywgbmFtZSkge1xuXHQgICAgICAgIGlmICghbmFtZSkge1xuXHQgICAgICAgICAgICBuYW1lID0gbGFuZy5sb2NhbGU7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuXHQgICAgICAgIGlmIChleHBvcnRXb3JkbGlzdCkge1xuXHQgICAgICAgICAgICB0cnkge1xuXHQgICAgICAgICAgICAgICAgdmFyIGFueUdsb2JhbCA9IHdpbmRvdztcblx0ICAgICAgICAgICAgICAgIGlmIChhbnlHbG9iYWwuX2V0aGVycyAmJiBhbnlHbG9iYWwuX2V0aGVycy53b3JkbGlzdHMpIHtcblx0ICAgICAgICAgICAgICAgICAgICBpZiAoIWFueUdsb2JhbC5fZXRoZXJzLndvcmRsaXN0c1tuYW1lXSkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAoMCwgbGliJDMuZGVmaW5lUmVhZE9ubHkpKGFueUdsb2JhbC5fZXRoZXJzLndvcmRsaXN0cywgbmFtZSwgbGFuZyk7XG5cdCAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIGNhdGNoIChlcnJvcikgeyB9XG5cdCAgICAgICAgfVxuXHQgICAgfTtcblx0ICAgIHJldHVybiBXb3JkbGlzdDtcblx0fSgpKTtcblx0ZXhwb3J0cy5Xb3JkbGlzdCA9IFdvcmRsaXN0O1xuXG5cdH0pO1xuXG5cdHZhciB3b3JkbGlzdCQxID0gLypAX19QVVJFX18qL2dldERlZmF1bHRFeHBvcnRGcm9tQ2pzKHdvcmRsaXN0KTtcblxuXHR2YXIgbGFuZ0VuXzEgPSBjcmVhdGVDb21tb25qc01vZHVsZShmdW5jdGlvbiAobW9kdWxlLCBleHBvcnRzKSB7XG5cdFwidXNlIHN0cmljdFwiO1xuXHR2YXIgX19leHRlbmRzID0gKGNvbW1vbmpzR2xvYmFsICYmIGNvbW1vbmpzR2xvYmFsLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcblx0ICAgIHZhciBleHRlbmRTdGF0aWNzID0gZnVuY3Rpb24gKGQsIGIpIHtcblx0ICAgICAgICBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG5cdCAgICAgICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcblx0ICAgICAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGIsIHApKSBkW3BdID0gYltwXTsgfTtcblx0ICAgICAgICByZXR1cm4gZXh0ZW5kU3RhdGljcyhkLCBiKTtcblx0ICAgIH07XG5cdCAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcblx0ICAgICAgICBpZiAodHlwZW9mIGIgIT09IFwiZnVuY3Rpb25cIiAmJiBiICE9PSBudWxsKVxuXHQgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2xhc3MgZXh0ZW5kcyB2YWx1ZSBcIiArIFN0cmluZyhiKSArIFwiIGlzIG5vdCBhIGNvbnN0cnVjdG9yIG9yIG51bGxcIik7XG5cdCAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcblx0ICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cblx0ICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG5cdCAgICB9O1xuXHR9KSgpO1xuXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5cdGV4cG9ydHMubGFuZ0VuID0gdm9pZCAwO1xuXG5cdHZhciB3b3JkcyA9IFwiQWJhbmRvbkFiaWxpdHlBYmxlQWJvdXRBYm92ZUFic2VudEFic29yYkFic3RyYWN0QWJzdXJkQWJ1c2VBY2Nlc3NBY2NpZGVudEFjY291bnRBY2N1c2VBY2hpZXZlQWNpZEFjb3VzdGljQWNxdWlyZUFjcm9zc0FjdEFjdGlvbkFjdG9yQWN0cmVzc0FjdHVhbEFkYXB0QWRkQWRkaWN0QWRkcmVzc0FkanVzdEFkbWl0QWR1bHRBZHZhbmNlQWR2aWNlQWVyb2JpY0FmZmFpckFmZm9yZEFmcmFpZEFnYWluQWdlQWdlbnRBZ3JlZUFoZWFkQWltQWlyQWlycG9ydEFpc2xlQWxhcm1BbGJ1bUFsY29ob2xBbGVydEFsaWVuQWxsQWxsZXlBbGxvd0FsbW9zdEFsb25lQWxwaGFBbHJlYWR5QWxzb0FsdGVyQWx3YXlzQW1hdGV1ckFtYXppbmdBbW9uZ0Ftb3VudEFtdXNlZEFuYWx5c3RBbmNob3JBbmNpZW50QW5nZXJBbmdsZUFuZ3J5QW5pbWFsQW5rbGVBbm5vdW5jZUFubnVhbEFub3RoZXJBbnN3ZXJBbnRlbm5hQW50aXF1ZUFueGlldHlBbnlBcGFydEFwb2xvZ3lBcHBlYXJBcHBsZUFwcHJvdmVBcHJpbEFyY2hBcmN0aWNBcmVhQXJlbmFBcmd1ZUFybUFybWVkQXJtb3JBcm15QXJvdW5kQXJyYW5nZUFycmVzdEFycml2ZUFycm93QXJ0QXJ0ZWZhY3RBcnRpc3RBcnR3b3JrQXNrQXNwZWN0QXNzYXVsdEFzc2V0QXNzaXN0QXNzdW1lQXN0aG1hQXRobGV0ZUF0b21BdHRhY2tBdHRlbmRBdHRpdHVkZUF0dHJhY3RBdWN0aW9uQXVkaXRBdWd1c3RBdW50QXV0aG9yQXV0b0F1dHVtbkF2ZXJhZ2VBdm9jYWRvQXZvaWRBd2FrZUF3YXJlQXdheUF3ZXNvbWVBd2Z1bEF3a3dhcmRBeGlzQmFieUJhY2hlbG9yQmFjb25CYWRnZUJhZ0JhbGFuY2VCYWxjb255QmFsbEJhbWJvb0JhbmFuYUJhbm5lckJhckJhcmVseUJhcmdhaW5CYXJyZWxCYXNlQmFzaWNCYXNrZXRCYXR0bGVCZWFjaEJlYW5CZWF1dHlCZWNhdXNlQmVjb21lQmVlZkJlZm9yZUJlZ2luQmVoYXZlQmVoaW5kQmVsaWV2ZUJlbG93QmVsdEJlbmNoQmVuZWZpdEJlc3RCZXRyYXlCZXR0ZXJCZXR3ZWVuQmV5b25kQmljeWNsZUJpZEJpa2VCaW5kQmlvbG9neUJpcmRCaXJ0aEJpdHRlckJsYWNrQmxhZGVCbGFtZUJsYW5rZXRCbGFzdEJsZWFrQmxlc3NCbGluZEJsb29kQmxvc3NvbUJsb3VzZUJsdWVCbHVyQmx1c2hCb2FyZEJvYXRCb2R5Qm9pbEJvbWJCb25lQm9udXNCb29rQm9vc3RCb3JkZXJCb3JpbmdCb3Jyb3dCb3NzQm90dG9tQm91bmNlQm94Qm95QnJhY2tldEJyYWluQnJhbmRCcmFzc0JyYXZlQnJlYWRCcmVlemVCcmlja0JyaWRnZUJyaWVmQnJpZ2h0QnJpbmdCcmlza0Jyb2Njb2xpQnJva2VuQnJvbnplQnJvb21Ccm90aGVyQnJvd25CcnVzaEJ1YmJsZUJ1ZGR5QnVkZ2V0QnVmZmFsb0J1aWxkQnVsYkJ1bGtCdWxsZXRCdW5kbGVCdW5rZXJCdXJkZW5CdXJnZXJCdXJzdEJ1c0J1c2luZXNzQnVzeUJ1dHRlckJ1eWVyQnV6ekNhYmJhZ2VDYWJpbkNhYmxlQ2FjdHVzQ2FnZUNha2VDYWxsQ2FsbUNhbWVyYUNhbXBDYW5DYW5hbENhbmNlbENhbmR5Q2Fubm9uQ2Fub2VDYW52YXNDYW55b25DYXBhYmxlQ2FwaXRhbENhcHRhaW5DYXJDYXJib25DYXJkQ2FyZ29DYXJwZXRDYXJyeUNhcnRDYXNlQ2FzaENhc2lub0Nhc3RsZUNhc3VhbENhdENhdGFsb2dDYXRjaENhdGVnb3J5Q2F0dGxlQ2F1Z2h0Q2F1c2VDYXV0aW9uQ2F2ZUNlaWxpbmdDZWxlcnlDZW1lbnRDZW5zdXNDZW50dXJ5Q2VyZWFsQ2VydGFpbkNoYWlyQ2hhbGtDaGFtcGlvbkNoYW5nZUNoYW9zQ2hhcHRlckNoYXJnZUNoYXNlQ2hhdENoZWFwQ2hlY2tDaGVlc2VDaGVmQ2hlcnJ5Q2hlc3RDaGlja2VuQ2hpZWZDaGlsZENoaW1uZXlDaG9pY2VDaG9vc2VDaHJvbmljQ2h1Y2tsZUNodW5rQ2h1cm5DaWdhckNpbm5hbW9uQ2lyY2xlQ2l0aXplbkNpdHlDaXZpbENsYWltQ2xhcENsYXJpZnlDbGF3Q2xheUNsZWFuQ2xlcmtDbGV2ZXJDbGlja0NsaWVudENsaWZmQ2xpbWJDbGluaWNDbGlwQ2xvY2tDbG9nQ2xvc2VDbG90aENsb3VkQ2xvd25DbHViQ2x1bXBDbHVzdGVyQ2x1dGNoQ29hY2hDb2FzdENvY29udXRDb2RlQ29mZmVlQ29pbENvaW5Db2xsZWN0Q29sb3JDb2x1bW5Db21iaW5lQ29tZUNvbWZvcnRDb21pY0NvbW1vbkNvbXBhbnlDb25jZXJ0Q29uZHVjdENvbmZpcm1Db25ncmVzc0Nvbm5lY3RDb25zaWRlckNvbnRyb2xDb252aW5jZUNvb2tDb29sQ29wcGVyQ29weUNvcmFsQ29yZUNvcm5Db3JyZWN0Q29zdENvdHRvbkNvdWNoQ291bnRyeUNvdXBsZUNvdXJzZUNvdXNpbkNvdmVyQ295b3RlQ3JhY2tDcmFkbGVDcmFmdENyYW1DcmFuZUNyYXNoQ3JhdGVyQ3Jhd2xDcmF6eUNyZWFtQ3JlZGl0Q3JlZWtDcmV3Q3JpY2tldENyaW1lQ3Jpc3BDcml0aWNDcm9wQ3Jvc3NDcm91Y2hDcm93ZENydWNpYWxDcnVlbENydWlzZUNydW1ibGVDcnVuY2hDcnVzaENyeUNyeXN0YWxDdWJlQ3VsdHVyZUN1cEN1cGJvYXJkQ3VyaW91c0N1cnJlbnRDdXJ0YWluQ3VydmVDdXNoaW9uQ3VzdG9tQ3V0ZUN5Y2xlRGFkRGFtYWdlRGFtcERhbmNlRGFuZ2VyRGFyaW5nRGFzaERhdWdodGVyRGF3bkRheURlYWxEZWJhdGVEZWJyaXNEZWNhZGVEZWNlbWJlckRlY2lkZURlY2xpbmVEZWNvcmF0ZURlY3JlYXNlRGVlckRlZmVuc2VEZWZpbmVEZWZ5RGVncmVlRGVsYXlEZWxpdmVyRGVtYW5kRGVtaXNlRGVuaWFsRGVudGlzdERlbnlEZXBhcnREZXBlbmREZXBvc2l0RGVwdGhEZXB1dHlEZXJpdmVEZXNjcmliZURlc2VydERlc2lnbkRlc2tEZXNwYWlyRGVzdHJveURldGFpbERldGVjdERldmVsb3BEZXZpY2VEZXZvdGVEaWFncmFtRGlhbERpYW1vbmREaWFyeURpY2VEaWVzZWxEaWV0RGlmZmVyRGlnaXRhbERpZ25pdHlEaWxlbW1hRGlubmVyRGlub3NhdXJEaXJlY3REaXJ0RGlzYWdyZWVEaXNjb3ZlckRpc2Vhc2VEaXNoRGlzbWlzc0Rpc29yZGVyRGlzcGxheURpc3RhbmNlRGl2ZXJ0RGl2aWRlRGl2b3JjZURpenp5RG9jdG9yRG9jdW1lbnREb2dEb2xsRG9scGhpbkRvbWFpbkRvbmF0ZURvbmtleURvbm9yRG9vckRvc2VEb3VibGVEb3ZlRHJhZnREcmFnb25EcmFtYURyYXN0aWNEcmF3RHJlYW1EcmVzc0RyaWZ0RHJpbGxEcmlua0RyaXBEcml2ZURyb3BEcnVtRHJ5RHVja0R1bWJEdW5lRHVyaW5nRHVzdER1dGNoRHV0eUR3YXJmRHluYW1pY0VhZ2VyRWFnbGVFYXJseUVhcm5FYXJ0aEVhc2lseUVhc3RFYXN5RWNob0Vjb2xvZ3lFY29ub215RWRnZUVkaXRFZHVjYXRlRWZmb3J0RWdnRWlnaHRFaXRoZXJFbGJvd0VsZGVyRWxlY3RyaWNFbGVnYW50RWxlbWVudEVsZXBoYW50RWxldmF0b3JFbGl0ZUVsc2VFbWJhcmtFbWJvZHlFbWJyYWNlRW1lcmdlRW1vdGlvbkVtcGxveUVtcG93ZXJFbXB0eUVuYWJsZUVuYWN0RW5kRW5kbGVzc0VuZG9yc2VFbmVteUVuZXJneUVuZm9yY2VFbmdhZ2VFbmdpbmVFbmhhbmNlRW5qb3lFbmxpc3RFbm91Z2hFbnJpY2hFbnJvbGxFbnN1cmVFbnRlckVudGlyZUVudHJ5RW52ZWxvcGVFcGlzb2RlRXF1YWxFcXVpcEVyYUVyYXNlRXJvZGVFcm9zaW9uRXJyb3JFcnVwdEVzY2FwZUVzc2F5RXNzZW5jZUVzdGF0ZUV0ZXJuYWxFdGhpY3NFdmlkZW5jZUV2aWxFdm9rZUV2b2x2ZUV4YWN0RXhhbXBsZUV4Y2Vzc0V4Y2hhbmdlRXhjaXRlRXhjbHVkZUV4Y3VzZUV4ZWN1dGVFeGVyY2lzZUV4aGF1c3RFeGhpYml0RXhpbGVFeGlzdEV4aXRFeG90aWNFeHBhbmRFeHBlY3RFeHBpcmVFeHBsYWluRXhwb3NlRXhwcmVzc0V4dGVuZEV4dHJhRXllRXllYnJvd0ZhYnJpY0ZhY2VGYWN1bHR5RmFkZUZhaW50RmFpdGhGYWxsRmFsc2VGYW1lRmFtaWx5RmFtb3VzRmFuRmFuY3lGYW50YXN5RmFybUZhc2hpb25GYXRGYXRhbEZhdGhlckZhdGlndWVGYXVsdEZhdm9yaXRlRmVhdHVyZUZlYnJ1YXJ5RmVkZXJhbEZlZUZlZWRGZWVsRmVtYWxlRmVuY2VGZXN0aXZhbEZldGNoRmV2ZXJGZXdGaWJlckZpY3Rpb25GaWVsZEZpZ3VyZUZpbGVGaWxtRmlsdGVyRmluYWxGaW5kRmluZUZpbmdlckZpbmlzaEZpcmVGaXJtRmlyc3RGaXNjYWxGaXNoRml0Rml0bmVzc0ZpeEZsYWdGbGFtZUZsYXNoRmxhdEZsYXZvckZsZWVGbGlnaHRGbGlwRmxvYXRGbG9ja0Zsb29yRmxvd2VyRmx1aWRGbHVzaEZseUZvYW1Gb2N1c0ZvZ0ZvaWxGb2xkRm9sbG93Rm9vZEZvb3RGb3JjZUZvcmVzdEZvcmdldEZvcmtGb3J0dW5lRm9ydW1Gb3J3YXJkRm9zc2lsRm9zdGVyRm91bmRGb3hGcmFnaWxlRnJhbWVGcmVxdWVudEZyZXNoRnJpZW5kRnJpbmdlRnJvZ0Zyb250RnJvc3RGcm93bkZyb3plbkZydWl0RnVlbEZ1bkZ1bm55RnVybmFjZUZ1cnlGdXR1cmVHYWRnZXRHYWluR2FsYXh5R2FsbGVyeUdhbWVHYXBHYXJhZ2VHYXJiYWdlR2FyZGVuR2FybGljR2FybWVudEdhc0dhc3BHYXRlR2F0aGVyR2F1Z2VHYXplR2VuZXJhbEdlbml1c0dlbnJlR2VudGxlR2VudWluZUdlc3R1cmVHaG9zdEdpYW50R2lmdEdpZ2dsZUdpbmdlckdpcmFmZmVHaXJsR2l2ZUdsYWRHbGFuY2VHbGFyZUdsYXNzR2xpZGVHbGltcHNlR2xvYmVHbG9vbUdsb3J5R2xvdmVHbG93R2x1ZUdvYXRHb2RkZXNzR29sZEdvb2RHb29zZUdvcmlsbGFHb3NwZWxHb3NzaXBHb3Zlcm5Hb3duR3JhYkdyYWNlR3JhaW5HcmFudEdyYXBlR3Jhc3NHcmF2aXR5R3JlYXRHcmVlbkdyaWRHcmllZkdyaXRHcm9jZXJ5R3JvdXBHcm93R3J1bnRHdWFyZEd1ZXNzR3VpZGVHdWlsdEd1aXRhckd1bkd5bUhhYml0SGFpckhhbGZIYW1tZXJIYW1zdGVySGFuZEhhcHB5SGFyYm9ySGFyZEhhcnNoSGFydmVzdEhhdEhhdmVIYXdrSGF6YXJkSGVhZEhlYWx0aEhlYXJ0SGVhdnlIZWRnZWhvZ0hlaWdodEhlbGxvSGVsbWV0SGVscEhlbkhlcm9IaWRkZW5IaWdoSGlsbEhpbnRIaXBIaXJlSGlzdG9yeUhvYmJ5SG9ja2V5SG9sZEhvbGVIb2xpZGF5SG9sbG93SG9tZUhvbmV5SG9vZEhvcGVIb3JuSG9ycm9ySG9yc2VIb3NwaXRhbEhvc3RIb3RlbEhvdXJIb3Zlckh1Ykh1Z2VIdW1hbkh1bWJsZUh1bW9ySHVuZHJlZEh1bmdyeUh1bnRIdXJkbGVIdXJyeUh1cnRIdXNiYW5kSHlicmlkSWNlSWNvbklkZWFJZGVudGlmeUlkbGVJZ25vcmVJbGxJbGxlZ2FsSWxsbmVzc0ltYWdlSW1pdGF0ZUltbWVuc2VJbW11bmVJbXBhY3RJbXBvc2VJbXByb3ZlSW1wdWxzZUluY2hJbmNsdWRlSW5jb21lSW5jcmVhc2VJbmRleEluZGljYXRlSW5kb29ySW5kdXN0cnlJbmZhbnRJbmZsaWN0SW5mb3JtSW5oYWxlSW5oZXJpdEluaXRpYWxJbmplY3RJbmp1cnlJbm1hdGVJbm5lcklubm9jZW50SW5wdXRJbnF1aXJ5SW5zYW5lSW5zZWN0SW5zaWRlSW5zcGlyZUluc3RhbGxJbnRhY3RJbnRlcmVzdEludG9JbnZlc3RJbnZpdGVJbnZvbHZlSXJvbklzbGFuZElzb2xhdGVJc3N1ZUl0ZW1Jdm9yeUphY2tldEphZ3VhckphckphenpKZWFsb3VzSmVhbnNKZWxseUpld2VsSm9iSm9pbkpva2VKb3VybmV5Sm95SnVkZ2VKdWljZUp1bXBKdW5nbGVKdW5pb3JKdW5rSnVzdEthbmdhcm9vS2VlbktlZXBLZXRjaHVwS2V5S2lja0tpZEtpZG5leUtpbmRLaW5nZG9tS2lzc0tpdEtpdGNoZW5LaXRlS2l0dGVuS2l3aUtuZWVLbmlmZUtub2NrS25vd0xhYkxhYmVsTGFib3JMYWRkZXJMYWR5TGFrZUxhbXBMYW5ndWFnZUxhcHRvcExhcmdlTGF0ZXJMYXRpbkxhdWdoTGF1bmRyeUxhdmFMYXdMYXduTGF3c3VpdExheWVyTGF6eUxlYWRlckxlYWZMZWFybkxlYXZlTGVjdHVyZUxlZnRMZWdMZWdhbExlZ2VuZExlaXN1cmVMZW1vbkxlbmRMZW5ndGhMZW5zTGVvcGFyZExlc3NvbkxldHRlckxldmVsTGlhckxpYmVydHlMaWJyYXJ5TGljZW5zZUxpZmVMaWZ0TGlnaHRMaWtlTGltYkxpbWl0TGlua0xpb25MaXF1aWRMaXN0TGl0dGxlTGl2ZUxpemFyZExvYWRMb2FuTG9ic3RlckxvY2FsTG9ja0xvZ2ljTG9uZWx5TG9uZ0xvb3BMb3R0ZXJ5TG91ZExvdW5nZUxvdmVMb3lhbEx1Y2t5THVnZ2FnZUx1bWJlckx1bmFyTHVuY2hMdXh1cnlMeXJpY3NNYWNoaW5lTWFkTWFnaWNNYWduZXRNYWlkTWFpbE1haW5NYWpvck1ha2VNYW1tYWxNYW5NYW5hZ2VNYW5kYXRlTWFuZ29NYW5zaW9uTWFudWFsTWFwbGVNYXJibGVNYXJjaE1hcmdpbk1hcmluZU1hcmtldE1hcnJpYWdlTWFza01hc3NNYXN0ZXJNYXRjaE1hdGVyaWFsTWF0aE1hdHJpeE1hdHRlck1heGltdW1NYXplTWVhZG93TWVhbk1lYXN1cmVNZWF0TWVjaGFuaWNNZWRhbE1lZGlhTWVsb2R5TWVsdE1lbWJlck1lbW9yeU1lbnRpb25NZW51TWVyY3lNZXJnZU1lcml0TWVycnlNZXNoTWVzc2FnZU1ldGFsTWV0aG9kTWlkZGxlTWlkbmlnaHRNaWxrTWlsbGlvbk1pbWljTWluZE1pbmltdW1NaW5vck1pbnV0ZU1pcmFjbGVNaXJyb3JNaXNlcnlNaXNzTWlzdGFrZU1peE1peGVkTWl4dHVyZU1vYmlsZU1vZGVsTW9kaWZ5TW9tTW9tZW50TW9uaXRvck1vbmtleU1vbnN0ZXJNb250aE1vb25Nb3JhbE1vcmVNb3JuaW5nTW9zcXVpdG9Nb3RoZXJNb3Rpb25Nb3Rvck1vdW50YWluTW91c2VNb3ZlTW92aWVNdWNoTXVmZmluTXVsZU11bHRpcGx5TXVzY2xlTXVzZXVtTXVzaHJvb21NdXNpY011c3RNdXR1YWxNeXNlbGZNeXN0ZXJ5TXl0aE5haXZlTmFtZU5hcGtpbk5hcnJvd05hc3R5TmF0aW9uTmF0dXJlTmVhck5lY2tOZWVkTmVnYXRpdmVOZWdsZWN0TmVpdGhlck5lcGhld05lcnZlTmVzdE5ldE5ldHdvcmtOZXV0cmFsTmV2ZXJOZXdzTmV4dE5pY2VOaWdodE5vYmxlTm9pc2VOb21pbmVlTm9vZGxlTm9ybWFsTm9ydGhOb3NlTm90YWJsZU5vdGVOb3RoaW5nTm90aWNlTm92ZWxOb3dOdWNsZWFyTnVtYmVyTnVyc2VOdXRPYWtPYmV5T2JqZWN0T2JsaWdlT2JzY3VyZU9ic2VydmVPYnRhaW5PYnZpb3VzT2NjdXJPY2Vhbk9jdG9iZXJPZG9yT2ZmT2ZmZXJPZmZpY2VPZnRlbk9pbE9rYXlPbGRPbGl2ZU9seW1waWNPbWl0T25jZU9uZU9uaW9uT25saW5lT25seU9wZW5PcGVyYU9waW5pb25PcHBvc2VPcHRpb25PcmFuZ2VPcmJpdE9yY2hhcmRPcmRlck9yZGluYXJ5T3JnYW5PcmllbnRPcmlnaW5hbE9ycGhhbk9zdHJpY2hPdGhlck91dGRvb3JPdXRlck91dHB1dE91dHNpZGVPdmFsT3Zlbk92ZXJPd25Pd25lck94eWdlbk95c3Rlck96b25lUGFjdFBhZGRsZVBhZ2VQYWlyUGFsYWNlUGFsbVBhbmRhUGFuZWxQYW5pY1BhbnRoZXJQYXBlclBhcmFkZVBhcmVudFBhcmtQYXJyb3RQYXJ0eVBhc3NQYXRjaFBhdGhQYXRpZW50UGF0cm9sUGF0dGVyblBhdXNlUGF2ZVBheW1lbnRQZWFjZVBlYW51dFBlYXJQZWFzYW50UGVsaWNhblBlblBlbmFsdHlQZW5jaWxQZW9wbGVQZXBwZXJQZXJmZWN0UGVybWl0UGVyc29uUGV0UGhvbmVQaG90b1BocmFzZVBoeXNpY2FsUGlhbm9QaWNuaWNQaWN0dXJlUGllY2VQaWdQaWdlb25QaWxsUGlsb3RQaW5rUGlvbmVlclBpcGVQaXN0b2xQaXRjaFBpenphUGxhY2VQbGFuZXRQbGFzdGljUGxhdGVQbGF5UGxlYXNlUGxlZGdlUGx1Y2tQbHVnUGx1bmdlUG9lbVBvZXRQb2ludFBvbGFyUG9sZVBvbGljZVBvbmRQb255UG9vbFBvcHVsYXJQb3J0aW9uUG9zaXRpb25Qb3NzaWJsZVBvc3RQb3RhdG9Qb3R0ZXJ5UG92ZXJ0eVBvd2RlclBvd2VyUHJhY3RpY2VQcmFpc2VQcmVkaWN0UHJlZmVyUHJlcGFyZVByZXNlbnRQcmV0dHlQcmV2ZW50UHJpY2VQcmlkZVByaW1hcnlQcmludFByaW9yaXR5UHJpc29uUHJpdmF0ZVByaXplUHJvYmxlbVByb2Nlc3NQcm9kdWNlUHJvZml0UHJvZ3JhbVByb2plY3RQcm9tb3RlUHJvb2ZQcm9wZXJ0eVByb3NwZXJQcm90ZWN0UHJvdWRQcm92aWRlUHVibGljUHVkZGluZ1B1bGxQdWxwUHVsc2VQdW1wa2luUHVuY2hQdXBpbFB1cHB5UHVyY2hhc2VQdXJpdHlQdXJwb3NlUHVyc2VQdXNoUHV0UHV6emxlUHlyYW1pZFF1YWxpdHlRdWFudHVtUXVhcnRlclF1ZXN0aW9uUXVpY2tRdWl0UXVpelF1b3RlUmFiYml0UmFjY29vblJhY2VSYWNrUmFkYXJSYWRpb1JhaWxSYWluUmFpc2VSYWxseVJhbXBSYW5jaFJhbmRvbVJhbmdlUmFwaWRSYXJlUmF0ZVJhdGhlclJhdmVuUmF3UmF6b3JSZWFkeVJlYWxSZWFzb25SZWJlbFJlYnVpbGRSZWNhbGxSZWNlaXZlUmVjaXBlUmVjb3JkUmVjeWNsZVJlZHVjZVJlZmxlY3RSZWZvcm1SZWZ1c2VSZWdpb25SZWdyZXRSZWd1bGFyUmVqZWN0UmVsYXhSZWxlYXNlUmVsaWVmUmVseVJlbWFpblJlbWVtYmVyUmVtaW5kUmVtb3ZlUmVuZGVyUmVuZXdSZW50UmVvcGVuUmVwYWlyUmVwZWF0UmVwbGFjZVJlcG9ydFJlcXVpcmVSZXNjdWVSZXNlbWJsZVJlc2lzdFJlc291cmNlUmVzcG9uc2VSZXN1bHRSZXRpcmVSZXRyZWF0UmV0dXJuUmV1bmlvblJldmVhbFJldmlld1Jld2FyZFJoeXRobVJpYlJpYmJvblJpY2VSaWNoUmlkZVJpZGdlUmlmbGVSaWdodFJpZ2lkUmluZ1Jpb3RSaXBwbGVSaXNrUml0dWFsUml2YWxSaXZlclJvYWRSb2FzdFJvYm90Um9idXN0Um9ja2V0Um9tYW5jZVJvb2ZSb29raWVSb29tUm9zZVJvdGF0ZVJvdWdoUm91bmRSb3V0ZVJveWFsUnViYmVyUnVkZVJ1Z1J1bGVSdW5SdW53YXlSdXJhbFNhZFNhZGRsZVNhZG5lc3NTYWZlU2FpbFNhbGFkU2FsbW9uU2Fsb25TYWx0U2FsdXRlU2FtZVNhbXBsZVNhbmRTYXRpc2Z5U2F0b3NoaVNhdWNlU2F1c2FnZVNhdmVTYXlTY2FsZVNjYW5TY2FyZVNjYXR0ZXJTY2VuZVNjaGVtZVNjaG9vbFNjaWVuY2VTY2lzc29yc1Njb3JwaW9uU2NvdXRTY3JhcFNjcmVlblNjcmlwdFNjcnViU2VhU2VhcmNoU2Vhc29uU2VhdFNlY29uZFNlY3JldFNlY3Rpb25TZWN1cml0eVNlZWRTZWVrU2VnbWVudFNlbGVjdFNlbGxTZW1pbmFyU2VuaW9yU2Vuc2VTZW50ZW5jZVNlcmllc1NlcnZpY2VTZXNzaW9uU2V0dGxlU2V0dXBTZXZlblNoYWRvd1NoYWZ0U2hhbGxvd1NoYXJlU2hlZFNoZWxsU2hlcmlmZlNoaWVsZFNoaWZ0U2hpbmVTaGlwU2hpdmVyU2hvY2tTaG9lU2hvb3RTaG9wU2hvcnRTaG91bGRlclNob3ZlU2hyaW1wU2hydWdTaHVmZmxlU2h5U2libGluZ1NpY2tTaWRlU2llZ2VTaWdodFNpZ25TaWxlbnRTaWxrU2lsbHlTaWx2ZXJTaW1pbGFyU2ltcGxlU2luY2VTaW5nU2lyZW5TaXN0ZXJTaXR1YXRlU2l4U2l6ZVNrYXRlU2tldGNoU2tpU2tpbGxTa2luU2tpcnRTa3VsbFNsYWJTbGFtU2xlZXBTbGVuZGVyU2xpY2VTbGlkZVNsaWdodFNsaW1TbG9nYW5TbG90U2xvd1NsdXNoU21hbGxTbWFydFNtaWxlU21va2VTbW9vdGhTbmFja1NuYWtlU25hcFNuaWZmU25vd1NvYXBTb2NjZXJTb2NpYWxTb2NrU29kYVNvZnRTb2xhclNvbGRpZXJTb2xpZFNvbHV0aW9uU29sdmVTb21lb25lU29uZ1Nvb25Tb3JyeVNvcnRTb3VsU291bmRTb3VwU291cmNlU291dGhTcGFjZVNwYXJlU3BhdGlhbFNwYXduU3BlYWtTcGVjaWFsU3BlZWRTcGVsbFNwZW5kU3BoZXJlU3BpY2VTcGlkZXJTcGlrZVNwaW5TcGlyaXRTcGxpdFNwb2lsU3BvbnNvclNwb29uU3BvcnRTcG90U3ByYXlTcHJlYWRTcHJpbmdTcHlTcXVhcmVTcXVlZXplU3F1aXJyZWxTdGFibGVTdGFkaXVtU3RhZmZTdGFnZVN0YWlyc1N0YW1wU3RhbmRTdGFydFN0YXRlU3RheVN0ZWFrU3RlZWxTdGVtU3RlcFN0ZXJlb1N0aWNrU3RpbGxTdGluZ1N0b2NrU3RvbWFjaFN0b25lU3Rvb2xTdG9yeVN0b3ZlU3RyYXRlZ3lTdHJlZXRTdHJpa2VTdHJvbmdTdHJ1Z2dsZVN0dWRlbnRTdHVmZlN0dW1ibGVTdHlsZVN1YmplY3RTdWJtaXRTdWJ3YXlTdWNjZXNzU3VjaFN1ZGRlblN1ZmZlclN1Z2FyU3VnZ2VzdFN1aXRTdW1tZXJTdW5TdW5ueVN1bnNldFN1cGVyU3VwcGx5U3VwcmVtZVN1cmVTdXJmYWNlU3VyZ2VTdXJwcmlzZVN1cnJvdW5kU3VydmV5U3VzcGVjdFN1c3RhaW5Td2FsbG93U3dhbXBTd2FwU3dhcm1Td2VhclN3ZWV0U3dpZnRTd2ltU3dpbmdTd2l0Y2hTd29yZFN5bWJvbFN5bXB0b21TeXJ1cFN5c3RlbVRhYmxlVGFja2xlVGFnVGFpbFRhbGVudFRhbGtUYW5rVGFwZVRhcmdldFRhc2tUYXN0ZVRhdHRvb1RheGlUZWFjaFRlYW1UZWxsVGVuVGVuYW50VGVubmlzVGVudFRlcm1UZXN0VGV4dFRoYW5rVGhhdFRoZW1lVGhlblRoZW9yeVRoZXJlVGhleVRoaW5nVGhpc1Rob3VnaHRUaHJlZVRocml2ZVRocm93VGh1bWJUaHVuZGVyVGlja2V0VGlkZVRpZ2VyVGlsdFRpbWJlclRpbWVUaW55VGlwVGlyZWRUaXNzdWVUaXRsZVRvYXN0VG9iYWNjb1RvZGF5VG9kZGxlclRvZVRvZ2V0aGVyVG9pbGV0VG9rZW5Ub21hdG9Ub21vcnJvd1RvbmVUb25ndWVUb25pZ2h0VG9vbFRvb3RoVG9wVG9waWNUb3BwbGVUb3JjaFRvcm5hZG9Ub3J0b2lzZVRvc3NUb3RhbFRvdXJpc3RUb3dhcmRUb3dlclRvd25Ub3lUcmFja1RyYWRlVHJhZmZpY1RyYWdpY1RyYWluVHJhbnNmZXJUcmFwVHJhc2hUcmF2ZWxUcmF5VHJlYXRUcmVlVHJlbmRUcmlhbFRyaWJlVHJpY2tUcmlnZ2VyVHJpbVRyaXBUcm9waHlUcm91YmxlVHJ1Y2tUcnVlVHJ1bHlUcnVtcGV0VHJ1c3RUcnV0aFRyeVR1YmVUdWl0aW9uVHVtYmxlVHVuYVR1bm5lbFR1cmtleVR1cm5UdXJ0bGVUd2VsdmVUd2VudHlUd2ljZVR3aW5Ud2lzdFR3b1R5cGVUeXBpY2FsVWdseVVtYnJlbGxhVW5hYmxlVW5hd2FyZVVuY2xlVW5jb3ZlclVuZGVyVW5kb1VuZmFpclVuZm9sZFVuaGFwcHlVbmlmb3JtVW5pcXVlVW5pdFVuaXZlcnNlVW5rbm93blVubG9ja1VudGlsVW51c3VhbFVudmVpbFVwZGF0ZVVwZ3JhZGVVcGhvbGRVcG9uVXBwZXJVcHNldFVyYmFuVXJnZVVzYWdlVXNlVXNlZFVzZWZ1bFVzZWxlc3NVc3VhbFV0aWxpdHlWYWNhbnRWYWN1dW1WYWd1ZVZhbGlkVmFsbGV5VmFsdmVWYW5WYW5pc2hWYXBvclZhcmlvdXNWYXN0VmF1bHRWZWhpY2xlVmVsdmV0VmVuZG9yVmVudHVyZVZlbnVlVmVyYlZlcmlmeVZlcnNpb25WZXJ5VmVzc2VsVmV0ZXJhblZpYWJsZVZpYnJhbnRWaWNpb3VzVmljdG9yeVZpZGVvVmlld1ZpbGxhZ2VWaW50YWdlVmlvbGluVmlydHVhbFZpcnVzVmlzYVZpc2l0VmlzdWFsVml0YWxWaXZpZFZvY2FsVm9pY2VWb2lkVm9sY2Fub1ZvbHVtZVZvdGVWb3lhZ2VXYWdlV2Fnb25XYWl0V2Fsa1dhbGxXYWxudXRXYW50V2FyZmFyZVdhcm1XYXJyaW9yV2FzaFdhc3BXYXN0ZVdhdGVyV2F2ZVdheVdlYWx0aFdlYXBvbldlYXJXZWFzZWxXZWF0aGVyV2ViV2VkZGluZ1dlZWtlbmRXZWlyZFdlbGNvbWVXZXN0V2V0V2hhbGVXaGF0V2hlYXRXaGVlbFdoZW5XaGVyZVdoaXBXaGlzcGVyV2lkZVdpZHRoV2lmZVdpbGRXaWxsV2luV2luZG93V2luZVdpbmdXaW5rV2lubmVyV2ludGVyV2lyZVdpc2RvbVdpc2VXaXNoV2l0bmVzc1dvbGZXb21hbldvbmRlcldvb2RXb29sV29yZFdvcmtXb3JsZFdvcnJ5V29ydGhXcmFwV3JlY2tXcmVzdGxlV3Jpc3RXcml0ZVdyb25nWWFyZFllYXJZZWxsb3dZb3VZb3VuZ1lvdXRoWmVicmFaZXJvWm9uZVpvb1wiO1xuXHR2YXIgd29yZGxpc3QkMSA9IG51bGw7XG5cdGZ1bmN0aW9uIGxvYWRXb3JkcyhsYW5nKSB7XG5cdCAgICBpZiAod29yZGxpc3QkMSAhPSBudWxsKSB7XG5cdCAgICAgICAgcmV0dXJuO1xuXHQgICAgfVxuXHQgICAgd29yZGxpc3QkMSA9IHdvcmRzLnJlcGxhY2UoLyhbQS1aXSkvZywgXCIgJDFcIikudG9Mb3dlckNhc2UoKS5zdWJzdHJpbmcoMSkuc3BsaXQoXCIgXCIpO1xuXHQgICAgLy8gVmVyaWZ5IHRoZSBjb21wdXRlZCBsaXN0IG1hdGNoZXMgdGhlIG9mZmljaWFsIGxpc3Rcblx0ICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuXHQgICAgaWYgKHdvcmRsaXN0LldvcmRsaXN0LmNoZWNrKGxhbmcpICE9PSBcIjB4M2M4YWNjMWU3YjA4ZDhlNzZmOWZkYTAxNWVmNDhkYzhjNzEwYTczY2I3ZTBmNzdiMmMxOGE5YjVhN2FkZGU2MFwiKSB7XG5cdCAgICAgICAgd29yZGxpc3QkMSA9IG51bGw7XG5cdCAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQklQMzkgV29yZGxpc3QgZm9yIGVuIChFbmdsaXNoKSBGQUlMRURcIik7XG5cdCAgICB9XG5cdH1cblx0dmFyIExhbmdFbiA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcblx0ICAgIF9fZXh0ZW5kcyhMYW5nRW4sIF9zdXBlcik7XG5cdCAgICBmdW5jdGlvbiBMYW5nRW4oKSB7XG5cdCAgICAgICAgcmV0dXJuIF9zdXBlci5jYWxsKHRoaXMsIFwiZW5cIikgfHwgdGhpcztcblx0ICAgIH1cblx0ICAgIExhbmdFbi5wcm90b3R5cGUuZ2V0V29yZCA9IGZ1bmN0aW9uIChpbmRleCkge1xuXHQgICAgICAgIGxvYWRXb3Jkcyh0aGlzKTtcblx0ICAgICAgICByZXR1cm4gd29yZGxpc3QkMVtpbmRleF07XG5cdCAgICB9O1xuXHQgICAgTGFuZ0VuLnByb3RvdHlwZS5nZXRXb3JkSW5kZXggPSBmdW5jdGlvbiAod29yZCkge1xuXHQgICAgICAgIGxvYWRXb3Jkcyh0aGlzKTtcblx0ICAgICAgICByZXR1cm4gd29yZGxpc3QkMS5pbmRleE9mKHdvcmQpO1xuXHQgICAgfTtcblx0ICAgIHJldHVybiBMYW5nRW47XG5cdH0od29yZGxpc3QuV29yZGxpc3QpKTtcblx0dmFyIGxhbmdFbiA9IG5ldyBMYW5nRW4oKTtcblx0ZXhwb3J0cy5sYW5nRW4gPSBsYW5nRW47XG5cdHdvcmRsaXN0LldvcmRsaXN0LnJlZ2lzdGVyKGxhbmdFbik7XG5cblx0fSk7XG5cblx0dmFyIGxhbmdFbiA9IC8qQF9fUFVSRV9fKi9nZXREZWZhdWx0RXhwb3J0RnJvbUNqcyhsYW5nRW5fMSk7XG5cblx0dmFyIGJyb3dzZXJXb3JkbGlzdHMgPSBjcmVhdGVDb21tb25qc01vZHVsZShmdW5jdGlvbiAobW9kdWxlLCBleHBvcnRzKSB7XG5cdFwidXNlIHN0cmljdFwiO1xuXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5cdGV4cG9ydHMud29yZGxpc3RzID0gdm9pZCAwO1xuXG5cdGV4cG9ydHMud29yZGxpc3RzID0ge1xuXHQgICAgZW46IGxhbmdFbl8xLmxhbmdFblxuXHR9O1xuXG5cdH0pO1xuXG5cdHZhciBicm93c2VyV29yZGxpc3RzJDEgPSAvKkBfX1BVUkVfXyovZ2V0RGVmYXVsdEV4cG9ydEZyb21DanMoYnJvd3NlcldvcmRsaXN0cyk7XG5cblx0dmFyIGxpYiRqID0gY3JlYXRlQ29tbW9uanNNb2R1bGUoZnVuY3Rpb24gKG1vZHVsZSwgZXhwb3J0cykge1xuXHRcInVzZSBzdHJpY3RcIjtcblx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuXHRleHBvcnRzLndvcmRsaXN0cyA9IGV4cG9ydHMuV29yZGxpc3QgPSBleHBvcnRzLmxvZ2dlciA9IHZvaWQgMDtcblx0Ly8gV29yZGxpc3RzXG5cdC8vIFNlZTogaHR0cHM6Ly9naXRodWIuY29tL2JpdGNvaW4vYmlwcy9ibG9iL21hc3Rlci9iaXAtMDAzOS9iaXAtMDAzOS13b3JkbGlzdHMubWRcblxuXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJsb2dnZXJcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHdvcmRsaXN0LmxvZ2dlcjsgfSB9KTtcblx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiV29yZGxpc3RcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHdvcmRsaXN0LldvcmRsaXN0OyB9IH0pO1xuXG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIndvcmRsaXN0c1wiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gYnJvd3NlcldvcmRsaXN0cy53b3JkbGlzdHM7IH0gfSk7XG5cblx0fSk7XG5cblx0dmFyIGluZGV4JGogPSAvKkBfX1BVUkVfXyovZ2V0RGVmYXVsdEV4cG9ydEZyb21DanMobGliJGopO1xuXG5cdHZhciBfdmVyc2lvbiR3ID0gY3JlYXRlQ29tbW9uanNNb2R1bGUoZnVuY3Rpb24gKG1vZHVsZSwgZXhwb3J0cykge1xuXHRcInVzZSBzdHJpY3RcIjtcblx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuXHRleHBvcnRzLnZlcnNpb24gPSB2b2lkIDA7XG5cdGV4cG9ydHMudmVyc2lvbiA9IFwiaGRub2RlLzUuNS4wXCI7XG5cblx0fSk7XG5cblx0dmFyIF92ZXJzaW9uJHggPSAvKkBfX1BVUkVfXyovZ2V0RGVmYXVsdEV4cG9ydEZyb21DanMoX3ZlcnNpb24kdyk7XG5cblx0dmFyIGxpYiRrID0gY3JlYXRlQ29tbW9uanNNb2R1bGUoZnVuY3Rpb24gKG1vZHVsZSwgZXhwb3J0cykge1xuXHRcInVzZSBzdHJpY3RcIjtcblx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuXHRleHBvcnRzLmdldEFjY291bnRQYXRoID0gZXhwb3J0cy5pc1ZhbGlkTW5lbW9uaWMgPSBleHBvcnRzLmVudHJvcHlUb01uZW1vbmljID0gZXhwb3J0cy5tbmVtb25pY1RvRW50cm9weSA9IGV4cG9ydHMubW5lbW9uaWNUb1NlZWQgPSBleHBvcnRzLkhETm9kZSA9IGV4cG9ydHMuZGVmYXVsdFBhdGggPSB2b2lkIDA7XG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cdHZhciBsb2dnZXIgPSBuZXcgbGliLkxvZ2dlcihfdmVyc2lvbiR3LnZlcnNpb24pO1xuXHR2YXIgTiA9IGxpYiQyLkJpZ051bWJlci5mcm9tKFwiMHhmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZWJhYWVkY2U2YWY0OGEwM2JiZmQyNWU4Y2QwMzY0MTQxXCIpO1xuXHQvLyBcIkJpdGNvaW4gc2VlZFwiXG5cdHZhciBNYXN0ZXJTZWNyZXQgPSAoMCwgbGliJDgudG9VdGY4Qnl0ZXMpKFwiQml0Y29pbiBzZWVkXCIpO1xuXHR2YXIgSGFyZGVuZWRCaXQgPSAweDgwMDAwMDAwO1xuXHQvLyBSZXR1cm5zIGEgYnl0ZSB3aXRoIHRoZSBNU0IgYml0cyBzZXRcblx0ZnVuY3Rpb24gZ2V0VXBwZXJNYXNrKGJpdHMpIHtcblx0ICAgIHJldHVybiAoKDEgPDwgYml0cykgLSAxKSA8PCAoOCAtIGJpdHMpO1xuXHR9XG5cdC8vIFJldHVybnMgYSBieXRlIHdpdGggdGhlIExTQiBiaXRzIHNldFxuXHRmdW5jdGlvbiBnZXRMb3dlck1hc2soYml0cykge1xuXHQgICAgcmV0dXJuICgxIDw8IGJpdHMpIC0gMTtcblx0fVxuXHRmdW5jdGlvbiBieXRlczMyKHZhbHVlKSB7XG5cdCAgICByZXR1cm4gKDAsIGxpYiQxLmhleFplcm9QYWQpKCgwLCBsaWIkMS5oZXhsaWZ5KSh2YWx1ZSksIDMyKTtcblx0fVxuXHRmdW5jdGlvbiBiYXNlNThjaGVjayhkYXRhKSB7XG5cdCAgICByZXR1cm4gbGliJGcuQmFzZTU4LmVuY29kZSgoMCwgbGliJDEuY29uY2F0KShbZGF0YSwgKDAsIGxpYiQxLmhleERhdGFTbGljZSkoKDAsIGxpYiRoLnNoYTI1NikoKDAsIGxpYiRoLnNoYTI1NikoZGF0YSkpLCAwLCA0KV0pKTtcblx0fVxuXHRmdW5jdGlvbiBnZXRXb3JkbGlzdCh3b3JkbGlzdCkge1xuXHQgICAgaWYgKHdvcmRsaXN0ID09IG51bGwpIHtcblx0ICAgICAgICByZXR1cm4gbGliJGoud29yZGxpc3RzW1wiZW5cIl07XG5cdCAgICB9XG5cdCAgICBpZiAodHlwZW9mICh3b3JkbGlzdCkgPT09IFwic3RyaW5nXCIpIHtcblx0ICAgICAgICB2YXIgd29yZHMgPSBsaWIkai53b3JkbGlzdHNbd29yZGxpc3RdO1xuXHQgICAgICAgIGlmICh3b3JkcyA9PSBudWxsKSB7XG5cdCAgICAgICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJ1bmtub3duIGxvY2FsZVwiLCBcIndvcmRsaXN0XCIsIHdvcmRsaXN0KTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgcmV0dXJuIHdvcmRzO1xuXHQgICAgfVxuXHQgICAgcmV0dXJuIHdvcmRsaXN0O1xuXHR9XG5cdHZhciBfY29uc3RydWN0b3JHdWFyZCA9IHt9O1xuXHRleHBvcnRzLmRlZmF1bHRQYXRoID0gXCJtLzQ0Jy82MCcvMCcvMC8wXCI7XG5cdDtcblx0dmFyIEhETm9kZSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcblx0ICAgIC8qKlxuXHQgICAgICogIFRoaXMgY29uc3RydWN0b3Igc2hvdWxkIG5vdCBiZSBjYWxsZWQgZGlyZWN0bHkuXG5cdCAgICAgKlxuXHQgICAgICogIFBsZWFzZSB1c2U6XG5cdCAgICAgKiAgIC0gZnJvbU1uZW1vbmljXG5cdCAgICAgKiAgIC0gZnJvbVNlZWRcblx0ICAgICAqL1xuXHQgICAgZnVuY3Rpb24gSEROb2RlKGNvbnN0cnVjdG9yR3VhcmQsIHByaXZhdGVLZXksIHB1YmxpY0tleSwgcGFyZW50RmluZ2VycHJpbnQsIGNoYWluQ29kZSwgaW5kZXgsIGRlcHRoLCBtbmVtb25pY09yUGF0aCkge1xuXHQgICAgICAgIHZhciBfbmV3VGFyZ2V0ID0gdGhpcy5jb25zdHJ1Y3Rvcjtcblx0ICAgICAgICBsb2dnZXIuY2hlY2tOZXcoX25ld1RhcmdldCwgSEROb2RlKTtcblx0ICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cblx0ICAgICAgICBpZiAoY29uc3RydWN0b3JHdWFyZCAhPT0gX2NvbnN0cnVjdG9yR3VhcmQpIHtcblx0ICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSEROb2RlIGNvbnN0cnVjdG9yIGNhbm5vdCBiZSBjYWxsZWQgZGlyZWN0bHlcIik7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGlmIChwcml2YXRlS2V5KSB7XG5cdCAgICAgICAgICAgIHZhciBzaWduaW5nS2V5ID0gbmV3IGxpYiRkLlNpZ25pbmdLZXkocHJpdmF0ZUtleSk7XG5cdCAgICAgICAgICAgICgwLCBsaWIkMy5kZWZpbmVSZWFkT25seSkodGhpcywgXCJwcml2YXRlS2V5XCIsIHNpZ25pbmdLZXkucHJpdmF0ZUtleSk7XG5cdCAgICAgICAgICAgICgwLCBsaWIkMy5kZWZpbmVSZWFkT25seSkodGhpcywgXCJwdWJsaWNLZXlcIiwgc2lnbmluZ0tleS5jb21wcmVzc2VkUHVibGljS2V5KTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgZWxzZSB7XG5cdCAgICAgICAgICAgICgwLCBsaWIkMy5kZWZpbmVSZWFkT25seSkodGhpcywgXCJwcml2YXRlS2V5XCIsIG51bGwpO1xuXHQgICAgICAgICAgICAoMCwgbGliJDMuZGVmaW5lUmVhZE9ubHkpKHRoaXMsIFwicHVibGljS2V5XCIsICgwLCBsaWIkMS5oZXhsaWZ5KShwdWJsaWNLZXkpKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgKDAsIGxpYiQzLmRlZmluZVJlYWRPbmx5KSh0aGlzLCBcInBhcmVudEZpbmdlcnByaW50XCIsIHBhcmVudEZpbmdlcnByaW50KTtcblx0ICAgICAgICAoMCwgbGliJDMuZGVmaW5lUmVhZE9ubHkpKHRoaXMsIFwiZmluZ2VycHJpbnRcIiwgKDAsIGxpYiQxLmhleERhdGFTbGljZSkoKDAsIGxpYiRoLnJpcGVtZDE2MCkoKDAsIGxpYiRoLnNoYTI1NikodGhpcy5wdWJsaWNLZXkpKSwgMCwgNCkpO1xuXHQgICAgICAgICgwLCBsaWIkMy5kZWZpbmVSZWFkT25seSkodGhpcywgXCJhZGRyZXNzXCIsICgwLCBsaWIkZS5jb21wdXRlQWRkcmVzcykodGhpcy5wdWJsaWNLZXkpKTtcblx0ICAgICAgICAoMCwgbGliJDMuZGVmaW5lUmVhZE9ubHkpKHRoaXMsIFwiY2hhaW5Db2RlXCIsIGNoYWluQ29kZSk7XG5cdCAgICAgICAgKDAsIGxpYiQzLmRlZmluZVJlYWRPbmx5KSh0aGlzLCBcImluZGV4XCIsIGluZGV4KTtcblx0ICAgICAgICAoMCwgbGliJDMuZGVmaW5lUmVhZE9ubHkpKHRoaXMsIFwiZGVwdGhcIiwgZGVwdGgpO1xuXHQgICAgICAgIGlmIChtbmVtb25pY09yUGF0aCA9PSBudWxsKSB7XG5cdCAgICAgICAgICAgIC8vIEZyb20gYSBzb3VyY2UgdGhhdCBkb2VzIG5vdCBwcmVzZXJ2ZSB0aGUgcGF0aCAoZS5nLiBleHRlbmRlZCBrZXlzKVxuXHQgICAgICAgICAgICAoMCwgbGliJDMuZGVmaW5lUmVhZE9ubHkpKHRoaXMsIFwibW5lbW9uaWNcIiwgbnVsbCk7XG5cdCAgICAgICAgICAgICgwLCBsaWIkMy5kZWZpbmVSZWFkT25seSkodGhpcywgXCJwYXRoXCIsIG51bGwpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBlbHNlIGlmICh0eXBlb2YgKG1uZW1vbmljT3JQYXRoKSA9PT0gXCJzdHJpbmdcIikge1xuXHQgICAgICAgICAgICAvLyBGcm9tIGEgc291cmNlIHRoYXQgZG9lcyBub3QgcHJlc2VydmUgdGhlIG1uZW1vbmljIChlLmcuIG5ldXRlcmVkKVxuXHQgICAgICAgICAgICAoMCwgbGliJDMuZGVmaW5lUmVhZE9ubHkpKHRoaXMsIFwibW5lbW9uaWNcIiwgbnVsbCk7XG5cdCAgICAgICAgICAgICgwLCBsaWIkMy5kZWZpbmVSZWFkT25seSkodGhpcywgXCJwYXRoXCIsIG1uZW1vbmljT3JQYXRoKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgZWxzZSB7XG5cdCAgICAgICAgICAgIC8vIEZyb20gYSBmdWxseSBxdWFsaWZpZWQgc291cmNlXG5cdCAgICAgICAgICAgICgwLCBsaWIkMy5kZWZpbmVSZWFkT25seSkodGhpcywgXCJtbmVtb25pY1wiLCBtbmVtb25pY09yUGF0aCk7XG5cdCAgICAgICAgICAgICgwLCBsaWIkMy5kZWZpbmVSZWFkT25seSkodGhpcywgXCJwYXRoXCIsIG1uZW1vbmljT3JQYXRoLnBhdGgpO1xuXHQgICAgICAgIH1cblx0ICAgIH1cblx0ICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShIRE5vZGUucHJvdG90eXBlLCBcImV4dGVuZGVkS2V5XCIsIHtcblx0ICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgLy8gV2Ugb25seSBzdXBwb3J0IHRoZSBtYWlubmV0IHZhbHVlcyBmb3Igbm93LCBidXQgaWYgYW55b25lIG5lZWRzXG5cdCAgICAgICAgICAgIC8vIHRlc3RuZXQgdmFsdWVzLCBsZXQgbWUga25vdy4gSSBiZWxpZXZlIGN1cnJlbnQgc2VudGltZW50IGlzIHRoYXRcblx0ICAgICAgICAgICAgLy8gd2Ugc2hvdWxkIGFsd2F5cyB1c2UgbWFpbm5ldCwgYW5kIHVzZSBCSVAtNDQgdG8gZGVyaXZlIHRoZSBuZXR3b3JrXG5cdCAgICAgICAgICAgIC8vICAgLSBNYWlubmV0OiBwdWJsaWM9MHgwNDg4QjIxRSwgcHJpdmF0ZT0weDA0ODhBREU0XG5cdCAgICAgICAgICAgIC8vICAgLSBUZXN0bmV0OiBwdWJsaWM9MHgwNDM1ODdDRiwgcHJpdmF0ZT0weDA0MzU4Mzk0XG5cdCAgICAgICAgICAgIGlmICh0aGlzLmRlcHRoID49IDI1Nikge1xuXHQgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRGVwdGggdG9vIGxhcmdlIVwiKTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICByZXR1cm4gYmFzZTU4Y2hlY2soKDAsIGxpYiQxLmNvbmNhdCkoW1xuXHQgICAgICAgICAgICAgICAgKCh0aGlzLnByaXZhdGVLZXkgIT0gbnVsbCkgPyBcIjB4MDQ4OEFERTRcIiA6IFwiMHgwNDg4QjIxRVwiKSxcblx0ICAgICAgICAgICAgICAgICgwLCBsaWIkMS5oZXhsaWZ5KSh0aGlzLmRlcHRoKSxcblx0ICAgICAgICAgICAgICAgIHRoaXMucGFyZW50RmluZ2VycHJpbnQsXG5cdCAgICAgICAgICAgICAgICAoMCwgbGliJDEuaGV4WmVyb1BhZCkoKDAsIGxpYiQxLmhleGxpZnkpKHRoaXMuaW5kZXgpLCA0KSxcblx0ICAgICAgICAgICAgICAgIHRoaXMuY2hhaW5Db2RlLFxuXHQgICAgICAgICAgICAgICAgKCh0aGlzLnByaXZhdGVLZXkgIT0gbnVsbCkgPyAoMCwgbGliJDEuY29uY2F0KShbXCIweDAwXCIsIHRoaXMucHJpdmF0ZUtleV0pIDogdGhpcy5wdWJsaWNLZXkpLFxuXHQgICAgICAgICAgICBdKSk7XG5cdCAgICAgICAgfSxcblx0ICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcblx0ICAgICAgICBjb25maWd1cmFibGU6IHRydWVcblx0ICAgIH0pO1xuXHQgICAgSEROb2RlLnByb3RvdHlwZS5uZXV0ZXIgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgcmV0dXJuIG5ldyBIRE5vZGUoX2NvbnN0cnVjdG9yR3VhcmQsIG51bGwsIHRoaXMucHVibGljS2V5LCB0aGlzLnBhcmVudEZpbmdlcnByaW50LCB0aGlzLmNoYWluQ29kZSwgdGhpcy5pbmRleCwgdGhpcy5kZXB0aCwgdGhpcy5wYXRoKTtcblx0ICAgIH07XG5cdCAgICBIRE5vZGUucHJvdG90eXBlLl9kZXJpdmUgPSBmdW5jdGlvbiAoaW5kZXgpIHtcblx0ICAgICAgICBpZiAoaW5kZXggPiAweGZmZmZmZmZmKSB7XG5cdCAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImludmFsaWQgaW5kZXggLSBcIiArIFN0cmluZyhpbmRleCkpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICAvLyBCYXNlIHBhdGhcblx0ICAgICAgICB2YXIgcGF0aCA9IHRoaXMucGF0aDtcblx0ICAgICAgICBpZiAocGF0aCkge1xuXHQgICAgICAgICAgICBwYXRoICs9IFwiL1wiICsgKGluZGV4ICYgfkhhcmRlbmVkQml0KTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgdmFyIGRhdGEgPSBuZXcgVWludDhBcnJheSgzNyk7XG5cdCAgICAgICAgaWYgKGluZGV4ICYgSGFyZGVuZWRCaXQpIHtcblx0ICAgICAgICAgICAgaWYgKCF0aGlzLnByaXZhdGVLZXkpIHtcblx0ICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImNhbm5vdCBkZXJpdmUgY2hpbGQgb2YgbmV1dGVyZWQgbm9kZVwiKTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAvLyBEYXRhID0gMHgwMCB8fCBzZXJfMjU2KGtfcGFyKVxuXHQgICAgICAgICAgICBkYXRhLnNldCgoMCwgbGliJDEuYXJyYXlpZnkpKHRoaXMucHJpdmF0ZUtleSksIDEpO1xuXHQgICAgICAgICAgICAvLyBIYXJkZW5lZCBwYXRoXG5cdCAgICAgICAgICAgIGlmIChwYXRoKSB7XG5cdCAgICAgICAgICAgICAgICBwYXRoICs9IFwiJ1wiO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGVsc2Uge1xuXHQgICAgICAgICAgICAvLyBEYXRhID0gc2VyX3AocG9pbnQoa19wYXIpKVxuXHQgICAgICAgICAgICBkYXRhLnNldCgoMCwgbGliJDEuYXJyYXlpZnkpKHRoaXMucHVibGljS2V5KSk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIC8vIERhdGEgKz0gc2VyXzMyKGkpXG5cdCAgICAgICAgZm9yICh2YXIgaSA9IDI0OyBpID49IDA7IGkgLT0gOCkge1xuXHQgICAgICAgICAgICBkYXRhWzMzICsgKGkgPj4gMyldID0gKChpbmRleCA+PiAoMjQgLSBpKSkgJiAweGZmKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgdmFyIEkgPSAoMCwgbGliJDEuYXJyYXlpZnkpKCgwLCBsaWIkaC5jb21wdXRlSG1hYykobGliJGguU3VwcG9ydGVkQWxnb3JpdGhtLnNoYTUxMiwgdGhpcy5jaGFpbkNvZGUsIGRhdGEpKTtcblx0ICAgICAgICB2YXIgSUwgPSBJLnNsaWNlKDAsIDMyKTtcblx0ICAgICAgICB2YXIgSVIgPSBJLnNsaWNlKDMyKTtcblx0ICAgICAgICAvLyBUaGUgcHJpdmF0ZSBrZXlcblx0ICAgICAgICB2YXIga2kgPSBudWxsO1xuXHQgICAgICAgIC8vIFRoZSBwdWJsaWMga2V5XG5cdCAgICAgICAgdmFyIEtpID0gbnVsbDtcblx0ICAgICAgICBpZiAodGhpcy5wcml2YXRlS2V5KSB7XG5cdCAgICAgICAgICAgIGtpID0gYnl0ZXMzMihsaWIkMi5CaWdOdW1iZXIuZnJvbShJTCkuYWRkKHRoaXMucHJpdmF0ZUtleSkubW9kKE4pKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgZWxzZSB7XG5cdCAgICAgICAgICAgIHZhciBlayA9IG5ldyBsaWIkZC5TaWduaW5nS2V5KCgwLCBsaWIkMS5oZXhsaWZ5KShJTCkpO1xuXHQgICAgICAgICAgICBLaSA9IGVrLl9hZGRQb2ludCh0aGlzLnB1YmxpY0tleSk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHZhciBtbmVtb25pY09yUGF0aCA9IHBhdGg7XG5cdCAgICAgICAgdmFyIHNyY01uZW1vbmljID0gdGhpcy5tbmVtb25pYztcblx0ICAgICAgICBpZiAoc3JjTW5lbW9uaWMpIHtcblx0ICAgICAgICAgICAgbW5lbW9uaWNPclBhdGggPSBPYmplY3QuZnJlZXplKHtcblx0ICAgICAgICAgICAgICAgIHBocmFzZTogc3JjTW5lbW9uaWMucGhyYXNlLFxuXHQgICAgICAgICAgICAgICAgcGF0aDogcGF0aCxcblx0ICAgICAgICAgICAgICAgIGxvY2FsZTogKHNyY01uZW1vbmljLmxvY2FsZSB8fCBcImVuXCIpXG5cdCAgICAgICAgICAgIH0pO1xuXHQgICAgICAgIH1cblx0ICAgICAgICByZXR1cm4gbmV3IEhETm9kZShfY29uc3RydWN0b3JHdWFyZCwga2ksIEtpLCB0aGlzLmZpbmdlcnByaW50LCBieXRlczMyKElSKSwgaW5kZXgsIHRoaXMuZGVwdGggKyAxLCBtbmVtb25pY09yUGF0aCk7XG5cdCAgICB9O1xuXHQgICAgSEROb2RlLnByb3RvdHlwZS5kZXJpdmVQYXRoID0gZnVuY3Rpb24gKHBhdGgpIHtcblx0ICAgICAgICB2YXIgY29tcG9uZW50cyA9IHBhdGguc3BsaXQoXCIvXCIpO1xuXHQgICAgICAgIGlmIChjb21wb25lbnRzLmxlbmd0aCA9PT0gMCB8fCAoY29tcG9uZW50c1swXSA9PT0gXCJtXCIgJiYgdGhpcy5kZXB0aCAhPT0gMCkpIHtcblx0ICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBwYXRoIC0gXCIgKyBwYXRoKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgaWYgKGNvbXBvbmVudHNbMF0gPT09IFwibVwiKSB7XG5cdCAgICAgICAgICAgIGNvbXBvbmVudHMuc2hpZnQoKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgdmFyIHJlc3VsdCA9IHRoaXM7XG5cdCAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb21wb25lbnRzLmxlbmd0aDsgaSsrKSB7XG5cdCAgICAgICAgICAgIHZhciBjb21wb25lbnQgPSBjb21wb25lbnRzW2ldO1xuXHQgICAgICAgICAgICBpZiAoY29tcG9uZW50Lm1hdGNoKC9eWzAtOV0rJyQvKSkge1xuXHQgICAgICAgICAgICAgICAgdmFyIGluZGV4ID0gcGFyc2VJbnQoY29tcG9uZW50LnN1YnN0cmluZygwLCBjb21wb25lbnQubGVuZ3RoIC0gMSkpO1xuXHQgICAgICAgICAgICAgICAgaWYgKGluZGV4ID49IEhhcmRlbmVkQml0KSB7XG5cdCAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBwYXRoIGluZGV4IC0gXCIgKyBjb21wb25lbnQpO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgcmVzdWx0ID0gcmVzdWx0Ll9kZXJpdmUoSGFyZGVuZWRCaXQgKyBpbmRleCk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgZWxzZSBpZiAoY29tcG9uZW50Lm1hdGNoKC9eWzAtOV0rJC8pKSB7XG5cdCAgICAgICAgICAgICAgICB2YXIgaW5kZXggPSBwYXJzZUludChjb21wb25lbnQpO1xuXHQgICAgICAgICAgICAgICAgaWYgKGluZGV4ID49IEhhcmRlbmVkQml0KSB7XG5cdCAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBwYXRoIGluZGV4IC0gXCIgKyBjb21wb25lbnQpO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgcmVzdWx0ID0gcmVzdWx0Ll9kZXJpdmUoaW5kZXgpO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIGVsc2Uge1xuXHQgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBwYXRoIGNvbXBvbmVudCAtIFwiICsgY29tcG9uZW50KTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH1cblx0ICAgICAgICByZXR1cm4gcmVzdWx0O1xuXHQgICAgfTtcblx0ICAgIEhETm9kZS5fZnJvbVNlZWQgPSBmdW5jdGlvbiAoc2VlZCwgbW5lbW9uaWMpIHtcblx0ICAgICAgICB2YXIgc2VlZEFycmF5ID0gKDAsIGxpYiQxLmFycmF5aWZ5KShzZWVkKTtcblx0ICAgICAgICBpZiAoc2VlZEFycmF5Lmxlbmd0aCA8IDE2IHx8IHNlZWRBcnJheS5sZW5ndGggPiA2NCkge1xuXHQgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIHNlZWRcIik7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHZhciBJID0gKDAsIGxpYiQxLmFycmF5aWZ5KSgoMCwgbGliJGguY29tcHV0ZUhtYWMpKGxpYiRoLlN1cHBvcnRlZEFsZ29yaXRobS5zaGE1MTIsIE1hc3RlclNlY3JldCwgc2VlZEFycmF5KSk7XG5cdCAgICAgICAgcmV0dXJuIG5ldyBIRE5vZGUoX2NvbnN0cnVjdG9yR3VhcmQsIGJ5dGVzMzIoSS5zbGljZSgwLCAzMikpLCBudWxsLCBcIjB4MDAwMDAwMDBcIiwgYnl0ZXMzMihJLnNsaWNlKDMyKSksIDAsIDAsIG1uZW1vbmljKTtcblx0ICAgIH07XG5cdCAgICBIRE5vZGUuZnJvbU1uZW1vbmljID0gZnVuY3Rpb24gKG1uZW1vbmljLCBwYXNzd29yZCwgd29yZGxpc3QpIHtcblx0ICAgICAgICAvLyBJZiBhIGxvY2FsZSBuYW1lIHdhcyBwYXNzZWQgaW4sIGZpbmQgdGhlIGFzc29jaWF0ZWQgd29yZGxpc3Rcblx0ICAgICAgICB3b3JkbGlzdCA9IGdldFdvcmRsaXN0KHdvcmRsaXN0KTtcblx0ICAgICAgICAvLyBOb3JtYWxpemUgdGhlIGNhc2UgYW5kIHNwYWNpbmcgaW4gdGhlIG1uZW1vbmljICh0aHJvd3MgaWYgdGhlIG1uZW1vbmljIGlzIGludmFsaWQpXG5cdCAgICAgICAgbW5lbW9uaWMgPSBlbnRyb3B5VG9NbmVtb25pYyhtbmVtb25pY1RvRW50cm9weShtbmVtb25pYywgd29yZGxpc3QpLCB3b3JkbGlzdCk7XG5cdCAgICAgICAgcmV0dXJuIEhETm9kZS5fZnJvbVNlZWQobW5lbW9uaWNUb1NlZWQobW5lbW9uaWMsIHBhc3N3b3JkKSwge1xuXHQgICAgICAgICAgICBwaHJhc2U6IG1uZW1vbmljLFxuXHQgICAgICAgICAgICBwYXRoOiBcIm1cIixcblx0ICAgICAgICAgICAgbG9jYWxlOiB3b3JkbGlzdC5sb2NhbGVcblx0ICAgICAgICB9KTtcblx0ICAgIH07XG5cdCAgICBIRE5vZGUuZnJvbVNlZWQgPSBmdW5jdGlvbiAoc2VlZCkge1xuXHQgICAgICAgIHJldHVybiBIRE5vZGUuX2Zyb21TZWVkKHNlZWQsIG51bGwpO1xuXHQgICAgfTtcblx0ICAgIEhETm9kZS5mcm9tRXh0ZW5kZWRLZXkgPSBmdW5jdGlvbiAoZXh0ZW5kZWRLZXkpIHtcblx0ICAgICAgICB2YXIgYnl0ZXMgPSBsaWIkZy5CYXNlNTguZGVjb2RlKGV4dGVuZGVkS2V5KTtcblx0ICAgICAgICBpZiAoYnl0ZXMubGVuZ3RoICE9PSA4MiB8fCBiYXNlNThjaGVjayhieXRlcy5zbGljZSgwLCA3OCkpICE9PSBleHRlbmRlZEtleSkge1xuXHQgICAgICAgICAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwiaW52YWxpZCBleHRlbmRlZCBrZXlcIiwgXCJleHRlbmRlZEtleVwiLCBcIltSRURBQ1RFRF1cIik7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHZhciBkZXB0aCA9IGJ5dGVzWzRdO1xuXHQgICAgICAgIHZhciBwYXJlbnRGaW5nZXJwcmludCA9ICgwLCBsaWIkMS5oZXhsaWZ5KShieXRlcy5zbGljZSg1LCA5KSk7XG5cdCAgICAgICAgdmFyIGluZGV4ID0gcGFyc2VJbnQoKDAsIGxpYiQxLmhleGxpZnkpKGJ5dGVzLnNsaWNlKDksIDEzKSkuc3Vic3RyaW5nKDIpLCAxNik7XG5cdCAgICAgICAgdmFyIGNoYWluQ29kZSA9ICgwLCBsaWIkMS5oZXhsaWZ5KShieXRlcy5zbGljZSgxMywgNDUpKTtcblx0ICAgICAgICB2YXIga2V5ID0gYnl0ZXMuc2xpY2UoNDUsIDc4KTtcblx0ICAgICAgICBzd2l0Y2ggKCgwLCBsaWIkMS5oZXhsaWZ5KShieXRlcy5zbGljZSgwLCA0KSkpIHtcblx0ICAgICAgICAgICAgLy8gUHVibGljIEtleVxuXHQgICAgICAgICAgICBjYXNlIFwiMHgwNDg4YjIxZVwiOlxuXHQgICAgICAgICAgICBjYXNlIFwiMHgwNDM1ODdjZlwiOlxuXHQgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBIRE5vZGUoX2NvbnN0cnVjdG9yR3VhcmQsIG51bGwsICgwLCBsaWIkMS5oZXhsaWZ5KShrZXkpLCBwYXJlbnRGaW5nZXJwcmludCwgY2hhaW5Db2RlLCBpbmRleCwgZGVwdGgsIG51bGwpO1xuXHQgICAgICAgICAgICAvLyBQcml2YXRlIEtleVxuXHQgICAgICAgICAgICBjYXNlIFwiMHgwNDg4YWRlNFwiOlxuXHQgICAgICAgICAgICBjYXNlIFwiMHgwNDM1ODM5NCBcIjpcblx0ICAgICAgICAgICAgICAgIGlmIChrZXlbMF0gIT09IDApIHtcblx0ICAgICAgICAgICAgICAgICAgICBicmVhaztcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgIHJldHVybiBuZXcgSEROb2RlKF9jb25zdHJ1Y3Rvckd1YXJkLCAoMCwgbGliJDEuaGV4bGlmeSkoa2V5LnNsaWNlKDEpKSwgbnVsbCwgcGFyZW50RmluZ2VycHJpbnQsIGNoYWluQ29kZSwgaW5kZXgsIGRlcHRoLCBudWxsKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgcmV0dXJuIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJpbnZhbGlkIGV4dGVuZGVkIGtleVwiLCBcImV4dGVuZGVkS2V5XCIsIFwiW1JFREFDVEVEXVwiKTtcblx0ICAgIH07XG5cdCAgICByZXR1cm4gSEROb2RlO1xuXHR9KCkpO1xuXHRleHBvcnRzLkhETm9kZSA9IEhETm9kZTtcblx0ZnVuY3Rpb24gbW5lbW9uaWNUb1NlZWQobW5lbW9uaWMsIHBhc3N3b3JkKSB7XG5cdCAgICBpZiAoIXBhc3N3b3JkKSB7XG5cdCAgICAgICAgcGFzc3dvcmQgPSBcIlwiO1xuXHQgICAgfVxuXHQgICAgdmFyIHNhbHQgPSAoMCwgbGliJDgudG9VdGY4Qnl0ZXMpKFwibW5lbW9uaWNcIiArIHBhc3N3b3JkLCBsaWIkOC5Vbmljb2RlTm9ybWFsaXphdGlvbkZvcm0uTkZLRCk7XG5cdCAgICByZXR1cm4gKDAsIGxpYiRpLnBia2RmMikoKDAsIGxpYiQ4LnRvVXRmOEJ5dGVzKShtbmVtb25pYywgbGliJDguVW5pY29kZU5vcm1hbGl6YXRpb25Gb3JtLk5GS0QpLCBzYWx0LCAyMDQ4LCA2NCwgXCJzaGE1MTJcIik7XG5cdH1cblx0ZXhwb3J0cy5tbmVtb25pY1RvU2VlZCA9IG1uZW1vbmljVG9TZWVkO1xuXHRmdW5jdGlvbiBtbmVtb25pY1RvRW50cm9weShtbmVtb25pYywgd29yZGxpc3QpIHtcblx0ICAgIHdvcmRsaXN0ID0gZ2V0V29yZGxpc3Qod29yZGxpc3QpO1xuXHQgICAgbG9nZ2VyLmNoZWNrTm9ybWFsaXplKCk7XG5cdCAgICB2YXIgd29yZHMgPSB3b3JkbGlzdC5zcGxpdChtbmVtb25pYyk7XG5cdCAgICBpZiAoKHdvcmRzLmxlbmd0aCAlIDMpICE9PSAwKSB7XG5cdCAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBtbmVtb25pY1wiKTtcblx0ICAgIH1cblx0ICAgIHZhciBlbnRyb3B5ID0gKDAsIGxpYiQxLmFycmF5aWZ5KShuZXcgVWludDhBcnJheShNYXRoLmNlaWwoMTEgKiB3b3Jkcy5sZW5ndGggLyA4KSkpO1xuXHQgICAgdmFyIG9mZnNldCA9IDA7XG5cdCAgICBmb3IgKHZhciBpID0gMDsgaSA8IHdvcmRzLmxlbmd0aDsgaSsrKSB7XG5cdCAgICAgICAgdmFyIGluZGV4ID0gd29yZGxpc3QuZ2V0V29yZEluZGV4KHdvcmRzW2ldLm5vcm1hbGl6ZShcIk5GS0RcIikpO1xuXHQgICAgICAgIGlmIChpbmRleCA9PT0gLTEpIHtcblx0ICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBtbmVtb25pY1wiKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgZm9yICh2YXIgYml0ID0gMDsgYml0IDwgMTE7IGJpdCsrKSB7XG5cdCAgICAgICAgICAgIGlmIChpbmRleCAmICgxIDw8ICgxMCAtIGJpdCkpKSB7XG5cdCAgICAgICAgICAgICAgICBlbnRyb3B5W29mZnNldCA+PiAzXSB8PSAoMSA8PCAoNyAtIChvZmZzZXQgJSA4KSkpO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIG9mZnNldCsrO1xuXHQgICAgICAgIH1cblx0ICAgIH1cblx0ICAgIHZhciBlbnRyb3B5Qml0cyA9IDMyICogd29yZHMubGVuZ3RoIC8gMztcblx0ICAgIHZhciBjaGVja3N1bUJpdHMgPSB3b3Jkcy5sZW5ndGggLyAzO1xuXHQgICAgdmFyIGNoZWNrc3VtTWFzayA9IGdldFVwcGVyTWFzayhjaGVja3N1bUJpdHMpO1xuXHQgICAgdmFyIGNoZWNrc3VtID0gKDAsIGxpYiQxLmFycmF5aWZ5KSgoMCwgbGliJGguc2hhMjU2KShlbnRyb3B5LnNsaWNlKDAsIGVudHJvcHlCaXRzIC8gOCkpKVswXSAmIGNoZWNrc3VtTWFzaztcblx0ICAgIGlmIChjaGVja3N1bSAhPT0gKGVudHJvcHlbZW50cm9weS5sZW5ndGggLSAxXSAmIGNoZWNrc3VtTWFzaykpIHtcblx0ICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIGNoZWNrc3VtXCIpO1xuXHQgICAgfVxuXHQgICAgcmV0dXJuICgwLCBsaWIkMS5oZXhsaWZ5KShlbnRyb3B5LnNsaWNlKDAsIGVudHJvcHlCaXRzIC8gOCkpO1xuXHR9XG5cdGV4cG9ydHMubW5lbW9uaWNUb0VudHJvcHkgPSBtbmVtb25pY1RvRW50cm9weTtcblx0ZnVuY3Rpb24gZW50cm9weVRvTW5lbW9uaWMoZW50cm9weSwgd29yZGxpc3QpIHtcblx0ICAgIHdvcmRsaXN0ID0gZ2V0V29yZGxpc3Qod29yZGxpc3QpO1xuXHQgICAgZW50cm9weSA9ICgwLCBsaWIkMS5hcnJheWlmeSkoZW50cm9weSk7XG5cdCAgICBpZiAoKGVudHJvcHkubGVuZ3RoICUgNCkgIT09IDAgfHwgZW50cm9weS5sZW5ndGggPCAxNiB8fCBlbnRyb3B5Lmxlbmd0aCA+IDMyKSB7XG5cdCAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBlbnRyb3B5XCIpO1xuXHQgICAgfVxuXHQgICAgdmFyIGluZGljZXMgPSBbMF07XG5cdCAgICB2YXIgcmVtYWluaW5nQml0cyA9IDExO1xuXHQgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBlbnRyb3B5Lmxlbmd0aDsgaSsrKSB7XG5cdCAgICAgICAgLy8gQ29uc3VtZSB0aGUgd2hvbGUgYnl0ZSAod2l0aCBzdGlsbCBtb3JlIHRvIGdvKVxuXHQgICAgICAgIGlmIChyZW1haW5pbmdCaXRzID4gOCkge1xuXHQgICAgICAgICAgICBpbmRpY2VzW2luZGljZXMubGVuZ3RoIC0gMV0gPDw9IDg7XG5cdCAgICAgICAgICAgIGluZGljZXNbaW5kaWNlcy5sZW5ndGggLSAxXSB8PSBlbnRyb3B5W2ldO1xuXHQgICAgICAgICAgICByZW1haW5pbmdCaXRzIC09IDg7XG5cdCAgICAgICAgICAgIC8vIFRoaXMgYnl0ZSB3aWxsIGNvbXBsZXRlIGFuIDExLWJpdCBpbmRleFxuXHQgICAgICAgIH1cblx0ICAgICAgICBlbHNlIHtcblx0ICAgICAgICAgICAgaW5kaWNlc1tpbmRpY2VzLmxlbmd0aCAtIDFdIDw8PSByZW1haW5pbmdCaXRzO1xuXHQgICAgICAgICAgICBpbmRpY2VzW2luZGljZXMubGVuZ3RoIC0gMV0gfD0gZW50cm9weVtpXSA+PiAoOCAtIHJlbWFpbmluZ0JpdHMpO1xuXHQgICAgICAgICAgICAvLyBTdGFydCB0aGUgbmV4dCB3b3JkXG5cdCAgICAgICAgICAgIGluZGljZXMucHVzaChlbnRyb3B5W2ldICYgZ2V0TG93ZXJNYXNrKDggLSByZW1haW5pbmdCaXRzKSk7XG5cdCAgICAgICAgICAgIHJlbWFpbmluZ0JpdHMgKz0gMztcblx0ICAgICAgICB9XG5cdCAgICB9XG5cdCAgICAvLyBDb21wdXRlIHRoZSBjaGVja3N1bSBiaXRzXG5cdCAgICB2YXIgY2hlY2tzdW1CaXRzID0gZW50cm9weS5sZW5ndGggLyA0O1xuXHQgICAgdmFyIGNoZWNrc3VtID0gKDAsIGxpYiQxLmFycmF5aWZ5KSgoMCwgbGliJGguc2hhMjU2KShlbnRyb3B5KSlbMF0gJiBnZXRVcHBlck1hc2soY2hlY2tzdW1CaXRzKTtcblx0ICAgIC8vIFNoaWZ0IHRoZSBjaGVja3N1bSBpbnRvIHRoZSB3b3JkIGluZGljZXNcblx0ICAgIGluZGljZXNbaW5kaWNlcy5sZW5ndGggLSAxXSA8PD0gY2hlY2tzdW1CaXRzO1xuXHQgICAgaW5kaWNlc1tpbmRpY2VzLmxlbmd0aCAtIDFdIHw9IChjaGVja3N1bSA+PiAoOCAtIGNoZWNrc3VtQml0cykpO1xuXHQgICAgcmV0dXJuIHdvcmRsaXN0LmpvaW4oaW5kaWNlcy5tYXAoZnVuY3Rpb24gKGluZGV4KSB7IHJldHVybiB3b3JkbGlzdC5nZXRXb3JkKGluZGV4KTsgfSkpO1xuXHR9XG5cdGV4cG9ydHMuZW50cm9weVRvTW5lbW9uaWMgPSBlbnRyb3B5VG9NbmVtb25pYztcblx0ZnVuY3Rpb24gaXNWYWxpZE1uZW1vbmljKG1uZW1vbmljLCB3b3JkbGlzdCkge1xuXHQgICAgdHJ5IHtcblx0ICAgICAgICBtbmVtb25pY1RvRW50cm9weShtbmVtb25pYywgd29yZGxpc3QpO1xuXHQgICAgICAgIHJldHVybiB0cnVlO1xuXHQgICAgfVxuXHQgICAgY2F0Y2ggKGVycm9yKSB7IH1cblx0ICAgIHJldHVybiBmYWxzZTtcblx0fVxuXHRleHBvcnRzLmlzVmFsaWRNbmVtb25pYyA9IGlzVmFsaWRNbmVtb25pYztcblx0ZnVuY3Rpb24gZ2V0QWNjb3VudFBhdGgoaW5kZXgpIHtcblx0ICAgIGlmICh0eXBlb2YgKGluZGV4KSAhPT0gXCJudW1iZXJcIiB8fCBpbmRleCA8IDAgfHwgaW5kZXggPj0gSGFyZGVuZWRCaXQgfHwgaW5kZXggJSAxKSB7XG5cdCAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcImludmFsaWQgYWNjb3VudCBpbmRleFwiLCBcImluZGV4XCIsIGluZGV4KTtcblx0ICAgIH1cblx0ICAgIHJldHVybiBcIm0vNDQnLzYwJy9cIiArIGluZGV4ICsgXCInLzAvMFwiO1xuXHR9XG5cdGV4cG9ydHMuZ2V0QWNjb3VudFBhdGggPSBnZXRBY2NvdW50UGF0aDtcblxuXHR9KTtcblxuXHR2YXIgaW5kZXgkayA9IC8qQF9fUFVSRV9fKi9nZXREZWZhdWx0RXhwb3J0RnJvbUNqcyhsaWIkayk7XG5cblx0dmFyIF92ZXJzaW9uJHkgPSBjcmVhdGVDb21tb25qc01vZHVsZShmdW5jdGlvbiAobW9kdWxlLCBleHBvcnRzKSB7XG5cdFwidXNlIHN0cmljdFwiO1xuXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5cdGV4cG9ydHMudmVyc2lvbiA9IHZvaWQgMDtcblx0ZXhwb3J0cy52ZXJzaW9uID0gXCJyYW5kb20vNS41LjBcIjtcblxuXHR9KTtcblxuXHR2YXIgX3ZlcnNpb24keiA9IC8qQF9fUFVSRV9fKi9nZXREZWZhdWx0RXhwb3J0RnJvbUNqcyhfdmVyc2lvbiR5KTtcblxuXHR2YXIgYnJvd3NlclJhbmRvbSA9IGNyZWF0ZUNvbW1vbmpzTW9kdWxlKGZ1bmN0aW9uIChtb2R1bGUsIGV4cG9ydHMpIHtcblx0XCJ1c2Ugc3RyaWN0XCI7XG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcblx0ZXhwb3J0cy5yYW5kb21CeXRlcyA9IHZvaWQgMDtcblxuXG5cblx0dmFyIGxvZ2dlciA9IG5ldyBsaWIuTG9nZ2VyKF92ZXJzaW9uJHkudmVyc2lvbik7XG5cdC8vIERlYnVnZ2luZyBsaW5lIGZvciB0ZXN0aW5nIGJyb3dzZXIgbGliIGluIG5vZGVcblx0Ly9jb25zdCB3aW5kb3cgPSB7IGNyeXB0bzogeyBnZXRSYW5kb21WYWx1ZXM6ICgpID0+IHsgfSB9IH07XG5cdHZhciBhbnlHbG9iYWwgPSBudWxsO1xuXHR0cnkge1xuXHQgICAgYW55R2xvYmFsID0gd2luZG93O1xuXHQgICAgaWYgKGFueUdsb2JhbCA9PSBudWxsKSB7XG5cdCAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwidHJ5IG5leHRcIik7XG5cdCAgICB9XG5cdH1cblx0Y2F0Y2ggKGVycm9yKSB7XG5cdCAgICB0cnkge1xuXHQgICAgICAgIGFueUdsb2JhbCA9IGNvbW1vbmpzR2xvYmFsO1xuXHQgICAgICAgIGlmIChhbnlHbG9iYWwgPT0gbnVsbCkge1xuXHQgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJ0cnkgbmV4dFwiKTtcblx0ICAgICAgICB9XG5cdCAgICB9XG5cdCAgICBjYXRjaCAoZXJyb3IpIHtcblx0ICAgICAgICBhbnlHbG9iYWwgPSB7fTtcblx0ICAgIH1cblx0fVxuXHR2YXIgY3J5cHRvID0gYW55R2xvYmFsLmNyeXB0byB8fCBhbnlHbG9iYWwubXNDcnlwdG87XG5cdGlmICghY3J5cHRvIHx8ICFjcnlwdG8uZ2V0UmFuZG9tVmFsdWVzKSB7XG5cdCAgICBsb2dnZXIud2FybihcIldBUk5JTkc6IE1pc3Npbmcgc3Ryb25nIHJhbmRvbSBudW1iZXIgc291cmNlXCIpO1xuXHQgICAgY3J5cHRvID0ge1xuXHQgICAgICAgIGdldFJhbmRvbVZhbHVlczogZnVuY3Rpb24gKGJ1ZmZlcikge1xuXHQgICAgICAgICAgICByZXR1cm4gbG9nZ2VyLnRocm93RXJyb3IoXCJubyBzZWN1cmUgcmFuZG9tIHNvdXJjZSBhdmFpYWxibGVcIiwgbGliLkxvZ2dlci5lcnJvcnMuVU5TVVBQT1JURURfT1BFUkFUSU9OLCB7XG5cdCAgICAgICAgICAgICAgICBvcGVyYXRpb246IFwiY3J5cHRvLmdldFJhbmRvbVZhbHVlc1wiXG5cdCAgICAgICAgICAgIH0pO1xuXHQgICAgICAgIH1cblx0ICAgIH07XG5cdH1cblx0ZnVuY3Rpb24gcmFuZG9tQnl0ZXMobGVuZ3RoKSB7XG5cdCAgICBpZiAobGVuZ3RoIDw9IDAgfHwgbGVuZ3RoID4gMTAyNCB8fCAobGVuZ3RoICUgMSkgfHwgbGVuZ3RoICE9IGxlbmd0aCkge1xuXHQgICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJpbnZhbGlkIGxlbmd0aFwiLCBcImxlbmd0aFwiLCBsZW5ndGgpO1xuXHQgICAgfVxuXHQgICAgdmFyIHJlc3VsdCA9IG5ldyBVaW50OEFycmF5KGxlbmd0aCk7XG5cdCAgICBjcnlwdG8uZ2V0UmFuZG9tVmFsdWVzKHJlc3VsdCk7XG5cdCAgICByZXR1cm4gKDAsIGxpYiQxLmFycmF5aWZ5KShyZXN1bHQpO1xuXHR9XG5cdGV4cG9ydHMucmFuZG9tQnl0ZXMgPSByYW5kb21CeXRlcztcblx0O1xuXG5cdH0pO1xuXG5cdHZhciBicm93c2VyUmFuZG9tJDEgPSAvKkBfX1BVUkVfXyovZ2V0RGVmYXVsdEV4cG9ydEZyb21DanMoYnJvd3NlclJhbmRvbSk7XG5cblx0dmFyIHNodWZmbGUgPSBjcmVhdGVDb21tb25qc01vZHVsZShmdW5jdGlvbiAobW9kdWxlLCBleHBvcnRzKSB7XG5cdFwidXNlIHN0cmljdFwiO1xuXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5cdGV4cG9ydHMuc2h1ZmZsZWQgPSB2b2lkIDA7XG5cdGZ1bmN0aW9uIHNodWZmbGVkKGFycmF5KSB7XG5cdCAgICBhcnJheSA9IGFycmF5LnNsaWNlKCk7XG5cdCAgICBmb3IgKHZhciBpID0gYXJyYXkubGVuZ3RoIC0gMTsgaSA+IDA7IGktLSkge1xuXHQgICAgICAgIHZhciBqID0gTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogKGkgKyAxKSk7XG5cdCAgICAgICAgdmFyIHRtcCA9IGFycmF5W2ldO1xuXHQgICAgICAgIGFycmF5W2ldID0gYXJyYXlbal07XG5cdCAgICAgICAgYXJyYXlbal0gPSB0bXA7XG5cdCAgICB9XG5cdCAgICByZXR1cm4gYXJyYXk7XG5cdH1cblx0ZXhwb3J0cy5zaHVmZmxlZCA9IHNodWZmbGVkO1xuXG5cdH0pO1xuXG5cdHZhciBzaHVmZmxlJDEgPSAvKkBfX1BVUkVfXyovZ2V0RGVmYXVsdEV4cG9ydEZyb21DanMoc2h1ZmZsZSk7XG5cblx0dmFyIGxpYiRsID0gY3JlYXRlQ29tbW9uanNNb2R1bGUoZnVuY3Rpb24gKG1vZHVsZSwgZXhwb3J0cykge1xuXHRcInVzZSBzdHJpY3RcIjtcblx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuXHRleHBvcnRzLnNodWZmbGVkID0gZXhwb3J0cy5yYW5kb21CeXRlcyA9IHZvaWQgMDtcblxuXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJyYW5kb21CeXRlc1wiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gYnJvd3NlclJhbmRvbS5yYW5kb21CeXRlczsgfSB9KTtcblxuXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJzaHVmZmxlZFwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gc2h1ZmZsZS5zaHVmZmxlZDsgfSB9KTtcblxuXHR9KTtcblxuXHR2YXIgaW5kZXgkbCA9IC8qQF9fUFVSRV9fKi9nZXREZWZhdWx0RXhwb3J0RnJvbUNqcyhsaWIkbCk7XG5cblx0dmFyIGFlc0pzID0gY3JlYXRlQ29tbW9uanNNb2R1bGUoZnVuY3Rpb24gKG1vZHVsZSwgZXhwb3J0cykge1xuXHRcInVzZSBzdHJpY3RcIjtcblxuXHQoZnVuY3Rpb24ocm9vdCkge1xuXG5cdCAgICBmdW5jdGlvbiBjaGVja0ludCh2YWx1ZSkge1xuXHQgICAgICAgIHJldHVybiAocGFyc2VJbnQodmFsdWUpID09PSB2YWx1ZSk7XG5cdCAgICB9XG5cblx0ICAgIGZ1bmN0aW9uIGNoZWNrSW50cyhhcnJheWlzaCkge1xuXHQgICAgICAgIGlmICghY2hlY2tJbnQoYXJyYXlpc2gubGVuZ3RoKSkgeyByZXR1cm4gZmFsc2U7IH1cblxuXHQgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJyYXlpc2gubGVuZ3RoOyBpKyspIHtcblx0ICAgICAgICAgICAgaWYgKCFjaGVja0ludChhcnJheWlzaFtpXSkgfHwgYXJyYXlpc2hbaV0gPCAwIHx8IGFycmF5aXNoW2ldID4gMjU1KSB7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9XG5cblx0ICAgICAgICByZXR1cm4gdHJ1ZTtcblx0ICAgIH1cblxuXHQgICAgZnVuY3Rpb24gY29lcmNlQXJyYXkoYXJnLCBjb3B5KSB7XG5cblx0ICAgICAgICAvLyBBcnJheUJ1ZmZlciB2aWV3XG5cdCAgICAgICAgaWYgKGFyZy5idWZmZXIgJiYgQXJyYXlCdWZmZXIuaXNWaWV3KGFyZykgJiYgYXJnLm5hbWUgPT09ICdVaW50OEFycmF5Jykge1xuXG5cdCAgICAgICAgICAgIGlmIChjb3B5KSB7XG5cdCAgICAgICAgICAgICAgICBpZiAoYXJnLnNsaWNlKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgYXJnID0gYXJnLnNsaWNlKCk7XG5cdCAgICAgICAgICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgICAgICAgICAgIGFyZyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZyk7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICByZXR1cm4gYXJnO1xuXHQgICAgICAgIH1cblxuXHQgICAgICAgIC8vIEl0J3MgYW4gYXJyYXk7IGNoZWNrIGl0IGlzIGEgdmFsaWQgcmVwcmVzZW50YXRpb24gb2YgYSBieXRlXG5cdCAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoYXJnKSkge1xuXHQgICAgICAgICAgICBpZiAoIWNoZWNrSW50cyhhcmcpKSB7XG5cdCAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0FycmF5IGNvbnRhaW5zIGludmFsaWQgdmFsdWU6ICcgKyBhcmcpO1xuXHQgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KGFyZyk7XG5cdCAgICAgICAgfVxuXG5cdCAgICAgICAgLy8gU29tZXRoaW5nIGVsc2UsIGJ1dCBiZWhhdmVzIGxpa2UgYW4gYXJyYXkgKG1heWJlIGEgQnVmZmVyPyBBcmd1bWVudHM/KVxuXHQgICAgICAgIGlmIChjaGVja0ludChhcmcubGVuZ3RoKSAmJiBjaGVja0ludHMoYXJnKSkge1xuXHQgICAgICAgICAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoYXJnKTtcblx0ICAgICAgICB9XG5cblx0ICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3Vuc3VwcG9ydGVkIGFycmF5LWxpa2Ugb2JqZWN0Jyk7XG5cdCAgICB9XG5cblx0ICAgIGZ1bmN0aW9uIGNyZWF0ZUFycmF5KGxlbmd0aCkge1xuXHQgICAgICAgIHJldHVybiBuZXcgVWludDhBcnJheShsZW5ndGgpO1xuXHQgICAgfVxuXG5cdCAgICBmdW5jdGlvbiBjb3B5QXJyYXkoc291cmNlQXJyYXksIHRhcmdldEFycmF5LCB0YXJnZXRTdGFydCwgc291cmNlU3RhcnQsIHNvdXJjZUVuZCkge1xuXHQgICAgICAgIGlmIChzb3VyY2VTdGFydCAhPSBudWxsIHx8IHNvdXJjZUVuZCAhPSBudWxsKSB7XG5cdCAgICAgICAgICAgIGlmIChzb3VyY2VBcnJheS5zbGljZSkge1xuXHQgICAgICAgICAgICAgICAgc291cmNlQXJyYXkgPSBzb3VyY2VBcnJheS5zbGljZShzb3VyY2VTdGFydCwgc291cmNlRW5kKTtcblx0ICAgICAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgICAgICAgIHNvdXJjZUFycmF5ID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoc291cmNlQXJyYXksIHNvdXJjZVN0YXJ0LCBzb3VyY2VFbmQpO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHRhcmdldEFycmF5LnNldChzb3VyY2VBcnJheSwgdGFyZ2V0U3RhcnQpO1xuXHQgICAgfVxuXG5cblxuXHQgICAgdmFyIGNvbnZlcnRVdGY4ID0gKGZ1bmN0aW9uKCkge1xuXHQgICAgICAgIGZ1bmN0aW9uIHRvQnl0ZXModGV4dCkge1xuXHQgICAgICAgICAgICB2YXIgcmVzdWx0ID0gW10sIGkgPSAwO1xuXHQgICAgICAgICAgICB0ZXh0ID0gZW5jb2RlVVJJKHRleHQpO1xuXHQgICAgICAgICAgICB3aGlsZSAoaSA8IHRleHQubGVuZ3RoKSB7XG5cdCAgICAgICAgICAgICAgICB2YXIgYyA9IHRleHQuY2hhckNvZGVBdChpKyspO1xuXG5cdCAgICAgICAgICAgICAgICAvLyBpZiBpdCBpcyBhICUgc2lnbiwgZW5jb2RlIHRoZSBmb2xsb3dpbmcgMiBieXRlcyBhcyBhIGhleCB2YWx1ZVxuXHQgICAgICAgICAgICAgICAgaWYgKGMgPT09IDM3KSB7XG5cdCAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2gocGFyc2VJbnQodGV4dC5zdWJzdHIoaSwgMiksIDE2KSk7XG5cdCAgICAgICAgICAgICAgICAgICAgaSArPSAyO1xuXG5cdCAgICAgICAgICAgICAgICAvLyBvdGhlcndpc2UsIGp1c3QgdGhlIGFjdHVhbCBieXRlXG5cdCAgICAgICAgICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKGMpO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgcmV0dXJuIGNvZXJjZUFycmF5KHJlc3VsdCk7XG5cdCAgICAgICAgfVxuXG5cdCAgICAgICAgZnVuY3Rpb24gZnJvbUJ5dGVzKGJ5dGVzKSB7XG5cdCAgICAgICAgICAgIHZhciByZXN1bHQgPSBbXSwgaSA9IDA7XG5cblx0ICAgICAgICAgICAgd2hpbGUgKGkgPCBieXRlcy5sZW5ndGgpIHtcblx0ICAgICAgICAgICAgICAgIHZhciBjID0gYnl0ZXNbaV07XG5cblx0ICAgICAgICAgICAgICAgIGlmIChjIDwgMTI4KSB7XG5cdCAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goU3RyaW5nLmZyb21DaGFyQ29kZShjKSk7XG5cdCAgICAgICAgICAgICAgICAgICAgaSsrO1xuXHQgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChjID4gMTkxICYmIGMgPCAyMjQpIHtcblx0ICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaChTdHJpbmcuZnJvbUNoYXJDb2RlKCgoYyAmIDB4MWYpIDw8IDYpIHwgKGJ5dGVzW2kgKyAxXSAmIDB4M2YpKSk7XG5cdCAgICAgICAgICAgICAgICAgICAgaSArPSAyO1xuXHQgICAgICAgICAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaChTdHJpbmcuZnJvbUNoYXJDb2RlKCgoYyAmIDB4MGYpIDw8IDEyKSB8ICgoYnl0ZXNbaSArIDFdICYgMHgzZikgPDwgNikgfCAoYnl0ZXNbaSArIDJdICYgMHgzZikpKTtcblx0ICAgICAgICAgICAgICAgICAgICBpICs9IDM7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICByZXR1cm4gcmVzdWx0LmpvaW4oJycpO1xuXHQgICAgICAgIH1cblxuXHQgICAgICAgIHJldHVybiB7XG5cdCAgICAgICAgICAgIHRvQnl0ZXM6IHRvQnl0ZXMsXG5cdCAgICAgICAgICAgIGZyb21CeXRlczogZnJvbUJ5dGVzLFxuXHQgICAgICAgIH1cblx0ICAgIH0pKCk7XG5cblx0ICAgIHZhciBjb252ZXJ0SGV4ID0gKGZ1bmN0aW9uKCkge1xuXHQgICAgICAgIGZ1bmN0aW9uIHRvQnl0ZXModGV4dCkge1xuXHQgICAgICAgICAgICB2YXIgcmVzdWx0ID0gW107XG5cdCAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGV4dC5sZW5ndGg7IGkgKz0gMikge1xuXHQgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2gocGFyc2VJbnQodGV4dC5zdWJzdHIoaSwgMiksIDE2KSk7XG5cdCAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuXHQgICAgICAgIH1cblxuXHQgICAgICAgIC8vIGh0dHA6Ly9peHRpLm5ldC9kZXZlbG9wbWVudC9qYXZhc2NyaXB0LzIwMTEvMTEvMTEvYmFzZTY0LWVuY29kZWRlY29kZS1vZi11dGY4LWluLWJyb3dzZXItd2l0aC1qcy5odG1sXG5cdCAgICAgICAgdmFyIEhleCA9ICcwMTIzNDU2Nzg5YWJjZGVmJztcblxuXHQgICAgICAgIGZ1bmN0aW9uIGZyb21CeXRlcyhieXRlcykge1xuXHQgICAgICAgICAgICAgICAgdmFyIHJlc3VsdCA9IFtdO1xuXHQgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBieXRlcy5sZW5ndGg7IGkrKykge1xuXHQgICAgICAgICAgICAgICAgICAgIHZhciB2ID0gYnl0ZXNbaV07XG5cdCAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goSGV4Wyh2ICYgMHhmMCkgPj4gNF0gKyBIZXhbdiAmIDB4MGZdKTtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQuam9pbignJyk7XG5cdCAgICAgICAgfVxuXG5cdCAgICAgICAgcmV0dXJuIHtcblx0ICAgICAgICAgICAgdG9CeXRlczogdG9CeXRlcyxcblx0ICAgICAgICAgICAgZnJvbUJ5dGVzOiBmcm9tQnl0ZXMsXG5cdCAgICAgICAgfVxuXHQgICAgfSkoKTtcblxuXG5cdCAgICAvLyBOdW1iZXIgb2Ygcm91bmRzIGJ5IGtleXNpemVcblx0ICAgIHZhciBudW1iZXJPZlJvdW5kcyA9IHsxNjogMTAsIDI0OiAxMiwgMzI6IDE0fTtcblxuXHQgICAgLy8gUm91bmQgY29uc3RhbnQgd29yZHNcblx0ICAgIHZhciByY29uID0gWzB4MDEsIDB4MDIsIDB4MDQsIDB4MDgsIDB4MTAsIDB4MjAsIDB4NDAsIDB4ODAsIDB4MWIsIDB4MzYsIDB4NmMsIDB4ZDgsIDB4YWIsIDB4NGQsIDB4OWEsIDB4MmYsIDB4NWUsIDB4YmMsIDB4NjMsIDB4YzYsIDB4OTcsIDB4MzUsIDB4NmEsIDB4ZDQsIDB4YjMsIDB4N2QsIDB4ZmEsIDB4ZWYsIDB4YzUsIDB4OTFdO1xuXG5cdCAgICAvLyBTLWJveCBhbmQgSW52ZXJzZSBTLWJveCAoUyBpcyBmb3IgU3Vic3RpdHV0aW9uKVxuXHQgICAgdmFyIFMgPSBbMHg2MywgMHg3YywgMHg3NywgMHg3YiwgMHhmMiwgMHg2YiwgMHg2ZiwgMHhjNSwgMHgzMCwgMHgwMSwgMHg2NywgMHgyYiwgMHhmZSwgMHhkNywgMHhhYiwgMHg3NiwgMHhjYSwgMHg4MiwgMHhjOSwgMHg3ZCwgMHhmYSwgMHg1OSwgMHg0NywgMHhmMCwgMHhhZCwgMHhkNCwgMHhhMiwgMHhhZiwgMHg5YywgMHhhNCwgMHg3MiwgMHhjMCwgMHhiNywgMHhmZCwgMHg5MywgMHgyNiwgMHgzNiwgMHgzZiwgMHhmNywgMHhjYywgMHgzNCwgMHhhNSwgMHhlNSwgMHhmMSwgMHg3MSwgMHhkOCwgMHgzMSwgMHgxNSwgMHgwNCwgMHhjNywgMHgyMywgMHhjMywgMHgxOCwgMHg5NiwgMHgwNSwgMHg5YSwgMHgwNywgMHgxMiwgMHg4MCwgMHhlMiwgMHhlYiwgMHgyNywgMHhiMiwgMHg3NSwgMHgwOSwgMHg4MywgMHgyYywgMHgxYSwgMHgxYiwgMHg2ZSwgMHg1YSwgMHhhMCwgMHg1MiwgMHgzYiwgMHhkNiwgMHhiMywgMHgyOSwgMHhlMywgMHgyZiwgMHg4NCwgMHg1MywgMHhkMSwgMHgwMCwgMHhlZCwgMHgyMCwgMHhmYywgMHhiMSwgMHg1YiwgMHg2YSwgMHhjYiwgMHhiZSwgMHgzOSwgMHg0YSwgMHg0YywgMHg1OCwgMHhjZiwgMHhkMCwgMHhlZiwgMHhhYSwgMHhmYiwgMHg0MywgMHg0ZCwgMHgzMywgMHg4NSwgMHg0NSwgMHhmOSwgMHgwMiwgMHg3ZiwgMHg1MCwgMHgzYywgMHg5ZiwgMHhhOCwgMHg1MSwgMHhhMywgMHg0MCwgMHg4ZiwgMHg5MiwgMHg5ZCwgMHgzOCwgMHhmNSwgMHhiYywgMHhiNiwgMHhkYSwgMHgyMSwgMHgxMCwgMHhmZiwgMHhmMywgMHhkMiwgMHhjZCwgMHgwYywgMHgxMywgMHhlYywgMHg1ZiwgMHg5NywgMHg0NCwgMHgxNywgMHhjNCwgMHhhNywgMHg3ZSwgMHgzZCwgMHg2NCwgMHg1ZCwgMHgxOSwgMHg3MywgMHg2MCwgMHg4MSwgMHg0ZiwgMHhkYywgMHgyMiwgMHgyYSwgMHg5MCwgMHg4OCwgMHg0NiwgMHhlZSwgMHhiOCwgMHgxNCwgMHhkZSwgMHg1ZSwgMHgwYiwgMHhkYiwgMHhlMCwgMHgzMiwgMHgzYSwgMHgwYSwgMHg0OSwgMHgwNiwgMHgyNCwgMHg1YywgMHhjMiwgMHhkMywgMHhhYywgMHg2MiwgMHg5MSwgMHg5NSwgMHhlNCwgMHg3OSwgMHhlNywgMHhjOCwgMHgzNywgMHg2ZCwgMHg4ZCwgMHhkNSwgMHg0ZSwgMHhhOSwgMHg2YywgMHg1NiwgMHhmNCwgMHhlYSwgMHg2NSwgMHg3YSwgMHhhZSwgMHgwOCwgMHhiYSwgMHg3OCwgMHgyNSwgMHgyZSwgMHgxYywgMHhhNiwgMHhiNCwgMHhjNiwgMHhlOCwgMHhkZCwgMHg3NCwgMHgxZiwgMHg0YiwgMHhiZCwgMHg4YiwgMHg4YSwgMHg3MCwgMHgzZSwgMHhiNSwgMHg2NiwgMHg0OCwgMHgwMywgMHhmNiwgMHgwZSwgMHg2MSwgMHgzNSwgMHg1NywgMHhiOSwgMHg4NiwgMHhjMSwgMHgxZCwgMHg5ZSwgMHhlMSwgMHhmOCwgMHg5OCwgMHgxMSwgMHg2OSwgMHhkOSwgMHg4ZSwgMHg5NCwgMHg5YiwgMHgxZSwgMHg4NywgMHhlOSwgMHhjZSwgMHg1NSwgMHgyOCwgMHhkZiwgMHg4YywgMHhhMSwgMHg4OSwgMHgwZCwgMHhiZiwgMHhlNiwgMHg0MiwgMHg2OCwgMHg0MSwgMHg5OSwgMHgyZCwgMHgwZiwgMHhiMCwgMHg1NCwgMHhiYiwgMHgxNl07XG5cdCAgICB2YXIgU2kgPVsweDUyLCAweDA5LCAweDZhLCAweGQ1LCAweDMwLCAweDM2LCAweGE1LCAweDM4LCAweGJmLCAweDQwLCAweGEzLCAweDllLCAweDgxLCAweGYzLCAweGQ3LCAweGZiLCAweDdjLCAweGUzLCAweDM5LCAweDgyLCAweDliLCAweDJmLCAweGZmLCAweDg3LCAweDM0LCAweDhlLCAweDQzLCAweDQ0LCAweGM0LCAweGRlLCAweGU5LCAweGNiLCAweDU0LCAweDdiLCAweDk0LCAweDMyLCAweGE2LCAweGMyLCAweDIzLCAweDNkLCAweGVlLCAweDRjLCAweDk1LCAweDBiLCAweDQyLCAweGZhLCAweGMzLCAweDRlLCAweDA4LCAweDJlLCAweGExLCAweDY2LCAweDI4LCAweGQ5LCAweDI0LCAweGIyLCAweDc2LCAweDViLCAweGEyLCAweDQ5LCAweDZkLCAweDhiLCAweGQxLCAweDI1LCAweDcyLCAweGY4LCAweGY2LCAweDY0LCAweDg2LCAweDY4LCAweDk4LCAweDE2LCAweGQ0LCAweGE0LCAweDVjLCAweGNjLCAweDVkLCAweDY1LCAweGI2LCAweDkyLCAweDZjLCAweDcwLCAweDQ4LCAweDUwLCAweGZkLCAweGVkLCAweGI5LCAweGRhLCAweDVlLCAweDE1LCAweDQ2LCAweDU3LCAweGE3LCAweDhkLCAweDlkLCAweDg0LCAweDkwLCAweGQ4LCAweGFiLCAweDAwLCAweDhjLCAweGJjLCAweGQzLCAweDBhLCAweGY3LCAweGU0LCAweDU4LCAweDA1LCAweGI4LCAweGIzLCAweDQ1LCAweDA2LCAweGQwLCAweDJjLCAweDFlLCAweDhmLCAweGNhLCAweDNmLCAweDBmLCAweDAyLCAweGMxLCAweGFmLCAweGJkLCAweDAzLCAweDAxLCAweDEzLCAweDhhLCAweDZiLCAweDNhLCAweDkxLCAweDExLCAweDQxLCAweDRmLCAweDY3LCAweGRjLCAweGVhLCAweDk3LCAweGYyLCAweGNmLCAweGNlLCAweGYwLCAweGI0LCAweGU2LCAweDczLCAweDk2LCAweGFjLCAweDc0LCAweDIyLCAweGU3LCAweGFkLCAweDM1LCAweDg1LCAweGUyLCAweGY5LCAweDM3LCAweGU4LCAweDFjLCAweDc1LCAweGRmLCAweDZlLCAweDQ3LCAweGYxLCAweDFhLCAweDcxLCAweDFkLCAweDI5LCAweGM1LCAweDg5LCAweDZmLCAweGI3LCAweDYyLCAweDBlLCAweGFhLCAweDE4LCAweGJlLCAweDFiLCAweGZjLCAweDU2LCAweDNlLCAweDRiLCAweGM2LCAweGQyLCAweDc5LCAweDIwLCAweDlhLCAweGRiLCAweGMwLCAweGZlLCAweDc4LCAweGNkLCAweDVhLCAweGY0LCAweDFmLCAweGRkLCAweGE4LCAweDMzLCAweDg4LCAweDA3LCAweGM3LCAweDMxLCAweGIxLCAweDEyLCAweDEwLCAweDU5LCAweDI3LCAweDgwLCAweGVjLCAweDVmLCAweDYwLCAweDUxLCAweDdmLCAweGE5LCAweDE5LCAweGI1LCAweDRhLCAweDBkLCAweDJkLCAweGU1LCAweDdhLCAweDlmLCAweDkzLCAweGM5LCAweDljLCAweGVmLCAweGEwLCAweGUwLCAweDNiLCAweDRkLCAweGFlLCAweDJhLCAweGY1LCAweGIwLCAweGM4LCAweGViLCAweGJiLCAweDNjLCAweDgzLCAweDUzLCAweDk5LCAweDYxLCAweDE3LCAweDJiLCAweDA0LCAweDdlLCAweGJhLCAweDc3LCAweGQ2LCAweDI2LCAweGUxLCAweDY5LCAweDE0LCAweDYzLCAweDU1LCAweDIxLCAweDBjLCAweDdkXTtcblxuXHQgICAgLy8gVHJhbnNmb3JtYXRpb25zIGZvciBlbmNyeXB0aW9uXG5cdCAgICB2YXIgVDEgPSBbMHhjNjYzNjNhNSwgMHhmODdjN2M4NCwgMHhlZTc3Nzc5OSwgMHhmNjdiN2I4ZCwgMHhmZmYyZjIwZCwgMHhkNjZiNmJiZCwgMHhkZTZmNmZiMSwgMHg5MWM1YzU1NCwgMHg2MDMwMzA1MCwgMHgwMjAxMDEwMywgMHhjZTY3NjdhOSwgMHg1NjJiMmI3ZCwgMHhlN2ZlZmUxOSwgMHhiNWQ3ZDc2MiwgMHg0ZGFiYWJlNiwgMHhlYzc2NzY5YSwgMHg4ZmNhY2E0NSwgMHgxZjgyODI5ZCwgMHg4OWM5Yzk0MCwgMHhmYTdkN2Q4NywgMHhlZmZhZmExNSwgMHhiMjU5NTllYiwgMHg4ZTQ3NDdjOSwgMHhmYmYwZjAwYiwgMHg0MWFkYWRlYywgMHhiM2Q0ZDQ2NywgMHg1ZmEyYTJmZCwgMHg0NWFmYWZlYSwgMHgyMzljOWNiZiwgMHg1M2E0YTRmNywgMHhlNDcyNzI5NiwgMHg5YmMwYzA1YiwgMHg3NWI3YjdjMiwgMHhlMWZkZmQxYywgMHgzZDkzOTNhZSwgMHg0YzI2MjY2YSwgMHg2YzM2MzY1YSwgMHg3ZTNmM2Y0MSwgMHhmNWY3ZjcwMiwgMHg4M2NjY2M0ZiwgMHg2ODM0MzQ1YywgMHg1MWE1YTVmNCwgMHhkMWU1ZTUzNCwgMHhmOWYxZjEwOCwgMHhlMjcxNzE5MywgMHhhYmQ4ZDg3MywgMHg2MjMxMzE1MywgMHgyYTE1MTUzZiwgMHgwODA0MDQwYywgMHg5NWM3Yzc1MiwgMHg0NjIzMjM2NSwgMHg5ZGMzYzM1ZSwgMHgzMDE4MTgyOCwgMHgzNzk2OTZhMSwgMHgwYTA1MDUwZiwgMHgyZjlhOWFiNSwgMHgwZTA3MDcwOSwgMHgyNDEyMTIzNiwgMHgxYjgwODA5YiwgMHhkZmUyZTIzZCwgMHhjZGViZWIyNiwgMHg0ZTI3Mjc2OSwgMHg3ZmIyYjJjZCwgMHhlYTc1NzU5ZiwgMHgxMjA5MDkxYiwgMHgxZDgzODM5ZSwgMHg1ODJjMmM3NCwgMHgzNDFhMWEyZSwgMHgzNjFiMWIyZCwgMHhkYzZlNmViMiwgMHhiNDVhNWFlZSwgMHg1YmEwYTBmYiwgMHhhNDUyNTJmNiwgMHg3NjNiM2I0ZCwgMHhiN2Q2ZDY2MSwgMHg3ZGIzYjNjZSwgMHg1MjI5Mjk3YiwgMHhkZGUzZTMzZSwgMHg1ZTJmMmY3MSwgMHgxMzg0ODQ5NywgMHhhNjUzNTNmNSwgMHhiOWQxZDE2OCwgMHgwMDAwMDAwMCwgMHhjMWVkZWQyYywgMHg0MDIwMjA2MCwgMHhlM2ZjZmMxZiwgMHg3OWIxYjFjOCwgMHhiNjViNWJlZCwgMHhkNDZhNmFiZSwgMHg4ZGNiY2I0NiwgMHg2N2JlYmVkOSwgMHg3MjM5Mzk0YiwgMHg5NDRhNGFkZSwgMHg5ODRjNGNkNCwgMHhiMDU4NThlOCwgMHg4NWNmY2Y0YSwgMHhiYmQwZDA2YiwgMHhjNWVmZWYyYSwgMHg0ZmFhYWFlNSwgMHhlZGZiZmIxNiwgMHg4NjQzNDNjNSwgMHg5YTRkNGRkNywgMHg2NjMzMzM1NSwgMHgxMTg1ODU5NCwgMHg4YTQ1NDVjZiwgMHhlOWY5ZjkxMCwgMHgwNDAyMDIwNiwgMHhmZTdmN2Y4MSwgMHhhMDUwNTBmMCwgMHg3ODNjM2M0NCwgMHgyNTlmOWZiYSwgMHg0YmE4YThlMywgMHhhMjUxNTFmMywgMHg1ZGEzYTNmZSwgMHg4MDQwNDBjMCwgMHgwNThmOGY4YSwgMHgzZjkyOTJhZCwgMHgyMTlkOWRiYywgMHg3MDM4Mzg0OCwgMHhmMWY1ZjUwNCwgMHg2M2JjYmNkZiwgMHg3N2I2YjZjMSwgMHhhZmRhZGE3NSwgMHg0MjIxMjE2MywgMHgyMDEwMTAzMCwgMHhlNWZmZmYxYSwgMHhmZGYzZjMwZSwgMHhiZmQyZDI2ZCwgMHg4MWNkY2Q0YywgMHgxODBjMGMxNCwgMHgyNjEzMTMzNSwgMHhjM2VjZWMyZiwgMHhiZTVmNWZlMSwgMHgzNTk3OTdhMiwgMHg4ODQ0NDRjYywgMHgyZTE3MTczOSwgMHg5M2M0YzQ1NywgMHg1NWE3YTdmMiwgMHhmYzdlN2U4MiwgMHg3YTNkM2Q0NywgMHhjODY0NjRhYywgMHhiYTVkNWRlNywgMHgzMjE5MTkyYiwgMHhlNjczNzM5NSwgMHhjMDYwNjBhMCwgMHgxOTgxODE5OCwgMHg5ZTRmNGZkMSwgMHhhM2RjZGM3ZiwgMHg0NDIyMjI2NiwgMHg1NDJhMmE3ZSwgMHgzYjkwOTBhYiwgMHgwYjg4ODg4MywgMHg4YzQ2NDZjYSwgMHhjN2VlZWUyOSwgMHg2YmI4YjhkMywgMHgyODE0MTQzYywgMHhhN2RlZGU3OSwgMHhiYzVlNWVlMiwgMHgxNjBiMGIxZCwgMHhhZGRiZGI3NiwgMHhkYmUwZTAzYiwgMHg2NDMyMzI1NiwgMHg3NDNhM2E0ZSwgMHgxNDBhMGExZSwgMHg5MjQ5NDlkYiwgMHgwYzA2MDYwYSwgMHg0ODI0MjQ2YywgMHhiODVjNWNlNCwgMHg5ZmMyYzI1ZCwgMHhiZGQzZDM2ZSwgMHg0M2FjYWNlZiwgMHhjNDYyNjJhNiwgMHgzOTkxOTFhOCwgMHgzMTk1OTVhNCwgMHhkM2U0ZTQzNywgMHhmMjc5Nzk4YiwgMHhkNWU3ZTczMiwgMHg4YmM4Yzg0MywgMHg2ZTM3Mzc1OSwgMHhkYTZkNmRiNywgMHgwMThkOGQ4YywgMHhiMWQ1ZDU2NCwgMHg5YzRlNGVkMiwgMHg0OWE5YTllMCwgMHhkODZjNmNiNCwgMHhhYzU2NTZmYSwgMHhmM2Y0ZjQwNywgMHhjZmVhZWEyNSwgMHhjYTY1NjVhZiwgMHhmNDdhN2E4ZSwgMHg0N2FlYWVlOSwgMHgxMDA4MDgxOCwgMHg2ZmJhYmFkNSwgMHhmMDc4Nzg4OCwgMHg0YTI1MjU2ZiwgMHg1YzJlMmU3MiwgMHgzODFjMWMyNCwgMHg1N2E2YTZmMSwgMHg3M2I0YjRjNywgMHg5N2M2YzY1MSwgMHhjYmU4ZTgyMywgMHhhMWRkZGQ3YywgMHhlODc0NzQ5YywgMHgzZTFmMWYyMSwgMHg5NjRiNGJkZCwgMHg2MWJkYmRkYywgMHgwZDhiOGI4NiwgMHgwZjhhOGE4NSwgMHhlMDcwNzA5MCwgMHg3YzNlM2U0MiwgMHg3MWI1YjVjNCwgMHhjYzY2NjZhYSwgMHg5MDQ4NDhkOCwgMHgwNjAzMDMwNSwgMHhmN2Y2ZjYwMSwgMHgxYzBlMGUxMiwgMHhjMjYxNjFhMywgMHg2YTM1MzU1ZiwgMHhhZTU3NTdmOSwgMHg2OWI5YjlkMCwgMHgxNzg2ODY5MSwgMHg5OWMxYzE1OCwgMHgzYTFkMWQyNywgMHgyNzllOWViOSwgMHhkOWUxZTEzOCwgMHhlYmY4ZjgxMywgMHgyYjk4OThiMywgMHgyMjExMTEzMywgMHhkMjY5NjliYiwgMHhhOWQ5ZDk3MCwgMHgwNzhlOGU4OSwgMHgzMzk0OTRhNywgMHgyZDliOWJiNiwgMHgzYzFlMWUyMiwgMHgxNTg3ODc5MiwgMHhjOWU5ZTkyMCwgMHg4N2NlY2U0OSwgMHhhYTU1NTVmZiwgMHg1MDI4Mjg3OCwgMHhhNWRmZGY3YSwgMHgwMzhjOGM4ZiwgMHg1OWExYTFmOCwgMHgwOTg5ODk4MCwgMHgxYTBkMGQxNywgMHg2NWJmYmZkYSwgMHhkN2U2ZTYzMSwgMHg4NDQyNDJjNiwgMHhkMDY4NjhiOCwgMHg4MjQxNDFjMywgMHgyOTk5OTliMCwgMHg1YTJkMmQ3NywgMHgxZTBmMGYxMSwgMHg3YmIwYjBjYiwgMHhhODU0NTRmYywgMHg2ZGJiYmJkNiwgMHgyYzE2MTYzYV07XG5cdCAgICB2YXIgVDIgPSBbMHhhNWM2NjM2MywgMHg4NGY4N2M3YywgMHg5OWVlNzc3NywgMHg4ZGY2N2I3YiwgMHgwZGZmZjJmMiwgMHhiZGQ2NmI2YiwgMHhiMWRlNmY2ZiwgMHg1NDkxYzVjNSwgMHg1MDYwMzAzMCwgMHgwMzAyMDEwMSwgMHhhOWNlNjc2NywgMHg3ZDU2MmIyYiwgMHgxOWU3ZmVmZSwgMHg2MmI1ZDdkNywgMHhlNjRkYWJhYiwgMHg5YWVjNzY3NiwgMHg0NThmY2FjYSwgMHg5ZDFmODI4MiwgMHg0MDg5YzljOSwgMHg4N2ZhN2Q3ZCwgMHgxNWVmZmFmYSwgMHhlYmIyNTk1OSwgMHhjOThlNDc0NywgMHgwYmZiZjBmMCwgMHhlYzQxYWRhZCwgMHg2N2IzZDRkNCwgMHhmZDVmYTJhMiwgMHhlYTQ1YWZhZiwgMHhiZjIzOWM5YywgMHhmNzUzYTRhNCwgMHg5NmU0NzI3MiwgMHg1YjliYzBjMCwgMHhjMjc1YjdiNywgMHgxY2UxZmRmZCwgMHhhZTNkOTM5MywgMHg2YTRjMjYyNiwgMHg1YTZjMzYzNiwgMHg0MTdlM2YzZiwgMHgwMmY1ZjdmNywgMHg0ZjgzY2NjYywgMHg1YzY4MzQzNCwgMHhmNDUxYTVhNSwgMHgzNGQxZTVlNSwgMHgwOGY5ZjFmMSwgMHg5M2UyNzE3MSwgMHg3M2FiZDhkOCwgMHg1MzYyMzEzMSwgMHgzZjJhMTUxNSwgMHgwYzA4MDQwNCwgMHg1Mjk1YzdjNywgMHg2NTQ2MjMyMywgMHg1ZTlkYzNjMywgMHgyODMwMTgxOCwgMHhhMTM3OTY5NiwgMHgwZjBhMDUwNSwgMHhiNTJmOWE5YSwgMHgwOTBlMDcwNywgMHgzNjI0MTIxMiwgMHg5YjFiODA4MCwgMHgzZGRmZTJlMiwgMHgyNmNkZWJlYiwgMHg2OTRlMjcyNywgMHhjZDdmYjJiMiwgMHg5ZmVhNzU3NSwgMHgxYjEyMDkwOSwgMHg5ZTFkODM4MywgMHg3NDU4MmMyYywgMHgyZTM0MWExYSwgMHgyZDM2MWIxYiwgMHhiMmRjNmU2ZSwgMHhlZWI0NWE1YSwgMHhmYjViYTBhMCwgMHhmNmE0NTI1MiwgMHg0ZDc2M2IzYiwgMHg2MWI3ZDZkNiwgMHhjZTdkYjNiMywgMHg3YjUyMjkyOSwgMHgzZWRkZTNlMywgMHg3MTVlMmYyZiwgMHg5NzEzODQ4NCwgMHhmNWE2NTM1MywgMHg2OGI5ZDFkMSwgMHgwMDAwMDAwMCwgMHgyY2MxZWRlZCwgMHg2MDQwMjAyMCwgMHgxZmUzZmNmYywgMHhjODc5YjFiMSwgMHhlZGI2NWI1YiwgMHhiZWQ0NmE2YSwgMHg0NjhkY2JjYiwgMHhkOTY3YmViZSwgMHg0YjcyMzkzOSwgMHhkZTk0NGE0YSwgMHhkNDk4NGM0YywgMHhlOGIwNTg1OCwgMHg0YTg1Y2ZjZiwgMHg2YmJiZDBkMCwgMHgyYWM1ZWZlZiwgMHhlNTRmYWFhYSwgMHgxNmVkZmJmYiwgMHhjNTg2NDM0MywgMHhkNzlhNGQ0ZCwgMHg1NTY2MzMzMywgMHg5NDExODU4NSwgMHhjZjhhNDU0NSwgMHgxMGU5ZjlmOSwgMHgwNjA0MDIwMiwgMHg4MWZlN2Y3ZiwgMHhmMGEwNTA1MCwgMHg0NDc4M2MzYywgMHhiYTI1OWY5ZiwgMHhlMzRiYThhOCwgMHhmM2EyNTE1MSwgMHhmZTVkYTNhMywgMHhjMDgwNDA0MCwgMHg4YTA1OGY4ZiwgMHhhZDNmOTI5MiwgMHhiYzIxOWQ5ZCwgMHg0ODcwMzgzOCwgMHgwNGYxZjVmNSwgMHhkZjYzYmNiYywgMHhjMTc3YjZiNiwgMHg3NWFmZGFkYSwgMHg2MzQyMjEyMSwgMHgzMDIwMTAxMCwgMHgxYWU1ZmZmZiwgMHgwZWZkZjNmMywgMHg2ZGJmZDJkMiwgMHg0YzgxY2RjZCwgMHgxNDE4MGMwYywgMHgzNTI2MTMxMywgMHgyZmMzZWNlYywgMHhlMWJlNWY1ZiwgMHhhMjM1OTc5NywgMHhjYzg4NDQ0NCwgMHgzOTJlMTcxNywgMHg1NzkzYzRjNCwgMHhmMjU1YTdhNywgMHg4MmZjN2U3ZSwgMHg0NzdhM2QzZCwgMHhhY2M4NjQ2NCwgMHhlN2JhNWQ1ZCwgMHgyYjMyMTkxOSwgMHg5NWU2NzM3MywgMHhhMGMwNjA2MCwgMHg5ODE5ODE4MSwgMHhkMTllNGY0ZiwgMHg3ZmEzZGNkYywgMHg2NjQ0MjIyMiwgMHg3ZTU0MmEyYSwgMHhhYjNiOTA5MCwgMHg4MzBiODg4OCwgMHhjYThjNDY0NiwgMHgyOWM3ZWVlZSwgMHhkMzZiYjhiOCwgMHgzYzI4MTQxNCwgMHg3OWE3ZGVkZSwgMHhlMmJjNWU1ZSwgMHgxZDE2MGIwYiwgMHg3NmFkZGJkYiwgMHgzYmRiZTBlMCwgMHg1NjY0MzIzMiwgMHg0ZTc0M2EzYSwgMHgxZTE0MGEwYSwgMHhkYjkyNDk0OSwgMHgwYTBjMDYwNiwgMHg2YzQ4MjQyNCwgMHhlNGI4NWM1YywgMHg1ZDlmYzJjMiwgMHg2ZWJkZDNkMywgMHhlZjQzYWNhYywgMHhhNmM0NjI2MiwgMHhhODM5OTE5MSwgMHhhNDMxOTU5NSwgMHgzN2QzZTRlNCwgMHg4YmYyNzk3OSwgMHgzMmQ1ZTdlNywgMHg0MzhiYzhjOCwgMHg1OTZlMzczNywgMHhiN2RhNmQ2ZCwgMHg4YzAxOGQ4ZCwgMHg2NGIxZDVkNSwgMHhkMjljNGU0ZSwgMHhlMDQ5YTlhOSwgMHhiNGQ4NmM2YywgMHhmYWFjNTY1NiwgMHgwN2YzZjRmNCwgMHgyNWNmZWFlYSwgMHhhZmNhNjU2NSwgMHg4ZWY0N2E3YSwgMHhlOTQ3YWVhZSwgMHgxODEwMDgwOCwgMHhkNTZmYmFiYSwgMHg4OGYwNzg3OCwgMHg2ZjRhMjUyNSwgMHg3MjVjMmUyZSwgMHgyNDM4MWMxYywgMHhmMTU3YTZhNiwgMHhjNzczYjRiNCwgMHg1MTk3YzZjNiwgMHgyM2NiZThlOCwgMHg3Y2ExZGRkZCwgMHg5Y2U4NzQ3NCwgMHgyMTNlMWYxZiwgMHhkZDk2NGI0YiwgMHhkYzYxYmRiZCwgMHg4NjBkOGI4YiwgMHg4NTBmOGE4YSwgMHg5MGUwNzA3MCwgMHg0MjdjM2UzZSwgMHhjNDcxYjViNSwgMHhhYWNjNjY2NiwgMHhkODkwNDg0OCwgMHgwNTA2MDMwMywgMHgwMWY3ZjZmNiwgMHgxMjFjMGUwZSwgMHhhM2MyNjE2MSwgMHg1ZjZhMzUzNSwgMHhmOWFlNTc1NywgMHhkMDY5YjliOSwgMHg5MTE3ODY4NiwgMHg1ODk5YzFjMSwgMHgyNzNhMWQxZCwgMHhiOTI3OWU5ZSwgMHgzOGQ5ZTFlMSwgMHgxM2ViZjhmOCwgMHhiMzJiOTg5OCwgMHgzMzIyMTExMSwgMHhiYmQyNjk2OSwgMHg3MGE5ZDlkOSwgMHg4OTA3OGU4ZSwgMHhhNzMzOTQ5NCwgMHhiNjJkOWI5YiwgMHgyMjNjMWUxZSwgMHg5MjE1ODc4NywgMHgyMGM5ZTllOSwgMHg0OTg3Y2VjZSwgMHhmZmFhNTU1NSwgMHg3ODUwMjgyOCwgMHg3YWE1ZGZkZiwgMHg4ZjAzOGM4YywgMHhmODU5YTFhMSwgMHg4MDA5ODk4OSwgMHgxNzFhMGQwZCwgMHhkYTY1YmZiZiwgMHgzMWQ3ZTZlNiwgMHhjNjg0NDI0MiwgMHhiOGQwNjg2OCwgMHhjMzgyNDE0MSwgMHhiMDI5OTk5OSwgMHg3NzVhMmQyZCwgMHgxMTFlMGYwZiwgMHhjYjdiYjBiMCwgMHhmY2E4NTQ1NCwgMHhkNjZkYmJiYiwgMHgzYTJjMTYxNl07XG5cdCAgICB2YXIgVDMgPSBbMHg2M2E1YzY2MywgMHg3Yzg0Zjg3YywgMHg3Nzk5ZWU3NywgMHg3YjhkZjY3YiwgMHhmMjBkZmZmMiwgMHg2YmJkZDY2YiwgMHg2ZmIxZGU2ZiwgMHhjNTU0OTFjNSwgMHgzMDUwNjAzMCwgMHgwMTAzMDIwMSwgMHg2N2E5Y2U2NywgMHgyYjdkNTYyYiwgMHhmZTE5ZTdmZSwgMHhkNzYyYjVkNywgMHhhYmU2NGRhYiwgMHg3NjlhZWM3NiwgMHhjYTQ1OGZjYSwgMHg4MjlkMWY4MiwgMHhjOTQwODljOSwgMHg3ZDg3ZmE3ZCwgMHhmYTE1ZWZmYSwgMHg1OWViYjI1OSwgMHg0N2M5OGU0NywgMHhmMDBiZmJmMCwgMHhhZGVjNDFhZCwgMHhkNDY3YjNkNCwgMHhhMmZkNWZhMiwgMHhhZmVhNDVhZiwgMHg5Y2JmMjM5YywgMHhhNGY3NTNhNCwgMHg3Mjk2ZTQ3MiwgMHhjMDViOWJjMCwgMHhiN2MyNzViNywgMHhmZDFjZTFmZCwgMHg5M2FlM2Q5MywgMHgyNjZhNGMyNiwgMHgzNjVhNmMzNiwgMHgzZjQxN2UzZiwgMHhmNzAyZjVmNywgMHhjYzRmODNjYywgMHgzNDVjNjgzNCwgMHhhNWY0NTFhNSwgMHhlNTM0ZDFlNSwgMHhmMTA4ZjlmMSwgMHg3MTkzZTI3MSwgMHhkODczYWJkOCwgMHgzMTUzNjIzMSwgMHgxNTNmMmExNSwgMHgwNDBjMDgwNCwgMHhjNzUyOTVjNywgMHgyMzY1NDYyMywgMHhjMzVlOWRjMywgMHgxODI4MzAxOCwgMHg5NmExMzc5NiwgMHgwNTBmMGEwNSwgMHg5YWI1MmY5YSwgMHgwNzA5MGUwNywgMHgxMjM2MjQxMiwgMHg4MDliMWI4MCwgMHhlMjNkZGZlMiwgMHhlYjI2Y2RlYiwgMHgyNzY5NGUyNywgMHhiMmNkN2ZiMiwgMHg3NTlmZWE3NSwgMHgwOTFiMTIwOSwgMHg4MzllMWQ4MywgMHgyYzc0NTgyYywgMHgxYTJlMzQxYSwgMHgxYjJkMzYxYiwgMHg2ZWIyZGM2ZSwgMHg1YWVlYjQ1YSwgMHhhMGZiNWJhMCwgMHg1MmY2YTQ1MiwgMHgzYjRkNzYzYiwgMHhkNjYxYjdkNiwgMHhiM2NlN2RiMywgMHgyOTdiNTIyOSwgMHhlMzNlZGRlMywgMHgyZjcxNWUyZiwgMHg4NDk3MTM4NCwgMHg1M2Y1YTY1MywgMHhkMTY4YjlkMSwgMHgwMDAwMDAwMCwgMHhlZDJjYzFlZCwgMHgyMDYwNDAyMCwgMHhmYzFmZTNmYywgMHhiMWM4NzliMSwgMHg1YmVkYjY1YiwgMHg2YWJlZDQ2YSwgMHhjYjQ2OGRjYiwgMHhiZWQ5NjdiZSwgMHgzOTRiNzIzOSwgMHg0YWRlOTQ0YSwgMHg0Y2Q0OTg0YywgMHg1OGU4YjA1OCwgMHhjZjRhODVjZiwgMHhkMDZiYmJkMCwgMHhlZjJhYzVlZiwgMHhhYWU1NGZhYSwgMHhmYjE2ZWRmYiwgMHg0M2M1ODY0MywgMHg0ZGQ3OWE0ZCwgMHgzMzU1NjYzMywgMHg4NTk0MTE4NSwgMHg0NWNmOGE0NSwgMHhmOTEwZTlmOSwgMHgwMjA2MDQwMiwgMHg3ZjgxZmU3ZiwgMHg1MGYwYTA1MCwgMHgzYzQ0NzgzYywgMHg5ZmJhMjU5ZiwgMHhhOGUzNGJhOCwgMHg1MWYzYTI1MSwgMHhhM2ZlNWRhMywgMHg0MGMwODA0MCwgMHg4ZjhhMDU4ZiwgMHg5MmFkM2Y5MiwgMHg5ZGJjMjE5ZCwgMHgzODQ4NzAzOCwgMHhmNTA0ZjFmNSwgMHhiY2RmNjNiYywgMHhiNmMxNzdiNiwgMHhkYTc1YWZkYSwgMHgyMTYzNDIyMSwgMHgxMDMwMjAxMCwgMHhmZjFhZTVmZiwgMHhmMzBlZmRmMywgMHhkMjZkYmZkMiwgMHhjZDRjODFjZCwgMHgwYzE0MTgwYywgMHgxMzM1MjYxMywgMHhlYzJmYzNlYywgMHg1ZmUxYmU1ZiwgMHg5N2EyMzU5NywgMHg0NGNjODg0NCwgMHgxNzM5MmUxNywgMHhjNDU3OTNjNCwgMHhhN2YyNTVhNywgMHg3ZTgyZmM3ZSwgMHgzZDQ3N2EzZCwgMHg2NGFjYzg2NCwgMHg1ZGU3YmE1ZCwgMHgxOTJiMzIxOSwgMHg3Mzk1ZTY3MywgMHg2MGEwYzA2MCwgMHg4MTk4MTk4MSwgMHg0ZmQxOWU0ZiwgMHhkYzdmYTNkYywgMHgyMjY2NDQyMiwgMHgyYTdlNTQyYSwgMHg5MGFiM2I5MCwgMHg4ODgzMGI4OCwgMHg0NmNhOGM0NiwgMHhlZTI5YzdlZSwgMHhiOGQzNmJiOCwgMHgxNDNjMjgxNCwgMHhkZTc5YTdkZSwgMHg1ZWUyYmM1ZSwgMHgwYjFkMTYwYiwgMHhkYjc2YWRkYiwgMHhlMDNiZGJlMCwgMHgzMjU2NjQzMiwgMHgzYTRlNzQzYSwgMHgwYTFlMTQwYSwgMHg0OWRiOTI0OSwgMHgwNjBhMGMwNiwgMHgyNDZjNDgyNCwgMHg1Y2U0Yjg1YywgMHhjMjVkOWZjMiwgMHhkMzZlYmRkMywgMHhhY2VmNDNhYywgMHg2MmE2YzQ2MiwgMHg5MWE4Mzk5MSwgMHg5NWE0MzE5NSwgMHhlNDM3ZDNlNCwgMHg3OThiZjI3OSwgMHhlNzMyZDVlNywgMHhjODQzOGJjOCwgMHgzNzU5NmUzNywgMHg2ZGI3ZGE2ZCwgMHg4ZDhjMDE4ZCwgMHhkNTY0YjFkNSwgMHg0ZWQyOWM0ZSwgMHhhOWUwNDlhOSwgMHg2Y2I0ZDg2YywgMHg1NmZhYWM1NiwgMHhmNDA3ZjNmNCwgMHhlYTI1Y2ZlYSwgMHg2NWFmY2E2NSwgMHg3YThlZjQ3YSwgMHhhZWU5NDdhZSwgMHgwODE4MTAwOCwgMHhiYWQ1NmZiYSwgMHg3ODg4ZjA3OCwgMHgyNTZmNGEyNSwgMHgyZTcyNWMyZSwgMHgxYzI0MzgxYywgMHhhNmYxNTdhNiwgMHhiNGM3NzNiNCwgMHhjNjUxOTdjNiwgMHhlODIzY2JlOCwgMHhkZDdjYTFkZCwgMHg3NDljZTg3NCwgMHgxZjIxM2UxZiwgMHg0YmRkOTY0YiwgMHhiZGRjNjFiZCwgMHg4Yjg2MGQ4YiwgMHg4YTg1MGY4YSwgMHg3MDkwZTA3MCwgMHgzZTQyN2MzZSwgMHhiNWM0NzFiNSwgMHg2NmFhY2M2NiwgMHg0OGQ4OTA0OCwgMHgwMzA1MDYwMywgMHhmNjAxZjdmNiwgMHgwZTEyMWMwZSwgMHg2MWEzYzI2MSwgMHgzNTVmNmEzNSwgMHg1N2Y5YWU1NywgMHhiOWQwNjliOSwgMHg4NjkxMTc4NiwgMHhjMTU4OTljMSwgMHgxZDI3M2ExZCwgMHg5ZWI5Mjc5ZSwgMHhlMTM4ZDllMSwgMHhmODEzZWJmOCwgMHg5OGIzMmI5OCwgMHgxMTMzMjIxMSwgMHg2OWJiZDI2OSwgMHhkOTcwYTlkOSwgMHg4ZTg5MDc4ZSwgMHg5NGE3MzM5NCwgMHg5YmI2MmQ5YiwgMHgxZTIyM2MxZSwgMHg4NzkyMTU4NywgMHhlOTIwYzllOSwgMHhjZTQ5ODdjZSwgMHg1NWZmYWE1NSwgMHgyODc4NTAyOCwgMHhkZjdhYTVkZiwgMHg4YzhmMDM4YywgMHhhMWY4NTlhMSwgMHg4OTgwMDk4OSwgMHgwZDE3MWEwZCwgMHhiZmRhNjViZiwgMHhlNjMxZDdlNiwgMHg0MmM2ODQ0MiwgMHg2OGI4ZDA2OCwgMHg0MWMzODI0MSwgMHg5OWIwMjk5OSwgMHgyZDc3NWEyZCwgMHgwZjExMWUwZiwgMHhiMGNiN2JiMCwgMHg1NGZjYTg1NCwgMHhiYmQ2NmRiYiwgMHgxNjNhMmMxNl07XG5cdCAgICB2YXIgVDQgPSBbMHg2MzYzYTVjNiwgMHg3YzdjODRmOCwgMHg3Nzc3OTllZSwgMHg3YjdiOGRmNiwgMHhmMmYyMGRmZiwgMHg2YjZiYmRkNiwgMHg2ZjZmYjFkZSwgMHhjNWM1NTQ5MSwgMHgzMDMwNTA2MCwgMHgwMTAxMDMwMiwgMHg2NzY3YTljZSwgMHgyYjJiN2Q1NiwgMHhmZWZlMTllNywgMHhkN2Q3NjJiNSwgMHhhYmFiZTY0ZCwgMHg3Njc2OWFlYywgMHhjYWNhNDU4ZiwgMHg4MjgyOWQxZiwgMHhjOWM5NDA4OSwgMHg3ZDdkODdmYSwgMHhmYWZhMTVlZiwgMHg1OTU5ZWJiMiwgMHg0NzQ3Yzk4ZSwgMHhmMGYwMGJmYiwgMHhhZGFkZWM0MSwgMHhkNGQ0NjdiMywgMHhhMmEyZmQ1ZiwgMHhhZmFmZWE0NSwgMHg5YzljYmYyMywgMHhhNGE0Zjc1MywgMHg3MjcyOTZlNCwgMHhjMGMwNWI5YiwgMHhiN2I3YzI3NSwgMHhmZGZkMWNlMSwgMHg5MzkzYWUzZCwgMHgyNjI2NmE0YywgMHgzNjM2NWE2YywgMHgzZjNmNDE3ZSwgMHhmN2Y3MDJmNSwgMHhjY2NjNGY4MywgMHgzNDM0NWM2OCwgMHhhNWE1ZjQ1MSwgMHhlNWU1MzRkMSwgMHhmMWYxMDhmOSwgMHg3MTcxOTNlMiwgMHhkOGQ4NzNhYiwgMHgzMTMxNTM2MiwgMHgxNTE1M2YyYSwgMHgwNDA0MGMwOCwgMHhjN2M3NTI5NSwgMHgyMzIzNjU0NiwgMHhjM2MzNWU5ZCwgMHgxODE4MjgzMCwgMHg5Njk2YTEzNywgMHgwNTA1MGYwYSwgMHg5YTlhYjUyZiwgMHgwNzA3MDkwZSwgMHgxMjEyMzYyNCwgMHg4MDgwOWIxYiwgMHhlMmUyM2RkZiwgMHhlYmViMjZjZCwgMHgyNzI3Njk0ZSwgMHhiMmIyY2Q3ZiwgMHg3NTc1OWZlYSwgMHgwOTA5MWIxMiwgMHg4MzgzOWUxZCwgMHgyYzJjNzQ1OCwgMHgxYTFhMmUzNCwgMHgxYjFiMmQzNiwgMHg2ZTZlYjJkYywgMHg1YTVhZWViNCwgMHhhMGEwZmI1YiwgMHg1MjUyZjZhNCwgMHgzYjNiNGQ3NiwgMHhkNmQ2NjFiNywgMHhiM2IzY2U3ZCwgMHgyOTI5N2I1MiwgMHhlM2UzM2VkZCwgMHgyZjJmNzE1ZSwgMHg4NDg0OTcxMywgMHg1MzUzZjVhNiwgMHhkMWQxNjhiOSwgMHgwMDAwMDAwMCwgMHhlZGVkMmNjMSwgMHgyMDIwNjA0MCwgMHhmY2ZjMWZlMywgMHhiMWIxYzg3OSwgMHg1YjViZWRiNiwgMHg2YTZhYmVkNCwgMHhjYmNiNDY4ZCwgMHhiZWJlZDk2NywgMHgzOTM5NGI3MiwgMHg0YTRhZGU5NCwgMHg0YzRjZDQ5OCwgMHg1ODU4ZThiMCwgMHhjZmNmNGE4NSwgMHhkMGQwNmJiYiwgMHhlZmVmMmFjNSwgMHhhYWFhZTU0ZiwgMHhmYmZiMTZlZCwgMHg0MzQzYzU4NiwgMHg0ZDRkZDc5YSwgMHgzMzMzNTU2NiwgMHg4NTg1OTQxMSwgMHg0NTQ1Y2Y4YSwgMHhmOWY5MTBlOSwgMHgwMjAyMDYwNCwgMHg3ZjdmODFmZSwgMHg1MDUwZjBhMCwgMHgzYzNjNDQ3OCwgMHg5ZjlmYmEyNSwgMHhhOGE4ZTM0YiwgMHg1MTUxZjNhMiwgMHhhM2EzZmU1ZCwgMHg0MDQwYzA4MCwgMHg4ZjhmOGEwNSwgMHg5MjkyYWQzZiwgMHg5ZDlkYmMyMSwgMHgzODM4NDg3MCwgMHhmNWY1MDRmMSwgMHhiY2JjZGY2MywgMHhiNmI2YzE3NywgMHhkYWRhNzVhZiwgMHgyMTIxNjM0MiwgMHgxMDEwMzAyMCwgMHhmZmZmMWFlNSwgMHhmM2YzMGVmZCwgMHhkMmQyNmRiZiwgMHhjZGNkNGM4MSwgMHgwYzBjMTQxOCwgMHgxMzEzMzUyNiwgMHhlY2VjMmZjMywgMHg1ZjVmZTFiZSwgMHg5Nzk3YTIzNSwgMHg0NDQ0Y2M4OCwgMHgxNzE3MzkyZSwgMHhjNGM0NTc5MywgMHhhN2E3ZjI1NSwgMHg3ZTdlODJmYywgMHgzZDNkNDc3YSwgMHg2NDY0YWNjOCwgMHg1ZDVkZTdiYSwgMHgxOTE5MmIzMiwgMHg3MzczOTVlNiwgMHg2MDYwYTBjMCwgMHg4MTgxOTgxOSwgMHg0ZjRmZDE5ZSwgMHhkY2RjN2ZhMywgMHgyMjIyNjY0NCwgMHgyYTJhN2U1NCwgMHg5MDkwYWIzYiwgMHg4ODg4ODMwYiwgMHg0NjQ2Y2E4YywgMHhlZWVlMjljNywgMHhiOGI4ZDM2YiwgMHgxNDE0M2MyOCwgMHhkZWRlNzlhNywgMHg1ZTVlZTJiYywgMHgwYjBiMWQxNiwgMHhkYmRiNzZhZCwgMHhlMGUwM2JkYiwgMHgzMjMyNTY2NCwgMHgzYTNhNGU3NCwgMHgwYTBhMWUxNCwgMHg0OTQ5ZGI5MiwgMHgwNjA2MGEwYywgMHgyNDI0NmM0OCwgMHg1YzVjZTRiOCwgMHhjMmMyNWQ5ZiwgMHhkM2QzNmViZCwgMHhhY2FjZWY0MywgMHg2MjYyYTZjNCwgMHg5MTkxYTgzOSwgMHg5NTk1YTQzMSwgMHhlNGU0MzdkMywgMHg3OTc5OGJmMiwgMHhlN2U3MzJkNSwgMHhjOGM4NDM4YiwgMHgzNzM3NTk2ZSwgMHg2ZDZkYjdkYSwgMHg4ZDhkOGMwMSwgMHhkNWQ1NjRiMSwgMHg0ZTRlZDI5YywgMHhhOWE5ZTA0OSwgMHg2YzZjYjRkOCwgMHg1NjU2ZmFhYywgMHhmNGY0MDdmMywgMHhlYWVhMjVjZiwgMHg2NTY1YWZjYSwgMHg3YTdhOGVmNCwgMHhhZWFlZTk0NywgMHgwODA4MTgxMCwgMHhiYWJhZDU2ZiwgMHg3ODc4ODhmMCwgMHgyNTI1NmY0YSwgMHgyZTJlNzI1YywgMHgxYzFjMjQzOCwgMHhhNmE2ZjE1NywgMHhiNGI0Yzc3MywgMHhjNmM2NTE5NywgMHhlOGU4MjNjYiwgMHhkZGRkN2NhMSwgMHg3NDc0OWNlOCwgMHgxZjFmMjEzZSwgMHg0YjRiZGQ5NiwgMHhiZGJkZGM2MSwgMHg4YjhiODYwZCwgMHg4YThhODUwZiwgMHg3MDcwOTBlMCwgMHgzZTNlNDI3YywgMHhiNWI1YzQ3MSwgMHg2NjY2YWFjYywgMHg0ODQ4ZDg5MCwgMHgwMzAzMDUwNiwgMHhmNmY2MDFmNywgMHgwZTBlMTIxYywgMHg2MTYxYTNjMiwgMHgzNTM1NWY2YSwgMHg1NzU3ZjlhZSwgMHhiOWI5ZDA2OSwgMHg4Njg2OTExNywgMHhjMWMxNTg5OSwgMHgxZDFkMjczYSwgMHg5ZTllYjkyNywgMHhlMWUxMzhkOSwgMHhmOGY4MTNlYiwgMHg5ODk4YjMyYiwgMHgxMTExMzMyMiwgMHg2OTY5YmJkMiwgMHhkOWQ5NzBhOSwgMHg4ZThlODkwNywgMHg5NDk0YTczMywgMHg5YjliYjYyZCwgMHgxZTFlMjIzYywgMHg4Nzg3OTIxNSwgMHhlOWU5MjBjOSwgMHhjZWNlNDk4NywgMHg1NTU1ZmZhYSwgMHgyODI4Nzg1MCwgMHhkZmRmN2FhNSwgMHg4YzhjOGYwMywgMHhhMWExZjg1OSwgMHg4OTg5ODAwOSwgMHgwZDBkMTcxYSwgMHhiZmJmZGE2NSwgMHhlNmU2MzFkNywgMHg0MjQyYzY4NCwgMHg2ODY4YjhkMCwgMHg0MTQxYzM4MiwgMHg5OTk5YjAyOSwgMHgyZDJkNzc1YSwgMHgwZjBmMTExZSwgMHhiMGIwY2I3YiwgMHg1NDU0ZmNhOCwgMHhiYmJiZDY2ZCwgMHgxNjE2M2EyY107XG5cblx0ICAgIC8vIFRyYW5zZm9ybWF0aW9ucyBmb3IgZGVjcnlwdGlvblxuXHQgICAgdmFyIFQ1ID0gWzB4NTFmNGE3NTAsIDB4N2U0MTY1NTMsIDB4MWExN2E0YzMsIDB4M2EyNzVlOTYsIDB4M2JhYjZiY2IsIDB4MWY5ZDQ1ZjEsIDB4YWNmYTU4YWIsIDB4NGJlMzAzOTMsIDB4MjAzMGZhNTUsIDB4YWQ3NjZkZjYsIDB4ODhjYzc2OTEsIDB4ZjUwMjRjMjUsIDB4NGZlNWQ3ZmMsIDB4YzUyYWNiZDcsIDB4MjYzNTQ0ODAsIDB4YjU2MmEzOGYsIDB4ZGViMTVhNDksIDB4MjViYTFiNjcsIDB4NDVlYTBlOTgsIDB4NWRmZWMwZTEsIDB4YzMyZjc1MDIsIDB4ODE0Y2YwMTIsIDB4OGQ0Njk3YTMsIDB4NmJkM2Y5YzYsIDB4MDM4ZjVmZTcsIDB4MTU5MjljOTUsIDB4YmY2ZDdhZWIsIDB4OTU1MjU5ZGEsIDB4ZDRiZTgzMmQsIDB4NTg3NDIxZDMsIDB4NDllMDY5MjksIDB4OGVjOWM4NDQsIDB4NzVjMjg5NmEsIDB4ZjQ4ZTc5NzgsIDB4OTk1ODNlNmIsIDB4MjdiOTcxZGQsIDB4YmVlMTRmYjYsIDB4ZjA4OGFkMTcsIDB4YzkyMGFjNjYsIDB4N2RjZTNhYjQsIDB4NjNkZjRhMTgsIDB4ZTUxYTMxODIsIDB4OTc1MTMzNjAsIDB4NjI1MzdmNDUsIDB4YjE2NDc3ZTAsIDB4YmI2YmFlODQsIDB4ZmU4MWEwMWMsIDB4ZjkwODJiOTQsIDB4NzA0ODY4NTgsIDB4OGY0NWZkMTksIDB4OTRkZTZjODcsIDB4NTI3YmY4YjcsIDB4YWI3M2QzMjMsIDB4NzI0YjAyZTIsIDB4ZTMxZjhmNTcsIDB4NjY1NWFiMmEsIDB4YjJlYjI4MDcsIDB4MmZiNWMyMDMsIDB4ODZjNTdiOWEsIDB4ZDMzNzA4YTUsIDB4MzAyODg3ZjIsIDB4MjNiZmE1YjIsIDB4MDIwMzZhYmEsIDB4ZWQxNjgyNWMsIDB4OGFjZjFjMmIsIDB4YTc3OWI0OTIsIDB4ZjMwN2YyZjAsIDB4NGU2OWUyYTEsIDB4NjVkYWY0Y2QsIDB4MDYwNWJlZDUsIDB4ZDEzNDYyMWYsIDB4YzRhNmZlOGEsIDB4MzQyZTUzOWQsIDB4YTJmMzU1YTAsIDB4MDU4YWUxMzIsIDB4YTRmNmViNzUsIDB4MGI4M2VjMzksIDB4NDA2MGVmYWEsIDB4NWU3MTlmMDYsIDB4YmQ2ZTEwNTEsIDB4M2UyMThhZjksIDB4OTZkZDA2M2QsIDB4ZGQzZTA1YWUsIDB4NGRlNmJkNDYsIDB4OTE1NDhkYjUsIDB4NzFjNDVkMDUsIDB4MDQwNmQ0NmYsIDB4NjA1MDE1ZmYsIDB4MTk5OGZiMjQsIDB4ZDZiZGU5OTcsIDB4ODk0MDQzY2MsIDB4NjdkOTllNzcsIDB4YjBlODQyYmQsIDB4MDc4OThiODgsIDB4ZTcxOTViMzgsIDB4NzljOGVlZGIsIDB4YTE3YzBhNDcsIDB4N2M0MjBmZTksIDB4Zjg4NDFlYzksIDB4MDAwMDAwMDAsIDB4MDk4MDg2ODMsIDB4MzIyYmVkNDgsIDB4MWUxMTcwYWMsIDB4NmM1YTcyNGUsIDB4ZmQwZWZmZmIsIDB4MGY4NTM4NTYsIDB4M2RhZWQ1MWUsIDB4MzYyZDM5MjcsIDB4MGEwZmQ5NjQsIDB4Njg1Y2E2MjEsIDB4OWI1YjU0ZDEsIDB4MjQzNjJlM2EsIDB4MGMwYTY3YjEsIDB4OTM1N2U3MGYsIDB4YjRlZTk2ZDIsIDB4MWI5YjkxOWUsIDB4ODBjMGM1NGYsIDB4NjFkYzIwYTIsIDB4NWE3NzRiNjksIDB4MWMxMjFhMTYsIDB4ZTI5M2JhMGEsIDB4YzBhMDJhZTUsIDB4M2MyMmUwNDMsIDB4MTIxYjE3MWQsIDB4MGUwOTBkMGIsIDB4ZjI4YmM3YWQsIDB4MmRiNmE4YjksIDB4MTQxZWE5YzgsIDB4NTdmMTE5ODUsIDB4YWY3NTA3NGMsIDB4ZWU5OWRkYmIsIDB4YTM3ZjYwZmQsIDB4ZjcwMTI2OWYsIDB4NWM3MmY1YmMsIDB4NDQ2NjNiYzUsIDB4NWJmYjdlMzQsIDB4OGI0MzI5NzYsIDB4Y2IyM2M2ZGMsIDB4YjZlZGZjNjgsIDB4YjhlNGYxNjMsIDB4ZDczMWRjY2EsIDB4NDI2Mzg1MTAsIDB4MTM5NzIyNDAsIDB4ODRjNjExMjAsIDB4ODU0YTI0N2QsIDB4ZDJiYjNkZjgsIDB4YWVmOTMyMTEsIDB4YzcyOWExNmQsIDB4MWQ5ZTJmNGIsIDB4ZGNiMjMwZjMsIDB4MGQ4NjUyZWMsIDB4NzdjMWUzZDAsIDB4MmJiMzE2NmMsIDB4YTk3MGI5OTksIDB4MTE5NDQ4ZmEsIDB4NDdlOTY0MjIsIDB4YThmYzhjYzQsIDB4YTBmMDNmMWEsIDB4NTY3ZDJjZDgsIDB4MjIzMzkwZWYsIDB4ODc0OTRlYzcsIDB4ZDkzOGQxYzEsIDB4OGNjYWEyZmUsIDB4OThkNDBiMzYsIDB4YTZmNTgxY2YsIDB4YTU3YWRlMjgsIDB4ZGFiNzhlMjYsIDB4M2ZhZGJmYTQsIDB4MmMzYTlkZTQsIDB4NTA3ODkyMGQsIDB4NmE1ZmNjOWIsIDB4NTQ3ZTQ2NjIsIDB4ZjY4ZDEzYzIsIDB4OTBkOGI4ZTgsIDB4MmUzOWY3NWUsIDB4ODJjM2FmZjUsIDB4OWY1ZDgwYmUsIDB4NjlkMDkzN2MsIDB4NmZkNTJkYTksIDB4Y2YyNTEyYjMsIDB4YzhhYzk5M2IsIDB4MTAxODdkYTcsIDB4ZTg5YzYzNmUsIDB4ZGIzYmJiN2IsIDB4Y2QyNjc4MDksIDB4NmU1OTE4ZjQsIDB4ZWM5YWI3MDEsIDB4ODM0ZjlhYTgsIDB4ZTY5NTZlNjUsIDB4YWFmZmU2N2UsIDB4MjFiY2NmMDgsIDB4ZWYxNWU4ZTYsIDB4YmFlNzliZDksIDB4NGE2ZjM2Y2UsIDB4ZWE5ZjA5ZDQsIDB4MjliMDdjZDYsIDB4MzFhNGIyYWYsIDB4MmEzZjIzMzEsIDB4YzZhNTk0MzAsIDB4MzVhMjY2YzAsIDB4NzQ0ZWJjMzcsIDB4ZmM4MmNhYTYsIDB4ZTA5MGQwYjAsIDB4MzNhN2Q4MTUsIDB4ZjEwNDk4NGEsIDB4NDFlY2RhZjcsIDB4N2ZjZDUwMGUsIDB4MTc5MWY2MmYsIDB4NzY0ZGQ2OGQsIDB4NDNlZmIwNGQsIDB4Y2NhYTRkNTQsIDB4ZTQ5NjA0ZGYsIDB4OWVkMWI1ZTMsIDB4NGM2YTg4MWIsIDB4YzEyYzFmYjgsIDB4NDY2NTUxN2YsIDB4OWQ1ZWVhMDQsIDB4MDE4YzM1NWQsIDB4ZmE4Nzc0NzMsIDB4ZmIwYjQxMmUsIDB4YjM2NzFkNWEsIDB4OTJkYmQyNTIsIDB4ZTkxMDU2MzMsIDB4NmRkNjQ3MTMsIDB4OWFkNzYxOGMsIDB4MzdhMTBjN2EsIDB4NTlmODE0OGUsIDB4ZWIxMzNjODksIDB4Y2VhOTI3ZWUsIDB4Yjc2MWM5MzUsIDB4ZTExY2U1ZWQsIDB4N2E0N2IxM2MsIDB4OWNkMmRmNTksIDB4NTVmMjczM2YsIDB4MTgxNGNlNzksIDB4NzNjNzM3YmYsIDB4NTNmN2NkZWEsIDB4NWZmZGFhNWIsIDB4ZGYzZDZmMTQsIDB4Nzg0NGRiODYsIDB4Y2FhZmYzODEsIDB4Yjk2OGM0M2UsIDB4MzgyNDM0MmMsIDB4YzJhMzQwNWYsIDB4MTYxZGMzNzIsIDB4YmNlMjI1MGMsIDB4MjgzYzQ5OGIsIDB4ZmYwZDk1NDEsIDB4MzlhODAxNzEsIDB4MDgwY2IzZGUsIDB4ZDhiNGU0OWMsIDB4NjQ1NmMxOTAsIDB4N2JjYjg0NjEsIDB4ZDUzMmI2NzAsIDB4NDg2YzVjNzQsIDB4ZDBiODU3NDJdO1xuXHQgICAgdmFyIFQ2ID0gWzB4NTA1MWY0YTcsIDB4NTM3ZTQxNjUsIDB4YzMxYTE3YTQsIDB4OTYzYTI3NWUsIDB4Y2IzYmFiNmIsIDB4ZjExZjlkNDUsIDB4YWJhY2ZhNTgsIDB4OTM0YmUzMDMsIDB4NTUyMDMwZmEsIDB4ZjZhZDc2NmQsIDB4OTE4OGNjNzYsIDB4MjVmNTAyNGMsIDB4ZmM0ZmU1ZDcsIDB4ZDdjNTJhY2IsIDB4ODAyNjM1NDQsIDB4OGZiNTYyYTMsIDB4NDlkZWIxNWEsIDB4NjcyNWJhMWIsIDB4OTg0NWVhMGUsIDB4ZTE1ZGZlYzAsIDB4MDJjMzJmNzUsIDB4MTI4MTRjZjAsIDB4YTM4ZDQ2OTcsIDB4YzY2YmQzZjksIDB4ZTcwMzhmNWYsIDB4OTUxNTkyOWMsIDB4ZWJiZjZkN2EsIDB4ZGE5NTUyNTksIDB4MmRkNGJlODMsIDB4ZDM1ODc0MjEsIDB4Mjk0OWUwNjksIDB4NDQ4ZWM5YzgsIDB4NmE3NWMyODksIDB4NzhmNDhlNzksIDB4NmI5OTU4M2UsIDB4ZGQyN2I5NzEsIDB4YjZiZWUxNGYsIDB4MTdmMDg4YWQsIDB4NjZjOTIwYWMsIDB4YjQ3ZGNlM2EsIDB4MTg2M2RmNGEsIDB4ODJlNTFhMzEsIDB4NjA5NzUxMzMsIDB4NDU2MjUzN2YsIDB4ZTBiMTY0NzcsIDB4ODRiYjZiYWUsIDB4MWNmZTgxYTAsIDB4OTRmOTA4MmIsIDB4NTg3MDQ4NjgsIDB4MTk4ZjQ1ZmQsIDB4ODc5NGRlNmMsIDB4Yjc1MjdiZjgsIDB4MjNhYjczZDMsIDB4ZTI3MjRiMDIsIDB4NTdlMzFmOGYsIDB4MmE2NjU1YWIsIDB4MDdiMmViMjgsIDB4MDMyZmI1YzIsIDB4OWE4NmM1N2IsIDB4YTVkMzM3MDgsIDB4ZjIzMDI4ODcsIDB4YjIyM2JmYTUsIDB4YmEwMjAzNmEsIDB4NWNlZDE2ODIsIDB4MmI4YWNmMWMsIDB4OTJhNzc5YjQsIDB4ZjBmMzA3ZjIsIDB4YTE0ZTY5ZTIsIDB4Y2Q2NWRhZjQsIDB4ZDUwNjA1YmUsIDB4MWZkMTM0NjIsIDB4OGFjNGE2ZmUsIDB4OWQzNDJlNTMsIDB4YTBhMmYzNTUsIDB4MzIwNThhZTEsIDB4NzVhNGY2ZWIsIDB4MzkwYjgzZWMsIDB4YWE0MDYwZWYsIDB4MDY1ZTcxOWYsIDB4NTFiZDZlMTAsIDB4ZjkzZTIxOGEsIDB4M2Q5NmRkMDYsIDB4YWVkZDNlMDUsIDB4NDY0ZGU2YmQsIDB4YjU5MTU0OGQsIDB4MDU3MWM0NWQsIDB4NmYwNDA2ZDQsIDB4ZmY2MDUwMTUsIDB4MjQxOTk4ZmIsIDB4OTdkNmJkZTksIDB4Y2M4OTQwNDMsIDB4Nzc2N2Q5OWUsIDB4YmRiMGU4NDIsIDB4ODgwNzg5OGIsIDB4MzhlNzE5NWIsIDB4ZGI3OWM4ZWUsIDB4NDdhMTdjMGEsIDB4ZTk3YzQyMGYsIDB4YzlmODg0MWUsIDB4MDAwMDAwMDAsIDB4ODMwOTgwODYsIDB4NDgzMjJiZWQsIDB4YWMxZTExNzAsIDB4NGU2YzVhNzIsIDB4ZmJmZDBlZmYsIDB4NTYwZjg1MzgsIDB4MWUzZGFlZDUsIDB4MjczNjJkMzksIDB4NjQwYTBmZDksIDB4MjE2ODVjYTYsIDB4ZDE5YjViNTQsIDB4M2EyNDM2MmUsIDB4YjEwYzBhNjcsIDB4MGY5MzU3ZTcsIDB4ZDJiNGVlOTYsIDB4OWUxYjliOTEsIDB4NGY4MGMwYzUsIDB4YTI2MWRjMjAsIDB4Njk1YTc3NGIsIDB4MTYxYzEyMWEsIDB4MGFlMjkzYmEsIDB4ZTVjMGEwMmEsIDB4NDMzYzIyZTAsIDB4MWQxMjFiMTcsIDB4MGIwZTA5MGQsIDB4YWRmMjhiYzcsIDB4YjkyZGI2YTgsIDB4YzgxNDFlYTksIDB4ODU1N2YxMTksIDB4NGNhZjc1MDcsIDB4YmJlZTk5ZGQsIDB4ZmRhMzdmNjAsIDB4OWZmNzAxMjYsIDB4YmM1YzcyZjUsIDB4YzU0NDY2M2IsIDB4MzQ1YmZiN2UsIDB4NzY4YjQzMjksIDB4ZGNjYjIzYzYsIDB4NjhiNmVkZmMsIDB4NjNiOGU0ZjEsIDB4Y2FkNzMxZGMsIDB4MTA0MjYzODUsIDB4NDAxMzk3MjIsIDB4MjA4NGM2MTEsIDB4N2Q4NTRhMjQsIDB4ZjhkMmJiM2QsIDB4MTFhZWY5MzIsIDB4NmRjNzI5YTEsIDB4NGIxZDllMmYsIDB4ZjNkY2IyMzAsIDB4ZWMwZDg2NTIsIDB4ZDA3N2MxZTMsIDB4NmMyYmIzMTYsIDB4OTlhOTcwYjksIDB4ZmExMTk0NDgsIDB4MjI0N2U5NjQsIDB4YzRhOGZjOGMsIDB4MWFhMGYwM2YsIDB4ZDg1NjdkMmMsIDB4ZWYyMjMzOTAsIDB4Yzc4NzQ5NGUsIDB4YzFkOTM4ZDEsIDB4ZmU4Y2NhYTIsIDB4MzY5OGQ0MGIsIDB4Y2ZhNmY1ODEsIDB4MjhhNTdhZGUsIDB4MjZkYWI3OGUsIDB4YTQzZmFkYmYsIDB4ZTQyYzNhOWQsIDB4MGQ1MDc4OTIsIDB4OWI2YTVmY2MsIDB4NjI1NDdlNDYsIDB4YzJmNjhkMTMsIDB4ZTg5MGQ4YjgsIDB4NWUyZTM5ZjcsIDB4ZjU4MmMzYWYsIDB4YmU5ZjVkODAsIDB4N2M2OWQwOTMsIDB4YTk2ZmQ1MmQsIDB4YjNjZjI1MTIsIDB4M2JjOGFjOTksIDB4YTcxMDE4N2QsIDB4NmVlODljNjMsIDB4N2JkYjNiYmIsIDB4MDljZDI2NzgsIDB4ZjQ2ZTU5MTgsIDB4MDFlYzlhYjcsIDB4YTg4MzRmOWEsIDB4NjVlNjk1NmUsIDB4N2VhYWZmZTYsIDB4MDgyMWJjY2YsIDB4ZTZlZjE1ZTgsIDB4ZDliYWU3OWIsIDB4Y2U0YTZmMzYsIDB4ZDRlYTlmMDksIDB4ZDYyOWIwN2MsIDB4YWYzMWE0YjIsIDB4MzEyYTNmMjMsIDB4MzBjNmE1OTQsIDB4YzAzNWEyNjYsIDB4Mzc3NDRlYmMsIDB4YTZmYzgyY2EsIDB4YjBlMDkwZDAsIDB4MTUzM2E3ZDgsIDB4NGFmMTA0OTgsIDB4Zjc0MWVjZGEsIDB4MGU3ZmNkNTAsIDB4MmYxNzkxZjYsIDB4OGQ3NjRkZDYsIDB4NGQ0M2VmYjAsIDB4NTRjY2FhNGQsIDB4ZGZlNDk2MDQsIDB4ZTM5ZWQxYjUsIDB4MWI0YzZhODgsIDB4YjhjMTJjMWYsIDB4N2Y0NjY1NTEsIDB4MDQ5ZDVlZWEsIDB4NWQwMThjMzUsIDB4NzNmYTg3NzQsIDB4MmVmYjBiNDEsIDB4NWFiMzY3MWQsIDB4NTI5MmRiZDIsIDB4MzNlOTEwNTYsIDB4MTM2ZGQ2NDcsIDB4OGM5YWQ3NjEsIDB4N2EzN2ExMGMsIDB4OGU1OWY4MTQsIDB4ODllYjEzM2MsIDB4ZWVjZWE5MjcsIDB4MzViNzYxYzksIDB4ZWRlMTFjZTUsIDB4M2M3YTQ3YjEsIDB4NTk5Y2QyZGYsIDB4M2Y1NWYyNzMsIDB4NzkxODE0Y2UsIDB4YmY3M2M3MzcsIDB4ZWE1M2Y3Y2QsIDB4NWI1ZmZkYWEsIDB4MTRkZjNkNmYsIDB4ODY3ODQ0ZGIsIDB4ODFjYWFmZjMsIDB4M2ViOTY4YzQsIDB4MmMzODI0MzQsIDB4NWZjMmEzNDAsIDB4NzIxNjFkYzMsIDB4MGNiY2UyMjUsIDB4OGIyODNjNDksIDB4NDFmZjBkOTUsIDB4NzEzOWE4MDEsIDB4ZGUwODBjYjMsIDB4OWNkOGI0ZTQsIDB4OTA2NDU2YzEsIDB4NjE3YmNiODQsIDB4NzBkNTMyYjYsIDB4NzQ0ODZjNWMsIDB4NDJkMGI4NTddO1xuXHQgICAgdmFyIFQ3ID0gWzB4YTc1MDUxZjQsIDB4NjU1MzdlNDEsIDB4YTRjMzFhMTcsIDB4NWU5NjNhMjcsIDB4NmJjYjNiYWIsIDB4NDVmMTFmOWQsIDB4NThhYmFjZmEsIDB4MDM5MzRiZTMsIDB4ZmE1NTIwMzAsIDB4NmRmNmFkNzYsIDB4NzY5MTg4Y2MsIDB4NGMyNWY1MDIsIDB4ZDdmYzRmZTUsIDB4Y2JkN2M1MmEsIDB4NDQ4MDI2MzUsIDB4YTM4ZmI1NjIsIDB4NWE0OWRlYjEsIDB4MWI2NzI1YmEsIDB4MGU5ODQ1ZWEsIDB4YzBlMTVkZmUsIDB4NzUwMmMzMmYsIDB4ZjAxMjgxNGMsIDB4OTdhMzhkNDYsIDB4ZjljNjZiZDMsIDB4NWZlNzAzOGYsIDB4OWM5NTE1OTIsIDB4N2FlYmJmNmQsIDB4NTlkYTk1NTIsIDB4ODMyZGQ0YmUsIDB4MjFkMzU4NzQsIDB4NjkyOTQ5ZTAsIDB4Yzg0NDhlYzksIDB4ODk2YTc1YzIsIDB4Nzk3OGY0OGUsIDB4M2U2Yjk5NTgsIDB4NzFkZDI3YjksIDB4NGZiNmJlZTEsIDB4YWQxN2YwODgsIDB4YWM2NmM5MjAsIDB4M2FiNDdkY2UsIDB4NGExODYzZGYsIDB4MzE4MmU1MWEsIDB4MzM2MDk3NTEsIDB4N2Y0NTYyNTMsIDB4NzdlMGIxNjQsIDB4YWU4NGJiNmIsIDB4YTAxY2ZlODEsIDB4MmI5NGY5MDgsIDB4Njg1ODcwNDgsIDB4ZmQxOThmNDUsIDB4NmM4Nzk0ZGUsIDB4ZjhiNzUyN2IsIDB4ZDMyM2FiNzMsIDB4MDJlMjcyNGIsIDB4OGY1N2UzMWYsIDB4YWIyYTY2NTUsIDB4MjgwN2IyZWIsIDB4YzIwMzJmYjUsIDB4N2I5YTg2YzUsIDB4MDhhNWQzMzcsIDB4ODdmMjMwMjgsIDB4YTViMjIzYmYsIDB4NmFiYTAyMDMsIDB4ODI1Y2VkMTYsIDB4MWMyYjhhY2YsIDB4YjQ5MmE3NzksIDB4ZjJmMGYzMDcsIDB4ZTJhMTRlNjksIDB4ZjRjZDY1ZGEsIDB4YmVkNTA2MDUsIDB4NjIxZmQxMzQsIDB4ZmU4YWM0YTYsIDB4NTM5ZDM0MmUsIDB4NTVhMGEyZjMsIDB4ZTEzMjA1OGEsIDB4ZWI3NWE0ZjYsIDB4ZWMzOTBiODMsIDB4ZWZhYTQwNjAsIDB4OWYwNjVlNzEsIDB4MTA1MWJkNmUsIDB4OGFmOTNlMjEsIDB4MDYzZDk2ZGQsIDB4MDVhZWRkM2UsIDB4YmQ0NjRkZTYsIDB4OGRiNTkxNTQsIDB4NWQwNTcxYzQsIDB4ZDQ2ZjA0MDYsIDB4MTVmZjYwNTAsIDB4ZmIyNDE5OTgsIDB4ZTk5N2Q2YmQsIDB4NDNjYzg5NDAsIDB4OWU3NzY3ZDksIDB4NDJiZGIwZTgsIDB4OGI4ODA3ODksIDB4NWIzOGU3MTksIDB4ZWVkYjc5YzgsIDB4MGE0N2ExN2MsIDB4MGZlOTdjNDIsIDB4MWVjOWY4ODQsIDB4MDAwMDAwMDAsIDB4ODY4MzA5ODAsIDB4ZWQ0ODMyMmIsIDB4NzBhYzFlMTEsIDB4NzI0ZTZjNWEsIDB4ZmZmYmZkMGUsIDB4Mzg1NjBmODUsIDB4ZDUxZTNkYWUsIDB4MzkyNzM2MmQsIDB4ZDk2NDBhMGYsIDB4YTYyMTY4NWMsIDB4NTRkMTliNWIsIDB4MmUzYTI0MzYsIDB4NjdiMTBjMGEsIDB4ZTcwZjkzNTcsIDB4OTZkMmI0ZWUsIDB4OTE5ZTFiOWIsIDB4YzU0ZjgwYzAsIDB4MjBhMjYxZGMsIDB4NGI2OTVhNzcsIDB4MWExNjFjMTIsIDB4YmEwYWUyOTMsIDB4MmFlNWMwYTAsIDB4ZTA0MzNjMjIsIDB4MTcxZDEyMWIsIDB4MGQwYjBlMDksIDB4YzdhZGYyOGIsIDB4YThiOTJkYjYsIDB4YTljODE0MWUsIDB4MTk4NTU3ZjEsIDB4MDc0Y2FmNzUsIDB4ZGRiYmVlOTksIDB4NjBmZGEzN2YsIDB4MjY5ZmY3MDEsIDB4ZjViYzVjNzIsIDB4M2JjNTQ0NjYsIDB4N2UzNDViZmIsIDB4Mjk3NjhiNDMsIDB4YzZkY2NiMjMsIDB4ZmM2OGI2ZWQsIDB4ZjE2M2I4ZTQsIDB4ZGNjYWQ3MzEsIDB4ODUxMDQyNjMsIDB4MjI0MDEzOTcsIDB4MTEyMDg0YzYsIDB4MjQ3ZDg1NGEsIDB4M2RmOGQyYmIsIDB4MzIxMWFlZjksIDB4YTE2ZGM3MjksIDB4MmY0YjFkOWUsIDB4MzBmM2RjYjIsIDB4NTJlYzBkODYsIDB4ZTNkMDc3YzEsIDB4MTY2YzJiYjMsIDB4Yjk5OWE5NzAsIDB4NDhmYTExOTQsIDB4NjQyMjQ3ZTksIDB4OGNjNGE4ZmMsIDB4M2YxYWEwZjAsIDB4MmNkODU2N2QsIDB4OTBlZjIyMzMsIDB4NGVjNzg3NDksIDB4ZDFjMWQ5MzgsIDB4YTJmZThjY2EsIDB4MGIzNjk4ZDQsIDB4ODFjZmE2ZjUsIDB4ZGUyOGE1N2EsIDB4OGUyNmRhYjcsIDB4YmZhNDNmYWQsIDB4OWRlNDJjM2EsIDB4OTIwZDUwNzgsIDB4Y2M5YjZhNWYsIDB4NDY2MjU0N2UsIDB4MTNjMmY2OGQsIDB4YjhlODkwZDgsIDB4Zjc1ZTJlMzksIDB4YWZmNTgyYzMsIDB4ODBiZTlmNWQsIDB4OTM3YzY5ZDAsIDB4MmRhOTZmZDUsIDB4MTJiM2NmMjUsIDB4OTkzYmM4YWMsIDB4N2RhNzEwMTgsIDB4NjM2ZWU4OWMsIDB4YmI3YmRiM2IsIDB4NzgwOWNkMjYsIDB4MThmNDZlNTksIDB4YjcwMWVjOWEsIDB4OWFhODgzNGYsIDB4NmU2NWU2OTUsIDB4ZTY3ZWFhZmYsIDB4Y2YwODIxYmMsIDB4ZThlNmVmMTUsIDB4OWJkOWJhZTcsIDB4MzZjZTRhNmYsIDB4MDlkNGVhOWYsIDB4N2NkNjI5YjAsIDB4YjJhZjMxYTQsIDB4MjMzMTJhM2YsIDB4OTQzMGM2YTUsIDB4NjZjMDM1YTIsIDB4YmMzNzc0NGUsIDB4Y2FhNmZjODIsIDB4ZDBiMGUwOTAsIDB4ZDgxNTMzYTcsIDB4OTg0YWYxMDQsIDB4ZGFmNzQxZWMsIDB4NTAwZTdmY2QsIDB4ZjYyZjE3OTEsIDB4ZDY4ZDc2NGQsIDB4YjA0ZDQzZWYsIDB4NGQ1NGNjYWEsIDB4MDRkZmU0OTYsIDB4YjVlMzllZDEsIDB4ODgxYjRjNmEsIDB4MWZiOGMxMmMsIDB4NTE3ZjQ2NjUsIDB4ZWEwNDlkNWUsIDB4MzU1ZDAxOGMsIDB4NzQ3M2ZhODcsIDB4NDEyZWZiMGIsIDB4MWQ1YWIzNjcsIDB4ZDI1MjkyZGIsIDB4NTYzM2U5MTAsIDB4NDcxMzZkZDYsIDB4NjE4YzlhZDcsIDB4MGM3YTM3YTEsIDB4MTQ4ZTU5ZjgsIDB4M2M4OWViMTMsIDB4MjdlZWNlYTksIDB4YzkzNWI3NjEsIDB4ZTVlZGUxMWMsIDB4YjEzYzdhNDcsIDB4ZGY1OTljZDIsIDB4NzMzZjU1ZjIsIDB4Y2U3OTE4MTQsIDB4MzdiZjczYzcsIDB4Y2RlYTUzZjcsIDB4YWE1YjVmZmQsIDB4NmYxNGRmM2QsIDB4ZGI4Njc4NDQsIDB4ZjM4MWNhYWYsIDB4YzQzZWI5NjgsIDB4MzQyYzM4MjQsIDB4NDA1ZmMyYTMsIDB4YzM3MjE2MWQsIDB4MjUwY2JjZTIsIDB4NDk4YjI4M2MsIDB4OTU0MWZmMGQsIDB4MDE3MTM5YTgsIDB4YjNkZTA4MGMsIDB4ZTQ5Y2Q4YjQsIDB4YzE5MDY0NTYsIDB4ODQ2MTdiY2IsIDB4YjY3MGQ1MzIsIDB4NWM3NDQ4NmMsIDB4NTc0MmQwYjhdO1xuXHQgICAgdmFyIFQ4ID0gWzB4ZjRhNzUwNTEsIDB4NDE2NTUzN2UsIDB4MTdhNGMzMWEsIDB4Mjc1ZTk2M2EsIDB4YWI2YmNiM2IsIDB4OWQ0NWYxMWYsIDB4ZmE1OGFiYWMsIDB4ZTMwMzkzNGIsIDB4MzBmYTU1MjAsIDB4NzY2ZGY2YWQsIDB4Y2M3NjkxODgsIDB4MDI0YzI1ZjUsIDB4ZTVkN2ZjNGYsIDB4MmFjYmQ3YzUsIDB4MzU0NDgwMjYsIDB4NjJhMzhmYjUsIDB4YjE1YTQ5ZGUsIDB4YmExYjY3MjUsIDB4ZWEwZTk4NDUsIDB4ZmVjMGUxNWQsIDB4MmY3NTAyYzMsIDB4NGNmMDEyODEsIDB4NDY5N2EzOGQsIDB4ZDNmOWM2NmIsIDB4OGY1ZmU3MDMsIDB4OTI5Yzk1MTUsIDB4NmQ3YWViYmYsIDB4NTI1OWRhOTUsIDB4YmU4MzJkZDQsIDB4NzQyMWQzNTgsIDB4ZTA2OTI5NDksIDB4YzljODQ0OGUsIDB4YzI4OTZhNzUsIDB4OGU3OTc4ZjQsIDB4NTgzZTZiOTksIDB4Yjk3MWRkMjcsIDB4ZTE0ZmI2YmUsIDB4ODhhZDE3ZjAsIDB4MjBhYzY2YzksIDB4Y2UzYWI0N2QsIDB4ZGY0YTE4NjMsIDB4MWEzMTgyZTUsIDB4NTEzMzYwOTcsIDB4NTM3ZjQ1NjIsIDB4NjQ3N2UwYjEsIDB4NmJhZTg0YmIsIDB4ODFhMDFjZmUsIDB4MDgyYjk0ZjksIDB4NDg2ODU4NzAsIDB4NDVmZDE5OGYsIDB4ZGU2Yzg3OTQsIDB4N2JmOGI3NTIsIDB4NzNkMzIzYWIsIDB4NGIwMmUyNzIsIDB4MWY4ZjU3ZTMsIDB4NTVhYjJhNjYsIDB4ZWIyODA3YjIsIDB4YjVjMjAzMmYsIDB4YzU3YjlhODYsIDB4MzcwOGE1ZDMsIDB4Mjg4N2YyMzAsIDB4YmZhNWIyMjMsIDB4MDM2YWJhMDIsIDB4MTY4MjVjZWQsIDB4Y2YxYzJiOGEsIDB4NzliNDkyYTcsIDB4MDdmMmYwZjMsIDB4NjllMmExNGUsIDB4ZGFmNGNkNjUsIDB4MDViZWQ1MDYsIDB4MzQ2MjFmZDEsIDB4YTZmZThhYzQsIDB4MmU1MzlkMzQsIDB4ZjM1NWEwYTIsIDB4OGFlMTMyMDUsIDB4ZjZlYjc1YTQsIDB4ODNlYzM5MGIsIDB4NjBlZmFhNDAsIDB4NzE5ZjA2NWUsIDB4NmUxMDUxYmQsIDB4MjE4YWY5M2UsIDB4ZGQwNjNkOTYsIDB4M2UwNWFlZGQsIDB4ZTZiZDQ2NGQsIDB4NTQ4ZGI1OTEsIDB4YzQ1ZDA1NzEsIDB4MDZkNDZmMDQsIDB4NTAxNWZmNjAsIDB4OThmYjI0MTksIDB4YmRlOTk3ZDYsIDB4NDA0M2NjODksIDB4ZDk5ZTc3NjcsIDB4ZTg0MmJkYjAsIDB4ODk4Yjg4MDcsIDB4MTk1YjM4ZTcsIDB4YzhlZWRiNzksIDB4N2MwYTQ3YTEsIDB4NDIwZmU5N2MsIDB4ODQxZWM5ZjgsIDB4MDAwMDAwMDAsIDB4ODA4NjgzMDksIDB4MmJlZDQ4MzIsIDB4MTE3MGFjMWUsIDB4NWE3MjRlNmMsIDB4MGVmZmZiZmQsIDB4ODUzODU2MGYsIDB4YWVkNTFlM2QsIDB4MmQzOTI3MzYsIDB4MGZkOTY0MGEsIDB4NWNhNjIxNjgsIDB4NWI1NGQxOWIsIDB4MzYyZTNhMjQsIDB4MGE2N2IxMGMsIDB4NTdlNzBmOTMsIDB4ZWU5NmQyYjQsIDB4OWI5MTllMWIsIDB4YzBjNTRmODAsIDB4ZGMyMGEyNjEsIDB4Nzc0YjY5NWEsIDB4MTIxYTE2MWMsIDB4OTNiYTBhZTIsIDB4YTAyYWU1YzAsIDB4MjJlMDQzM2MsIDB4MWIxNzFkMTIsIDB4MDkwZDBiMGUsIDB4OGJjN2FkZjIsIDB4YjZhOGI5MmQsIDB4MWVhOWM4MTQsIDB4ZjExOTg1NTcsIDB4NzUwNzRjYWYsIDB4OTlkZGJiZWUsIDB4N2Y2MGZkYTMsIDB4MDEyNjlmZjcsIDB4NzJmNWJjNWMsIDB4NjYzYmM1NDQsIDB4ZmI3ZTM0NWIsIDB4NDMyOTc2OGIsIDB4MjNjNmRjY2IsIDB4ZWRmYzY4YjYsIDB4ZTRmMTYzYjgsIDB4MzFkY2NhZDcsIDB4NjM4NTEwNDIsIDB4OTcyMjQwMTMsIDB4YzYxMTIwODQsIDB4NGEyNDdkODUsIDB4YmIzZGY4ZDIsIDB4ZjkzMjExYWUsIDB4MjlhMTZkYzcsIDB4OWUyZjRiMWQsIDB4YjIzMGYzZGMsIDB4ODY1MmVjMGQsIDB4YzFlM2QwNzcsIDB4YjMxNjZjMmIsIDB4NzBiOTk5YTksIDB4OTQ0OGZhMTEsIDB4ZTk2NDIyNDcsIDB4ZmM4Y2M0YTgsIDB4ZjAzZjFhYTAsIDB4N2QyY2Q4NTYsIDB4MzM5MGVmMjIsIDB4NDk0ZWM3ODcsIDB4MzhkMWMxZDksIDB4Y2FhMmZlOGMsIDB4ZDQwYjM2OTgsIDB4ZjU4MWNmYTYsIDB4N2FkZTI4YTUsIDB4Yjc4ZTI2ZGEsIDB4YWRiZmE0M2YsIDB4M2E5ZGU0MmMsIDB4Nzg5MjBkNTAsIDB4NWZjYzliNmEsIDB4N2U0NjYyNTQsIDB4OGQxM2MyZjYsIDB4ZDhiOGU4OTAsIDB4MzlmNzVlMmUsIDB4YzNhZmY1ODIsIDB4NWQ4MGJlOWYsIDB4ZDA5MzdjNjksIDB4ZDUyZGE5NmYsIDB4MjUxMmIzY2YsIDB4YWM5OTNiYzgsIDB4MTg3ZGE3MTAsIDB4OWM2MzZlZTgsIDB4M2JiYjdiZGIsIDB4MjY3ODA5Y2QsIDB4NTkxOGY0NmUsIDB4OWFiNzAxZWMsIDB4NGY5YWE4ODMsIDB4OTU2ZTY1ZTYsIDB4ZmZlNjdlYWEsIDB4YmNjZjA4MjEsIDB4MTVlOGU2ZWYsIDB4ZTc5YmQ5YmEsIDB4NmYzNmNlNGEsIDB4OWYwOWQ0ZWEsIDB4YjA3Y2Q2MjksIDB4YTRiMmFmMzEsIDB4M2YyMzMxMmEsIDB4YTU5NDMwYzYsIDB4YTI2NmMwMzUsIDB4NGViYzM3NzQsIDB4ODJjYWE2ZmMsIDB4OTBkMGIwZTAsIDB4YTdkODE1MzMsIDB4MDQ5ODRhZjEsIDB4ZWNkYWY3NDEsIDB4Y2Q1MDBlN2YsIDB4OTFmNjJmMTcsIDB4NGRkNjhkNzYsIDB4ZWZiMDRkNDMsIDB4YWE0ZDU0Y2MsIDB4OTYwNGRmZTQsIDB4ZDFiNWUzOWUsIDB4NmE4ODFiNGMsIDB4MmMxZmI4YzEsIDB4NjU1MTdmNDYsIDB4NWVlYTA0OWQsIDB4OGMzNTVkMDEsIDB4ODc3NDczZmEsIDB4MGI0MTJlZmIsIDB4NjcxZDVhYjMsIDB4ZGJkMjUyOTIsIDB4MTA1NjMzZTksIDB4ZDY0NzEzNmQsIDB4ZDc2MThjOWEsIDB4YTEwYzdhMzcsIDB4ZjgxNDhlNTksIDB4MTMzYzg5ZWIsIDB4YTkyN2VlY2UsIDB4NjFjOTM1YjcsIDB4MWNlNWVkZTEsIDB4NDdiMTNjN2EsIDB4ZDJkZjU5OWMsIDB4ZjI3MzNmNTUsIDB4MTRjZTc5MTgsIDB4YzczN2JmNzMsIDB4ZjdjZGVhNTMsIDB4ZmRhYTViNWYsIDB4M2Q2ZjE0ZGYsIDB4NDRkYjg2NzgsIDB4YWZmMzgxY2EsIDB4NjhjNDNlYjksIDB4MjQzNDJjMzgsIDB4YTM0MDVmYzIsIDB4MWRjMzcyMTYsIDB4ZTIyNTBjYmMsIDB4M2M0OThiMjgsIDB4MGQ5NTQxZmYsIDB4YTgwMTcxMzksIDB4MGNiM2RlMDgsIDB4YjRlNDljZDgsIDB4NTZjMTkwNjQsIDB4Y2I4NDYxN2IsIDB4MzJiNjcwZDUsIDB4NmM1Yzc0NDgsIDB4Yjg1NzQyZDBdO1xuXG5cdCAgICAvLyBUcmFuc2Zvcm1hdGlvbnMgZm9yIGRlY3J5cHRpb24ga2V5IGV4cGFuc2lvblxuXHQgICAgdmFyIFUxID0gWzB4MDAwMDAwMDAsIDB4MGUwOTBkMGIsIDB4MWMxMjFhMTYsIDB4MTIxYjE3MWQsIDB4MzgyNDM0MmMsIDB4MzYyZDM5MjcsIDB4MjQzNjJlM2EsIDB4MmEzZjIzMzEsIDB4NzA0ODY4NTgsIDB4N2U0MTY1NTMsIDB4NmM1YTcyNGUsIDB4NjI1MzdmNDUsIDB4NDg2YzVjNzQsIDB4NDY2NTUxN2YsIDB4NTQ3ZTQ2NjIsIDB4NWE3NzRiNjksIDB4ZTA5MGQwYjAsIDB4ZWU5OWRkYmIsIDB4ZmM4MmNhYTYsIDB4ZjI4YmM3YWQsIDB4ZDhiNGU0OWMsIDB4ZDZiZGU5OTcsIDB4YzRhNmZlOGEsIDB4Y2FhZmYzODEsIDB4OTBkOGI4ZTgsIDB4OWVkMWI1ZTMsIDB4OGNjYWEyZmUsIDB4ODJjM2FmZjUsIDB4YThmYzhjYzQsIDB4YTZmNTgxY2YsIDB4YjRlZTk2ZDIsIDB4YmFlNzliZDksIDB4ZGIzYmJiN2IsIDB4ZDUzMmI2NzAsIDB4YzcyOWExNmQsIDB4YzkyMGFjNjYsIDB4ZTMxZjhmNTcsIDB4ZWQxNjgyNWMsIDB4ZmYwZDk1NDEsIDB4ZjEwNDk4NGEsIDB4YWI3M2QzMjMsIDB4YTU3YWRlMjgsIDB4Yjc2MWM5MzUsIDB4Yjk2OGM0M2UsIDB4OTM1N2U3MGYsIDB4OWQ1ZWVhMDQsIDB4OGY0NWZkMTksIDB4ODE0Y2YwMTIsIDB4M2JhYjZiY2IsIDB4MzVhMjY2YzAsIDB4MjdiOTcxZGQsIDB4MjliMDdjZDYsIDB4MDM4ZjVmZTcsIDB4MGQ4NjUyZWMsIDB4MWY5ZDQ1ZjEsIDB4MTE5NDQ4ZmEsIDB4NGJlMzAzOTMsIDB4NDVlYTBlOTgsIDB4NTdmMTE5ODUsIDB4NTlmODE0OGUsIDB4NzNjNzM3YmYsIDB4N2RjZTNhYjQsIDB4NmZkNTJkYTksIDB4NjFkYzIwYTIsIDB4YWQ3NjZkZjYsIDB4YTM3ZjYwZmQsIDB4YjE2NDc3ZTAsIDB4YmY2ZDdhZWIsIDB4OTU1MjU5ZGEsIDB4OWI1YjU0ZDEsIDB4ODk0MDQzY2MsIDB4ODc0OTRlYzcsIDB4ZGQzZTA1YWUsIDB4ZDMzNzA4YTUsIDB4YzEyYzFmYjgsIDB4Y2YyNTEyYjMsIDB4ZTUxYTMxODIsIDB4ZWIxMzNjODksIDB4ZjkwODJiOTQsIDB4ZjcwMTI2OWYsIDB4NGRlNmJkNDYsIDB4NDNlZmIwNGQsIDB4NTFmNGE3NTAsIDB4NWZmZGFhNWIsIDB4NzVjMjg5NmEsIDB4N2JjYjg0NjEsIDB4NjlkMDkzN2MsIDB4NjdkOTllNzcsIDB4M2RhZWQ1MWUsIDB4MzNhN2Q4MTUsIDB4MjFiY2NmMDgsIDB4MmZiNWMyMDMsIDB4MDU4YWUxMzIsIDB4MGI4M2VjMzksIDB4MTk5OGZiMjQsIDB4MTc5MWY2MmYsIDB4NzY0ZGQ2OGQsIDB4Nzg0NGRiODYsIDB4NmE1ZmNjOWIsIDB4NjQ1NmMxOTAsIDB4NGU2OWUyYTEsIDB4NDA2MGVmYWEsIDB4NTI3YmY4YjcsIDB4NWM3MmY1YmMsIDB4MDYwNWJlZDUsIDB4MDgwY2IzZGUsIDB4MWExN2E0YzMsIDB4MTQxZWE5YzgsIDB4M2UyMThhZjksIDB4MzAyODg3ZjIsIDB4MjIzMzkwZWYsIDB4MmMzYTlkZTQsIDB4OTZkZDA2M2QsIDB4OThkNDBiMzYsIDB4OGFjZjFjMmIsIDB4ODRjNjExMjAsIDB4YWVmOTMyMTEsIDB4YTBmMDNmMWEsIDB4YjJlYjI4MDcsIDB4YmNlMjI1MGMsIDB4ZTY5NTZlNjUsIDB4ZTg5YzYzNmUsIDB4ZmE4Nzc0NzMsIDB4ZjQ4ZTc5NzgsIDB4ZGViMTVhNDksIDB4ZDBiODU3NDIsIDB4YzJhMzQwNWYsIDB4Y2NhYTRkNTQsIDB4NDFlY2RhZjcsIDB4NGZlNWQ3ZmMsIDB4NWRmZWMwZTEsIDB4NTNmN2NkZWEsIDB4NzljOGVlZGIsIDB4NzdjMWUzZDAsIDB4NjVkYWY0Y2QsIDB4NmJkM2Y5YzYsIDB4MzFhNGIyYWYsIDB4M2ZhZGJmYTQsIDB4MmRiNmE4YjksIDB4MjNiZmE1YjIsIDB4MDk4MDg2ODMsIDB4MDc4OThiODgsIDB4MTU5MjljOTUsIDB4MWI5YjkxOWUsIDB4YTE3YzBhNDcsIDB4YWY3NTA3NGMsIDB4YmQ2ZTEwNTEsIDB4YjM2NzFkNWEsIDB4OTk1ODNlNmIsIDB4OTc1MTMzNjAsIDB4ODU0YTI0N2QsIDB4OGI0MzI5NzYsIDB4ZDEzNDYyMWYsIDB4ZGYzZDZmMTQsIDB4Y2QyNjc4MDksIDB4YzMyZjc1MDIsIDB4ZTkxMDU2MzMsIDB4ZTcxOTViMzgsIDB4ZjUwMjRjMjUsIDB4ZmIwYjQxMmUsIDB4OWFkNzYxOGMsIDB4OTRkZTZjODcsIDB4ODZjNTdiOWEsIDB4ODhjYzc2OTEsIDB4YTJmMzU1YTAsIDB4YWNmYTU4YWIsIDB4YmVlMTRmYjYsIDB4YjBlODQyYmQsIDB4ZWE5ZjA5ZDQsIDB4ZTQ5NjA0ZGYsIDB4ZjY4ZDEzYzIsIDB4Zjg4NDFlYzksIDB4ZDJiYjNkZjgsIDB4ZGNiMjMwZjMsIDB4Y2VhOTI3ZWUsIDB4YzBhMDJhZTUsIDB4N2E0N2IxM2MsIDB4NzQ0ZWJjMzcsIDB4NjY1NWFiMmEsIDB4Njg1Y2E2MjEsIDB4NDI2Mzg1MTAsIDB4NGM2YTg4MWIsIDB4NWU3MTlmMDYsIDB4NTA3ODkyMGQsIDB4MGEwZmQ5NjQsIDB4MDQwNmQ0NmYsIDB4MTYxZGMzNzIsIDB4MTgxNGNlNzksIDB4MzIyYmVkNDgsIDB4M2MyMmUwNDMsIDB4MmUzOWY3NWUsIDB4MjAzMGZhNTUsIDB4ZWM5YWI3MDEsIDB4ZTI5M2JhMGEsIDB4ZjA4OGFkMTcsIDB4ZmU4MWEwMWMsIDB4ZDRiZTgzMmQsIDB4ZGFiNzhlMjYsIDB4YzhhYzk5M2IsIDB4YzZhNTk0MzAsIDB4OWNkMmRmNTksIDB4OTJkYmQyNTIsIDB4ODBjMGM1NGYsIDB4OGVjOWM4NDQsIDB4YTRmNmViNzUsIDB4YWFmZmU2N2UsIDB4YjhlNGYxNjMsIDB4YjZlZGZjNjgsIDB4MGMwYTY3YjEsIDB4MDIwMzZhYmEsIDB4MTAxODdkYTcsIDB4MWUxMTcwYWMsIDB4MzQyZTUzOWQsIDB4M2EyNzVlOTYsIDB4MjgzYzQ5OGIsIDB4MjYzNTQ0ODAsIDB4N2M0MjBmZTksIDB4NzI0YjAyZTIsIDB4NjA1MDE1ZmYsIDB4NmU1OTE4ZjQsIDB4NDQ2NjNiYzUsIDB4NGE2ZjM2Y2UsIDB4NTg3NDIxZDMsIDB4NTY3ZDJjZDgsIDB4MzdhMTBjN2EsIDB4MzlhODAxNzEsIDB4MmJiMzE2NmMsIDB4MjViYTFiNjcsIDB4MGY4NTM4NTYsIDB4MDE4YzM1NWQsIDB4MTM5NzIyNDAsIDB4MWQ5ZTJmNGIsIDB4NDdlOTY0MjIsIDB4NDllMDY5MjksIDB4NWJmYjdlMzQsIDB4NTVmMjczM2YsIDB4N2ZjZDUwMGUsIDB4NzFjNDVkMDUsIDB4NjNkZjRhMTgsIDB4NmRkNjQ3MTMsIDB4ZDczMWRjY2EsIDB4ZDkzOGQxYzEsIDB4Y2IyM2M2ZGMsIDB4YzUyYWNiZDcsIDB4ZWYxNWU4ZTYsIDB4ZTExY2U1ZWQsIDB4ZjMwN2YyZjAsIDB4ZmQwZWZmZmIsIDB4YTc3OWI0OTIsIDB4YTk3MGI5OTksIDB4YmI2YmFlODQsIDB4YjU2MmEzOGYsIDB4OWY1ZDgwYmUsIDB4OTE1NDhkYjUsIDB4ODM0ZjlhYTgsIDB4OGQ0Njk3YTNdO1xuXHQgICAgdmFyIFUyID0gWzB4MDAwMDAwMDAsIDB4MGIwZTA5MGQsIDB4MTYxYzEyMWEsIDB4MWQxMjFiMTcsIDB4MmMzODI0MzQsIDB4MjczNjJkMzksIDB4M2EyNDM2MmUsIDB4MzEyYTNmMjMsIDB4NTg3MDQ4NjgsIDB4NTM3ZTQxNjUsIDB4NGU2YzVhNzIsIDB4NDU2MjUzN2YsIDB4NzQ0ODZjNWMsIDB4N2Y0NjY1NTEsIDB4NjI1NDdlNDYsIDB4Njk1YTc3NGIsIDB4YjBlMDkwZDAsIDB4YmJlZTk5ZGQsIDB4YTZmYzgyY2EsIDB4YWRmMjhiYzcsIDB4OWNkOGI0ZTQsIDB4OTdkNmJkZTksIDB4OGFjNGE2ZmUsIDB4ODFjYWFmZjMsIDB4ZTg5MGQ4YjgsIDB4ZTM5ZWQxYjUsIDB4ZmU4Y2NhYTIsIDB4ZjU4MmMzYWYsIDB4YzRhOGZjOGMsIDB4Y2ZhNmY1ODEsIDB4ZDJiNGVlOTYsIDB4ZDliYWU3OWIsIDB4N2JkYjNiYmIsIDB4NzBkNTMyYjYsIDB4NmRjNzI5YTEsIDB4NjZjOTIwYWMsIDB4NTdlMzFmOGYsIDB4NWNlZDE2ODIsIDB4NDFmZjBkOTUsIDB4NGFmMTA0OTgsIDB4MjNhYjczZDMsIDB4MjhhNTdhZGUsIDB4MzViNzYxYzksIDB4M2ViOTY4YzQsIDB4MGY5MzU3ZTcsIDB4MDQ5ZDVlZWEsIDB4MTk4ZjQ1ZmQsIDB4MTI4MTRjZjAsIDB4Y2IzYmFiNmIsIDB4YzAzNWEyNjYsIDB4ZGQyN2I5NzEsIDB4ZDYyOWIwN2MsIDB4ZTcwMzhmNWYsIDB4ZWMwZDg2NTIsIDB4ZjExZjlkNDUsIDB4ZmExMTk0NDgsIDB4OTM0YmUzMDMsIDB4OTg0NWVhMGUsIDB4ODU1N2YxMTksIDB4OGU1OWY4MTQsIDB4YmY3M2M3MzcsIDB4YjQ3ZGNlM2EsIDB4YTk2ZmQ1MmQsIDB4YTI2MWRjMjAsIDB4ZjZhZDc2NmQsIDB4ZmRhMzdmNjAsIDB4ZTBiMTY0NzcsIDB4ZWJiZjZkN2EsIDB4ZGE5NTUyNTksIDB4ZDE5YjViNTQsIDB4Y2M4OTQwNDMsIDB4Yzc4NzQ5NGUsIDB4YWVkZDNlMDUsIDB4YTVkMzM3MDgsIDB4YjhjMTJjMWYsIDB4YjNjZjI1MTIsIDB4ODJlNTFhMzEsIDB4ODllYjEzM2MsIDB4OTRmOTA4MmIsIDB4OWZmNzAxMjYsIDB4NDY0ZGU2YmQsIDB4NGQ0M2VmYjAsIDB4NTA1MWY0YTcsIDB4NWI1ZmZkYWEsIDB4NmE3NWMyODksIDB4NjE3YmNiODQsIDB4N2M2OWQwOTMsIDB4Nzc2N2Q5OWUsIDB4MWUzZGFlZDUsIDB4MTUzM2E3ZDgsIDB4MDgyMWJjY2YsIDB4MDMyZmI1YzIsIDB4MzIwNThhZTEsIDB4MzkwYjgzZWMsIDB4MjQxOTk4ZmIsIDB4MmYxNzkxZjYsIDB4OGQ3NjRkZDYsIDB4ODY3ODQ0ZGIsIDB4OWI2YTVmY2MsIDB4OTA2NDU2YzEsIDB4YTE0ZTY5ZTIsIDB4YWE0MDYwZWYsIDB4Yjc1MjdiZjgsIDB4YmM1YzcyZjUsIDB4ZDUwNjA1YmUsIDB4ZGUwODBjYjMsIDB4YzMxYTE3YTQsIDB4YzgxNDFlYTksIDB4ZjkzZTIxOGEsIDB4ZjIzMDI4ODcsIDB4ZWYyMjMzOTAsIDB4ZTQyYzNhOWQsIDB4M2Q5NmRkMDYsIDB4MzY5OGQ0MGIsIDB4MmI4YWNmMWMsIDB4MjA4NGM2MTEsIDB4MTFhZWY5MzIsIDB4MWFhMGYwM2YsIDB4MDdiMmViMjgsIDB4MGNiY2UyMjUsIDB4NjVlNjk1NmUsIDB4NmVlODljNjMsIDB4NzNmYTg3NzQsIDB4NzhmNDhlNzksIDB4NDlkZWIxNWEsIDB4NDJkMGI4NTcsIDB4NWZjMmEzNDAsIDB4NTRjY2FhNGQsIDB4Zjc0MWVjZGEsIDB4ZmM0ZmU1ZDcsIDB4ZTE1ZGZlYzAsIDB4ZWE1M2Y3Y2QsIDB4ZGI3OWM4ZWUsIDB4ZDA3N2MxZTMsIDB4Y2Q2NWRhZjQsIDB4YzY2YmQzZjksIDB4YWYzMWE0YjIsIDB4YTQzZmFkYmYsIDB4YjkyZGI2YTgsIDB4YjIyM2JmYTUsIDB4ODMwOTgwODYsIDB4ODgwNzg5OGIsIDB4OTUxNTkyOWMsIDB4OWUxYjliOTEsIDB4NDdhMTdjMGEsIDB4NGNhZjc1MDcsIDB4NTFiZDZlMTAsIDB4NWFiMzY3MWQsIDB4NmI5OTU4M2UsIDB4NjA5NzUxMzMsIDB4N2Q4NTRhMjQsIDB4NzY4YjQzMjksIDB4MWZkMTM0NjIsIDB4MTRkZjNkNmYsIDB4MDljZDI2NzgsIDB4MDJjMzJmNzUsIDB4MzNlOTEwNTYsIDB4MzhlNzE5NWIsIDB4MjVmNTAyNGMsIDB4MmVmYjBiNDEsIDB4OGM5YWQ3NjEsIDB4ODc5NGRlNmMsIDB4OWE4NmM1N2IsIDB4OTE4OGNjNzYsIDB4YTBhMmYzNTUsIDB4YWJhY2ZhNTgsIDB4YjZiZWUxNGYsIDB4YmRiMGU4NDIsIDB4ZDRlYTlmMDksIDB4ZGZlNDk2MDQsIDB4YzJmNjhkMTMsIDB4YzlmODg0MWUsIDB4ZjhkMmJiM2QsIDB4ZjNkY2IyMzAsIDB4ZWVjZWE5MjcsIDB4ZTVjMGEwMmEsIDB4M2M3YTQ3YjEsIDB4Mzc3NDRlYmMsIDB4MmE2NjU1YWIsIDB4MjE2ODVjYTYsIDB4MTA0MjYzODUsIDB4MWI0YzZhODgsIDB4MDY1ZTcxOWYsIDB4MGQ1MDc4OTIsIDB4NjQwYTBmZDksIDB4NmYwNDA2ZDQsIDB4NzIxNjFkYzMsIDB4NzkxODE0Y2UsIDB4NDgzMjJiZWQsIDB4NDMzYzIyZTAsIDB4NWUyZTM5ZjcsIDB4NTUyMDMwZmEsIDB4MDFlYzlhYjcsIDB4MGFlMjkzYmEsIDB4MTdmMDg4YWQsIDB4MWNmZTgxYTAsIDB4MmRkNGJlODMsIDB4MjZkYWI3OGUsIDB4M2JjOGFjOTksIDB4MzBjNmE1OTQsIDB4NTk5Y2QyZGYsIDB4NTI5MmRiZDIsIDB4NGY4MGMwYzUsIDB4NDQ4ZWM5YzgsIDB4NzVhNGY2ZWIsIDB4N2VhYWZmZTYsIDB4NjNiOGU0ZjEsIDB4NjhiNmVkZmMsIDB4YjEwYzBhNjcsIDB4YmEwMjAzNmEsIDB4YTcxMDE4N2QsIDB4YWMxZTExNzAsIDB4OWQzNDJlNTMsIDB4OTYzYTI3NWUsIDB4OGIyODNjNDksIDB4ODAyNjM1NDQsIDB4ZTk3YzQyMGYsIDB4ZTI3MjRiMDIsIDB4ZmY2MDUwMTUsIDB4ZjQ2ZTU5MTgsIDB4YzU0NDY2M2IsIDB4Y2U0YTZmMzYsIDB4ZDM1ODc0MjEsIDB4ZDg1NjdkMmMsIDB4N2EzN2ExMGMsIDB4NzEzOWE4MDEsIDB4NmMyYmIzMTYsIDB4NjcyNWJhMWIsIDB4NTYwZjg1MzgsIDB4NWQwMThjMzUsIDB4NDAxMzk3MjIsIDB4NGIxZDllMmYsIDB4MjI0N2U5NjQsIDB4Mjk0OWUwNjksIDB4MzQ1YmZiN2UsIDB4M2Y1NWYyNzMsIDB4MGU3ZmNkNTAsIDB4MDU3MWM0NWQsIDB4MTg2M2RmNGEsIDB4MTM2ZGQ2NDcsIDB4Y2FkNzMxZGMsIDB4YzFkOTM4ZDEsIDB4ZGNjYjIzYzYsIDB4ZDdjNTJhY2IsIDB4ZTZlZjE1ZTgsIDB4ZWRlMTFjZTUsIDB4ZjBmMzA3ZjIsIDB4ZmJmZDBlZmYsIDB4OTJhNzc5YjQsIDB4OTlhOTcwYjksIDB4ODRiYjZiYWUsIDB4OGZiNTYyYTMsIDB4YmU5ZjVkODAsIDB4YjU5MTU0OGQsIDB4YTg4MzRmOWEsIDB4YTM4ZDQ2OTddO1xuXHQgICAgdmFyIFUzID0gWzB4MDAwMDAwMDAsIDB4MGQwYjBlMDksIDB4MWExNjFjMTIsIDB4MTcxZDEyMWIsIDB4MzQyYzM4MjQsIDB4MzkyNzM2MmQsIDB4MmUzYTI0MzYsIDB4MjMzMTJhM2YsIDB4Njg1ODcwNDgsIDB4NjU1MzdlNDEsIDB4NzI0ZTZjNWEsIDB4N2Y0NTYyNTMsIDB4NWM3NDQ4NmMsIDB4NTE3ZjQ2NjUsIDB4NDY2MjU0N2UsIDB4NGI2OTVhNzcsIDB4ZDBiMGUwOTAsIDB4ZGRiYmVlOTksIDB4Y2FhNmZjODIsIDB4YzdhZGYyOGIsIDB4ZTQ5Y2Q4YjQsIDB4ZTk5N2Q2YmQsIDB4ZmU4YWM0YTYsIDB4ZjM4MWNhYWYsIDB4YjhlODkwZDgsIDB4YjVlMzllZDEsIDB4YTJmZThjY2EsIDB4YWZmNTgyYzMsIDB4OGNjNGE4ZmMsIDB4ODFjZmE2ZjUsIDB4OTZkMmI0ZWUsIDB4OWJkOWJhZTcsIDB4YmI3YmRiM2IsIDB4YjY3MGQ1MzIsIDB4YTE2ZGM3MjksIDB4YWM2NmM5MjAsIDB4OGY1N2UzMWYsIDB4ODI1Y2VkMTYsIDB4OTU0MWZmMGQsIDB4OTg0YWYxMDQsIDB4ZDMyM2FiNzMsIDB4ZGUyOGE1N2EsIDB4YzkzNWI3NjEsIDB4YzQzZWI5NjgsIDB4ZTcwZjkzNTcsIDB4ZWEwNDlkNWUsIDB4ZmQxOThmNDUsIDB4ZjAxMjgxNGMsIDB4NmJjYjNiYWIsIDB4NjZjMDM1YTIsIDB4NzFkZDI3YjksIDB4N2NkNjI5YjAsIDB4NWZlNzAzOGYsIDB4NTJlYzBkODYsIDB4NDVmMTFmOWQsIDB4NDhmYTExOTQsIDB4MDM5MzRiZTMsIDB4MGU5ODQ1ZWEsIDB4MTk4NTU3ZjEsIDB4MTQ4ZTU5ZjgsIDB4MzdiZjczYzcsIDB4M2FiNDdkY2UsIDB4MmRhOTZmZDUsIDB4MjBhMjYxZGMsIDB4NmRmNmFkNzYsIDB4NjBmZGEzN2YsIDB4NzdlMGIxNjQsIDB4N2FlYmJmNmQsIDB4NTlkYTk1NTIsIDB4NTRkMTliNWIsIDB4NDNjYzg5NDAsIDB4NGVjNzg3NDksIDB4MDVhZWRkM2UsIDB4MDhhNWQzMzcsIDB4MWZiOGMxMmMsIDB4MTJiM2NmMjUsIDB4MzE4MmU1MWEsIDB4M2M4OWViMTMsIDB4MmI5NGY5MDgsIDB4MjY5ZmY3MDEsIDB4YmQ0NjRkZTYsIDB4YjA0ZDQzZWYsIDB4YTc1MDUxZjQsIDB4YWE1YjVmZmQsIDB4ODk2YTc1YzIsIDB4ODQ2MTdiY2IsIDB4OTM3YzY5ZDAsIDB4OWU3NzY3ZDksIDB4ZDUxZTNkYWUsIDB4ZDgxNTMzYTcsIDB4Y2YwODIxYmMsIDB4YzIwMzJmYjUsIDB4ZTEzMjA1OGEsIDB4ZWMzOTBiODMsIDB4ZmIyNDE5OTgsIDB4ZjYyZjE3OTEsIDB4ZDY4ZDc2NGQsIDB4ZGI4Njc4NDQsIDB4Y2M5YjZhNWYsIDB4YzE5MDY0NTYsIDB4ZTJhMTRlNjksIDB4ZWZhYTQwNjAsIDB4ZjhiNzUyN2IsIDB4ZjViYzVjNzIsIDB4YmVkNTA2MDUsIDB4YjNkZTA4MGMsIDB4YTRjMzFhMTcsIDB4YTljODE0MWUsIDB4OGFmOTNlMjEsIDB4ODdmMjMwMjgsIDB4OTBlZjIyMzMsIDB4OWRlNDJjM2EsIDB4MDYzZDk2ZGQsIDB4MGIzNjk4ZDQsIDB4MWMyYjhhY2YsIDB4MTEyMDg0YzYsIDB4MzIxMWFlZjksIDB4M2YxYWEwZjAsIDB4MjgwN2IyZWIsIDB4MjUwY2JjZTIsIDB4NmU2NWU2OTUsIDB4NjM2ZWU4OWMsIDB4NzQ3M2ZhODcsIDB4Nzk3OGY0OGUsIDB4NWE0OWRlYjEsIDB4NTc0MmQwYjgsIDB4NDA1ZmMyYTMsIDB4NGQ1NGNjYWEsIDB4ZGFmNzQxZWMsIDB4ZDdmYzRmZTUsIDB4YzBlMTVkZmUsIDB4Y2RlYTUzZjcsIDB4ZWVkYjc5YzgsIDB4ZTNkMDc3YzEsIDB4ZjRjZDY1ZGEsIDB4ZjljNjZiZDMsIDB4YjJhZjMxYTQsIDB4YmZhNDNmYWQsIDB4YThiOTJkYjYsIDB4YTViMjIzYmYsIDB4ODY4MzA5ODAsIDB4OGI4ODA3ODksIDB4OWM5NTE1OTIsIDB4OTE5ZTFiOWIsIDB4MGE0N2ExN2MsIDB4MDc0Y2FmNzUsIDB4MTA1MWJkNmUsIDB4MWQ1YWIzNjcsIDB4M2U2Yjk5NTgsIDB4MzM2MDk3NTEsIDB4MjQ3ZDg1NGEsIDB4Mjk3NjhiNDMsIDB4NjIxZmQxMzQsIDB4NmYxNGRmM2QsIDB4NzgwOWNkMjYsIDB4NzUwMmMzMmYsIDB4NTYzM2U5MTAsIDB4NWIzOGU3MTksIDB4NGMyNWY1MDIsIDB4NDEyZWZiMGIsIDB4NjE4YzlhZDcsIDB4NmM4Nzk0ZGUsIDB4N2I5YTg2YzUsIDB4NzY5MTg4Y2MsIDB4NTVhMGEyZjMsIDB4NThhYmFjZmEsIDB4NGZiNmJlZTEsIDB4NDJiZGIwZTgsIDB4MDlkNGVhOWYsIDB4MDRkZmU0OTYsIDB4MTNjMmY2OGQsIDB4MWVjOWY4ODQsIDB4M2RmOGQyYmIsIDB4MzBmM2RjYjIsIDB4MjdlZWNlYTksIDB4MmFlNWMwYTAsIDB4YjEzYzdhNDcsIDB4YmMzNzc0NGUsIDB4YWIyYTY2NTUsIDB4YTYyMTY4NWMsIDB4ODUxMDQyNjMsIDB4ODgxYjRjNmEsIDB4OWYwNjVlNzEsIDB4OTIwZDUwNzgsIDB4ZDk2NDBhMGYsIDB4ZDQ2ZjA0MDYsIDB4YzM3MjE2MWQsIDB4Y2U3OTE4MTQsIDB4ZWQ0ODMyMmIsIDB4ZTA0MzNjMjIsIDB4Zjc1ZTJlMzksIDB4ZmE1NTIwMzAsIDB4YjcwMWVjOWEsIDB4YmEwYWUyOTMsIDB4YWQxN2YwODgsIDB4YTAxY2ZlODEsIDB4ODMyZGQ0YmUsIDB4OGUyNmRhYjcsIDB4OTkzYmM4YWMsIDB4OTQzMGM2YTUsIDB4ZGY1OTljZDIsIDB4ZDI1MjkyZGIsIDB4YzU0ZjgwYzAsIDB4Yzg0NDhlYzksIDB4ZWI3NWE0ZjYsIDB4ZTY3ZWFhZmYsIDB4ZjE2M2I4ZTQsIDB4ZmM2OGI2ZWQsIDB4NjdiMTBjMGEsIDB4NmFiYTAyMDMsIDB4N2RhNzEwMTgsIDB4NzBhYzFlMTEsIDB4NTM5ZDM0MmUsIDB4NWU5NjNhMjcsIDB4NDk4YjI4M2MsIDB4NDQ4MDI2MzUsIDB4MGZlOTdjNDIsIDB4MDJlMjcyNGIsIDB4MTVmZjYwNTAsIDB4MThmNDZlNTksIDB4M2JjNTQ0NjYsIDB4MzZjZTRhNmYsIDB4MjFkMzU4NzQsIDB4MmNkODU2N2QsIDB4MGM3YTM3YTEsIDB4MDE3MTM5YTgsIDB4MTY2YzJiYjMsIDB4MWI2NzI1YmEsIDB4Mzg1NjBmODUsIDB4MzU1ZDAxOGMsIDB4MjI0MDEzOTcsIDB4MmY0YjFkOWUsIDB4NjQyMjQ3ZTksIDB4NjkyOTQ5ZTAsIDB4N2UzNDViZmIsIDB4NzMzZjU1ZjIsIDB4NTAwZTdmY2QsIDB4NWQwNTcxYzQsIDB4NGExODYzZGYsIDB4NDcxMzZkZDYsIDB4ZGNjYWQ3MzEsIDB4ZDFjMWQ5MzgsIDB4YzZkY2NiMjMsIDB4Y2JkN2M1MmEsIDB4ZThlNmVmMTUsIDB4ZTVlZGUxMWMsIDB4ZjJmMGYzMDcsIDB4ZmZmYmZkMGUsIDB4YjQ5MmE3NzksIDB4Yjk5OWE5NzAsIDB4YWU4NGJiNmIsIDB4YTM4ZmI1NjIsIDB4ODBiZTlmNWQsIDB4OGRiNTkxNTQsIDB4OWFhODgzNGYsIDB4OTdhMzhkNDZdO1xuXHQgICAgdmFyIFU0ID0gWzB4MDAwMDAwMDAsIDB4MDkwZDBiMGUsIDB4MTIxYTE2MWMsIDB4MWIxNzFkMTIsIDB4MjQzNDJjMzgsIDB4MmQzOTI3MzYsIDB4MzYyZTNhMjQsIDB4M2YyMzMxMmEsIDB4NDg2ODU4NzAsIDB4NDE2NTUzN2UsIDB4NWE3MjRlNmMsIDB4NTM3ZjQ1NjIsIDB4NmM1Yzc0NDgsIDB4NjU1MTdmNDYsIDB4N2U0NjYyNTQsIDB4Nzc0YjY5NWEsIDB4OTBkMGIwZTAsIDB4OTlkZGJiZWUsIDB4ODJjYWE2ZmMsIDB4OGJjN2FkZjIsIDB4YjRlNDljZDgsIDB4YmRlOTk3ZDYsIDB4YTZmZThhYzQsIDB4YWZmMzgxY2EsIDB4ZDhiOGU4OTAsIDB4ZDFiNWUzOWUsIDB4Y2FhMmZlOGMsIDB4YzNhZmY1ODIsIDB4ZmM4Y2M0YTgsIDB4ZjU4MWNmYTYsIDB4ZWU5NmQyYjQsIDB4ZTc5YmQ5YmEsIDB4M2JiYjdiZGIsIDB4MzJiNjcwZDUsIDB4MjlhMTZkYzcsIDB4MjBhYzY2YzksIDB4MWY4ZjU3ZTMsIDB4MTY4MjVjZWQsIDB4MGQ5NTQxZmYsIDB4MDQ5ODRhZjEsIDB4NzNkMzIzYWIsIDB4N2FkZTI4YTUsIDB4NjFjOTM1YjcsIDB4NjhjNDNlYjksIDB4NTdlNzBmOTMsIDB4NWVlYTA0OWQsIDB4NDVmZDE5OGYsIDB4NGNmMDEyODEsIDB4YWI2YmNiM2IsIDB4YTI2NmMwMzUsIDB4Yjk3MWRkMjcsIDB4YjA3Y2Q2MjksIDB4OGY1ZmU3MDMsIDB4ODY1MmVjMGQsIDB4OWQ0NWYxMWYsIDB4OTQ0OGZhMTEsIDB4ZTMwMzkzNGIsIDB4ZWEwZTk4NDUsIDB4ZjExOTg1NTcsIDB4ZjgxNDhlNTksIDB4YzczN2JmNzMsIDB4Y2UzYWI0N2QsIDB4ZDUyZGE5NmYsIDB4ZGMyMGEyNjEsIDB4NzY2ZGY2YWQsIDB4N2Y2MGZkYTMsIDB4NjQ3N2UwYjEsIDB4NmQ3YWViYmYsIDB4NTI1OWRhOTUsIDB4NWI1NGQxOWIsIDB4NDA0M2NjODksIDB4NDk0ZWM3ODcsIDB4M2UwNWFlZGQsIDB4MzcwOGE1ZDMsIDB4MmMxZmI4YzEsIDB4MjUxMmIzY2YsIDB4MWEzMTgyZTUsIDB4MTMzYzg5ZWIsIDB4MDgyYjk0ZjksIDB4MDEyNjlmZjcsIDB4ZTZiZDQ2NGQsIDB4ZWZiMDRkNDMsIDB4ZjRhNzUwNTEsIDB4ZmRhYTViNWYsIDB4YzI4OTZhNzUsIDB4Y2I4NDYxN2IsIDB4ZDA5MzdjNjksIDB4ZDk5ZTc3NjcsIDB4YWVkNTFlM2QsIDB4YTdkODE1MzMsIDB4YmNjZjA4MjEsIDB4YjVjMjAzMmYsIDB4OGFlMTMyMDUsIDB4ODNlYzM5MGIsIDB4OThmYjI0MTksIDB4OTFmNjJmMTcsIDB4NGRkNjhkNzYsIDB4NDRkYjg2NzgsIDB4NWZjYzliNmEsIDB4NTZjMTkwNjQsIDB4NjllMmExNGUsIDB4NjBlZmFhNDAsIDB4N2JmOGI3NTIsIDB4NzJmNWJjNWMsIDB4MDViZWQ1MDYsIDB4MGNiM2RlMDgsIDB4MTdhNGMzMWEsIDB4MWVhOWM4MTQsIDB4MjE4YWY5M2UsIDB4Mjg4N2YyMzAsIDB4MzM5MGVmMjIsIDB4M2E5ZGU0MmMsIDB4ZGQwNjNkOTYsIDB4ZDQwYjM2OTgsIDB4Y2YxYzJiOGEsIDB4YzYxMTIwODQsIDB4ZjkzMjExYWUsIDB4ZjAzZjFhYTAsIDB4ZWIyODA3YjIsIDB4ZTIyNTBjYmMsIDB4OTU2ZTY1ZTYsIDB4OWM2MzZlZTgsIDB4ODc3NDczZmEsIDB4OGU3OTc4ZjQsIDB4YjE1YTQ5ZGUsIDB4Yjg1NzQyZDAsIDB4YTM0MDVmYzIsIDB4YWE0ZDU0Y2MsIDB4ZWNkYWY3NDEsIDB4ZTVkN2ZjNGYsIDB4ZmVjMGUxNWQsIDB4ZjdjZGVhNTMsIDB4YzhlZWRiNzksIDB4YzFlM2QwNzcsIDB4ZGFmNGNkNjUsIDB4ZDNmOWM2NmIsIDB4YTRiMmFmMzEsIDB4YWRiZmE0M2YsIDB4YjZhOGI5MmQsIDB4YmZhNWIyMjMsIDB4ODA4NjgzMDksIDB4ODk4Yjg4MDcsIDB4OTI5Yzk1MTUsIDB4OWI5MTllMWIsIDB4N2MwYTQ3YTEsIDB4NzUwNzRjYWYsIDB4NmUxMDUxYmQsIDB4NjcxZDVhYjMsIDB4NTgzZTZiOTksIDB4NTEzMzYwOTcsIDB4NGEyNDdkODUsIDB4NDMyOTc2OGIsIDB4MzQ2MjFmZDEsIDB4M2Q2ZjE0ZGYsIDB4MjY3ODA5Y2QsIDB4MmY3NTAyYzMsIDB4MTA1NjMzZTksIDB4MTk1YjM4ZTcsIDB4MDI0YzI1ZjUsIDB4MGI0MTJlZmIsIDB4ZDc2MThjOWEsIDB4ZGU2Yzg3OTQsIDB4YzU3YjlhODYsIDB4Y2M3NjkxODgsIDB4ZjM1NWEwYTIsIDB4ZmE1OGFiYWMsIDB4ZTE0ZmI2YmUsIDB4ZTg0MmJkYjAsIDB4OWYwOWQ0ZWEsIDB4OTYwNGRmZTQsIDB4OGQxM2MyZjYsIDB4ODQxZWM5ZjgsIDB4YmIzZGY4ZDIsIDB4YjIzMGYzZGMsIDB4YTkyN2VlY2UsIDB4YTAyYWU1YzAsIDB4NDdiMTNjN2EsIDB4NGViYzM3NzQsIDB4NTVhYjJhNjYsIDB4NWNhNjIxNjgsIDB4NjM4NTEwNDIsIDB4NmE4ODFiNGMsIDB4NzE5ZjA2NWUsIDB4Nzg5MjBkNTAsIDB4MGZkOTY0MGEsIDB4MDZkNDZmMDQsIDB4MWRjMzcyMTYsIDB4MTRjZTc5MTgsIDB4MmJlZDQ4MzIsIDB4MjJlMDQzM2MsIDB4MzlmNzVlMmUsIDB4MzBmYTU1MjAsIDB4OWFiNzAxZWMsIDB4OTNiYTBhZTIsIDB4ODhhZDE3ZjAsIDB4ODFhMDFjZmUsIDB4YmU4MzJkZDQsIDB4Yjc4ZTI2ZGEsIDB4YWM5OTNiYzgsIDB4YTU5NDMwYzYsIDB4ZDJkZjU5OWMsIDB4ZGJkMjUyOTIsIDB4YzBjNTRmODAsIDB4YzljODQ0OGUsIDB4ZjZlYjc1YTQsIDB4ZmZlNjdlYWEsIDB4ZTRmMTYzYjgsIDB4ZWRmYzY4YjYsIDB4MGE2N2IxMGMsIDB4MDM2YWJhMDIsIDB4MTg3ZGE3MTAsIDB4MTE3MGFjMWUsIDB4MmU1MzlkMzQsIDB4Mjc1ZTk2M2EsIDB4M2M0OThiMjgsIDB4MzU0NDgwMjYsIDB4NDIwZmU5N2MsIDB4NGIwMmUyNzIsIDB4NTAxNWZmNjAsIDB4NTkxOGY0NmUsIDB4NjYzYmM1NDQsIDB4NmYzNmNlNGEsIDB4NzQyMWQzNTgsIDB4N2QyY2Q4NTYsIDB4YTEwYzdhMzcsIDB4YTgwMTcxMzksIDB4YjMxNjZjMmIsIDB4YmExYjY3MjUsIDB4ODUzODU2MGYsIDB4OGMzNTVkMDEsIDB4OTcyMjQwMTMsIDB4OWUyZjRiMWQsIDB4ZTk2NDIyNDcsIDB4ZTA2OTI5NDksIDB4ZmI3ZTM0NWIsIDB4ZjI3MzNmNTUsIDB4Y2Q1MDBlN2YsIDB4YzQ1ZDA1NzEsIDB4ZGY0YTE4NjMsIDB4ZDY0NzEzNmQsIDB4MzFkY2NhZDcsIDB4MzhkMWMxZDksIDB4MjNjNmRjY2IsIDB4MmFjYmQ3YzUsIDB4MTVlOGU2ZWYsIDB4MWNlNWVkZTEsIDB4MDdmMmYwZjMsIDB4MGVmZmZiZmQsIDB4NzliNDkyYTcsIDB4NzBiOTk5YTksIDB4NmJhZTg0YmIsIDB4NjJhMzhmYjUsIDB4NWQ4MGJlOWYsIDB4NTQ4ZGI1OTEsIDB4NGY5YWE4ODMsIDB4NDY5N2EzOGRdO1xuXG5cdCAgICBmdW5jdGlvbiBjb252ZXJ0VG9JbnQzMihieXRlcykge1xuXHQgICAgICAgIHZhciByZXN1bHQgPSBbXTtcblx0ICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGJ5dGVzLmxlbmd0aDsgaSArPSA0KSB7XG5cdCAgICAgICAgICAgIHJlc3VsdC5wdXNoKFxuXHQgICAgICAgICAgICAgICAgKGJ5dGVzW2kgICAgXSA8PCAyNCkgfFxuXHQgICAgICAgICAgICAgICAgKGJ5dGVzW2kgKyAxXSA8PCAxNikgfFxuXHQgICAgICAgICAgICAgICAgKGJ5dGVzW2kgKyAyXSA8PCAgOCkgfFxuXHQgICAgICAgICAgICAgICAgIGJ5dGVzW2kgKyAzXVxuXHQgICAgICAgICAgICApO1xuXHQgICAgICAgIH1cblx0ICAgICAgICByZXR1cm4gcmVzdWx0O1xuXHQgICAgfVxuXG5cdCAgICB2YXIgQUVTID0gZnVuY3Rpb24oa2V5KSB7XG5cdCAgICAgICAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIEFFUykpIHtcblx0ICAgICAgICAgICAgdGhyb3cgRXJyb3IoJ0FFUyBtdXN0IGJlIGluc3Rhbml0YXRlZCB3aXRoIGBuZXdgJyk7XG5cdCAgICAgICAgfVxuXG5cdCAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsICdrZXknLCB7XG5cdCAgICAgICAgICAgIHZhbHVlOiBjb2VyY2VBcnJheShrZXksIHRydWUpXG5cdCAgICAgICAgfSk7XG5cblx0ICAgICAgICB0aGlzLl9wcmVwYXJlKCk7XG5cdCAgICB9O1xuXG5cblx0ICAgIEFFUy5wcm90b3R5cGUuX3ByZXBhcmUgPSBmdW5jdGlvbigpIHtcblxuXHQgICAgICAgIHZhciByb3VuZHMgPSBudW1iZXJPZlJvdW5kc1t0aGlzLmtleS5sZW5ndGhdO1xuXHQgICAgICAgIGlmIChyb3VuZHMgPT0gbnVsbCkge1xuXHQgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQga2V5IHNpemUgKG11c3QgYmUgMTYsIDI0IG9yIDMyIGJ5dGVzKScpO1xuXHQgICAgICAgIH1cblxuXHQgICAgICAgIC8vIGVuY3J5cHRpb24gcm91bmQga2V5c1xuXHQgICAgICAgIHRoaXMuX0tlID0gW107XG5cblx0ICAgICAgICAvLyBkZWNyeXB0aW9uIHJvdW5kIGtleXNcblx0ICAgICAgICB0aGlzLl9LZCA9IFtdO1xuXG5cdCAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPD0gcm91bmRzOyBpKyspIHtcblx0ICAgICAgICAgICAgdGhpcy5fS2UucHVzaChbMCwgMCwgMCwgMF0pO1xuXHQgICAgICAgICAgICB0aGlzLl9LZC5wdXNoKFswLCAwLCAwLCAwXSk7XG5cdCAgICAgICAgfVxuXG5cdCAgICAgICAgdmFyIHJvdW5kS2V5Q291bnQgPSAocm91bmRzICsgMSkgKiA0O1xuXHQgICAgICAgIHZhciBLQyA9IHRoaXMua2V5Lmxlbmd0aCAvIDQ7XG5cblx0ICAgICAgICAvLyBjb252ZXJ0IHRoZSBrZXkgaW50byBpbnRzXG5cdCAgICAgICAgdmFyIHRrID0gY29udmVydFRvSW50MzIodGhpcy5rZXkpO1xuXG5cdCAgICAgICAgLy8gY29weSB2YWx1ZXMgaW50byByb3VuZCBrZXkgYXJyYXlzXG5cdCAgICAgICAgdmFyIGluZGV4O1xuXHQgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgS0M7IGkrKykge1xuXHQgICAgICAgICAgICBpbmRleCA9IGkgPj4gMjtcblx0ICAgICAgICAgICAgdGhpcy5fS2VbaW5kZXhdW2kgJSA0XSA9IHRrW2ldO1xuXHQgICAgICAgICAgICB0aGlzLl9LZFtyb3VuZHMgLSBpbmRleF1baSAlIDRdID0gdGtbaV07XG5cdCAgICAgICAgfVxuXG5cdCAgICAgICAgLy8ga2V5IGV4cGFuc2lvbiAoZmlwcy0xOTcgc2VjdGlvbiA1LjIpXG5cdCAgICAgICAgdmFyIHJjb25wb2ludGVyID0gMDtcblx0ICAgICAgICB2YXIgdCA9IEtDLCB0dDtcblx0ICAgICAgICB3aGlsZSAodCA8IHJvdW5kS2V5Q291bnQpIHtcblx0ICAgICAgICAgICAgdHQgPSB0a1tLQyAtIDFdO1xuXHQgICAgICAgICAgICB0a1swXSBePSAoKFNbKHR0ID4+IDE2KSAmIDB4RkZdIDw8IDI0KSBeXG5cdCAgICAgICAgICAgICAgICAgICAgICAoU1sodHQgPj4gIDgpICYgMHhGRl0gPDwgMTYpIF5cblx0ICAgICAgICAgICAgICAgICAgICAgIChTWyB0dCAgICAgICAgJiAweEZGXSA8PCAgOCkgXlxuXHQgICAgICAgICAgICAgICAgICAgICAgIFNbKHR0ID4+IDI0KSAmIDB4RkZdICAgICAgICBeXG5cdCAgICAgICAgICAgICAgICAgICAgICAocmNvbltyY29ucG9pbnRlcl0gPDwgMjQpKTtcblx0ICAgICAgICAgICAgcmNvbnBvaW50ZXIgKz0gMTtcblxuXHQgICAgICAgICAgICAvLyBrZXkgZXhwYW5zaW9uIChmb3Igbm9uLTI1NiBiaXQpXG5cdCAgICAgICAgICAgIGlmIChLQyAhPSA4KSB7XG5cdCAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMTsgaSA8IEtDOyBpKyspIHtcblx0ICAgICAgICAgICAgICAgICAgICB0a1tpXSBePSB0a1tpIC0gMV07XG5cdCAgICAgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgLy8ga2V5IGV4cGFuc2lvbiBmb3IgMjU2LWJpdCBrZXlzIGlzIFwic2xpZ2h0bHkgZGlmZmVyZW50XCIgKGZpcHMtMTk3KVxuXHQgICAgICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCAoS0MgLyAyKTsgaSsrKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgdGtbaV0gXj0gdGtbaSAtIDFdO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgdHQgPSB0a1soS0MgLyAyKSAtIDFdO1xuXG5cdCAgICAgICAgICAgICAgICB0a1tLQyAvIDJdIF49IChTWyB0dCAgICAgICAgJiAweEZGXSAgICAgICAgXlxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoU1sodHQgPj4gIDgpICYgMHhGRl0gPDwgIDgpIF5cblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKFNbKHR0ID4+IDE2KSAmIDB4RkZdIDw8IDE2KSBeXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChTWyh0dCA+PiAyNCkgJiAweEZGXSA8PCAyNCkpO1xuXG5cdCAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gKEtDIC8gMikgKyAxOyBpIDwgS0M7IGkrKykge1xuXHQgICAgICAgICAgICAgICAgICAgIHRrW2ldIF49IHRrW2kgLSAxXTtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgIC8vIGNvcHkgdmFsdWVzIGludG8gcm91bmQga2V5IGFycmF5c1xuXHQgICAgICAgICAgICB2YXIgaSA9IDAsIHIsIGM7XG5cdCAgICAgICAgICAgIHdoaWxlIChpIDwgS0MgJiYgdCA8IHJvdW5kS2V5Q291bnQpIHtcblx0ICAgICAgICAgICAgICAgIHIgPSB0ID4+IDI7XG5cdCAgICAgICAgICAgICAgICBjID0gdCAlIDQ7XG5cdCAgICAgICAgICAgICAgICB0aGlzLl9LZVtyXVtjXSA9IHRrW2ldO1xuXHQgICAgICAgICAgICAgICAgdGhpcy5fS2Rbcm91bmRzIC0gcl1bY10gPSB0a1tpKytdO1xuXHQgICAgICAgICAgICAgICAgdCsrO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfVxuXG5cdCAgICAgICAgLy8gaW52ZXJzZS1jaXBoZXItaWZ5IHRoZSBkZWNyeXB0aW9uIHJvdW5kIGtleSAoZmlwcy0xOTcgc2VjdGlvbiA1LjMpXG5cdCAgICAgICAgZm9yICh2YXIgciA9IDE7IHIgPCByb3VuZHM7IHIrKykge1xuXHQgICAgICAgICAgICBmb3IgKHZhciBjID0gMDsgYyA8IDQ7IGMrKykge1xuXHQgICAgICAgICAgICAgICAgdHQgPSB0aGlzLl9LZFtyXVtjXTtcblx0ICAgICAgICAgICAgICAgIHRoaXMuX0tkW3JdW2NdID0gKFUxWyh0dCA+PiAyNCkgJiAweEZGXSBeXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBVMlsodHQgPj4gMTYpICYgMHhGRl0gXlxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgVTNbKHR0ID4+ICA4KSAmIDB4RkZdIF5cblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFU0WyB0dCAgICAgICAgJiAweEZGXSk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9XG5cdCAgICB9O1xuXG5cdCAgICBBRVMucHJvdG90eXBlLmVuY3J5cHQgPSBmdW5jdGlvbihwbGFpbnRleHQpIHtcblx0ICAgICAgICBpZiAocGxhaW50ZXh0Lmxlbmd0aCAhPSAxNikge1xuXHQgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgcGxhaW50ZXh0IHNpemUgKG11c3QgYmUgMTYgYnl0ZXMpJyk7XG5cdCAgICAgICAgfVxuXG5cdCAgICAgICAgdmFyIHJvdW5kcyA9IHRoaXMuX0tlLmxlbmd0aCAtIDE7XG5cdCAgICAgICAgdmFyIGEgPSBbMCwgMCwgMCwgMF07XG5cblx0ICAgICAgICAvLyBjb252ZXJ0IHBsYWludGV4dCB0byAoaW50cyBeIGtleSlcblx0ICAgICAgICB2YXIgdCA9IGNvbnZlcnRUb0ludDMyKHBsYWludGV4dCk7XG5cdCAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCA0OyBpKyspIHtcblx0ICAgICAgICAgICAgdFtpXSBePSB0aGlzLl9LZVswXVtpXTtcblx0ICAgICAgICB9XG5cblx0ICAgICAgICAvLyBhcHBseSByb3VuZCB0cmFuc2Zvcm1zXG5cdCAgICAgICAgZm9yICh2YXIgciA9IDE7IHIgPCByb3VuZHM7IHIrKykge1xuXHQgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IDQ7IGkrKykge1xuXHQgICAgICAgICAgICAgICAgYVtpXSA9IChUMVsodFsgaSAgICAgICAgIF0gPj4gMjQpICYgMHhmZl0gXlxuXHQgICAgICAgICAgICAgICAgICAgICAgICBUMlsodFsoaSArIDEpICUgNF0gPj4gMTYpICYgMHhmZl0gXlxuXHQgICAgICAgICAgICAgICAgICAgICAgICBUM1sodFsoaSArIDIpICUgNF0gPj4gIDgpICYgMHhmZl0gXlxuXHQgICAgICAgICAgICAgICAgICAgICAgICBUNFsgdFsoaSArIDMpICUgNF0gICAgICAgICYgMHhmZl0gXlxuXHQgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9LZVtyXVtpXSk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgdCA9IGEuc2xpY2UoKTtcblx0ICAgICAgICB9XG5cblx0ICAgICAgICAvLyB0aGUgbGFzdCByb3VuZCBpcyBzcGVjaWFsXG5cdCAgICAgICAgdmFyIHJlc3VsdCA9IGNyZWF0ZUFycmF5KDE2KSwgdHQ7XG5cdCAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCA0OyBpKyspIHtcblx0ICAgICAgICAgICAgdHQgPSB0aGlzLl9LZVtyb3VuZHNdW2ldO1xuXHQgICAgICAgICAgICByZXN1bHRbNCAqIGkgICAgXSA9IChTWyh0WyBpICAgICAgICAgXSA+PiAyNCkgJiAweGZmXSBeICh0dCA+PiAyNCkpICYgMHhmZjtcblx0ICAgICAgICAgICAgcmVzdWx0WzQgKiBpICsgMV0gPSAoU1sodFsoaSArIDEpICUgNF0gPj4gMTYpICYgMHhmZl0gXiAodHQgPj4gMTYpKSAmIDB4ZmY7XG5cdCAgICAgICAgICAgIHJlc3VsdFs0ICogaSArIDJdID0gKFNbKHRbKGkgKyAyKSAlIDRdID4+ICA4KSAmIDB4ZmZdIF4gKHR0ID4+ICA4KSkgJiAweGZmO1xuXHQgICAgICAgICAgICByZXN1bHRbNCAqIGkgKyAzXSA9IChTWyB0WyhpICsgMykgJSA0XSAgICAgICAgJiAweGZmXSBeICB0dCAgICAgICApICYgMHhmZjtcblx0ICAgICAgICB9XG5cblx0ICAgICAgICByZXR1cm4gcmVzdWx0O1xuXHQgICAgfTtcblxuXHQgICAgQUVTLnByb3RvdHlwZS5kZWNyeXB0ID0gZnVuY3Rpb24oY2lwaGVydGV4dCkge1xuXHQgICAgICAgIGlmIChjaXBoZXJ0ZXh0Lmxlbmd0aCAhPSAxNikge1xuXHQgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgY2lwaGVydGV4dCBzaXplIChtdXN0IGJlIDE2IGJ5dGVzKScpO1xuXHQgICAgICAgIH1cblxuXHQgICAgICAgIHZhciByb3VuZHMgPSB0aGlzLl9LZC5sZW5ndGggLSAxO1xuXHQgICAgICAgIHZhciBhID0gWzAsIDAsIDAsIDBdO1xuXG5cdCAgICAgICAgLy8gY29udmVydCBwbGFpbnRleHQgdG8gKGludHMgXiBrZXkpXG5cdCAgICAgICAgdmFyIHQgPSBjb252ZXJ0VG9JbnQzMihjaXBoZXJ0ZXh0KTtcblx0ICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IDQ7IGkrKykge1xuXHQgICAgICAgICAgICB0W2ldIF49IHRoaXMuX0tkWzBdW2ldO1xuXHQgICAgICAgIH1cblxuXHQgICAgICAgIC8vIGFwcGx5IHJvdW5kIHRyYW5zZm9ybXNcblx0ICAgICAgICBmb3IgKHZhciByID0gMTsgciA8IHJvdW5kczsgcisrKSB7XG5cdCAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgNDsgaSsrKSB7XG5cdCAgICAgICAgICAgICAgICBhW2ldID0gKFQ1Wyh0WyBpICAgICAgICAgIF0gPj4gMjQpICYgMHhmZl0gXlxuXHQgICAgICAgICAgICAgICAgICAgICAgICBUNlsodFsoaSArIDMpICUgNF0gPj4gMTYpICYgMHhmZl0gXlxuXHQgICAgICAgICAgICAgICAgICAgICAgICBUN1sodFsoaSArIDIpICUgNF0gPj4gIDgpICYgMHhmZl0gXlxuXHQgICAgICAgICAgICAgICAgICAgICAgICBUOFsgdFsoaSArIDEpICUgNF0gICAgICAgICYgMHhmZl0gXlxuXHQgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9LZFtyXVtpXSk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgdCA9IGEuc2xpY2UoKTtcblx0ICAgICAgICB9XG5cblx0ICAgICAgICAvLyB0aGUgbGFzdCByb3VuZCBpcyBzcGVjaWFsXG5cdCAgICAgICAgdmFyIHJlc3VsdCA9IGNyZWF0ZUFycmF5KDE2KSwgdHQ7XG5cdCAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCA0OyBpKyspIHtcblx0ICAgICAgICAgICAgdHQgPSB0aGlzLl9LZFtyb3VuZHNdW2ldO1xuXHQgICAgICAgICAgICByZXN1bHRbNCAqIGkgICAgXSA9IChTaVsodFsgaSAgICAgICAgIF0gPj4gMjQpICYgMHhmZl0gXiAodHQgPj4gMjQpKSAmIDB4ZmY7XG5cdCAgICAgICAgICAgIHJlc3VsdFs0ICogaSArIDFdID0gKFNpWyh0WyhpICsgMykgJSA0XSA+PiAxNikgJiAweGZmXSBeICh0dCA+PiAxNikpICYgMHhmZjtcblx0ICAgICAgICAgICAgcmVzdWx0WzQgKiBpICsgMl0gPSAoU2lbKHRbKGkgKyAyKSAlIDRdID4+ICA4KSAmIDB4ZmZdIF4gKHR0ID4+ICA4KSkgJiAweGZmO1xuXHQgICAgICAgICAgICByZXN1bHRbNCAqIGkgKyAzXSA9IChTaVsgdFsoaSArIDEpICUgNF0gICAgICAgICYgMHhmZl0gXiAgdHQgICAgICAgKSAmIDB4ZmY7XG5cdCAgICAgICAgfVxuXG5cdCAgICAgICAgcmV0dXJuIHJlc3VsdDtcblx0ICAgIH07XG5cblxuXHQgICAgLyoqXG5cdCAgICAgKiAgTW9kZSBPZiBPcGVyYXRpb24gLSBFbGVjdG9uaWMgQ29kZWJvb2sgKEVDQilcblx0ICAgICAqL1xuXHQgICAgdmFyIE1vZGVPZk9wZXJhdGlvbkVDQiA9IGZ1bmN0aW9uKGtleSkge1xuXHQgICAgICAgIGlmICghKHRoaXMgaW5zdGFuY2VvZiBNb2RlT2ZPcGVyYXRpb25FQ0IpKSB7XG5cdCAgICAgICAgICAgIHRocm93IEVycm9yKCdBRVMgbXVzdCBiZSBpbnN0YW5pdGF0ZWQgd2l0aCBgbmV3YCcpO1xuXHQgICAgICAgIH1cblxuXHQgICAgICAgIHRoaXMuZGVzY3JpcHRpb24gPSBcIkVsZWN0cm9uaWMgQ29kZSBCbG9ja1wiO1xuXHQgICAgICAgIHRoaXMubmFtZSA9IFwiZWNiXCI7XG5cblx0ICAgICAgICB0aGlzLl9hZXMgPSBuZXcgQUVTKGtleSk7XG5cdCAgICB9O1xuXG5cdCAgICBNb2RlT2ZPcGVyYXRpb25FQ0IucHJvdG90eXBlLmVuY3J5cHQgPSBmdW5jdGlvbihwbGFpbnRleHQpIHtcblx0ICAgICAgICBwbGFpbnRleHQgPSBjb2VyY2VBcnJheShwbGFpbnRleHQpO1xuXG5cdCAgICAgICAgaWYgKChwbGFpbnRleHQubGVuZ3RoICUgMTYpICE9PSAwKSB7XG5cdCAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBwbGFpbnRleHQgc2l6ZSAobXVzdCBiZSBtdWx0aXBsZSBvZiAxNiBieXRlcyknKTtcblx0ICAgICAgICB9XG5cblx0ICAgICAgICB2YXIgY2lwaGVydGV4dCA9IGNyZWF0ZUFycmF5KHBsYWludGV4dC5sZW5ndGgpO1xuXHQgICAgICAgIHZhciBibG9jayA9IGNyZWF0ZUFycmF5KDE2KTtcblxuXHQgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcGxhaW50ZXh0Lmxlbmd0aDsgaSArPSAxNikge1xuXHQgICAgICAgICAgICBjb3B5QXJyYXkocGxhaW50ZXh0LCBibG9jaywgMCwgaSwgaSArIDE2KTtcblx0ICAgICAgICAgICAgYmxvY2sgPSB0aGlzLl9hZXMuZW5jcnlwdChibG9jayk7XG5cdCAgICAgICAgICAgIGNvcHlBcnJheShibG9jaywgY2lwaGVydGV4dCwgaSk7XG5cdCAgICAgICAgfVxuXG5cdCAgICAgICAgcmV0dXJuIGNpcGhlcnRleHQ7XG5cdCAgICB9O1xuXG5cdCAgICBNb2RlT2ZPcGVyYXRpb25FQ0IucHJvdG90eXBlLmRlY3J5cHQgPSBmdW5jdGlvbihjaXBoZXJ0ZXh0KSB7XG5cdCAgICAgICAgY2lwaGVydGV4dCA9IGNvZXJjZUFycmF5KGNpcGhlcnRleHQpO1xuXG5cdCAgICAgICAgaWYgKChjaXBoZXJ0ZXh0Lmxlbmd0aCAlIDE2KSAhPT0gMCkge1xuXHQgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgY2lwaGVydGV4dCBzaXplIChtdXN0IGJlIG11bHRpcGxlIG9mIDE2IGJ5dGVzKScpO1xuXHQgICAgICAgIH1cblxuXHQgICAgICAgIHZhciBwbGFpbnRleHQgPSBjcmVhdGVBcnJheShjaXBoZXJ0ZXh0Lmxlbmd0aCk7XG5cdCAgICAgICAgdmFyIGJsb2NrID0gY3JlYXRlQXJyYXkoMTYpO1xuXG5cdCAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaXBoZXJ0ZXh0Lmxlbmd0aDsgaSArPSAxNikge1xuXHQgICAgICAgICAgICBjb3B5QXJyYXkoY2lwaGVydGV4dCwgYmxvY2ssIDAsIGksIGkgKyAxNik7XG5cdCAgICAgICAgICAgIGJsb2NrID0gdGhpcy5fYWVzLmRlY3J5cHQoYmxvY2spO1xuXHQgICAgICAgICAgICBjb3B5QXJyYXkoYmxvY2ssIHBsYWludGV4dCwgaSk7XG5cdCAgICAgICAgfVxuXG5cdCAgICAgICAgcmV0dXJuIHBsYWludGV4dDtcblx0ICAgIH07XG5cblxuXHQgICAgLyoqXG5cdCAgICAgKiAgTW9kZSBPZiBPcGVyYXRpb24gLSBDaXBoZXIgQmxvY2sgQ2hhaW5pbmcgKENCQylcblx0ICAgICAqL1xuXHQgICAgdmFyIE1vZGVPZk9wZXJhdGlvbkNCQyA9IGZ1bmN0aW9uKGtleSwgaXYpIHtcblx0ICAgICAgICBpZiAoISh0aGlzIGluc3RhbmNlb2YgTW9kZU9mT3BlcmF0aW9uQ0JDKSkge1xuXHQgICAgICAgICAgICB0aHJvdyBFcnJvcignQUVTIG11c3QgYmUgaW5zdGFuaXRhdGVkIHdpdGggYG5ld2AnKTtcblx0ICAgICAgICB9XG5cblx0ICAgICAgICB0aGlzLmRlc2NyaXB0aW9uID0gXCJDaXBoZXIgQmxvY2sgQ2hhaW5pbmdcIjtcblx0ICAgICAgICB0aGlzLm5hbWUgPSBcImNiY1wiO1xuXG5cdCAgICAgICAgaWYgKCFpdikge1xuXHQgICAgICAgICAgICBpdiA9IGNyZWF0ZUFycmF5KDE2KTtcblxuXHQgICAgICAgIH0gZWxzZSBpZiAoaXYubGVuZ3RoICE9IDE2KSB7XG5cdCAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBpbml0aWFsYXRpb24gdmVjdG9yIHNpemUgKG11c3QgYmUgMTYgYnl0ZXMpJyk7XG5cdCAgICAgICAgfVxuXG5cdCAgICAgICAgdGhpcy5fbGFzdENpcGhlcmJsb2NrID0gY29lcmNlQXJyYXkoaXYsIHRydWUpO1xuXG5cdCAgICAgICAgdGhpcy5fYWVzID0gbmV3IEFFUyhrZXkpO1xuXHQgICAgfTtcblxuXHQgICAgTW9kZU9mT3BlcmF0aW9uQ0JDLnByb3RvdHlwZS5lbmNyeXB0ID0gZnVuY3Rpb24ocGxhaW50ZXh0KSB7XG5cdCAgICAgICAgcGxhaW50ZXh0ID0gY29lcmNlQXJyYXkocGxhaW50ZXh0KTtcblxuXHQgICAgICAgIGlmICgocGxhaW50ZXh0Lmxlbmd0aCAlIDE2KSAhPT0gMCkge1xuXHQgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgcGxhaW50ZXh0IHNpemUgKG11c3QgYmUgbXVsdGlwbGUgb2YgMTYgYnl0ZXMpJyk7XG5cdCAgICAgICAgfVxuXG5cdCAgICAgICAgdmFyIGNpcGhlcnRleHQgPSBjcmVhdGVBcnJheShwbGFpbnRleHQubGVuZ3RoKTtcblx0ICAgICAgICB2YXIgYmxvY2sgPSBjcmVhdGVBcnJheSgxNik7XG5cblx0ICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBsYWludGV4dC5sZW5ndGg7IGkgKz0gMTYpIHtcblx0ICAgICAgICAgICAgY29weUFycmF5KHBsYWludGV4dCwgYmxvY2ssIDAsIGksIGkgKyAxNik7XG5cblx0ICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCAxNjsgaisrKSB7XG5cdCAgICAgICAgICAgICAgICBibG9ja1tqXSBePSB0aGlzLl9sYXN0Q2lwaGVyYmxvY2tbal07XG5cdCAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICB0aGlzLl9sYXN0Q2lwaGVyYmxvY2sgPSB0aGlzLl9hZXMuZW5jcnlwdChibG9jayk7XG5cdCAgICAgICAgICAgIGNvcHlBcnJheSh0aGlzLl9sYXN0Q2lwaGVyYmxvY2ssIGNpcGhlcnRleHQsIGkpO1xuXHQgICAgICAgIH1cblxuXHQgICAgICAgIHJldHVybiBjaXBoZXJ0ZXh0O1xuXHQgICAgfTtcblxuXHQgICAgTW9kZU9mT3BlcmF0aW9uQ0JDLnByb3RvdHlwZS5kZWNyeXB0ID0gZnVuY3Rpb24oY2lwaGVydGV4dCkge1xuXHQgICAgICAgIGNpcGhlcnRleHQgPSBjb2VyY2VBcnJheShjaXBoZXJ0ZXh0KTtcblxuXHQgICAgICAgIGlmICgoY2lwaGVydGV4dC5sZW5ndGggJSAxNikgIT09IDApIHtcblx0ICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIGNpcGhlcnRleHQgc2l6ZSAobXVzdCBiZSBtdWx0aXBsZSBvZiAxNiBieXRlcyknKTtcblx0ICAgICAgICB9XG5cblx0ICAgICAgICB2YXIgcGxhaW50ZXh0ID0gY3JlYXRlQXJyYXkoY2lwaGVydGV4dC5sZW5ndGgpO1xuXHQgICAgICAgIHZhciBibG9jayA9IGNyZWF0ZUFycmF5KDE2KTtcblxuXHQgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2lwaGVydGV4dC5sZW5ndGg7IGkgKz0gMTYpIHtcblx0ICAgICAgICAgICAgY29weUFycmF5KGNpcGhlcnRleHQsIGJsb2NrLCAwLCBpLCBpICsgMTYpO1xuXHQgICAgICAgICAgICBibG9jayA9IHRoaXMuX2Flcy5kZWNyeXB0KGJsb2NrKTtcblxuXHQgICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IDE2OyBqKyspIHtcblx0ICAgICAgICAgICAgICAgIHBsYWludGV4dFtpICsgal0gPSBibG9ja1tqXSBeIHRoaXMuX2xhc3RDaXBoZXJibG9ja1tqXTtcblx0ICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgIGNvcHlBcnJheShjaXBoZXJ0ZXh0LCB0aGlzLl9sYXN0Q2lwaGVyYmxvY2ssIDAsIGksIGkgKyAxNik7XG5cdCAgICAgICAgfVxuXG5cdCAgICAgICAgcmV0dXJuIHBsYWludGV4dDtcblx0ICAgIH07XG5cblxuXHQgICAgLyoqXG5cdCAgICAgKiAgTW9kZSBPZiBPcGVyYXRpb24gLSBDaXBoZXIgRmVlZGJhY2sgKENGQilcblx0ICAgICAqL1xuXHQgICAgdmFyIE1vZGVPZk9wZXJhdGlvbkNGQiA9IGZ1bmN0aW9uKGtleSwgaXYsIHNlZ21lbnRTaXplKSB7XG5cdCAgICAgICAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIE1vZGVPZk9wZXJhdGlvbkNGQikpIHtcblx0ICAgICAgICAgICAgdGhyb3cgRXJyb3IoJ0FFUyBtdXN0IGJlIGluc3Rhbml0YXRlZCB3aXRoIGBuZXdgJyk7XG5cdCAgICAgICAgfVxuXG5cdCAgICAgICAgdGhpcy5kZXNjcmlwdGlvbiA9IFwiQ2lwaGVyIEZlZWRiYWNrXCI7XG5cdCAgICAgICAgdGhpcy5uYW1lID0gXCJjZmJcIjtcblxuXHQgICAgICAgIGlmICghaXYpIHtcblx0ICAgICAgICAgICAgaXYgPSBjcmVhdGVBcnJheSgxNik7XG5cblx0ICAgICAgICB9IGVsc2UgaWYgKGl2Lmxlbmd0aCAhPSAxNikge1xuXHQgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgaW5pdGlhbGF0aW9uIHZlY3RvciBzaXplIChtdXN0IGJlIDE2IHNpemUpJyk7XG5cdCAgICAgICAgfVxuXG5cdCAgICAgICAgaWYgKCFzZWdtZW50U2l6ZSkgeyBzZWdtZW50U2l6ZSA9IDE7IH1cblxuXHQgICAgICAgIHRoaXMuc2VnbWVudFNpemUgPSBzZWdtZW50U2l6ZTtcblxuXHQgICAgICAgIHRoaXMuX3NoaWZ0UmVnaXN0ZXIgPSBjb2VyY2VBcnJheShpdiwgdHJ1ZSk7XG5cblx0ICAgICAgICB0aGlzLl9hZXMgPSBuZXcgQUVTKGtleSk7XG5cdCAgICB9O1xuXG5cdCAgICBNb2RlT2ZPcGVyYXRpb25DRkIucHJvdG90eXBlLmVuY3J5cHQgPSBmdW5jdGlvbihwbGFpbnRleHQpIHtcblx0ICAgICAgICBpZiAoKHBsYWludGV4dC5sZW5ndGggJSB0aGlzLnNlZ21lbnRTaXplKSAhPSAwKSB7XG5cdCAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBwbGFpbnRleHQgc2l6ZSAobXVzdCBiZSBzZWdtZW50U2l6ZSBieXRlcyknKTtcblx0ICAgICAgICB9XG5cblx0ICAgICAgICB2YXIgZW5jcnlwdGVkID0gY29lcmNlQXJyYXkocGxhaW50ZXh0LCB0cnVlKTtcblxuXHQgICAgICAgIHZhciB4b3JTZWdtZW50O1xuXHQgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZW5jcnlwdGVkLmxlbmd0aDsgaSArPSB0aGlzLnNlZ21lbnRTaXplKSB7XG5cdCAgICAgICAgICAgIHhvclNlZ21lbnQgPSB0aGlzLl9hZXMuZW5jcnlwdCh0aGlzLl9zaGlmdFJlZ2lzdGVyKTtcblx0ICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCB0aGlzLnNlZ21lbnRTaXplOyBqKyspIHtcblx0ICAgICAgICAgICAgICAgIGVuY3J5cHRlZFtpICsgal0gXj0geG9yU2VnbWVudFtqXTtcblx0ICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgIC8vIFNoaWZ0IHRoZSByZWdpc3RlclxuXHQgICAgICAgICAgICBjb3B5QXJyYXkodGhpcy5fc2hpZnRSZWdpc3RlciwgdGhpcy5fc2hpZnRSZWdpc3RlciwgMCwgdGhpcy5zZWdtZW50U2l6ZSk7XG5cdCAgICAgICAgICAgIGNvcHlBcnJheShlbmNyeXB0ZWQsIHRoaXMuX3NoaWZ0UmVnaXN0ZXIsIDE2IC0gdGhpcy5zZWdtZW50U2l6ZSwgaSwgaSArIHRoaXMuc2VnbWVudFNpemUpO1xuXHQgICAgICAgIH1cblxuXHQgICAgICAgIHJldHVybiBlbmNyeXB0ZWQ7XG5cdCAgICB9O1xuXG5cdCAgICBNb2RlT2ZPcGVyYXRpb25DRkIucHJvdG90eXBlLmRlY3J5cHQgPSBmdW5jdGlvbihjaXBoZXJ0ZXh0KSB7XG5cdCAgICAgICAgaWYgKChjaXBoZXJ0ZXh0Lmxlbmd0aCAlIHRoaXMuc2VnbWVudFNpemUpICE9IDApIHtcblx0ICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIGNpcGhlcnRleHQgc2l6ZSAobXVzdCBiZSBzZWdtZW50U2l6ZSBieXRlcyknKTtcblx0ICAgICAgICB9XG5cblx0ICAgICAgICB2YXIgcGxhaW50ZXh0ID0gY29lcmNlQXJyYXkoY2lwaGVydGV4dCwgdHJ1ZSk7XG5cblx0ICAgICAgICB2YXIgeG9yU2VnbWVudDtcblx0ICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBsYWludGV4dC5sZW5ndGg7IGkgKz0gdGhpcy5zZWdtZW50U2l6ZSkge1xuXHQgICAgICAgICAgICB4b3JTZWdtZW50ID0gdGhpcy5fYWVzLmVuY3J5cHQodGhpcy5fc2hpZnRSZWdpc3Rlcik7XG5cblx0ICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCB0aGlzLnNlZ21lbnRTaXplOyBqKyspIHtcblx0ICAgICAgICAgICAgICAgIHBsYWludGV4dFtpICsgal0gXj0geG9yU2VnbWVudFtqXTtcblx0ICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgIC8vIFNoaWZ0IHRoZSByZWdpc3RlclxuXHQgICAgICAgICAgICBjb3B5QXJyYXkodGhpcy5fc2hpZnRSZWdpc3RlciwgdGhpcy5fc2hpZnRSZWdpc3RlciwgMCwgdGhpcy5zZWdtZW50U2l6ZSk7XG5cdCAgICAgICAgICAgIGNvcHlBcnJheShjaXBoZXJ0ZXh0LCB0aGlzLl9zaGlmdFJlZ2lzdGVyLCAxNiAtIHRoaXMuc2VnbWVudFNpemUsIGksIGkgKyB0aGlzLnNlZ21lbnRTaXplKTtcblx0ICAgICAgICB9XG5cblx0ICAgICAgICByZXR1cm4gcGxhaW50ZXh0O1xuXHQgICAgfTtcblxuXHQgICAgLyoqXG5cdCAgICAgKiAgTW9kZSBPZiBPcGVyYXRpb24gLSBPdXRwdXQgRmVlZGJhY2sgKE9GQilcblx0ICAgICAqL1xuXHQgICAgdmFyIE1vZGVPZk9wZXJhdGlvbk9GQiA9IGZ1bmN0aW9uKGtleSwgaXYpIHtcblx0ICAgICAgICBpZiAoISh0aGlzIGluc3RhbmNlb2YgTW9kZU9mT3BlcmF0aW9uT0ZCKSkge1xuXHQgICAgICAgICAgICB0aHJvdyBFcnJvcignQUVTIG11c3QgYmUgaW5zdGFuaXRhdGVkIHdpdGggYG5ld2AnKTtcblx0ICAgICAgICB9XG5cblx0ICAgICAgICB0aGlzLmRlc2NyaXB0aW9uID0gXCJPdXRwdXQgRmVlZGJhY2tcIjtcblx0ICAgICAgICB0aGlzLm5hbWUgPSBcIm9mYlwiO1xuXG5cdCAgICAgICAgaWYgKCFpdikge1xuXHQgICAgICAgICAgICBpdiA9IGNyZWF0ZUFycmF5KDE2KTtcblxuXHQgICAgICAgIH0gZWxzZSBpZiAoaXYubGVuZ3RoICE9IDE2KSB7XG5cdCAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBpbml0aWFsYXRpb24gdmVjdG9yIHNpemUgKG11c3QgYmUgMTYgYnl0ZXMpJyk7XG5cdCAgICAgICAgfVxuXG5cdCAgICAgICAgdGhpcy5fbGFzdFByZWNpcGhlciA9IGNvZXJjZUFycmF5KGl2LCB0cnVlKTtcblx0ICAgICAgICB0aGlzLl9sYXN0UHJlY2lwaGVySW5kZXggPSAxNjtcblxuXHQgICAgICAgIHRoaXMuX2FlcyA9IG5ldyBBRVMoa2V5KTtcblx0ICAgIH07XG5cblx0ICAgIE1vZGVPZk9wZXJhdGlvbk9GQi5wcm90b3R5cGUuZW5jcnlwdCA9IGZ1bmN0aW9uKHBsYWludGV4dCkge1xuXHQgICAgICAgIHZhciBlbmNyeXB0ZWQgPSBjb2VyY2VBcnJheShwbGFpbnRleHQsIHRydWUpO1xuXG5cdCAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBlbmNyeXB0ZWQubGVuZ3RoOyBpKyspIHtcblx0ICAgICAgICAgICAgaWYgKHRoaXMuX2xhc3RQcmVjaXBoZXJJbmRleCA9PT0gMTYpIHtcblx0ICAgICAgICAgICAgICAgIHRoaXMuX2xhc3RQcmVjaXBoZXIgPSB0aGlzLl9hZXMuZW5jcnlwdCh0aGlzLl9sYXN0UHJlY2lwaGVyKTtcblx0ICAgICAgICAgICAgICAgIHRoaXMuX2xhc3RQcmVjaXBoZXJJbmRleCA9IDA7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgZW5jcnlwdGVkW2ldIF49IHRoaXMuX2xhc3RQcmVjaXBoZXJbdGhpcy5fbGFzdFByZWNpcGhlckluZGV4KytdO1xuXHQgICAgICAgIH1cblxuXHQgICAgICAgIHJldHVybiBlbmNyeXB0ZWQ7XG5cdCAgICB9O1xuXG5cdCAgICAvLyBEZWNyeXB0aW9uIGlzIHN5bWV0cmljXG5cdCAgICBNb2RlT2ZPcGVyYXRpb25PRkIucHJvdG90eXBlLmRlY3J5cHQgPSBNb2RlT2ZPcGVyYXRpb25PRkIucHJvdG90eXBlLmVuY3J5cHQ7XG5cblxuXHQgICAgLyoqXG5cdCAgICAgKiAgQ291bnRlciBvYmplY3QgZm9yIENUUiBjb21tb24gbW9kZSBvZiBvcGVyYXRpb25cblx0ICAgICAqL1xuXHQgICAgdmFyIENvdW50ZXIgPSBmdW5jdGlvbihpbml0aWFsVmFsdWUpIHtcblx0ICAgICAgICBpZiAoISh0aGlzIGluc3RhbmNlb2YgQ291bnRlcikpIHtcblx0ICAgICAgICAgICAgdGhyb3cgRXJyb3IoJ0NvdW50ZXIgbXVzdCBiZSBpbnN0YW5pdGF0ZWQgd2l0aCBgbmV3YCcpO1xuXHQgICAgICAgIH1cblxuXHQgICAgICAgIC8vIFdlIGFsbG93IDAsIGJ1dCBhbnl0aGluZyBmYWxzZS1pc2ggdXNlcyB0aGUgZGVmYXVsdCAxXG5cdCAgICAgICAgaWYgKGluaXRpYWxWYWx1ZSAhPT0gMCAmJiAhaW5pdGlhbFZhbHVlKSB7IGluaXRpYWxWYWx1ZSA9IDE7IH1cblxuXHQgICAgICAgIGlmICh0eXBlb2YoaW5pdGlhbFZhbHVlKSA9PT0gJ251bWJlcicpIHtcblx0ICAgICAgICAgICAgdGhpcy5fY291bnRlciA9IGNyZWF0ZUFycmF5KDE2KTtcblx0ICAgICAgICAgICAgdGhpcy5zZXRWYWx1ZShpbml0aWFsVmFsdWUpO1xuXG5cdCAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgICAgdGhpcy5zZXRCeXRlcyhpbml0aWFsVmFsdWUpO1xuXHQgICAgICAgIH1cblx0ICAgIH07XG5cblx0ICAgIENvdW50ZXIucHJvdG90eXBlLnNldFZhbHVlID0gZnVuY3Rpb24odmFsdWUpIHtcblx0ICAgICAgICBpZiAodHlwZW9mKHZhbHVlKSAhPT0gJ251bWJlcicgfHwgcGFyc2VJbnQodmFsdWUpICE9IHZhbHVlKSB7XG5cdCAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBjb3VudGVyIHZhbHVlIChtdXN0IGJlIGFuIGludGVnZXIpJyk7XG5cdCAgICAgICAgfVxuXG5cdCAgICAgICAgZm9yICh2YXIgaW5kZXggPSAxNTsgaW5kZXggPj0gMDsgLS1pbmRleCkge1xuXHQgICAgICAgICAgICB0aGlzLl9jb3VudGVyW2luZGV4XSA9IHZhbHVlICUgMjU2O1xuXHQgICAgICAgICAgICB2YWx1ZSA9IHZhbHVlID4+IDg7XG5cdCAgICAgICAgfVxuXHQgICAgfTtcblxuXHQgICAgQ291bnRlci5wcm90b3R5cGUuc2V0Qnl0ZXMgPSBmdW5jdGlvbihieXRlcykge1xuXHQgICAgICAgIGJ5dGVzID0gY29lcmNlQXJyYXkoYnl0ZXMsIHRydWUpO1xuXG5cdCAgICAgICAgaWYgKGJ5dGVzLmxlbmd0aCAhPSAxNikge1xuXHQgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgY291bnRlciBieXRlcyBzaXplIChtdXN0IGJlIDE2IGJ5dGVzKScpO1xuXHQgICAgICAgIH1cblxuXHQgICAgICAgIHRoaXMuX2NvdW50ZXIgPSBieXRlcztcblx0ICAgIH07XG5cblx0ICAgIENvdW50ZXIucHJvdG90eXBlLmluY3JlbWVudCA9IGZ1bmN0aW9uKCkge1xuXHQgICAgICAgIGZvciAodmFyIGkgPSAxNTsgaSA+PSAwOyBpLS0pIHtcblx0ICAgICAgICAgICAgaWYgKHRoaXMuX2NvdW50ZXJbaV0gPT09IDI1NSkge1xuXHQgICAgICAgICAgICAgICAgdGhpcy5fY291bnRlcltpXSA9IDA7XG5cdCAgICAgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgICAgICB0aGlzLl9jb3VudGVyW2ldKys7XG5cdCAgICAgICAgICAgICAgICBicmVhaztcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH1cblx0ICAgIH07XG5cblxuXHQgICAgLyoqXG5cdCAgICAgKiAgTW9kZSBPZiBPcGVyYXRpb24gLSBDb3VudGVyIChDVFIpXG5cdCAgICAgKi9cblx0ICAgIHZhciBNb2RlT2ZPcGVyYXRpb25DVFIgPSBmdW5jdGlvbihrZXksIGNvdW50ZXIpIHtcblx0ICAgICAgICBpZiAoISh0aGlzIGluc3RhbmNlb2YgTW9kZU9mT3BlcmF0aW9uQ1RSKSkge1xuXHQgICAgICAgICAgICB0aHJvdyBFcnJvcignQUVTIG11c3QgYmUgaW5zdGFuaXRhdGVkIHdpdGggYG5ld2AnKTtcblx0ICAgICAgICB9XG5cblx0ICAgICAgICB0aGlzLmRlc2NyaXB0aW9uID0gXCJDb3VudGVyXCI7XG5cdCAgICAgICAgdGhpcy5uYW1lID0gXCJjdHJcIjtcblxuXHQgICAgICAgIGlmICghKGNvdW50ZXIgaW5zdGFuY2VvZiBDb3VudGVyKSkge1xuXHQgICAgICAgICAgICBjb3VudGVyID0gbmV3IENvdW50ZXIoY291bnRlcik7XG5cdCAgICAgICAgfVxuXG5cdCAgICAgICAgdGhpcy5fY291bnRlciA9IGNvdW50ZXI7XG5cblx0ICAgICAgICB0aGlzLl9yZW1haW5pbmdDb3VudGVyID0gbnVsbDtcblx0ICAgICAgICB0aGlzLl9yZW1haW5pbmdDb3VudGVySW5kZXggPSAxNjtcblxuXHQgICAgICAgIHRoaXMuX2FlcyA9IG5ldyBBRVMoa2V5KTtcblx0ICAgIH07XG5cblx0ICAgIE1vZGVPZk9wZXJhdGlvbkNUUi5wcm90b3R5cGUuZW5jcnlwdCA9IGZ1bmN0aW9uKHBsYWludGV4dCkge1xuXHQgICAgICAgIHZhciBlbmNyeXB0ZWQgPSBjb2VyY2VBcnJheShwbGFpbnRleHQsIHRydWUpO1xuXG5cdCAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBlbmNyeXB0ZWQubGVuZ3RoOyBpKyspIHtcblx0ICAgICAgICAgICAgaWYgKHRoaXMuX3JlbWFpbmluZ0NvdW50ZXJJbmRleCA9PT0gMTYpIHtcblx0ICAgICAgICAgICAgICAgIHRoaXMuX3JlbWFpbmluZ0NvdW50ZXIgPSB0aGlzLl9hZXMuZW5jcnlwdCh0aGlzLl9jb3VudGVyLl9jb3VudGVyKTtcblx0ICAgICAgICAgICAgICAgIHRoaXMuX3JlbWFpbmluZ0NvdW50ZXJJbmRleCA9IDA7XG5cdCAgICAgICAgICAgICAgICB0aGlzLl9jb3VudGVyLmluY3JlbWVudCgpO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIGVuY3J5cHRlZFtpXSBePSB0aGlzLl9yZW1haW5pbmdDb3VudGVyW3RoaXMuX3JlbWFpbmluZ0NvdW50ZXJJbmRleCsrXTtcblx0ICAgICAgICB9XG5cblx0ICAgICAgICByZXR1cm4gZW5jcnlwdGVkO1xuXHQgICAgfTtcblxuXHQgICAgLy8gRGVjcnlwdGlvbiBpcyBzeW1ldHJpY1xuXHQgICAgTW9kZU9mT3BlcmF0aW9uQ1RSLnByb3RvdHlwZS5kZWNyeXB0ID0gTW9kZU9mT3BlcmF0aW9uQ1RSLnByb3RvdHlwZS5lbmNyeXB0O1xuXG5cblx0ICAgIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5cdCAgICAvLyBQYWRkaW5nXG5cblx0ICAgIC8vIFNlZTpodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjMjMxNVxuXHQgICAgZnVuY3Rpb24gcGtjczdwYWQoZGF0YSkge1xuXHQgICAgICAgIGRhdGEgPSBjb2VyY2VBcnJheShkYXRhLCB0cnVlKTtcblx0ICAgICAgICB2YXIgcGFkZGVyID0gMTYgLSAoZGF0YS5sZW5ndGggJSAxNik7XG5cdCAgICAgICAgdmFyIHJlc3VsdCA9IGNyZWF0ZUFycmF5KGRhdGEubGVuZ3RoICsgcGFkZGVyKTtcblx0ICAgICAgICBjb3B5QXJyYXkoZGF0YSwgcmVzdWx0KTtcblx0ICAgICAgICBmb3IgKHZhciBpID0gZGF0YS5sZW5ndGg7IGkgPCByZXN1bHQubGVuZ3RoOyBpKyspIHtcblx0ICAgICAgICAgICAgcmVzdWx0W2ldID0gcGFkZGVyO1xuXHQgICAgICAgIH1cblx0ICAgICAgICByZXR1cm4gcmVzdWx0O1xuXHQgICAgfVxuXG5cdCAgICBmdW5jdGlvbiBwa2NzN3N0cmlwKGRhdGEpIHtcblx0ICAgICAgICBkYXRhID0gY29lcmNlQXJyYXkoZGF0YSwgdHJ1ZSk7XG5cdCAgICAgICAgaWYgKGRhdGEubGVuZ3RoIDwgMTYpIHsgdGhyb3cgbmV3IEVycm9yKCdQS0NTIzcgaW52YWxpZCBsZW5ndGgnKTsgfVxuXG5cdCAgICAgICAgdmFyIHBhZGRlciA9IGRhdGFbZGF0YS5sZW5ndGggLSAxXTtcblx0ICAgICAgICBpZiAocGFkZGVyID4gMTYpIHsgdGhyb3cgbmV3IEVycm9yKCdQS0NTIzcgcGFkZGluZyBieXRlIG91dCBvZiByYW5nZScpOyB9XG5cblx0ICAgICAgICB2YXIgbGVuZ3RoID0gZGF0YS5sZW5ndGggLSBwYWRkZXI7XG5cdCAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwYWRkZXI7IGkrKykge1xuXHQgICAgICAgICAgICBpZiAoZGF0YVtsZW5ndGggKyBpXSAhPT0gcGFkZGVyKSB7XG5cdCAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1BLQ1MjNyBpbnZhbGlkIHBhZGRpbmcgYnl0ZScpO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfVxuXG5cdCAgICAgICAgdmFyIHJlc3VsdCA9IGNyZWF0ZUFycmF5KGxlbmd0aCk7XG5cdCAgICAgICAgY29weUFycmF5KGRhdGEsIHJlc3VsdCwgMCwgMCwgbGVuZ3RoKTtcblx0ICAgICAgICByZXR1cm4gcmVzdWx0O1xuXHQgICAgfVxuXG5cdCAgICAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXHQgICAgLy8gRXhwb3J0aW5nXG5cblxuXHQgICAgLy8gVGhlIGJsb2NrIGNpcGhlclxuXHQgICAgdmFyIGFlc2pzID0ge1xuXHQgICAgICAgIEFFUzogQUVTLFxuXHQgICAgICAgIENvdW50ZXI6IENvdW50ZXIsXG5cblx0ICAgICAgICBNb2RlT2ZPcGVyYXRpb246IHtcblx0ICAgICAgICAgICAgZWNiOiBNb2RlT2ZPcGVyYXRpb25FQ0IsXG5cdCAgICAgICAgICAgIGNiYzogTW9kZU9mT3BlcmF0aW9uQ0JDLFxuXHQgICAgICAgICAgICBjZmI6IE1vZGVPZk9wZXJhdGlvbkNGQixcblx0ICAgICAgICAgICAgb2ZiOiBNb2RlT2ZPcGVyYXRpb25PRkIsXG5cdCAgICAgICAgICAgIGN0cjogTW9kZU9mT3BlcmF0aW9uQ1RSXG5cdCAgICAgICAgfSxcblxuXHQgICAgICAgIHV0aWxzOiB7XG5cdCAgICAgICAgICAgIGhleDogY29udmVydEhleCxcblx0ICAgICAgICAgICAgdXRmODogY29udmVydFV0Zjhcblx0ICAgICAgICB9LFxuXG5cdCAgICAgICAgcGFkZGluZzoge1xuXHQgICAgICAgICAgICBwa2NzNzoge1xuXHQgICAgICAgICAgICAgICAgcGFkOiBwa2NzN3BhZCxcblx0ICAgICAgICAgICAgICAgIHN0cmlwOiBwa2NzN3N0cmlwXG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9LFxuXG5cdCAgICAgICAgX2FycmF5VGVzdDoge1xuXHQgICAgICAgICAgICBjb2VyY2VBcnJheTogY29lcmNlQXJyYXksXG5cdCAgICAgICAgICAgIGNyZWF0ZUFycmF5OiBjcmVhdGVBcnJheSxcblx0ICAgICAgICAgICAgY29weUFycmF5OiBjb3B5QXJyYXksXG5cdCAgICAgICAgfVxuXHQgICAgfTtcblxuXG5cdCAgICAvLyBub2RlLmpzXG5cdCAgICBpZiAoJ29iamVjdCcgIT09ICd1bmRlZmluZWQnKSB7XG5cdCAgICAgICAgbW9kdWxlLmV4cG9ydHMgPSBhZXNqcztcblxuXHQgICAgLy8gUmVxdWlyZUpTL0FNRFxuXHQgICAgLy8gaHR0cDovL3d3dy5yZXF1aXJlanMub3JnL2RvY3MvYXBpLmh0bWxcblx0ICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9hbWRqcy9hbWRqcy1hcGkvd2lraS9BTURcblx0ICAgIH0gZWxzZSBpZiAodHlwZW9mKHVuZGVmaW5lZCkgPT09ICdmdW5jdGlvbicgJiYgdW5kZWZpbmVkLmFtZCkge1xuXHQgICAgICAgIHVuZGVmaW5lZChhZXNqcyk7XG5cblx0ICAgIC8vIFdlYiBCcm93c2Vyc1xuXHQgICAgfSBlbHNlIHtcblxuXHQgICAgICAgIC8vIElmIHRoZXJlIHdhcyBhbiBleGlzdGluZyBsaWJyYXJ5IGF0IFwiYWVzanNcIiBtYWtlIHN1cmUgaXQncyBzdGlsbCBhdmFpbGFibGVcblx0ICAgICAgICBpZiAocm9vdC5hZXNqcykge1xuXHQgICAgICAgICAgICBhZXNqcy5fYWVzanMgPSByb290LmFlc2pzO1xuXHQgICAgICAgIH1cblxuXHQgICAgICAgIHJvb3QuYWVzanMgPSBhZXNqcztcblx0ICAgIH1cblxuXG5cdH0pKGNvbW1vbmpzR2xvYmFsKTtcblx0fSk7XG5cblx0dmFyIF92ZXJzaW9uJEEgPSBjcmVhdGVDb21tb25qc01vZHVsZShmdW5jdGlvbiAobW9kdWxlLCBleHBvcnRzKSB7XG5cdFwidXNlIHN0cmljdFwiO1xuXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5cdGV4cG9ydHMudmVyc2lvbiA9IHZvaWQgMDtcblx0ZXhwb3J0cy52ZXJzaW9uID0gXCJqc29uLXdhbGxldHMvNS41LjBcIjtcblxuXHR9KTtcblxuXHR2YXIgX3ZlcnNpb24kQiA9IC8qQF9fUFVSRV9fKi9nZXREZWZhdWx0RXhwb3J0RnJvbUNqcyhfdmVyc2lvbiRBKTtcblxuXHR2YXIgdXRpbHMkMSA9IGNyZWF0ZUNvbW1vbmpzTW9kdWxlKGZ1bmN0aW9uIChtb2R1bGUsIGV4cG9ydHMpIHtcblx0XCJ1c2Ugc3RyaWN0XCI7XG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcblx0ZXhwb3J0cy51dWlkVjQgPSBleHBvcnRzLnNlYXJjaFBhdGggPSBleHBvcnRzLmdldFBhc3N3b3JkID0gZXhwb3J0cy56cGFkID0gZXhwb3J0cy5sb29zZUFycmF5aWZ5ID0gdm9pZCAwO1xuXG5cblx0ZnVuY3Rpb24gbG9vc2VBcnJheWlmeShoZXhTdHJpbmcpIHtcblx0ICAgIGlmICh0eXBlb2YgKGhleFN0cmluZykgPT09ICdzdHJpbmcnICYmIGhleFN0cmluZy5zdWJzdHJpbmcoMCwgMikgIT09ICcweCcpIHtcblx0ICAgICAgICBoZXhTdHJpbmcgPSAnMHgnICsgaGV4U3RyaW5nO1xuXHQgICAgfVxuXHQgICAgcmV0dXJuICgwLCBsaWIkMS5hcnJheWlmeSkoaGV4U3RyaW5nKTtcblx0fVxuXHRleHBvcnRzLmxvb3NlQXJyYXlpZnkgPSBsb29zZUFycmF5aWZ5O1xuXHRmdW5jdGlvbiB6cGFkKHZhbHVlLCBsZW5ndGgpIHtcblx0ICAgIHZhbHVlID0gU3RyaW5nKHZhbHVlKTtcblx0ICAgIHdoaWxlICh2YWx1ZS5sZW5ndGggPCBsZW5ndGgpIHtcblx0ICAgICAgICB2YWx1ZSA9ICcwJyArIHZhbHVlO1xuXHQgICAgfVxuXHQgICAgcmV0dXJuIHZhbHVlO1xuXHR9XG5cdGV4cG9ydHMuenBhZCA9IHpwYWQ7XG5cdGZ1bmN0aW9uIGdldFBhc3N3b3JkKHBhc3N3b3JkKSB7XG5cdCAgICBpZiAodHlwZW9mIChwYXNzd29yZCkgPT09ICdzdHJpbmcnKSB7XG5cdCAgICAgICAgcmV0dXJuICgwLCBsaWIkOC50b1V0ZjhCeXRlcykocGFzc3dvcmQsIGxpYiQ4LlVuaWNvZGVOb3JtYWxpemF0aW9uRm9ybS5ORktDKTtcblx0ICAgIH1cblx0ICAgIHJldHVybiAoMCwgbGliJDEuYXJyYXlpZnkpKHBhc3N3b3JkKTtcblx0fVxuXHRleHBvcnRzLmdldFBhc3N3b3JkID0gZ2V0UGFzc3dvcmQ7XG5cdGZ1bmN0aW9uIHNlYXJjaFBhdGgob2JqZWN0LCBwYXRoKSB7XG5cdCAgICB2YXIgY3VycmVudENoaWxkID0gb2JqZWN0O1xuXHQgICAgdmFyIGNvbXBzID0gcGF0aC50b0xvd2VyQ2FzZSgpLnNwbGl0KCcvJyk7XG5cdCAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNvbXBzLmxlbmd0aDsgaSsrKSB7XG5cdCAgICAgICAgLy8gU2VhcmNoIGZvciBhIGNoaWxkIG9iamVjdCB3aXRoIGEgY2FzZS1pbnNlbnNpdGl2ZSBtYXRjaGluZyBrZXlcblx0ICAgICAgICB2YXIgbWF0Y2hpbmdDaGlsZCA9IG51bGw7XG5cdCAgICAgICAgZm9yICh2YXIga2V5IGluIGN1cnJlbnRDaGlsZCkge1xuXHQgICAgICAgICAgICBpZiAoa2V5LnRvTG93ZXJDYXNlKCkgPT09IGNvbXBzW2ldKSB7XG5cdCAgICAgICAgICAgICAgICBtYXRjaGluZ0NoaWxkID0gY3VycmVudENoaWxkW2tleV07XG5cdCAgICAgICAgICAgICAgICBicmVhaztcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH1cblx0ICAgICAgICAvLyBEaWRuJ3QgZmluZCBvbmUuIDonKFxuXHQgICAgICAgIGlmIChtYXRjaGluZ0NoaWxkID09PSBudWxsKSB7XG5cdCAgICAgICAgICAgIHJldHVybiBudWxsO1xuXHQgICAgICAgIH1cblx0ICAgICAgICAvLyBOb3cgY2hlY2sgdGhpcyBjaGlsZC4uLlxuXHQgICAgICAgIGN1cnJlbnRDaGlsZCA9IG1hdGNoaW5nQ2hpbGQ7XG5cdCAgICB9XG5cdCAgICByZXR1cm4gY3VycmVudENoaWxkO1xuXHR9XG5cdGV4cG9ydHMuc2VhcmNoUGF0aCA9IHNlYXJjaFBhdGg7XG5cdC8vIFNlZTogaHR0cHM6Ly93d3cuaWV0Zi5vcmcvcmZjL3JmYzQxMjIudHh0IChTZWN0aW9uIDQuNClcblx0ZnVuY3Rpb24gdXVpZFY0KHJhbmRvbUJ5dGVzKSB7XG5cdCAgICB2YXIgYnl0ZXMgPSAoMCwgbGliJDEuYXJyYXlpZnkpKHJhbmRvbUJ5dGVzKTtcblx0ICAgIC8vIFNlY3Rpb246IDQuMS4zOlxuXHQgICAgLy8gLSB0aW1lX2hpX2FuZF92ZXJzaW9uWzEyOjE2XSA9IDBiMDEwMFxuXHQgICAgYnl0ZXNbNl0gPSAoYnl0ZXNbNl0gJiAweDBmKSB8IDB4NDA7XG5cdCAgICAvLyBTZWN0aW9uIDQuNFxuXHQgICAgLy8gLSBjbG9ja19zZXFfaGlfYW5kX3Jlc2VydmVkWzZdID0gMGIwXG5cdCAgICAvLyAtIGNsb2NrX3NlcV9oaV9hbmRfcmVzZXJ2ZWRbN10gPSAwYjFcblx0ICAgIGJ5dGVzWzhdID0gKGJ5dGVzWzhdICYgMHgzZikgfCAweDgwO1xuXHQgICAgdmFyIHZhbHVlID0gKDAsIGxpYiQxLmhleGxpZnkpKGJ5dGVzKTtcblx0ICAgIHJldHVybiBbXG5cdCAgICAgICAgdmFsdWUuc3Vic3RyaW5nKDIsIDEwKSxcblx0ICAgICAgICB2YWx1ZS5zdWJzdHJpbmcoMTAsIDE0KSxcblx0ICAgICAgICB2YWx1ZS5zdWJzdHJpbmcoMTQsIDE4KSxcblx0ICAgICAgICB2YWx1ZS5zdWJzdHJpbmcoMTgsIDIyKSxcblx0ICAgICAgICB2YWx1ZS5zdWJzdHJpbmcoMjIsIDM0KSxcblx0ICAgIF0uam9pbihcIi1cIik7XG5cdH1cblx0ZXhwb3J0cy51dWlkVjQgPSB1dWlkVjQ7XG5cblx0fSk7XG5cblx0dmFyIHV0aWxzJDIgPSAvKkBfX1BVUkVfXyovZ2V0RGVmYXVsdEV4cG9ydEZyb21DanModXRpbHMkMSk7XG5cblx0dmFyIGNyb3dkc2FsZSA9IGNyZWF0ZUNvbW1vbmpzTW9kdWxlKGZ1bmN0aW9uIChtb2R1bGUsIGV4cG9ydHMpIHtcblx0XCJ1c2Ugc3RyaWN0XCI7XG5cdHZhciBfX2V4dGVuZHMgPSAoY29tbW9uanNHbG9iYWwgJiYgY29tbW9uanNHbG9iYWwuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuXHQgICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBmdW5jdGlvbiAoZCwgYikge1xuXHQgICAgICAgIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcblx0ICAgICAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuXHQgICAgICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoYiwgcCkpIGRbcF0gPSBiW3BdOyB9O1xuXHQgICAgICAgIHJldHVybiBleHRlbmRTdGF0aWNzKGQsIGIpO1xuXHQgICAgfTtcblx0ICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuXHQgICAgICAgIGlmICh0eXBlb2YgYiAhPT0gXCJmdW5jdGlvblwiICYmIGIgIT09IG51bGwpXG5cdCAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDbGFzcyBleHRlbmRzIHZhbHVlIFwiICsgU3RyaW5nKGIpICsgXCIgaXMgbm90IGEgY29uc3RydWN0b3Igb3IgbnVsbFwiKTtcblx0ICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuXHQgICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuXHQgICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcblx0ICAgIH07XG5cdH0pKCk7XG5cdHZhciBfX2ltcG9ydERlZmF1bHQgPSAoY29tbW9uanNHbG9iYWwgJiYgY29tbW9uanNHbG9iYWwuX19pbXBvcnREZWZhdWx0KSB8fCBmdW5jdGlvbiAobW9kKSB7XG5cdCAgICByZXR1cm4gKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgPyBtb2QgOiB7IFwiZGVmYXVsdFwiOiBtb2QgfTtcblx0fTtcblx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuXHRleHBvcnRzLmRlY3J5cHQgPSBleHBvcnRzLkNyb3dkc2FsZUFjY291bnQgPSB2b2lkIDA7XG5cdHZhciBhZXNfanNfMSA9IF9faW1wb3J0RGVmYXVsdChhZXNKcyk7XG5cblxuXG5cblxuXG5cblxuXHR2YXIgbG9nZ2VyID0gbmV3IGxpYi5Mb2dnZXIoX3ZlcnNpb24kQS52ZXJzaW9uKTtcblxuXHR2YXIgQ3Jvd2RzYWxlQWNjb3VudCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcblx0ICAgIF9fZXh0ZW5kcyhDcm93ZHNhbGVBY2NvdW50LCBfc3VwZXIpO1xuXHQgICAgZnVuY3Rpb24gQ3Jvd2RzYWxlQWNjb3VudCgpIHtcblx0ICAgICAgICByZXR1cm4gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG5cdCAgICB9XG5cdCAgICBDcm93ZHNhbGVBY2NvdW50LnByb3RvdHlwZS5pc0Nyb3dkc2FsZUFjY291bnQgPSBmdW5jdGlvbiAodmFsdWUpIHtcblx0ICAgICAgICByZXR1cm4gISEodmFsdWUgJiYgdmFsdWUuX2lzQ3Jvd2RzYWxlQWNjb3VudCk7XG5cdCAgICB9O1xuXHQgICAgcmV0dXJuIENyb3dkc2FsZUFjY291bnQ7XG5cdH0obGliJDMuRGVzY3JpcHRpb24pKTtcblx0ZXhwb3J0cy5Dcm93ZHNhbGVBY2NvdW50ID0gQ3Jvd2RzYWxlQWNjb3VudDtcblx0Ly8gU2VlOiBodHRwczovL2dpdGh1Yi5jb20vZXRoZXJldW0vcHlldGhzYWxldG9vbFxuXHRmdW5jdGlvbiBkZWNyeXB0KGpzb24sIHBhc3N3b3JkKSB7XG5cdCAgICB2YXIgZGF0YSA9IEpTT04ucGFyc2UoanNvbik7XG5cdCAgICBwYXNzd29yZCA9ICgwLCB1dGlscyQxLmdldFBhc3N3b3JkKShwYXNzd29yZCk7XG5cdCAgICAvLyBFdGhlcmV1bSBBZGRyZXNzXG5cdCAgICB2YXIgZXRoYWRkciA9ICgwLCBsaWIkNi5nZXRBZGRyZXNzKSgoMCwgdXRpbHMkMS5zZWFyY2hQYXRoKShkYXRhLCBcImV0aGFkZHJcIikpO1xuXHQgICAgLy8gRW5jcnlwdGVkIFNlZWRcblx0ICAgIHZhciBlbmNzZWVkID0gKDAsIHV0aWxzJDEubG9vc2VBcnJheWlmeSkoKDAsIHV0aWxzJDEuc2VhcmNoUGF0aCkoZGF0YSwgXCJlbmNzZWVkXCIpKTtcblx0ICAgIGlmICghZW5jc2VlZCB8fCAoZW5jc2VlZC5sZW5ndGggJSAxNikgIT09IDApIHtcblx0ICAgICAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwiaW52YWxpZCBlbmNzZWVkXCIsIFwianNvblwiLCBqc29uKTtcblx0ICAgIH1cblx0ICAgIHZhciBrZXkgPSAoMCwgbGliJDEuYXJyYXlpZnkpKCgwLCBsaWIkaS5wYmtkZjIpKHBhc3N3b3JkLCBwYXNzd29yZCwgMjAwMCwgMzIsIFwic2hhMjU2XCIpKS5zbGljZSgwLCAxNik7XG5cdCAgICB2YXIgaXYgPSBlbmNzZWVkLnNsaWNlKDAsIDE2KTtcblx0ICAgIHZhciBlbmNyeXB0ZWRTZWVkID0gZW5jc2VlZC5zbGljZSgxNik7XG5cdCAgICAvLyBEZWNyeXB0IHRoZSBzZWVkXG5cdCAgICB2YXIgYWVzQ2JjID0gbmV3IGFlc19qc18xLmRlZmF1bHQuTW9kZU9mT3BlcmF0aW9uLmNiYyhrZXksIGl2KTtcblx0ICAgIHZhciBzZWVkID0gYWVzX2pzXzEuZGVmYXVsdC5wYWRkaW5nLnBrY3M3LnN0cmlwKCgwLCBsaWIkMS5hcnJheWlmeSkoYWVzQ2JjLmRlY3J5cHQoZW5jcnlwdGVkU2VlZCkpKTtcblx0ICAgIC8vIFRoaXMgd2FsbGV0IGZvcm1hdCBpcyB3ZWlyZC4uLiBDb252ZXJ0IHRoZSBiaW5hcnkgZW5jb2RlZCBoZXggdG8gYSBzdHJpbmcuXG5cdCAgICB2YXIgc2VlZEhleCA9IFwiXCI7XG5cdCAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNlZWQubGVuZ3RoOyBpKyspIHtcblx0ICAgICAgICBzZWVkSGV4ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoc2VlZFtpXSk7XG5cdCAgICB9XG5cdCAgICB2YXIgc2VlZEhleEJ5dGVzID0gKDAsIGxpYiQ4LnRvVXRmOEJ5dGVzKShzZWVkSGV4KTtcblx0ICAgIHZhciBwcml2YXRlS2V5ID0gKDAsIGxpYiQ0LmtlY2NhazI1Nikoc2VlZEhleEJ5dGVzKTtcblx0ICAgIHJldHVybiBuZXcgQ3Jvd2RzYWxlQWNjb3VudCh7XG5cdCAgICAgICAgX2lzQ3Jvd2RzYWxlQWNjb3VudDogdHJ1ZSxcblx0ICAgICAgICBhZGRyZXNzOiBldGhhZGRyLFxuXHQgICAgICAgIHByaXZhdGVLZXk6IHByaXZhdGVLZXlcblx0ICAgIH0pO1xuXHR9XG5cdGV4cG9ydHMuZGVjcnlwdCA9IGRlY3J5cHQ7XG5cblx0fSk7XG5cblx0dmFyIGNyb3dkc2FsZSQxID0gLypAX19QVVJFX18qL2dldERlZmF1bHRFeHBvcnRGcm9tQ2pzKGNyb3dkc2FsZSk7XG5cblx0dmFyIGluc3BlY3QgPSBjcmVhdGVDb21tb25qc01vZHVsZShmdW5jdGlvbiAobW9kdWxlLCBleHBvcnRzKSB7XG5cdFwidXNlIHN0cmljdFwiO1xuXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5cdGV4cG9ydHMuZ2V0SnNvbldhbGxldEFkZHJlc3MgPSBleHBvcnRzLmlzS2V5c3RvcmVXYWxsZXQgPSBleHBvcnRzLmlzQ3Jvd2RzYWxlV2FsbGV0ID0gdm9pZCAwO1xuXG5cdGZ1bmN0aW9uIGlzQ3Jvd2RzYWxlV2FsbGV0KGpzb24pIHtcblx0ICAgIHZhciBkYXRhID0gbnVsbDtcblx0ICAgIHRyeSB7XG5cdCAgICAgICAgZGF0YSA9IEpTT04ucGFyc2UoanNvbik7XG5cdCAgICB9XG5cdCAgICBjYXRjaCAoZXJyb3IpIHtcblx0ICAgICAgICByZXR1cm4gZmFsc2U7XG5cdCAgICB9XG5cdCAgICByZXR1cm4gKGRhdGEuZW5jc2VlZCAmJiBkYXRhLmV0aGFkZHIpO1xuXHR9XG5cdGV4cG9ydHMuaXNDcm93ZHNhbGVXYWxsZXQgPSBpc0Nyb3dkc2FsZVdhbGxldDtcblx0ZnVuY3Rpb24gaXNLZXlzdG9yZVdhbGxldChqc29uKSB7XG5cdCAgICB2YXIgZGF0YSA9IG51bGw7XG5cdCAgICB0cnkge1xuXHQgICAgICAgIGRhdGEgPSBKU09OLnBhcnNlKGpzb24pO1xuXHQgICAgfVxuXHQgICAgY2F0Y2ggKGVycm9yKSB7XG5cdCAgICAgICAgcmV0dXJuIGZhbHNlO1xuXHQgICAgfVxuXHQgICAgaWYgKCFkYXRhLnZlcnNpb24gfHwgcGFyc2VJbnQoZGF0YS52ZXJzaW9uKSAhPT0gZGF0YS52ZXJzaW9uIHx8IHBhcnNlSW50KGRhdGEudmVyc2lvbikgIT09IDMpIHtcblx0ICAgICAgICByZXR1cm4gZmFsc2U7XG5cdCAgICB9XG5cdCAgICAvLyBAVE9ETzogUHV0IG1vcmUgY2hlY2tzIHRvIG1ha2Ugc3VyZSBpdCBoYXMga2RmLCBpdiBhbmQgYWxsIHRoYXQgZ29vZCBzdHVmZlxuXHQgICAgcmV0dXJuIHRydWU7XG5cdH1cblx0ZXhwb3J0cy5pc0tleXN0b3JlV2FsbGV0ID0gaXNLZXlzdG9yZVdhbGxldDtcblx0Ly9leHBvcnQgZnVuY3Rpb24gaXNKc29uV2FsbGV0KGpzb246IHN0cmluZyk6IGJvb2xlYW4ge1xuXHQvLyAgICByZXR1cm4gKGlzU2VjcmV0U3RvcmFnZVdhbGxldChqc29uKSB8fCBpc0Nyb3dkc2FsZVdhbGxldChqc29uKSk7XG5cdC8vfVxuXHRmdW5jdGlvbiBnZXRKc29uV2FsbGV0QWRkcmVzcyhqc29uKSB7XG5cdCAgICBpZiAoaXNDcm93ZHNhbGVXYWxsZXQoanNvbikpIHtcblx0ICAgICAgICB0cnkge1xuXHQgICAgICAgICAgICByZXR1cm4gKDAsIGxpYiQ2LmdldEFkZHJlc3MpKEpTT04ucGFyc2UoanNvbikuZXRoYWRkcik7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGNhdGNoIChlcnJvcikge1xuXHQgICAgICAgICAgICByZXR1cm4gbnVsbDtcblx0ICAgICAgICB9XG5cdCAgICB9XG5cdCAgICBpZiAoaXNLZXlzdG9yZVdhbGxldChqc29uKSkge1xuXHQgICAgICAgIHRyeSB7XG5cdCAgICAgICAgICAgIHJldHVybiAoMCwgbGliJDYuZ2V0QWRkcmVzcykoSlNPTi5wYXJzZShqc29uKS5hZGRyZXNzKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG5cdCAgICAgICAgICAgIHJldHVybiBudWxsO1xuXHQgICAgICAgIH1cblx0ICAgIH1cblx0ICAgIHJldHVybiBudWxsO1xuXHR9XG5cdGV4cG9ydHMuZ2V0SnNvbldhbGxldEFkZHJlc3MgPSBnZXRKc29uV2FsbGV0QWRkcmVzcztcblxuXHR9KTtcblxuXHR2YXIgaW5zcGVjdCQxID0gLypAX19QVVJFX18qL2dldERlZmF1bHRFeHBvcnRGcm9tQ2pzKGluc3BlY3QpO1xuXG5cdHZhciBzY3J5cHQgPSBjcmVhdGVDb21tb25qc01vZHVsZShmdW5jdGlvbiAobW9kdWxlLCBleHBvcnRzKSB7XG5cdFwidXNlIHN0cmljdFwiO1xuXG5cdChmdW5jdGlvbihyb290KSB7XG5cdCAgICBjb25zdCBNQVhfVkFMVUUgPSAweDdmZmZmZmZmO1xuXG5cdCAgICAvLyBUaGUgU0hBMjU2IGFuZCBQQktERjIgaW1wbGVtZW50YXRpb24gYXJlIGZyb20gc2NyeXB0LWFzeW5jLWpzOlxuXHQgICAgLy8gU2VlOiBodHRwczovL2dpdGh1Yi5jb20vZGNoZXN0L3NjcnlwdC1hc3luYy1qc1xuXHQgICAgZnVuY3Rpb24gU0hBMjU2KG0pIHtcblx0ICAgICAgICBjb25zdCBLID0gbmV3IFVpbnQzMkFycmF5KFtcblx0ICAgICAgICAgICAweDQyOGEyZjk4LCAweDcxMzc0NDkxLCAweGI1YzBmYmNmLCAweGU5YjVkYmE1LCAweDM5NTZjMjViLFxuXHQgICAgICAgICAgIDB4NTlmMTExZjEsIDB4OTIzZjgyYTQsIDB4YWIxYzVlZDUsIDB4ZDgwN2FhOTgsIDB4MTI4MzViMDEsXG5cdCAgICAgICAgICAgMHgyNDMxODViZSwgMHg1NTBjN2RjMywgMHg3MmJlNWQ3NCwgMHg4MGRlYjFmZSwgMHg5YmRjMDZhNyxcblx0ICAgICAgICAgICAweGMxOWJmMTc0LCAweGU0OWI2OWMxLCAweGVmYmU0Nzg2LCAweDBmYzE5ZGM2LCAweDI0MGNhMWNjLFxuXHQgICAgICAgICAgIDB4MmRlOTJjNmYsIDB4NGE3NDg0YWEsIDB4NWNiMGE5ZGMsIDB4NzZmOTg4ZGEsIDB4OTgzZTUxNTIsXG5cdCAgICAgICAgICAgMHhhODMxYzY2ZCwgMHhiMDAzMjdjOCwgMHhiZjU5N2ZjNywgMHhjNmUwMGJmMywgMHhkNWE3OTE0Nyxcblx0ICAgICAgICAgICAweDA2Y2E2MzUxLCAweDE0MjkyOTY3LCAweDI3YjcwYTg1LCAweDJlMWIyMTM4LCAweDRkMmM2ZGZjLFxuXHQgICAgICAgICAgIDB4NTMzODBkMTMsIDB4NjUwYTczNTQsIDB4NzY2YTBhYmIsIDB4ODFjMmM5MmUsIDB4OTI3MjJjODUsXG5cdCAgICAgICAgICAgMHhhMmJmZThhMSwgMHhhODFhNjY0YiwgMHhjMjRiOGI3MCwgMHhjNzZjNTFhMywgMHhkMTkyZTgxOSxcblx0ICAgICAgICAgICAweGQ2OTkwNjI0LCAweGY0MGUzNTg1LCAweDEwNmFhMDcwLCAweDE5YTRjMTE2LCAweDFlMzc2YzA4LFxuXHQgICAgICAgICAgIDB4Mjc0ODc3NGMsIDB4MzRiMGJjYjUsIDB4MzkxYzBjYjMsIDB4NGVkOGFhNGEsIDB4NWI5Y2NhNGYsXG5cdCAgICAgICAgICAgMHg2ODJlNmZmMywgMHg3NDhmODJlZSwgMHg3OGE1NjM2ZiwgMHg4NGM4NzgxNCwgMHg4Y2M3MDIwOCxcblx0ICAgICAgICAgICAweDkwYmVmZmZhLCAweGE0NTA2Y2ViLCAweGJlZjlhM2Y3LCAweGM2NzE3OGYyXG5cdCAgICAgICBdKTtcblxuXHQgICAgICAgIGxldCBoMCA9IDB4NmEwOWU2NjcsIGgxID0gMHhiYjY3YWU4NSwgaDIgPSAweDNjNmVmMzcyLCBoMyA9IDB4YTU0ZmY1M2E7XG5cdCAgICAgICAgbGV0IGg0ID0gMHg1MTBlNTI3ZiwgaDUgPSAweDliMDU2ODhjLCBoNiA9IDB4MWY4M2Q5YWIsIGg3ID0gMHg1YmUwY2QxOTtcblx0ICAgICAgICBjb25zdCB3ID0gbmV3IFVpbnQzMkFycmF5KDY0KTtcblxuXHQgICAgICAgIGZ1bmN0aW9uIGJsb2NrcyhwKSB7XG5cdCAgICAgICAgICAgIGxldCBvZmYgPSAwLCBsZW4gPSBwLmxlbmd0aDtcblx0ICAgICAgICAgICAgd2hpbGUgKGxlbiA+PSA2NCkge1xuXHQgICAgICAgICAgICAgICAgbGV0IGEgPSBoMCwgYiA9IGgxLCBjID0gaDIsIGQgPSBoMywgZSA9IGg0LCBmID0gaDUsIGcgPSBoNiwgaCA9IGg3LCB1LCBpLCBqLCB0MSwgdDI7XG5cblx0ICAgICAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCAxNjsgaSsrKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgaiA9IG9mZiArIGkqNDtcblx0ICAgICAgICAgICAgICAgICAgICB3W2ldID0gKChwW2pdICYgMHhmZik8PDI0KSB8ICgocFtqKzFdICYgMHhmZik8PDE2KSB8XG5cdCAgICAgICAgICAgICAgICAgICAgKChwW2orMl0gJiAweGZmKTw8OCkgfCAocFtqKzNdICYgMHhmZik7XG5cdCAgICAgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgICAgIGZvciAoaSA9IDE2OyBpIDwgNjQ7IGkrKykge1xuXHQgICAgICAgICAgICAgICAgICAgIHUgPSB3W2ktMl07XG5cdCAgICAgICAgICAgICAgICAgICAgdDEgPSAoKHU+Pj4xNykgfCAodTw8KDMyLTE3KSkpIF4gKCh1Pj4+MTkpIHwgKHU8PCgzMi0xOSkpKSBeICh1Pj4+MTApO1xuXG5cdCAgICAgICAgICAgICAgICAgICAgdSA9IHdbaS0xNV07XG5cdCAgICAgICAgICAgICAgICAgICAgdDIgPSAoKHU+Pj43KSB8ICh1PDwoMzItNykpKSBeICgodT4+PjE4KSB8ICh1PDwoMzItMTgpKSkgXiAodT4+PjMpO1xuXG5cdCAgICAgICAgICAgICAgICAgICAgd1tpXSA9ICgoKHQxICsgd1tpLTddKSB8IDApICsgKCh0MiArIHdbaS0xNl0pIHwgMCkpIHwgMDtcblx0ICAgICAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IDY0OyBpKyspIHtcblx0ICAgICAgICAgICAgICAgICAgICB0MSA9ICgoKCgoKGU+Pj42KSB8IChlPDwoMzItNikpKSBeICgoZT4+PjExKSB8IChlPDwoMzItMTEpKSkgXlxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgoZT4+PjI1KSB8IChlPDwoMzItMjUpKSkpICsgKChlICYgZikgXiAofmUgJiBnKSkpIHwgMCkgK1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICgoaCArICgoS1tpXSArIHdbaV0pIHwgMCkpIHwgMCkpIHwgMDtcblxuXHQgICAgICAgICAgICAgICAgICAgIHQyID0gKCgoKGE+Pj4yKSB8IChhPDwoMzItMikpKSBeICgoYT4+PjEzKSB8IChhPDwoMzItMTMpKSkgXlxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAoKGE+Pj4yMikgfCAoYTw8KDMyLTIyKSkpKSArICgoYSAmIGIpIF4gKGEgJiBjKSBeIChiICYgYykpKSB8IDA7XG5cblx0ICAgICAgICAgICAgICAgICAgICBoID0gZztcblx0ICAgICAgICAgICAgICAgICAgICBnID0gZjtcblx0ICAgICAgICAgICAgICAgICAgICBmID0gZTtcblx0ICAgICAgICAgICAgICAgICAgICBlID0gKGQgKyB0MSkgfCAwO1xuXHQgICAgICAgICAgICAgICAgICAgIGQgPSBjO1xuXHQgICAgICAgICAgICAgICAgICAgIGMgPSBiO1xuXHQgICAgICAgICAgICAgICAgICAgIGIgPSBhO1xuXHQgICAgICAgICAgICAgICAgICAgIGEgPSAodDEgKyB0MikgfCAwO1xuXHQgICAgICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgICAgICBoMCA9IChoMCArIGEpIHwgMDtcblx0ICAgICAgICAgICAgICAgIGgxID0gKGgxICsgYikgfCAwO1xuXHQgICAgICAgICAgICAgICAgaDIgPSAoaDIgKyBjKSB8IDA7XG5cdCAgICAgICAgICAgICAgICBoMyA9IChoMyArIGQpIHwgMDtcblx0ICAgICAgICAgICAgICAgIGg0ID0gKGg0ICsgZSkgfCAwO1xuXHQgICAgICAgICAgICAgICAgaDUgPSAoaDUgKyBmKSB8IDA7XG5cdCAgICAgICAgICAgICAgICBoNiA9IChoNiArIGcpIHwgMDtcblx0ICAgICAgICAgICAgICAgIGg3ID0gKGg3ICsgaCkgfCAwO1xuXG5cdCAgICAgICAgICAgICAgICBvZmYgKz0gNjQ7XG5cdCAgICAgICAgICAgICAgICBsZW4gLT0gNjQ7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9XG5cblx0ICAgICAgICBibG9ja3MobSk7XG5cblx0ICAgICAgICBsZXQgaSwgYnl0ZXNMZWZ0ID0gbS5sZW5ndGggJSA2NCxcblx0ICAgICAgICBiaXRMZW5IaSA9IChtLmxlbmd0aCAvIDB4MjAwMDAwMDApIHwgMCxcblx0ICAgICAgICBiaXRMZW5MbyA9IG0ubGVuZ3RoIDw8IDMsXG5cdCAgICAgICAgbnVtWmVyb3MgPSAoYnl0ZXNMZWZ0IDwgNTYpID8gNTYgOiAxMjAsXG5cdCAgICAgICAgcCA9IG0uc2xpY2UobS5sZW5ndGggLSBieXRlc0xlZnQsIG0ubGVuZ3RoKTtcblxuXHQgICAgICAgIHAucHVzaCgweDgwKTtcblx0ICAgICAgICBmb3IgKGkgPSBieXRlc0xlZnQgKyAxOyBpIDwgbnVtWmVyb3M7IGkrKykgeyBwLnB1c2goMCk7IH1cblx0ICAgICAgICBwLnB1c2goKGJpdExlbkhpID4+PiAyNCkgJiAweGZmKTtcblx0ICAgICAgICBwLnB1c2goKGJpdExlbkhpID4+PiAxNikgJiAweGZmKTtcblx0ICAgICAgICBwLnB1c2goKGJpdExlbkhpID4+PiA4KSAgJiAweGZmKTtcblx0ICAgICAgICBwLnB1c2goKGJpdExlbkhpID4+PiAwKSAgJiAweGZmKTtcblx0ICAgICAgICBwLnB1c2goKGJpdExlbkxvID4+PiAyNCkgJiAweGZmKTtcblx0ICAgICAgICBwLnB1c2goKGJpdExlbkxvID4+PiAxNikgJiAweGZmKTtcblx0ICAgICAgICBwLnB1c2goKGJpdExlbkxvID4+PiA4KSAgJiAweGZmKTtcblx0ICAgICAgICBwLnB1c2goKGJpdExlbkxvID4+PiAwKSAgJiAweGZmKTtcblxuXHQgICAgICAgIGJsb2NrcyhwKTtcblxuXHQgICAgICAgIHJldHVybiBbXG5cdCAgICAgICAgICAgIChoMCA+Pj4gMjQpICYgMHhmZiwgKGgwID4+PiAxNikgJiAweGZmLCAoaDAgPj4+IDgpICYgMHhmZiwgKGgwID4+PiAwKSAmIDB4ZmYsXG5cdCAgICAgICAgICAgIChoMSA+Pj4gMjQpICYgMHhmZiwgKGgxID4+PiAxNikgJiAweGZmLCAoaDEgPj4+IDgpICYgMHhmZiwgKGgxID4+PiAwKSAmIDB4ZmYsXG5cdCAgICAgICAgICAgIChoMiA+Pj4gMjQpICYgMHhmZiwgKGgyID4+PiAxNikgJiAweGZmLCAoaDIgPj4+IDgpICYgMHhmZiwgKGgyID4+PiAwKSAmIDB4ZmYsXG5cdCAgICAgICAgICAgIChoMyA+Pj4gMjQpICYgMHhmZiwgKGgzID4+PiAxNikgJiAweGZmLCAoaDMgPj4+IDgpICYgMHhmZiwgKGgzID4+PiAwKSAmIDB4ZmYsXG5cdCAgICAgICAgICAgIChoNCA+Pj4gMjQpICYgMHhmZiwgKGg0ID4+PiAxNikgJiAweGZmLCAoaDQgPj4+IDgpICYgMHhmZiwgKGg0ID4+PiAwKSAmIDB4ZmYsXG5cdCAgICAgICAgICAgIChoNSA+Pj4gMjQpICYgMHhmZiwgKGg1ID4+PiAxNikgJiAweGZmLCAoaDUgPj4+IDgpICYgMHhmZiwgKGg1ID4+PiAwKSAmIDB4ZmYsXG5cdCAgICAgICAgICAgIChoNiA+Pj4gMjQpICYgMHhmZiwgKGg2ID4+PiAxNikgJiAweGZmLCAoaDYgPj4+IDgpICYgMHhmZiwgKGg2ID4+PiAwKSAmIDB4ZmYsXG5cdCAgICAgICAgICAgIChoNyA+Pj4gMjQpICYgMHhmZiwgKGg3ID4+PiAxNikgJiAweGZmLCAoaDcgPj4+IDgpICYgMHhmZiwgKGg3ID4+PiAwKSAmIDB4ZmZcblx0ICAgICAgICBdO1xuXHQgICAgfVxuXG5cdCAgICBmdW5jdGlvbiBQQktERjJfSE1BQ19TSEEyNTZfT25lSXRlcihwYXNzd29yZCwgc2FsdCwgZGtMZW4pIHtcblx0ICAgICAgICAvLyBjb21wcmVzcyBwYXNzd29yZCBpZiBpdCdzIGxvbmdlciB0aGFuIGhhc2ggYmxvY2sgbGVuZ3RoXG5cdCAgICAgICAgcGFzc3dvcmQgPSAocGFzc3dvcmQubGVuZ3RoIDw9IDY0KSA/IHBhc3N3b3JkIDogU0hBMjU2KHBhc3N3b3JkKTtcblxuXHQgICAgICAgIGNvbnN0IGlubmVyTGVuID0gNjQgKyBzYWx0Lmxlbmd0aCArIDQ7XG5cdCAgICAgICAgY29uc3QgaW5uZXIgPSBuZXcgQXJyYXkoaW5uZXJMZW4pO1xuXHQgICAgICAgIGNvbnN0IG91dGVyS2V5ID0gbmV3IEFycmF5KDY0KTtcblxuXHQgICAgICAgIGxldCBpO1xuXHQgICAgICAgIGxldCBkayA9IFtdO1xuXG5cdCAgICAgICAgLy8gaW5uZXIgPSAocGFzc3dvcmQgXiBpcGFkKSB8fCBzYWx0IHx8IGNvdW50ZXJcblx0ICAgICAgICBmb3IgKGkgPSAwOyBpIDwgNjQ7IGkrKykgeyBpbm5lcltpXSA9IDB4MzY7IH1cblx0ICAgICAgICBmb3IgKGkgPSAwOyBpIDwgcGFzc3dvcmQubGVuZ3RoOyBpKyspIHsgaW5uZXJbaV0gXj0gcGFzc3dvcmRbaV07IH1cblx0ICAgICAgICBmb3IgKGkgPSAwOyBpIDwgc2FsdC5sZW5ndGg7IGkrKykgeyBpbm5lcls2NCArIGldID0gc2FsdFtpXTsgfVxuXHQgICAgICAgIGZvciAoaSA9IGlubmVyTGVuIC0gNDsgaSA8IGlubmVyTGVuOyBpKyspIHsgaW5uZXJbaV0gPSAwOyB9XG5cblx0ICAgICAgICAvLyBvdXRlcktleSA9IHBhc3N3b3JkIF4gb3BhZFxuXHQgICAgICAgIGZvciAoaSA9IDA7IGkgPCA2NDsgaSsrKSBvdXRlcktleVtpXSA9IDB4NWM7XG5cdCAgICAgICAgZm9yIChpID0gMDsgaSA8IHBhc3N3b3JkLmxlbmd0aDsgaSsrKSBvdXRlcktleVtpXSBePSBwYXNzd29yZFtpXTtcblxuXHQgICAgICAgIC8vIGluY3JlbWVudHMgY291bnRlciBpbnNpZGUgaW5uZXJcblx0ICAgICAgICBmdW5jdGlvbiBpbmNyZW1lbnRDb3VudGVyKCkge1xuXHQgICAgICAgICAgICBmb3IgKGxldCBpID0gaW5uZXJMZW4gLSAxOyBpID49IGlubmVyTGVuIC0gNDsgaS0tKSB7XG5cdCAgICAgICAgICAgICAgICBpbm5lcltpXSsrO1xuXHQgICAgICAgICAgICAgICAgaWYgKGlubmVyW2ldIDw9IDB4ZmYpIHJldHVybjtcblx0ICAgICAgICAgICAgICAgIGlubmVyW2ldID0gMDtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH1cblxuXHQgICAgICAgIC8vIG91dHB1dCBibG9ja3MgPSBTSEEyNTYob3V0ZXJLZXkgfHwgU0hBMjU2KGlubmVyKSkgLi4uXG5cdCAgICAgICAgd2hpbGUgKGRrTGVuID49IDMyKSB7XG5cdCAgICAgICAgICAgIGluY3JlbWVudENvdW50ZXIoKTtcblx0ICAgICAgICAgICAgZGsgPSBkay5jb25jYXQoU0hBMjU2KG91dGVyS2V5LmNvbmNhdChTSEEyNTYoaW5uZXIpKSkpO1xuXHQgICAgICAgICAgICBka0xlbiAtPSAzMjtcblx0ICAgICAgICB9XG5cdCAgICAgICAgaWYgKGRrTGVuID4gMCkge1xuXHQgICAgICAgICAgICBpbmNyZW1lbnRDb3VudGVyKCk7XG5cdCAgICAgICAgICAgIGRrID0gZGsuY29uY2F0KFNIQTI1NihvdXRlcktleS5jb25jYXQoU0hBMjU2KGlubmVyKSkpLnNsaWNlKDAsIGRrTGVuKSk7XG5cdCAgICAgICAgfVxuXG5cdCAgICAgICAgcmV0dXJuIGRrO1xuXHQgICAgfVxuXG5cdCAgICAvLyBUaGUgZm9sbG93aW5nIGlzIGFuIGFkYXB0YXRpb24gb2Ygc2NyeXB0c3lcblx0ICAgIC8vIFNlZTogaHR0cHM6Ly93d3cubnBtanMuY29tL3BhY2thZ2Uvc2NyeXB0c3lcblx0ICAgIGZ1bmN0aW9uIGJsb2NrbWl4X3NhbHNhOChCWSwgWWksIHIsIHgsIF9YKSB7XG5cdCAgICAgICAgbGV0IGk7XG5cblx0ICAgICAgICBhcnJheWNvcHkoQlksICgyICogciAtIDEpICogMTYsIF9YLCAwLCAxNik7XG5cdCAgICAgICAgZm9yIChpID0gMDsgaSA8IDIgKiByOyBpKyspIHtcblx0ICAgICAgICAgICAgYmxvY2t4b3IoQlksIGkgKiAxNiwgX1gsIDE2KTtcblx0ICAgICAgICAgICAgc2Fsc2EyMF84KF9YLCB4KTtcblx0ICAgICAgICAgICAgYXJyYXljb3B5KF9YLCAwLCBCWSwgWWkgKyAoaSAqIDE2KSwgMTYpO1xuXHQgICAgICAgIH1cblxuXHQgICAgICAgIGZvciAoaSA9IDA7IGkgPCByOyBpKyspIHtcblx0ICAgICAgICAgICAgYXJyYXljb3B5KEJZLCBZaSArIChpICogMikgKiAxNiwgQlksIChpICogMTYpLCAxNik7XG5cdCAgICAgICAgfVxuXG5cdCAgICAgICAgZm9yIChpID0gMDsgaSA8IHI7IGkrKykge1xuXHQgICAgICAgICAgICBhcnJheWNvcHkoQlksIFlpICsgKGkgKiAyICsgMSkgKiAxNiwgQlksIChpICsgcikgKiAxNiwgMTYpO1xuXHQgICAgICAgIH1cblx0ICAgIH1cblxuXHQgICAgZnVuY3Rpb24gUihhLCBiKSB7XG5cdCAgICAgICAgcmV0dXJuIChhIDw8IGIpIHwgKGEgPj4+ICgzMiAtIGIpKTtcblx0ICAgIH1cblxuXHQgICAgZnVuY3Rpb24gc2Fsc2EyMF84KEIsIHgpIHtcblx0ICAgICAgICBhcnJheWNvcHkoQiwgMCwgeCwgMCwgMTYpO1xuXG5cdCAgICAgICAgZm9yIChsZXQgaSA9IDg7IGkgPiAwOyBpIC09IDIpIHtcblx0ICAgICAgICAgICAgeFsgNF0gXj0gUih4WyAwXSArIHhbMTJdLCA3KTtcblx0ICAgICAgICAgICAgeFsgOF0gXj0gUih4WyA0XSArIHhbIDBdLCA5KTtcblx0ICAgICAgICAgICAgeFsxMl0gXj0gUih4WyA4XSArIHhbIDRdLCAxMyk7XG5cdCAgICAgICAgICAgIHhbIDBdIF49IFIoeFsxMl0gKyB4WyA4XSwgMTgpO1xuXHQgICAgICAgICAgICB4WyA5XSBePSBSKHhbIDVdICsgeFsgMV0sIDcpO1xuXHQgICAgICAgICAgICB4WzEzXSBePSBSKHhbIDldICsgeFsgNV0sIDkpO1xuXHQgICAgICAgICAgICB4WyAxXSBePSBSKHhbMTNdICsgeFsgOV0sIDEzKTtcblx0ICAgICAgICAgICAgeFsgNV0gXj0gUih4WyAxXSArIHhbMTNdLCAxOCk7XG5cdCAgICAgICAgICAgIHhbMTRdIF49IFIoeFsxMF0gKyB4WyA2XSwgNyk7XG5cdCAgICAgICAgICAgIHhbIDJdIF49IFIoeFsxNF0gKyB4WzEwXSwgOSk7XG5cdCAgICAgICAgICAgIHhbIDZdIF49IFIoeFsgMl0gKyB4WzE0XSwgMTMpO1xuXHQgICAgICAgICAgICB4WzEwXSBePSBSKHhbIDZdICsgeFsgMl0sIDE4KTtcblx0ICAgICAgICAgICAgeFsgM10gXj0gUih4WzE1XSArIHhbMTFdLCA3KTtcblx0ICAgICAgICAgICAgeFsgN10gXj0gUih4WyAzXSArIHhbMTVdLCA5KTtcblx0ICAgICAgICAgICAgeFsxMV0gXj0gUih4WyA3XSArIHhbIDNdLCAxMyk7XG5cdCAgICAgICAgICAgIHhbMTVdIF49IFIoeFsxMV0gKyB4WyA3XSwgMTgpO1xuXHQgICAgICAgICAgICB4WyAxXSBePSBSKHhbIDBdICsgeFsgM10sIDcpO1xuXHQgICAgICAgICAgICB4WyAyXSBePSBSKHhbIDFdICsgeFsgMF0sIDkpO1xuXHQgICAgICAgICAgICB4WyAzXSBePSBSKHhbIDJdICsgeFsgMV0sIDEzKTtcblx0ICAgICAgICAgICAgeFsgMF0gXj0gUih4WyAzXSArIHhbIDJdLCAxOCk7XG5cdCAgICAgICAgICAgIHhbIDZdIF49IFIoeFsgNV0gKyB4WyA0XSwgNyk7XG5cdCAgICAgICAgICAgIHhbIDddIF49IFIoeFsgNl0gKyB4WyA1XSwgOSk7XG5cdCAgICAgICAgICAgIHhbIDRdIF49IFIoeFsgN10gKyB4WyA2XSwgMTMpO1xuXHQgICAgICAgICAgICB4WyA1XSBePSBSKHhbIDRdICsgeFsgN10sIDE4KTtcblx0ICAgICAgICAgICAgeFsxMV0gXj0gUih4WzEwXSArIHhbIDldLCA3KTtcblx0ICAgICAgICAgICAgeFsgOF0gXj0gUih4WzExXSArIHhbMTBdLCA5KTtcblx0ICAgICAgICAgICAgeFsgOV0gXj0gUih4WyA4XSArIHhbMTFdLCAxMyk7XG5cdCAgICAgICAgICAgIHhbMTBdIF49IFIoeFsgOV0gKyB4WyA4XSwgMTgpO1xuXHQgICAgICAgICAgICB4WzEyXSBePSBSKHhbMTVdICsgeFsxNF0sIDcpO1xuXHQgICAgICAgICAgICB4WzEzXSBePSBSKHhbMTJdICsgeFsxNV0sIDkpO1xuXHQgICAgICAgICAgICB4WzE0XSBePSBSKHhbMTNdICsgeFsxMl0sIDEzKTtcblx0ICAgICAgICAgICAgeFsxNV0gXj0gUih4WzE0XSArIHhbMTNdLCAxOCk7XG5cdCAgICAgICAgfVxuXG5cdCAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCAxNjsgKytpKSB7XG5cdCAgICAgICAgICAgIEJbaV0gKz0geFtpXTtcblx0ICAgICAgICB9XG5cdCAgICB9XG5cblx0ICAgIC8vIG5haXZlIGFwcHJvYWNoLi4uIGdvaW5nIGJhY2sgdG8gbG9vcCB1bnJvbGxpbmcgbWF5IHlpZWxkIGFkZGl0aW9uYWwgcGVyZm9ybWFuY2Vcblx0ICAgIGZ1bmN0aW9uIGJsb2NreG9yKFMsIFNpLCBELCBsZW4pIHtcblx0ICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG5cdCAgICAgICAgICAgIERbaV0gXj0gU1tTaSArIGldO1xuXHQgICAgICAgIH1cblx0ICAgIH1cblxuXHQgICAgZnVuY3Rpb24gYXJyYXljb3B5KHNyYywgc3JjUG9zLCBkZXN0LCBkZXN0UG9zLCBsZW5ndGgpIHtcblx0ICAgICAgICB3aGlsZSAobGVuZ3RoLS0pIHtcblx0ICAgICAgICAgICAgZGVzdFtkZXN0UG9zKytdID0gc3JjW3NyY1BvcysrXTtcblx0ICAgICAgICB9XG5cdCAgICB9XG5cblx0ICAgIGZ1bmN0aW9uIGNoZWNrQnVmZmVyaXNoKG8pIHtcblx0ICAgICAgICBpZiAoIW8gfHwgdHlwZW9mKG8ubGVuZ3RoKSAhPT0gJ251bWJlcicpIHsgcmV0dXJuIGZhbHNlOyB9XG5cblx0ICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG8ubGVuZ3RoOyBpKyspIHtcblx0ICAgICAgICAgICAgY29uc3QgdiA9IG9baV07XG5cdCAgICAgICAgICAgIGlmICh0eXBlb2YodikgIT09ICdudW1iZXInIHx8IHYgJSAxIHx8IHYgPCAwIHx8IHYgPj0gMjU2KSB7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9XG5cblx0ICAgICAgICByZXR1cm4gdHJ1ZTtcblx0ICAgIH1cblxuXHQgICAgZnVuY3Rpb24gZW5zdXJlSW50ZWdlcih2YWx1ZSwgbmFtZSkge1xuXHQgICAgICAgIGlmICh0eXBlb2YodmFsdWUpICE9PSBcIm51bWJlclwiIHx8ICh2YWx1ZSAlIDEpKSB7IHRocm93IG5ldyBFcnJvcignaW52YWxpZCAnICsgbmFtZSk7IH1cblx0ICAgICAgICByZXR1cm4gdmFsdWU7XG5cdCAgICB9XG5cblx0ICAgIC8vIE4gPSBDcHUgY29zdCwgciA9IE1lbW9yeSBjb3N0LCBwID0gcGFyYWxsZWxpemF0aW9uIGNvc3Rcblx0ICAgIC8vIGNhbGxiYWNrKGVycm9yLCBwcm9ncmVzcywga2V5KVxuXHQgICAgZnVuY3Rpb24gX3NjcnlwdChwYXNzd29yZCwgc2FsdCwgTiwgciwgcCwgZGtMZW4sIGNhbGxiYWNrKSB7XG5cblx0ICAgICAgICBOID0gZW5zdXJlSW50ZWdlcihOLCAnTicpO1xuXHQgICAgICAgIHIgPSBlbnN1cmVJbnRlZ2VyKHIsICdyJyk7XG5cdCAgICAgICAgcCA9IGVuc3VyZUludGVnZXIocCwgJ3AnKTtcblxuXHQgICAgICAgIGRrTGVuID0gZW5zdXJlSW50ZWdlcihka0xlbiwgJ2RrTGVuJyk7XG5cblx0ICAgICAgICBpZiAoTiA9PT0gMCB8fCAoTiAmIChOIC0gMSkpICE9PSAwKSB7IHRocm93IG5ldyBFcnJvcignTiBtdXN0IGJlIHBvd2VyIG9mIDInKTsgfVxuXG5cdCAgICAgICAgaWYgKE4gPiBNQVhfVkFMVUUgLyAxMjggLyByKSB7IHRocm93IG5ldyBFcnJvcignTiB0b28gbGFyZ2UnKTsgfVxuXHQgICAgICAgIGlmIChyID4gTUFYX1ZBTFVFIC8gMTI4IC8gcCkgeyB0aHJvdyBuZXcgRXJyb3IoJ3IgdG9vIGxhcmdlJyk7IH1cblxuXHQgICAgICAgIGlmICghY2hlY2tCdWZmZXJpc2gocGFzc3dvcmQpKSB7XG5cdCAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigncGFzc3dvcmQgbXVzdCBiZSBhbiBhcnJheSBvciBidWZmZXInKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgcGFzc3dvcmQgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChwYXNzd29yZCk7XG5cblx0ICAgICAgICBpZiAoIWNoZWNrQnVmZmVyaXNoKHNhbHQpKSB7XG5cdCAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignc2FsdCBtdXN0IGJlIGFuIGFycmF5IG9yIGJ1ZmZlcicpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBzYWx0ID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoc2FsdCk7XG5cblx0ICAgICAgICBsZXQgYiA9IFBCS0RGMl9ITUFDX1NIQTI1Nl9PbmVJdGVyKHBhc3N3b3JkLCBzYWx0LCBwICogMTI4ICogcik7XG5cdCAgICAgICAgY29uc3QgQiA9IG5ldyBVaW50MzJBcnJheShwICogMzIgKiByKTtcblx0ICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IEIubGVuZ3RoOyBpKyspIHtcblx0ICAgICAgICAgICAgY29uc3QgaiA9IGkgKiA0O1xuXHQgICAgICAgICAgICBCW2ldID0gKChiW2ogKyAzXSAmIDB4ZmYpIDw8IDI0KSB8XG5cdCAgICAgICAgICAgICAgICAgICAoKGJbaiArIDJdICYgMHhmZikgPDwgMTYpIHxcblx0ICAgICAgICAgICAgICAgICAgICgoYltqICsgMV0gJiAweGZmKSA8PCA4KSB8XG5cdCAgICAgICAgICAgICAgICAgICAoKGJbaiArIDBdICYgMHhmZikgPDwgMCk7XG5cdCAgICAgICAgfVxuXG5cdCAgICAgICAgY29uc3QgWFkgPSBuZXcgVWludDMyQXJyYXkoNjQgKiByKTtcblx0ICAgICAgICBjb25zdCBWID0gbmV3IFVpbnQzMkFycmF5KDMyICogciAqIE4pO1xuXG5cdCAgICAgICAgY29uc3QgWWkgPSAzMiAqIHI7XG5cblx0ICAgICAgICAvLyBzY3JhdGNoIHNwYWNlXG5cdCAgICAgICAgY29uc3QgeCA9IG5ldyBVaW50MzJBcnJheSgxNik7ICAgICAgIC8vIHNhbHNhMjBfOFxuXHQgICAgICAgIGNvbnN0IF9YID0gbmV3IFVpbnQzMkFycmF5KDE2KTsgICAgICAvLyBibG9ja21peF9zYWxzYThcblxuXHQgICAgICAgIGNvbnN0IHRvdGFsT3BzID0gcCAqIE4gKiAyO1xuXHQgICAgICAgIGxldCBjdXJyZW50T3AgPSAwO1xuXHQgICAgICAgIGxldCBsYXN0UGVyY2VudDEwID0gbnVsbDtcblxuXHQgICAgICAgIC8vIFNldCB0aGlzIHRvIHRydWUgdG8gYWJhbmRvbiB0aGUgc2NyeXB0IG9uIHRoZSBuZXh0IHN0ZXBcblx0ICAgICAgICBsZXQgc3RvcCA9IGZhbHNlO1xuXG5cdCAgICAgICAgLy8gU3RhdGUgaW5mb3JtYXRpb25cblx0ICAgICAgICBsZXQgc3RhdGUgPSAwO1xuXHQgICAgICAgIGxldCBpMCA9IDAsIGkxO1xuXHQgICAgICAgIGxldCBCaTtcblxuXHQgICAgICAgIC8vIEhvdyBtYW55IGJsb2NrbWl4X3NhbHNhOCBjYW4gd2UgZG8gcGVyIHN0ZXA/XG5cdCAgICAgICAgY29uc3QgbGltaXQgPSBjYWxsYmFjayA/IHBhcnNlSW50KDEwMDAgLyByKTogMHhmZmZmZmZmZjtcblxuXHQgICAgICAgIC8vIFRyaWNrIGZyb20gc2NyeXB0LWFzeW5jOyBpZiB0aGVyZSBpcyBhIHNldEltbWVkaWF0ZSBzaGltIGluIHBsYWNlLCB1c2UgaXRcblx0ICAgICAgICBjb25zdCBuZXh0VGljayA9ICh0eXBlb2Yoc2V0SW1tZWRpYXRlKSAhPT0gJ3VuZGVmaW5lZCcpID8gc2V0SW1tZWRpYXRlIDogc2V0VGltZW91dDtcblxuXHQgICAgICAgIC8vIFRoaXMgaXMgcmVhbGx5IGFsbCBJIGNoYW5nZWQ7IG1ha2luZyBzY3J5cHRzeSBhIHN0YXRlIG1hY2hpbmUgc28gd2Ugb2NjYXNpb25hbGx5XG5cdCAgICAgICAgLy8gc3RvcCBhbmQgZ2l2ZSBvdGhlciBldm50cyBvbiB0aGUgZXZudCBsb29wIGEgY2hhbmNlIHRvIHJ1bi4gflJpY01vb1xuXHQgICAgICAgIGNvbnN0IGluY3JlbWVudGFsU01peCA9IGZ1bmN0aW9uKCkge1xuXHQgICAgICAgICAgICBpZiAoc3RvcCkge1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKG5ldyBFcnJvcignY2FuY2VsbGVkJyksIGN1cnJlbnRPcCAvIHRvdGFsT3BzKTtcblx0ICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgIGxldCBzdGVwcztcblxuXHQgICAgICAgICAgICBzd2l0Y2ggKHN0YXRlKSB7XG5cdCAgICAgICAgICAgICAgICBjYXNlIDA6XG5cdCAgICAgICAgICAgICAgICAgICAgLy8gZm9yICh2YXIgaSA9IDA7IGkgPCBwOyBpKyspLi4uXG5cdCAgICAgICAgICAgICAgICAgICAgQmkgPSBpMCAqIDMyICogcjtcblxuXHQgICAgICAgICAgICAgICAgICAgIGFycmF5Y29weShCLCBCaSwgWFksIDAsIFlpKTsgICAgICAgICAgICAgICAgICAgICAgIC8vIFJPTWl4IC0gMVxuXG5cdCAgICAgICAgICAgICAgICAgICAgc3RhdGUgPSAxOyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gTW92ZSB0byBST01peCAyXG5cdCAgICAgICAgICAgICAgICAgICAgaTEgPSAwO1xuXG5cdCAgICAgICAgICAgICAgICAgICAgLy8gRmFsbCB0aHJvdWdoXG5cblx0ICAgICAgICAgICAgICAgIGNhc2UgMTpcblxuXHQgICAgICAgICAgICAgICAgICAgIC8vIFJ1biB1cCB0byAxMDAwIHN0ZXBzIG9mIHRoZSBmaXJzdCBpbm5lciBzbWl4IGxvb3Bcblx0ICAgICAgICAgICAgICAgICAgICBzdGVwcyA9IE4gLSBpMTtcblx0ICAgICAgICAgICAgICAgICAgICBpZiAoc3RlcHMgPiBsaW1pdCkgeyBzdGVwcyA9IGxpbWl0OyB9XG5cdCAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzdGVwczsgaSsrKSB7ICAgICAgICAgICAgICAgICAgLy8gUk9NaXggLSAyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGFycmF5Y29weShYWSwgMCwgViwgKGkxICsgaSkgKiBZaSwgWWkpOyAgICAgICAgIC8vIFJPTWl4IC0gM1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBibG9ja21peF9zYWxzYTgoWFksIFlpLCByLCB4LCBfWCk7ICAgICAgICAgICAgIC8vIFJPTWl4IC0gNFxuXHQgICAgICAgICAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICAgICAgICAgIC8vIGZvciAodmFyIGkgPSAwOyBpIDwgTjsgaSsrKVxuXHQgICAgICAgICAgICAgICAgICAgIGkxICs9IHN0ZXBzO1xuXHQgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRPcCArPSBzdGVwcztcblxuXHQgICAgICAgICAgICAgICAgICAgIGlmIChjYWxsYmFjaykge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAvLyBDYWxsIHRoZSBjYWxsYmFjayB3aXRoIHRoZSBwcm9ncmVzcyAob3B0aW9uYWxseSBzdG9wcGluZyB1cylcblx0ICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcGVyY2VudDEwID0gcGFyc2VJbnQoMTAwMCAqIGN1cnJlbnRPcCAvIHRvdGFsT3BzKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHBlcmNlbnQxMCAhPT0gbGFzdFBlcmNlbnQxMCkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RvcCA9IGNhbGxiYWNrKG51bGwsIGN1cnJlbnRPcCAvIHRvdGFsT3BzKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzdG9wKSB7IGJyZWFrOyB9XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBsYXN0UGVyY2VudDEwID0gcGVyY2VudDEwO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKGkxIDwgTikgeyBicmVhazsgfVxuXG5cdCAgICAgICAgICAgICAgICAgICAgaTEgPSAwOyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIE1vdmUgdG8gUk9NaXggNlxuXHQgICAgICAgICAgICAgICAgICAgIHN0YXRlID0gMjtcblxuXHQgICAgICAgICAgICAgICAgICAgIC8vIEZhbGwgdGhyb3VnaFxuXG5cdCAgICAgICAgICAgICAgICBjYXNlIDI6XG5cblx0ICAgICAgICAgICAgICAgICAgICAvLyBSdW4gdXAgdG8gMTAwMCBzdGVwcyBvZiB0aGUgc2Vjb25kIGlubmVyIHNtaXggbG9vcFxuXHQgICAgICAgICAgICAgICAgICAgIHN0ZXBzID0gTiAtIGkxO1xuXHQgICAgICAgICAgICAgICAgICAgIGlmIChzdGVwcyA+IGxpbWl0KSB7IHN0ZXBzID0gbGltaXQ7IH1cblx0ICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHN0ZXBzOyBpKyspIHsgICAgICAgICAgICAgICAgLy8gUk9NaXggLSA2XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IG9mZnNldCA9ICgyICogciAtIDEpICogMTY7ICAgICAgICAgICAgIC8vIFJPTWl4IC0gN1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBqID0gWFlbb2Zmc2V0XSAmIChOIC0gMSk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGJsb2NreG9yKFYsIGogKiBZaSwgWFksIFlpKTsgICAgICAgICAgICAgICAgIC8vIFJPTWl4IC0gOCAoaW5uZXIpXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGJsb2NrbWl4X3NhbHNhOChYWSwgWWksIHIsIHgsIF9YKTsgICAgICAgICAgIC8vIFJPTWl4IC0gOSAob3V0ZXIpXG5cdCAgICAgICAgICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgICAgICAgICAgLy8gZm9yICh2YXIgaSA9IDA7IGkgPCBOOyBpKyspLi4uXG5cdCAgICAgICAgICAgICAgICAgICAgaTEgKz0gc3RlcHM7XG5cdCAgICAgICAgICAgICAgICAgICAgY3VycmVudE9wICs9IHN0ZXBzO1xuXG5cdCAgICAgICAgICAgICAgICAgICAgLy8gQ2FsbCB0aGUgY2FsbGJhY2sgd2l0aCB0aGUgcHJvZ3Jlc3MgKG9wdGlvbmFsbHkgc3RvcHBpbmcgdXMpXG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKGNhbGxiYWNrKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHBlcmNlbnQxMCA9IHBhcnNlSW50KDEwMDAgKiBjdXJyZW50T3AgLyB0b3RhbE9wcyk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwZXJjZW50MTAgIT09IGxhc3RQZXJjZW50MTApIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0b3AgPSBjYWxsYmFjayhudWxsLCBjdXJyZW50T3AgLyB0b3RhbE9wcyk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoc3RvcCkgeyBicmVhazsgfVxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGFzdFBlcmNlbnQxMCA9IHBlcmNlbnQxMDtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICAgICAgICAgIGlmIChpMSA8IE4pIHsgYnJlYWs7IH1cblxuXHQgICAgICAgICAgICAgICAgICAgIGFycmF5Y29weShYWSwgMCwgQiwgQmksIFlpKTsgICAgICAgICAgICAgICAgICAgICAvLyBST01peCAtIDEwXG5cblx0ICAgICAgICAgICAgICAgICAgICAvLyBmb3IgKHZhciBpID0gMDsgaSA8IHA7IGkrKykuLi5cblx0ICAgICAgICAgICAgICAgICAgICBpMCsrO1xuXHQgICAgICAgICAgICAgICAgICAgIGlmIChpMCA8IHApIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGUgPSAwO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcblx0ICAgICAgICAgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgICAgICAgICBiID0gW107XG5cdCAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBCLmxlbmd0aDsgaSsrKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGIucHVzaCgoQltpXSA+PiAgMCkgJiAweGZmKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgYi5wdXNoKChCW2ldID4+ICA4KSAmIDB4ZmYpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBiLnB1c2goKEJbaV0gPj4gMTYpICYgMHhmZik7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGIucHVzaCgoQltpXSA+PiAyNCkgJiAweGZmKTtcblx0ICAgICAgICAgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgICAgICAgICBjb25zdCBkZXJpdmVkS2V5ID0gUEJLREYyX0hNQUNfU0hBMjU2X09uZUl0ZXIocGFzc3dvcmQsIGIsIGRrTGVuKTtcblxuXHQgICAgICAgICAgICAgICAgICAgIC8vIFNlbmQgdGhlIHJlc3VsdCB0byB0aGUgY2FsbGJhY2tcblx0ICAgICAgICAgICAgICAgICAgICBpZiAoY2FsbGJhY2spIHsgY2FsbGJhY2sobnVsbCwgMS4wLCBkZXJpdmVkS2V5KTsgfVxuXG5cdCAgICAgICAgICAgICAgICAgICAgLy8gRG9uZTsgZG9uJ3QgYnJlYWsgKHdoaWNoIHdvdWxkIHJlc2NoZWR1bGUpXG5cdCAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGRlcml2ZWRLZXk7XG5cdCAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICAvLyBTY2hlZHVsZSB0aGUgbmV4dCBzdGVwc1xuXHQgICAgICAgICAgICBpZiAoY2FsbGJhY2spIHsgbmV4dFRpY2soaW5jcmVtZW50YWxTTWl4KTsgfVxuXHQgICAgICAgIH07XG5cblx0ICAgICAgICAvLyBSdW4gdGhlIHNtaXggc3RhdGUgbWFjaGluZSB1bnRpbCBjb21wbGV0aW9uXG5cdCAgICAgICAgaWYgKCFjYWxsYmFjaykge1xuXHQgICAgICAgICAgICB3aGlsZSAodHJ1ZSkge1xuXHQgICAgICAgICAgICAgICAgY29uc3QgZGVyaXZlZEtleSA9IGluY3JlbWVudGFsU01peCgpO1xuXHQgICAgICAgICAgICAgICAgaWYgKGRlcml2ZWRLZXkgIT0gdW5kZWZpbmVkKSB7IHJldHVybiBkZXJpdmVkS2V5OyB9XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9XG5cblx0ICAgICAgICAvLyBCb290c3RyYXAgdGhlIGFzeW5jIGluY3JlbWVudGFsIHNtaXhcblx0ICAgICAgICBpbmNyZW1lbnRhbFNNaXgoKTtcblx0ICAgIH1cblxuXHQgICAgY29uc3QgbGliID0ge1xuXHQgICAgICAgIHNjcnlwdDogZnVuY3Rpb24ocGFzc3dvcmQsIHNhbHQsIE4sIHIsIHAsIGRrTGVuLCBwcm9ncmVzc0NhbGxiYWNrKSB7XG5cdCAgICAgICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHtcblx0ICAgICAgICAgICAgICAgIGxldCBsYXN0UHJvZ3Jlc3MgPSAwO1xuXHQgICAgICAgICAgICAgICAgaWYgKHByb2dyZXNzQ2FsbGJhY2spIHsgcHJvZ3Jlc3NDYWxsYmFjaygwKTsgfVxuXHQgICAgICAgICAgICAgICAgX3NjcnlwdChwYXNzd29yZCwgc2FsdCwgTiwgciwgcCwgZGtMZW4sIGZ1bmN0aW9uKGVycm9yLCBwcm9ncmVzcywga2V5KSB7XG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKGVycm9yKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJlamVjdChlcnJvcik7XG5cdCAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChrZXkpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHByb2dyZXNzQ2FsbGJhY2sgJiYgbGFzdFByb2dyZXNzICE9PSAxKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcm9ncmVzc0NhbGxiYWNrKDEpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmUobmV3IFVpbnQ4QXJyYXkoa2V5KSk7XG5cdCAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChwcm9ncmVzc0NhbGxiYWNrICYmIHByb2dyZXNzICE9PSBsYXN0UHJvZ3Jlc3MpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgbGFzdFByb2dyZXNzID0gcHJvZ3Jlc3M7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBwcm9ncmVzc0NhbGxiYWNrKHByb2dyZXNzKTtcblx0ICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICB9KTtcblx0ICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgfSxcblx0ICAgICAgICBzeW5jU2NyeXB0OiBmdW5jdGlvbihwYXNzd29yZCwgc2FsdCwgTiwgciwgcCwgZGtMZW4pIHtcblx0ICAgICAgICAgICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KF9zY3J5cHQocGFzc3dvcmQsIHNhbHQsIE4sIHIsIHAsIGRrTGVuKSk7XG5cdCAgICAgICAgfVxuXHQgICAgfTtcblxuXHQgICAgLy8gbm9kZS5qc1xuXHQgICAgaWYgKCdvYmplY3QnICE9PSAndW5kZWZpbmVkJykge1xuXHQgICAgICAgbW9kdWxlLmV4cG9ydHMgPSBsaWI7XG5cblx0ICAgIC8vIFJlcXVpcmVKUy9BTURcblx0ICAgIC8vIGh0dHA6Ly93d3cucmVxdWlyZWpzLm9yZy9kb2NzL2FwaS5odG1sXG5cdCAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vYW1kanMvYW1kanMtYXBpL3dpa2kvQU1EXG5cdCAgICB9IGVsc2UgaWYgKHR5cGVvZih1bmRlZmluZWQpID09PSAnZnVuY3Rpb24nICYmIHVuZGVmaW5lZC5hbWQpIHtcblx0ICAgICAgICB1bmRlZmluZWQobGliKTtcblxuXHQgICAgLy8gV2ViIEJyb3dzZXJzXG5cdCAgICB9IGVsc2UgaWYgKHJvb3QpIHtcblxuXHQgICAgICAgIC8vIElmIHRoZXJlIHdhcyBhbiBleGlzdGluZyBsaWJyYXJ5IFwic2NyeXB0XCIsIG1ha2Ugc3VyZSBpdCBpcyBzdGlsbCBhdmFpbGFibGVcblx0ICAgICAgICBpZiAocm9vdC5zY3J5cHQpIHtcblx0ICAgICAgICAgICAgcm9vdC5fc2NyeXB0ID0gcm9vdC5zY3J5cHQ7XG5cdCAgICAgICAgfVxuXG5cdCAgICAgICAgcm9vdC5zY3J5cHQgPSBsaWI7XG5cdCAgICB9XG5cblx0fSkoY29tbW9uanNHbG9iYWwpO1xuXHR9KTtcblxuXHR2YXIga2V5c3RvcmUgPSBjcmVhdGVDb21tb25qc01vZHVsZShmdW5jdGlvbiAobW9kdWxlLCBleHBvcnRzKSB7XG5cdFwidXNlIHN0cmljdFwiO1xuXHR2YXIgX19leHRlbmRzID0gKGNvbW1vbmpzR2xvYmFsICYmIGNvbW1vbmpzR2xvYmFsLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcblx0ICAgIHZhciBleHRlbmRTdGF0aWNzID0gZnVuY3Rpb24gKGQsIGIpIHtcblx0ICAgICAgICBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG5cdCAgICAgICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcblx0ICAgICAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGIsIHApKSBkW3BdID0gYltwXTsgfTtcblx0ICAgICAgICByZXR1cm4gZXh0ZW5kU3RhdGljcyhkLCBiKTtcblx0ICAgIH07XG5cdCAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcblx0ICAgICAgICBpZiAodHlwZW9mIGIgIT09IFwiZnVuY3Rpb25cIiAmJiBiICE9PSBudWxsKVxuXHQgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2xhc3MgZXh0ZW5kcyB2YWx1ZSBcIiArIFN0cmluZyhiKSArIFwiIGlzIG5vdCBhIGNvbnN0cnVjdG9yIG9yIG51bGxcIik7XG5cdCAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcblx0ICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cblx0ICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG5cdCAgICB9O1xuXHR9KSgpO1xuXHR2YXIgX19hd2FpdGVyID0gKGNvbW1vbmpzR2xvYmFsICYmIGNvbW1vbmpzR2xvYmFsLl9fYXdhaXRlcikgfHwgZnVuY3Rpb24gKHRoaXNBcmcsIF9hcmd1bWVudHMsIFAsIGdlbmVyYXRvcikge1xuXHQgICAgZnVuY3Rpb24gYWRvcHQodmFsdWUpIHsgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgUCA/IHZhbHVlIDogbmV3IFAoZnVuY3Rpb24gKHJlc29sdmUpIHsgcmVzb2x2ZSh2YWx1ZSk7IH0pOyB9XG5cdCAgICByZXR1cm4gbmV3IChQIHx8IChQID0gUHJvbWlzZSkpKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcblx0ICAgICAgICBmdW5jdGlvbiBmdWxmaWxsZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3IubmV4dCh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG5cdCAgICAgICAgZnVuY3Rpb24gcmVqZWN0ZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3JbXCJ0aHJvd1wiXSh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG5cdCAgICAgICAgZnVuY3Rpb24gc3RlcChyZXN1bHQpIHsgcmVzdWx0LmRvbmUgPyByZXNvbHZlKHJlc3VsdC52YWx1ZSkgOiBhZG9wdChyZXN1bHQudmFsdWUpLnRoZW4oZnVsZmlsbGVkLCByZWplY3RlZCk7IH1cblx0ICAgICAgICBzdGVwKChnZW5lcmF0b3IgPSBnZW5lcmF0b3IuYXBwbHkodGhpc0FyZywgX2FyZ3VtZW50cyB8fCBbXSkpLm5leHQoKSk7XG5cdCAgICB9KTtcblx0fTtcblx0dmFyIF9fZ2VuZXJhdG9yID0gKGNvbW1vbmpzR2xvYmFsICYmIGNvbW1vbmpzR2xvYmFsLl9fZ2VuZXJhdG9yKSB8fCBmdW5jdGlvbiAodGhpc0FyZywgYm9keSkge1xuXHQgICAgdmFyIF8gPSB7IGxhYmVsOiAwLCBzZW50OiBmdW5jdGlvbigpIHsgaWYgKHRbMF0gJiAxKSB0aHJvdyB0WzFdOyByZXR1cm4gdFsxXTsgfSwgdHJ5czogW10sIG9wczogW10gfSwgZiwgeSwgdCwgZztcblx0ICAgIHJldHVybiBnID0geyBuZXh0OiB2ZXJiKDApLCBcInRocm93XCI6IHZlcmIoMSksIFwicmV0dXJuXCI6IHZlcmIoMikgfSwgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIChnW1N5bWJvbC5pdGVyYXRvcl0gPSBmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXM7IH0pLCBnO1xuXHQgICAgZnVuY3Rpb24gdmVyYihuKSB7IHJldHVybiBmdW5jdGlvbiAodikgeyByZXR1cm4gc3RlcChbbiwgdl0pOyB9OyB9XG5cdCAgICBmdW5jdGlvbiBzdGVwKG9wKSB7XG5cdCAgICAgICAgaWYgKGYpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJHZW5lcmF0b3IgaXMgYWxyZWFkeSBleGVjdXRpbmcuXCIpO1xuXHQgICAgICAgIHdoaWxlIChfKSB0cnkge1xuXHQgICAgICAgICAgICBpZiAoZiA9IDEsIHkgJiYgKHQgPSBvcFswXSAmIDIgPyB5W1wicmV0dXJuXCJdIDogb3BbMF0gPyB5W1widGhyb3dcIl0gfHwgKCh0ID0geVtcInJldHVyblwiXSkgJiYgdC5jYWxsKHkpLCAwKSA6IHkubmV4dCkgJiYgISh0ID0gdC5jYWxsKHksIG9wWzFdKSkuZG9uZSkgcmV0dXJuIHQ7XG5cdCAgICAgICAgICAgIGlmICh5ID0gMCwgdCkgb3AgPSBbb3BbMF0gJiAyLCB0LnZhbHVlXTtcblx0ICAgICAgICAgICAgc3dpdGNoIChvcFswXSkge1xuXHQgICAgICAgICAgICAgICAgY2FzZSAwOiBjYXNlIDE6IHQgPSBvcDsgYnJlYWs7XG5cdCAgICAgICAgICAgICAgICBjYXNlIDQ6IF8ubGFiZWwrKzsgcmV0dXJuIHsgdmFsdWU6IG9wWzFdLCBkb25lOiBmYWxzZSB9O1xuXHQgICAgICAgICAgICAgICAgY2FzZSA1OiBfLmxhYmVsKys7IHkgPSBvcFsxXTsgb3AgPSBbMF07IGNvbnRpbnVlO1xuXHQgICAgICAgICAgICAgICAgY2FzZSA3OiBvcCA9IF8ub3BzLnBvcCgpOyBfLnRyeXMucG9wKCk7IGNvbnRpbnVlO1xuXHQgICAgICAgICAgICAgICAgZGVmYXVsdDpcblx0ICAgICAgICAgICAgICAgICAgICBpZiAoISh0ID0gXy50cnlzLCB0ID0gdC5sZW5ndGggPiAwICYmIHRbdC5sZW5ndGggLSAxXSkgJiYgKG9wWzBdID09PSA2IHx8IG9wWzBdID09PSAyKSkgeyBfID0gMDsgY29udGludWU7IH1cblx0ICAgICAgICAgICAgICAgICAgICBpZiAob3BbMF0gPT09IDMgJiYgKCF0IHx8IChvcFsxXSA+IHRbMF0gJiYgb3BbMV0gPCB0WzNdKSkpIHsgXy5sYWJlbCA9IG9wWzFdOyBicmVhazsgfVxuXHQgICAgICAgICAgICAgICAgICAgIGlmIChvcFswXSA9PT0gNiAmJiBfLmxhYmVsIDwgdFsxXSkgeyBfLmxhYmVsID0gdFsxXTsgdCA9IG9wOyBicmVhazsgfVxuXHQgICAgICAgICAgICAgICAgICAgIGlmICh0ICYmIF8ubGFiZWwgPCB0WzJdKSB7IF8ubGFiZWwgPSB0WzJdOyBfLm9wcy5wdXNoKG9wKTsgYnJlYWs7IH1cblx0ICAgICAgICAgICAgICAgICAgICBpZiAodFsyXSkgXy5vcHMucG9wKCk7XG5cdCAgICAgICAgICAgICAgICAgICAgXy50cnlzLnBvcCgpOyBjb250aW51ZTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICBvcCA9IGJvZHkuY2FsbCh0aGlzQXJnLCBfKTtcblx0ICAgICAgICB9IGNhdGNoIChlKSB7IG9wID0gWzYsIGVdOyB5ID0gMDsgfSBmaW5hbGx5IHsgZiA9IHQgPSAwOyB9XG5cdCAgICAgICAgaWYgKG9wWzBdICYgNSkgdGhyb3cgb3BbMV07IHJldHVybiB7IHZhbHVlOiBvcFswXSA/IG9wWzFdIDogdm9pZCAwLCBkb25lOiB0cnVlIH07XG5cdCAgICB9XG5cdH07XG5cdHZhciBfX2ltcG9ydERlZmF1bHQgPSAoY29tbW9uanNHbG9iYWwgJiYgY29tbW9uanNHbG9iYWwuX19pbXBvcnREZWZhdWx0KSB8fCBmdW5jdGlvbiAobW9kKSB7XG5cdCAgICByZXR1cm4gKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgPyBtb2QgOiB7IFwiZGVmYXVsdFwiOiBtb2QgfTtcblx0fTtcblx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuXHRleHBvcnRzLmVuY3J5cHQgPSBleHBvcnRzLmRlY3J5cHQgPSBleHBvcnRzLmRlY3J5cHRTeW5jID0gZXhwb3J0cy5LZXlzdG9yZUFjY291bnQgPSB2b2lkIDA7XG5cdHZhciBhZXNfanNfMSA9IF9faW1wb3J0RGVmYXVsdChhZXNKcyk7XG5cdHZhciBzY3J5cHRfanNfMSA9IF9faW1wb3J0RGVmYXVsdChzY3J5cHQpO1xuXG5cblxuXG5cblxuXG5cblxuXG5cblx0dmFyIGxvZ2dlciA9IG5ldyBsaWIuTG9nZ2VyKF92ZXJzaW9uJEEudmVyc2lvbik7XG5cdC8vIEV4cG9ydGVkIFR5cGVzXG5cdGZ1bmN0aW9uIGhhc01uZW1vbmljKHZhbHVlKSB7XG5cdCAgICByZXR1cm4gKHZhbHVlICE9IG51bGwgJiYgdmFsdWUubW5lbW9uaWMgJiYgdmFsdWUubW5lbW9uaWMucGhyYXNlKTtcblx0fVxuXHR2YXIgS2V5c3RvcmVBY2NvdW50ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuXHQgICAgX19leHRlbmRzKEtleXN0b3JlQWNjb3VudCwgX3N1cGVyKTtcblx0ICAgIGZ1bmN0aW9uIEtleXN0b3JlQWNjb3VudCgpIHtcblx0ICAgICAgICByZXR1cm4gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG5cdCAgICB9XG5cdCAgICBLZXlzdG9yZUFjY291bnQucHJvdG90eXBlLmlzS2V5c3RvcmVBY2NvdW50ID0gZnVuY3Rpb24gKHZhbHVlKSB7XG5cdCAgICAgICAgcmV0dXJuICEhKHZhbHVlICYmIHZhbHVlLl9pc0tleXN0b3JlQWNjb3VudCk7XG5cdCAgICB9O1xuXHQgICAgcmV0dXJuIEtleXN0b3JlQWNjb3VudDtcblx0fShsaWIkMy5EZXNjcmlwdGlvbikpO1xuXHRleHBvcnRzLktleXN0b3JlQWNjb3VudCA9IEtleXN0b3JlQWNjb3VudDtcblx0ZnVuY3Rpb24gX2RlY3J5cHQoZGF0YSwga2V5LCBjaXBoZXJ0ZXh0KSB7XG5cdCAgICB2YXIgY2lwaGVyID0gKDAsIHV0aWxzJDEuc2VhcmNoUGF0aCkoZGF0YSwgXCJjcnlwdG8vY2lwaGVyXCIpO1xuXHQgICAgaWYgKGNpcGhlciA9PT0gXCJhZXMtMTI4LWN0clwiKSB7XG5cdCAgICAgICAgdmFyIGl2ID0gKDAsIHV0aWxzJDEubG9vc2VBcnJheWlmeSkoKDAsIHV0aWxzJDEuc2VhcmNoUGF0aCkoZGF0YSwgXCJjcnlwdG8vY2lwaGVycGFyYW1zL2l2XCIpKTtcblx0ICAgICAgICB2YXIgY291bnRlciA9IG5ldyBhZXNfanNfMS5kZWZhdWx0LkNvdW50ZXIoaXYpO1xuXHQgICAgICAgIHZhciBhZXNDdHIgPSBuZXcgYWVzX2pzXzEuZGVmYXVsdC5Nb2RlT2ZPcGVyYXRpb24uY3RyKGtleSwgY291bnRlcik7XG5cdCAgICAgICAgcmV0dXJuICgwLCBsaWIkMS5hcnJheWlmeSkoYWVzQ3RyLmRlY3J5cHQoY2lwaGVydGV4dCkpO1xuXHQgICAgfVxuXHQgICAgcmV0dXJuIG51bGw7XG5cdH1cblx0ZnVuY3Rpb24gX2dldEFjY291bnQoZGF0YSwga2V5KSB7XG5cdCAgICB2YXIgY2lwaGVydGV4dCA9ICgwLCB1dGlscyQxLmxvb3NlQXJyYXlpZnkpKCgwLCB1dGlscyQxLnNlYXJjaFBhdGgpKGRhdGEsIFwiY3J5cHRvL2NpcGhlcnRleHRcIikpO1xuXHQgICAgdmFyIGNvbXB1dGVkTUFDID0gKDAsIGxpYiQxLmhleGxpZnkpKCgwLCBsaWIkNC5rZWNjYWsyNTYpKCgwLCBsaWIkMS5jb25jYXQpKFtrZXkuc2xpY2UoMTYsIDMyKSwgY2lwaGVydGV4dF0pKSkuc3Vic3RyaW5nKDIpO1xuXHQgICAgaWYgKGNvbXB1dGVkTUFDICE9PSAoMCwgdXRpbHMkMS5zZWFyY2hQYXRoKShkYXRhLCBcImNyeXB0by9tYWNcIikudG9Mb3dlckNhc2UoKSkge1xuXHQgICAgICAgIHRocm93IG5ldyBFcnJvcihcImludmFsaWQgcGFzc3dvcmRcIik7XG5cdCAgICB9XG5cdCAgICB2YXIgcHJpdmF0ZUtleSA9IF9kZWNyeXB0KGRhdGEsIGtleS5zbGljZSgwLCAxNiksIGNpcGhlcnRleHQpO1xuXHQgICAgaWYgKCFwcml2YXRlS2V5KSB7XG5cdCAgICAgICAgbG9nZ2VyLnRocm93RXJyb3IoXCJ1bnN1cHBvcnRlZCBjaXBoZXJcIiwgbGliLkxvZ2dlci5lcnJvcnMuVU5TVVBQT1JURURfT1BFUkFUSU9OLCB7XG5cdCAgICAgICAgICAgIG9wZXJhdGlvbjogXCJkZWNyeXB0XCJcblx0ICAgICAgICB9KTtcblx0ICAgIH1cblx0ICAgIHZhciBtbmVtb25pY0tleSA9IGtleS5zbGljZSgzMiwgNjQpO1xuXHQgICAgdmFyIGFkZHJlc3MgPSAoMCwgbGliJGUuY29tcHV0ZUFkZHJlc3MpKHByaXZhdGVLZXkpO1xuXHQgICAgaWYgKGRhdGEuYWRkcmVzcykge1xuXHQgICAgICAgIHZhciBjaGVjayA9IGRhdGEuYWRkcmVzcy50b0xvd2VyQ2FzZSgpO1xuXHQgICAgICAgIGlmIChjaGVjay5zdWJzdHJpbmcoMCwgMikgIT09IFwiMHhcIikge1xuXHQgICAgICAgICAgICBjaGVjayA9IFwiMHhcIiArIGNoZWNrO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBpZiAoKDAsIGxpYiQ2LmdldEFkZHJlc3MpKGNoZWNrKSAhPT0gYWRkcmVzcykge1xuXHQgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJhZGRyZXNzIG1pc21hdGNoXCIpO1xuXHQgICAgICAgIH1cblx0ICAgIH1cblx0ICAgIHZhciBhY2NvdW50ID0ge1xuXHQgICAgICAgIF9pc0tleXN0b3JlQWNjb3VudDogdHJ1ZSxcblx0ICAgICAgICBhZGRyZXNzOiBhZGRyZXNzLFxuXHQgICAgICAgIHByaXZhdGVLZXk6ICgwLCBsaWIkMS5oZXhsaWZ5KShwcml2YXRlS2V5KVxuXHQgICAgfTtcblx0ICAgIC8vIFZlcnNpb24gMC4xIHgtZXRoZXJzIG1ldGFkYXRhIG11c3QgY29udGFpbiBhbiBlbmNyeXB0ZWQgbW5lbW9uaWMgcGhyYXNlXG5cdCAgICBpZiAoKDAsIHV0aWxzJDEuc2VhcmNoUGF0aCkoZGF0YSwgXCJ4LWV0aGVycy92ZXJzaW9uXCIpID09PSBcIjAuMVwiKSB7XG5cdCAgICAgICAgdmFyIG1uZW1vbmljQ2lwaGVydGV4dCA9ICgwLCB1dGlscyQxLmxvb3NlQXJyYXlpZnkpKCgwLCB1dGlscyQxLnNlYXJjaFBhdGgpKGRhdGEsIFwieC1ldGhlcnMvbW5lbW9uaWNDaXBoZXJ0ZXh0XCIpKTtcblx0ICAgICAgICB2YXIgbW5lbW9uaWNJdiA9ICgwLCB1dGlscyQxLmxvb3NlQXJyYXlpZnkpKCgwLCB1dGlscyQxLnNlYXJjaFBhdGgpKGRhdGEsIFwieC1ldGhlcnMvbW5lbW9uaWNDb3VudGVyXCIpKTtcblx0ICAgICAgICB2YXIgbW5lbW9uaWNDb3VudGVyID0gbmV3IGFlc19qc18xLmRlZmF1bHQuQ291bnRlcihtbmVtb25pY0l2KTtcblx0ICAgICAgICB2YXIgbW5lbW9uaWNBZXNDdHIgPSBuZXcgYWVzX2pzXzEuZGVmYXVsdC5Nb2RlT2ZPcGVyYXRpb24uY3RyKG1uZW1vbmljS2V5LCBtbmVtb25pY0NvdW50ZXIpO1xuXHQgICAgICAgIHZhciBwYXRoID0gKDAsIHV0aWxzJDEuc2VhcmNoUGF0aCkoZGF0YSwgXCJ4LWV0aGVycy9wYXRoXCIpIHx8IGxpYiRrLmRlZmF1bHRQYXRoO1xuXHQgICAgICAgIHZhciBsb2NhbGUgPSAoMCwgdXRpbHMkMS5zZWFyY2hQYXRoKShkYXRhLCBcIngtZXRoZXJzL2xvY2FsZVwiKSB8fCBcImVuXCI7XG5cdCAgICAgICAgdmFyIGVudHJvcHkgPSAoMCwgbGliJDEuYXJyYXlpZnkpKG1uZW1vbmljQWVzQ3RyLmRlY3J5cHQobW5lbW9uaWNDaXBoZXJ0ZXh0KSk7XG5cdCAgICAgICAgdHJ5IHtcblx0ICAgICAgICAgICAgdmFyIG1uZW1vbmljID0gKDAsIGxpYiRrLmVudHJvcHlUb01uZW1vbmljKShlbnRyb3B5LCBsb2NhbGUpO1xuXHQgICAgICAgICAgICB2YXIgbm9kZSA9IGxpYiRrLkhETm9kZS5mcm9tTW5lbW9uaWMobW5lbW9uaWMsIG51bGwsIGxvY2FsZSkuZGVyaXZlUGF0aChwYXRoKTtcblx0ICAgICAgICAgICAgaWYgKG5vZGUucHJpdmF0ZUtleSAhPSBhY2NvdW50LnByaXZhdGVLZXkpIHtcblx0ICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIm1uZW1vbmljIG1pc21hdGNoXCIpO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIGFjY291bnQubW5lbW9uaWMgPSBub2RlLm1uZW1vbmljO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBjYXRjaCAoZXJyb3IpIHtcblx0ICAgICAgICAgICAgLy8gSWYgd2UgZG9uJ3QgaGF2ZSB0aGUgbG9jYWxlIHdvcmRsaXN0IGluc3RhbGxlZCB0b1xuXHQgICAgICAgICAgICAvLyByZWFkIHRoaXMgbW5lbW9uaWMsIGp1c3QgYmFpbCBhbmQgZG9uJ3Qgc2V0IHRoZVxuXHQgICAgICAgICAgICAvLyBtbmVtb25pY1xuXHQgICAgICAgICAgICBpZiAoZXJyb3IuY29kZSAhPT0gbGliLkxvZ2dlci5lcnJvcnMuSU5WQUxJRF9BUkdVTUVOVCB8fCBlcnJvci5hcmd1bWVudCAhPT0gXCJ3b3JkbGlzdFwiKSB7XG5cdCAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH1cblx0ICAgIH1cblx0ICAgIHJldHVybiBuZXcgS2V5c3RvcmVBY2NvdW50KGFjY291bnQpO1xuXHR9XG5cdGZ1bmN0aW9uIHBia2RmMlN5bmMocGFzc3dvcmRCeXRlcywgc2FsdCwgY291bnQsIGRrTGVuLCBwcmZGdW5jKSB7XG5cdCAgICByZXR1cm4gKDAsIGxpYiQxLmFycmF5aWZ5KSgoMCwgbGliJGkucGJrZGYyKShwYXNzd29yZEJ5dGVzLCBzYWx0LCBjb3VudCwgZGtMZW4sIHByZkZ1bmMpKTtcblx0fVxuXHRmdW5jdGlvbiBwYmtkZjIocGFzc3dvcmRCeXRlcywgc2FsdCwgY291bnQsIGRrTGVuLCBwcmZGdW5jKSB7XG5cdCAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHBia2RmMlN5bmMocGFzc3dvcmRCeXRlcywgc2FsdCwgY291bnQsIGRrTGVuLCBwcmZGdW5jKSk7XG5cdH1cblx0ZnVuY3Rpb24gX2NvbXB1dGVLZGZLZXkoZGF0YSwgcGFzc3dvcmQsIHBia2RmMkZ1bmMsIHNjcnlwdEZ1bmMsIHByb2dyZXNzQ2FsbGJhY2spIHtcblx0ICAgIHZhciBwYXNzd29yZEJ5dGVzID0gKDAsIHV0aWxzJDEuZ2V0UGFzc3dvcmQpKHBhc3N3b3JkKTtcblx0ICAgIHZhciBrZGYgPSAoMCwgdXRpbHMkMS5zZWFyY2hQYXRoKShkYXRhLCBcImNyeXB0by9rZGZcIik7XG5cdCAgICBpZiAoa2RmICYmIHR5cGVvZiAoa2RmKSA9PT0gXCJzdHJpbmdcIikge1xuXHQgICAgICAgIHZhciB0aHJvd0Vycm9yID0gZnVuY3Rpb24gKG5hbWUsIHZhbHVlKSB7XG5cdCAgICAgICAgICAgIHJldHVybiBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwiaW52YWxpZCBrZXktZGVyaXZhdGlvbiBmdW5jdGlvbiBwYXJhbWV0ZXJzXCIsIG5hbWUsIHZhbHVlKTtcblx0ICAgICAgICB9O1xuXHQgICAgICAgIGlmIChrZGYudG9Mb3dlckNhc2UoKSA9PT0gXCJzY3J5cHRcIikge1xuXHQgICAgICAgICAgICB2YXIgc2FsdCA9ICgwLCB1dGlscyQxLmxvb3NlQXJyYXlpZnkpKCgwLCB1dGlscyQxLnNlYXJjaFBhdGgpKGRhdGEsIFwiY3J5cHRvL2tkZnBhcmFtcy9zYWx0XCIpKTtcblx0ICAgICAgICAgICAgdmFyIE4gPSBwYXJzZUludCgoMCwgdXRpbHMkMS5zZWFyY2hQYXRoKShkYXRhLCBcImNyeXB0by9rZGZwYXJhbXMvblwiKSk7XG5cdCAgICAgICAgICAgIHZhciByID0gcGFyc2VJbnQoKDAsIHV0aWxzJDEuc2VhcmNoUGF0aCkoZGF0YSwgXCJjcnlwdG8va2RmcGFyYW1zL3JcIikpO1xuXHQgICAgICAgICAgICB2YXIgcCA9IHBhcnNlSW50KCgwLCB1dGlscyQxLnNlYXJjaFBhdGgpKGRhdGEsIFwiY3J5cHRvL2tkZnBhcmFtcy9wXCIpKTtcblx0ICAgICAgICAgICAgLy8gQ2hlY2sgZm9yIGFsbCByZXF1aXJlZCBwYXJhbWV0ZXJzXG5cdCAgICAgICAgICAgIGlmICghTiB8fCAhciB8fCAhcCkge1xuXHQgICAgICAgICAgICAgICAgdGhyb3dFcnJvcihcImtkZlwiLCBrZGYpO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIC8vIE1ha2Ugc3VyZSBOIGlzIGEgcG93ZXIgb2YgMlxuXHQgICAgICAgICAgICBpZiAoKE4gJiAoTiAtIDEpKSAhPT0gMCkge1xuXHQgICAgICAgICAgICAgICAgdGhyb3dFcnJvcihcIk5cIiwgTik7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgdmFyIGRrTGVuID0gcGFyc2VJbnQoKDAsIHV0aWxzJDEuc2VhcmNoUGF0aCkoZGF0YSwgXCJjcnlwdG8va2RmcGFyYW1zL2RrbGVuXCIpKTtcblx0ICAgICAgICAgICAgaWYgKGRrTGVuICE9PSAzMikge1xuXHQgICAgICAgICAgICAgICAgdGhyb3dFcnJvcihcImRrbGVuXCIsIGRrTGVuKTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICByZXR1cm4gc2NyeXB0RnVuYyhwYXNzd29yZEJ5dGVzLCBzYWx0LCBOLCByLCBwLCA2NCwgcHJvZ3Jlc3NDYWxsYmFjayk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGVsc2UgaWYgKGtkZi50b0xvd2VyQ2FzZSgpID09PSBcInBia2RmMlwiKSB7XG5cdCAgICAgICAgICAgIHZhciBzYWx0ID0gKDAsIHV0aWxzJDEubG9vc2VBcnJheWlmeSkoKDAsIHV0aWxzJDEuc2VhcmNoUGF0aCkoZGF0YSwgXCJjcnlwdG8va2RmcGFyYW1zL3NhbHRcIikpO1xuXHQgICAgICAgICAgICB2YXIgcHJmRnVuYyA9IG51bGw7XG5cdCAgICAgICAgICAgIHZhciBwcmYgPSAoMCwgdXRpbHMkMS5zZWFyY2hQYXRoKShkYXRhLCBcImNyeXB0by9rZGZwYXJhbXMvcHJmXCIpO1xuXHQgICAgICAgICAgICBpZiAocHJmID09PSBcImhtYWMtc2hhMjU2XCIpIHtcblx0ICAgICAgICAgICAgICAgIHByZkZ1bmMgPSBcInNoYTI1NlwiO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIGVsc2UgaWYgKHByZiA9PT0gXCJobWFjLXNoYTUxMlwiKSB7XG5cdCAgICAgICAgICAgICAgICBwcmZGdW5jID0gXCJzaGE1MTJcIjtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICBlbHNlIHtcblx0ICAgICAgICAgICAgICAgIHRocm93RXJyb3IoXCJwcmZcIiwgcHJmKTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB2YXIgY291bnQgPSBwYXJzZUludCgoMCwgdXRpbHMkMS5zZWFyY2hQYXRoKShkYXRhLCBcImNyeXB0by9rZGZwYXJhbXMvY1wiKSk7XG5cdCAgICAgICAgICAgIHZhciBka0xlbiA9IHBhcnNlSW50KCgwLCB1dGlscyQxLnNlYXJjaFBhdGgpKGRhdGEsIFwiY3J5cHRvL2tkZnBhcmFtcy9ka2xlblwiKSk7XG5cdCAgICAgICAgICAgIGlmIChka0xlbiAhPT0gMzIpIHtcblx0ICAgICAgICAgICAgICAgIHRocm93RXJyb3IoXCJka2xlblwiLCBka0xlbik7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgcmV0dXJuIHBia2RmMkZ1bmMocGFzc3dvcmRCeXRlcywgc2FsdCwgY291bnQsIGRrTGVuLCBwcmZGdW5jKTtcblx0ICAgICAgICB9XG5cdCAgICB9XG5cdCAgICByZXR1cm4gbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcInVuc3VwcG9ydGVkIGtleS1kZXJpdmF0aW9uIGZ1bmN0aW9uXCIsIFwia2RmXCIsIGtkZik7XG5cdH1cblx0ZnVuY3Rpb24gZGVjcnlwdFN5bmMoanNvbiwgcGFzc3dvcmQpIHtcblx0ICAgIHZhciBkYXRhID0gSlNPTi5wYXJzZShqc29uKTtcblx0ICAgIHZhciBrZXkgPSBfY29tcHV0ZUtkZktleShkYXRhLCBwYXNzd29yZCwgcGJrZGYyU3luYywgc2NyeXB0X2pzXzEuZGVmYXVsdC5zeW5jU2NyeXB0KTtcblx0ICAgIHJldHVybiBfZ2V0QWNjb3VudChkYXRhLCBrZXkpO1xuXHR9XG5cdGV4cG9ydHMuZGVjcnlwdFN5bmMgPSBkZWNyeXB0U3luYztcblx0ZnVuY3Rpb24gZGVjcnlwdChqc29uLCBwYXNzd29yZCwgcHJvZ3Jlc3NDYWxsYmFjaykge1xuXHQgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIHZhciBkYXRhLCBrZXk7XG5cdCAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuXHQgICAgICAgICAgICBzd2l0Y2ggKF9hLmxhYmVsKSB7XG5cdCAgICAgICAgICAgICAgICBjYXNlIDA6XG5cdCAgICAgICAgICAgICAgICAgICAgZGF0YSA9IEpTT04ucGFyc2UoanNvbik7XG5cdCAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgX2NvbXB1dGVLZGZLZXkoZGF0YSwgcGFzc3dvcmQsIHBia2RmMiwgc2NyeXB0X2pzXzEuZGVmYXVsdC5zY3J5cHQsIHByb2dyZXNzQ2FsbGJhY2spXTtcblx0ICAgICAgICAgICAgICAgIGNhc2UgMTpcblx0ICAgICAgICAgICAgICAgICAgICBrZXkgPSBfYS5zZW50KCk7XG5cdCAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIF9nZXRBY2NvdW50KGRhdGEsIGtleSldO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfSk7XG5cdCAgICB9KTtcblx0fVxuXHRleHBvcnRzLmRlY3J5cHQgPSBkZWNyeXB0O1xuXHRmdW5jdGlvbiBlbmNyeXB0KGFjY291bnQsIHBhc3N3b3JkLCBvcHRpb25zLCBwcm9ncmVzc0NhbGxiYWNrKSB7XG5cdCAgICB0cnkge1xuXHQgICAgICAgIC8vIENoZWNrIHRoZSBhZGRyZXNzIG1hdGNoZXMgdGhlIHByaXZhdGUga2V5XG5cdCAgICAgICAgaWYgKCgwLCBsaWIkNi5nZXRBZGRyZXNzKShhY2NvdW50LmFkZHJlc3MpICE9PSAoMCwgbGliJGUuY29tcHV0ZUFkZHJlc3MpKGFjY291bnQucHJpdmF0ZUtleSkpIHtcblx0ICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiYWRkcmVzcy9wcml2YXRlS2V5IG1pc21hdGNoXCIpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICAvLyBDaGVjayB0aGUgbW5lbW9uaWMgKGlmIGFueSkgbWF0Y2hlcyB0aGUgcHJpdmF0ZSBrZXlcblx0ICAgICAgICBpZiAoaGFzTW5lbW9uaWMoYWNjb3VudCkpIHtcblx0ICAgICAgICAgICAgdmFyIG1uZW1vbmljID0gYWNjb3VudC5tbmVtb25pYztcblx0ICAgICAgICAgICAgdmFyIG5vZGUgPSBsaWIkay5IRE5vZGUuZnJvbU1uZW1vbmljKG1uZW1vbmljLnBocmFzZSwgbnVsbCwgbW5lbW9uaWMubG9jYWxlKS5kZXJpdmVQYXRoKG1uZW1vbmljLnBhdGggfHwgbGliJGsuZGVmYXVsdFBhdGgpO1xuXHQgICAgICAgICAgICBpZiAobm9kZS5wcml2YXRlS2V5ICE9IGFjY291bnQucHJpdmF0ZUtleSkge1xuXHQgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwibW5lbW9uaWMgbWlzbWF0Y2hcIik7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9XG5cdCAgICB9XG5cdCAgICBjYXRjaCAoZSkge1xuXHQgICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChlKTtcblx0ICAgIH1cblx0ICAgIC8vIFRoZSBvcHRpb25zIGFyZSBvcHRpb25hbCwgc28gYWRqdXN0IHRoZSBjYWxsIGFzIG5lZWRlZFxuXHQgICAgaWYgKHR5cGVvZiAob3B0aW9ucykgPT09IFwiZnVuY3Rpb25cIiAmJiAhcHJvZ3Jlc3NDYWxsYmFjaykge1xuXHQgICAgICAgIHByb2dyZXNzQ2FsbGJhY2sgPSBvcHRpb25zO1xuXHQgICAgICAgIG9wdGlvbnMgPSB7fTtcblx0ICAgIH1cblx0ICAgIGlmICghb3B0aW9ucykge1xuXHQgICAgICAgIG9wdGlvbnMgPSB7fTtcblx0ICAgIH1cblx0ICAgIHZhciBwcml2YXRlS2V5ID0gKDAsIGxpYiQxLmFycmF5aWZ5KShhY2NvdW50LnByaXZhdGVLZXkpO1xuXHQgICAgdmFyIHBhc3N3b3JkQnl0ZXMgPSAoMCwgdXRpbHMkMS5nZXRQYXNzd29yZCkocGFzc3dvcmQpO1xuXHQgICAgdmFyIGVudHJvcHkgPSBudWxsO1xuXHQgICAgdmFyIHBhdGggPSBudWxsO1xuXHQgICAgdmFyIGxvY2FsZSA9IG51bGw7XG5cdCAgICBpZiAoaGFzTW5lbW9uaWMoYWNjb3VudCkpIHtcblx0ICAgICAgICB2YXIgc3JjTW5lbW9uaWMgPSBhY2NvdW50Lm1uZW1vbmljO1xuXHQgICAgICAgIGVudHJvcHkgPSAoMCwgbGliJDEuYXJyYXlpZnkpKCgwLCBsaWIkay5tbmVtb25pY1RvRW50cm9weSkoc3JjTW5lbW9uaWMucGhyYXNlLCBzcmNNbmVtb25pYy5sb2NhbGUgfHwgXCJlblwiKSk7XG5cdCAgICAgICAgcGF0aCA9IHNyY01uZW1vbmljLnBhdGggfHwgbGliJGsuZGVmYXVsdFBhdGg7XG5cdCAgICAgICAgbG9jYWxlID0gc3JjTW5lbW9uaWMubG9jYWxlIHx8IFwiZW5cIjtcblx0ICAgIH1cblx0ICAgIHZhciBjbGllbnQgPSBvcHRpb25zLmNsaWVudDtcblx0ICAgIGlmICghY2xpZW50KSB7XG5cdCAgICAgICAgY2xpZW50ID0gXCJldGhlcnMuanNcIjtcblx0ICAgIH1cblx0ICAgIC8vIENoZWNrL2dlbmVyYXRlIHRoZSBzYWx0XG5cdCAgICB2YXIgc2FsdCA9IG51bGw7XG5cdCAgICBpZiAob3B0aW9ucy5zYWx0KSB7XG5cdCAgICAgICAgc2FsdCA9ICgwLCBsaWIkMS5hcnJheWlmeSkob3B0aW9ucy5zYWx0KTtcblx0ICAgIH1cblx0ICAgIGVsc2Uge1xuXHQgICAgICAgIHNhbHQgPSAoMCwgbGliJGwucmFuZG9tQnl0ZXMpKDMyKTtcblx0ICAgICAgICA7XG5cdCAgICB9XG5cdCAgICAvLyBPdmVycmlkZSBpbml0aWFsaXphdGlvbiB2ZWN0b3Jcblx0ICAgIHZhciBpdiA9IG51bGw7XG5cdCAgICBpZiAob3B0aW9ucy5pdikge1xuXHQgICAgICAgIGl2ID0gKDAsIGxpYiQxLmFycmF5aWZ5KShvcHRpb25zLml2KTtcblx0ICAgICAgICBpZiAoaXYubGVuZ3RoICE9PSAxNikge1xuXHQgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIGl2XCIpO1xuXHQgICAgICAgIH1cblx0ICAgIH1cblx0ICAgIGVsc2Uge1xuXHQgICAgICAgIGl2ID0gKDAsIGxpYiRsLnJhbmRvbUJ5dGVzKSgxNik7XG5cdCAgICB9XG5cdCAgICAvLyBPdmVycmlkZSB0aGUgdXVpZFxuXHQgICAgdmFyIHV1aWRSYW5kb20gPSBudWxsO1xuXHQgICAgaWYgKG9wdGlvbnMudXVpZCkge1xuXHQgICAgICAgIHV1aWRSYW5kb20gPSAoMCwgbGliJDEuYXJyYXlpZnkpKG9wdGlvbnMudXVpZCk7XG5cdCAgICAgICAgaWYgKHV1aWRSYW5kb20ubGVuZ3RoICE9PSAxNikge1xuXHQgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIHV1aWRcIik7XG5cdCAgICAgICAgfVxuXHQgICAgfVxuXHQgICAgZWxzZSB7XG5cdCAgICAgICAgdXVpZFJhbmRvbSA9ICgwLCBsaWIkbC5yYW5kb21CeXRlcykoMTYpO1xuXHQgICAgfVxuXHQgICAgLy8gT3ZlcnJpZGUgdGhlIHNjcnlwdCBwYXNzd29yZC1iYXNlZCBrZXkgZGVyaXZhdGlvbiBmdW5jdGlvbiBwYXJhbWV0ZXJzXG5cdCAgICB2YXIgTiA9ICgxIDw8IDE3KSwgciA9IDgsIHAgPSAxO1xuXHQgICAgaWYgKG9wdGlvbnMuc2NyeXB0KSB7XG5cdCAgICAgICAgaWYgKG9wdGlvbnMuc2NyeXB0Lk4pIHtcblx0ICAgICAgICAgICAgTiA9IG9wdGlvbnMuc2NyeXB0Lk47XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGlmIChvcHRpb25zLnNjcnlwdC5yKSB7XG5cdCAgICAgICAgICAgIHIgPSBvcHRpb25zLnNjcnlwdC5yO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBpZiAob3B0aW9ucy5zY3J5cHQucCkge1xuXHQgICAgICAgICAgICBwID0gb3B0aW9ucy5zY3J5cHQucDtcblx0ICAgICAgICB9XG5cdCAgICB9XG5cdCAgICAvLyBXZSB0YWtlIDY0IGJ5dGVzOlxuXHQgICAgLy8gICAtIDMyIGJ5dGVzICAgQXMgbm9ybWFsIGZvciB0aGUgV2ViMyBzZWNyZXQgc3RvcmFnZSAoZGVyaXZlZEtleSwgbWFjUHJlZml4KVxuXHQgICAgLy8gICAtIDMyIGJ5dGVzICAgQUVTIGtleSB0byBlbmNyeXB0IG1uZW1vbmljIHdpdGggKHJlcXVpcmVkIGhlcmUgdG8gYmUgRXRoZXJzIFdhbGxldClcblx0ICAgIHJldHVybiBzY3J5cHRfanNfMS5kZWZhdWx0LnNjcnlwdChwYXNzd29yZEJ5dGVzLCBzYWx0LCBOLCByLCBwLCA2NCwgcHJvZ3Jlc3NDYWxsYmFjaykudGhlbihmdW5jdGlvbiAoa2V5KSB7XG5cdCAgICAgICAga2V5ID0gKDAsIGxpYiQxLmFycmF5aWZ5KShrZXkpO1xuXHQgICAgICAgIC8vIFRoaXMgd2lsbCBiZSB1c2VkIHRvIGVuY3J5cHQgdGhlIHdhbGxldCAoYXMgcGVyIFdlYjMgc2VjcmV0IHN0b3JhZ2UpXG5cdCAgICAgICAgdmFyIGRlcml2ZWRLZXkgPSBrZXkuc2xpY2UoMCwgMTYpO1xuXHQgICAgICAgIHZhciBtYWNQcmVmaXggPSBrZXkuc2xpY2UoMTYsIDMyKTtcblx0ICAgICAgICAvLyBUaGlzIHdpbGwgYmUgdXNlZCB0byBlbmNyeXB0IHRoZSBtbmVtb25pYyBwaHJhc2UgKGlmIGFueSlcblx0ICAgICAgICB2YXIgbW5lbW9uaWNLZXkgPSBrZXkuc2xpY2UoMzIsIDY0KTtcblx0ICAgICAgICAvLyBFbmNyeXB0IHRoZSBwcml2YXRlIGtleVxuXHQgICAgICAgIHZhciBjb3VudGVyID0gbmV3IGFlc19qc18xLmRlZmF1bHQuQ291bnRlcihpdik7XG5cdCAgICAgICAgdmFyIGFlc0N0ciA9IG5ldyBhZXNfanNfMS5kZWZhdWx0Lk1vZGVPZk9wZXJhdGlvbi5jdHIoZGVyaXZlZEtleSwgY291bnRlcik7XG5cdCAgICAgICAgdmFyIGNpcGhlcnRleHQgPSAoMCwgbGliJDEuYXJyYXlpZnkpKGFlc0N0ci5lbmNyeXB0KHByaXZhdGVLZXkpKTtcblx0ICAgICAgICAvLyBDb21wdXRlIHRoZSBtZXNzYWdlIGF1dGhlbnRpY2F0aW9uIGNvZGUsIHVzZWQgdG8gY2hlY2sgdGhlIHBhc3N3b3JkXG5cdCAgICAgICAgdmFyIG1hYyA9ICgwLCBsaWIkNC5rZWNjYWsyNTYpKCgwLCBsaWIkMS5jb25jYXQpKFttYWNQcmVmaXgsIGNpcGhlcnRleHRdKSk7XG5cdCAgICAgICAgLy8gU2VlOiBodHRwczovL2dpdGh1Yi5jb20vZXRoZXJldW0vd2lraS93aWtpL1dlYjMtU2VjcmV0LVN0b3JhZ2UtRGVmaW5pdGlvblxuXHQgICAgICAgIHZhciBkYXRhID0ge1xuXHQgICAgICAgICAgICBhZGRyZXNzOiBhY2NvdW50LmFkZHJlc3Muc3Vic3RyaW5nKDIpLnRvTG93ZXJDYXNlKCksXG5cdCAgICAgICAgICAgIGlkOiAoMCwgdXRpbHMkMS51dWlkVjQpKHV1aWRSYW5kb20pLFxuXHQgICAgICAgICAgICB2ZXJzaW9uOiAzLFxuXHQgICAgICAgICAgICBDcnlwdG86IHtcblx0ICAgICAgICAgICAgICAgIGNpcGhlcjogXCJhZXMtMTI4LWN0clwiLFxuXHQgICAgICAgICAgICAgICAgY2lwaGVycGFyYW1zOiB7XG5cdCAgICAgICAgICAgICAgICAgICAgaXY6ICgwLCBsaWIkMS5oZXhsaWZ5KShpdikuc3Vic3RyaW5nKDIpLFxuXHQgICAgICAgICAgICAgICAgfSxcblx0ICAgICAgICAgICAgICAgIGNpcGhlcnRleHQ6ICgwLCBsaWIkMS5oZXhsaWZ5KShjaXBoZXJ0ZXh0KS5zdWJzdHJpbmcoMiksXG5cdCAgICAgICAgICAgICAgICBrZGY6IFwic2NyeXB0XCIsXG5cdCAgICAgICAgICAgICAgICBrZGZwYXJhbXM6IHtcblx0ICAgICAgICAgICAgICAgICAgICBzYWx0OiAoMCwgbGliJDEuaGV4bGlmeSkoc2FsdCkuc3Vic3RyaW5nKDIpLFxuXHQgICAgICAgICAgICAgICAgICAgIG46IE4sXG5cdCAgICAgICAgICAgICAgICAgICAgZGtsZW46IDMyLFxuXHQgICAgICAgICAgICAgICAgICAgIHA6IHAsXG5cdCAgICAgICAgICAgICAgICAgICAgcjogclxuXHQgICAgICAgICAgICAgICAgfSxcblx0ICAgICAgICAgICAgICAgIG1hYzogbWFjLnN1YnN0cmluZygyKVxuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfTtcblx0ICAgICAgICAvLyBJZiB3ZSBoYXZlIGEgbW5lbW9uaWMsIGVuY3J5cHQgaXQgaW50byB0aGUgSlNPTiB3YWxsZXRcblx0ICAgICAgICBpZiAoZW50cm9weSkge1xuXHQgICAgICAgICAgICB2YXIgbW5lbW9uaWNJdiA9ICgwLCBsaWIkbC5yYW5kb21CeXRlcykoMTYpO1xuXHQgICAgICAgICAgICB2YXIgbW5lbW9uaWNDb3VudGVyID0gbmV3IGFlc19qc18xLmRlZmF1bHQuQ291bnRlcihtbmVtb25pY0l2KTtcblx0ICAgICAgICAgICAgdmFyIG1uZW1vbmljQWVzQ3RyID0gbmV3IGFlc19qc18xLmRlZmF1bHQuTW9kZU9mT3BlcmF0aW9uLmN0cihtbmVtb25pY0tleSwgbW5lbW9uaWNDb3VudGVyKTtcblx0ICAgICAgICAgICAgdmFyIG1uZW1vbmljQ2lwaGVydGV4dCA9ICgwLCBsaWIkMS5hcnJheWlmeSkobW5lbW9uaWNBZXNDdHIuZW5jcnlwdChlbnRyb3B5KSk7XG5cdCAgICAgICAgICAgIHZhciBub3cgPSBuZXcgRGF0ZSgpO1xuXHQgICAgICAgICAgICB2YXIgdGltZXN0YW1wID0gKG5vdy5nZXRVVENGdWxsWWVhcigpICsgXCItXCIgK1xuXHQgICAgICAgICAgICAgICAgKDAsIHV0aWxzJDEuenBhZCkobm93LmdldFVUQ01vbnRoKCkgKyAxLCAyKSArIFwiLVwiICtcblx0ICAgICAgICAgICAgICAgICgwLCB1dGlscyQxLnpwYWQpKG5vdy5nZXRVVENEYXRlKCksIDIpICsgXCJUXCIgK1xuXHQgICAgICAgICAgICAgICAgKDAsIHV0aWxzJDEuenBhZCkobm93LmdldFVUQ0hvdXJzKCksIDIpICsgXCItXCIgK1xuXHQgICAgICAgICAgICAgICAgKDAsIHV0aWxzJDEuenBhZCkobm93LmdldFVUQ01pbnV0ZXMoKSwgMikgKyBcIi1cIiArXG5cdCAgICAgICAgICAgICAgICAoMCwgdXRpbHMkMS56cGFkKShub3cuZ2V0VVRDU2Vjb25kcygpLCAyKSArIFwiLjBaXCIpO1xuXHQgICAgICAgICAgICBkYXRhW1wieC1ldGhlcnNcIl0gPSB7XG5cdCAgICAgICAgICAgICAgICBjbGllbnQ6IGNsaWVudCxcblx0ICAgICAgICAgICAgICAgIGdldGhGaWxlbmFtZTogKFwiVVRDLS1cIiArIHRpbWVzdGFtcCArIFwiLS1cIiArIGRhdGEuYWRkcmVzcyksXG5cdCAgICAgICAgICAgICAgICBtbmVtb25pY0NvdW50ZXI6ICgwLCBsaWIkMS5oZXhsaWZ5KShtbmVtb25pY0l2KS5zdWJzdHJpbmcoMiksXG5cdCAgICAgICAgICAgICAgICBtbmVtb25pY0NpcGhlcnRleHQ6ICgwLCBsaWIkMS5oZXhsaWZ5KShtbmVtb25pY0NpcGhlcnRleHQpLnN1YnN0cmluZygyKSxcblx0ICAgICAgICAgICAgICAgIHBhdGg6IHBhdGgsXG5cdCAgICAgICAgICAgICAgICBsb2NhbGU6IGxvY2FsZSxcblx0ICAgICAgICAgICAgICAgIHZlcnNpb246IFwiMC4xXCJcblx0ICAgICAgICAgICAgfTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KGRhdGEpO1xuXHQgICAgfSk7XG5cdH1cblx0ZXhwb3J0cy5lbmNyeXB0ID0gZW5jcnlwdDtcblxuXHR9KTtcblxuXHR2YXIga2V5c3RvcmUkMSA9IC8qQF9fUFVSRV9fKi9nZXREZWZhdWx0RXhwb3J0RnJvbUNqcyhrZXlzdG9yZSk7XG5cblx0dmFyIGxpYiRtID0gY3JlYXRlQ29tbW9uanNNb2R1bGUoZnVuY3Rpb24gKG1vZHVsZSwgZXhwb3J0cykge1xuXHRcInVzZSBzdHJpY3RcIjtcblx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuXHRleHBvcnRzLmRlY3J5cHRKc29uV2FsbGV0U3luYyA9IGV4cG9ydHMuZGVjcnlwdEpzb25XYWxsZXQgPSBleHBvcnRzLmdldEpzb25XYWxsZXRBZGRyZXNzID0gZXhwb3J0cy5pc0tleXN0b3JlV2FsbGV0ID0gZXhwb3J0cy5pc0Nyb3dkc2FsZVdhbGxldCA9IGV4cG9ydHMuZW5jcnlwdEtleXN0b3JlID0gZXhwb3J0cy5kZWNyeXB0S2V5c3RvcmVTeW5jID0gZXhwb3J0cy5kZWNyeXB0S2V5c3RvcmUgPSBleHBvcnRzLmRlY3J5cHRDcm93ZHNhbGUgPSB2b2lkIDA7XG5cblx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiZGVjcnlwdENyb3dkc2FsZVwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gY3Jvd2RzYWxlLmRlY3J5cHQ7IH0gfSk7XG5cblx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiZ2V0SnNvbldhbGxldEFkZHJlc3NcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGluc3BlY3QuZ2V0SnNvbldhbGxldEFkZHJlc3M7IH0gfSk7XG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImlzQ3Jvd2RzYWxlV2FsbGV0XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBpbnNwZWN0LmlzQ3Jvd2RzYWxlV2FsbGV0OyB9IH0pO1xuXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJpc0tleXN0b3JlV2FsbGV0XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBpbnNwZWN0LmlzS2V5c3RvcmVXYWxsZXQ7IH0gfSk7XG5cblx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiZGVjcnlwdEtleXN0b3JlXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBrZXlzdG9yZS5kZWNyeXB0OyB9IH0pO1xuXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJkZWNyeXB0S2V5c3RvcmVTeW5jXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBrZXlzdG9yZS5kZWNyeXB0U3luYzsgfSB9KTtcblx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiZW5jcnlwdEtleXN0b3JlXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBrZXlzdG9yZS5lbmNyeXB0OyB9IH0pO1xuXHRmdW5jdGlvbiBkZWNyeXB0SnNvbldhbGxldChqc29uLCBwYXNzd29yZCwgcHJvZ3Jlc3NDYWxsYmFjaykge1xuXHQgICAgaWYgKCgwLCBpbnNwZWN0LmlzQ3Jvd2RzYWxlV2FsbGV0KShqc29uKSkge1xuXHQgICAgICAgIGlmIChwcm9ncmVzc0NhbGxiYWNrKSB7XG5cdCAgICAgICAgICAgIHByb2dyZXNzQ2FsbGJhY2soMCk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHZhciBhY2NvdW50ID0gKDAsIGNyb3dkc2FsZS5kZWNyeXB0KShqc29uLCBwYXNzd29yZCk7XG5cdCAgICAgICAgaWYgKHByb2dyZXNzQ2FsbGJhY2spIHtcblx0ICAgICAgICAgICAgcHJvZ3Jlc3NDYWxsYmFjaygxKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShhY2NvdW50KTtcblx0ICAgIH1cblx0ICAgIGlmICgoMCwgaW5zcGVjdC5pc0tleXN0b3JlV2FsbGV0KShqc29uKSkge1xuXHQgICAgICAgIHJldHVybiAoMCwga2V5c3RvcmUuZGVjcnlwdCkoanNvbiwgcGFzc3dvcmQsIHByb2dyZXNzQ2FsbGJhY2spO1xuXHQgICAgfVxuXHQgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KG5ldyBFcnJvcihcImludmFsaWQgSlNPTiB3YWxsZXRcIikpO1xuXHR9XG5cdGV4cG9ydHMuZGVjcnlwdEpzb25XYWxsZXQgPSBkZWNyeXB0SnNvbldhbGxldDtcblx0ZnVuY3Rpb24gZGVjcnlwdEpzb25XYWxsZXRTeW5jKGpzb24sIHBhc3N3b3JkKSB7XG5cdCAgICBpZiAoKDAsIGluc3BlY3QuaXNDcm93ZHNhbGVXYWxsZXQpKGpzb24pKSB7XG5cdCAgICAgICAgcmV0dXJuICgwLCBjcm93ZHNhbGUuZGVjcnlwdCkoanNvbiwgcGFzc3dvcmQpO1xuXHQgICAgfVxuXHQgICAgaWYgKCgwLCBpbnNwZWN0LmlzS2V5c3RvcmVXYWxsZXQpKGpzb24pKSB7XG5cdCAgICAgICAgcmV0dXJuICgwLCBrZXlzdG9yZS5kZWNyeXB0U3luYykoanNvbiwgcGFzc3dvcmQpO1xuXHQgICAgfVxuXHQgICAgdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBKU09OIHdhbGxldFwiKTtcblx0fVxuXHRleHBvcnRzLmRlY3J5cHRKc29uV2FsbGV0U3luYyA9IGRlY3J5cHRKc29uV2FsbGV0U3luYztcblxuXHR9KTtcblxuXHR2YXIgaW5kZXgkbSA9IC8qQF9fUFVSRV9fKi9nZXREZWZhdWx0RXhwb3J0RnJvbUNqcyhsaWIkbSk7XG5cblx0dmFyIF92ZXJzaW9uJEMgPSBjcmVhdGVDb21tb25qc01vZHVsZShmdW5jdGlvbiAobW9kdWxlLCBleHBvcnRzKSB7XG5cdFwidXNlIHN0cmljdFwiO1xuXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5cdGV4cG9ydHMudmVyc2lvbiA9IHZvaWQgMDtcblx0ZXhwb3J0cy52ZXJzaW9uID0gXCJ3YWxsZXQvNS41LjBcIjtcblxuXHR9KTtcblxuXHR2YXIgX3ZlcnNpb24kRCA9IC8qQF9fUFVSRV9fKi9nZXREZWZhdWx0RXhwb3J0RnJvbUNqcyhfdmVyc2lvbiRDKTtcblxuXHR2YXIgbGliJG4gPSBjcmVhdGVDb21tb25qc01vZHVsZShmdW5jdGlvbiAobW9kdWxlLCBleHBvcnRzKSB7XG5cdFwidXNlIHN0cmljdFwiO1xuXHR2YXIgX19leHRlbmRzID0gKGNvbW1vbmpzR2xvYmFsICYmIGNvbW1vbmpzR2xvYmFsLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcblx0ICAgIHZhciBleHRlbmRTdGF0aWNzID0gZnVuY3Rpb24gKGQsIGIpIHtcblx0ICAgICAgICBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG5cdCAgICAgICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcblx0ICAgICAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGIsIHApKSBkW3BdID0gYltwXTsgfTtcblx0ICAgICAgICByZXR1cm4gZXh0ZW5kU3RhdGljcyhkLCBiKTtcblx0ICAgIH07XG5cdCAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcblx0ICAgICAgICBpZiAodHlwZW9mIGIgIT09IFwiZnVuY3Rpb25cIiAmJiBiICE9PSBudWxsKVxuXHQgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2xhc3MgZXh0ZW5kcyB2YWx1ZSBcIiArIFN0cmluZyhiKSArIFwiIGlzIG5vdCBhIGNvbnN0cnVjdG9yIG9yIG51bGxcIik7XG5cdCAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcblx0ICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cblx0ICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG5cdCAgICB9O1xuXHR9KSgpO1xuXHR2YXIgX19hd2FpdGVyID0gKGNvbW1vbmpzR2xvYmFsICYmIGNvbW1vbmpzR2xvYmFsLl9fYXdhaXRlcikgfHwgZnVuY3Rpb24gKHRoaXNBcmcsIF9hcmd1bWVudHMsIFAsIGdlbmVyYXRvcikge1xuXHQgICAgZnVuY3Rpb24gYWRvcHQodmFsdWUpIHsgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgUCA/IHZhbHVlIDogbmV3IFAoZnVuY3Rpb24gKHJlc29sdmUpIHsgcmVzb2x2ZSh2YWx1ZSk7IH0pOyB9XG5cdCAgICByZXR1cm4gbmV3IChQIHx8IChQID0gUHJvbWlzZSkpKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcblx0ICAgICAgICBmdW5jdGlvbiBmdWxmaWxsZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3IubmV4dCh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG5cdCAgICAgICAgZnVuY3Rpb24gcmVqZWN0ZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3JbXCJ0aHJvd1wiXSh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG5cdCAgICAgICAgZnVuY3Rpb24gc3RlcChyZXN1bHQpIHsgcmVzdWx0LmRvbmUgPyByZXNvbHZlKHJlc3VsdC52YWx1ZSkgOiBhZG9wdChyZXN1bHQudmFsdWUpLnRoZW4oZnVsZmlsbGVkLCByZWplY3RlZCk7IH1cblx0ICAgICAgICBzdGVwKChnZW5lcmF0b3IgPSBnZW5lcmF0b3IuYXBwbHkodGhpc0FyZywgX2FyZ3VtZW50cyB8fCBbXSkpLm5leHQoKSk7XG5cdCAgICB9KTtcblx0fTtcblx0dmFyIF9fZ2VuZXJhdG9yID0gKGNvbW1vbmpzR2xvYmFsICYmIGNvbW1vbmpzR2xvYmFsLl9fZ2VuZXJhdG9yKSB8fCBmdW5jdGlvbiAodGhpc0FyZywgYm9keSkge1xuXHQgICAgdmFyIF8gPSB7IGxhYmVsOiAwLCBzZW50OiBmdW5jdGlvbigpIHsgaWYgKHRbMF0gJiAxKSB0aHJvdyB0WzFdOyByZXR1cm4gdFsxXTsgfSwgdHJ5czogW10sIG9wczogW10gfSwgZiwgeSwgdCwgZztcblx0ICAgIHJldHVybiBnID0geyBuZXh0OiB2ZXJiKDApLCBcInRocm93XCI6IHZlcmIoMSksIFwicmV0dXJuXCI6IHZlcmIoMikgfSwgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIChnW1N5bWJvbC5pdGVyYXRvcl0gPSBmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXM7IH0pLCBnO1xuXHQgICAgZnVuY3Rpb24gdmVyYihuKSB7IHJldHVybiBmdW5jdGlvbiAodikgeyByZXR1cm4gc3RlcChbbiwgdl0pOyB9OyB9XG5cdCAgICBmdW5jdGlvbiBzdGVwKG9wKSB7XG5cdCAgICAgICAgaWYgKGYpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJHZW5lcmF0b3IgaXMgYWxyZWFkeSBleGVjdXRpbmcuXCIpO1xuXHQgICAgICAgIHdoaWxlIChfKSB0cnkge1xuXHQgICAgICAgICAgICBpZiAoZiA9IDEsIHkgJiYgKHQgPSBvcFswXSAmIDIgPyB5W1wicmV0dXJuXCJdIDogb3BbMF0gPyB5W1widGhyb3dcIl0gfHwgKCh0ID0geVtcInJldHVyblwiXSkgJiYgdC5jYWxsKHkpLCAwKSA6IHkubmV4dCkgJiYgISh0ID0gdC5jYWxsKHksIG9wWzFdKSkuZG9uZSkgcmV0dXJuIHQ7XG5cdCAgICAgICAgICAgIGlmICh5ID0gMCwgdCkgb3AgPSBbb3BbMF0gJiAyLCB0LnZhbHVlXTtcblx0ICAgICAgICAgICAgc3dpdGNoIChvcFswXSkge1xuXHQgICAgICAgICAgICAgICAgY2FzZSAwOiBjYXNlIDE6IHQgPSBvcDsgYnJlYWs7XG5cdCAgICAgICAgICAgICAgICBjYXNlIDQ6IF8ubGFiZWwrKzsgcmV0dXJuIHsgdmFsdWU6IG9wWzFdLCBkb25lOiBmYWxzZSB9O1xuXHQgICAgICAgICAgICAgICAgY2FzZSA1OiBfLmxhYmVsKys7IHkgPSBvcFsxXTsgb3AgPSBbMF07IGNvbnRpbnVlO1xuXHQgICAgICAgICAgICAgICAgY2FzZSA3OiBvcCA9IF8ub3BzLnBvcCgpOyBfLnRyeXMucG9wKCk7IGNvbnRpbnVlO1xuXHQgICAgICAgICAgICAgICAgZGVmYXVsdDpcblx0ICAgICAgICAgICAgICAgICAgICBpZiAoISh0ID0gXy50cnlzLCB0ID0gdC5sZW5ndGggPiAwICYmIHRbdC5sZW5ndGggLSAxXSkgJiYgKG9wWzBdID09PSA2IHx8IG9wWzBdID09PSAyKSkgeyBfID0gMDsgY29udGludWU7IH1cblx0ICAgICAgICAgICAgICAgICAgICBpZiAob3BbMF0gPT09IDMgJiYgKCF0IHx8IChvcFsxXSA+IHRbMF0gJiYgb3BbMV0gPCB0WzNdKSkpIHsgXy5sYWJlbCA9IG9wWzFdOyBicmVhazsgfVxuXHQgICAgICAgICAgICAgICAgICAgIGlmIChvcFswXSA9PT0gNiAmJiBfLmxhYmVsIDwgdFsxXSkgeyBfLmxhYmVsID0gdFsxXTsgdCA9IG9wOyBicmVhazsgfVxuXHQgICAgICAgICAgICAgICAgICAgIGlmICh0ICYmIF8ubGFiZWwgPCB0WzJdKSB7IF8ubGFiZWwgPSB0WzJdOyBfLm9wcy5wdXNoKG9wKTsgYnJlYWs7IH1cblx0ICAgICAgICAgICAgICAgICAgICBpZiAodFsyXSkgXy5vcHMucG9wKCk7XG5cdCAgICAgICAgICAgICAgICAgICAgXy50cnlzLnBvcCgpOyBjb250aW51ZTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICBvcCA9IGJvZHkuY2FsbCh0aGlzQXJnLCBfKTtcblx0ICAgICAgICB9IGNhdGNoIChlKSB7IG9wID0gWzYsIGVdOyB5ID0gMDsgfSBmaW5hbGx5IHsgZiA9IHQgPSAwOyB9XG5cdCAgICAgICAgaWYgKG9wWzBdICYgNSkgdGhyb3cgb3BbMV07IHJldHVybiB7IHZhbHVlOiBvcFswXSA/IG9wWzFdIDogdm9pZCAwLCBkb25lOiB0cnVlIH07XG5cdCAgICB9XG5cdH07XG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcblx0ZXhwb3J0cy52ZXJpZnlUeXBlZERhdGEgPSBleHBvcnRzLnZlcmlmeU1lc3NhZ2UgPSBleHBvcnRzLldhbGxldCA9IHZvaWQgMDtcblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cdHZhciBsb2dnZXIgPSBuZXcgbGliLkxvZ2dlcihfdmVyc2lvbiRDLnZlcnNpb24pO1xuXHRmdW5jdGlvbiBpc0FjY291bnQodmFsdWUpIHtcblx0ICAgIHJldHVybiAodmFsdWUgIT0gbnVsbCAmJiAoMCwgbGliJDEuaXNIZXhTdHJpbmcpKHZhbHVlLnByaXZhdGVLZXksIDMyKSAmJiB2YWx1ZS5hZGRyZXNzICE9IG51bGwpO1xuXHR9XG5cdGZ1bmN0aW9uIGhhc01uZW1vbmljKHZhbHVlKSB7XG5cdCAgICB2YXIgbW5lbW9uaWMgPSB2YWx1ZS5tbmVtb25pYztcblx0ICAgIHJldHVybiAobW5lbW9uaWMgJiYgbW5lbW9uaWMucGhyYXNlKTtcblx0fVxuXHR2YXIgV2FsbGV0ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuXHQgICAgX19leHRlbmRzKFdhbGxldCwgX3N1cGVyKTtcblx0ICAgIGZ1bmN0aW9uIFdhbGxldChwcml2YXRlS2V5LCBwcm92aWRlcikge1xuXHQgICAgICAgIHZhciBfbmV3VGFyZ2V0ID0gdGhpcy5jb25zdHJ1Y3Rvcjtcblx0ICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXHQgICAgICAgIGxvZ2dlci5jaGVja05ldyhfbmV3VGFyZ2V0LCBXYWxsZXQpO1xuXHQgICAgICAgIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcykgfHwgdGhpcztcblx0ICAgICAgICBpZiAoaXNBY2NvdW50KHByaXZhdGVLZXkpKSB7XG5cdCAgICAgICAgICAgIHZhciBzaWduaW5nS2V5XzEgPSBuZXcgbGliJGQuU2lnbmluZ0tleShwcml2YXRlS2V5LnByaXZhdGVLZXkpO1xuXHQgICAgICAgICAgICAoMCwgbGliJDMuZGVmaW5lUmVhZE9ubHkpKF90aGlzLCBcIl9zaWduaW5nS2V5XCIsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIHNpZ25pbmdLZXlfMTsgfSk7XG5cdCAgICAgICAgICAgICgwLCBsaWIkMy5kZWZpbmVSZWFkT25seSkoX3RoaXMsIFwiYWRkcmVzc1wiLCAoMCwgbGliJGUuY29tcHV0ZUFkZHJlc3MpKF90aGlzLnB1YmxpY0tleSkpO1xuXHQgICAgICAgICAgICBpZiAoX3RoaXMuYWRkcmVzcyAhPT0gKDAsIGxpYiQ2LmdldEFkZHJlc3MpKHByaXZhdGVLZXkuYWRkcmVzcykpIHtcblx0ICAgICAgICAgICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJwcml2YXRlS2V5L2FkZHJlc3MgbWlzbWF0Y2hcIiwgXCJwcml2YXRlS2V5XCIsIFwiW1JFREFDVEVEXVwiKTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICBpZiAoaGFzTW5lbW9uaWMocHJpdmF0ZUtleSkpIHtcblx0ICAgICAgICAgICAgICAgIHZhciBzcmNNbmVtb25pY18xID0gcHJpdmF0ZUtleS5tbmVtb25pYztcblx0ICAgICAgICAgICAgICAgICgwLCBsaWIkMy5kZWZpbmVSZWFkT25seSkoX3RoaXMsIFwiX21uZW1vbmljXCIsIGZ1bmN0aW9uICgpIHsgcmV0dXJuICh7XG5cdCAgICAgICAgICAgICAgICAgICAgcGhyYXNlOiBzcmNNbmVtb25pY18xLnBocmFzZSxcblx0ICAgICAgICAgICAgICAgICAgICBwYXRoOiBzcmNNbmVtb25pY18xLnBhdGggfHwgbGliJGsuZGVmYXVsdFBhdGgsXG5cdCAgICAgICAgICAgICAgICAgICAgbG9jYWxlOiBzcmNNbmVtb25pY18xLmxvY2FsZSB8fCBcImVuXCJcblx0ICAgICAgICAgICAgICAgIH0pOyB9KTtcblx0ICAgICAgICAgICAgICAgIHZhciBtbmVtb25pYyA9IF90aGlzLm1uZW1vbmljO1xuXHQgICAgICAgICAgICAgICAgdmFyIG5vZGUgPSBsaWIkay5IRE5vZGUuZnJvbU1uZW1vbmljKG1uZW1vbmljLnBocmFzZSwgbnVsbCwgbW5lbW9uaWMubG9jYWxlKS5kZXJpdmVQYXRoKG1uZW1vbmljLnBhdGgpO1xuXHQgICAgICAgICAgICAgICAgaWYgKCgwLCBsaWIkZS5jb21wdXRlQWRkcmVzcykobm9kZS5wcml2YXRlS2V5KSAhPT0gX3RoaXMuYWRkcmVzcykge1xuXHQgICAgICAgICAgICAgICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJtbmVtb25pYy9hZGRyZXNzIG1pc21hdGNoXCIsIFwicHJpdmF0ZUtleVwiLCBcIltSRURBQ1RFRF1cIik7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgZWxzZSB7XG5cdCAgICAgICAgICAgICAgICAoMCwgbGliJDMuZGVmaW5lUmVhZE9ubHkpKF90aGlzLCBcIl9tbmVtb25pY1wiLCBmdW5jdGlvbiAoKSB7IHJldHVybiBudWxsOyB9KTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH1cblx0ICAgICAgICBlbHNlIHtcblx0ICAgICAgICAgICAgaWYgKGxpYiRkLlNpZ25pbmdLZXkuaXNTaWduaW5nS2V5KHByaXZhdGVLZXkpKSB7XG5cdCAgICAgICAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cblx0ICAgICAgICAgICAgICAgIGlmIChwcml2YXRlS2V5LmN1cnZlICE9PSBcInNlY3AyNTZrMVwiKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcInVuc3VwcG9ydGVkIGN1cnZlOyBtdXN0IGJlIHNlY3AyNTZrMVwiLCBcInByaXZhdGVLZXlcIiwgXCJbUkVEQUNURURdXCIpO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgKDAsIGxpYiQzLmRlZmluZVJlYWRPbmx5KShfdGhpcywgXCJfc2lnbmluZ0tleVwiLCBmdW5jdGlvbiAoKSB7IHJldHVybiBwcml2YXRlS2V5OyB9KTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICBlbHNlIHtcblx0ICAgICAgICAgICAgICAgIC8vIEEgbG90IG9mIGNvbW1vbiB0b29scyBkbyBub3QgcHJlZml4IHByaXZhdGUga2V5cyB3aXRoIGEgMHggKHNlZTogIzExNjYpXG5cdCAgICAgICAgICAgICAgICBpZiAodHlwZW9mIChwcml2YXRlS2V5KSA9PT0gXCJzdHJpbmdcIikge1xuXHQgICAgICAgICAgICAgICAgICAgIGlmIChwcml2YXRlS2V5Lm1hdGNoKC9eWzAtOWEtZl0qJC9pKSAmJiBwcml2YXRlS2V5Lmxlbmd0aCA9PT0gNjQpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcHJpdmF0ZUtleSA9IFwiMHhcIiArIHByaXZhdGVLZXk7XG5cdCAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgdmFyIHNpZ25pbmdLZXlfMiA9IG5ldyBsaWIkZC5TaWduaW5nS2V5KHByaXZhdGVLZXkpO1xuXHQgICAgICAgICAgICAgICAgKDAsIGxpYiQzLmRlZmluZVJlYWRPbmx5KShfdGhpcywgXCJfc2lnbmluZ0tleVwiLCBmdW5jdGlvbiAoKSB7IHJldHVybiBzaWduaW5nS2V5XzI7IH0pO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICgwLCBsaWIkMy5kZWZpbmVSZWFkT25seSkoX3RoaXMsIFwiX21uZW1vbmljXCIsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIG51bGw7IH0pO1xuXHQgICAgICAgICAgICAoMCwgbGliJDMuZGVmaW5lUmVhZE9ubHkpKF90aGlzLCBcImFkZHJlc3NcIiwgKDAsIGxpYiRlLmNvbXB1dGVBZGRyZXNzKShfdGhpcy5wdWJsaWNLZXkpKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG5cdCAgICAgICAgaWYgKHByb3ZpZGVyICYmICFsaWIkYi5Qcm92aWRlci5pc1Byb3ZpZGVyKHByb3ZpZGVyKSkge1xuXHQgICAgICAgICAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwiaW52YWxpZCBwcm92aWRlclwiLCBcInByb3ZpZGVyXCIsIHByb3ZpZGVyKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgKDAsIGxpYiQzLmRlZmluZVJlYWRPbmx5KShfdGhpcywgXCJwcm92aWRlclwiLCBwcm92aWRlciB8fCBudWxsKTtcblx0ICAgICAgICByZXR1cm4gX3RoaXM7XG5cdCAgICB9XG5cdCAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoV2FsbGV0LnByb3RvdHlwZSwgXCJtbmVtb25pY1wiLCB7XG5cdCAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl9tbmVtb25pYygpOyB9LFxuXHQgICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuXHQgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuXHQgICAgfSk7XG5cdCAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoV2FsbGV0LnByb3RvdHlwZSwgXCJwcml2YXRlS2V5XCIsIHtcblx0ICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX3NpZ25pbmdLZXkoKS5wcml2YXRlS2V5OyB9LFxuXHQgICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuXHQgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuXHQgICAgfSk7XG5cdCAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoV2FsbGV0LnByb3RvdHlwZSwgXCJwdWJsaWNLZXlcIiwge1xuXHQgICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fc2lnbmluZ0tleSgpLnB1YmxpY0tleTsgfSxcblx0ICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcblx0ICAgICAgICBjb25maWd1cmFibGU6IHRydWVcblx0ICAgIH0pO1xuXHQgICAgV2FsbGV0LnByb3RvdHlwZS5nZXRBZGRyZXNzID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUodGhpcy5hZGRyZXNzKTtcblx0ICAgIH07XG5cdCAgICBXYWxsZXQucHJvdG90eXBlLmNvbm5lY3QgPSBmdW5jdGlvbiAocHJvdmlkZXIpIHtcblx0ICAgICAgICByZXR1cm4gbmV3IFdhbGxldCh0aGlzLCBwcm92aWRlcik7XG5cdCAgICB9O1xuXHQgICAgV2FsbGV0LnByb3RvdHlwZS5zaWduVHJhbnNhY3Rpb24gPSBmdW5jdGlvbiAodHJhbnNhY3Rpb24pIHtcblx0ICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXHQgICAgICAgIHJldHVybiAoMCwgbGliJDMucmVzb2x2ZVByb3BlcnRpZXMpKHRyYW5zYWN0aW9uKS50aGVuKGZ1bmN0aW9uICh0eCkge1xuXHQgICAgICAgICAgICBpZiAodHguZnJvbSAhPSBudWxsKSB7XG5cdCAgICAgICAgICAgICAgICBpZiAoKDAsIGxpYiQ2LmdldEFkZHJlc3MpKHR4LmZyb20pICE9PSBfdGhpcy5hZGRyZXNzKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcInRyYW5zYWN0aW9uIGZyb20gYWRkcmVzcyBtaXNtYXRjaFwiLCBcInRyYW5zYWN0aW9uLmZyb21cIiwgdHJhbnNhY3Rpb24uZnJvbSk7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICBkZWxldGUgdHguZnJvbTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB2YXIgc2lnbmF0dXJlID0gX3RoaXMuX3NpZ25pbmdLZXkoKS5zaWduRGlnZXN0KCgwLCBsaWIkNC5rZWNjYWsyNTYpKCgwLCBsaWIkZS5zZXJpYWxpemUpKHR4KSkpO1xuXHQgICAgICAgICAgICByZXR1cm4gKDAsIGxpYiRlLnNlcmlhbGl6ZSkodHgsIHNpZ25hdHVyZSk7XG5cdCAgICAgICAgfSk7XG5cdCAgICB9O1xuXHQgICAgV2FsbGV0LnByb3RvdHlwZS5zaWduTWVzc2FnZSA9IGZ1bmN0aW9uIChtZXNzYWdlKSB7XG5cdCAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgKDAsIGxpYiQxLmpvaW5TaWduYXR1cmUpKHRoaXMuX3NpZ25pbmdLZXkoKS5zaWduRGlnZXN0KCgwLCBsaWIkOS5oYXNoTWVzc2FnZSkobWVzc2FnZSkpKV07XG5cdCAgICAgICAgICAgIH0pO1xuXHQgICAgICAgIH0pO1xuXHQgICAgfTtcblx0ICAgIFdhbGxldC5wcm90b3R5cGUuX3NpZ25UeXBlZERhdGEgPSBmdW5jdGlvbiAoZG9tYWluLCB0eXBlcywgdmFsdWUpIHtcblx0ICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIHZhciBwb3B1bGF0ZWQ7XG5cdCAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cdCAgICAgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcblx0ICAgICAgICAgICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcblx0ICAgICAgICAgICAgICAgICAgICBjYXNlIDA6IHJldHVybiBbNCAvKnlpZWxkKi8sIGxpYiQ5Ll9UeXBlZERhdGFFbmNvZGVyLnJlc29sdmVOYW1lcyhkb21haW4sIHR5cGVzLCB2YWx1ZSwgZnVuY3Rpb24gKG5hbWUpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChfdGhpcy5wcm92aWRlciA9PSBudWxsKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbG9nZ2VyLnRocm93RXJyb3IoXCJjYW5ub3QgcmVzb2x2ZSBFTlMgbmFtZXMgd2l0aG91dCBhIHByb3ZpZGVyXCIsIGxpYi5Mb2dnZXIuZXJyb3JzLlVOU1VQUE9SVEVEX09QRVJBVElPTiwge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcGVyYXRpb246IFwicmVzb2x2ZU5hbWVcIixcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IG5hbWVcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfdGhpcy5wcm92aWRlci5yZXNvbHZlTmFtZShuYW1lKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfSldO1xuXHQgICAgICAgICAgICAgICAgICAgIGNhc2UgMTpcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcG9wdWxhdGVkID0gX2Euc2VudCgpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgKDAsIGxpYiQxLmpvaW5TaWduYXR1cmUpKHRoaXMuX3NpZ25pbmdLZXkoKS5zaWduRGlnZXN0KGxpYiQ5Ll9UeXBlZERhdGFFbmNvZGVyLmhhc2gocG9wdWxhdGVkLmRvbWFpbiwgdHlwZXMsIHBvcHVsYXRlZC52YWx1ZSkpKV07XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIH0pO1xuXHQgICAgICAgIH0pO1xuXHQgICAgfTtcblx0ICAgIFdhbGxldC5wcm90b3R5cGUuZW5jcnlwdCA9IGZ1bmN0aW9uIChwYXNzd29yZCwgb3B0aW9ucywgcHJvZ3Jlc3NDYWxsYmFjaykge1xuXHQgICAgICAgIGlmICh0eXBlb2YgKG9wdGlvbnMpID09PSBcImZ1bmN0aW9uXCIgJiYgIXByb2dyZXNzQ2FsbGJhY2spIHtcblx0ICAgICAgICAgICAgcHJvZ3Jlc3NDYWxsYmFjayA9IG9wdGlvbnM7XG5cdCAgICAgICAgICAgIG9wdGlvbnMgPSB7fTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgaWYgKHByb2dyZXNzQ2FsbGJhY2sgJiYgdHlwZW9mIChwcm9ncmVzc0NhbGxiYWNrKSAhPT0gXCJmdW5jdGlvblwiKSB7XG5cdCAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImludmFsaWQgY2FsbGJhY2tcIik7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGlmICghb3B0aW9ucykge1xuXHQgICAgICAgICAgICBvcHRpb25zID0ge307XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHJldHVybiAoMCwgbGliJG0uZW5jcnlwdEtleXN0b3JlKSh0aGlzLCBwYXNzd29yZCwgb3B0aW9ucywgcHJvZ3Jlc3NDYWxsYmFjayk7XG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdCAgICAgKiAgU3RhdGljIG1ldGhvZHMgdG8gY3JlYXRlIFdhbGxldCBpbnN0YW5jZXMuXG5cdCAgICAgKi9cblx0ICAgIFdhbGxldC5jcmVhdGVSYW5kb20gPSBmdW5jdGlvbiAob3B0aW9ucykge1xuXHQgICAgICAgIHZhciBlbnRyb3B5ID0gKDAsIGxpYiRsLnJhbmRvbUJ5dGVzKSgxNik7XG5cdCAgICAgICAgaWYgKCFvcHRpb25zKSB7XG5cdCAgICAgICAgICAgIG9wdGlvbnMgPSB7fTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgaWYgKG9wdGlvbnMuZXh0cmFFbnRyb3B5KSB7XG5cdCAgICAgICAgICAgIGVudHJvcHkgPSAoMCwgbGliJDEuYXJyYXlpZnkpKCgwLCBsaWIkMS5oZXhEYXRhU2xpY2UpKCgwLCBsaWIkNC5rZWNjYWsyNTYpKCgwLCBsaWIkMS5jb25jYXQpKFtlbnRyb3B5LCBvcHRpb25zLmV4dHJhRW50cm9weV0pKSwgMCwgMTYpKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgdmFyIG1uZW1vbmljID0gKDAsIGxpYiRrLmVudHJvcHlUb01uZW1vbmljKShlbnRyb3B5LCBvcHRpb25zLmxvY2FsZSk7XG5cdCAgICAgICAgcmV0dXJuIFdhbGxldC5mcm9tTW5lbW9uaWMobW5lbW9uaWMsIG9wdGlvbnMucGF0aCwgb3B0aW9ucy5sb2NhbGUpO1xuXHQgICAgfTtcblx0ICAgIFdhbGxldC5mcm9tRW5jcnlwdGVkSnNvbiA9IGZ1bmN0aW9uIChqc29uLCBwYXNzd29yZCwgcHJvZ3Jlc3NDYWxsYmFjaykge1xuXHQgICAgICAgIHJldHVybiAoMCwgbGliJG0uZGVjcnlwdEpzb25XYWxsZXQpKGpzb24sIHBhc3N3b3JkLCBwcm9ncmVzc0NhbGxiYWNrKS50aGVuKGZ1bmN0aW9uIChhY2NvdW50KSB7XG5cdCAgICAgICAgICAgIHJldHVybiBuZXcgV2FsbGV0KGFjY291bnQpO1xuXHQgICAgICAgIH0pO1xuXHQgICAgfTtcblx0ICAgIFdhbGxldC5mcm9tRW5jcnlwdGVkSnNvblN5bmMgPSBmdW5jdGlvbiAoanNvbiwgcGFzc3dvcmQpIHtcblx0ICAgICAgICByZXR1cm4gbmV3IFdhbGxldCgoMCwgbGliJG0uZGVjcnlwdEpzb25XYWxsZXRTeW5jKShqc29uLCBwYXNzd29yZCkpO1xuXHQgICAgfTtcblx0ICAgIFdhbGxldC5mcm9tTW5lbW9uaWMgPSBmdW5jdGlvbiAobW5lbW9uaWMsIHBhdGgsIHdvcmRsaXN0KSB7XG5cdCAgICAgICAgaWYgKCFwYXRoKSB7XG5cdCAgICAgICAgICAgIHBhdGggPSBsaWIkay5kZWZhdWx0UGF0aDtcblx0ICAgICAgICB9XG5cdCAgICAgICAgcmV0dXJuIG5ldyBXYWxsZXQobGliJGsuSEROb2RlLmZyb21NbmVtb25pYyhtbmVtb25pYywgbnVsbCwgd29yZGxpc3QpLmRlcml2ZVBhdGgocGF0aCkpO1xuXHQgICAgfTtcblx0ICAgIHJldHVybiBXYWxsZXQ7XG5cdH0obGliJGMuU2lnbmVyKSk7XG5cdGV4cG9ydHMuV2FsbGV0ID0gV2FsbGV0O1xuXHRmdW5jdGlvbiB2ZXJpZnlNZXNzYWdlKG1lc3NhZ2UsIHNpZ25hdHVyZSkge1xuXHQgICAgcmV0dXJuICgwLCBsaWIkZS5yZWNvdmVyQWRkcmVzcykoKDAsIGxpYiQ5Lmhhc2hNZXNzYWdlKShtZXNzYWdlKSwgc2lnbmF0dXJlKTtcblx0fVxuXHRleHBvcnRzLnZlcmlmeU1lc3NhZ2UgPSB2ZXJpZnlNZXNzYWdlO1xuXHRmdW5jdGlvbiB2ZXJpZnlUeXBlZERhdGEoZG9tYWluLCB0eXBlcywgdmFsdWUsIHNpZ25hdHVyZSkge1xuXHQgICAgcmV0dXJuICgwLCBsaWIkZS5yZWNvdmVyQWRkcmVzcykobGliJDkuX1R5cGVkRGF0YUVuY29kZXIuaGFzaChkb21haW4sIHR5cGVzLCB2YWx1ZSksIHNpZ25hdHVyZSk7XG5cdH1cblx0ZXhwb3J0cy52ZXJpZnlUeXBlZERhdGEgPSB2ZXJpZnlUeXBlZERhdGE7XG5cblx0fSk7XG5cblx0dmFyIGluZGV4JG4gPSAvKkBfX1BVUkVfXyovZ2V0RGVmYXVsdEV4cG9ydEZyb21DanMobGliJG4pO1xuXG5cdHZhciBfdmVyc2lvbiRFID0gY3JlYXRlQ29tbW9uanNNb2R1bGUoZnVuY3Rpb24gKG1vZHVsZSwgZXhwb3J0cykge1xuXHRcInVzZSBzdHJpY3RcIjtcblx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuXHRleHBvcnRzLnZlcnNpb24gPSB2b2lkIDA7XG5cdGV4cG9ydHMudmVyc2lvbiA9IFwibmV0d29ya3MvNS41LjBcIjtcblxuXHR9KTtcblxuXHR2YXIgX3ZlcnNpb24kRiA9IC8qQF9fUFVSRV9fKi9nZXREZWZhdWx0RXhwb3J0RnJvbUNqcyhfdmVyc2lvbiRFKTtcblxuXHR2YXIgbGliJG8gPSBjcmVhdGVDb21tb25qc01vZHVsZShmdW5jdGlvbiAobW9kdWxlLCBleHBvcnRzKSB7XG5cdFwidXNlIHN0cmljdFwiO1xuXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5cdGV4cG9ydHMuZ2V0TmV0d29yayA9IHZvaWQgMDtcblxuXG5cdHZhciBsb2dnZXIgPSBuZXcgbGliLkxvZ2dlcihfdmVyc2lvbiRFLnZlcnNpb24pO1xuXHQ7XG5cdGZ1bmN0aW9uIGlzUmVuZXR3b3JrYWJsZSh2YWx1ZSkge1xuXHQgICAgcmV0dXJuICh2YWx1ZSAmJiB0eXBlb2YgKHZhbHVlLnJlbmV0d29yaykgPT09IFwiZnVuY3Rpb25cIik7XG5cdH1cblx0ZnVuY3Rpb24gZXRoRGVmYXVsdFByb3ZpZGVyKG5ldHdvcmspIHtcblx0ICAgIHZhciBmdW5jID0gZnVuY3Rpb24gKHByb3ZpZGVycywgb3B0aW9ucykge1xuXHQgICAgICAgIGlmIChvcHRpb25zID09IG51bGwpIHtcblx0ICAgICAgICAgICAgb3B0aW9ucyA9IHt9O1xuXHQgICAgICAgIH1cblx0ICAgICAgICB2YXIgcHJvdmlkZXJMaXN0ID0gW107XG5cdCAgICAgICAgaWYgKHByb3ZpZGVycy5JbmZ1cmFQcm92aWRlcikge1xuXHQgICAgICAgICAgICB0cnkge1xuXHQgICAgICAgICAgICAgICAgcHJvdmlkZXJMaXN0LnB1c2gobmV3IHByb3ZpZGVycy5JbmZ1cmFQcm92aWRlcihuZXR3b3JrLCBvcHRpb25zLmluZnVyYSkpO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIGNhdGNoIChlcnJvcikgeyB9XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGlmIChwcm92aWRlcnMuRXRoZXJzY2FuUHJvdmlkZXIpIHtcblx0ICAgICAgICAgICAgdHJ5IHtcblx0ICAgICAgICAgICAgICAgIHByb3ZpZGVyTGlzdC5wdXNoKG5ldyBwcm92aWRlcnMuRXRoZXJzY2FuUHJvdmlkZXIobmV0d29yaywgb3B0aW9ucy5ldGhlcnNjYW4pKTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHsgfVxuXHQgICAgICAgIH1cblx0ICAgICAgICBpZiAocHJvdmlkZXJzLkFsY2hlbXlQcm92aWRlcikge1xuXHQgICAgICAgICAgICB0cnkge1xuXHQgICAgICAgICAgICAgICAgcHJvdmlkZXJMaXN0LnB1c2gobmV3IHByb3ZpZGVycy5BbGNoZW15UHJvdmlkZXIobmV0d29yaywgb3B0aW9ucy5hbGNoZW15KSk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7IH1cblx0ICAgICAgICB9XG5cdCAgICAgICAgaWYgKHByb3ZpZGVycy5Qb2NrZXRQcm92aWRlcikge1xuXHQgICAgICAgICAgICAvLyBUaGVzZSBuZXR3b3JrcyBhcmUgY3VycmVudGx5IGZhdWx0eSBvbiBQb2NrZXQgYXMgdGhlaXJcblx0ICAgICAgICAgICAgLy8gbmV0d29yayBkb2VzIG5vdCBoYW5kbGUgdGhlIEJlcmxpbiBoYXJkZm9yaywgd2hpY2ggaXNcblx0ICAgICAgICAgICAgLy8gbGl2ZSBvbiB0aGVzZSBvbmVzLlxuXHQgICAgICAgICAgICAvLyBAVE9ETzogVGhpcyBnb2VzIGF3YXkgb25jZSBQb2NrZXQgaGFzIHVwZ3JhZGVkIHRoZWlyIG5vZGVzXG5cdCAgICAgICAgICAgIHZhciBza2lwID0gW1wiZ29lcmxpXCIsIFwicm9wc3RlblwiLCBcInJpbmtlYnlcIl07XG5cdCAgICAgICAgICAgIHRyeSB7XG5cdCAgICAgICAgICAgICAgICB2YXIgcHJvdmlkZXIgPSBuZXcgcHJvdmlkZXJzLlBvY2tldFByb3ZpZGVyKG5ldHdvcmspO1xuXHQgICAgICAgICAgICAgICAgaWYgKHByb3ZpZGVyLm5ldHdvcmsgJiYgc2tpcC5pbmRleE9mKHByb3ZpZGVyLm5ldHdvcmsubmFtZSkgPT09IC0xKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgcHJvdmlkZXJMaXN0LnB1c2gocHJvdmlkZXIpO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIGNhdGNoIChlcnJvcikgeyB9XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGlmIChwcm92aWRlcnMuQ2xvdWRmbGFyZVByb3ZpZGVyKSB7XG5cdCAgICAgICAgICAgIHRyeSB7XG5cdCAgICAgICAgICAgICAgICBwcm92aWRlckxpc3QucHVzaChuZXcgcHJvdmlkZXJzLkNsb3VkZmxhcmVQcm92aWRlcihuZXR3b3JrKSk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7IH1cblx0ICAgICAgICB9XG5cdCAgICAgICAgaWYgKHByb3ZpZGVyTGlzdC5sZW5ndGggPT09IDApIHtcblx0ICAgICAgICAgICAgcmV0dXJuIG51bGw7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGlmIChwcm92aWRlcnMuRmFsbGJhY2tQcm92aWRlcikge1xuXHQgICAgICAgICAgICB2YXIgcXVvcnVtID0gMTtcblx0ICAgICAgICAgICAgaWYgKG9wdGlvbnMucXVvcnVtICE9IG51bGwpIHtcblx0ICAgICAgICAgICAgICAgIHF1b3J1bSA9IG9wdGlvbnMucXVvcnVtO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIGVsc2UgaWYgKG5ldHdvcmsgPT09IFwiaG9tZXN0ZWFkXCIpIHtcblx0ICAgICAgICAgICAgICAgIHF1b3J1bSA9IDI7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgcmV0dXJuIG5ldyBwcm92aWRlcnMuRmFsbGJhY2tQcm92aWRlcihwcm92aWRlckxpc3QsIHF1b3J1bSk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHJldHVybiBwcm92aWRlckxpc3RbMF07XG5cdCAgICB9O1xuXHQgICAgZnVuYy5yZW5ldHdvcmsgPSBmdW5jdGlvbiAobmV0d29yaykge1xuXHQgICAgICAgIHJldHVybiBldGhEZWZhdWx0UHJvdmlkZXIobmV0d29yayk7XG5cdCAgICB9O1xuXHQgICAgcmV0dXJuIGZ1bmM7XG5cdH1cblx0ZnVuY3Rpb24gZXRjRGVmYXVsdFByb3ZpZGVyKHVybCwgbmV0d29yaykge1xuXHQgICAgdmFyIGZ1bmMgPSBmdW5jdGlvbiAocHJvdmlkZXJzLCBvcHRpb25zKSB7XG5cdCAgICAgICAgaWYgKHByb3ZpZGVycy5Kc29uUnBjUHJvdmlkZXIpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIG5ldyBwcm92aWRlcnMuSnNvblJwY1Byb3ZpZGVyKHVybCwgbmV0d29yayk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHJldHVybiBudWxsO1xuXHQgICAgfTtcblx0ICAgIGZ1bmMucmVuZXR3b3JrID0gZnVuY3Rpb24gKG5ldHdvcmspIHtcblx0ICAgICAgICByZXR1cm4gZXRjRGVmYXVsdFByb3ZpZGVyKHVybCwgbmV0d29yayk7XG5cdCAgICB9O1xuXHQgICAgcmV0dXJuIGZ1bmM7XG5cdH1cblx0dmFyIGhvbWVzdGVhZCA9IHtcblx0ICAgIGNoYWluSWQ6IDEsXG5cdCAgICBlbnNBZGRyZXNzOiBcIjB4MDAwMDAwMDAwMDBDMkUwNzRlQzY5QTBkRmIyOTk3QkE2QzdkMmUxZVwiLFxuXHQgICAgbmFtZTogXCJob21lc3RlYWRcIixcblx0ICAgIF9kZWZhdWx0UHJvdmlkZXI6IGV0aERlZmF1bHRQcm92aWRlcihcImhvbWVzdGVhZFwiKVxuXHR9O1xuXHR2YXIgcm9wc3RlbiA9IHtcblx0ICAgIGNoYWluSWQ6IDMsXG5cdCAgICBlbnNBZGRyZXNzOiBcIjB4MDAwMDAwMDAwMDBDMkUwNzRlQzY5QTBkRmIyOTk3QkE2QzdkMmUxZVwiLFxuXHQgICAgbmFtZTogXCJyb3BzdGVuXCIsXG5cdCAgICBfZGVmYXVsdFByb3ZpZGVyOiBldGhEZWZhdWx0UHJvdmlkZXIoXCJyb3BzdGVuXCIpXG5cdH07XG5cdHZhciBjbGFzc2ljTW9yZG9yID0ge1xuXHQgICAgY2hhaW5JZDogNjMsXG5cdCAgICBuYW1lOiBcImNsYXNzaWNNb3Jkb3JcIixcblx0ICAgIF9kZWZhdWx0UHJvdmlkZXI6IGV0Y0RlZmF1bHRQcm92aWRlcihcImh0dHBzOi8vd3d3LmV0aGVyY2x1c3Rlci5jb20vbW9yZG9yXCIsIFwiY2xhc3NpY01vcmRvclwiKVxuXHR9O1xuXHR2YXIgbmV0d29ya3MgPSB7XG5cdCAgICB1bnNwZWNpZmllZDogeyBjaGFpbklkOiAwLCBuYW1lOiBcInVuc3BlY2lmaWVkXCIgfSxcblx0ICAgIGhvbWVzdGVhZDogaG9tZXN0ZWFkLFxuXHQgICAgbWFpbm5ldDogaG9tZXN0ZWFkLFxuXHQgICAgbW9yZGVuOiB7IGNoYWluSWQ6IDIsIG5hbWU6IFwibW9yZGVuXCIgfSxcblx0ICAgIHJvcHN0ZW46IHJvcHN0ZW4sXG5cdCAgICB0ZXN0bmV0OiByb3BzdGVuLFxuXHQgICAgcmlua2VieToge1xuXHQgICAgICAgIGNoYWluSWQ6IDQsXG5cdCAgICAgICAgZW5zQWRkcmVzczogXCIweDAwMDAwMDAwMDAwQzJFMDc0ZUM2OUEwZEZiMjk5N0JBNkM3ZDJlMWVcIixcblx0ICAgICAgICBuYW1lOiBcInJpbmtlYnlcIixcblx0ICAgICAgICBfZGVmYXVsdFByb3ZpZGVyOiBldGhEZWZhdWx0UHJvdmlkZXIoXCJyaW5rZWJ5XCIpXG5cdCAgICB9LFxuXHQgICAga292YW46IHtcblx0ICAgICAgICBjaGFpbklkOiA0Mixcblx0ICAgICAgICBuYW1lOiBcImtvdmFuXCIsXG5cdCAgICAgICAgX2RlZmF1bHRQcm92aWRlcjogZXRoRGVmYXVsdFByb3ZpZGVyKFwia292YW5cIilcblx0ICAgIH0sXG5cdCAgICBnb2VybGk6IHtcblx0ICAgICAgICBjaGFpbklkOiA1LFxuXHQgICAgICAgIGVuc0FkZHJlc3M6IFwiMHgwMDAwMDAwMDAwMEMyRTA3NGVDNjlBMGRGYjI5OTdCQTZDN2QyZTFlXCIsXG5cdCAgICAgICAgbmFtZTogXCJnb2VybGlcIixcblx0ICAgICAgICBfZGVmYXVsdFByb3ZpZGVyOiBldGhEZWZhdWx0UHJvdmlkZXIoXCJnb2VybGlcIilcblx0ICAgIH0sXG5cdCAgICAvLyBFVEMgKFNlZTogIzM1MSlcblx0ICAgIGNsYXNzaWM6IHtcblx0ICAgICAgICBjaGFpbklkOiA2MSxcblx0ICAgICAgICBuYW1lOiBcImNsYXNzaWNcIixcblx0ICAgICAgICBfZGVmYXVsdFByb3ZpZGVyOiBldGNEZWZhdWx0UHJvdmlkZXIoXCJodHRwczovXFwvd3d3LmV0aGVyY2x1c3Rlci5jb20vZXRjXCIsIFwiY2xhc3NpY1wiKVxuXHQgICAgfSxcblx0ICAgIGNsYXNzaWNNb3JkZW46IHsgY2hhaW5JZDogNjIsIG5hbWU6IFwiY2xhc3NpY01vcmRlblwiIH0sXG5cdCAgICBjbGFzc2ljTW9yZG9yOiBjbGFzc2ljTW9yZG9yLFxuXHQgICAgY2xhc3NpY1Rlc3RuZXQ6IGNsYXNzaWNNb3Jkb3IsXG5cdCAgICBjbGFzc2ljS290dGk6IHtcblx0ICAgICAgICBjaGFpbklkOiA2LFxuXHQgICAgICAgIG5hbWU6IFwiY2xhc3NpY0tvdHRpXCIsXG5cdCAgICAgICAgX2RlZmF1bHRQcm92aWRlcjogZXRjRGVmYXVsdFByb3ZpZGVyKFwiaHR0cHM6L1xcL3d3dy5ldGhlcmNsdXN0ZXIuY29tL2tvdHRpXCIsIFwiY2xhc3NpY0tvdHRpXCIpXG5cdCAgICB9LFxuXHQgICAgeGRhaTogeyBjaGFpbklkOiAxMDAsIG5hbWU6IFwieGRhaVwiIH0sXG5cdCAgICBtYXRpYzogeyBjaGFpbklkOiAxMzcsIG5hbWU6IFwibWF0aWNcIiB9LFxuXHQgICAgbWF0aWNtdW06IHsgY2hhaW5JZDogODAwMDEsIG5hbWU6IFwibWF0aWNtdW1cIiB9LFxuXHQgICAgYm5iOiB7IGNoYWluSWQ6IDU2LCBuYW1lOiBcImJuYlwiIH0sXG5cdCAgICBibmJ0OiB7IGNoYWluSWQ6IDk3LCBuYW1lOiBcImJuYnRcIiB9LFxuXHR9O1xuXHQvKipcblx0ICogIGdldE5ldHdvcmtcblx0ICpcblx0ICogIENvbnZlcnRzIGEgbmFtZWQgY29tbW9uIG5ldHdvcmtzIG9yIGNoYWluIElEIChuZXR3b3JrIElEKSB0byBhIE5ldHdvcmtcblx0ICogIGFuZCB2ZXJpZmllcyBhIG5ldHdvcmsgaXMgYSB2YWxpZCBOZXR3b3JrLi5cblx0ICovXG5cdGZ1bmN0aW9uIGdldE5ldHdvcmsobmV0d29yaykge1xuXHQgICAgLy8gTm8gbmV0d29yayAobnVsbClcblx0ICAgIGlmIChuZXR3b3JrID09IG51bGwpIHtcblx0ICAgICAgICByZXR1cm4gbnVsbDtcblx0ICAgIH1cblx0ICAgIGlmICh0eXBlb2YgKG5ldHdvcmspID09PSBcIm51bWJlclwiKSB7XG5cdCAgICAgICAgZm9yICh2YXIgbmFtZV8xIGluIG5ldHdvcmtzKSB7XG5cdCAgICAgICAgICAgIHZhciBzdGFuZGFyZF8xID0gbmV0d29ya3NbbmFtZV8xXTtcblx0ICAgICAgICAgICAgaWYgKHN0YW5kYXJkXzEuY2hhaW5JZCA9PT0gbmV0d29yaykge1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuIHtcblx0ICAgICAgICAgICAgICAgICAgICBuYW1lOiBzdGFuZGFyZF8xLm5hbWUsXG5cdCAgICAgICAgICAgICAgICAgICAgY2hhaW5JZDogc3RhbmRhcmRfMS5jaGFpbklkLFxuXHQgICAgICAgICAgICAgICAgICAgIGVuc0FkZHJlc3M6IChzdGFuZGFyZF8xLmVuc0FkZHJlc3MgfHwgbnVsbCksXG5cdCAgICAgICAgICAgICAgICAgICAgX2RlZmF1bHRQcm92aWRlcjogKHN0YW5kYXJkXzEuX2RlZmF1bHRQcm92aWRlciB8fCBudWxsKVxuXHQgICAgICAgICAgICAgICAgfTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH1cblx0ICAgICAgICByZXR1cm4ge1xuXHQgICAgICAgICAgICBjaGFpbklkOiBuZXR3b3JrLFxuXHQgICAgICAgICAgICBuYW1lOiBcInVua25vd25cIlxuXHQgICAgICAgIH07XG5cdCAgICB9XG5cdCAgICBpZiAodHlwZW9mIChuZXR3b3JrKSA9PT0gXCJzdHJpbmdcIikge1xuXHQgICAgICAgIHZhciBzdGFuZGFyZF8yID0gbmV0d29ya3NbbmV0d29ya107XG5cdCAgICAgICAgaWYgKHN0YW5kYXJkXzIgPT0gbnVsbCkge1xuXHQgICAgICAgICAgICByZXR1cm4gbnVsbDtcblx0ICAgICAgICB9XG5cdCAgICAgICAgcmV0dXJuIHtcblx0ICAgICAgICAgICAgbmFtZTogc3RhbmRhcmRfMi5uYW1lLFxuXHQgICAgICAgICAgICBjaGFpbklkOiBzdGFuZGFyZF8yLmNoYWluSWQsXG5cdCAgICAgICAgICAgIGVuc0FkZHJlc3M6IHN0YW5kYXJkXzIuZW5zQWRkcmVzcyxcblx0ICAgICAgICAgICAgX2RlZmF1bHRQcm92aWRlcjogKHN0YW5kYXJkXzIuX2RlZmF1bHRQcm92aWRlciB8fCBudWxsKVxuXHQgICAgICAgIH07XG5cdCAgICB9XG5cdCAgICB2YXIgc3RhbmRhcmQgPSBuZXR3b3Jrc1tuZXR3b3JrLm5hbWVdO1xuXHQgICAgLy8gTm90IGEgc3RhbmRhcmQgbmV0d29yazsgY2hlY2sgdGhhdCBpdCBpcyBhIHZhbGlkIG5ldHdvcmsgaW4gZ2VuZXJhbFxuXHQgICAgaWYgKCFzdGFuZGFyZCkge1xuXHQgICAgICAgIGlmICh0eXBlb2YgKG5ldHdvcmsuY2hhaW5JZCkgIT09IFwibnVtYmVyXCIpIHtcblx0ICAgICAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcImludmFsaWQgbmV0d29yayBjaGFpbklkXCIsIFwibmV0d29ya1wiLCBuZXR3b3JrKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgcmV0dXJuIG5ldHdvcms7XG5cdCAgICB9XG5cdCAgICAvLyBNYWtlIHN1cmUgdGhlIGNoYWluSWQgbWF0Y2hlcyB0aGUgZXhwZWN0ZWQgbmV0d29yayBjaGFpbklkIChvciBpcyAwOyBkaXNhYmxlIEVJUC0xNTUpXG5cdCAgICBpZiAobmV0d29yay5jaGFpbklkICE9PSAwICYmIG5ldHdvcmsuY2hhaW5JZCAhPT0gc3RhbmRhcmQuY2hhaW5JZCkge1xuXHQgICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJuZXR3b3JrIGNoYWluSWQgbWlzbWF0Y2hcIiwgXCJuZXR3b3JrXCIsIG5ldHdvcmspO1xuXHQgICAgfVxuXHQgICAgLy8gQFRPRE86IEluIHRoZSBuZXh0IG1ham9yIHZlcnNpb24gYWRkIGFuIGF0dGFjaCBmdW5jdGlvbiB0byBhIGRlZmF1bHRQcm92aWRlclxuXHQgICAgLy8gY2xhc3MgYW5kIG1vdmUgdGhlIF9kZWZhdWx0UHJvdmlkZXIgaW50ZXJuYWwgdG8gdGhpcyBmaWxlIChleHRlbmQgTmV0d29yaylcblx0ICAgIHZhciBkZWZhdWx0UHJvdmlkZXIgPSBuZXR3b3JrLl9kZWZhdWx0UHJvdmlkZXIgfHwgbnVsbDtcblx0ICAgIGlmIChkZWZhdWx0UHJvdmlkZXIgPT0gbnVsbCAmJiBzdGFuZGFyZC5fZGVmYXVsdFByb3ZpZGVyKSB7XG5cdCAgICAgICAgaWYgKGlzUmVuZXR3b3JrYWJsZShzdGFuZGFyZC5fZGVmYXVsdFByb3ZpZGVyKSkge1xuXHQgICAgICAgICAgICBkZWZhdWx0UHJvdmlkZXIgPSBzdGFuZGFyZC5fZGVmYXVsdFByb3ZpZGVyLnJlbmV0d29yayhuZXR3b3JrKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgZWxzZSB7XG5cdCAgICAgICAgICAgIGRlZmF1bHRQcm92aWRlciA9IHN0YW5kYXJkLl9kZWZhdWx0UHJvdmlkZXI7XG5cdCAgICAgICAgfVxuXHQgICAgfVxuXHQgICAgLy8gU3RhbmRhcmQgTmV0d29yayAoYWxsb3cgb3ZlcnJpZGluZyB0aGUgRU5TIGFkZHJlc3MpXG5cdCAgICByZXR1cm4ge1xuXHQgICAgICAgIG5hbWU6IG5ldHdvcmsubmFtZSxcblx0ICAgICAgICBjaGFpbklkOiBzdGFuZGFyZC5jaGFpbklkLFxuXHQgICAgICAgIGVuc0FkZHJlc3M6IChuZXR3b3JrLmVuc0FkZHJlc3MgfHwgc3RhbmRhcmQuZW5zQWRkcmVzcyB8fCBudWxsKSxcblx0ICAgICAgICBfZGVmYXVsdFByb3ZpZGVyOiBkZWZhdWx0UHJvdmlkZXJcblx0ICAgIH07XG5cdH1cblx0ZXhwb3J0cy5nZXROZXR3b3JrID0gZ2V0TmV0d29yaztcblxuXHR9KTtcblxuXHR2YXIgaW5kZXgkbyA9IC8qQF9fUFVSRV9fKi9nZXREZWZhdWx0RXhwb3J0RnJvbUNqcyhsaWIkbyk7XG5cblx0dmFyIGJyb3dzZXJCYXNlNjQgPSBjcmVhdGVDb21tb25qc01vZHVsZShmdW5jdGlvbiAobW9kdWxlLCBleHBvcnRzKSB7XG5cdFwidXNlIHN0cmljdFwiO1xuXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5cdGV4cG9ydHMuZW5jb2RlID0gZXhwb3J0cy5kZWNvZGUgPSB2b2lkIDA7XG5cblx0ZnVuY3Rpb24gZGVjb2RlKHRleHREYXRhKSB7XG5cdCAgICB0ZXh0RGF0YSA9IGF0b2IodGV4dERhdGEpO1xuXHQgICAgdmFyIGRhdGEgPSBbXTtcblx0ICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGV4dERhdGEubGVuZ3RoOyBpKyspIHtcblx0ICAgICAgICBkYXRhLnB1c2godGV4dERhdGEuY2hhckNvZGVBdChpKSk7XG5cdCAgICB9XG5cdCAgICByZXR1cm4gKDAsIGxpYiQxLmFycmF5aWZ5KShkYXRhKTtcblx0fVxuXHRleHBvcnRzLmRlY29kZSA9IGRlY29kZTtcblx0ZnVuY3Rpb24gZW5jb2RlKGRhdGEpIHtcblx0ICAgIGRhdGEgPSAoMCwgbGliJDEuYXJyYXlpZnkpKGRhdGEpO1xuXHQgICAgdmFyIHRleHREYXRhID0gXCJcIjtcblx0ICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZGF0YS5sZW5ndGg7IGkrKykge1xuXHQgICAgICAgIHRleHREYXRhICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoZGF0YVtpXSk7XG5cdCAgICB9XG5cdCAgICByZXR1cm4gYnRvYSh0ZXh0RGF0YSk7XG5cdH1cblx0ZXhwb3J0cy5lbmNvZGUgPSBlbmNvZGU7XG5cblx0fSk7XG5cblx0dmFyIGJyb3dzZXJCYXNlNjQkMSA9IC8qQF9fUFVSRV9fKi9nZXREZWZhdWx0RXhwb3J0RnJvbUNqcyhicm93c2VyQmFzZTY0KTtcblxuXHR2YXIgbGliJHAgPSBjcmVhdGVDb21tb25qc01vZHVsZShmdW5jdGlvbiAobW9kdWxlLCBleHBvcnRzKSB7XG5cdFwidXNlIHN0cmljdFwiO1xuXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5cdGV4cG9ydHMuZW5jb2RlID0gZXhwb3J0cy5kZWNvZGUgPSB2b2lkIDA7XG5cblx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiZGVjb2RlXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBicm93c2VyQmFzZTY0LmRlY29kZTsgfSB9KTtcblx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiZW5jb2RlXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBicm93c2VyQmFzZTY0LmVuY29kZTsgfSB9KTtcblxuXHR9KTtcblxuXHR2YXIgaW5kZXgkcCA9IC8qQF9fUFVSRV9fKi9nZXREZWZhdWx0RXhwb3J0RnJvbUNqcyhsaWIkcCk7XG5cblx0dmFyIF92ZXJzaW9uJEcgPSBjcmVhdGVDb21tb25qc01vZHVsZShmdW5jdGlvbiAobW9kdWxlLCBleHBvcnRzKSB7XG5cdFwidXNlIHN0cmljdFwiO1xuXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5cdGV4cG9ydHMudmVyc2lvbiA9IHZvaWQgMDtcblx0ZXhwb3J0cy52ZXJzaW9uID0gXCJ3ZWIvNS41LjBcIjtcblxuXHR9KTtcblxuXHR2YXIgX3ZlcnNpb24kSCA9IC8qQF9fUFVSRV9fKi9nZXREZWZhdWx0RXhwb3J0RnJvbUNqcyhfdmVyc2lvbiRHKTtcblxuXHR2YXIgYnJvd3NlckdldHVybCA9IGNyZWF0ZUNvbW1vbmpzTW9kdWxlKGZ1bmN0aW9uIChtb2R1bGUsIGV4cG9ydHMpIHtcblx0XCJ1c2Ugc3RyaWN0XCI7XG5cdHZhciBfX2F3YWl0ZXIgPSAoY29tbW9uanNHbG9iYWwgJiYgY29tbW9uanNHbG9iYWwuX19hd2FpdGVyKSB8fCBmdW5jdGlvbiAodGhpc0FyZywgX2FyZ3VtZW50cywgUCwgZ2VuZXJhdG9yKSB7XG5cdCAgICBmdW5jdGlvbiBhZG9wdCh2YWx1ZSkgeyByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBQID8gdmFsdWUgOiBuZXcgUChmdW5jdGlvbiAocmVzb2x2ZSkgeyByZXNvbHZlKHZhbHVlKTsgfSk7IH1cblx0ICAgIHJldHVybiBuZXcgKFAgfHwgKFAgPSBQcm9taXNlKSkoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuXHQgICAgICAgIGZ1bmN0aW9uIGZ1bGZpbGxlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvci5uZXh0KHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cblx0ICAgICAgICBmdW5jdGlvbiByZWplY3RlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvcltcInRocm93XCJdKHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cblx0ICAgICAgICBmdW5jdGlvbiBzdGVwKHJlc3VsdCkgeyByZXN1bHQuZG9uZSA/IHJlc29sdmUocmVzdWx0LnZhbHVlKSA6IGFkb3B0KHJlc3VsdC52YWx1ZSkudGhlbihmdWxmaWxsZWQsIHJlamVjdGVkKTsgfVxuXHQgICAgICAgIHN0ZXAoKGdlbmVyYXRvciA9IGdlbmVyYXRvci5hcHBseSh0aGlzQXJnLCBfYXJndW1lbnRzIHx8IFtdKSkubmV4dCgpKTtcblx0ICAgIH0pO1xuXHR9O1xuXHR2YXIgX19nZW5lcmF0b3IgPSAoY29tbW9uanNHbG9iYWwgJiYgY29tbW9uanNHbG9iYWwuX19nZW5lcmF0b3IpIHx8IGZ1bmN0aW9uICh0aGlzQXJnLCBib2R5KSB7XG5cdCAgICB2YXIgXyA9IHsgbGFiZWw6IDAsIHNlbnQ6IGZ1bmN0aW9uKCkgeyBpZiAodFswXSAmIDEpIHRocm93IHRbMV07IHJldHVybiB0WzFdOyB9LCB0cnlzOiBbXSwgb3BzOiBbXSB9LCBmLCB5LCB0LCBnO1xuXHQgICAgcmV0dXJuIGcgPSB7IG5leHQ6IHZlcmIoMCksIFwidGhyb3dcIjogdmVyYigxKSwgXCJyZXR1cm5cIjogdmVyYigyKSB9LCB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgKGdbU3ltYm9sLml0ZXJhdG9yXSA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpczsgfSksIGc7XG5cdCAgICBmdW5jdGlvbiB2ZXJiKG4pIHsgcmV0dXJuIGZ1bmN0aW9uICh2KSB7IHJldHVybiBzdGVwKFtuLCB2XSk7IH07IH1cblx0ICAgIGZ1bmN0aW9uIHN0ZXAob3ApIHtcblx0ICAgICAgICBpZiAoZikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkdlbmVyYXRvciBpcyBhbHJlYWR5IGV4ZWN1dGluZy5cIik7XG5cdCAgICAgICAgd2hpbGUgKF8pIHRyeSB7XG5cdCAgICAgICAgICAgIGlmIChmID0gMSwgeSAmJiAodCA9IG9wWzBdICYgMiA/IHlbXCJyZXR1cm5cIl0gOiBvcFswXSA/IHlbXCJ0aHJvd1wiXSB8fCAoKHQgPSB5W1wicmV0dXJuXCJdKSAmJiB0LmNhbGwoeSksIDApIDogeS5uZXh0KSAmJiAhKHQgPSB0LmNhbGwoeSwgb3BbMV0pKS5kb25lKSByZXR1cm4gdDtcblx0ICAgICAgICAgICAgaWYgKHkgPSAwLCB0KSBvcCA9IFtvcFswXSAmIDIsIHQudmFsdWVdO1xuXHQgICAgICAgICAgICBzd2l0Y2ggKG9wWzBdKSB7XG5cdCAgICAgICAgICAgICAgICBjYXNlIDA6IGNhc2UgMTogdCA9IG9wOyBicmVhaztcblx0ICAgICAgICAgICAgICAgIGNhc2UgNDogXy5sYWJlbCsrOyByZXR1cm4geyB2YWx1ZTogb3BbMV0sIGRvbmU6IGZhbHNlIH07XG5cdCAgICAgICAgICAgICAgICBjYXNlIDU6IF8ubGFiZWwrKzsgeSA9IG9wWzFdOyBvcCA9IFswXTsgY29udGludWU7XG5cdCAgICAgICAgICAgICAgICBjYXNlIDc6IG9wID0gXy5vcHMucG9wKCk7IF8udHJ5cy5wb3AoKTsgY29udGludWU7XG5cdCAgICAgICAgICAgICAgICBkZWZhdWx0OlxuXHQgICAgICAgICAgICAgICAgICAgIGlmICghKHQgPSBfLnRyeXMsIHQgPSB0Lmxlbmd0aCA+IDAgJiYgdFt0Lmxlbmd0aCAtIDFdKSAmJiAob3BbMF0gPT09IDYgfHwgb3BbMF0gPT09IDIpKSB7IF8gPSAwOyBjb250aW51ZTsgfVxuXHQgICAgICAgICAgICAgICAgICAgIGlmIChvcFswXSA9PT0gMyAmJiAoIXQgfHwgKG9wWzFdID4gdFswXSAmJiBvcFsxXSA8IHRbM10pKSkgeyBfLmxhYmVsID0gb3BbMV07IGJyZWFrOyB9XG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKG9wWzBdID09PSA2ICYmIF8ubGFiZWwgPCB0WzFdKSB7IF8ubGFiZWwgPSB0WzFdOyB0ID0gb3A7IGJyZWFrOyB9XG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKHQgJiYgXy5sYWJlbCA8IHRbMl0pIHsgXy5sYWJlbCA9IHRbMl07IF8ub3BzLnB1c2gob3ApOyBicmVhazsgfVxuXHQgICAgICAgICAgICAgICAgICAgIGlmICh0WzJdKSBfLm9wcy5wb3AoKTtcblx0ICAgICAgICAgICAgICAgICAgICBfLnRyeXMucG9wKCk7IGNvbnRpbnVlO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIG9wID0gYm9keS5jYWxsKHRoaXNBcmcsIF8pO1xuXHQgICAgICAgIH0gY2F0Y2ggKGUpIHsgb3AgPSBbNiwgZV07IHkgPSAwOyB9IGZpbmFsbHkgeyBmID0gdCA9IDA7IH1cblx0ICAgICAgICBpZiAob3BbMF0gJiA1KSB0aHJvdyBvcFsxXTsgcmV0dXJuIHsgdmFsdWU6IG9wWzBdID8gb3BbMV0gOiB2b2lkIDAsIGRvbmU6IHRydWUgfTtcblx0ICAgIH1cblx0fTtcblx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuXHRleHBvcnRzLmdldFVybCA9IHZvaWQgMDtcblxuXHRmdW5jdGlvbiBnZXRVcmwoaHJlZiwgb3B0aW9ucykge1xuXHQgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIHZhciByZXF1ZXN0LCByZXNwb25zZSwgYm9keSwgaGVhZGVycztcblx0ICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG5cdCAgICAgICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcblx0ICAgICAgICAgICAgICAgIGNhc2UgMDpcblx0ICAgICAgICAgICAgICAgICAgICBpZiAob3B0aW9ucyA9PSBudWxsKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnMgPSB7fTtcblx0ICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgcmVxdWVzdCA9IHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgbWV0aG9kOiAob3B0aW9ucy5tZXRob2QgfHwgXCJHRVRcIiksXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGhlYWRlcnM6IChvcHRpb25zLmhlYWRlcnMgfHwge30pLFxuXHQgICAgICAgICAgICAgICAgICAgICAgICBib2R5OiAob3B0aW9ucy5ib2R5IHx8IHVuZGVmaW5lZCksXG5cdCAgICAgICAgICAgICAgICAgICAgfTtcblx0ICAgICAgICAgICAgICAgICAgICBpZiAob3B0aW9ucy5za2lwRmV0Y2hTZXR1cCAhPT0gdHJ1ZSkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICByZXF1ZXN0Lm1vZGUgPSBcImNvcnNcIjsgLy8gbm8tY29ycywgY29ycywgKnNhbWUtb3JpZ2luXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJlcXVlc3QuY2FjaGUgPSBcIm5vLWNhY2hlXCI7IC8vICpkZWZhdWx0LCBuby1jYWNoZSwgcmVsb2FkLCBmb3JjZS1jYWNoZSwgb25seS1pZi1jYWNoZWRcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcmVxdWVzdC5jcmVkZW50aWFscyA9IFwic2FtZS1vcmlnaW5cIjsgLy8gaW5jbHVkZSwgKnNhbWUtb3JpZ2luLCBvbWl0XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJlcXVlc3QucmVkaXJlY3QgPSBcImZvbGxvd1wiOyAvLyBtYW51YWwsICpmb2xsb3csIGVycm9yXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJlcXVlc3QucmVmZXJyZXIgPSBcImNsaWVudFwiOyAvLyBuby1yZWZlcnJlciwgKmNsaWVudFxuXHQgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICA7XG5cdCAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgZmV0Y2goaHJlZiwgcmVxdWVzdCldO1xuXHQgICAgICAgICAgICAgICAgY2FzZSAxOlxuXHQgICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlID0gX2Euc2VudCgpO1xuXHQgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIHJlc3BvbnNlLmFycmF5QnVmZmVyKCldO1xuXHQgICAgICAgICAgICAgICAgY2FzZSAyOlxuXHQgICAgICAgICAgICAgICAgICAgIGJvZHkgPSBfYS5zZW50KCk7XG5cdCAgICAgICAgICAgICAgICAgICAgaGVhZGVycyA9IHt9O1xuXHQgICAgICAgICAgICAgICAgICAgIGlmIChyZXNwb25zZS5oZWFkZXJzLmZvckVhY2gpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2UuaGVhZGVycy5mb3JFYWNoKGZ1bmN0aW9uICh2YWx1ZSwga2V5KSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBoZWFkZXJzW2tleS50b0xvd2VyQ2FzZSgpXSA9IHZhbHVlO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB9KTtcblx0ICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICgocmVzcG9uc2UuaGVhZGVycykua2V5cykoKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhlYWRlcnNba2V5LnRvTG93ZXJDYXNlKCldID0gcmVzcG9uc2UuaGVhZGVycy5nZXQoa2V5KTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBoZWFkZXJzOiBoZWFkZXJzLFxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhdHVzQ29kZTogcmVzcG9uc2Uuc3RhdHVzLFxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhdHVzTWVzc2FnZTogcmVzcG9uc2Uuc3RhdHVzVGV4dCxcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJvZHk6ICgwLCBsaWIkMS5hcnJheWlmeSkobmV3IFVpbnQ4QXJyYXkoYm9keSkpLFxuXHQgICAgICAgICAgICAgICAgICAgICAgICB9XTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH0pO1xuXHQgICAgfSk7XG5cdH1cblx0ZXhwb3J0cy5nZXRVcmwgPSBnZXRVcmw7XG5cblx0fSk7XG5cblx0dmFyIGJyb3dzZXJHZXR1cmwkMSA9IC8qQF9fUFVSRV9fKi9nZXREZWZhdWx0RXhwb3J0RnJvbUNqcyhicm93c2VyR2V0dXJsKTtcblxuXHR2YXIgbGliJHEgPSBjcmVhdGVDb21tb25qc01vZHVsZShmdW5jdGlvbiAobW9kdWxlLCBleHBvcnRzKSB7XG5cdFwidXNlIHN0cmljdFwiO1xuXHR2YXIgX19hd2FpdGVyID0gKGNvbW1vbmpzR2xvYmFsICYmIGNvbW1vbmpzR2xvYmFsLl9fYXdhaXRlcikgfHwgZnVuY3Rpb24gKHRoaXNBcmcsIF9hcmd1bWVudHMsIFAsIGdlbmVyYXRvcikge1xuXHQgICAgZnVuY3Rpb24gYWRvcHQodmFsdWUpIHsgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgUCA/IHZhbHVlIDogbmV3IFAoZnVuY3Rpb24gKHJlc29sdmUpIHsgcmVzb2x2ZSh2YWx1ZSk7IH0pOyB9XG5cdCAgICByZXR1cm4gbmV3IChQIHx8IChQID0gUHJvbWlzZSkpKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcblx0ICAgICAgICBmdW5jdGlvbiBmdWxmaWxsZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3IubmV4dCh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG5cdCAgICAgICAgZnVuY3Rpb24gcmVqZWN0ZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3JbXCJ0aHJvd1wiXSh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG5cdCAgICAgICAgZnVuY3Rpb24gc3RlcChyZXN1bHQpIHsgcmVzdWx0LmRvbmUgPyByZXNvbHZlKHJlc3VsdC52YWx1ZSkgOiBhZG9wdChyZXN1bHQudmFsdWUpLnRoZW4oZnVsZmlsbGVkLCByZWplY3RlZCk7IH1cblx0ICAgICAgICBzdGVwKChnZW5lcmF0b3IgPSBnZW5lcmF0b3IuYXBwbHkodGhpc0FyZywgX2FyZ3VtZW50cyB8fCBbXSkpLm5leHQoKSk7XG5cdCAgICB9KTtcblx0fTtcblx0dmFyIF9fZ2VuZXJhdG9yID0gKGNvbW1vbmpzR2xvYmFsICYmIGNvbW1vbmpzR2xvYmFsLl9fZ2VuZXJhdG9yKSB8fCBmdW5jdGlvbiAodGhpc0FyZywgYm9keSkge1xuXHQgICAgdmFyIF8gPSB7IGxhYmVsOiAwLCBzZW50OiBmdW5jdGlvbigpIHsgaWYgKHRbMF0gJiAxKSB0aHJvdyB0WzFdOyByZXR1cm4gdFsxXTsgfSwgdHJ5czogW10sIG9wczogW10gfSwgZiwgeSwgdCwgZztcblx0ICAgIHJldHVybiBnID0geyBuZXh0OiB2ZXJiKDApLCBcInRocm93XCI6IHZlcmIoMSksIFwicmV0dXJuXCI6IHZlcmIoMikgfSwgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIChnW1N5bWJvbC5pdGVyYXRvcl0gPSBmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXM7IH0pLCBnO1xuXHQgICAgZnVuY3Rpb24gdmVyYihuKSB7IHJldHVybiBmdW5jdGlvbiAodikgeyByZXR1cm4gc3RlcChbbiwgdl0pOyB9OyB9XG5cdCAgICBmdW5jdGlvbiBzdGVwKG9wKSB7XG5cdCAgICAgICAgaWYgKGYpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJHZW5lcmF0b3IgaXMgYWxyZWFkeSBleGVjdXRpbmcuXCIpO1xuXHQgICAgICAgIHdoaWxlIChfKSB0cnkge1xuXHQgICAgICAgICAgICBpZiAoZiA9IDEsIHkgJiYgKHQgPSBvcFswXSAmIDIgPyB5W1wicmV0dXJuXCJdIDogb3BbMF0gPyB5W1widGhyb3dcIl0gfHwgKCh0ID0geVtcInJldHVyblwiXSkgJiYgdC5jYWxsKHkpLCAwKSA6IHkubmV4dCkgJiYgISh0ID0gdC5jYWxsKHksIG9wWzFdKSkuZG9uZSkgcmV0dXJuIHQ7XG5cdCAgICAgICAgICAgIGlmICh5ID0gMCwgdCkgb3AgPSBbb3BbMF0gJiAyLCB0LnZhbHVlXTtcblx0ICAgICAgICAgICAgc3dpdGNoIChvcFswXSkge1xuXHQgICAgICAgICAgICAgICAgY2FzZSAwOiBjYXNlIDE6IHQgPSBvcDsgYnJlYWs7XG5cdCAgICAgICAgICAgICAgICBjYXNlIDQ6IF8ubGFiZWwrKzsgcmV0dXJuIHsgdmFsdWU6IG9wWzFdLCBkb25lOiBmYWxzZSB9O1xuXHQgICAgICAgICAgICAgICAgY2FzZSA1OiBfLmxhYmVsKys7IHkgPSBvcFsxXTsgb3AgPSBbMF07IGNvbnRpbnVlO1xuXHQgICAgICAgICAgICAgICAgY2FzZSA3OiBvcCA9IF8ub3BzLnBvcCgpOyBfLnRyeXMucG9wKCk7IGNvbnRpbnVlO1xuXHQgICAgICAgICAgICAgICAgZGVmYXVsdDpcblx0ICAgICAgICAgICAgICAgICAgICBpZiAoISh0ID0gXy50cnlzLCB0ID0gdC5sZW5ndGggPiAwICYmIHRbdC5sZW5ndGggLSAxXSkgJiYgKG9wWzBdID09PSA2IHx8IG9wWzBdID09PSAyKSkgeyBfID0gMDsgY29udGludWU7IH1cblx0ICAgICAgICAgICAgICAgICAgICBpZiAob3BbMF0gPT09IDMgJiYgKCF0IHx8IChvcFsxXSA+IHRbMF0gJiYgb3BbMV0gPCB0WzNdKSkpIHsgXy5sYWJlbCA9IG9wWzFdOyBicmVhazsgfVxuXHQgICAgICAgICAgICAgICAgICAgIGlmIChvcFswXSA9PT0gNiAmJiBfLmxhYmVsIDwgdFsxXSkgeyBfLmxhYmVsID0gdFsxXTsgdCA9IG9wOyBicmVhazsgfVxuXHQgICAgICAgICAgICAgICAgICAgIGlmICh0ICYmIF8ubGFiZWwgPCB0WzJdKSB7IF8ubGFiZWwgPSB0WzJdOyBfLm9wcy5wdXNoKG9wKTsgYnJlYWs7IH1cblx0ICAgICAgICAgICAgICAgICAgICBpZiAodFsyXSkgXy5vcHMucG9wKCk7XG5cdCAgICAgICAgICAgICAgICAgICAgXy50cnlzLnBvcCgpOyBjb250aW51ZTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICBvcCA9IGJvZHkuY2FsbCh0aGlzQXJnLCBfKTtcblx0ICAgICAgICB9IGNhdGNoIChlKSB7IG9wID0gWzYsIGVdOyB5ID0gMDsgfSBmaW5hbGx5IHsgZiA9IHQgPSAwOyB9XG5cdCAgICAgICAgaWYgKG9wWzBdICYgNSkgdGhyb3cgb3BbMV07IHJldHVybiB7IHZhbHVlOiBvcFswXSA/IG9wWzFdIDogdm9pZCAwLCBkb25lOiB0cnVlIH07XG5cdCAgICB9XG5cdH07XG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcblx0ZXhwb3J0cy5wb2xsID0gZXhwb3J0cy5mZXRjaEpzb24gPSBleHBvcnRzLl9mZXRjaERhdGEgPSB2b2lkIDA7XG5cblxuXG5cblxuXG5cdHZhciBsb2dnZXIgPSBuZXcgbGliLkxvZ2dlcihfdmVyc2lvbiRHLnZlcnNpb24pO1xuXG5cdGZ1bmN0aW9uIHN0YWxsZXIoZHVyYXRpb24pIHtcblx0ICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSkge1xuXHQgICAgICAgIHNldFRpbWVvdXQocmVzb2x2ZSwgZHVyYXRpb24pO1xuXHQgICAgfSk7XG5cdH1cblx0ZnVuY3Rpb24gYm9keWlmeSh2YWx1ZSwgdHlwZSkge1xuXHQgICAgaWYgKHZhbHVlID09IG51bGwpIHtcblx0ICAgICAgICByZXR1cm4gbnVsbDtcblx0ICAgIH1cblx0ICAgIGlmICh0eXBlb2YgKHZhbHVlKSA9PT0gXCJzdHJpbmdcIikge1xuXHQgICAgICAgIHJldHVybiB2YWx1ZTtcblx0ICAgIH1cblx0ICAgIGlmICgoMCwgbGliJDEuaXNCeXRlc0xpa2UpKHZhbHVlKSkge1xuXHQgICAgICAgIGlmICh0eXBlICYmICh0eXBlLnNwbGl0KFwiL1wiKVswXSA9PT0gXCJ0ZXh0XCIgfHwgdHlwZS5zcGxpdChcIjtcIilbMF0udHJpbSgpID09PSBcImFwcGxpY2F0aW9uL2pzb25cIikpIHtcblx0ICAgICAgICAgICAgdHJ5IHtcblx0ICAgICAgICAgICAgICAgIHJldHVybiAoMCwgbGliJDgudG9VdGY4U3RyaW5nKSh2YWx1ZSk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7IH1cblx0ICAgICAgICAgICAgO1xuXHQgICAgICAgIH1cblx0ICAgICAgICByZXR1cm4gKDAsIGxpYiQxLmhleGxpZnkpKHZhbHVlKTtcblx0ICAgIH1cblx0ICAgIHJldHVybiB2YWx1ZTtcblx0fVxuXHQvLyBUaGlzIEFQSSBpcyBzdGlsbCBhIHdvcmsgaW4gcHJvZ3Jlc3M7IHRoZSBmdXR1cmUgY2hhbmdlcyB3aWxsIGxpa2VseSBiZTpcblx0Ly8gLSBDb25uZWN0aW9uSW5mbyA9PiBGZXRjaERhdGFSZXF1ZXN0PFQgPSBhbnk+XG5cdC8vIC0gRmV0Y2hEYXRhUmVxdWVzdC5ib2R5PyA9IHN0cmluZyB8IFVpbnQ4QXJyYXkgfCB7IGNvbnRlbnRUeXBlOiBzdHJpbmcsIGRhdGE6IHN0cmluZyB8IFVpbnQ4QXJyYXkgfVxuXHQvLyAgIC0gSWYgc3RyaW5nID0+IHRleHQvcGxhaW4sIFVpbnQ4QXJyYXkgPT4gYXBwbGljYXRpb24vb2N0ZXQtc3RyZWFtIChpZiBjb250ZW50LXR5cGUgdW5zcGVjaWZpZWQpXG5cdC8vIC0gRmV0Y2hEYXRhUmVxdWVzdC5wcm9jZXNzRnVuYyA9IChib2R5OiBVaW50OEFycmF5LCByZXNwb25zZTogRmV0Y2hEYXRhUmVzcG9uc2UpID0+IFRcblx0Ly8gRm9yIHRoaXMgcmVhc29uLCBpdCBzaG91bGQgYmUgY29uc2lkZXJlZCBpbnRlcm5hbCB1bnRpbCB0aGUgQVBJIGlzIGZpbmFsaXplZFxuXHRmdW5jdGlvbiBfZmV0Y2hEYXRhKGNvbm5lY3Rpb24sIGJvZHksIHByb2Nlc3NGdW5jKSB7XG5cdCAgICAvLyBIb3cgbWFueSB0aW1lcyB0byByZXRyeSBpbiB0aGUgZXZlbnQgb2YgYSB0aHJvdHRsZVxuXHQgICAgdmFyIGF0dGVtcHRMaW1pdCA9ICh0eXBlb2YgKGNvbm5lY3Rpb24pID09PSBcIm9iamVjdFwiICYmIGNvbm5lY3Rpb24udGhyb3R0bGVMaW1pdCAhPSBudWxsKSA/IGNvbm5lY3Rpb24udGhyb3R0bGVMaW1pdCA6IDEyO1xuXHQgICAgbG9nZ2VyLmFzc2VydEFyZ3VtZW50KChhdHRlbXB0TGltaXQgPiAwICYmIChhdHRlbXB0TGltaXQgJSAxKSA9PT0gMCksIFwiaW52YWxpZCBjb25uZWN0aW9uIHRocm90dGxlIGxpbWl0XCIsIFwiY29ubmVjdGlvbi50aHJvdHRsZUxpbWl0XCIsIGF0dGVtcHRMaW1pdCk7XG5cdCAgICB2YXIgdGhyb3R0bGVDYWxsYmFjayA9ICgodHlwZW9mIChjb25uZWN0aW9uKSA9PT0gXCJvYmplY3RcIikgPyBjb25uZWN0aW9uLnRocm90dGxlQ2FsbGJhY2sgOiBudWxsKTtcblx0ICAgIHZhciB0aHJvdHRsZVNsb3RJbnRlcnZhbCA9ICgodHlwZW9mIChjb25uZWN0aW9uKSA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgKGNvbm5lY3Rpb24udGhyb3R0bGVTbG90SW50ZXJ2YWwpID09PSBcIm51bWJlclwiKSA/IGNvbm5lY3Rpb24udGhyb3R0bGVTbG90SW50ZXJ2YWwgOiAxMDApO1xuXHQgICAgbG9nZ2VyLmFzc2VydEFyZ3VtZW50KCh0aHJvdHRsZVNsb3RJbnRlcnZhbCA+IDAgJiYgKHRocm90dGxlU2xvdEludGVydmFsICUgMSkgPT09IDApLCBcImludmFsaWQgY29ubmVjdGlvbiB0aHJvdHRsZSBzbG90IGludGVydmFsXCIsIFwiY29ubmVjdGlvbi50aHJvdHRsZVNsb3RJbnRlcnZhbFwiLCB0aHJvdHRsZVNsb3RJbnRlcnZhbCk7XG5cdCAgICB2YXIgaGVhZGVycyA9IHt9O1xuXHQgICAgdmFyIHVybCA9IG51bGw7XG5cdCAgICAvLyBAVE9ETzogQWxsb3cgQ29ubmVjdGlvbkluZm8gdG8gb3ZlcnJpZGUgc29tZSBvZiB0aGVzZSB2YWx1ZXNcblx0ICAgIHZhciBvcHRpb25zID0ge1xuXHQgICAgICAgIG1ldGhvZDogXCJHRVRcIixcblx0ICAgIH07XG5cdCAgICB2YXIgYWxsb3czMDQgPSBmYWxzZTtcblx0ICAgIHZhciB0aW1lb3V0ID0gMiAqIDYwICogMTAwMDtcblx0ICAgIGlmICh0eXBlb2YgKGNvbm5lY3Rpb24pID09PSBcInN0cmluZ1wiKSB7XG5cdCAgICAgICAgdXJsID0gY29ubmVjdGlvbjtcblx0ICAgIH1cblx0ICAgIGVsc2UgaWYgKHR5cGVvZiAoY29ubmVjdGlvbikgPT09IFwib2JqZWN0XCIpIHtcblx0ICAgICAgICBpZiAoY29ubmVjdGlvbiA9PSBudWxsIHx8IGNvbm5lY3Rpb24udXJsID09IG51bGwpIHtcblx0ICAgICAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcIm1pc3NpbmcgVVJMXCIsIFwiY29ubmVjdGlvbi51cmxcIiwgY29ubmVjdGlvbik7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHVybCA9IGNvbm5lY3Rpb24udXJsO1xuXHQgICAgICAgIGlmICh0eXBlb2YgKGNvbm5lY3Rpb24udGltZW91dCkgPT09IFwibnVtYmVyXCIgJiYgY29ubmVjdGlvbi50aW1lb3V0ID4gMCkge1xuXHQgICAgICAgICAgICB0aW1lb3V0ID0gY29ubmVjdGlvbi50aW1lb3V0O1xuXHQgICAgICAgIH1cblx0ICAgICAgICBpZiAoY29ubmVjdGlvbi5oZWFkZXJzKSB7XG5cdCAgICAgICAgICAgIGZvciAodmFyIGtleSBpbiBjb25uZWN0aW9uLmhlYWRlcnMpIHtcblx0ICAgICAgICAgICAgICAgIGhlYWRlcnNba2V5LnRvTG93ZXJDYXNlKCldID0geyBrZXk6IGtleSwgdmFsdWU6IFN0cmluZyhjb25uZWN0aW9uLmhlYWRlcnNba2V5XSkgfTtcblx0ICAgICAgICAgICAgICAgIGlmIChbXCJpZi1ub25lLW1hdGNoXCIsIFwiaWYtbW9kaWZpZWQtc2luY2VcIl0uaW5kZXhPZihrZXkudG9Mb3dlckNhc2UoKSkgPj0gMCkge1xuXHQgICAgICAgICAgICAgICAgICAgIGFsbG93MzA0ID0gdHJ1ZTtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH1cblx0ICAgICAgICBvcHRpb25zLmFsbG93R3ppcCA9ICEhY29ubmVjdGlvbi5hbGxvd0d6aXA7XG5cdCAgICAgICAgaWYgKGNvbm5lY3Rpb24udXNlciAhPSBudWxsICYmIGNvbm5lY3Rpb24ucGFzc3dvcmQgIT0gbnVsbCkge1xuXHQgICAgICAgICAgICBpZiAodXJsLnN1YnN0cmluZygwLCA2KSAhPT0gXCJodHRwczpcIiAmJiBjb25uZWN0aW9uLmFsbG93SW5zZWN1cmVBdXRoZW50aWNhdGlvbiAhPT0gdHJ1ZSkge1xuXHQgICAgICAgICAgICAgICAgbG9nZ2VyLnRocm93RXJyb3IoXCJiYXNpYyBhdXRoZW50aWNhdGlvbiByZXF1aXJlcyBhIHNlY3VyZSBodHRwcyB1cmxcIiwgbGliLkxvZ2dlci5lcnJvcnMuSU5WQUxJRF9BUkdVTUVOVCwgeyBhcmd1bWVudDogXCJ1cmxcIiwgdXJsOiB1cmwsIHVzZXI6IGNvbm5lY3Rpb24udXNlciwgcGFzc3dvcmQ6IFwiW1JFREFDVEVEXVwiIH0pO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIHZhciBhdXRob3JpemF0aW9uID0gY29ubmVjdGlvbi51c2VyICsgXCI6XCIgKyBjb25uZWN0aW9uLnBhc3N3b3JkO1xuXHQgICAgICAgICAgICBoZWFkZXJzW1wiYXV0aG9yaXphdGlvblwiXSA9IHtcblx0ICAgICAgICAgICAgICAgIGtleTogXCJBdXRob3JpemF0aW9uXCIsXG5cdCAgICAgICAgICAgICAgICB2YWx1ZTogXCJCYXNpYyBcIiArICgwLCBsaWIkcC5lbmNvZGUpKCgwLCBsaWIkOC50b1V0ZjhCeXRlcykoYXV0aG9yaXphdGlvbikpXG5cdCAgICAgICAgICAgIH07XG5cdCAgICAgICAgfVxuXHQgICAgfVxuXHQgICAgaWYgKGJvZHkpIHtcblx0ICAgICAgICBvcHRpb25zLm1ldGhvZCA9IFwiUE9TVFwiO1xuXHQgICAgICAgIG9wdGlvbnMuYm9keSA9IGJvZHk7XG5cdCAgICAgICAgaWYgKGhlYWRlcnNbXCJjb250ZW50LXR5cGVcIl0gPT0gbnVsbCkge1xuXHQgICAgICAgICAgICBoZWFkZXJzW1wiY29udGVudC10eXBlXCJdID0geyBrZXk6IFwiQ29udGVudC1UeXBlXCIsIHZhbHVlOiBcImFwcGxpY2F0aW9uL29jdGV0LXN0cmVhbVwiIH07XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGlmIChoZWFkZXJzW1wiY29udGVudC1sZW5ndGhcIl0gPT0gbnVsbCkge1xuXHQgICAgICAgICAgICBoZWFkZXJzW1wiY29udGVudC1sZW5ndGhcIl0gPSB7IGtleTogXCJDb250ZW50LUxlbmd0aFwiLCB2YWx1ZTogU3RyaW5nKGJvZHkubGVuZ3RoKSB9O1xuXHQgICAgICAgIH1cblx0ICAgIH1cblx0ICAgIHZhciBmbGF0SGVhZGVycyA9IHt9O1xuXHQgICAgT2JqZWN0LmtleXMoaGVhZGVycykuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG5cdCAgICAgICAgdmFyIGhlYWRlciA9IGhlYWRlcnNba2V5XTtcblx0ICAgICAgICBmbGF0SGVhZGVyc1toZWFkZXIua2V5XSA9IGhlYWRlci52YWx1ZTtcblx0ICAgIH0pO1xuXHQgICAgb3B0aW9ucy5oZWFkZXJzID0gZmxhdEhlYWRlcnM7XG5cdCAgICB2YXIgcnVubmluZ1RpbWVvdXQgPSAoZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIHZhciB0aW1lciA9IG51bGw7XG5cdCAgICAgICAgdmFyIHByb21pc2UgPSBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG5cdCAgICAgICAgICAgIGlmICh0aW1lb3V0KSB7XG5cdCAgICAgICAgICAgICAgICB0aW1lciA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICAgICAgICAgIGlmICh0aW1lciA9PSBudWxsKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcblx0ICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgdGltZXIgPSBudWxsO1xuXHQgICAgICAgICAgICAgICAgICAgIHJlamVjdChsb2dnZXIubWFrZUVycm9yKFwidGltZW91dFwiLCBsaWIuTG9nZ2VyLmVycm9ycy5USU1FT1VULCB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJlcXVlc3RCb2R5OiBib2R5aWZ5KG9wdGlvbnMuYm9keSwgZmxhdEhlYWRlcnNbXCJjb250ZW50LXR5cGVcIl0pLFxuXHQgICAgICAgICAgICAgICAgICAgICAgICByZXF1ZXN0TWV0aG9kOiBvcHRpb25zLm1ldGhvZCxcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdGltZW91dDogdGltZW91dCxcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdXJsOiB1cmxcblx0ICAgICAgICAgICAgICAgICAgICB9KSk7XG5cdCAgICAgICAgICAgICAgICB9LCB0aW1lb3V0KTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH0pO1xuXHQgICAgICAgIHZhciBjYW5jZWwgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIGlmICh0aW1lciA9PSBudWxsKSB7XG5cdCAgICAgICAgICAgICAgICByZXR1cm47XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVyKTtcblx0ICAgICAgICAgICAgdGltZXIgPSBudWxsO1xuXHQgICAgICAgIH07XG5cdCAgICAgICAgcmV0dXJuIHsgcHJvbWlzZTogcHJvbWlzZSwgY2FuY2VsOiBjYW5jZWwgfTtcblx0ICAgIH0pKCk7XG5cdCAgICB2YXIgcnVubmluZ0ZldGNoID0gKGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIHZhciBhdHRlbXB0LCByZXNwb25zZSwgdHJ5QWdhaW4sIHN0YWxsLCByZXRyeUFmdGVyLCBlcnJvcl8xLCBib2R5XzEsIHJlc3VsdCwgZXJyb3JfMiwgdHJ5QWdhaW4sIHRpbWVvdXRfMTtcblx0ICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuXHQgICAgICAgICAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkge1xuXHQgICAgICAgICAgICAgICAgICAgIGNhc2UgMDpcblx0ICAgICAgICAgICAgICAgICAgICAgICAgYXR0ZW1wdCA9IDA7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIF9hLmxhYmVsID0gMTtcblx0ICAgICAgICAgICAgICAgICAgICBjYXNlIDE6XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGlmICghKGF0dGVtcHQgPCBhdHRlbXB0TGltaXQpKSByZXR1cm4gWzMgLypicmVhayovLCAxOV07XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlID0gbnVsbDtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgX2EubGFiZWwgPSAyO1xuXHQgICAgICAgICAgICAgICAgICAgIGNhc2UgMjpcblx0ICAgICAgICAgICAgICAgICAgICAgICAgX2EudHJ5cy5wdXNoKFsyLCA4LCAsIDldKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgKDAsIGJyb3dzZXJHZXR1cmwuZ2V0VXJsKSh1cmwsIG9wdGlvbnMpXTtcblx0ICAgICAgICAgICAgICAgICAgICBjYXNlIDM6XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlID0gX2Euc2VudCgpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIShyZXNwb25zZS5zdGF0dXNDb2RlID09PSA0MjkgJiYgYXR0ZW1wdCA8IGF0dGVtcHRMaW1pdCkpIHJldHVybiBbMyAvKmJyZWFrKi8sIDddO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB0cnlBZ2FpbiA9IHRydWU7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGlmICghdGhyb3R0bGVDYWxsYmFjaykgcmV0dXJuIFszIC8qYnJlYWsqLywgNV07XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIHRocm90dGxlQ2FsbGJhY2soYXR0ZW1wdCwgdXJsKV07XG5cdCAgICAgICAgICAgICAgICAgICAgY2FzZSA0OlxuXHQgICAgICAgICAgICAgICAgICAgICAgICB0cnlBZ2FpbiA9IF9hLnNlbnQoKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgX2EubGFiZWwgPSA1O1xuXHQgICAgICAgICAgICAgICAgICAgIGNhc2UgNTpcblx0ICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCF0cnlBZ2FpbikgcmV0dXJuIFszIC8qYnJlYWsqLywgN107XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHN0YWxsID0gMDtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcmV0cnlBZnRlciA9IHJlc3BvbnNlLmhlYWRlcnNbXCJyZXRyeS1hZnRlclwiXTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiAocmV0cnlBZnRlcikgPT09IFwic3RyaW5nXCIgJiYgcmV0cnlBZnRlci5tYXRjaCgvXlsxLTldWzAtOV0qJC8pKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGFsbCA9IHBhcnNlSW50KHJldHJ5QWZ0ZXIpICogMTAwMDtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YWxsID0gdGhyb3R0bGVTbG90SW50ZXJ2YWwgKiBwYXJzZUludChTdHJpbmcoTWF0aC5yYW5kb20oKSAqIE1hdGgucG93KDIsIGF0dGVtcHQpKSk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICAgICAgLy9jb25zb2xlLmxvZyhcIlN0YWxsaW5nIDQyOVwiKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgc3RhbGxlcihzdGFsbCldO1xuXHQgICAgICAgICAgICAgICAgICAgIGNhc2UgNjpcblx0ICAgICAgICAgICAgICAgICAgICAgICAgLy9jb25zb2xlLmxvZyhcIlN0YWxsaW5nIDQyOVwiKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgX2Euc2VudCgpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzMgLypicmVhayovLCAxOF07XG5cdCAgICAgICAgICAgICAgICAgICAgY2FzZSA3OiByZXR1cm4gWzMgLypicmVhayovLCA5XTtcblx0ICAgICAgICAgICAgICAgICAgICBjYXNlIDg6XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yXzEgPSBfYS5zZW50KCk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlID0gZXJyb3JfMS5yZXNwb25zZTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJlc3BvbnNlID09IG51bGwpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJ1bm5pbmdUaW1lb3V0LmNhbmNlbCgpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgbG9nZ2VyLnRocm93RXJyb3IoXCJtaXNzaW5nIHJlc3BvbnNlXCIsIGxpYi5Mb2dnZXIuZXJyb3JzLlNFUlZFUl9FUlJPUiwge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlcXVlc3RCb2R5OiBib2R5aWZ5KG9wdGlvbnMuYm9keSwgZmxhdEhlYWRlcnNbXCJjb250ZW50LXR5cGVcIl0pLFxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlcXVlc3RNZXRob2Q6IG9wdGlvbnMubWV0aG9kLFxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlcnZlckVycm9yOiBlcnJvcl8xLFxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVybDogdXJsXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzMgLypicmVhayovLCA5XTtcblx0ICAgICAgICAgICAgICAgICAgICBjYXNlIDk6XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGJvZHlfMSA9IHJlc3BvbnNlLmJvZHk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGlmIChhbGxvdzMwNCAmJiByZXNwb25zZS5zdGF0dXNDb2RlID09PSAzMDQpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJvZHlfMSA9IG51bGw7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAocmVzcG9uc2Uuc3RhdHVzQ29kZSA8IDIwMCB8fCByZXNwb25zZS5zdGF0dXNDb2RlID49IDMwMCkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgcnVubmluZ1RpbWVvdXQuY2FuY2VsKCk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBsb2dnZXIudGhyb3dFcnJvcihcImJhZCByZXNwb25zZVwiLCBsaWIuTG9nZ2VyLmVycm9ycy5TRVJWRVJfRVJST1IsIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGF0dXM6IHJlc3BvbnNlLnN0YXR1c0NvZGUsXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaGVhZGVyczogcmVzcG9uc2UuaGVhZGVycyxcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBib2R5OiBib2R5aWZ5KGJvZHlfMSwgKChyZXNwb25zZS5oZWFkZXJzKSA/IHJlc3BvbnNlLmhlYWRlcnNbXCJjb250ZW50LXR5cGVcIl0gOiBudWxsKSksXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVxdWVzdEJvZHk6IGJvZHlpZnkob3B0aW9ucy5ib2R5LCBmbGF0SGVhZGVyc1tcImNvbnRlbnQtdHlwZVwiXSksXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVxdWVzdE1ldGhvZDogb3B0aW9ucy5tZXRob2QsXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdXJsOiB1cmxcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGlmICghcHJvY2Vzc0Z1bmMpIHJldHVybiBbMyAvKmJyZWFrKi8sIDE3XTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgX2EubGFiZWwgPSAxMDtcblx0ICAgICAgICAgICAgICAgICAgICBjYXNlIDEwOlxuXHQgICAgICAgICAgICAgICAgICAgICAgICBfYS50cnlzLnB1c2goWzEwLCAxMiwgLCAxN10pO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCBwcm9jZXNzRnVuYyhib2R5XzEsIHJlc3BvbnNlKV07XG5cdCAgICAgICAgICAgICAgICAgICAgY2FzZSAxMTpcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gX2Euc2VudCgpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBydW5uaW5nVGltZW91dC5jYW5jZWwoKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIHJlc3VsdF07XG5cdCAgICAgICAgICAgICAgICAgICAgY2FzZSAxMjpcblx0ICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3JfMiA9IF9hLnNlbnQoKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCEoZXJyb3JfMi50aHJvdHRsZVJldHJ5ICYmIGF0dGVtcHQgPCBhdHRlbXB0TGltaXQpKSByZXR1cm4gWzMgLypicmVhayovLCAxNl07XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHRyeUFnYWluID0gdHJ1ZTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCF0aHJvdHRsZUNhbGxiYWNrKSByZXR1cm4gWzMgLypicmVhayovLCAxNF07XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIHRocm90dGxlQ2FsbGJhY2soYXR0ZW1wdCwgdXJsKV07XG5cdCAgICAgICAgICAgICAgICAgICAgY2FzZSAxMzpcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdHJ5QWdhaW4gPSBfYS5zZW50KCk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIF9hLmxhYmVsID0gMTQ7XG5cdCAgICAgICAgICAgICAgICAgICAgY2FzZSAxNDpcblx0ICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCF0cnlBZ2FpbikgcmV0dXJuIFszIC8qYnJlYWsqLywgMTZdO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB0aW1lb3V0XzEgPSB0aHJvdHRsZVNsb3RJbnRlcnZhbCAqIHBhcnNlSW50KFN0cmluZyhNYXRoLnJhbmRvbSgpICogTWF0aC5wb3coMiwgYXR0ZW1wdCkpKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgLy9jb25zb2xlLmxvZyhcIlN0YWxsaW5nIGNhbGxiYWNrXCIpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCBzdGFsbGVyKHRpbWVvdXRfMSldO1xuXHQgICAgICAgICAgICAgICAgICAgIGNhc2UgMTU6XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIC8vY29uc29sZS5sb2coXCJTdGFsbGluZyBjYWxsYmFja1wiKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgX2Euc2VudCgpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzMgLypicmVhayovLCAxOF07XG5cdCAgICAgICAgICAgICAgICAgICAgY2FzZSAxNjpcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcnVubmluZ1RpbWVvdXQuY2FuY2VsKCk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGxvZ2dlci50aHJvd0Vycm9yKFwicHJvY2Vzc2luZyByZXNwb25zZSBlcnJvclwiLCBsaWIuTG9nZ2VyLmVycm9ycy5TRVJWRVJfRVJST1IsIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJvZHk6IGJvZHlpZnkoYm9keV8xLCAoKHJlc3BvbnNlLmhlYWRlcnMpID8gcmVzcG9uc2UuaGVhZGVyc1tcImNvbnRlbnQtdHlwZVwiXSA6IG51bGwpKSxcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yOiBlcnJvcl8yLFxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVxdWVzdEJvZHk6IGJvZHlpZnkob3B0aW9ucy5ib2R5LCBmbGF0SGVhZGVyc1tcImNvbnRlbnQtdHlwZVwiXSksXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXF1ZXN0TWV0aG9kOiBvcHRpb25zLm1ldGhvZCxcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVybDogdXJsXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzMgLypicmVhayovLCAxN107XG5cdCAgICAgICAgICAgICAgICAgICAgY2FzZSAxNzpcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcnVubmluZ1RpbWVvdXQuY2FuY2VsKCk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIC8vIElmIHdlIGhhZCBhIHByb2Nlc3NGdW5jLCBpdCBlaXRoZXIgcmV0dXJuZWQgYSBUIG9yIHRocmV3IGFib3ZlLlxuXHQgICAgICAgICAgICAgICAgICAgICAgICAvLyBUaGUgXCJib2R5XCIgaXMgbm93IGEgVWludDhBcnJheS5cblx0ICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIGJvZHlfMV07XG5cdCAgICAgICAgICAgICAgICAgICAgY2FzZSAxODpcblx0ICAgICAgICAgICAgICAgICAgICAgICAgYXR0ZW1wdCsrO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzMgLypicmVhayovLCAxXTtcblx0ICAgICAgICAgICAgICAgICAgICBjYXNlIDE5OiByZXR1cm4gWzIgLypyZXR1cm4qLywgbG9nZ2VyLnRocm93RXJyb3IoXCJmYWlsZWQgcmVzcG9uc2VcIiwgbGliLkxvZ2dlci5lcnJvcnMuU0VSVkVSX0VSUk9SLCB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXF1ZXN0Qm9keTogYm9keWlmeShvcHRpb25zLmJvZHksIGZsYXRIZWFkZXJzW1wiY29udGVudC10eXBlXCJdKSxcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlcXVlc3RNZXRob2Q6IG9wdGlvbnMubWV0aG9kLFxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgdXJsOiB1cmxcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfSldO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB9KTtcblx0ICAgICAgICB9KTtcblx0ICAgIH0pKCk7XG5cdCAgICByZXR1cm4gUHJvbWlzZS5yYWNlKFtydW5uaW5nVGltZW91dC5wcm9taXNlLCBydW5uaW5nRmV0Y2hdKTtcblx0fVxuXHRleHBvcnRzLl9mZXRjaERhdGEgPSBfZmV0Y2hEYXRhO1xuXHRmdW5jdGlvbiBmZXRjaEpzb24oY29ubmVjdGlvbiwganNvbiwgcHJvY2Vzc0Z1bmMpIHtcblx0ICAgIHZhciBwcm9jZXNzSnNvbkZ1bmMgPSBmdW5jdGlvbiAodmFsdWUsIHJlc3BvbnNlKSB7XG5cdCAgICAgICAgdmFyIHJlc3VsdCA9IG51bGw7XG5cdCAgICAgICAgaWYgKHZhbHVlICE9IG51bGwpIHtcblx0ICAgICAgICAgICAgdHJ5IHtcblx0ICAgICAgICAgICAgICAgIHJlc3VsdCA9IEpTT04ucGFyc2UoKDAsIGxpYiQ4LnRvVXRmOFN0cmluZykodmFsdWUpKTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcblx0ICAgICAgICAgICAgICAgIGxvZ2dlci50aHJvd0Vycm9yKFwiaW52YWxpZCBKU09OXCIsIGxpYi5Mb2dnZXIuZXJyb3JzLlNFUlZFUl9FUlJPUiwge1xuXHQgICAgICAgICAgICAgICAgICAgIGJvZHk6IHZhbHVlLFxuXHQgICAgICAgICAgICAgICAgICAgIGVycm9yOiBlcnJvclxuXHQgICAgICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9XG5cdCAgICAgICAgaWYgKHByb2Nlc3NGdW5jKSB7XG5cdCAgICAgICAgICAgIHJlc3VsdCA9IHByb2Nlc3NGdW5jKHJlc3VsdCwgcmVzcG9uc2UpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICByZXR1cm4gcmVzdWx0O1xuXHQgICAgfTtcblx0ICAgIC8vIElmIHdlIGhhdmUganNvbiB0byBzZW5kLCB3ZSBtdXN0XG5cdCAgICAvLyAtIGFkZCBjb250ZW50LXR5cGUgb2YgYXBwbGljYXRpb24vanNvbiAodW5sZXNzIGFscmVhZHkgb3ZlcnJpZGRlbilcblx0ICAgIC8vIC0gY29udmVydCB0aGUganNvbiB0byBieXRlc1xuXHQgICAgdmFyIGJvZHkgPSBudWxsO1xuXHQgICAgaWYgKGpzb24gIT0gbnVsbCkge1xuXHQgICAgICAgIGJvZHkgPSAoMCwgbGliJDgudG9VdGY4Qnl0ZXMpKGpzb24pO1xuXHQgICAgICAgIC8vIENyZWF0ZSBhIGNvbm5lY3Rpb24gd2l0aCB0aGUgY29udGVudC10eXBlIHNldCBmb3IgSlNPTlxuXHQgICAgICAgIHZhciB1cGRhdGVkID0gKHR5cGVvZiAoY29ubmVjdGlvbikgPT09IFwic3RyaW5nXCIpID8gKHsgdXJsOiBjb25uZWN0aW9uIH0pIDogKDAsIGxpYiQzLnNoYWxsb3dDb3B5KShjb25uZWN0aW9uKTtcblx0ICAgICAgICBpZiAodXBkYXRlZC5oZWFkZXJzKSB7XG5cdCAgICAgICAgICAgIHZhciBoYXNDb250ZW50VHlwZSA9IChPYmplY3Qua2V5cyh1cGRhdGVkLmhlYWRlcnMpLmZpbHRlcihmdW5jdGlvbiAoaykgeyByZXR1cm4gKGsudG9Mb3dlckNhc2UoKSA9PT0gXCJjb250ZW50LXR5cGVcIik7IH0pLmxlbmd0aCkgIT09IDA7XG5cdCAgICAgICAgICAgIGlmICghaGFzQ29udGVudFR5cGUpIHtcblx0ICAgICAgICAgICAgICAgIHVwZGF0ZWQuaGVhZGVycyA9ICgwLCBsaWIkMy5zaGFsbG93Q29weSkodXBkYXRlZC5oZWFkZXJzKTtcblx0ICAgICAgICAgICAgICAgIHVwZGF0ZWQuaGVhZGVyc1tcImNvbnRlbnQtdHlwZVwiXSA9IFwiYXBwbGljYXRpb24vanNvblwiO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGVsc2Uge1xuXHQgICAgICAgICAgICB1cGRhdGVkLmhlYWRlcnMgPSB7IFwiY29udGVudC10eXBlXCI6IFwiYXBwbGljYXRpb24vanNvblwiIH07XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGNvbm5lY3Rpb24gPSB1cGRhdGVkO1xuXHQgICAgfVxuXHQgICAgcmV0dXJuIF9mZXRjaERhdGEoY29ubmVjdGlvbiwgYm9keSwgcHJvY2Vzc0pzb25GdW5jKTtcblx0fVxuXHRleHBvcnRzLmZldGNoSnNvbiA9IGZldGNoSnNvbjtcblx0ZnVuY3Rpb24gcG9sbChmdW5jLCBvcHRpb25zKSB7XG5cdCAgICBpZiAoIW9wdGlvbnMpIHtcblx0ICAgICAgICBvcHRpb25zID0ge307XG5cdCAgICB9XG5cdCAgICBvcHRpb25zID0gKDAsIGxpYiQzLnNoYWxsb3dDb3B5KShvcHRpb25zKTtcblx0ICAgIGlmIChvcHRpb25zLmZsb29yID09IG51bGwpIHtcblx0ICAgICAgICBvcHRpb25zLmZsb29yID0gMDtcblx0ICAgIH1cblx0ICAgIGlmIChvcHRpb25zLmNlaWxpbmcgPT0gbnVsbCkge1xuXHQgICAgICAgIG9wdGlvbnMuY2VpbGluZyA9IDEwMDAwO1xuXHQgICAgfVxuXHQgICAgaWYgKG9wdGlvbnMuaW50ZXJ2YWwgPT0gbnVsbCkge1xuXHQgICAgICAgIG9wdGlvbnMuaW50ZXJ2YWwgPSAyNTA7XG5cdCAgICB9XG5cdCAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuXHQgICAgICAgIHZhciB0aW1lciA9IG51bGw7XG5cdCAgICAgICAgdmFyIGRvbmUgPSBmYWxzZTtcblx0ICAgICAgICAvLyBSZXR1cm5zIHRydWUgaWYgY2FuY2VsIHdhcyBzdWNjZXNzZnVsLiBVbnN1Y2Nlc3NmdWwgY2FuY2VsIG1lYW5zIHdlJ3JlIGFscmVhZHkgZG9uZS5cblx0ICAgICAgICB2YXIgY2FuY2VsID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICBpZiAoZG9uZSkge1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIGRvbmUgPSB0cnVlO1xuXHQgICAgICAgICAgICBpZiAodGltZXIpIHtcblx0ICAgICAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aW1lcik7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgcmV0dXJuIHRydWU7XG5cdCAgICAgICAgfTtcblx0ICAgICAgICBpZiAob3B0aW9ucy50aW1lb3V0KSB7XG5cdCAgICAgICAgICAgIHRpbWVyID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgICAgICBpZiAoY2FuY2VsKCkpIHtcblx0ICAgICAgICAgICAgICAgICAgICByZWplY3QobmV3IEVycm9yKFwidGltZW91dFwiKSk7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIH0sIG9wdGlvbnMudGltZW91dCk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHZhciByZXRyeUxpbWl0ID0gb3B0aW9ucy5yZXRyeUxpbWl0O1xuXHQgICAgICAgIHZhciBhdHRlbXB0ID0gMDtcblx0ICAgICAgICBmdW5jdGlvbiBjaGVjaygpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIGZ1bmMoKS50aGVuKGZ1bmN0aW9uIChyZXN1bHQpIHtcblx0ICAgICAgICAgICAgICAgIC8vIElmIHdlIGhhdmUgYSByZXN1bHQsIG9yIGFyZSBhbGxvd2VkIG51bGwgdGhlbiB3ZSdyZSBkb25lXG5cdCAgICAgICAgICAgICAgICBpZiAocmVzdWx0ICE9PSB1bmRlZmluZWQpIHtcblx0ICAgICAgICAgICAgICAgICAgICBpZiAoY2FuY2VsKCkpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShyZXN1bHQpO1xuXHQgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgIGVsc2UgaWYgKG9wdGlvbnMub25jZVBvbGwpIHtcblx0ICAgICAgICAgICAgICAgICAgICBvcHRpb25zLm9uY2VQb2xsLm9uY2UoXCJwb2xsXCIsIGNoZWNrKTtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgIGVsc2UgaWYgKG9wdGlvbnMub25jZUJsb2NrKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy5vbmNlQmxvY2sub25jZShcImJsb2NrXCIsIGNoZWNrKTtcblx0ICAgICAgICAgICAgICAgICAgICAvLyBPdGhlcndpc2UsIGV4cG9uZW50aWFsIGJhY2stb2ZmICh1cCB0byAxMHMpIG91ciBuZXh0IHJlcXVlc3Rcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgIGVsc2UgaWYgKCFkb25lKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgYXR0ZW1wdCsrO1xuXHQgICAgICAgICAgICAgICAgICAgIGlmIChhdHRlbXB0ID4gcmV0cnlMaW1pdCkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBpZiAoY2FuY2VsKCkpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlamVjdChuZXcgRXJyb3IoXCJyZXRyeSBsaW1pdCByZWFjaGVkXCIpKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG5cdCAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgIHZhciB0aW1lb3V0ID0gb3B0aW9ucy5pbnRlcnZhbCAqIHBhcnNlSW50KFN0cmluZyhNYXRoLnJhbmRvbSgpICogTWF0aC5wb3coMiwgYXR0ZW1wdCkpKTtcblx0ICAgICAgICAgICAgICAgICAgICBpZiAodGltZW91dCA8IG9wdGlvbnMuZmxvb3IpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdGltZW91dCA9IG9wdGlvbnMuZmxvb3I7XG5cdCAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgIGlmICh0aW1lb3V0ID4gb3B0aW9ucy5jZWlsaW5nKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHRpbWVvdXQgPSBvcHRpb25zLmNlaWxpbmc7XG5cdCAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoY2hlY2ssIHRpbWVvdXQpO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG5cdCAgICAgICAgICAgIH0sIGZ1bmN0aW9uIChlcnJvcikge1xuXHQgICAgICAgICAgICAgICAgaWYgKGNhbmNlbCgpKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgcmVqZWN0KGVycm9yKTtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGNoZWNrKCk7XG5cdCAgICB9KTtcblx0fVxuXHRleHBvcnRzLnBvbGwgPSBwb2xsO1xuXG5cdH0pO1xuXG5cdHZhciBpbmRleCRxID0gLypAX19QVVJFX18qL2dldERlZmF1bHRFeHBvcnRGcm9tQ2pzKGxpYiRxKTtcblxuXHQndXNlIHN0cmljdCc7XG5cdHZhciBBTFBIQUJFVCA9ICdxcHpyeTl4OGdmMnR2ZHcwczNqbjU0a2hjZTZtdWE3bCc7XG5cblx0Ly8gcHJlLWNvbXB1dGUgbG9va3VwIHRhYmxlXG5cdHZhciBBTFBIQUJFVF9NQVAgPSB7fTtcblx0Zm9yICh2YXIgeiA9IDA7IHogPCBBTFBIQUJFVC5sZW5ndGg7IHorKykge1xuXHQgIHZhciB4ID0gQUxQSEFCRVQuY2hhckF0KHopO1xuXG5cdCAgaWYgKEFMUEhBQkVUX01BUFt4XSAhPT0gdW5kZWZpbmVkKSB0aHJvdyBuZXcgVHlwZUVycm9yKHggKyAnIGlzIGFtYmlndW91cycpXG5cdCAgQUxQSEFCRVRfTUFQW3hdID0gejtcblx0fVxuXG5cdGZ1bmN0aW9uIHBvbHltb2RTdGVwIChwcmUpIHtcblx0ICB2YXIgYiA9IHByZSA+PiAyNTtcblx0ICByZXR1cm4gKChwcmUgJiAweDFGRkZGRkYpIDw8IDUpIF5cblx0ICAgICgtKChiID4+IDApICYgMSkgJiAweDNiNmE1N2IyKSBeXG5cdCAgICAoLSgoYiA+PiAxKSAmIDEpICYgMHgyNjUwOGU2ZCkgXlxuXHQgICAgKC0oKGIgPj4gMikgJiAxKSAmIDB4MWVhMTE5ZmEpIF5cblx0ICAgICgtKChiID4+IDMpICYgMSkgJiAweDNkNDIzM2RkKSBeXG5cdCAgICAoLSgoYiA+PiA0KSAmIDEpICYgMHgyYTE0NjJiMylcblx0fVxuXG5cdGZ1bmN0aW9uIHByZWZpeENoayAocHJlZml4KSB7XG5cdCAgdmFyIGNoayA9IDE7XG5cdCAgZm9yICh2YXIgaSA9IDA7IGkgPCBwcmVmaXgubGVuZ3RoOyArK2kpIHtcblx0ICAgIHZhciBjID0gcHJlZml4LmNoYXJDb2RlQXQoaSk7XG5cdCAgICBpZiAoYyA8IDMzIHx8IGMgPiAxMjYpIHJldHVybiAnSW52YWxpZCBwcmVmaXggKCcgKyBwcmVmaXggKyAnKSdcblxuXHQgICAgY2hrID0gcG9seW1vZFN0ZXAoY2hrKSBeIChjID4+IDUpO1xuXHQgIH1cblx0ICBjaGsgPSBwb2x5bW9kU3RlcChjaGspO1xuXG5cdCAgZm9yIChpID0gMDsgaSA8IHByZWZpeC5sZW5ndGg7ICsraSkge1xuXHQgICAgdmFyIHYgPSBwcmVmaXguY2hhckNvZGVBdChpKTtcblx0ICAgIGNoayA9IHBvbHltb2RTdGVwKGNoaykgXiAodiAmIDB4MWYpO1xuXHQgIH1cblx0ICByZXR1cm4gY2hrXG5cdH1cblxuXHRmdW5jdGlvbiBlbmNvZGUgKHByZWZpeCwgd29yZHMsIExJTUlUKSB7XG5cdCAgTElNSVQgPSBMSU1JVCB8fCA5MDtcblx0ICBpZiAoKHByZWZpeC5sZW5ndGggKyA3ICsgd29yZHMubGVuZ3RoKSA+IExJTUlUKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdFeGNlZWRzIGxlbmd0aCBsaW1pdCcpXG5cblx0ICBwcmVmaXggPSBwcmVmaXgudG9Mb3dlckNhc2UoKTtcblxuXHQgIC8vIGRldGVybWluZSBjaGsgbW9kXG5cdCAgdmFyIGNoayA9IHByZWZpeENoayhwcmVmaXgpO1xuXHQgIGlmICh0eXBlb2YgY2hrID09PSAnc3RyaW5nJykgdGhyb3cgbmV3IEVycm9yKGNoaylcblxuXHQgIHZhciByZXN1bHQgPSBwcmVmaXggKyAnMSc7XG5cdCAgZm9yICh2YXIgaSA9IDA7IGkgPCB3b3Jkcy5sZW5ndGg7ICsraSkge1xuXHQgICAgdmFyIHggPSB3b3Jkc1tpXTtcblx0ICAgIGlmICgoeCA+PiA1KSAhPT0gMCkgdGhyb3cgbmV3IEVycm9yKCdOb24gNS1iaXQgd29yZCcpXG5cblx0ICAgIGNoayA9IHBvbHltb2RTdGVwKGNoaykgXiB4O1xuXHQgICAgcmVzdWx0ICs9IEFMUEhBQkVULmNoYXJBdCh4KTtcblx0ICB9XG5cblx0ICBmb3IgKGkgPSAwOyBpIDwgNjsgKytpKSB7XG5cdCAgICBjaGsgPSBwb2x5bW9kU3RlcChjaGspO1xuXHQgIH1cblx0ICBjaGsgXj0gMTtcblxuXHQgIGZvciAoaSA9IDA7IGkgPCA2OyArK2kpIHtcblx0ICAgIHZhciB2ID0gKGNoayA+PiAoKDUgLSBpKSAqIDUpKSAmIDB4MWY7XG5cdCAgICByZXN1bHQgKz0gQUxQSEFCRVQuY2hhckF0KHYpO1xuXHQgIH1cblxuXHQgIHJldHVybiByZXN1bHRcblx0fVxuXG5cdGZ1bmN0aW9uIF9fZGVjb2RlIChzdHIsIExJTUlUKSB7XG5cdCAgTElNSVQgPSBMSU1JVCB8fCA5MDtcblx0ICBpZiAoc3RyLmxlbmd0aCA8IDgpIHJldHVybiBzdHIgKyAnIHRvbyBzaG9ydCdcblx0ICBpZiAoc3RyLmxlbmd0aCA+IExJTUlUKSByZXR1cm4gJ0V4Y2VlZHMgbGVuZ3RoIGxpbWl0J1xuXG5cdCAgLy8gZG9uJ3QgYWxsb3cgbWl4ZWQgY2FzZVxuXHQgIHZhciBsb3dlcmVkID0gc3RyLnRvTG93ZXJDYXNlKCk7XG5cdCAgdmFyIHVwcGVyZWQgPSBzdHIudG9VcHBlckNhc2UoKTtcblx0ICBpZiAoc3RyICE9PSBsb3dlcmVkICYmIHN0ciAhPT0gdXBwZXJlZCkgcmV0dXJuICdNaXhlZC1jYXNlIHN0cmluZyAnICsgc3RyXG5cdCAgc3RyID0gbG93ZXJlZDtcblxuXHQgIHZhciBzcGxpdCA9IHN0ci5sYXN0SW5kZXhPZignMScpO1xuXHQgIGlmIChzcGxpdCA9PT0gLTEpIHJldHVybiAnTm8gc2VwYXJhdG9yIGNoYXJhY3RlciBmb3IgJyArIHN0clxuXHQgIGlmIChzcGxpdCA9PT0gMCkgcmV0dXJuICdNaXNzaW5nIHByZWZpeCBmb3IgJyArIHN0clxuXG5cdCAgdmFyIHByZWZpeCA9IHN0ci5zbGljZSgwLCBzcGxpdCk7XG5cdCAgdmFyIHdvcmRDaGFycyA9IHN0ci5zbGljZShzcGxpdCArIDEpO1xuXHQgIGlmICh3b3JkQ2hhcnMubGVuZ3RoIDwgNikgcmV0dXJuICdEYXRhIHRvbyBzaG9ydCdcblxuXHQgIHZhciBjaGsgPSBwcmVmaXhDaGsocHJlZml4KTtcblx0ICBpZiAodHlwZW9mIGNoayA9PT0gJ3N0cmluZycpIHJldHVybiBjaGtcblxuXHQgIHZhciB3b3JkcyA9IFtdO1xuXHQgIGZvciAodmFyIGkgPSAwOyBpIDwgd29yZENoYXJzLmxlbmd0aDsgKytpKSB7XG5cdCAgICB2YXIgYyA9IHdvcmRDaGFycy5jaGFyQXQoaSk7XG5cdCAgICB2YXIgdiA9IEFMUEhBQkVUX01BUFtjXTtcblx0ICAgIGlmICh2ID09PSB1bmRlZmluZWQpIHJldHVybiAnVW5rbm93biBjaGFyYWN0ZXIgJyArIGNcblx0ICAgIGNoayA9IHBvbHltb2RTdGVwKGNoaykgXiB2O1xuXG5cdCAgICAvLyBub3QgaW4gdGhlIGNoZWNrc3VtP1xuXHQgICAgaWYgKGkgKyA2ID49IHdvcmRDaGFycy5sZW5ndGgpIGNvbnRpbnVlXG5cdCAgICB3b3Jkcy5wdXNoKHYpO1xuXHQgIH1cblxuXHQgIGlmIChjaGsgIT09IDEpIHJldHVybiAnSW52YWxpZCBjaGVja3N1bSBmb3IgJyArIHN0clxuXHQgIHJldHVybiB7IHByZWZpeDogcHJlZml4LCB3b3Jkczogd29yZHMgfVxuXHR9XG5cblx0ZnVuY3Rpb24gZGVjb2RlVW5zYWZlICgpIHtcblx0ICB2YXIgcmVzID0gX19kZWNvZGUuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcblx0ICBpZiAodHlwZW9mIHJlcyA9PT0gJ29iamVjdCcpIHJldHVybiByZXNcblx0fVxuXG5cdGZ1bmN0aW9uIGRlY29kZSAoc3RyKSB7XG5cdCAgdmFyIHJlcyA9IF9fZGVjb2RlLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG5cdCAgaWYgKHR5cGVvZiByZXMgPT09ICdvYmplY3QnKSByZXR1cm4gcmVzXG5cblx0ICB0aHJvdyBuZXcgRXJyb3IocmVzKVxuXHR9XG5cblx0ZnVuY3Rpb24gY29udmVydCAoZGF0YSwgaW5CaXRzLCBvdXRCaXRzLCBwYWQpIHtcblx0ICB2YXIgdmFsdWUgPSAwO1xuXHQgIHZhciBiaXRzID0gMDtcblx0ICB2YXIgbWF4ViA9ICgxIDw8IG91dEJpdHMpIC0gMTtcblxuXHQgIHZhciByZXN1bHQgPSBbXTtcblx0ICBmb3IgKHZhciBpID0gMDsgaSA8IGRhdGEubGVuZ3RoOyArK2kpIHtcblx0ICAgIHZhbHVlID0gKHZhbHVlIDw8IGluQml0cykgfCBkYXRhW2ldO1xuXHQgICAgYml0cyArPSBpbkJpdHM7XG5cblx0ICAgIHdoaWxlIChiaXRzID49IG91dEJpdHMpIHtcblx0ICAgICAgYml0cyAtPSBvdXRCaXRzO1xuXHQgICAgICByZXN1bHQucHVzaCgodmFsdWUgPj4gYml0cykgJiBtYXhWKTtcblx0ICAgIH1cblx0ICB9XG5cblx0ICBpZiAocGFkKSB7XG5cdCAgICBpZiAoYml0cyA+IDApIHtcblx0ICAgICAgcmVzdWx0LnB1c2goKHZhbHVlIDw8IChvdXRCaXRzIC0gYml0cykpICYgbWF4Vik7XG5cdCAgICB9XG5cdCAgfSBlbHNlIHtcblx0ICAgIGlmIChiaXRzID49IGluQml0cykgcmV0dXJuICdFeGNlc3MgcGFkZGluZydcblx0ICAgIGlmICgodmFsdWUgPDwgKG91dEJpdHMgLSBiaXRzKSkgJiBtYXhWKSByZXR1cm4gJ05vbi16ZXJvIHBhZGRpbmcnXG5cdCAgfVxuXG5cdCAgcmV0dXJuIHJlc3VsdFxuXHR9XG5cblx0ZnVuY3Rpb24gdG9Xb3Jkc1Vuc2FmZSAoYnl0ZXMpIHtcblx0ICB2YXIgcmVzID0gY29udmVydChieXRlcywgOCwgNSwgdHJ1ZSk7XG5cdCAgaWYgKEFycmF5LmlzQXJyYXkocmVzKSkgcmV0dXJuIHJlc1xuXHR9XG5cblx0ZnVuY3Rpb24gdG9Xb3JkcyAoYnl0ZXMpIHtcblx0ICB2YXIgcmVzID0gY29udmVydChieXRlcywgOCwgNSwgdHJ1ZSk7XG5cdCAgaWYgKEFycmF5LmlzQXJyYXkocmVzKSkgcmV0dXJuIHJlc1xuXG5cdCAgdGhyb3cgbmV3IEVycm9yKHJlcylcblx0fVxuXG5cdGZ1bmN0aW9uIGZyb21Xb3Jkc1Vuc2FmZSAod29yZHMpIHtcblx0ICB2YXIgcmVzID0gY29udmVydCh3b3JkcywgNSwgOCwgZmFsc2UpO1xuXHQgIGlmIChBcnJheS5pc0FycmF5KHJlcykpIHJldHVybiByZXNcblx0fVxuXG5cdGZ1bmN0aW9uIGZyb21Xb3JkcyAod29yZHMpIHtcblx0ICB2YXIgcmVzID0gY29udmVydCh3b3JkcywgNSwgOCwgZmFsc2UpO1xuXHQgIGlmIChBcnJheS5pc0FycmF5KHJlcykpIHJldHVybiByZXNcblxuXHQgIHRocm93IG5ldyBFcnJvcihyZXMpXG5cdH1cblxuXHR2YXIgYmVjaDMyID0ge1xuXHQgIGRlY29kZVVuc2FmZTogZGVjb2RlVW5zYWZlLFxuXHQgIGRlY29kZTogZGVjb2RlLFxuXHQgIGVuY29kZTogZW5jb2RlLFxuXHQgIHRvV29yZHNVbnNhZmU6IHRvV29yZHNVbnNhZmUsXG5cdCAgdG9Xb3JkczogdG9Xb3Jkcyxcblx0ICBmcm9tV29yZHNVbnNhZmU6IGZyb21Xb3Jkc1Vuc2FmZSxcblx0ICBmcm9tV29yZHM6IGZyb21Xb3Jkc1xuXHR9O1xuXG5cdHZhciBfdmVyc2lvbiRJID0gY3JlYXRlQ29tbW9uanNNb2R1bGUoZnVuY3Rpb24gKG1vZHVsZSwgZXhwb3J0cykge1xuXHRcInVzZSBzdHJpY3RcIjtcblx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuXHRleHBvcnRzLnZlcnNpb24gPSB2b2lkIDA7XG5cdGV4cG9ydHMudmVyc2lvbiA9IFwicHJvdmlkZXJzLzUuNS4wXCI7XG5cblx0fSk7XG5cblx0dmFyIF92ZXJzaW9uJEogPSAvKkBfX1BVUkVfXyovZ2V0RGVmYXVsdEV4cG9ydEZyb21DanMoX3ZlcnNpb24kSSk7XG5cblx0dmFyIGZvcm1hdHRlciA9IGNyZWF0ZUNvbW1vbmpzTW9kdWxlKGZ1bmN0aW9uIChtb2R1bGUsIGV4cG9ydHMpIHtcblx0XCJ1c2Ugc3RyaWN0XCI7XG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcblx0ZXhwb3J0cy5zaG93VGhyb3R0bGVNZXNzYWdlID0gZXhwb3J0cy5pc0NvbW11bml0eVJlc291cmNlID0gZXhwb3J0cy5pc0NvbW11bml0eVJlc291cmNhYmxlID0gZXhwb3J0cy5Gb3JtYXR0ZXIgPSB2b2lkIDA7XG5cblxuXG5cblxuXG5cblxuXHR2YXIgbG9nZ2VyID0gbmV3IGxpYi5Mb2dnZXIoX3ZlcnNpb24kSS52ZXJzaW9uKTtcblx0dmFyIEZvcm1hdHRlciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcblx0ICAgIGZ1bmN0aW9uIEZvcm1hdHRlcigpIHtcblx0ICAgICAgICB2YXIgX25ld1RhcmdldCA9IHRoaXMuY29uc3RydWN0b3I7XG5cdCAgICAgICAgbG9nZ2VyLmNoZWNrTmV3KF9uZXdUYXJnZXQsIEZvcm1hdHRlcik7XG5cdCAgICAgICAgdGhpcy5mb3JtYXRzID0gdGhpcy5nZXREZWZhdWx0Rm9ybWF0cygpO1xuXHQgICAgfVxuXHQgICAgRm9ybWF0dGVyLnByb3RvdHlwZS5nZXREZWZhdWx0Rm9ybWF0cyA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXHQgICAgICAgIHZhciBmb3JtYXRzID0gKHt9KTtcblx0ICAgICAgICB2YXIgYWRkcmVzcyA9IHRoaXMuYWRkcmVzcy5iaW5kKHRoaXMpO1xuXHQgICAgICAgIHZhciBiaWdOdW1iZXIgPSB0aGlzLmJpZ051bWJlci5iaW5kKHRoaXMpO1xuXHQgICAgICAgIHZhciBibG9ja1RhZyA9IHRoaXMuYmxvY2tUYWcuYmluZCh0aGlzKTtcblx0ICAgICAgICB2YXIgZGF0YSA9IHRoaXMuZGF0YS5iaW5kKHRoaXMpO1xuXHQgICAgICAgIHZhciBoYXNoID0gdGhpcy5oYXNoLmJpbmQodGhpcyk7XG5cdCAgICAgICAgdmFyIGhleCA9IHRoaXMuaGV4LmJpbmQodGhpcyk7XG5cdCAgICAgICAgdmFyIG51bWJlciA9IHRoaXMubnVtYmVyLmJpbmQodGhpcyk7XG5cdCAgICAgICAgdmFyIHR5cGUgPSB0aGlzLnR5cGUuYmluZCh0aGlzKTtcblx0ICAgICAgICB2YXIgc3RyaWN0RGF0YSA9IGZ1bmN0aW9uICh2KSB7IHJldHVybiBfdGhpcy5kYXRhKHYsIHRydWUpOyB9O1xuXHQgICAgICAgIGZvcm1hdHMudHJhbnNhY3Rpb24gPSB7XG5cdCAgICAgICAgICAgIGhhc2g6IGhhc2gsXG5cdCAgICAgICAgICAgIHR5cGU6IHR5cGUsXG5cdCAgICAgICAgICAgIGFjY2Vzc0xpc3Q6IEZvcm1hdHRlci5hbGxvd051bGwodGhpcy5hY2Nlc3NMaXN0LmJpbmQodGhpcyksIG51bGwpLFxuXHQgICAgICAgICAgICBibG9ja0hhc2g6IEZvcm1hdHRlci5hbGxvd051bGwoaGFzaCwgbnVsbCksXG5cdCAgICAgICAgICAgIGJsb2NrTnVtYmVyOiBGb3JtYXR0ZXIuYWxsb3dOdWxsKG51bWJlciwgbnVsbCksXG5cdCAgICAgICAgICAgIHRyYW5zYWN0aW9uSW5kZXg6IEZvcm1hdHRlci5hbGxvd051bGwobnVtYmVyLCBudWxsKSxcblx0ICAgICAgICAgICAgY29uZmlybWF0aW9uczogRm9ybWF0dGVyLmFsbG93TnVsbChudW1iZXIsIG51bGwpLFxuXHQgICAgICAgICAgICBmcm9tOiBhZGRyZXNzLFxuXHQgICAgICAgICAgICAvLyBlaXRoZXIgKGdhc1ByaWNlKSBvciAobWF4UHJpb3JpdHlGZWVQZXJHYXMgKyBtYXhGZWVQZXJHYXMpXG5cdCAgICAgICAgICAgIC8vIG11c3QgYmUgc2V0XG5cdCAgICAgICAgICAgIGdhc1ByaWNlOiBGb3JtYXR0ZXIuYWxsb3dOdWxsKGJpZ051bWJlciksXG5cdCAgICAgICAgICAgIG1heFByaW9yaXR5RmVlUGVyR2FzOiBGb3JtYXR0ZXIuYWxsb3dOdWxsKGJpZ051bWJlciksXG5cdCAgICAgICAgICAgIG1heEZlZVBlckdhczogRm9ybWF0dGVyLmFsbG93TnVsbChiaWdOdW1iZXIpLFxuXHQgICAgICAgICAgICBnYXNMaW1pdDogYmlnTnVtYmVyLFxuXHQgICAgICAgICAgICB0bzogRm9ybWF0dGVyLmFsbG93TnVsbChhZGRyZXNzLCBudWxsKSxcblx0ICAgICAgICAgICAgdmFsdWU6IGJpZ051bWJlcixcblx0ICAgICAgICAgICAgbm9uY2U6IG51bWJlcixcblx0ICAgICAgICAgICAgZGF0YTogZGF0YSxcblx0ICAgICAgICAgICAgcjogRm9ybWF0dGVyLmFsbG93TnVsbCh0aGlzLnVpbnQyNTYpLFxuXHQgICAgICAgICAgICBzOiBGb3JtYXR0ZXIuYWxsb3dOdWxsKHRoaXMudWludDI1NiksXG5cdCAgICAgICAgICAgIHY6IEZvcm1hdHRlci5hbGxvd051bGwobnVtYmVyKSxcblx0ICAgICAgICAgICAgY3JlYXRlczogRm9ybWF0dGVyLmFsbG93TnVsbChhZGRyZXNzLCBudWxsKSxcblx0ICAgICAgICAgICAgcmF3OiBGb3JtYXR0ZXIuYWxsb3dOdWxsKGRhdGEpLFxuXHQgICAgICAgIH07XG5cdCAgICAgICAgZm9ybWF0cy50cmFuc2FjdGlvblJlcXVlc3QgPSB7XG5cdCAgICAgICAgICAgIGZyb206IEZvcm1hdHRlci5hbGxvd051bGwoYWRkcmVzcyksXG5cdCAgICAgICAgICAgIG5vbmNlOiBGb3JtYXR0ZXIuYWxsb3dOdWxsKG51bWJlciksXG5cdCAgICAgICAgICAgIGdhc0xpbWl0OiBGb3JtYXR0ZXIuYWxsb3dOdWxsKGJpZ051bWJlciksXG5cdCAgICAgICAgICAgIGdhc1ByaWNlOiBGb3JtYXR0ZXIuYWxsb3dOdWxsKGJpZ051bWJlciksXG5cdCAgICAgICAgICAgIG1heFByaW9yaXR5RmVlUGVyR2FzOiBGb3JtYXR0ZXIuYWxsb3dOdWxsKGJpZ051bWJlciksXG5cdCAgICAgICAgICAgIG1heEZlZVBlckdhczogRm9ybWF0dGVyLmFsbG93TnVsbChiaWdOdW1iZXIpLFxuXHQgICAgICAgICAgICB0bzogRm9ybWF0dGVyLmFsbG93TnVsbChhZGRyZXNzKSxcblx0ICAgICAgICAgICAgdmFsdWU6IEZvcm1hdHRlci5hbGxvd051bGwoYmlnTnVtYmVyKSxcblx0ICAgICAgICAgICAgZGF0YTogRm9ybWF0dGVyLmFsbG93TnVsbChzdHJpY3REYXRhKSxcblx0ICAgICAgICAgICAgdHlwZTogRm9ybWF0dGVyLmFsbG93TnVsbChudW1iZXIpLFxuXHQgICAgICAgICAgICBhY2Nlc3NMaXN0OiBGb3JtYXR0ZXIuYWxsb3dOdWxsKHRoaXMuYWNjZXNzTGlzdC5iaW5kKHRoaXMpLCBudWxsKSxcblx0ICAgICAgICB9O1xuXHQgICAgICAgIGZvcm1hdHMucmVjZWlwdExvZyA9IHtcblx0ICAgICAgICAgICAgdHJhbnNhY3Rpb25JbmRleDogbnVtYmVyLFxuXHQgICAgICAgICAgICBibG9ja051bWJlcjogbnVtYmVyLFxuXHQgICAgICAgICAgICB0cmFuc2FjdGlvbkhhc2g6IGhhc2gsXG5cdCAgICAgICAgICAgIGFkZHJlc3M6IGFkZHJlc3MsXG5cdCAgICAgICAgICAgIHRvcGljczogRm9ybWF0dGVyLmFycmF5T2YoaGFzaCksXG5cdCAgICAgICAgICAgIGRhdGE6IGRhdGEsXG5cdCAgICAgICAgICAgIGxvZ0luZGV4OiBudW1iZXIsXG5cdCAgICAgICAgICAgIGJsb2NrSGFzaDogaGFzaCxcblx0ICAgICAgICB9O1xuXHQgICAgICAgIGZvcm1hdHMucmVjZWlwdCA9IHtcblx0ICAgICAgICAgICAgdG86IEZvcm1hdHRlci5hbGxvd051bGwodGhpcy5hZGRyZXNzLCBudWxsKSxcblx0ICAgICAgICAgICAgZnJvbTogRm9ybWF0dGVyLmFsbG93TnVsbCh0aGlzLmFkZHJlc3MsIG51bGwpLFxuXHQgICAgICAgICAgICBjb250cmFjdEFkZHJlc3M6IEZvcm1hdHRlci5hbGxvd051bGwoYWRkcmVzcywgbnVsbCksXG5cdCAgICAgICAgICAgIHRyYW5zYWN0aW9uSW5kZXg6IG51bWJlcixcblx0ICAgICAgICAgICAgLy8gc2hvdWxkIGJlIGFsbG93TnVsbChoYXNoKSwgYnV0IGJyb2tlbi1FSVAtNjU4IHN1cHBvcnQgaXMgaGFuZGxlZCBpbiByZWNlaXB0XG5cdCAgICAgICAgICAgIHJvb3Q6IEZvcm1hdHRlci5hbGxvd051bGwoaGV4KSxcblx0ICAgICAgICAgICAgZ2FzVXNlZDogYmlnTnVtYmVyLFxuXHQgICAgICAgICAgICBsb2dzQmxvb206IEZvcm1hdHRlci5hbGxvd051bGwoZGF0YSksXG5cdCAgICAgICAgICAgIGJsb2NrSGFzaDogaGFzaCxcblx0ICAgICAgICAgICAgdHJhbnNhY3Rpb25IYXNoOiBoYXNoLFxuXHQgICAgICAgICAgICBsb2dzOiBGb3JtYXR0ZXIuYXJyYXlPZih0aGlzLnJlY2VpcHRMb2cuYmluZCh0aGlzKSksXG5cdCAgICAgICAgICAgIGJsb2NrTnVtYmVyOiBudW1iZXIsXG5cdCAgICAgICAgICAgIGNvbmZpcm1hdGlvbnM6IEZvcm1hdHRlci5hbGxvd051bGwobnVtYmVyLCBudWxsKSxcblx0ICAgICAgICAgICAgY3VtdWxhdGl2ZUdhc1VzZWQ6IGJpZ051bWJlcixcblx0ICAgICAgICAgICAgZWZmZWN0aXZlR2FzUHJpY2U6IEZvcm1hdHRlci5hbGxvd051bGwoYmlnTnVtYmVyKSxcblx0ICAgICAgICAgICAgc3RhdHVzOiBGb3JtYXR0ZXIuYWxsb3dOdWxsKG51bWJlciksXG5cdCAgICAgICAgICAgIHR5cGU6IHR5cGVcblx0ICAgICAgICB9O1xuXHQgICAgICAgIGZvcm1hdHMuYmxvY2sgPSB7XG5cdCAgICAgICAgICAgIGhhc2g6IGhhc2gsXG5cdCAgICAgICAgICAgIHBhcmVudEhhc2g6IGhhc2gsXG5cdCAgICAgICAgICAgIG51bWJlcjogbnVtYmVyLFxuXHQgICAgICAgICAgICB0aW1lc3RhbXA6IG51bWJlcixcblx0ICAgICAgICAgICAgbm9uY2U6IEZvcm1hdHRlci5hbGxvd051bGwoaGV4KSxcblx0ICAgICAgICAgICAgZGlmZmljdWx0eTogdGhpcy5kaWZmaWN1bHR5LmJpbmQodGhpcyksXG5cdCAgICAgICAgICAgIGdhc0xpbWl0OiBiaWdOdW1iZXIsXG5cdCAgICAgICAgICAgIGdhc1VzZWQ6IGJpZ051bWJlcixcblx0ICAgICAgICAgICAgbWluZXI6IGFkZHJlc3MsXG5cdCAgICAgICAgICAgIGV4dHJhRGF0YTogZGF0YSxcblx0ICAgICAgICAgICAgdHJhbnNhY3Rpb25zOiBGb3JtYXR0ZXIuYWxsb3dOdWxsKEZvcm1hdHRlci5hcnJheU9mKGhhc2gpKSxcblx0ICAgICAgICAgICAgYmFzZUZlZVBlckdhczogRm9ybWF0dGVyLmFsbG93TnVsbChiaWdOdW1iZXIpXG5cdCAgICAgICAgfTtcblx0ICAgICAgICBmb3JtYXRzLmJsb2NrV2l0aFRyYW5zYWN0aW9ucyA9ICgwLCBsaWIkMy5zaGFsbG93Q29weSkoZm9ybWF0cy5ibG9jayk7XG5cdCAgICAgICAgZm9ybWF0cy5ibG9ja1dpdGhUcmFuc2FjdGlvbnMudHJhbnNhY3Rpb25zID0gRm9ybWF0dGVyLmFsbG93TnVsbChGb3JtYXR0ZXIuYXJyYXlPZih0aGlzLnRyYW5zYWN0aW9uUmVzcG9uc2UuYmluZCh0aGlzKSkpO1xuXHQgICAgICAgIGZvcm1hdHMuZmlsdGVyID0ge1xuXHQgICAgICAgICAgICBmcm9tQmxvY2s6IEZvcm1hdHRlci5hbGxvd051bGwoYmxvY2tUYWcsIHVuZGVmaW5lZCksXG5cdCAgICAgICAgICAgIHRvQmxvY2s6IEZvcm1hdHRlci5hbGxvd051bGwoYmxvY2tUYWcsIHVuZGVmaW5lZCksXG5cdCAgICAgICAgICAgIGJsb2NrSGFzaDogRm9ybWF0dGVyLmFsbG93TnVsbChoYXNoLCB1bmRlZmluZWQpLFxuXHQgICAgICAgICAgICBhZGRyZXNzOiBGb3JtYXR0ZXIuYWxsb3dOdWxsKGFkZHJlc3MsIHVuZGVmaW5lZCksXG5cdCAgICAgICAgICAgIHRvcGljczogRm9ybWF0dGVyLmFsbG93TnVsbCh0aGlzLnRvcGljcy5iaW5kKHRoaXMpLCB1bmRlZmluZWQpLFxuXHQgICAgICAgIH07XG5cdCAgICAgICAgZm9ybWF0cy5maWx0ZXJMb2cgPSB7XG5cdCAgICAgICAgICAgIGJsb2NrTnVtYmVyOiBGb3JtYXR0ZXIuYWxsb3dOdWxsKG51bWJlciksXG5cdCAgICAgICAgICAgIGJsb2NrSGFzaDogRm9ybWF0dGVyLmFsbG93TnVsbChoYXNoKSxcblx0ICAgICAgICAgICAgdHJhbnNhY3Rpb25JbmRleDogbnVtYmVyLFxuXHQgICAgICAgICAgICByZW1vdmVkOiBGb3JtYXR0ZXIuYWxsb3dOdWxsKHRoaXMuYm9vbGVhbi5iaW5kKHRoaXMpKSxcblx0ICAgICAgICAgICAgYWRkcmVzczogYWRkcmVzcyxcblx0ICAgICAgICAgICAgZGF0YTogRm9ybWF0dGVyLmFsbG93RmFsc2lzaChkYXRhLCBcIjB4XCIpLFxuXHQgICAgICAgICAgICB0b3BpY3M6IEZvcm1hdHRlci5hcnJheU9mKGhhc2gpLFxuXHQgICAgICAgICAgICB0cmFuc2FjdGlvbkhhc2g6IGhhc2gsXG5cdCAgICAgICAgICAgIGxvZ0luZGV4OiBudW1iZXIsXG5cdCAgICAgICAgfTtcblx0ICAgICAgICByZXR1cm4gZm9ybWF0cztcblx0ICAgIH07XG5cdCAgICBGb3JtYXR0ZXIucHJvdG90eXBlLmFjY2Vzc0xpc3QgPSBmdW5jdGlvbiAoYWNjZXNzTGlzdCkge1xuXHQgICAgICAgIHJldHVybiAoMCwgbGliJGUuYWNjZXNzTGlzdGlmeSkoYWNjZXNzTGlzdCB8fCBbXSk7XG5cdCAgICB9O1xuXHQgICAgLy8gUmVxdWlyZXMgYSBCaWdOdW1iZXJpc2ggdGhhdCBpcyB3aXRoaW4gdGhlIElFRUU3NTQgc2FmZSBpbnRlZ2VyIHJhbmdlOyByZXR1cm5zIGEgbnVtYmVyXG5cdCAgICAvLyBTdHJpY3QhIFVzZWQgb24gaW5wdXQuXG5cdCAgICBGb3JtYXR0ZXIucHJvdG90eXBlLm51bWJlciA9IGZ1bmN0aW9uIChudW1iZXIpIHtcblx0ICAgICAgICBpZiAobnVtYmVyID09PSBcIjB4XCIpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIDA7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHJldHVybiBsaWIkMi5CaWdOdW1iZXIuZnJvbShudW1iZXIpLnRvTnVtYmVyKCk7XG5cdCAgICB9O1xuXHQgICAgRm9ybWF0dGVyLnByb3RvdHlwZS50eXBlID0gZnVuY3Rpb24gKG51bWJlcikge1xuXHQgICAgICAgIGlmIChudW1iZXIgPT09IFwiMHhcIiB8fCBudW1iZXIgPT0gbnVsbCkge1xuXHQgICAgICAgICAgICByZXR1cm4gMDtcblx0ICAgICAgICB9XG5cdCAgICAgICAgcmV0dXJuIGxpYiQyLkJpZ051bWJlci5mcm9tKG51bWJlcikudG9OdW1iZXIoKTtcblx0ICAgIH07XG5cdCAgICAvLyBTdHJpY3QhIFVzZWQgb24gaW5wdXQuXG5cdCAgICBGb3JtYXR0ZXIucHJvdG90eXBlLmJpZ051bWJlciA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuXHQgICAgICAgIHJldHVybiBsaWIkMi5CaWdOdW1iZXIuZnJvbSh2YWx1ZSk7XG5cdCAgICB9O1xuXHQgICAgLy8gUmVxdWlyZXMgYSBib29sZWFuLCBcInRydWVcIiBvciAgXCJmYWxzZVwiOyByZXR1cm5zIGEgYm9vbGVhblxuXHQgICAgRm9ybWF0dGVyLnByb3RvdHlwZS5ib29sZWFuID0gZnVuY3Rpb24gKHZhbHVlKSB7XG5cdCAgICAgICAgaWYgKHR5cGVvZiAodmFsdWUpID09PSBcImJvb2xlYW5cIikge1xuXHQgICAgICAgICAgICByZXR1cm4gdmFsdWU7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGlmICh0eXBlb2YgKHZhbHVlKSA9PT0gXCJzdHJpbmdcIikge1xuXHQgICAgICAgICAgICB2YWx1ZSA9IHZhbHVlLnRvTG93ZXJDYXNlKCk7XG5cdCAgICAgICAgICAgIGlmICh2YWx1ZSA9PT0gXCJ0cnVlXCIpIHtcblx0ICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIGlmICh2YWx1ZSA9PT0gXCJmYWxzZVwiKSB7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9XG5cdCAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBib29sZWFuIC0gXCIgKyB2YWx1ZSk7XG5cdCAgICB9O1xuXHQgICAgRm9ybWF0dGVyLnByb3RvdHlwZS5oZXggPSBmdW5jdGlvbiAodmFsdWUsIHN0cmljdCkge1xuXHQgICAgICAgIGlmICh0eXBlb2YgKHZhbHVlKSA9PT0gXCJzdHJpbmdcIikge1xuXHQgICAgICAgICAgICBpZiAoIXN0cmljdCAmJiB2YWx1ZS5zdWJzdHJpbmcoMCwgMikgIT09IFwiMHhcIikge1xuXHQgICAgICAgICAgICAgICAgdmFsdWUgPSBcIjB4XCIgKyB2YWx1ZTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICBpZiAoKDAsIGxpYiQxLmlzSGV4U3RyaW5nKSh2YWx1ZSkpIHtcblx0ICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZS50b0xvd2VyQ2FzZSgpO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHJldHVybiBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwiaW52YWxpZCBoYXNoXCIsIFwidmFsdWVcIiwgdmFsdWUpO1xuXHQgICAgfTtcblx0ICAgIEZvcm1hdHRlci5wcm90b3R5cGUuZGF0YSA9IGZ1bmN0aW9uICh2YWx1ZSwgc3RyaWN0KSB7XG5cdCAgICAgICAgdmFyIHJlc3VsdCA9IHRoaXMuaGV4KHZhbHVlLCBzdHJpY3QpO1xuXHQgICAgICAgIGlmICgocmVzdWx0Lmxlbmd0aCAlIDIpICE9PSAwKSB7XG5cdCAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImludmFsaWQgZGF0YTsgb2RkLWxlbmd0aCAtIFwiICsgdmFsdWUpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICByZXR1cm4gcmVzdWx0O1xuXHQgICAgfTtcblx0ICAgIC8vIFJlcXVpcmVzIGFuIGFkZHJlc3Ncblx0ICAgIC8vIFN0cmljdCEgVXNlZCBvbiBpbnB1dC5cblx0ICAgIEZvcm1hdHRlci5wcm90b3R5cGUuYWRkcmVzcyA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuXHQgICAgICAgIHJldHVybiAoMCwgbGliJDYuZ2V0QWRkcmVzcykodmFsdWUpO1xuXHQgICAgfTtcblx0ICAgIEZvcm1hdHRlci5wcm90b3R5cGUuY2FsbEFkZHJlc3MgPSBmdW5jdGlvbiAodmFsdWUpIHtcblx0ICAgICAgICBpZiAoISgwLCBsaWIkMS5pc0hleFN0cmluZykodmFsdWUsIDMyKSkge1xuXHQgICAgICAgICAgICByZXR1cm4gbnVsbDtcblx0ICAgICAgICB9XG5cdCAgICAgICAgdmFyIGFkZHJlc3MgPSAoMCwgbGliJDYuZ2V0QWRkcmVzcykoKDAsIGxpYiQxLmhleERhdGFTbGljZSkodmFsdWUsIDEyKSk7XG5cdCAgICAgICAgcmV0dXJuIChhZGRyZXNzID09PSBsaWIkNy5BZGRyZXNzWmVybykgPyBudWxsIDogYWRkcmVzcztcblx0ICAgIH07XG5cdCAgICBGb3JtYXR0ZXIucHJvdG90eXBlLmNvbnRyYWN0QWRkcmVzcyA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuXHQgICAgICAgIHJldHVybiAoMCwgbGliJDYuZ2V0Q29udHJhY3RBZGRyZXNzKSh2YWx1ZSk7XG5cdCAgICB9O1xuXHQgICAgLy8gU3RyaWN0ISBVc2VkIG9uIGlucHV0LlxuXHQgICAgRm9ybWF0dGVyLnByb3RvdHlwZS5ibG9ja1RhZyA9IGZ1bmN0aW9uIChibG9ja1RhZykge1xuXHQgICAgICAgIGlmIChibG9ja1RhZyA9PSBudWxsKSB7XG5cdCAgICAgICAgICAgIHJldHVybiBcImxhdGVzdFwiO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBpZiAoYmxvY2tUYWcgPT09IFwiZWFybGllc3RcIikge1xuXHQgICAgICAgICAgICByZXR1cm4gXCIweDBcIjtcblx0ICAgICAgICB9XG5cdCAgICAgICAgaWYgKGJsb2NrVGFnID09PSBcImxhdGVzdFwiIHx8IGJsb2NrVGFnID09PSBcInBlbmRpbmdcIikge1xuXHQgICAgICAgICAgICByZXR1cm4gYmxvY2tUYWc7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGlmICh0eXBlb2YgKGJsb2NrVGFnKSA9PT0gXCJudW1iZXJcIiB8fCAoMCwgbGliJDEuaXNIZXhTdHJpbmcpKGJsb2NrVGFnKSkge1xuXHQgICAgICAgICAgICByZXR1cm4gKDAsIGxpYiQxLmhleFZhbHVlKShibG9ja1RhZyk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHRocm93IG5ldyBFcnJvcihcImludmFsaWQgYmxvY2tUYWdcIik7XG5cdCAgICB9O1xuXHQgICAgLy8gUmVxdWlyZXMgYSBoYXNoLCBvcHRpb25hbGx5IHJlcXVpcmVzIDB4IHByZWZpeDsgcmV0dXJucyBwcmVmaXhlZCBsb3dlcmNhc2UgaGFzaC5cblx0ICAgIEZvcm1hdHRlci5wcm90b3R5cGUuaGFzaCA9IGZ1bmN0aW9uICh2YWx1ZSwgc3RyaWN0KSB7XG5cdCAgICAgICAgdmFyIHJlc3VsdCA9IHRoaXMuaGV4KHZhbHVlLCBzdHJpY3QpO1xuXHQgICAgICAgIGlmICgoMCwgbGliJDEuaGV4RGF0YUxlbmd0aCkocmVzdWx0KSAhPT0gMzIpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJpbnZhbGlkIGhhc2hcIiwgXCJ2YWx1ZVwiLCB2YWx1ZSk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHJldHVybiByZXN1bHQ7XG5cdCAgICB9O1xuXHQgICAgLy8gUmV0dXJucyB0aGUgZGlmZmljdWx0eSBhcyBhIG51bWJlciwgb3IgaWYgdG9vIGxhcmdlIChpLmUuIFBvQSBuZXR3b3JrKSBudWxsXG5cdCAgICBGb3JtYXR0ZXIucHJvdG90eXBlLmRpZmZpY3VsdHkgPSBmdW5jdGlvbiAodmFsdWUpIHtcblx0ICAgICAgICBpZiAodmFsdWUgPT0gbnVsbCkge1xuXHQgICAgICAgICAgICByZXR1cm4gbnVsbDtcblx0ICAgICAgICB9XG5cdCAgICAgICAgdmFyIHYgPSBsaWIkMi5CaWdOdW1iZXIuZnJvbSh2YWx1ZSk7XG5cdCAgICAgICAgdHJ5IHtcblx0ICAgICAgICAgICAgcmV0dXJuIHYudG9OdW1iZXIoKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgY2F0Y2ggKGVycm9yKSB7IH1cblx0ICAgICAgICByZXR1cm4gbnVsbDtcblx0ICAgIH07XG5cdCAgICBGb3JtYXR0ZXIucHJvdG90eXBlLnVpbnQyNTYgPSBmdW5jdGlvbiAodmFsdWUpIHtcblx0ICAgICAgICBpZiAoISgwLCBsaWIkMS5pc0hleFN0cmluZykodmFsdWUpKSB7XG5cdCAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImludmFsaWQgdWludDI1NlwiKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgcmV0dXJuICgwLCBsaWIkMS5oZXhaZXJvUGFkKSh2YWx1ZSwgMzIpO1xuXHQgICAgfTtcblx0ICAgIEZvcm1hdHRlci5wcm90b3R5cGUuX2Jsb2NrID0gZnVuY3Rpb24gKHZhbHVlLCBmb3JtYXQpIHtcblx0ICAgICAgICBpZiAodmFsdWUuYXV0aG9yICE9IG51bGwgJiYgdmFsdWUubWluZXIgPT0gbnVsbCkge1xuXHQgICAgICAgICAgICB2YWx1ZS5taW5lciA9IHZhbHVlLmF1dGhvcjtcblx0ICAgICAgICB9XG5cdCAgICAgICAgLy8gVGhlIGRpZmZpY3VsdHkgbWF5IG5lZWQgdG8gY29tZSBmcm9tIF9kaWZmaWN1bHR5IGluIHJlY3Vyc2VkIGJsb2Nrc1xuXHQgICAgICAgIHZhciBkaWZmaWN1bHR5ID0gKHZhbHVlLl9kaWZmaWN1bHR5ICE9IG51bGwpID8gdmFsdWUuX2RpZmZpY3VsdHkgOiB2YWx1ZS5kaWZmaWN1bHR5O1xuXHQgICAgICAgIHZhciByZXN1bHQgPSBGb3JtYXR0ZXIuY2hlY2soZm9ybWF0LCB2YWx1ZSk7XG5cdCAgICAgICAgcmVzdWx0Ll9kaWZmaWN1bHR5ID0gKChkaWZmaWN1bHR5ID09IG51bGwpID8gbnVsbCA6IGxpYiQyLkJpZ051bWJlci5mcm9tKGRpZmZpY3VsdHkpKTtcblx0ICAgICAgICByZXR1cm4gcmVzdWx0O1xuXHQgICAgfTtcblx0ICAgIEZvcm1hdHRlci5wcm90b3R5cGUuYmxvY2sgPSBmdW5jdGlvbiAodmFsdWUpIHtcblx0ICAgICAgICByZXR1cm4gdGhpcy5fYmxvY2sodmFsdWUsIHRoaXMuZm9ybWF0cy5ibG9jayk7XG5cdCAgICB9O1xuXHQgICAgRm9ybWF0dGVyLnByb3RvdHlwZS5ibG9ja1dpdGhUcmFuc2FjdGlvbnMgPSBmdW5jdGlvbiAodmFsdWUpIHtcblx0ICAgICAgICByZXR1cm4gdGhpcy5fYmxvY2sodmFsdWUsIHRoaXMuZm9ybWF0cy5ibG9ja1dpdGhUcmFuc2FjdGlvbnMpO1xuXHQgICAgfTtcblx0ICAgIC8vIFN0cmljdCEgVXNlZCBvbiBpbnB1dC5cblx0ICAgIEZvcm1hdHRlci5wcm90b3R5cGUudHJhbnNhY3Rpb25SZXF1ZXN0ID0gZnVuY3Rpb24gKHZhbHVlKSB7XG5cdCAgICAgICAgcmV0dXJuIEZvcm1hdHRlci5jaGVjayh0aGlzLmZvcm1hdHMudHJhbnNhY3Rpb25SZXF1ZXN0LCB2YWx1ZSk7XG5cdCAgICB9O1xuXHQgICAgRm9ybWF0dGVyLnByb3RvdHlwZS50cmFuc2FjdGlvblJlc3BvbnNlID0gZnVuY3Rpb24gKHRyYW5zYWN0aW9uKSB7XG5cdCAgICAgICAgLy8gUmVuYW1lIGdhcyB0byBnYXNMaW1pdFxuXHQgICAgICAgIGlmICh0cmFuc2FjdGlvbi5nYXMgIT0gbnVsbCAmJiB0cmFuc2FjdGlvbi5nYXNMaW1pdCA9PSBudWxsKSB7XG5cdCAgICAgICAgICAgIHRyYW5zYWN0aW9uLmdhc0xpbWl0ID0gdHJhbnNhY3Rpb24uZ2FzO1xuXHQgICAgICAgIH1cblx0ICAgICAgICAvLyBTb21lIGNsaWVudHMgKFRlc3RSUEMpIGRvIHN0cmFuZ2UgdGhpbmdzIGxpa2UgcmV0dXJuIDB4MCBmb3IgdGhlXG5cdCAgICAgICAgLy8gMCBhZGRyZXNzOyBjb3JyZWN0IHRoaXMgdG8gYmUgYSByZWFsIGFkZHJlc3Ncblx0ICAgICAgICBpZiAodHJhbnNhY3Rpb24udG8gJiYgbGliJDIuQmlnTnVtYmVyLmZyb20odHJhbnNhY3Rpb24udG8pLmlzWmVybygpKSB7XG5cdCAgICAgICAgICAgIHRyYW5zYWN0aW9uLnRvID0gXCIweDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDBcIjtcblx0ICAgICAgICB9XG5cdCAgICAgICAgLy8gUmVuYW1lIGlucHV0IHRvIGRhdGFcblx0ICAgICAgICBpZiAodHJhbnNhY3Rpb24uaW5wdXQgIT0gbnVsbCAmJiB0cmFuc2FjdGlvbi5kYXRhID09IG51bGwpIHtcblx0ICAgICAgICAgICAgdHJhbnNhY3Rpb24uZGF0YSA9IHRyYW5zYWN0aW9uLmlucHV0O1xuXHQgICAgICAgIH1cblx0ICAgICAgICAvLyBJZiB0byBhbmQgY3JlYXRlcyBhcmUgZW1wdHksIHBvcHVsYXRlIHRoZSBjcmVhdGVzIGZyb20gdGhlIHRyYW5zYWN0aW9uXG5cdCAgICAgICAgaWYgKHRyYW5zYWN0aW9uLnRvID09IG51bGwgJiYgdHJhbnNhY3Rpb24uY3JlYXRlcyA9PSBudWxsKSB7XG5cdCAgICAgICAgICAgIHRyYW5zYWN0aW9uLmNyZWF0ZXMgPSB0aGlzLmNvbnRyYWN0QWRkcmVzcyh0cmFuc2FjdGlvbik7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGlmICgodHJhbnNhY3Rpb24udHlwZSA9PT0gMSB8fCB0cmFuc2FjdGlvbi50eXBlID09PSAyKSAmJiB0cmFuc2FjdGlvbi5hY2Nlc3NMaXN0ID09IG51bGwpIHtcblx0ICAgICAgICAgICAgdHJhbnNhY3Rpb24uYWNjZXNzTGlzdCA9IFtdO1xuXHQgICAgICAgIH1cblx0ICAgICAgICB2YXIgcmVzdWx0ID0gRm9ybWF0dGVyLmNoZWNrKHRoaXMuZm9ybWF0cy50cmFuc2FjdGlvbiwgdHJhbnNhY3Rpb24pO1xuXHQgICAgICAgIGlmICh0cmFuc2FjdGlvbi5jaGFpbklkICE9IG51bGwpIHtcblx0ICAgICAgICAgICAgdmFyIGNoYWluSWQgPSB0cmFuc2FjdGlvbi5jaGFpbklkO1xuXHQgICAgICAgICAgICBpZiAoKDAsIGxpYiQxLmlzSGV4U3RyaW5nKShjaGFpbklkKSkge1xuXHQgICAgICAgICAgICAgICAgY2hhaW5JZCA9IGxpYiQyLkJpZ051bWJlci5mcm9tKGNoYWluSWQpLnRvTnVtYmVyKCk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgcmVzdWx0LmNoYWluSWQgPSBjaGFpbklkO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBlbHNlIHtcblx0ICAgICAgICAgICAgdmFyIGNoYWluSWQgPSB0cmFuc2FjdGlvbi5uZXR3b3JrSWQ7XG5cdCAgICAgICAgICAgIC8vIGdldGgtZXRjIHJldHVybnMgY2hhaW5JZFxuXHQgICAgICAgICAgICBpZiAoY2hhaW5JZCA9PSBudWxsICYmIHJlc3VsdC52ID09IG51bGwpIHtcblx0ICAgICAgICAgICAgICAgIGNoYWluSWQgPSB0cmFuc2FjdGlvbi5jaGFpbklkO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIGlmICgoMCwgbGliJDEuaXNIZXhTdHJpbmcpKGNoYWluSWQpKSB7XG5cdCAgICAgICAgICAgICAgICBjaGFpbklkID0gbGliJDIuQmlnTnVtYmVyLmZyb20oY2hhaW5JZCkudG9OdW1iZXIoKTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICBpZiAodHlwZW9mIChjaGFpbklkKSAhPT0gXCJudW1iZXJcIiAmJiByZXN1bHQudiAhPSBudWxsKSB7XG5cdCAgICAgICAgICAgICAgICBjaGFpbklkID0gKHJlc3VsdC52IC0gMzUpIC8gMjtcblx0ICAgICAgICAgICAgICAgIGlmIChjaGFpbklkIDwgMCkge1xuXHQgICAgICAgICAgICAgICAgICAgIGNoYWluSWQgPSAwO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgY2hhaW5JZCA9IHBhcnNlSW50KGNoYWluSWQpO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIGlmICh0eXBlb2YgKGNoYWluSWQpICE9PSBcIm51bWJlclwiKSB7XG5cdCAgICAgICAgICAgICAgICBjaGFpbklkID0gMDtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICByZXN1bHQuY2hhaW5JZCA9IGNoYWluSWQ7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIC8vIDB4MDAwMC4uLiBzaG91bGQgYWN0dWFsbHkgYmUgbnVsbFxuXHQgICAgICAgIGlmIChyZXN1bHQuYmxvY2tIYXNoICYmIHJlc3VsdC5ibG9ja0hhc2gucmVwbGFjZSgvMC9nLCBcIlwiKSA9PT0gXCJ4XCIpIHtcblx0ICAgICAgICAgICAgcmVzdWx0LmJsb2NrSGFzaCA9IG51bGw7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHJldHVybiByZXN1bHQ7XG5cdCAgICB9O1xuXHQgICAgRm9ybWF0dGVyLnByb3RvdHlwZS50cmFuc2FjdGlvbiA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuXHQgICAgICAgIHJldHVybiAoMCwgbGliJGUucGFyc2UpKHZhbHVlKTtcblx0ICAgIH07XG5cdCAgICBGb3JtYXR0ZXIucHJvdG90eXBlLnJlY2VpcHRMb2cgPSBmdW5jdGlvbiAodmFsdWUpIHtcblx0ICAgICAgICByZXR1cm4gRm9ybWF0dGVyLmNoZWNrKHRoaXMuZm9ybWF0cy5yZWNlaXB0TG9nLCB2YWx1ZSk7XG5cdCAgICB9O1xuXHQgICAgRm9ybWF0dGVyLnByb3RvdHlwZS5yZWNlaXB0ID0gZnVuY3Rpb24gKHZhbHVlKSB7XG5cdCAgICAgICAgdmFyIHJlc3VsdCA9IEZvcm1hdHRlci5jaGVjayh0aGlzLmZvcm1hdHMucmVjZWlwdCwgdmFsdWUpO1xuXHQgICAgICAgIC8vIFJTSyBpbmNvcnJlY3RseSBpbXBsZW1lbnRlZCBFSVAtNjU4LCBzbyB3ZSBtdW5nZSB0aGluZ3MgYSBiaXQgaGVyZSBmb3IgaXRcblx0ICAgICAgICBpZiAocmVzdWx0LnJvb3QgIT0gbnVsbCkge1xuXHQgICAgICAgICAgICBpZiAocmVzdWx0LnJvb3QubGVuZ3RoIDw9IDQpIHtcblx0ICAgICAgICAgICAgICAgIC8vIENvdWxkIGJlIDB4MDAsIDB4MCwgMHgwMSBvciAweDFcblx0ICAgICAgICAgICAgICAgIHZhciB2YWx1ZV8xID0gbGliJDIuQmlnTnVtYmVyLmZyb20ocmVzdWx0LnJvb3QpLnRvTnVtYmVyKCk7XG5cdCAgICAgICAgICAgICAgICBpZiAodmFsdWVfMSA9PT0gMCB8fCB2YWx1ZV8xID09PSAxKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgLy8gTWFrZSBzdXJlIGlmIGJvdGggYXJlIHNwZWNpZmllZCwgdGhleSBtYXRjaFxuXHQgICAgICAgICAgICAgICAgICAgIGlmIChyZXN1bHQuc3RhdHVzICE9IG51bGwgJiYgKHJlc3VsdC5zdGF0dXMgIT09IHZhbHVlXzEpKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJhbHQtcm9vdC1zdGF0dXMvc3RhdHVzIG1pc21hdGNoXCIsIFwidmFsdWVcIiwgeyByb290OiByZXN1bHQucm9vdCwgc3RhdHVzOiByZXN1bHQuc3RhdHVzIH0pO1xuXHQgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICByZXN1bHQuc3RhdHVzID0gdmFsdWVfMTtcblx0ICAgICAgICAgICAgICAgICAgICBkZWxldGUgcmVzdWx0LnJvb3Q7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICBlbHNlIHtcblx0ICAgICAgICAgICAgICAgICAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwiaW52YWxpZCBhbHQtcm9vdC1zdGF0dXNcIiwgXCJ2YWx1ZS5yb290XCIsIHJlc3VsdC5yb290KTtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICBlbHNlIGlmIChyZXN1bHQucm9vdC5sZW5ndGggIT09IDY2KSB7XG5cdCAgICAgICAgICAgICAgICAvLyBNdXN0IGJlIGEgdmFsaWQgYnl0ZXMzMlxuXHQgICAgICAgICAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcImludmFsaWQgcm9vdCBoYXNoXCIsIFwidmFsdWUucm9vdFwiLCByZXN1bHQucm9vdCk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9XG5cdCAgICAgICAgaWYgKHJlc3VsdC5zdGF0dXMgIT0gbnVsbCkge1xuXHQgICAgICAgICAgICByZXN1bHQuYnl6YW50aXVtID0gdHJ1ZTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgcmV0dXJuIHJlc3VsdDtcblx0ICAgIH07XG5cdCAgICBGb3JtYXR0ZXIucHJvdG90eXBlLnRvcGljcyA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuXHQgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cdCAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG5cdCAgICAgICAgICAgIHJldHVybiB2YWx1ZS5tYXAoZnVuY3Rpb24gKHYpIHsgcmV0dXJuIF90aGlzLnRvcGljcyh2KTsgfSk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGVsc2UgaWYgKHZhbHVlICE9IG51bGwpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIHRoaXMuaGFzaCh2YWx1ZSwgdHJ1ZSk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHJldHVybiBudWxsO1xuXHQgICAgfTtcblx0ICAgIEZvcm1hdHRlci5wcm90b3R5cGUuZmlsdGVyID0gZnVuY3Rpb24gKHZhbHVlKSB7XG5cdCAgICAgICAgcmV0dXJuIEZvcm1hdHRlci5jaGVjayh0aGlzLmZvcm1hdHMuZmlsdGVyLCB2YWx1ZSk7XG5cdCAgICB9O1xuXHQgICAgRm9ybWF0dGVyLnByb3RvdHlwZS5maWx0ZXJMb2cgPSBmdW5jdGlvbiAodmFsdWUpIHtcblx0ICAgICAgICByZXR1cm4gRm9ybWF0dGVyLmNoZWNrKHRoaXMuZm9ybWF0cy5maWx0ZXJMb2csIHZhbHVlKTtcblx0ICAgIH07XG5cdCAgICBGb3JtYXR0ZXIuY2hlY2sgPSBmdW5jdGlvbiAoZm9ybWF0LCBvYmplY3QpIHtcblx0ICAgICAgICB2YXIgcmVzdWx0ID0ge307XG5cdCAgICAgICAgZm9yICh2YXIga2V5IGluIGZvcm1hdCkge1xuXHQgICAgICAgICAgICB0cnkge1xuXHQgICAgICAgICAgICAgICAgdmFyIHZhbHVlID0gZm9ybWF0W2tleV0ob2JqZWN0W2tleV0pO1xuXHQgICAgICAgICAgICAgICAgaWYgKHZhbHVlICE9PSB1bmRlZmluZWQpIHtcblx0ICAgICAgICAgICAgICAgICAgICByZXN1bHRba2V5XSA9IHZhbHVlO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuXHQgICAgICAgICAgICAgICAgZXJyb3IuY2hlY2tLZXkgPSBrZXk7XG5cdCAgICAgICAgICAgICAgICBlcnJvci5jaGVja1ZhbHVlID0gb2JqZWN0W2tleV07XG5cdCAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH1cblx0ICAgICAgICByZXR1cm4gcmVzdWx0O1xuXHQgICAgfTtcblx0ICAgIC8vIGlmIHZhbHVlIGlzIG51bGwtaXNoLCBudWxsVmFsdWUgaXMgcmV0dXJuZWRcblx0ICAgIEZvcm1hdHRlci5hbGxvd051bGwgPSBmdW5jdGlvbiAoZm9ybWF0LCBudWxsVmFsdWUpIHtcblx0ICAgICAgICByZXR1cm4gKGZ1bmN0aW9uICh2YWx1ZSkge1xuXHQgICAgICAgICAgICBpZiAodmFsdWUgPT0gbnVsbCkge1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuIG51bGxWYWx1ZTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICByZXR1cm4gZm9ybWF0KHZhbHVlKTtcblx0ICAgICAgICB9KTtcblx0ICAgIH07XG5cdCAgICAvLyBJZiB2YWx1ZSBpcyBmYWxzZS1pc2gsIHJlcGxhY2VWYWx1ZSBpcyByZXR1cm5lZFxuXHQgICAgRm9ybWF0dGVyLmFsbG93RmFsc2lzaCA9IGZ1bmN0aW9uIChmb3JtYXQsIHJlcGxhY2VWYWx1ZSkge1xuXHQgICAgICAgIHJldHVybiAoZnVuY3Rpb24gKHZhbHVlKSB7XG5cdCAgICAgICAgICAgIGlmICghdmFsdWUpIHtcblx0ICAgICAgICAgICAgICAgIHJldHVybiByZXBsYWNlVmFsdWU7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgcmV0dXJuIGZvcm1hdCh2YWx1ZSk7XG5cdCAgICAgICAgfSk7XG5cdCAgICB9O1xuXHQgICAgLy8gUmVxdWlyZXMgYW4gQXJyYXkgc2F0aXNmeWluZyBjaGVja1xuXHQgICAgRm9ybWF0dGVyLmFycmF5T2YgPSBmdW5jdGlvbiAoZm9ybWF0KSB7XG5cdCAgICAgICAgcmV0dXJuIChmdW5jdGlvbiAoYXJyYXkpIHtcblx0ICAgICAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KGFycmF5KSkge1xuXHQgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwibm90IGFuIGFycmF5XCIpO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIHZhciByZXN1bHQgPSBbXTtcblx0ICAgICAgICAgICAgYXJyYXkuZm9yRWFjaChmdW5jdGlvbiAodmFsdWUpIHtcblx0ICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKGZvcm1hdCh2YWx1ZSkpO1xuXHQgICAgICAgICAgICB9KTtcblx0ICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcblx0ICAgICAgICB9KTtcblx0ICAgIH07XG5cdCAgICByZXR1cm4gRm9ybWF0dGVyO1xuXHR9KCkpO1xuXHRleHBvcnRzLkZvcm1hdHRlciA9IEZvcm1hdHRlcjtcblx0ZnVuY3Rpb24gaXNDb21tdW5pdHlSZXNvdXJjYWJsZSh2YWx1ZSkge1xuXHQgICAgcmV0dXJuICh2YWx1ZSAmJiB0eXBlb2YgKHZhbHVlLmlzQ29tbXVuaXR5UmVzb3VyY2UpID09PSBcImZ1bmN0aW9uXCIpO1xuXHR9XG5cdGV4cG9ydHMuaXNDb21tdW5pdHlSZXNvdXJjYWJsZSA9IGlzQ29tbXVuaXR5UmVzb3VyY2FibGU7XG5cdGZ1bmN0aW9uIGlzQ29tbXVuaXR5UmVzb3VyY2UodmFsdWUpIHtcblx0ICAgIHJldHVybiAoaXNDb21tdW5pdHlSZXNvdXJjYWJsZSh2YWx1ZSkgJiYgdmFsdWUuaXNDb21tdW5pdHlSZXNvdXJjZSgpKTtcblx0fVxuXHRleHBvcnRzLmlzQ29tbXVuaXR5UmVzb3VyY2UgPSBpc0NvbW11bml0eVJlc291cmNlO1xuXHQvLyBTaG93IHRoZSB0aHJvdHRsZSBtZXNzYWdlIG9ubHkgb25jZVxuXHR2YXIgdGhyb3R0bGVNZXNzYWdlID0gZmFsc2U7XG5cdGZ1bmN0aW9uIHNob3dUaHJvdHRsZU1lc3NhZ2UoKSB7XG5cdCAgICBpZiAodGhyb3R0bGVNZXNzYWdlKSB7XG5cdCAgICAgICAgcmV0dXJuO1xuXHQgICAgfVxuXHQgICAgdGhyb3R0bGVNZXNzYWdlID0gdHJ1ZTtcblx0ICAgIGNvbnNvbGUubG9nKFwiPT09PT09PT09IE5PVElDRSA9PT09PT09PT1cIik7XG5cdCAgICBjb25zb2xlLmxvZyhcIlJlcXVlc3QtUmF0ZSBFeGNlZWRlZCAgKHRoaXMgbWVzc2FnZSB3aWxsIG5vdCBiZSByZXBlYXRlZClcIik7XG5cdCAgICBjb25zb2xlLmxvZyhcIlwiKTtcblx0ICAgIGNvbnNvbGUubG9nKFwiVGhlIGRlZmF1bHQgQVBJIGtleXMgZm9yIGVhY2ggc2VydmljZSBhcmUgcHJvdmlkZWQgYXMgYSBoaWdobHktdGhyb3R0bGVkLFwiKTtcblx0ICAgIGNvbnNvbGUubG9nKFwiY29tbXVuaXR5IHJlc291cmNlIGZvciBsb3ctdHJhZmZpYyBwcm9qZWN0cyBhbmQgZWFybHkgcHJvdG90eXBpbmcuXCIpO1xuXHQgICAgY29uc29sZS5sb2coXCJcIik7XG5cdCAgICBjb25zb2xlLmxvZyhcIldoaWxlIHlvdXIgYXBwbGljYXRpb24gd2lsbCBjb250aW51ZSB0byBmdW5jdGlvbiwgd2UgaGlnaGx5IHJlY29tbWVuZGVkXCIpO1xuXHQgICAgY29uc29sZS5sb2coXCJzaWduaW5nIHVwIGZvciB5b3VyIG93biBBUEkga2V5cyB0byBpbXByb3ZlIHBlcmZvcm1hbmNlLCBpbmNyZWFzZSB5b3VyXCIpO1xuXHQgICAgY29uc29sZS5sb2coXCJyZXF1ZXN0IHJhdGUvbGltaXQgYW5kIGVuYWJsZSBvdGhlciBwZXJrcywgc3VjaCBhcyBtZXRyaWNzIGFuZCBhZHZhbmNlZCBBUElzLlwiKTtcblx0ICAgIGNvbnNvbGUubG9nKFwiXCIpO1xuXHQgICAgY29uc29sZS5sb2coXCJGb3IgbW9yZSBkZXRhaWxzOiBodHRwczovXFwvZG9jcy5ldGhlcnMuaW8vYXBpLWtleXMvXCIpO1xuXHQgICAgY29uc29sZS5sb2coXCI9PT09PT09PT09PT09PT09PT09PT09PT09PVwiKTtcblx0fVxuXHRleHBvcnRzLnNob3dUaHJvdHRsZU1lc3NhZ2UgPSBzaG93VGhyb3R0bGVNZXNzYWdlO1xuXG5cdH0pO1xuXG5cdHZhciBmb3JtYXR0ZXIkMSA9IC8qQF9fUFVSRV9fKi9nZXREZWZhdWx0RXhwb3J0RnJvbUNqcyhmb3JtYXR0ZXIpO1xuXG5cdHZhciBiYXNlUHJvdmlkZXIgPSBjcmVhdGVDb21tb25qc01vZHVsZShmdW5jdGlvbiAobW9kdWxlLCBleHBvcnRzKSB7XG5cdFwidXNlIHN0cmljdFwiO1xuXHR2YXIgX19leHRlbmRzID0gKGNvbW1vbmpzR2xvYmFsICYmIGNvbW1vbmpzR2xvYmFsLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcblx0ICAgIHZhciBleHRlbmRTdGF0aWNzID0gZnVuY3Rpb24gKGQsIGIpIHtcblx0ICAgICAgICBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG5cdCAgICAgICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcblx0ICAgICAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGIsIHApKSBkW3BdID0gYltwXTsgfTtcblx0ICAgICAgICByZXR1cm4gZXh0ZW5kU3RhdGljcyhkLCBiKTtcblx0ICAgIH07XG5cdCAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcblx0ICAgICAgICBpZiAodHlwZW9mIGIgIT09IFwiZnVuY3Rpb25cIiAmJiBiICE9PSBudWxsKVxuXHQgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2xhc3MgZXh0ZW5kcyB2YWx1ZSBcIiArIFN0cmluZyhiKSArIFwiIGlzIG5vdCBhIGNvbnN0cnVjdG9yIG9yIG51bGxcIik7XG5cdCAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcblx0ICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cblx0ICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG5cdCAgICB9O1xuXHR9KSgpO1xuXHR2YXIgX19hd2FpdGVyID0gKGNvbW1vbmpzR2xvYmFsICYmIGNvbW1vbmpzR2xvYmFsLl9fYXdhaXRlcikgfHwgZnVuY3Rpb24gKHRoaXNBcmcsIF9hcmd1bWVudHMsIFAsIGdlbmVyYXRvcikge1xuXHQgICAgZnVuY3Rpb24gYWRvcHQodmFsdWUpIHsgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgUCA/IHZhbHVlIDogbmV3IFAoZnVuY3Rpb24gKHJlc29sdmUpIHsgcmVzb2x2ZSh2YWx1ZSk7IH0pOyB9XG5cdCAgICByZXR1cm4gbmV3IChQIHx8IChQID0gUHJvbWlzZSkpKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcblx0ICAgICAgICBmdW5jdGlvbiBmdWxmaWxsZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3IubmV4dCh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG5cdCAgICAgICAgZnVuY3Rpb24gcmVqZWN0ZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3JbXCJ0aHJvd1wiXSh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG5cdCAgICAgICAgZnVuY3Rpb24gc3RlcChyZXN1bHQpIHsgcmVzdWx0LmRvbmUgPyByZXNvbHZlKHJlc3VsdC52YWx1ZSkgOiBhZG9wdChyZXN1bHQudmFsdWUpLnRoZW4oZnVsZmlsbGVkLCByZWplY3RlZCk7IH1cblx0ICAgICAgICBzdGVwKChnZW5lcmF0b3IgPSBnZW5lcmF0b3IuYXBwbHkodGhpc0FyZywgX2FyZ3VtZW50cyB8fCBbXSkpLm5leHQoKSk7XG5cdCAgICB9KTtcblx0fTtcblx0dmFyIF9fZ2VuZXJhdG9yID0gKGNvbW1vbmpzR2xvYmFsICYmIGNvbW1vbmpzR2xvYmFsLl9fZ2VuZXJhdG9yKSB8fCBmdW5jdGlvbiAodGhpc0FyZywgYm9keSkge1xuXHQgICAgdmFyIF8gPSB7IGxhYmVsOiAwLCBzZW50OiBmdW5jdGlvbigpIHsgaWYgKHRbMF0gJiAxKSB0aHJvdyB0WzFdOyByZXR1cm4gdFsxXTsgfSwgdHJ5czogW10sIG9wczogW10gfSwgZiwgeSwgdCwgZztcblx0ICAgIHJldHVybiBnID0geyBuZXh0OiB2ZXJiKDApLCBcInRocm93XCI6IHZlcmIoMSksIFwicmV0dXJuXCI6IHZlcmIoMikgfSwgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIChnW1N5bWJvbC5pdGVyYXRvcl0gPSBmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXM7IH0pLCBnO1xuXHQgICAgZnVuY3Rpb24gdmVyYihuKSB7IHJldHVybiBmdW5jdGlvbiAodikgeyByZXR1cm4gc3RlcChbbiwgdl0pOyB9OyB9XG5cdCAgICBmdW5jdGlvbiBzdGVwKG9wKSB7XG5cdCAgICAgICAgaWYgKGYpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJHZW5lcmF0b3IgaXMgYWxyZWFkeSBleGVjdXRpbmcuXCIpO1xuXHQgICAgICAgIHdoaWxlIChfKSB0cnkge1xuXHQgICAgICAgICAgICBpZiAoZiA9IDEsIHkgJiYgKHQgPSBvcFswXSAmIDIgPyB5W1wicmV0dXJuXCJdIDogb3BbMF0gPyB5W1widGhyb3dcIl0gfHwgKCh0ID0geVtcInJldHVyblwiXSkgJiYgdC5jYWxsKHkpLCAwKSA6IHkubmV4dCkgJiYgISh0ID0gdC5jYWxsKHksIG9wWzFdKSkuZG9uZSkgcmV0dXJuIHQ7XG5cdCAgICAgICAgICAgIGlmICh5ID0gMCwgdCkgb3AgPSBbb3BbMF0gJiAyLCB0LnZhbHVlXTtcblx0ICAgICAgICAgICAgc3dpdGNoIChvcFswXSkge1xuXHQgICAgICAgICAgICAgICAgY2FzZSAwOiBjYXNlIDE6IHQgPSBvcDsgYnJlYWs7XG5cdCAgICAgICAgICAgICAgICBjYXNlIDQ6IF8ubGFiZWwrKzsgcmV0dXJuIHsgdmFsdWU6IG9wWzFdLCBkb25lOiBmYWxzZSB9O1xuXHQgICAgICAgICAgICAgICAgY2FzZSA1OiBfLmxhYmVsKys7IHkgPSBvcFsxXTsgb3AgPSBbMF07IGNvbnRpbnVlO1xuXHQgICAgICAgICAgICAgICAgY2FzZSA3OiBvcCA9IF8ub3BzLnBvcCgpOyBfLnRyeXMucG9wKCk7IGNvbnRpbnVlO1xuXHQgICAgICAgICAgICAgICAgZGVmYXVsdDpcblx0ICAgICAgICAgICAgICAgICAgICBpZiAoISh0ID0gXy50cnlzLCB0ID0gdC5sZW5ndGggPiAwICYmIHRbdC5sZW5ndGggLSAxXSkgJiYgKG9wWzBdID09PSA2IHx8IG9wWzBdID09PSAyKSkgeyBfID0gMDsgY29udGludWU7IH1cblx0ICAgICAgICAgICAgICAgICAgICBpZiAob3BbMF0gPT09IDMgJiYgKCF0IHx8IChvcFsxXSA+IHRbMF0gJiYgb3BbMV0gPCB0WzNdKSkpIHsgXy5sYWJlbCA9IG9wWzFdOyBicmVhazsgfVxuXHQgICAgICAgICAgICAgICAgICAgIGlmIChvcFswXSA9PT0gNiAmJiBfLmxhYmVsIDwgdFsxXSkgeyBfLmxhYmVsID0gdFsxXTsgdCA9IG9wOyBicmVhazsgfVxuXHQgICAgICAgICAgICAgICAgICAgIGlmICh0ICYmIF8ubGFiZWwgPCB0WzJdKSB7IF8ubGFiZWwgPSB0WzJdOyBfLm9wcy5wdXNoKG9wKTsgYnJlYWs7IH1cblx0ICAgICAgICAgICAgICAgICAgICBpZiAodFsyXSkgXy5vcHMucG9wKCk7XG5cdCAgICAgICAgICAgICAgICAgICAgXy50cnlzLnBvcCgpOyBjb250aW51ZTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICBvcCA9IGJvZHkuY2FsbCh0aGlzQXJnLCBfKTtcblx0ICAgICAgICB9IGNhdGNoIChlKSB7IG9wID0gWzYsIGVdOyB5ID0gMDsgfSBmaW5hbGx5IHsgZiA9IHQgPSAwOyB9XG5cdCAgICAgICAgaWYgKG9wWzBdICYgNSkgdGhyb3cgb3BbMV07IHJldHVybiB7IHZhbHVlOiBvcFswXSA/IG9wWzFdIDogdm9pZCAwLCBkb25lOiB0cnVlIH07XG5cdCAgICB9XG5cdH07XG5cdHZhciBfX2ltcG9ydERlZmF1bHQgPSAoY29tbW9uanNHbG9iYWwgJiYgY29tbW9uanNHbG9iYWwuX19pbXBvcnREZWZhdWx0KSB8fCBmdW5jdGlvbiAobW9kKSB7XG5cdCAgICByZXR1cm4gKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgPyBtb2QgOiB7IFwiZGVmYXVsdFwiOiBtb2QgfTtcblx0fTtcblx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuXHRleHBvcnRzLkJhc2VQcm92aWRlciA9IGV4cG9ydHMuUmVzb2x2ZXIgPSBleHBvcnRzLkV2ZW50ID0gdm9pZCAwO1xuXG5cblxuXG5cblxuXG5cblxuXG5cblx0dmFyIGJlY2gzMl8xID0gX19pbXBvcnREZWZhdWx0KGJlY2gzMik7XG5cblxuXHR2YXIgbG9nZ2VyID0gbmV3IGxpYi5Mb2dnZXIoX3ZlcnNpb24kSS52ZXJzaW9uKTtcblxuXHQvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cblx0Ly8gRXZlbnQgU2VyaWFsaXplaW5nXG5cdGZ1bmN0aW9uIGNoZWNrVG9waWModG9waWMpIHtcblx0ICAgIGlmICh0b3BpYyA9PSBudWxsKSB7XG5cdCAgICAgICAgcmV0dXJuIFwibnVsbFwiO1xuXHQgICAgfVxuXHQgICAgaWYgKCgwLCBsaWIkMS5oZXhEYXRhTGVuZ3RoKSh0b3BpYykgIT09IDMyKSB7XG5cdCAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcImludmFsaWQgdG9waWNcIiwgXCJ0b3BpY1wiLCB0b3BpYyk7XG5cdCAgICB9XG5cdCAgICByZXR1cm4gdG9waWMudG9Mb3dlckNhc2UoKTtcblx0fVxuXHRmdW5jdGlvbiBzZXJpYWxpemVUb3BpY3ModG9waWNzKSB7XG5cdCAgICAvLyBSZW1vdmUgdHJhaWxpbmcgbnVsbCBBTkQtdG9waWNzOyB0aGV5IGFyZSByZWR1bmRhbnRcblx0ICAgIHRvcGljcyA9IHRvcGljcy5zbGljZSgpO1xuXHQgICAgd2hpbGUgKHRvcGljcy5sZW5ndGggPiAwICYmIHRvcGljc1t0b3BpY3MubGVuZ3RoIC0gMV0gPT0gbnVsbCkge1xuXHQgICAgICAgIHRvcGljcy5wb3AoKTtcblx0ICAgIH1cblx0ICAgIHJldHVybiB0b3BpY3MubWFwKGZ1bmN0aW9uICh0b3BpYykge1xuXHQgICAgICAgIGlmIChBcnJheS5pc0FycmF5KHRvcGljKSkge1xuXHQgICAgICAgICAgICAvLyBPbmx5IHRyYWNrIHVuaXF1ZSBPUi10b3BpY3Ncblx0ICAgICAgICAgICAgdmFyIHVuaXF1ZV8xID0ge307XG5cdCAgICAgICAgICAgIHRvcGljLmZvckVhY2goZnVuY3Rpb24gKHRvcGljKSB7XG5cdCAgICAgICAgICAgICAgICB1bmlxdWVfMVtjaGVja1RvcGljKHRvcGljKV0gPSB0cnVlO1xuXHQgICAgICAgICAgICB9KTtcblx0ICAgICAgICAgICAgLy8gVGhlIG9yZGVyIG9mIE9SLXRvcGljcyBkb2VzIG5vdCBtYXR0ZXJcblx0ICAgICAgICAgICAgdmFyIHNvcnRlZCA9IE9iamVjdC5rZXlzKHVuaXF1ZV8xKTtcblx0ICAgICAgICAgICAgc29ydGVkLnNvcnQoKTtcblx0ICAgICAgICAgICAgcmV0dXJuIHNvcnRlZC5qb2luKFwifFwiKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgZWxzZSB7XG5cdCAgICAgICAgICAgIHJldHVybiBjaGVja1RvcGljKHRvcGljKTtcblx0ICAgICAgICB9XG5cdCAgICB9KS5qb2luKFwiJlwiKTtcblx0fVxuXHRmdW5jdGlvbiBkZXNlcmlhbGl6ZVRvcGljcyhkYXRhKSB7XG5cdCAgICBpZiAoZGF0YSA9PT0gXCJcIikge1xuXHQgICAgICAgIHJldHVybiBbXTtcblx0ICAgIH1cblx0ICAgIHJldHVybiBkYXRhLnNwbGl0KC8mL2cpLm1hcChmdW5jdGlvbiAodG9waWMpIHtcblx0ICAgICAgICBpZiAodG9waWMgPT09IFwiXCIpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIFtdO1xuXHQgICAgICAgIH1cblx0ICAgICAgICB2YXIgY29tcHMgPSB0b3BpYy5zcGxpdChcInxcIikubWFwKGZ1bmN0aW9uICh0b3BpYykge1xuXHQgICAgICAgICAgICByZXR1cm4gKCh0b3BpYyA9PT0gXCJudWxsXCIpID8gbnVsbCA6IHRvcGljKTtcblx0ICAgICAgICB9KTtcblx0ICAgICAgICByZXR1cm4gKChjb21wcy5sZW5ndGggPT09IDEpID8gY29tcHNbMF0gOiBjb21wcyk7XG5cdCAgICB9KTtcblx0fVxuXHRmdW5jdGlvbiBnZXRFdmVudFRhZyhldmVudE5hbWUpIHtcblx0ICAgIGlmICh0eXBlb2YgKGV2ZW50TmFtZSkgPT09IFwic3RyaW5nXCIpIHtcblx0ICAgICAgICBldmVudE5hbWUgPSBldmVudE5hbWUudG9Mb3dlckNhc2UoKTtcblx0ICAgICAgICBpZiAoKDAsIGxpYiQxLmhleERhdGFMZW5ndGgpKGV2ZW50TmFtZSkgPT09IDMyKSB7XG5cdCAgICAgICAgICAgIHJldHVybiBcInR4OlwiICsgZXZlbnROYW1lO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBpZiAoZXZlbnROYW1lLmluZGV4T2YoXCI6XCIpID09PSAtMSkge1xuXHQgICAgICAgICAgICByZXR1cm4gZXZlbnROYW1lO1xuXHQgICAgICAgIH1cblx0ICAgIH1cblx0ICAgIGVsc2UgaWYgKEFycmF5LmlzQXJyYXkoZXZlbnROYW1lKSkge1xuXHQgICAgICAgIHJldHVybiBcImZpbHRlcjoqOlwiICsgc2VyaWFsaXplVG9waWNzKGV2ZW50TmFtZSk7XG5cdCAgICB9XG5cdCAgICBlbHNlIGlmIChsaWIkYi5Gb3JrRXZlbnQuaXNGb3JrRXZlbnQoZXZlbnROYW1lKSkge1xuXHQgICAgICAgIGxvZ2dlci53YXJuKFwibm90IGltcGxlbWVudGVkXCIpO1xuXHQgICAgICAgIHRocm93IG5ldyBFcnJvcihcIm5vdCBpbXBsZW1lbnRlZFwiKTtcblx0ICAgIH1cblx0ICAgIGVsc2UgaWYgKGV2ZW50TmFtZSAmJiB0eXBlb2YgKGV2ZW50TmFtZSkgPT09IFwib2JqZWN0XCIpIHtcblx0ICAgICAgICByZXR1cm4gXCJmaWx0ZXI6XCIgKyAoZXZlbnROYW1lLmFkZHJlc3MgfHwgXCIqXCIpICsgXCI6XCIgKyBzZXJpYWxpemVUb3BpY3MoZXZlbnROYW1lLnRvcGljcyB8fCBbXSk7XG5cdCAgICB9XG5cdCAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIGV2ZW50IC0gXCIgKyBldmVudE5hbWUpO1xuXHR9XG5cdC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXHQvLyBIZWxwZXIgT2JqZWN0XG5cdGZ1bmN0aW9uIGdldFRpbWUoKSB7XG5cdCAgICByZXR1cm4gKG5ldyBEYXRlKCkpLmdldFRpbWUoKTtcblx0fVxuXHRmdW5jdGlvbiBzdGFsbChkdXJhdGlvbikge1xuXHQgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlKSB7XG5cdCAgICAgICAgc2V0VGltZW91dChyZXNvbHZlLCBkdXJhdGlvbik7XG5cdCAgICB9KTtcblx0fVxuXHQvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cblx0Ly8gUHJvdmlkZXIgT2JqZWN0XG5cdC8qKlxuXHQgKiAgRXZlbnRUeXBlXG5cdCAqICAgLSBcImJsb2NrXCJcblx0ICogICAtIFwicG9sbFwiXG5cdCAqICAgLSBcImRpZFBvbGxcIlxuXHQgKiAgIC0gXCJwZW5kaW5nXCJcblx0ICogICAtIFwiZXJyb3JcIlxuXHQgKiAgIC0gXCJuZXR3b3JrXCJcblx0ICogICAtIGZpbHRlclxuXHQgKiAgIC0gdG9waWNzIGFycmF5XG5cdCAqICAgLSB0cmFuc2FjdGlvbiBoYXNoXG5cdCAqL1xuXHR2YXIgUG9sbGFibGVFdmVudHMgPSBbXCJibG9ja1wiLCBcIm5ldHdvcmtcIiwgXCJwZW5kaW5nXCIsIFwicG9sbFwiXTtcblx0dmFyIEV2ZW50ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuXHQgICAgZnVuY3Rpb24gRXZlbnQodGFnLCBsaXN0ZW5lciwgb25jZSkge1xuXHQgICAgICAgICgwLCBsaWIkMy5kZWZpbmVSZWFkT25seSkodGhpcywgXCJ0YWdcIiwgdGFnKTtcblx0ICAgICAgICAoMCwgbGliJDMuZGVmaW5lUmVhZE9ubHkpKHRoaXMsIFwibGlzdGVuZXJcIiwgbGlzdGVuZXIpO1xuXHQgICAgICAgICgwLCBsaWIkMy5kZWZpbmVSZWFkT25seSkodGhpcywgXCJvbmNlXCIsIG9uY2UpO1xuXHQgICAgfVxuXHQgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEV2ZW50LnByb3RvdHlwZSwgXCJldmVudFwiLCB7XG5cdCAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIHN3aXRjaCAodGhpcy50eXBlKSB7XG5cdCAgICAgICAgICAgICAgICBjYXNlIFwidHhcIjpcblx0ICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5oYXNoO1xuXHQgICAgICAgICAgICAgICAgY2FzZSBcImZpbHRlclwiOlxuXHQgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmZpbHRlcjtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICByZXR1cm4gdGhpcy50YWc7XG5cdCAgICAgICAgfSxcblx0ICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcblx0ICAgICAgICBjb25maWd1cmFibGU6IHRydWVcblx0ICAgIH0pO1xuXHQgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEV2ZW50LnByb3RvdHlwZSwgXCJ0eXBlXCIsIHtcblx0ICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIHRoaXMudGFnLnNwbGl0KFwiOlwiKVswXTtcblx0ICAgICAgICB9LFxuXHQgICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuXHQgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuXHQgICAgfSk7XG5cdCAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoRXZlbnQucHJvdG90eXBlLCBcImhhc2hcIiwge1xuXHQgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICB2YXIgY29tcHMgPSB0aGlzLnRhZy5zcGxpdChcIjpcIik7XG5cdCAgICAgICAgICAgIGlmIChjb21wc1swXSAhPT0gXCJ0eFwiKSB7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICByZXR1cm4gY29tcHNbMV07XG5cdCAgICAgICAgfSxcblx0ICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcblx0ICAgICAgICBjb25maWd1cmFibGU6IHRydWVcblx0ICAgIH0pO1xuXHQgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEV2ZW50LnByb3RvdHlwZSwgXCJmaWx0ZXJcIiwge1xuXHQgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICB2YXIgY29tcHMgPSB0aGlzLnRhZy5zcGxpdChcIjpcIik7XG5cdCAgICAgICAgICAgIGlmIChjb21wc1swXSAhPT0gXCJmaWx0ZXJcIikge1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgdmFyIGFkZHJlc3MgPSBjb21wc1sxXTtcblx0ICAgICAgICAgICAgdmFyIHRvcGljcyA9IGRlc2VyaWFsaXplVG9waWNzKGNvbXBzWzJdKTtcblx0ICAgICAgICAgICAgdmFyIGZpbHRlciA9IHt9O1xuXHQgICAgICAgICAgICBpZiAodG9waWNzLmxlbmd0aCA+IDApIHtcblx0ICAgICAgICAgICAgICAgIGZpbHRlci50b3BpY3MgPSB0b3BpY3M7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgaWYgKGFkZHJlc3MgJiYgYWRkcmVzcyAhPT0gXCIqXCIpIHtcblx0ICAgICAgICAgICAgICAgIGZpbHRlci5hZGRyZXNzID0gYWRkcmVzcztcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICByZXR1cm4gZmlsdGVyO1xuXHQgICAgICAgIH0sXG5cdCAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG5cdCAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG5cdCAgICB9KTtcblx0ICAgIEV2ZW50LnByb3RvdHlwZS5wb2xsYWJsZSA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICByZXR1cm4gKHRoaXMudGFnLmluZGV4T2YoXCI6XCIpID49IDAgfHwgUG9sbGFibGVFdmVudHMuaW5kZXhPZih0aGlzLnRhZykgPj0gMCk7XG5cdCAgICB9O1xuXHQgICAgcmV0dXJuIEV2ZW50O1xuXHR9KCkpO1xuXHRleHBvcnRzLkV2ZW50ID0gRXZlbnQ7XG5cdDtcblx0Ly8gaHR0cHM6Ly9naXRodWIuY29tL3NhdG9zaGlsYWJzL3NsaXBzL2Jsb2IvbWFzdGVyL3NsaXAtMDA0NC5tZFxuXHR2YXIgY29pbkluZm9zID0ge1xuXHQgICAgXCIwXCI6IHsgc3ltYm9sOiBcImJ0Y1wiLCBwMnBraDogMHgwMCwgcDJzaDogMHgwNSwgcHJlZml4OiBcImJjXCIgfSxcblx0ICAgIFwiMlwiOiB7IHN5bWJvbDogXCJsdGNcIiwgcDJwa2g6IDB4MzAsIHAyc2g6IDB4MzIsIHByZWZpeDogXCJsdGNcIiB9LFxuXHQgICAgXCIzXCI6IHsgc3ltYm9sOiBcImRvZ2VcIiwgcDJwa2g6IDB4MWUsIHAyc2g6IDB4MTYgfSxcblx0ICAgIFwiNjBcIjogeyBzeW1ib2w6IFwiZXRoXCIsIGlsazogXCJldGhcIiB9LFxuXHQgICAgXCI2MVwiOiB7IHN5bWJvbDogXCJldGNcIiwgaWxrOiBcImV0aFwiIH0sXG5cdCAgICBcIjcwMFwiOiB7IHN5bWJvbDogXCJ4ZGFpXCIsIGlsazogXCJldGhcIiB9LFxuXHR9O1xuXHRmdW5jdGlvbiBieXRlczMyaWZ5KHZhbHVlKSB7XG5cdCAgICByZXR1cm4gKDAsIGxpYiQxLmhleFplcm9QYWQpKGxpYiQyLkJpZ051bWJlci5mcm9tKHZhbHVlKS50b0hleFN0cmluZygpLCAzMik7XG5cdH1cblx0Ly8gQ29tcHV0ZSB0aGUgQmFzZTU4Q2hlY2sgZW5jb2RlZCBkYXRhIChjaGVja3N1bSBpcyBmaXJzdCA0IGJ5dGVzIG9mIHNoYTI1NmQpXG5cdGZ1bmN0aW9uIGJhc2U1OEVuY29kZShkYXRhKSB7XG5cdCAgICByZXR1cm4gbGliJGcuQmFzZTU4LmVuY29kZSgoMCwgbGliJDEuY29uY2F0KShbZGF0YSwgKDAsIGxpYiQxLmhleERhdGFTbGljZSkoKDAsIGxpYiRoLnNoYTI1NikoKDAsIGxpYiRoLnNoYTI1NikoZGF0YSkpLCAwLCA0KV0pKTtcblx0fVxuXHR2YXIgbWF0Y2hlcnMgPSBbXG5cdCAgICBuZXcgUmVnRXhwKFwiXihodHRwcyk6L1xcLyguKikkXCIsIFwiaVwiKSxcblx0ICAgIG5ldyBSZWdFeHAoXCJeKGRhdGEpOiguKikkXCIsIFwiaVwiKSxcblx0ICAgIG5ldyBSZWdFeHAoXCJeKGlwZnMpOi9cXC8oLiopJFwiLCBcImlcIiksXG5cdCAgICBuZXcgUmVnRXhwKFwiXmVpcDE1NTpbMC05XSsvKGVyY1swLTldKyk6KC4qKSRcIiwgXCJpXCIpLFxuXHRdO1xuXHRmdW5jdGlvbiBfcGFyc2VTdHJpbmcocmVzdWx0KSB7XG5cdCAgICB0cnkge1xuXHQgICAgICAgIHJldHVybiAoMCwgbGliJDgudG9VdGY4U3RyaW5nKShfcGFyc2VCeXRlcyhyZXN1bHQpKTtcblx0ICAgIH1cblx0ICAgIGNhdGNoIChlcnJvcikgeyB9XG5cdCAgICByZXR1cm4gbnVsbDtcblx0fVxuXHRmdW5jdGlvbiBfcGFyc2VCeXRlcyhyZXN1bHQpIHtcblx0ICAgIGlmIChyZXN1bHQgPT09IFwiMHhcIikge1xuXHQgICAgICAgIHJldHVybiBudWxsO1xuXHQgICAgfVxuXHQgICAgdmFyIG9mZnNldCA9IGxpYiQyLkJpZ051bWJlci5mcm9tKCgwLCBsaWIkMS5oZXhEYXRhU2xpY2UpKHJlc3VsdCwgMCwgMzIpKS50b051bWJlcigpO1xuXHQgICAgdmFyIGxlbmd0aCA9IGxpYiQyLkJpZ051bWJlci5mcm9tKCgwLCBsaWIkMS5oZXhEYXRhU2xpY2UpKHJlc3VsdCwgb2Zmc2V0LCBvZmZzZXQgKyAzMikpLnRvTnVtYmVyKCk7XG5cdCAgICByZXR1cm4gKDAsIGxpYiQxLmhleERhdGFTbGljZSkocmVzdWx0LCBvZmZzZXQgKyAzMiwgb2Zmc2V0ICsgMzIgKyBsZW5ndGgpO1xuXHR9XG5cdHZhciBSZXNvbHZlciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcblx0ICAgIC8vIFRoZSByZXNvbHZlZEFkZHJlc3MgaXMgb25seSBmb3IgY3JlYXRpbmcgYSBSZXZlcnNlTG9va3VwIHJlc29sdmVyXG5cdCAgICBmdW5jdGlvbiBSZXNvbHZlcihwcm92aWRlciwgYWRkcmVzcywgbmFtZSwgcmVzb2x2ZWRBZGRyZXNzKSB7XG5cdCAgICAgICAgKDAsIGxpYiQzLmRlZmluZVJlYWRPbmx5KSh0aGlzLCBcInByb3ZpZGVyXCIsIHByb3ZpZGVyKTtcblx0ICAgICAgICAoMCwgbGliJDMuZGVmaW5lUmVhZE9ubHkpKHRoaXMsIFwibmFtZVwiLCBuYW1lKTtcblx0ICAgICAgICAoMCwgbGliJDMuZGVmaW5lUmVhZE9ubHkpKHRoaXMsIFwiYWRkcmVzc1wiLCBwcm92aWRlci5mb3JtYXR0ZXIuYWRkcmVzcyhhZGRyZXNzKSk7XG5cdCAgICAgICAgKDAsIGxpYiQzLmRlZmluZVJlYWRPbmx5KSh0aGlzLCBcIl9yZXNvbHZlZEFkZHJlc3NcIiwgcmVzb2x2ZWRBZGRyZXNzKTtcblx0ICAgIH1cblx0ICAgIFJlc29sdmVyLnByb3RvdHlwZS5fZmV0Y2hCeXRlcyA9IGZ1bmN0aW9uIChzZWxlY3RvciwgcGFyYW1ldGVycykge1xuXHQgICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgdmFyIHR4LCBfYSwgZXJyb3JfMTtcblx0ICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYikge1xuXHQgICAgICAgICAgICAgICAgc3dpdGNoIChfYi5sYWJlbCkge1xuXHQgICAgICAgICAgICAgICAgICAgIGNhc2UgMDpcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdHggPSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB0bzogdGhpcy5hZGRyZXNzLFxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YTogKDAsIGxpYiQxLmhleENvbmNhdCkoW3NlbGVjdG9yLCAoMCwgbGliJDkubmFtZWhhc2gpKHRoaXMubmFtZSksIChwYXJhbWV0ZXJzIHx8IFwiMHhcIildKVxuXHQgICAgICAgICAgICAgICAgICAgICAgICB9O1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBfYi5sYWJlbCA9IDE7XG5cdCAgICAgICAgICAgICAgICAgICAgY2FzZSAxOlxuXHQgICAgICAgICAgICAgICAgICAgICAgICBfYi50cnlzLnB1c2goWzEsIDMsICwgNF0pO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBfYSA9IF9wYXJzZUJ5dGVzO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCB0aGlzLnByb3ZpZGVyLmNhbGwodHgpXTtcblx0ICAgICAgICAgICAgICAgICAgICBjYXNlIDI6IHJldHVybiBbMiAvKnJldHVybiovLCBfYS5hcHBseSh2b2lkIDAsIFtfYi5zZW50KCldKV07XG5cdCAgICAgICAgICAgICAgICAgICAgY2FzZSAzOlxuXHQgICAgICAgICAgICAgICAgICAgICAgICBlcnJvcl8xID0gX2Iuc2VudCgpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZXJyb3JfMS5jb2RlID09PSBsaWIuTG9nZ2VyLmVycm9ycy5DQUxMX0VYQ0VQVElPTikge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIG51bGxdO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCBudWxsXTtcblx0ICAgICAgICAgICAgICAgICAgICBjYXNlIDQ6IHJldHVybiBbMiAvKnJldHVybiovXTtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgfSk7XG5cdCAgICB9O1xuXHQgICAgUmVzb2x2ZXIucHJvdG90eXBlLl9nZXRBZGRyZXNzID0gZnVuY3Rpb24gKGNvaW5UeXBlLCBoZXhCeXRlcykge1xuXHQgICAgICAgIHZhciBjb2luSW5mbyA9IGNvaW5JbmZvc1tTdHJpbmcoY29pblR5cGUpXTtcblx0ICAgICAgICBpZiAoY29pbkluZm8gPT0gbnVsbCkge1xuXHQgICAgICAgICAgICBsb2dnZXIudGhyb3dFcnJvcihcInVuc3VwcG9ydGVkIGNvaW4gdHlwZTogXCIgKyBjb2luVHlwZSwgbGliLkxvZ2dlci5lcnJvcnMuVU5TVVBQT1JURURfT1BFUkFUSU9OLCB7XG5cdCAgICAgICAgICAgICAgICBvcGVyYXRpb246IFwiZ2V0QWRkcmVzcyhcIiArIGNvaW5UeXBlICsgXCIpXCJcblx0ICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGlmIChjb2luSW5mby5pbGsgPT09IFwiZXRoXCIpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIHRoaXMucHJvdmlkZXIuZm9ybWF0dGVyLmFkZHJlc3MoaGV4Qnl0ZXMpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICB2YXIgYnl0ZXMgPSAoMCwgbGliJDEuYXJyYXlpZnkpKGhleEJ5dGVzKTtcblx0ICAgICAgICAvLyBQMlBLSDogT1BfRFVQIE9QX0hBU0gxNjAgPHB1YktleUhhc2g+IE9QX0VRVUFMVkVSSUZZIE9QX0NIRUNLU0lHXG5cdCAgICAgICAgaWYgKGNvaW5JbmZvLnAycGtoICE9IG51bGwpIHtcblx0ICAgICAgICAgICAgdmFyIHAycGtoID0gaGV4Qnl0ZXMubWF0Y2goL14weDc2YTkoWzAtOWEtZl1bMC05YS1mXSkoWzAtOWEtZl0qKTg4YWMkLyk7XG5cdCAgICAgICAgICAgIGlmIChwMnBraCkge1xuXHQgICAgICAgICAgICAgICAgdmFyIGxlbmd0aF8xID0gcGFyc2VJbnQocDJwa2hbMV0sIDE2KTtcblx0ICAgICAgICAgICAgICAgIGlmIChwMnBraFsyXS5sZW5ndGggPT09IGxlbmd0aF8xICogMiAmJiBsZW5ndGhfMSA+PSAxICYmIGxlbmd0aF8xIDw9IDc1KSB7XG5cdCAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGJhc2U1OEVuY29kZSgoMCwgbGliJDEuY29uY2F0KShbW2NvaW5JbmZvLnAycGtoXSwgKFwiMHhcIiArIHAycGtoWzJdKV0pKTtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH1cblx0ICAgICAgICAvLyBQMlNIOiBPUF9IQVNIMTYwIDxzY3JpcHRIYXNoPiBPUF9FUVVBTFxuXHQgICAgICAgIGlmIChjb2luSW5mby5wMnNoICE9IG51bGwpIHtcblx0ICAgICAgICAgICAgdmFyIHAyc2ggPSBoZXhCeXRlcy5tYXRjaCgvXjB4YTkoWzAtOWEtZl1bMC05YS1mXSkoWzAtOWEtZl0qKTg3JC8pO1xuXHQgICAgICAgICAgICBpZiAocDJzaCkge1xuXHQgICAgICAgICAgICAgICAgdmFyIGxlbmd0aF8yID0gcGFyc2VJbnQocDJzaFsxXSwgMTYpO1xuXHQgICAgICAgICAgICAgICAgaWYgKHAyc2hbMl0ubGVuZ3RoID09PSBsZW5ndGhfMiAqIDIgJiYgbGVuZ3RoXzIgPj0gMSAmJiBsZW5ndGhfMiA8PSA3NSkge1xuXHQgICAgICAgICAgICAgICAgICAgIHJldHVybiBiYXNlNThFbmNvZGUoKDAsIGxpYiQxLmNvbmNhdCkoW1tjb2luSW5mby5wMnNoXSwgKFwiMHhcIiArIHAyc2hbMl0pXSkpO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfVxuXHQgICAgICAgIC8vIEJlY2gzMlxuXHQgICAgICAgIGlmIChjb2luSW5mby5wcmVmaXggIT0gbnVsbCkge1xuXHQgICAgICAgICAgICB2YXIgbGVuZ3RoXzMgPSBieXRlc1sxXTtcblx0ICAgICAgICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2JpdGNvaW4vYmlwcy9ibG9iL21hc3Rlci9iaXAtMDE0MS5tZWRpYXdpa2kjd2l0bmVzcy1wcm9ncmFtXG5cdCAgICAgICAgICAgIHZhciB2ZXJzaW9uXzEgPSBieXRlc1swXTtcblx0ICAgICAgICAgICAgaWYgKHZlcnNpb25fMSA9PT0gMHgwMCkge1xuXHQgICAgICAgICAgICAgICAgaWYgKGxlbmd0aF8zICE9PSAyMCAmJiBsZW5ndGhfMyAhPT0gMzIpIHtcblx0ICAgICAgICAgICAgICAgICAgICB2ZXJzaW9uXzEgPSAtMTtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICBlbHNlIHtcblx0ICAgICAgICAgICAgICAgIHZlcnNpb25fMSA9IC0xO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIGlmICh2ZXJzaW9uXzEgPj0gMCAmJiBieXRlcy5sZW5ndGggPT09IDIgKyBsZW5ndGhfMyAmJiBsZW5ndGhfMyA+PSAxICYmIGxlbmd0aF8zIDw9IDc1KSB7XG5cdCAgICAgICAgICAgICAgICB2YXIgd29yZHMgPSBiZWNoMzJfMS5kZWZhdWx0LnRvV29yZHMoYnl0ZXMuc2xpY2UoMikpO1xuXHQgICAgICAgICAgICAgICAgd29yZHMudW5zaGlmdCh2ZXJzaW9uXzEpO1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuIGJlY2gzMl8xLmRlZmF1bHQuZW5jb2RlKGNvaW5JbmZvLnByZWZpeCwgd29yZHMpO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHJldHVybiBudWxsO1xuXHQgICAgfTtcblx0ICAgIFJlc29sdmVyLnByb3RvdHlwZS5nZXRBZGRyZXNzID0gZnVuY3Rpb24gKGNvaW5UeXBlKSB7XG5cdCAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICB2YXIgdHJhbnNhY3Rpb24sIGhleEJ5dGVzXzEsIGVycm9yXzIsIGhleEJ5dGVzLCBhZGRyZXNzO1xuXHQgICAgICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG5cdCAgICAgICAgICAgICAgICBzd2l0Y2ggKF9hLmxhYmVsKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgY2FzZSAwOlxuXHQgICAgICAgICAgICAgICAgICAgICAgICBpZiAoY29pblR5cGUgPT0gbnVsbCkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29pblR5cGUgPSA2MDtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIShjb2luVHlwZSA9PT0gNjApKSByZXR1cm4gWzMgLypicmVhayovLCA0XTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgX2EubGFiZWwgPSAxO1xuXHQgICAgICAgICAgICAgICAgICAgIGNhc2UgMTpcblx0ICAgICAgICAgICAgICAgICAgICAgICAgX2EudHJ5cy5wdXNoKFsxLCAzLCAsIDRdKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdHJhbnNhY3Rpb24gPSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB0bzogdGhpcy5hZGRyZXNzLFxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YTogKFwiMHgzYjNiNTdkZVwiICsgKDAsIGxpYiQ5Lm5hbWVoYXNoKSh0aGlzLm5hbWUpLnN1YnN0cmluZygyKSlcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgdGhpcy5wcm92aWRlci5jYWxsKHRyYW5zYWN0aW9uKV07XG5cdCAgICAgICAgICAgICAgICAgICAgY2FzZSAyOlxuXHQgICAgICAgICAgICAgICAgICAgICAgICBoZXhCeXRlc18xID0gX2Euc2VudCgpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAvLyBObyBhZGRyZXNzXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGlmIChoZXhCeXRlc18xID09PSBcIjB4XCIgfHwgaGV4Qnl0ZXNfMSA9PT0gbGliJDcuSGFzaFplcm8pIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCBudWxsXTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgdGhpcy5wcm92aWRlci5mb3JtYXR0ZXIuY2FsbEFkZHJlc3MoaGV4Qnl0ZXNfMSldO1xuXHQgICAgICAgICAgICAgICAgICAgIGNhc2UgMzpcblx0ICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3JfMiA9IF9hLnNlbnQoKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGVycm9yXzIuY29kZSA9PT0gbGliLkxvZ2dlci5lcnJvcnMuQ0FMTF9FWENFUFRJT04pIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCBudWxsXTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcl8yO1xuXHQgICAgICAgICAgICAgICAgICAgIGNhc2UgNDogcmV0dXJuIFs0IC8qeWllbGQqLywgdGhpcy5fZmV0Y2hCeXRlcyhcIjB4ZjFjYjdlMDZcIiwgYnl0ZXMzMmlmeShjb2luVHlwZSkpXTtcblx0ICAgICAgICAgICAgICAgICAgICBjYXNlIDU6XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGhleEJ5dGVzID0gX2Euc2VudCgpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAvLyBObyBhZGRyZXNzXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGlmIChoZXhCeXRlcyA9PSBudWxsIHx8IGhleEJ5dGVzID09PSBcIjB4XCIpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCBudWxsXTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgICAgICBhZGRyZXNzID0gdGhpcy5fZ2V0QWRkcmVzcyhjb2luVHlwZSwgaGV4Qnl0ZXMpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBpZiAoYWRkcmVzcyA9PSBudWxsKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBsb2dnZXIudGhyb3dFcnJvcihcImludmFsaWQgb3IgdW5zdXBwb3J0ZWQgY29pbiBkYXRhXCIsIGxpYi5Mb2dnZXIuZXJyb3JzLlVOU1VQUE9SVEVEX09QRVJBVElPTiwge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wZXJhdGlvbjogXCJnZXRBZGRyZXNzKFwiICsgY29pblR5cGUgKyBcIilcIixcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2luVHlwZTogY29pblR5cGUsXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YTogaGV4Qnl0ZXNcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCBhZGRyZXNzXTtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgfSk7XG5cdCAgICB9O1xuXHQgICAgUmVzb2x2ZXIucHJvdG90eXBlLmdldEF2YXRhciA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIHZhciBsaW5rYWdlLCBhdmF0YXIsIGksIG1hdGNoLCBfYSwgc2VsZWN0b3IsIG93bmVyLCBfYiwgY29tcHMsIGFkZHIsIHRva2VuSWQsIHRva2VuT3duZXIsIF9jLCBfZCwgYmFsYW5jZSwgX2UsIF9mLCB0eCwgbWV0YWRhdGFVcmwsIF9nLCBtZXRhZGF0YSwgZXJyb3JfMztcblx0ICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfaCkge1xuXHQgICAgICAgICAgICAgICAgc3dpdGNoIChfaC5sYWJlbCkge1xuXHQgICAgICAgICAgICAgICAgICAgIGNhc2UgMDpcblx0ICAgICAgICAgICAgICAgICAgICAgICAgbGlua2FnZSA9IFtdO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBfaC5sYWJlbCA9IDE7XG5cdCAgICAgICAgICAgICAgICAgICAgY2FzZSAxOlxuXHQgICAgICAgICAgICAgICAgICAgICAgICBfaC50cnlzLnB1c2goWzEsIDE5LCAsIDIwXSk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIHRoaXMuZ2V0VGV4dChcImF2YXRhclwiKV07XG5cdCAgICAgICAgICAgICAgICAgICAgY2FzZSAyOlxuXHQgICAgICAgICAgICAgICAgICAgICAgICBhdmF0YXIgPSBfaC5zZW50KCk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGlmIChhdmF0YXIgPT0gbnVsbCkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIG51bGxdO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGkgPSAwO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBfaC5sYWJlbCA9IDM7XG5cdCAgICAgICAgICAgICAgICAgICAgY2FzZSAzOlxuXHQgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIShpIDwgbWF0Y2hlcnMubGVuZ3RoKSkgcmV0dXJuIFszIC8qYnJlYWsqLywgMThdO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBtYXRjaCA9IGF2YXRhci5tYXRjaChtYXRjaGVyc1tpXSk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGlmIChtYXRjaCA9PSBudWxsKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzMgLypicmVhayovLCAxN107XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICAgICAgX2EgPSBtYXRjaFsxXTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChfYSkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcImh0dHBzXCI6IHJldHVybiBbMyAvKmJyZWFrKi8sIDRdO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcImRhdGFcIjogcmV0dXJuIFszIC8qYnJlYWsqLywgNV07XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwiaXBmc1wiOiByZXR1cm4gWzMgLypicmVhayovLCA2XTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCJlcmM3MjFcIjogcmV0dXJuIFszIC8qYnJlYWsqLywgN107XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwiZXJjMTE1NVwiOiByZXR1cm4gWzMgLypicmVhayovLCA3XTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzMgLypicmVhayovLCAxN107XG5cdCAgICAgICAgICAgICAgICAgICAgY2FzZSA0OlxuXHQgICAgICAgICAgICAgICAgICAgICAgICBsaW5rYWdlLnB1c2goeyB0eXBlOiBcInVybFwiLCBjb250ZW50OiBhdmF0YXIgfSk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCB7IGxpbmthZ2U6IGxpbmthZ2UsIHVybDogYXZhdGFyIH1dO1xuXHQgICAgICAgICAgICAgICAgICAgIGNhc2UgNTpcblx0ICAgICAgICAgICAgICAgICAgICAgICAgbGlua2FnZS5wdXNoKHsgdHlwZTogXCJkYXRhXCIsIGNvbnRlbnQ6IGF2YXRhciB9KTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIHsgbGlua2FnZTogbGlua2FnZSwgdXJsOiBhdmF0YXIgfV07XG5cdCAgICAgICAgICAgICAgICAgICAgY2FzZSA2OlxuXHQgICAgICAgICAgICAgICAgICAgICAgICBsaW5rYWdlLnB1c2goeyB0eXBlOiBcImlwZnNcIiwgY29udGVudDogYXZhdGFyIH0pO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgeyBsaW5rYWdlOiBsaW5rYWdlLCB1cmw6IFwiaHR0cHM6Ly9nYXRld2F5LmlwZnMuaW8vaXBmcy9cIiArIGF2YXRhci5zdWJzdHJpbmcoNykgfV07XG5cdCAgICAgICAgICAgICAgICAgICAgY2FzZSA3OlxuXHQgICAgICAgICAgICAgICAgICAgICAgICBzZWxlY3RvciA9IChtYXRjaFsxXSA9PT0gXCJlcmM3MjFcIikgPyBcIjB4Yzg3YjU2ZGRcIiA6IFwiMHgwZTg5MzQxY1wiO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBsaW5rYWdlLnB1c2goeyB0eXBlOiBtYXRjaFsxXSwgY29udGVudDogYXZhdGFyIH0pO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBfYiA9IHRoaXMuX3Jlc29sdmVkQWRkcmVzcztcblx0ICAgICAgICAgICAgICAgICAgICAgICAgaWYgKF9iKSByZXR1cm4gWzMgLypicmVhayovLCA5XTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgdGhpcy5nZXRBZGRyZXNzKCldO1xuXHQgICAgICAgICAgICAgICAgICAgIGNhc2UgODpcblx0ICAgICAgICAgICAgICAgICAgICAgICAgX2IgPSAoX2guc2VudCgpKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgX2gubGFiZWwgPSA5O1xuXHQgICAgICAgICAgICAgICAgICAgIGNhc2UgOTpcblx0ICAgICAgICAgICAgICAgICAgICAgICAgb3duZXIgPSAoX2IpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBjb21wcyA9IChtYXRjaFsyXSB8fCBcIlwiKS5zcGxpdChcIi9cIik7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjb21wcy5sZW5ndGggIT09IDIpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCBudWxsXTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCB0aGlzLnByb3ZpZGVyLmZvcm1hdHRlci5hZGRyZXNzKGNvbXBzWzBdKV07XG5cdCAgICAgICAgICAgICAgICAgICAgY2FzZSAxMDpcblx0ICAgICAgICAgICAgICAgICAgICAgICAgYWRkciA9IF9oLnNlbnQoKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdG9rZW5JZCA9ICgwLCBsaWIkMS5oZXhaZXJvUGFkKShsaWIkMi5CaWdOdW1iZXIuZnJvbShjb21wc1sxXSkudG9IZXhTdHJpbmcoKSwgMzIpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIShtYXRjaFsxXSA9PT0gXCJlcmM3MjFcIikpIHJldHVybiBbMyAvKmJyZWFrKi8sIDEyXTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgX2QgPSAoX2MgPSB0aGlzLnByb3ZpZGVyLmZvcm1hdHRlcikuY2FsbEFkZHJlc3M7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIHRoaXMucHJvdmlkZXIuY2FsbCh7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdG86IGFkZHIsIGRhdGE6ICgwLCBsaWIkMS5oZXhDb25jYXQpKFtcIjB4NjM1MjIxMWVcIiwgdG9rZW5JZF0pXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KV07XG5cdCAgICAgICAgICAgICAgICAgICAgY2FzZSAxMTpcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdG9rZW5Pd25lciA9IF9kLmFwcGx5KF9jLCBbX2guc2VudCgpXSk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvd25lciAhPT0gdG9rZW5Pd25lcikge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIG51bGxdO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGxpbmthZ2UucHVzaCh7IHR5cGU6IFwib3duZXJcIiwgY29udGVudDogdG9rZW5Pd25lciB9KTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFszIC8qYnJlYWsqLywgMTRdO1xuXHQgICAgICAgICAgICAgICAgICAgIGNhc2UgMTI6XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGlmICghKG1hdGNoWzFdID09PSBcImVyYzExNTVcIikpIHJldHVybiBbMyAvKmJyZWFrKi8sIDE0XTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgX2YgPSAoX2UgPSBsaWIkMi5CaWdOdW1iZXIpLmZyb207XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIHRoaXMucHJvdmlkZXIuY2FsbCh7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdG86IGFkZHIsIGRhdGE6ICgwLCBsaWIkMS5oZXhDb25jYXQpKFtcIjB4MDBmZGQ1OGVcIiwgKDAsIGxpYiQxLmhleFplcm9QYWQpKG93bmVyLCAzMiksIHRva2VuSWRdKVxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSldO1xuXHQgICAgICAgICAgICAgICAgICAgIGNhc2UgMTM6XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGJhbGFuY2UgPSBfZi5hcHBseShfZSwgW19oLnNlbnQoKV0pO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBpZiAoYmFsYW5jZS5pc1plcm8oKSkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIG51bGxdO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGxpbmthZ2UucHVzaCh7IHR5cGU6IFwiYmFsYW5jZVwiLCBjb250ZW50OiBiYWxhbmNlLnRvU3RyaW5nKCkgfSk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIF9oLmxhYmVsID0gMTQ7XG5cdCAgICAgICAgICAgICAgICAgICAgY2FzZSAxNDpcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdHggPSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB0bzogdGhpcy5wcm92aWRlci5mb3JtYXR0ZXIuYWRkcmVzcyhjb21wc1swXSksXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhOiAoMCwgbGliJDEuaGV4Q29uY2F0KShbc2VsZWN0b3IsIHRva2VuSWRdKVxuXHQgICAgICAgICAgICAgICAgICAgICAgICB9O1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBfZyA9IF9wYXJzZVN0cmluZztcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgdGhpcy5wcm92aWRlci5jYWxsKHR4KV07XG5cdCAgICAgICAgICAgICAgICAgICAgY2FzZSAxNTpcblx0ICAgICAgICAgICAgICAgICAgICAgICAgbWV0YWRhdGFVcmwgPSBfZy5hcHBseSh2b2lkIDAsIFtfaC5zZW50KCldKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG1ldGFkYXRhVXJsID09IG51bGwpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCBudWxsXTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgICAgICBsaW5rYWdlLnB1c2goeyB0eXBlOiBcIm1ldGFkYXRhLXVybFwiLCBjb250ZW50OiBtZXRhZGF0YVVybCB9KTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgLy8gRVJDLTExNTUgYWxsb3dzIGEgZ2VuZXJpYyB7aWR9IGluIHRoZSBVUkxcblx0ICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG1hdGNoWzFdID09PSBcImVyYzExNTVcIikge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWV0YWRhdGFVcmwgPSBtZXRhZGF0YVVybC5yZXBsYWNlKFwie2lkfVwiLCB0b2tlbklkLnN1YnN0cmluZygyKSk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgKDAsIGxpYiRxLmZldGNoSnNvbikobWV0YWRhdGFVcmwpXTtcblx0ICAgICAgICAgICAgICAgICAgICBjYXNlIDE2OlxuXHQgICAgICAgICAgICAgICAgICAgICAgICBtZXRhZGF0YSA9IF9oLnNlbnQoKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgLy8gUHVsbCB0aGUgaW1hZ2UgVVJMIG91dFxuXHQgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIW1ldGFkYXRhIHx8IHR5cGVvZiAobWV0YWRhdGEuaW1hZ2UpICE9PSBcInN0cmluZ1wiIHx8ICFtZXRhZGF0YS5pbWFnZS5tYXRjaCgvXmh0dHBzOlxcL1xcLy9pKSkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIG51bGxdO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGxpbmthZ2UucHVzaCh7IHR5cGU6IFwibWV0YWRhdGFcIiwgY29udGVudDogSlNPTi5zdHJpbmdpZnkobWV0YWRhdGEpIH0pO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBsaW5rYWdlLnB1c2goeyB0eXBlOiBcInVybFwiLCBjb250ZW50OiBtZXRhZGF0YS5pbWFnZSB9KTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIHsgbGlua2FnZTogbGlua2FnZSwgdXJsOiBtZXRhZGF0YS5pbWFnZSB9XTtcblx0ICAgICAgICAgICAgICAgICAgICBjYXNlIDE3OlxuXHQgICAgICAgICAgICAgICAgICAgICAgICBpKys7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMyAvKmJyZWFrKi8sIDNdO1xuXHQgICAgICAgICAgICAgICAgICAgIGNhc2UgMTg6IHJldHVybiBbMyAvKmJyZWFrKi8sIDIwXTtcblx0ICAgICAgICAgICAgICAgICAgICBjYXNlIDE5OlxuXHQgICAgICAgICAgICAgICAgICAgICAgICBlcnJvcl8zID0gX2guc2VudCgpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzMgLypicmVhayovLCAyMF07XG5cdCAgICAgICAgICAgICAgICAgICAgY2FzZSAyMDogcmV0dXJuIFsyIC8qcmV0dXJuKi8sIG51bGxdO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB9KTtcblx0ICAgICAgICB9KTtcblx0ICAgIH07XG5cdCAgICBSZXNvbHZlci5wcm90b3R5cGUuZ2V0Q29udGVudEhhc2ggPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICB2YXIgaGV4Qnl0ZXMsIGlwZnMsIGxlbmd0aF80LCBzd2FybTtcblx0ICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuXHQgICAgICAgICAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkge1xuXHQgICAgICAgICAgICAgICAgICAgIGNhc2UgMDogcmV0dXJuIFs0IC8qeWllbGQqLywgdGhpcy5fZmV0Y2hCeXRlcyhcIjB4YmMxYzU4ZDFcIildO1xuXHQgICAgICAgICAgICAgICAgICAgIGNhc2UgMTpcblx0ICAgICAgICAgICAgICAgICAgICAgICAgaGV4Qnl0ZXMgPSBfYS5zZW50KCk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIC8vIE5vIGNvbnRlbnRoYXNoXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGlmIChoZXhCeXRlcyA9PSBudWxsIHx8IGhleEJ5dGVzID09PSBcIjB4XCIpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCBudWxsXTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgICAgICBpcGZzID0gaGV4Qnl0ZXMubWF0Y2goL14weGUzMDEwMTcwKChbMC05YS1mXVswLTlhLWZdKShbMC05YS1mXVswLTlhLWZdKShbMC05YS1mXSopKSQvKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlwZnMpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxlbmd0aF80ID0gcGFyc2VJbnQoaXBmc1szXSwgMTYpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlwZnNbNF0ubGVuZ3RoID09PSBsZW5ndGhfNCAqIDIpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgXCJpcGZzOi9cXC9cIiArIGxpYiRnLkJhc2U1OC5lbmNvZGUoXCIweFwiICsgaXBmc1sxXSldO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHN3YXJtID0gaGV4Qnl0ZXMubWF0Y2goL14weGU0MDEwMWZhMDExYjIwKFswLTlhLWZdKikkLyk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzd2FybSkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHN3YXJtWzFdLmxlbmd0aCA9PT0gKDMyICogMikpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgXCJieno6L1xcL1wiICsgc3dhcm1bMV1dO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCBsb2dnZXIudGhyb3dFcnJvcihcImludmFsaWQgb3IgdW5zdXBwb3J0ZWQgY29udGVudCBoYXNoIGRhdGFcIiwgbGliLkxvZ2dlci5lcnJvcnMuVU5TVVBQT1JURURfT1BFUkFUSU9OLCB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3BlcmF0aW9uOiBcImdldENvbnRlbnRIYXNoKClcIixcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhOiBoZXhCeXRlc1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSldO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB9KTtcblx0ICAgICAgICB9KTtcblx0ICAgIH07XG5cdCAgICBSZXNvbHZlci5wcm90b3R5cGUuZ2V0VGV4dCA9IGZ1bmN0aW9uIChrZXkpIHtcblx0ICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIHZhciBrZXlCeXRlcywgaGV4Qnl0ZXM7XG5cdCAgICAgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcblx0ICAgICAgICAgICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcblx0ICAgICAgICAgICAgICAgICAgICBjYXNlIDA6XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGtleUJ5dGVzID0gKDAsIGxpYiQ4LnRvVXRmOEJ5dGVzKShrZXkpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAvLyBUaGUgbm9kZWhhc2ggY29uc3VtZXMgdGhlIGZpcnN0IHNsb3QsIHNvIHRoZSBzdHJpbmcgcG9pbnRlciB0YXJnZXRzXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIC8vIG9mZnNldCA2NCwgd2l0aCB0aGUgbGVuZ3RoIGF0IG9mZnNldCA2NCBhbmQgZGF0YSBzdGFydGluZyBhdCBvZmZzZXQgOTZcblx0ICAgICAgICAgICAgICAgICAgICAgICAga2V5Qnl0ZXMgPSAoMCwgbGliJDEuY29uY2F0KShbYnl0ZXMzMmlmeSg2NCksIGJ5dGVzMzJpZnkoa2V5Qnl0ZXMubGVuZ3RoKSwga2V5Qnl0ZXNdKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgLy8gUGFkIHRvIHdvcmQtc2l6ZSAoMzIgYnl0ZXMpXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGlmICgoa2V5Qnl0ZXMubGVuZ3RoICUgMzIpICE9PSAwKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBrZXlCeXRlcyA9ICgwLCBsaWIkMS5jb25jYXQpKFtrZXlCeXRlcywgKDAsIGxpYiQxLmhleFplcm9QYWQpKFwiMHhcIiwgMzIgLSAoa2V5Lmxlbmd0aCAlIDMyKSldKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCB0aGlzLl9mZXRjaEJ5dGVzKFwiMHg1OWQxZDQzY1wiLCAoMCwgbGliJDEuaGV4bGlmeSkoa2V5Qnl0ZXMpKV07XG5cdCAgICAgICAgICAgICAgICAgICAgY2FzZSAxOlxuXHQgICAgICAgICAgICAgICAgICAgICAgICBoZXhCeXRlcyA9IF9hLnNlbnQoKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGhleEJ5dGVzID09IG51bGwgfHwgaGV4Qnl0ZXMgPT09IFwiMHhcIikge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIG51bGxdO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCAoMCwgbGliJDgudG9VdGY4U3RyaW5nKShoZXhCeXRlcyldO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB9KTtcblx0ICAgICAgICB9KTtcblx0ICAgIH07XG5cdCAgICByZXR1cm4gUmVzb2x2ZXI7XG5cdH0oKSk7XG5cdGV4cG9ydHMuUmVzb2x2ZXIgPSBSZXNvbHZlcjtcblx0dmFyIGRlZmF1bHRGb3JtYXR0ZXIgPSBudWxsO1xuXHR2YXIgbmV4dFBvbGxJZCA9IDE7XG5cdHZhciBCYXNlUHJvdmlkZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG5cdCAgICBfX2V4dGVuZHMoQmFzZVByb3ZpZGVyLCBfc3VwZXIpO1xuXHQgICAgLyoqXG5cdCAgICAgKiAgcmVhZHlcblx0ICAgICAqXG5cdCAgICAgKiAgQSBQcm9taXNlPE5ldHdvcms+IHRoYXQgcmVzb2x2ZXMgb25seSBvbmNlIHRoZSBwcm92aWRlciBpcyByZWFkeS5cblx0ICAgICAqXG5cdCAgICAgKiAgU3ViLWNsYXNzZXMgdGhhdCBjYWxsIHRoZSBzdXBlciB3aXRoIGEgbmV0d29yayB3aXRob3V0IGEgY2hhaW5JZFxuXHQgICAgICogIE1VU1Qgc2V0IHRoaXMuIFN0YW5kYXJkIG5hbWVkIG5ldHdvcmtzIGhhdmUgYSBrbm93biBjaGFpbklkLlxuXHQgICAgICpcblx0ICAgICAqL1xuXHQgICAgZnVuY3Rpb24gQmFzZVByb3ZpZGVyKG5ldHdvcmspIHtcblx0ICAgICAgICB2YXIgX25ld1RhcmdldCA9IHRoaXMuY29uc3RydWN0b3I7XG5cdCAgICAgICAgdmFyIF90aGlzID0gdGhpcztcblx0ICAgICAgICBsb2dnZXIuY2hlY2tOZXcoX25ld1RhcmdldCwgbGliJGIuUHJvdmlkZXIpO1xuXHQgICAgICAgIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcykgfHwgdGhpcztcblx0ICAgICAgICAvLyBFdmVudHMgYmVpbmcgbGlzdGVuZWQgdG9cblx0ICAgICAgICBfdGhpcy5fZXZlbnRzID0gW107XG5cdCAgICAgICAgX3RoaXMuX2VtaXR0ZWQgPSB7IGJsb2NrOiAtMiB9O1xuXHQgICAgICAgIF90aGlzLmZvcm1hdHRlciA9IF9uZXdUYXJnZXQuZ2V0Rm9ybWF0dGVyKCk7XG5cdCAgICAgICAgLy8gSWYgbmV0d29yayBpcyBhbnksIHRoaXMgUHJvdmlkZXIgYWxsb3dzIHRoZSB1bmRlcmx5aW5nXG5cdCAgICAgICAgLy8gbmV0d29yayB0byBjaGFuZ2UgZHluYW1pY2FsbHksIGFuZCB3ZSBhdXRvLWRldGVjdCB0aGVcblx0ICAgICAgICAvLyBjdXJyZW50IG5ldHdvcmtcblx0ICAgICAgICAoMCwgbGliJDMuZGVmaW5lUmVhZE9ubHkpKF90aGlzLCBcImFueU5ldHdvcmtcIiwgKG5ldHdvcmsgPT09IFwiYW55XCIpKTtcblx0ICAgICAgICBpZiAoX3RoaXMuYW55TmV0d29yaykge1xuXHQgICAgICAgICAgICBuZXR3b3JrID0gX3RoaXMuZGV0ZWN0TmV0d29yaygpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBpZiAobmV0d29yayBpbnN0YW5jZW9mIFByb21pc2UpIHtcblx0ICAgICAgICAgICAgX3RoaXMuX25ldHdvcmtQcm9taXNlID0gbmV0d29yaztcblx0ICAgICAgICAgICAgLy8gU3F1YXNoIGFueSBcInVuaGFuZGxlZCBwcm9taXNlXCIgZXJyb3JzOyB0aGF0IGRvIG5vdCBuZWVkIHRvIGJlIGhhbmRsZWRcblx0ICAgICAgICAgICAgbmV0d29yay5jYXRjaChmdW5jdGlvbiAoZXJyb3IpIHsgfSk7XG5cdCAgICAgICAgICAgIC8vIFRyaWdnZXIgaW5pdGlhbCBuZXR3b3JrIHNldHRpbmcgKGFzeW5jKVxuXHQgICAgICAgICAgICBfdGhpcy5fcmVhZHkoKS5jYXRjaChmdW5jdGlvbiAoZXJyb3IpIHsgfSk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGVsc2Uge1xuXHQgICAgICAgICAgICB2YXIga25vd25OZXR3b3JrID0gKDAsIGxpYiQzLmdldFN0YXRpYykoX25ld1RhcmdldCwgXCJnZXROZXR3b3JrXCIpKG5ldHdvcmspO1xuXHQgICAgICAgICAgICBpZiAoa25vd25OZXR3b3JrKSB7XG5cdCAgICAgICAgICAgICAgICAoMCwgbGliJDMuZGVmaW5lUmVhZE9ubHkpKF90aGlzLCBcIl9uZXR3b3JrXCIsIGtub3duTmV0d29yayk7XG5cdCAgICAgICAgICAgICAgICBfdGhpcy5lbWl0KFwibmV0d29ya1wiLCBrbm93bk5ldHdvcmssIG51bGwpO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIGVsc2Uge1xuXHQgICAgICAgICAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcImludmFsaWQgbmV0d29ya1wiLCBcIm5ldHdvcmtcIiwgbmV0d29yayk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9XG5cdCAgICAgICAgX3RoaXMuX21heEludGVybmFsQmxvY2tOdW1iZXIgPSAtMTAyNDtcblx0ICAgICAgICBfdGhpcy5fbGFzdEJsb2NrTnVtYmVyID0gLTI7XG5cdCAgICAgICAgX3RoaXMuX3BvbGxpbmdJbnRlcnZhbCA9IDQwMDA7XG5cdCAgICAgICAgX3RoaXMuX2Zhc3RRdWVyeURhdGUgPSAwO1xuXHQgICAgICAgIHJldHVybiBfdGhpcztcblx0ICAgIH1cblx0ICAgIEJhc2VQcm92aWRlci5wcm90b3R5cGUuX3JlYWR5ID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgdmFyIG5ldHdvcmssIGVycm9yXzQ7XG5cdCAgICAgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcblx0ICAgICAgICAgICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcblx0ICAgICAgICAgICAgICAgICAgICBjYXNlIDA6XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGlmICghKHRoaXMuX25ldHdvcmsgPT0gbnVsbCkpIHJldHVybiBbMyAvKmJyZWFrKi8sIDddO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBuZXR3b3JrID0gbnVsbDtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCF0aGlzLl9uZXR3b3JrUHJvbWlzZSkgcmV0dXJuIFszIC8qYnJlYWsqLywgNF07XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIF9hLmxhYmVsID0gMTtcblx0ICAgICAgICAgICAgICAgICAgICBjYXNlIDE6XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIF9hLnRyeXMucHVzaChbMSwgMywgLCA0XSk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIHRoaXMuX25ldHdvcmtQcm9taXNlXTtcblx0ICAgICAgICAgICAgICAgICAgICBjYXNlIDI6XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIG5ldHdvcmsgPSBfYS5zZW50KCk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMyAvKmJyZWFrKi8sIDRdO1xuXHQgICAgICAgICAgICAgICAgICAgIGNhc2UgMzpcblx0ICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3JfNCA9IF9hLnNlbnQoKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFszIC8qYnJlYWsqLywgNF07XG5cdCAgICAgICAgICAgICAgICAgICAgY2FzZSA0OlxuXHQgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIShuZXR3b3JrID09IG51bGwpKSByZXR1cm4gWzMgLypicmVhayovLCA2XTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgdGhpcy5kZXRlY3ROZXR3b3JrKCldO1xuXHQgICAgICAgICAgICAgICAgICAgIGNhc2UgNTpcblx0ICAgICAgICAgICAgICAgICAgICAgICAgbmV0d29yayA9IF9hLnNlbnQoKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgX2EubGFiZWwgPSA2O1xuXHQgICAgICAgICAgICAgICAgICAgIGNhc2UgNjpcblx0ICAgICAgICAgICAgICAgICAgICAgICAgLy8gVGhpcyBzaG91bGQgbmV2ZXIgaGFwcGVuOyBldmVyeSBQcm92aWRlciBzdWItY2xhc3Mgc2hvdWxkIGhhdmVcblx0ICAgICAgICAgICAgICAgICAgICAgICAgLy8gc3VnZ2VzdGVkIGEgbmV0d29yayBieSBoZXJlIChvciBoYXZlIHRocm93bikuXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGlmICghbmV0d29yaykge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgbG9nZ2VyLnRocm93RXJyb3IoXCJubyBuZXR3b3JrIGRldGVjdGVkXCIsIGxpYi5Mb2dnZXIuZXJyb3JzLlVOS05PV05fRVJST1IsIHt9KTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgICAgICAvLyBQb3NzaWJsZSB0aGlzIGNhbGwgc3RhY2tlZCBzbyBkbyBub3QgY2FsbCBkZWZpbmVSZWFkT25seSBhZ2FpblxuXHQgICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5fbmV0d29yayA9PSBudWxsKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5hbnlOZXR3b3JrKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fbmV0d29yayA9IG5ldHdvcms7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoMCwgbGliJDMuZGVmaW5lUmVhZE9ubHkpKHRoaXMsIFwiX25ldHdvcmtcIiwgbmV0d29yayk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmVtaXQoXCJuZXR3b3JrXCIsIG5ldHdvcmssIG51bGwpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIF9hLmxhYmVsID0gNztcblx0ICAgICAgICAgICAgICAgICAgICBjYXNlIDc6IHJldHVybiBbMiAvKnJldHVybiovLCB0aGlzLl9uZXR3b3JrXTtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgfSk7XG5cdCAgICB9O1xuXHQgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEJhc2VQcm92aWRlci5wcm90b3R5cGUsIFwicmVhZHlcIiwge1xuXHQgICAgICAgIC8vIFRoaXMgd2lsbCBhbHdheXMgcmV0dXJuIHRoZSBtb3N0IHJlY2VudGx5IGVzdGFibGlzaGVkIG5ldHdvcmsuXG5cdCAgICAgICAgLy8gRm9yIFwiYW55XCIsIHRoaXMgY2FuIGNoYW5nZSAoYSBcIm5ldHdvcmtcIiBldmVudCBpcyBlbWl0dGVkIGJlZm9yZVxuXHQgICAgICAgIC8vIGFueSBjaGFuZ2UgaXMgcmVmbGVjdGVkKTsgb3RoZXJ3aXNlIHRoaXMgY2Fubm90IGNoYW5nZVxuXHQgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXHQgICAgICAgICAgICByZXR1cm4gKDAsIGxpYiRxLnBvbGwpKGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgICAgIHJldHVybiBfdGhpcy5fcmVhZHkoKS50aGVuKGZ1bmN0aW9uIChuZXR3b3JrKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldHdvcms7XG5cdCAgICAgICAgICAgICAgICB9LCBmdW5jdGlvbiAoZXJyb3IpIHtcblx0ICAgICAgICAgICAgICAgICAgICAvLyBJZiB0aGUgbmV0d29yayBpc24ndCBydW5uaW5nIHlldCwgd2Ugd2lsbCB3YWl0XG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKGVycm9yLmNvZGUgPT09IGxpYi5Mb2dnZXIuZXJyb3JzLk5FVFdPUktfRVJST1IgJiYgZXJyb3IuZXZlbnQgPT09IFwibm9OZXR3b3JrXCIpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcblx0ICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG5cdCAgICAgICAgICAgICAgICB9KTtcblx0ICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgfSxcblx0ICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcblx0ICAgICAgICBjb25maWd1cmFibGU6IHRydWVcblx0ICAgIH0pO1xuXHQgICAgLy8gQFRPRE86IFJlbW92ZSB0aGlzIGFuZCBqdXN0IGNyZWF0ZSBhIHNpbmdsZXRvbiBmb3JtYXR0ZXJcblx0ICAgIEJhc2VQcm92aWRlci5nZXRGb3JtYXR0ZXIgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgaWYgKGRlZmF1bHRGb3JtYXR0ZXIgPT0gbnVsbCkge1xuXHQgICAgICAgICAgICBkZWZhdWx0Rm9ybWF0dGVyID0gbmV3IGZvcm1hdHRlci5Gb3JtYXR0ZXIoKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgcmV0dXJuIGRlZmF1bHRGb3JtYXR0ZXI7XG5cdCAgICB9O1xuXHQgICAgLy8gQFRPRE86IFJlbW92ZSB0aGlzIGFuZCBqdXN0IHVzZSBnZXROZXR3b3JrXG5cdCAgICBCYXNlUHJvdmlkZXIuZ2V0TmV0d29yayA9IGZ1bmN0aW9uIChuZXR3b3JrKSB7XG5cdCAgICAgICAgcmV0dXJuICgwLCBsaWIkby5nZXROZXR3b3JrKSgobmV0d29yayA9PSBudWxsKSA/IFwiaG9tZXN0ZWFkXCIgOiBuZXR3b3JrKTtcblx0ICAgIH07XG5cdCAgICAvLyBGZXRjaGVzIHRoZSBibG9ja051bWJlciwgYnV0IHdpbGwgcmV1c2UgYW55IHJlc3VsdCB0aGF0IGlzIGxlc3Ncblx0ICAgIC8vIHRoYW4gbWF4QWdlIG9sZCBvciBoYXMgYmVlbiByZXF1ZXN0ZWQgc2luY2UgdGhlIGxhc3QgcmVxdWVzdFxuXHQgICAgQmFzZVByb3ZpZGVyLnByb3RvdHlwZS5fZ2V0SW50ZXJuYWxCbG9ja051bWJlciA9IGZ1bmN0aW9uIChtYXhBZ2UpIHtcblx0ICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIHZhciBpbnRlcm5hbEJsb2NrTnVtYmVyLCByZXN1bHQsIGVycm9yXzUsIHJlcVRpbWUsIGNoZWNrSW50ZXJuYWxCbG9ja051bWJlcjtcblx0ICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcblx0ICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuXHQgICAgICAgICAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkge1xuXHQgICAgICAgICAgICAgICAgICAgIGNhc2UgMDogcmV0dXJuIFs0IC8qeWllbGQqLywgdGhpcy5fcmVhZHkoKV07XG5cdCAgICAgICAgICAgICAgICAgICAgY2FzZSAxOlxuXHQgICAgICAgICAgICAgICAgICAgICAgICBfYS5zZW50KCk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGlmICghKG1heEFnZSA+IDApKSByZXR1cm4gWzMgLypicmVhayovLCA3XTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgX2EubGFiZWwgPSAyO1xuXHQgICAgICAgICAgICAgICAgICAgIGNhc2UgMjpcblx0ICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCF0aGlzLl9pbnRlcm5hbEJsb2NrTnVtYmVyKSByZXR1cm4gWzMgLypicmVhayovLCA3XTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgaW50ZXJuYWxCbG9ja051bWJlciA9IHRoaXMuX2ludGVybmFsQmxvY2tOdW1iZXI7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIF9hLmxhYmVsID0gMztcblx0ICAgICAgICAgICAgICAgICAgICBjYXNlIDM6XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIF9hLnRyeXMucHVzaChbMywgNSwgLCA2XSk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIGludGVybmFsQmxvY2tOdW1iZXJdO1xuXHQgICAgICAgICAgICAgICAgICAgIGNhc2UgNDpcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gX2Euc2VudCgpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBpZiAoKGdldFRpbWUoKSAtIHJlc3VsdC5yZXNwVGltZSkgPD0gbWF4QWdlKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgcmVzdWx0LmJsb2NrTnVtYmVyXTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgICAgICAvLyBUb28gb2xkOyBmZXRjaCBhIG5ldyB2YWx1ZVxuXHQgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzMgLypicmVhayovLCA3XTtcblx0ICAgICAgICAgICAgICAgICAgICBjYXNlIDU6XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yXzUgPSBfYS5zZW50KCk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRoZSBmZXRjaCByZWplY3RlZDsgaWYgd2UgYXJlIHRoZSBmaXJzdCB0byBnZXQgdGhlXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIC8vIHJlamVjdGlvbiwgZHJvcCB0aHJvdWdoIHNvIHdlIHJlcGxhY2UgaXQgd2l0aCBhIG5ld1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAvLyBmZXRjaDsgYWxsIG90aGVycyBibG9ja2VkIHdpbGwgdGhlbiBnZXQgdGhhdCBmZXRjaFxuXHQgICAgICAgICAgICAgICAgICAgICAgICAvLyB3aGljaCB3b24ndCBtYXRjaCB0aGUgb25lIHRoZXkgXCJyZW1lbWJlcmVkXCIgYW5kIGxvb3Bcblx0ICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuX2ludGVybmFsQmxvY2tOdW1iZXIgPT09IGludGVybmFsQmxvY2tOdW1iZXIpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMyAvKmJyZWFrKi8sIDddO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMyAvKmJyZWFrKi8sIDZdO1xuXHQgICAgICAgICAgICAgICAgICAgIGNhc2UgNjogcmV0dXJuIFszIC8qYnJlYWsqLywgMl07XG5cdCAgICAgICAgICAgICAgICAgICAgY2FzZSA3OlxuXHQgICAgICAgICAgICAgICAgICAgICAgICByZXFUaW1lID0gZ2V0VGltZSgpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBjaGVja0ludGVybmFsQmxvY2tOdW1iZXIgPSAoMCwgbGliJDMucmVzb2x2ZVByb3BlcnRpZXMpKHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJsb2NrTnVtYmVyOiB0aGlzLnBlcmZvcm0oXCJnZXRCbG9ja051bWJlclwiLCB7fSksXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXR3b3JrRXJyb3I6IHRoaXMuZ2V0TmV0d29yaygpLnRoZW4oZnVuY3Rpb24gKG5ldHdvcmspIHsgcmV0dXJuIChudWxsKTsgfSwgZnVuY3Rpb24gKGVycm9yKSB7IHJldHVybiAoZXJyb3IpOyB9KVxuXHQgICAgICAgICAgICAgICAgICAgICAgICB9KS50aGVuKGZ1bmN0aW9uIChfYSkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGJsb2NrTnVtYmVyID0gX2EuYmxvY2tOdW1iZXIsIG5ldHdvcmtFcnJvciA9IF9hLm5ldHdvcmtFcnJvcjtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChuZXR3b3JrRXJyb3IpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBVbnJlbWVtYmVyIHRoaXMgYmFkIGludGVybmFsIGJsb2NrIG51bWJlclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChfdGhpcy5faW50ZXJuYWxCbG9ja051bWJlciA9PT0gY2hlY2tJbnRlcm5hbEJsb2NrTnVtYmVyKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLl9pbnRlcm5hbEJsb2NrTnVtYmVyID0gbnVsbDtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV0d29ya0Vycm9yO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHJlc3BUaW1lID0gZ2V0VGltZSgpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgYmxvY2tOdW1iZXIgPSBsaWIkMi5CaWdOdW1iZXIuZnJvbShibG9ja051bWJlcikudG9OdW1iZXIoKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChibG9ja051bWJlciA8IF90aGlzLl9tYXhJbnRlcm5hbEJsb2NrTnVtYmVyKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYmxvY2tOdW1iZXIgPSBfdGhpcy5fbWF4SW50ZXJuYWxCbG9ja051bWJlcjtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLl9tYXhJbnRlcm5hbEJsb2NrTnVtYmVyID0gYmxvY2tOdW1iZXI7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5fc2V0RmFzdEJsb2NrTnVtYmVyKGJsb2NrTnVtYmVyKTsgLy8gQFRPRE86IFN0aWxsIG5lZWQgdGhpcz9cblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7IGJsb2NrTnVtYmVyOiBibG9ja051bWJlciwgcmVxVGltZTogcmVxVGltZSwgcmVzcFRpbWU6IHJlc3BUaW1lIH07XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9pbnRlcm5hbEJsb2NrTnVtYmVyID0gY2hlY2tJbnRlcm5hbEJsb2NrTnVtYmVyO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAvLyBTd2FsbG93IHVuaGFuZGxlZCBleGNlcHRpb25zOyBpZiBuZWVkZWQgdGhleSBhcmUgaGFuZGxlZCBlbHNlIHdoZXJlXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGNoZWNrSW50ZXJuYWxCbG9ja051bWJlci5jYXRjaChmdW5jdGlvbiAoZXJyb3IpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIERvbid0IG51bGwgdGhlIGRlYWQgKHJlamVjdGVkKSBmZXRjaCwgaWYgaXQgaGFzIGFscmVhZHkgYmVlbiB1cGRhdGVkXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoX3RoaXMuX2ludGVybmFsQmxvY2tOdW1iZXIgPT09IGNoZWNrSW50ZXJuYWxCbG9ja051bWJlcikge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLl9pbnRlcm5hbEJsb2NrTnVtYmVyID0gbnVsbDtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIGNoZWNrSW50ZXJuYWxCbG9ja051bWJlcl07XG5cdCAgICAgICAgICAgICAgICAgICAgY2FzZSA4OiByZXR1cm4gWzIgLypyZXR1cm4qLywgKF9hLnNlbnQoKSkuYmxvY2tOdW1iZXJdO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB9KTtcblx0ICAgICAgICB9KTtcblx0ICAgIH07XG5cdCAgICBCYXNlUHJvdmlkZXIucHJvdG90eXBlLnBvbGwgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICB2YXIgcG9sbElkLCBydW5uZXJzLCBibG9ja051bWJlciwgZXJyb3JfNiwgaTtcblx0ICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcblx0ICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuXHQgICAgICAgICAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkge1xuXHQgICAgICAgICAgICAgICAgICAgIGNhc2UgMDpcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcG9sbElkID0gbmV4dFBvbGxJZCsrO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBydW5uZXJzID0gW107XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGJsb2NrTnVtYmVyID0gbnVsbDtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgX2EubGFiZWwgPSAxO1xuXHQgICAgICAgICAgICAgICAgICAgIGNhc2UgMTpcblx0ICAgICAgICAgICAgICAgICAgICAgICAgX2EudHJ5cy5wdXNoKFsxLCAzLCAsIDRdKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgdGhpcy5fZ2V0SW50ZXJuYWxCbG9ja051bWJlcigxMDAgKyB0aGlzLnBvbGxpbmdJbnRlcnZhbCAvIDIpXTtcblx0ICAgICAgICAgICAgICAgICAgICBjYXNlIDI6XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGJsb2NrTnVtYmVyID0gX2Euc2VudCgpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzMgLypicmVhayovLCA0XTtcblx0ICAgICAgICAgICAgICAgICAgICBjYXNlIDM6XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yXzYgPSBfYS5zZW50KCk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZW1pdChcImVycm9yXCIsIGVycm9yXzYpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qL107XG5cdCAgICAgICAgICAgICAgICAgICAgY2FzZSA0OlxuXHQgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9zZXRGYXN0QmxvY2tOdW1iZXIoYmxvY2tOdW1iZXIpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAvLyBFbWl0IGEgcG9sbCBldmVudCBhZnRlciB3ZSBoYXZlIHRoZSBsYXRlc3QgKGZhc3QpIGJsb2NrIG51bWJlclxuXHQgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmVtaXQoXCJwb2xsXCIsIHBvbGxJZCwgYmxvY2tOdW1iZXIpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAvLyBJZiB0aGUgYmxvY2sgaGFzIG5vdCBjaGFuZ2VkLCBtZWguXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGlmIChibG9ja051bWJlciA9PT0gdGhpcy5fbGFzdEJsb2NrTnVtYmVyKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmVtaXQoXCJkaWRQb2xsXCIsIHBvbGxJZCk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qL107XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICAgICAgLy8gRmlyc3QgcG9sbGluZyBjeWNsZSwgdHJpZ2dlciBhIFwiYmxvY2tcIiBldmVudHNcblx0ICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuX2VtaXR0ZWQuYmxvY2sgPT09IC0yKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9lbWl0dGVkLmJsb2NrID0gYmxvY2tOdW1iZXIgLSAxO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGlmIChNYXRoLmFicygodGhpcy5fZW1pdHRlZC5ibG9jaykgLSBibG9ja051bWJlcikgPiAxMDAwKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBsb2dnZXIud2FybihcIm5ldHdvcmsgYmxvY2sgc2tldyBkZXRlY3RlZDsgc2tpcHBpbmcgYmxvY2sgZXZlbnRzIChlbWl0dGVkPVwiICsgdGhpcy5fZW1pdHRlZC5ibG9jayArIFwiIGJsb2NrTnVtYmVyXCIgKyBibG9ja051bWJlciArIFwiKVwiKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZW1pdChcImVycm9yXCIsIGxvZ2dlci5tYWtlRXJyb3IoXCJuZXR3b3JrIGJsb2NrIHNrZXcgZGV0ZWN0ZWRcIiwgbGliLkxvZ2dlci5lcnJvcnMuTkVUV09SS19FUlJPUiwge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJsb2NrTnVtYmVyOiBibG9ja051bWJlcixcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBldmVudDogXCJibG9ja1NrZXdcIixcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcmV2aW91c0Jsb2NrTnVtYmVyOiB0aGlzLl9lbWl0dGVkLmJsb2NrXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KSk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmVtaXQoXCJibG9ja1wiLCBibG9ja051bWJlcik7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBOb3RpZnkgYWxsIGxpc3RlbmVyIGZvciBlYWNoIGJsb2NrIHRoYXQgaGFzIHBhc3NlZFxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChpID0gdGhpcy5fZW1pdHRlZC5ibG9jayArIDE7IGkgPD0gYmxvY2tOdW1iZXI7IGkrKykge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZW1pdChcImJsb2NrXCIsIGkpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRoZSBlbWl0dGVkIGJsb2NrIHdhcyB1cGRhdGVkLCBjaGVjayBmb3Igb2Jzb2xldGUgZXZlbnRzXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLl9lbWl0dGVkLmJsb2NrICE9PSBibG9ja051bWJlcikge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fZW1pdHRlZC5ibG9jayA9IGJsb2NrTnVtYmVyO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgT2JqZWN0LmtleXModGhpcy5fZW1pdHRlZCkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gVGhlIGJsb2NrIGV2ZW50IGRvZXMgbm90IGV4cGlyZVxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChrZXkgPT09IFwiYmxvY2tcIikge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRoZSBibG9jayB3ZSB3ZXJlIGF0IHdoZW4gd2UgZW1pdHRlZCB0aGlzIGV2ZW50XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGV2ZW50QmxvY2tOdW1iZXIgPSBfdGhpcy5fZW1pdHRlZFtrZXldO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFdlIGNhbm5vdCBnYXJiYWdlIGNvbGxlY3QgcGVuZGluZyB0cmFuc2FjdGlvbnMgb3IgYmxvY2tzIGhlcmVcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBUaGV5IHNob3VsZCBiZSBnYXJiYWdlIGNvbGxlY3RlZCBieSB0aGUgUHJvdmlkZXIgd2hlbiBzZXR0aW5nXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gXCJwZW5kaW5nXCIgZXZlbnRzXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGV2ZW50QmxvY2tOdW1iZXIgPT09IFwicGVuZGluZ1wiKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gRXZpY3QgYW55IHRyYW5zYWN0aW9uIGhhc2hlcyBvciBibG9jayBoYXNoZXMgb3ZlciAxMiBibG9ja3Ncblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBvbGQsIHNpbmNlIHRoZXkgc2hvdWxkIG5vdCByZXR1cm4gbnVsbCBhbnl3YXlzXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGJsb2NrTnVtYmVyIC0gZXZlbnRCbG9ja051bWJlciA+IDEyKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBfdGhpcy5fZW1pdHRlZFtrZXldO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIC8vIEZpcnN0IHBvbGxpbmcgY3ljbGVcblx0ICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuX2xhc3RCbG9ja051bWJlciA9PT0gLTIpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2xhc3RCbG9ja051bWJlciA9IGJsb2NrTnVtYmVyIC0gMTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgICAgICAvLyBGaW5kIGFsbCB0cmFuc2FjdGlvbiBoYXNoZXMgd2UgYXJlIHdhaXRpbmcgb25cblx0ICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fZXZlbnRzLmZvckVhY2goZnVuY3Rpb24gKGV2ZW50KSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKGV2ZW50LnR5cGUpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwidHhcIjoge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgaGFzaF8yID0gZXZlbnQuaGFzaDtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHJ1bm5lciA9IF90aGlzLmdldFRyYW5zYWN0aW9uUmVjZWlwdChoYXNoXzIpLnRoZW4oZnVuY3Rpb24gKHJlY2VpcHQpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghcmVjZWlwdCB8fCByZWNlaXB0LmJsb2NrTnVtYmVyID09IG51bGwpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLl9lbWl0dGVkW1widDpcIiArIGhhc2hfMl0gPSByZWNlaXB0LmJsb2NrTnVtYmVyO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuZW1pdChoYXNoXzIsIHJlY2VpcHQpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pLmNhdGNoKGZ1bmN0aW9uIChlcnJvcikgeyBfdGhpcy5lbWl0KFwiZXJyb3JcIiwgZXJyb3IpOyB9KTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcnVubmVycy5wdXNoKHJ1bm5lcik7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwiZmlsdGVyXCI6IHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGZpbHRlcl8xID0gZXZlbnQuZmlsdGVyO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmaWx0ZXJfMS5mcm9tQmxvY2sgPSBfdGhpcy5fbGFzdEJsb2NrTnVtYmVyICsgMTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZmlsdGVyXzEudG9CbG9jayA9IGJsb2NrTnVtYmVyO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcnVubmVyID0gX3RoaXMuZ2V0TG9ncyhmaWx0ZXJfMSkudGhlbihmdW5jdGlvbiAobG9ncykge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGxvZ3MubGVuZ3RoID09PSAwKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbG9ncy5mb3JFYWNoKGZ1bmN0aW9uIChsb2cpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5fZW1pdHRlZFtcImI6XCIgKyBsb2cuYmxvY2tIYXNoXSA9IGxvZy5ibG9ja051bWJlcjtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5fZW1pdHRlZFtcInQ6XCIgKyBsb2cudHJhbnNhY3Rpb25IYXNoXSA9IGxvZy5ibG9ja051bWJlcjtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5lbWl0KGZpbHRlcl8xLCBsb2cpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pLmNhdGNoKGZ1bmN0aW9uIChlcnJvcikgeyBfdGhpcy5lbWl0KFwiZXJyb3JcIiwgZXJyb3IpOyB9KTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcnVubmVycy5wdXNoKHJ1bm5lcik7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2xhc3RCbG9ja051bWJlciA9IGJsb2NrTnVtYmVyO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAvLyBPbmNlIGFsbCBldmVudHMgZm9yIHRoaXMgbG9vcCBoYXZlIGJlZW4gcHJvY2Vzc2VkLCBlbWl0IFwiZGlkUG9sbFwiXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIFByb21pc2UuYWxsKHJ1bm5lcnMpLnRoZW4oZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuZW1pdChcImRpZFBvbGxcIiwgcG9sbElkKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfSkuY2F0Y2goZnVuY3Rpb24gKGVycm9yKSB7IF90aGlzLmVtaXQoXCJlcnJvclwiLCBlcnJvcik7IH0pO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qL107XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIH0pO1xuXHQgICAgICAgIH0pO1xuXHQgICAgfTtcblx0ICAgIC8vIERlcHJlY2F0ZWQ7IGRvIG5vdCB1c2UgdGhpc1xuXHQgICAgQmFzZVByb3ZpZGVyLnByb3RvdHlwZS5yZXNldEV2ZW50c0Jsb2NrID0gZnVuY3Rpb24gKGJsb2NrTnVtYmVyKSB7XG5cdCAgICAgICAgdGhpcy5fbGFzdEJsb2NrTnVtYmVyID0gYmxvY2tOdW1iZXIgLSAxO1xuXHQgICAgICAgIGlmICh0aGlzLnBvbGxpbmcpIHtcblx0ICAgICAgICAgICAgdGhpcy5wb2xsKCk7XG5cdCAgICAgICAgfVxuXHQgICAgfTtcblx0ICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShCYXNlUHJvdmlkZXIucHJvdG90eXBlLCBcIm5ldHdvcmtcIiwge1xuXHQgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICByZXR1cm4gdGhpcy5fbmV0d29yaztcblx0ICAgICAgICB9LFxuXHQgICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuXHQgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuXHQgICAgfSk7XG5cdCAgICAvLyBUaGlzIG1ldGhvZCBzaG91bGQgcXVlcnkgdGhlIG5ldHdvcmsgaWYgdGhlIHVuZGVybHlpbmcgbmV0d29ya1xuXHQgICAgLy8gY2FuIGNoYW5nZSwgc3VjaCBhcyB3aGVuIGNvbm5lY3RlZCB0byBhIEpTT04tUlBDIGJhY2tlbmRcblx0ICAgIEJhc2VQcm92aWRlci5wcm90b3R5cGUuZGV0ZWN0TmV0d29yayA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcblx0ICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCBsb2dnZXIudGhyb3dFcnJvcihcInByb3ZpZGVyIGRvZXMgbm90IHN1cHBvcnQgbmV0d29yayBkZXRlY3Rpb25cIiwgbGliLkxvZ2dlci5lcnJvcnMuVU5TVVBQT1JURURfT1BFUkFUSU9OLCB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIG9wZXJhdGlvbjogXCJwcm92aWRlci5kZXRlY3ROZXR3b3JrXCJcblx0ICAgICAgICAgICAgICAgICAgICB9KV07XG5cdCAgICAgICAgICAgIH0pO1xuXHQgICAgICAgIH0pO1xuXHQgICAgfTtcblx0ICAgIEJhc2VQcm92aWRlci5wcm90b3R5cGUuZ2V0TmV0d29yayA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIHZhciBuZXR3b3JrLCBjdXJyZW50TmV0d29yaywgZXJyb3I7XG5cdCAgICAgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcblx0ICAgICAgICAgICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcblx0ICAgICAgICAgICAgICAgICAgICBjYXNlIDA6IHJldHVybiBbNCAvKnlpZWxkKi8sIHRoaXMuX3JlYWR5KCldO1xuXHQgICAgICAgICAgICAgICAgICAgIGNhc2UgMTpcblx0ICAgICAgICAgICAgICAgICAgICAgICAgbmV0d29yayA9IF9hLnNlbnQoKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgdGhpcy5kZXRlY3ROZXR3b3JrKCldO1xuXHQgICAgICAgICAgICAgICAgICAgIGNhc2UgMjpcblx0ICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudE5ldHdvcmsgPSBfYS5zZW50KCk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGlmICghKG5ldHdvcmsuY2hhaW5JZCAhPT0gY3VycmVudE5ldHdvcmsuY2hhaW5JZCkpIHJldHVybiBbMyAvKmJyZWFrKi8sIDVdO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXRoaXMuYW55TmV0d29yaykgcmV0dXJuIFszIC8qYnJlYWsqLywgNF07XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX25ldHdvcmsgPSBjdXJyZW50TmV0d29yaztcblx0ICAgICAgICAgICAgICAgICAgICAgICAgLy8gUmVzZXQgYWxsIGludGVybmFsIGJsb2NrIG51bWJlciBndWFyZHMgYW5kIGNhY2hlc1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9sYXN0QmxvY2tOdW1iZXIgPSAtMjtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fZmFzdEJsb2NrTnVtYmVyID0gbnVsbDtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fZmFzdEJsb2NrTnVtYmVyUHJvbWlzZSA9IG51bGw7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2Zhc3RRdWVyeURhdGUgPSAwO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9lbWl0dGVkLmJsb2NrID0gLTI7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX21heEludGVybmFsQmxvY2tOdW1iZXIgPSAtMTAyNDtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5faW50ZXJuYWxCbG9ja051bWJlciA9IG51bGw7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRoZSBcIm5ldHdvcmtcIiBldmVudCBNVVNUIGhhcHBlbiBiZWZvcmUgdGhpcyBtZXRob2QgcmVzb2x2ZXNcblx0ICAgICAgICAgICAgICAgICAgICAgICAgLy8gc28gYW55IGV2ZW50cyBoYXZlIGEgY2hhbmNlIHRvIHVucmVnaXN0ZXIsIHNvIHdlIHN0YWxsIGFuXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIC8vIGFkZGl0aW9uYWwgZXZlbnQgbG9vcCBiZWZvcmUgcmV0dXJuaW5nIGZyb20gL3RoaXMvIGNhbGxcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5lbWl0KFwibmV0d29ya1wiLCBjdXJyZW50TmV0d29yaywgbmV0d29yayk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIHN0YWxsKDApXTtcblx0ICAgICAgICAgICAgICAgICAgICBjYXNlIDM6XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIF9hLnNlbnQoKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIHRoaXMuX25ldHdvcmtdO1xuXHQgICAgICAgICAgICAgICAgICAgIGNhc2UgNDpcblx0ICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3IgPSBsb2dnZXIubWFrZUVycm9yKFwidW5kZXJseWluZyBuZXR3b3JrIGNoYW5nZWRcIiwgbGliLkxvZ2dlci5lcnJvcnMuTkVUV09SS19FUlJPUiwge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXZlbnQ6IFwiY2hhbmdlZFwiLFxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV0d29yazogbmV0d29yayxcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRldGVjdGVkTmV0d29yazogY3VycmVudE5ldHdvcmtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZW1pdChcImVycm9yXCIsIGVycm9yKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG5cdCAgICAgICAgICAgICAgICAgICAgY2FzZSA1OiByZXR1cm4gWzIgLypyZXR1cm4qLywgbmV0d29ya107XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIH0pO1xuXHQgICAgICAgIH0pO1xuXHQgICAgfTtcblx0ICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShCYXNlUHJvdmlkZXIucHJvdG90eXBlLCBcImJsb2NrTnVtYmVyXCIsIHtcblx0ICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcblx0ICAgICAgICAgICAgdGhpcy5fZ2V0SW50ZXJuYWxCbG9ja051bWJlcigxMDAgKyB0aGlzLnBvbGxpbmdJbnRlcnZhbCAvIDIpLnRoZW4oZnVuY3Rpb24gKGJsb2NrTnVtYmVyKSB7XG5cdCAgICAgICAgICAgICAgICBfdGhpcy5fc2V0RmFzdEJsb2NrTnVtYmVyKGJsb2NrTnVtYmVyKTtcblx0ICAgICAgICAgICAgfSwgZnVuY3Rpb24gKGVycm9yKSB7IH0pO1xuXHQgICAgICAgICAgICByZXR1cm4gKHRoaXMuX2Zhc3RCbG9ja051bWJlciAhPSBudWxsKSA/IHRoaXMuX2Zhc3RCbG9ja051bWJlciA6IC0xO1xuXHQgICAgICAgIH0sXG5cdCAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG5cdCAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG5cdCAgICB9KTtcblx0ICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShCYXNlUHJvdmlkZXIucHJvdG90eXBlLCBcInBvbGxpbmdcIiwge1xuXHQgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICByZXR1cm4gKHRoaXMuX3BvbGxlciAhPSBudWxsKTtcblx0ICAgICAgICB9LFxuXHQgICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKSB7XG5cdCAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cdCAgICAgICAgICAgIGlmICh2YWx1ZSAmJiAhdGhpcy5fcG9sbGVyKSB7XG5cdCAgICAgICAgICAgICAgICB0aGlzLl9wb2xsZXIgPSBzZXRJbnRlcnZhbChmdW5jdGlvbiAoKSB7IF90aGlzLnBvbGwoKTsgfSwgdGhpcy5wb2xsaW5nSW50ZXJ2YWwpO1xuXHQgICAgICAgICAgICAgICAgaWYgKCF0aGlzLl9ib290c3RyYXBQb2xsKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgdGhpcy5fYm9vdHN0cmFwUG9sbCA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5wb2xsKCk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIC8vIFdlIGJsb2NrIGFkZGl0aW9uYWwgcG9sbHMgdW50aWwgdGhlIHBvbGxpbmcgaW50ZXJ2YWxcblx0ICAgICAgICAgICAgICAgICAgICAgICAgLy8gaXMgZG9uZSwgdG8gcHJldmVudCBvdmVyd2hlbG1pbmcgdGhlIHBvbGwgZnVuY3Rpb25cblx0ICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuX2Jvb3RzdHJhcFBvbGwgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIElmIHBvbGxpbmcgd2FzIGRpc2FibGVkLCBzb21ldGhpbmcgbWF5IHJlcXVpcmUgYSBwb2tlXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBzaW5jZSBzdGFydGluZyB0aGUgYm9vdHN0cmFwIHBvbGwgYW5kIGl0IHdhcyBkaXNhYmxlZFxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFfdGhpcy5fcG9sbGVyKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMucG9sbCgpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gQ2xlYXIgb3V0IHRoZSBib290c3RyYXAgc28gd2UgY2FuIGRvIGFub3RoZXJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLl9ib290c3RyYXBQb2xsID0gbnVsbDtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfSwgX3RoaXMucG9sbGluZ0ludGVydmFsKTtcblx0ICAgICAgICAgICAgICAgICAgICB9LCAwKTtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICBlbHNlIGlmICghdmFsdWUgJiYgdGhpcy5fcG9sbGVyKSB7XG5cdCAgICAgICAgICAgICAgICBjbGVhckludGVydmFsKHRoaXMuX3BvbGxlcik7XG5cdCAgICAgICAgICAgICAgICB0aGlzLl9wb2xsZXIgPSBudWxsO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfSxcblx0ICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcblx0ICAgICAgICBjb25maWd1cmFibGU6IHRydWVcblx0ICAgIH0pO1xuXHQgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEJhc2VQcm92aWRlci5wcm90b3R5cGUsIFwicG9sbGluZ0ludGVydmFsXCIsIHtcblx0ICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3BvbGxpbmdJbnRlcnZhbDtcblx0ICAgICAgICB9LFxuXHQgICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKSB7XG5cdCAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cdCAgICAgICAgICAgIGlmICh0eXBlb2YgKHZhbHVlKSAhPT0gXCJudW1iZXJcIiB8fCB2YWx1ZSA8PSAwIHx8IHBhcnNlSW50KFN0cmluZyh2YWx1ZSkpICE9IHZhbHVlKSB7XG5cdCAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIHBvbGxpbmcgaW50ZXJ2YWxcIik7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgdGhpcy5fcG9sbGluZ0ludGVydmFsID0gdmFsdWU7XG5cdCAgICAgICAgICAgIGlmICh0aGlzLl9wb2xsZXIpIHtcblx0ICAgICAgICAgICAgICAgIGNsZWFySW50ZXJ2YWwodGhpcy5fcG9sbGVyKTtcblx0ICAgICAgICAgICAgICAgIHRoaXMuX3BvbGxlciA9IHNldEludGVydmFsKGZ1bmN0aW9uICgpIHsgX3RoaXMucG9sbCgpOyB9LCB0aGlzLl9wb2xsaW5nSW50ZXJ2YWwpO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfSxcblx0ICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcblx0ICAgICAgICBjb25maWd1cmFibGU6IHRydWVcblx0ICAgIH0pO1xuXHQgICAgQmFzZVByb3ZpZGVyLnByb3RvdHlwZS5fZ2V0RmFzdEJsb2NrTnVtYmVyID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cdCAgICAgICAgdmFyIG5vdyA9IGdldFRpbWUoKTtcblx0ICAgICAgICAvLyBTdGFsZSBibG9jayBudW1iZXIsIHJlcXVlc3QgYSBuZXdlciB2YWx1ZVxuXHQgICAgICAgIGlmICgobm93IC0gdGhpcy5fZmFzdFF1ZXJ5RGF0ZSkgPiAyICogdGhpcy5fcG9sbGluZ0ludGVydmFsKSB7XG5cdCAgICAgICAgICAgIHRoaXMuX2Zhc3RRdWVyeURhdGUgPSBub3c7XG5cdCAgICAgICAgICAgIHRoaXMuX2Zhc3RCbG9ja051bWJlclByb21pc2UgPSB0aGlzLmdldEJsb2NrTnVtYmVyKCkudGhlbihmdW5jdGlvbiAoYmxvY2tOdW1iZXIpIHtcblx0ICAgICAgICAgICAgICAgIGlmIChfdGhpcy5fZmFzdEJsb2NrTnVtYmVyID09IG51bGwgfHwgYmxvY2tOdW1iZXIgPiBfdGhpcy5fZmFzdEJsb2NrTnVtYmVyKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgX3RoaXMuX2Zhc3RCbG9ja051bWJlciA9IGJsb2NrTnVtYmVyO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgcmV0dXJuIF90aGlzLl9mYXN0QmxvY2tOdW1iZXI7XG5cdCAgICAgICAgICAgIH0pO1xuXHQgICAgICAgIH1cblx0ICAgICAgICByZXR1cm4gdGhpcy5fZmFzdEJsb2NrTnVtYmVyUHJvbWlzZTtcblx0ICAgIH07XG5cdCAgICBCYXNlUHJvdmlkZXIucHJvdG90eXBlLl9zZXRGYXN0QmxvY2tOdW1iZXIgPSBmdW5jdGlvbiAoYmxvY2tOdW1iZXIpIHtcblx0ICAgICAgICAvLyBPbGRlciBibG9jaywgbWF5YmUgYSBzdGFsZSByZXF1ZXN0XG5cdCAgICAgICAgaWYgKHRoaXMuX2Zhc3RCbG9ja051bWJlciAhPSBudWxsICYmIGJsb2NrTnVtYmVyIDwgdGhpcy5fZmFzdEJsb2NrTnVtYmVyKSB7XG5cdCAgICAgICAgICAgIHJldHVybjtcblx0ICAgICAgICB9XG5cdCAgICAgICAgLy8gVXBkYXRlIHRoZSB0aW1lIHdlIHVwZGF0ZWQgdGhlIGJsb2NrbnVtYmVyXG5cdCAgICAgICAgdGhpcy5fZmFzdFF1ZXJ5RGF0ZSA9IGdldFRpbWUoKTtcblx0ICAgICAgICAvLyBOZXdlciBibG9jayBudW1iZXIsIHVzZSAgaXRcblx0ICAgICAgICBpZiAodGhpcy5fZmFzdEJsb2NrTnVtYmVyID09IG51bGwgfHwgYmxvY2tOdW1iZXIgPiB0aGlzLl9mYXN0QmxvY2tOdW1iZXIpIHtcblx0ICAgICAgICAgICAgdGhpcy5fZmFzdEJsb2NrTnVtYmVyID0gYmxvY2tOdW1iZXI7XG5cdCAgICAgICAgICAgIHRoaXMuX2Zhc3RCbG9ja051bWJlclByb21pc2UgPSBQcm9taXNlLnJlc29sdmUoYmxvY2tOdW1iZXIpO1xuXHQgICAgICAgIH1cblx0ICAgIH07XG5cdCAgICBCYXNlUHJvdmlkZXIucHJvdG90eXBlLndhaXRGb3JUcmFuc2FjdGlvbiA9IGZ1bmN0aW9uICh0cmFuc2FjdGlvbkhhc2gsIGNvbmZpcm1hdGlvbnMsIHRpbWVvdXQpIHtcblx0ICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcblx0ICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCB0aGlzLl93YWl0Rm9yVHJhbnNhY3Rpb24odHJhbnNhY3Rpb25IYXNoLCAoY29uZmlybWF0aW9ucyA9PSBudWxsKSA/IDEgOiBjb25maXJtYXRpb25zLCB0aW1lb3V0IHx8IDAsIG51bGwpXTtcblx0ICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgfSk7XG5cdCAgICB9O1xuXHQgICAgQmFzZVByb3ZpZGVyLnByb3RvdHlwZS5fd2FpdEZvclRyYW5zYWN0aW9uID0gZnVuY3Rpb24gKHRyYW5zYWN0aW9uSGFzaCwgY29uZmlybWF0aW9ucywgdGltZW91dCwgcmVwbGFjZWFibGUpIHtcblx0ICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIHZhciByZWNlaXB0O1xuXHQgICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXHQgICAgICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG5cdCAgICAgICAgICAgICAgICBzd2l0Y2ggKF9hLmxhYmVsKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgY2FzZSAwOiByZXR1cm4gWzQgLyp5aWVsZCovLCB0aGlzLmdldFRyYW5zYWN0aW9uUmVjZWlwdCh0cmFuc2FjdGlvbkhhc2gpXTtcblx0ICAgICAgICAgICAgICAgICAgICBjYXNlIDE6XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJlY2VpcHQgPSBfYS5zZW50KCk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIC8vIFJlY2VpcHQgaXMgYWxyZWFkeSBnb29kXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGlmICgocmVjZWlwdCA/IHJlY2VpcHQuY29uZmlybWF0aW9ucyA6IDApID49IGNvbmZpcm1hdGlvbnMpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCByZWNlaXB0XTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgICAgICAvLyBQb2xsIHVudGlsIHRoZSByZWNlaXB0IGlzIGdvb2QuLi5cblx0ICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgY2FuY2VsRnVuY3MgPSBbXTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZG9uZSA9IGZhbHNlO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBhbHJlYWR5RG9uZSA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGRvbmUpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRvbmUgPSB0cnVlO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYW5jZWxGdW5jcy5mb3JFYWNoKGZ1bmN0aW9uIChmdW5jKSB7IGZ1bmMoKTsgfSk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBtaW5lZEhhbmRsZXIgPSBmdW5jdGlvbiAocmVjZWlwdCkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocmVjZWlwdC5jb25maXJtYXRpb25zIDwgY29uZmlybWF0aW9ucykge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChhbHJlYWR5RG9uZSgpKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShyZWNlaXB0KTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLm9uKHRyYW5zYWN0aW9uSGFzaCwgbWluZWRIYW5kbGVyKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYW5jZWxGdW5jcy5wdXNoKGZ1bmN0aW9uICgpIHsgX3RoaXMucmVtb3ZlTGlzdGVuZXIodHJhbnNhY3Rpb25IYXNoLCBtaW5lZEhhbmRsZXIpOyB9KTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocmVwbGFjZWFibGUpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGxhc3RCbG9ja051bWJlcl8xID0gcmVwbGFjZWFibGUuc3RhcnRCbG9jaztcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHNjYW5uZWRCbG9ja18xID0gbnVsbDtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHJlcGxhY2VIYW5kbGVyXzEgPSBmdW5jdGlvbiAoYmxvY2tOdW1iZXIpIHsgcmV0dXJuIF9fYXdhaXRlcihfdGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDA6XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZG9uZSkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovXTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFdhaXQgMSBzZWNvbmQ7IHRoaXMgaXMgb25seSB1c2VkIGluIHRoZSBjYXNlIG9mIGEgZmF1bHQsIHNvXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB3ZSB3aWxsIHRyYWRlIG9mZiBhIGxpdHRsZSBiaXQgb2YgbGF0ZW5jeSBmb3IgbW9yZSBjb25zaXN0ZW50XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyByZXN1bHRzIGFuZCBmZXdlciBKU09OLVJQQyBjYWxsc1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgc3RhbGwoMTAwMCldO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDE6XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBXYWl0IDEgc2Vjb25kOyB0aGlzIGlzIG9ubHkgdXNlZCBpbiB0aGUgY2FzZSBvZiBhIGZhdWx0LCBzb1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gd2Ugd2lsbCB0cmFkZSBvZmYgYSBsaXR0bGUgYml0IG9mIGxhdGVuY3kgZm9yIG1vcmUgY29uc2lzdGVudFxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gcmVzdWx0cyBhbmQgZmV3ZXIgSlNPTi1SUEMgY2FsbHNcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9hLnNlbnQoKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZ2V0VHJhbnNhY3Rpb25Db3VudChyZXBsYWNlYWJsZS5mcm9tKS50aGVuKGZ1bmN0aW9uIChub25jZSkgeyByZXR1cm4gX19hd2FpdGVyKF90aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBtaW5lZCwgYmxvY2ssIHRpLCB0eCwgcmVjZWlwdF8xLCByZWFzb247XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKF9hLmxhYmVsKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDA6XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGRvbmUpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi9dO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIShub25jZSA8PSByZXBsYWNlYWJsZS5ub25jZSkpIHJldHVybiBbMyAvKmJyZWFrKi8sIDFdO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxhc3RCbG9ja051bWJlcl8xID0gYmxvY2tOdW1iZXI7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFszIC8qYnJlYWsqLywgOV07XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDE6IHJldHVybiBbNCAvKnlpZWxkKi8sIHRoaXMuZ2V0VHJhbnNhY3Rpb24odHJhbnNhY3Rpb25IYXNoKV07XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDI6XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWluZWQgPSBfYS5zZW50KCk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG1pbmVkICYmIG1pbmVkLmJsb2NrTnVtYmVyICE9IG51bGwpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi9dO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBGaXJzdCB0aW1lIHNjYW5uaW5nLiBXZSBzdGFydCBhIGxpdHRsZSBlYXJsaWVyIGZvciBzb21lXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gd2lnZ2xlIHJvb20gaGVyZSB0byBoYW5kbGUgdGhlIGV2ZW50dWFsbHkgY29uc2lzdGVudCBuYXR1cmVcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBvZiBibG9ja2NoYWluIChlLmcuIHRoZSBnZXRUcmFuc2FjdGlvbkNvdW50IHdhcyBmb3IgYVxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGRpZmZlcmVudCBibG9jaylcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoc2Nhbm5lZEJsb2NrXzEgPT0gbnVsbCkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzY2FubmVkQmxvY2tfMSA9IGxhc3RCbG9ja051bWJlcl8xIC0gMztcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNjYW5uZWRCbG9ja18xIDwgcmVwbGFjZWFibGUuc3RhcnRCbG9jaykge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2Nhbm5lZEJsb2NrXzEgPSByZXBsYWNlYWJsZS5zdGFydEJsb2NrO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9hLmxhYmVsID0gMztcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMzpcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIShzY2FubmVkQmxvY2tfMSA8PSBibG9ja051bWJlcikpIHJldHVybiBbMyAvKmJyZWFrKi8sIDldO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkb25lKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovXTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgdGhpcy5nZXRCbG9ja1dpdGhUcmFuc2FjdGlvbnMoc2Nhbm5lZEJsb2NrXzEpXTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgNDpcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBibG9jayA9IF9hLnNlbnQoKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aSA9IDA7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX2EubGFiZWwgPSA1O1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSA1OlxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghKHRpIDwgYmxvY2sudHJhbnNhY3Rpb25zLmxlbmd0aCkpIHJldHVybiBbMyAvKmJyZWFrKi8sIDhdO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR4ID0gYmxvY2sudHJhbnNhY3Rpb25zW3RpXTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBTdWNjZXNzZnVsbHkgbWluZWQhXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHR4Lmhhc2ggPT09IHRyYW5zYWN0aW9uSGFzaCkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qL107XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghKHR4LmZyb20gPT09IHJlcGxhY2VhYmxlLmZyb20gJiYgdHgubm9uY2UgPT09IHJlcGxhY2VhYmxlLm5vbmNlKSkgcmV0dXJuIFszIC8qYnJlYWsqLywgN107XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGRvbmUpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi9dO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCB0aGlzLndhaXRGb3JUcmFuc2FjdGlvbih0eC5oYXNoLCBjb25maXJtYXRpb25zKV07XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDY6XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVjZWlwdF8xID0gX2Euc2VudCgpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEFscmVhZHkgcmVzb2x2ZWQgb3IgcmVqZWN0ZWQgKHByb2xseSBhIHRpbWVvdXQpXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGFscmVhZHlEb25lKCkpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi9dO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWFzb24gPSBcInJlcGxhY2VkXCI7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHR4LmRhdGEgPT09IHJlcGxhY2VhYmxlLmRhdGEgJiYgdHgudG8gPT09IHJlcGxhY2VhYmxlLnRvICYmIHR4LnZhbHVlLmVxKHJlcGxhY2VhYmxlLnZhbHVlKSkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWFzb24gPSBcInJlcHJpY2VkXCI7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHR4LmRhdGEgPT09IFwiMHhcIiAmJiB0eC5mcm9tID09PSB0eC50byAmJiB0eC52YWx1ZS5pc1plcm8oKSkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWFzb24gPSBcImNhbmNlbGxlZFwiO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBFeHBsYWluIHdoeSB3ZSB3ZXJlIHJlcGxhY2VkXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVqZWN0KGxvZ2dlci5tYWtlRXJyb3IoXCJ0cmFuc2FjdGlvbiB3YXMgcmVwbGFjZWRcIiwgbGliLkxvZ2dlci5lcnJvcnMuVFJBTlNBQ1RJT05fUkVQTEFDRUQsIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FuY2VsbGVkOiAocmVhc29uID09PSBcInJlcGxhY2VkXCIgfHwgcmVhc29uID09PSBcImNhbmNlbGxlZFwiKSxcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVhc29uOiByZWFzb24sXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlcGxhY2VtZW50OiB0aGlzLl93cmFwVHJhbnNhY3Rpb24odHgpLFxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBoYXNoOiB0cmFuc2FjdGlvbkhhc2gsXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlY2VpcHQ6IHJlY2VpcHRfMVxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qL107XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDc6XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGkrKztcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzMgLypicmVhayovLCA1XTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgODpcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzY2FubmVkQmxvY2tfMSsrO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMyAvKmJyZWFrKi8sIDNdO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSA5OlxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkb25lKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovXTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5vbmNlKFwiYmxvY2tcIiwgcmVwbGFjZUhhbmRsZXJfMSk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi9dO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTsgfSwgZnVuY3Rpb24gKGVycm9yKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGRvbmUpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5vbmNlKFwiYmxvY2tcIiwgcmVwbGFjZUhhbmRsZXJfMSk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovXTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7IH07XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkb25lKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMub25jZShcImJsb2NrXCIsIHJlcGxhY2VIYW5kbGVyXzEpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYW5jZWxGdW5jcy5wdXNoKGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLnJlbW92ZUxpc3RlbmVyKFwiYmxvY2tcIiwgcmVwbGFjZUhhbmRsZXJfMSk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mICh0aW1lb3V0KSA9PT0gXCJudW1iZXJcIiAmJiB0aW1lb3V0ID4gMCkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgdGltZXJfMSA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGFscmVhZHlEb25lKCkpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWplY3QobG9nZ2VyLm1ha2VFcnJvcihcInRpbWVvdXQgZXhjZWVkZWRcIiwgbGliLkxvZ2dlci5lcnJvcnMuVElNRU9VVCwgeyB0aW1lb3V0OiB0aW1lb3V0IH0pKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSwgdGltZW91dCk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aW1lcl8xLnVucmVmKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aW1lcl8xLnVucmVmKCk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FuY2VsRnVuY3MucHVzaChmdW5jdGlvbiAoKSB7IGNsZWFyVGltZW91dCh0aW1lcl8xKTsgfSk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSldO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB9KTtcblx0ICAgICAgICB9KTtcblx0ICAgIH07XG5cdCAgICBCYXNlUHJvdmlkZXIucHJvdG90eXBlLmdldEJsb2NrTnVtYmVyID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIHRoaXMuX2dldEludGVybmFsQmxvY2tOdW1iZXIoMCldO1xuXHQgICAgICAgICAgICB9KTtcblx0ICAgICAgICB9KTtcblx0ICAgIH07XG5cdCAgICBCYXNlUHJvdmlkZXIucHJvdG90eXBlLmdldEdhc1ByaWNlID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgdmFyIHJlc3VsdDtcblx0ICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuXHQgICAgICAgICAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkge1xuXHQgICAgICAgICAgICAgICAgICAgIGNhc2UgMDogcmV0dXJuIFs0IC8qeWllbGQqLywgdGhpcy5nZXROZXR3b3JrKCldO1xuXHQgICAgICAgICAgICAgICAgICAgIGNhc2UgMTpcblx0ICAgICAgICAgICAgICAgICAgICAgICAgX2Euc2VudCgpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCB0aGlzLnBlcmZvcm0oXCJnZXRHYXNQcmljZVwiLCB7fSldO1xuXHQgICAgICAgICAgICAgICAgICAgIGNhc2UgMjpcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gX2Euc2VudCgpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB0cnkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIGxpYiQyLkJpZ051bWJlci5mcm9tKHJlc3VsdCldO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIGxvZ2dlci50aHJvd0Vycm9yKFwiYmFkIHJlc3VsdCBmcm9tIGJhY2tlbmRcIiwgbGliLkxvZ2dlci5lcnJvcnMuU0VSVkVSX0VSUk9SLCB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1ldGhvZDogXCJnZXRHYXNQcmljZVwiLFxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQ6IHJlc3VsdCxcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3I6IGVycm9yXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSldO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovXTtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgfSk7XG5cdCAgICB9O1xuXHQgICAgQmFzZVByb3ZpZGVyLnByb3RvdHlwZS5nZXRCYWxhbmNlID0gZnVuY3Rpb24gKGFkZHJlc3NPck5hbWUsIGJsb2NrVGFnKSB7XG5cdCAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICB2YXIgcGFyYW1zLCByZXN1bHQ7XG5cdCAgICAgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcblx0ICAgICAgICAgICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcblx0ICAgICAgICAgICAgICAgICAgICBjYXNlIDA6IHJldHVybiBbNCAvKnlpZWxkKi8sIHRoaXMuZ2V0TmV0d29yaygpXTtcblx0ICAgICAgICAgICAgICAgICAgICBjYXNlIDE6XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIF9hLnNlbnQoKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgKDAsIGxpYiQzLnJlc29sdmVQcm9wZXJ0aWVzKSh7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYWRkcmVzczogdGhpcy5fZ2V0QWRkcmVzcyhhZGRyZXNzT3JOYW1lKSxcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBibG9ja1RhZzogdGhpcy5fZ2V0QmxvY2tUYWcoYmxvY2tUYWcpXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KV07XG5cdCAgICAgICAgICAgICAgICAgICAgY2FzZSAyOlxuXHQgICAgICAgICAgICAgICAgICAgICAgICBwYXJhbXMgPSBfYS5zZW50KCk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIHRoaXMucGVyZm9ybShcImdldEJhbGFuY2VcIiwgcGFyYW1zKV07XG5cdCAgICAgICAgICAgICAgICAgICAgY2FzZSAzOlxuXHQgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSBfYS5zZW50KCk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHRyeSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgbGliJDIuQmlnTnVtYmVyLmZyb20ocmVzdWx0KV07XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgbG9nZ2VyLnRocm93RXJyb3IoXCJiYWQgcmVzdWx0IGZyb20gYmFja2VuZFwiLCBsaWIuTG9nZ2VyLmVycm9ycy5TRVJWRVJfRVJST1IsIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWV0aG9kOiBcImdldEJhbGFuY2VcIixcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFyYW1zOiBwYXJhbXMsXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdDogcmVzdWx0LFxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlcnJvcjogZXJyb3Jcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KV07XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi9dO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB9KTtcblx0ICAgICAgICB9KTtcblx0ICAgIH07XG5cdCAgICBCYXNlUHJvdmlkZXIucHJvdG90eXBlLmdldFRyYW5zYWN0aW9uQ291bnQgPSBmdW5jdGlvbiAoYWRkcmVzc09yTmFtZSwgYmxvY2tUYWcpIHtcblx0ICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIHZhciBwYXJhbXMsIHJlc3VsdDtcblx0ICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuXHQgICAgICAgICAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkge1xuXHQgICAgICAgICAgICAgICAgICAgIGNhc2UgMDogcmV0dXJuIFs0IC8qeWllbGQqLywgdGhpcy5nZXROZXR3b3JrKCldO1xuXHQgICAgICAgICAgICAgICAgICAgIGNhc2UgMTpcblx0ICAgICAgICAgICAgICAgICAgICAgICAgX2Euc2VudCgpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCAoMCwgbGliJDMucmVzb2x2ZVByb3BlcnRpZXMpKHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhZGRyZXNzOiB0aGlzLl9nZXRBZGRyZXNzKGFkZHJlc3NPck5hbWUpLFxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJsb2NrVGFnOiB0aGlzLl9nZXRCbG9ja1RhZyhibG9ja1RhZylcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pXTtcblx0ICAgICAgICAgICAgICAgICAgICBjYXNlIDI6XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHBhcmFtcyA9IF9hLnNlbnQoKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgdGhpcy5wZXJmb3JtKFwiZ2V0VHJhbnNhY3Rpb25Db3VudFwiLCBwYXJhbXMpXTtcblx0ICAgICAgICAgICAgICAgICAgICBjYXNlIDM6XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IF9hLnNlbnQoKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdHJ5IHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCBsaWIkMi5CaWdOdW1iZXIuZnJvbShyZXN1bHQpLnRvTnVtYmVyKCldO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIGxvZ2dlci50aHJvd0Vycm9yKFwiYmFkIHJlc3VsdCBmcm9tIGJhY2tlbmRcIiwgbGliLkxvZ2dlci5lcnJvcnMuU0VSVkVSX0VSUk9SLCB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1ldGhvZDogXCJnZXRUcmFuc2FjdGlvbkNvdW50XCIsXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhcmFtczogcGFyYW1zLFxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQ6IHJlc3VsdCxcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3I6IGVycm9yXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSldO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovXTtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgfSk7XG5cdCAgICB9O1xuXHQgICAgQmFzZVByb3ZpZGVyLnByb3RvdHlwZS5nZXRDb2RlID0gZnVuY3Rpb24gKGFkZHJlc3NPck5hbWUsIGJsb2NrVGFnKSB7XG5cdCAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICB2YXIgcGFyYW1zLCByZXN1bHQ7XG5cdCAgICAgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcblx0ICAgICAgICAgICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcblx0ICAgICAgICAgICAgICAgICAgICBjYXNlIDA6IHJldHVybiBbNCAvKnlpZWxkKi8sIHRoaXMuZ2V0TmV0d29yaygpXTtcblx0ICAgICAgICAgICAgICAgICAgICBjYXNlIDE6XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIF9hLnNlbnQoKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgKDAsIGxpYiQzLnJlc29sdmVQcm9wZXJ0aWVzKSh7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYWRkcmVzczogdGhpcy5fZ2V0QWRkcmVzcyhhZGRyZXNzT3JOYW1lKSxcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBibG9ja1RhZzogdGhpcy5fZ2V0QmxvY2tUYWcoYmxvY2tUYWcpXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KV07XG5cdCAgICAgICAgICAgICAgICAgICAgY2FzZSAyOlxuXHQgICAgICAgICAgICAgICAgICAgICAgICBwYXJhbXMgPSBfYS5zZW50KCk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIHRoaXMucGVyZm9ybShcImdldENvZGVcIiwgcGFyYW1zKV07XG5cdCAgICAgICAgICAgICAgICAgICAgY2FzZSAzOlxuXHQgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSBfYS5zZW50KCk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHRyeSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgKDAsIGxpYiQxLmhleGxpZnkpKHJlc3VsdCldO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIGxvZ2dlci50aHJvd0Vycm9yKFwiYmFkIHJlc3VsdCBmcm9tIGJhY2tlbmRcIiwgbGliLkxvZ2dlci5lcnJvcnMuU0VSVkVSX0VSUk9SLCB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1ldGhvZDogXCJnZXRDb2RlXCIsXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhcmFtczogcGFyYW1zLFxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQ6IHJlc3VsdCxcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3I6IGVycm9yXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSldO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovXTtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgfSk7XG5cdCAgICB9O1xuXHQgICAgQmFzZVByb3ZpZGVyLnByb3RvdHlwZS5nZXRTdG9yYWdlQXQgPSBmdW5jdGlvbiAoYWRkcmVzc09yTmFtZSwgcG9zaXRpb24sIGJsb2NrVGFnKSB7XG5cdCAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICB2YXIgcGFyYW1zLCByZXN1bHQ7XG5cdCAgICAgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcblx0ICAgICAgICAgICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcblx0ICAgICAgICAgICAgICAgICAgICBjYXNlIDA6IHJldHVybiBbNCAvKnlpZWxkKi8sIHRoaXMuZ2V0TmV0d29yaygpXTtcblx0ICAgICAgICAgICAgICAgICAgICBjYXNlIDE6XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIF9hLnNlbnQoKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgKDAsIGxpYiQzLnJlc29sdmVQcm9wZXJ0aWVzKSh7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYWRkcmVzczogdGhpcy5fZ2V0QWRkcmVzcyhhZGRyZXNzT3JOYW1lKSxcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBibG9ja1RhZzogdGhpcy5fZ2V0QmxvY2tUYWcoYmxvY2tUYWcpLFxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBvc2l0aW9uOiBQcm9taXNlLnJlc29sdmUocG9zaXRpb24pLnRoZW4oZnVuY3Rpb24gKHApIHsgcmV0dXJuICgwLCBsaWIkMS5oZXhWYWx1ZSkocCk7IH0pXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KV07XG5cdCAgICAgICAgICAgICAgICAgICAgY2FzZSAyOlxuXHQgICAgICAgICAgICAgICAgICAgICAgICBwYXJhbXMgPSBfYS5zZW50KCk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIHRoaXMucGVyZm9ybShcImdldFN0b3JhZ2VBdFwiLCBwYXJhbXMpXTtcblx0ICAgICAgICAgICAgICAgICAgICBjYXNlIDM6XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IF9hLnNlbnQoKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdHJ5IHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCAoMCwgbGliJDEuaGV4bGlmeSkocmVzdWx0KV07XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgbG9nZ2VyLnRocm93RXJyb3IoXCJiYWQgcmVzdWx0IGZyb20gYmFja2VuZFwiLCBsaWIuTG9nZ2VyLmVycm9ycy5TRVJWRVJfRVJST1IsIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWV0aG9kOiBcImdldFN0b3JhZ2VBdFwiLFxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXJhbXM6IHBhcmFtcyxcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0OiByZXN1bHQsXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yOiBlcnJvclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pXTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qL107XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIH0pO1xuXHQgICAgICAgIH0pO1xuXHQgICAgfTtcblx0ICAgIC8vIFRoaXMgc2hvdWxkIGJlIGNhbGxlZCBieSBhbnkgc3ViY2xhc3Mgd3JhcHBpbmcgYSBUcmFuc2FjdGlvblJlc3BvbnNlXG5cdCAgICBCYXNlUHJvdmlkZXIucHJvdG90eXBlLl93cmFwVHJhbnNhY3Rpb24gPSBmdW5jdGlvbiAodHgsIGhhc2gsIHN0YXJ0QmxvY2spIHtcblx0ICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXHQgICAgICAgIGlmIChoYXNoICE9IG51bGwgJiYgKDAsIGxpYiQxLmhleERhdGFMZW5ndGgpKGhhc2gpICE9PSAzMikge1xuXHQgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIHJlc3BvbnNlIC0gc2VuZFRyYW5zYWN0aW9uXCIpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICB2YXIgcmVzdWx0ID0gdHg7XG5cdCAgICAgICAgLy8gQ2hlY2sgdGhlIGhhc2ggd2UgZXhwZWN0IGlzIHRoZSBzYW1lIGFzIHRoZSBoYXNoIHRoZSBzZXJ2ZXIgcmVwb3J0ZWRcblx0ICAgICAgICBpZiAoaGFzaCAhPSBudWxsICYmIHR4Lmhhc2ggIT09IGhhc2gpIHtcblx0ICAgICAgICAgICAgbG9nZ2VyLnRocm93RXJyb3IoXCJUcmFuc2FjdGlvbiBoYXNoIG1pc21hdGNoIGZyb20gUHJvdmlkZXIuc2VuZFRyYW5zYWN0aW9uLlwiLCBsaWIuTG9nZ2VyLmVycm9ycy5VTktOT1dOX0VSUk9SLCB7IGV4cGVjdGVkSGFzaDogdHguaGFzaCwgcmV0dXJuZWRIYXNoOiBoYXNoIH0pO1xuXHQgICAgICAgIH1cblx0ICAgICAgICByZXN1bHQud2FpdCA9IGZ1bmN0aW9uIChjb25maXJtcywgdGltZW91dCkgeyByZXR1cm4gX19hd2FpdGVyKF90aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICB2YXIgcmVwbGFjZW1lbnQsIHJlY2VpcHQ7XG5cdCAgICAgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcblx0ICAgICAgICAgICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcblx0ICAgICAgICAgICAgICAgICAgICBjYXNlIDA6XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjb25maXJtcyA9PSBudWxsKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25maXJtcyA9IDE7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRpbWVvdXQgPT0gbnVsbCkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGltZW91dCA9IDA7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICAgICAgcmVwbGFjZW1lbnQgPSB1bmRlZmluZWQ7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjb25maXJtcyAhPT0gMCAmJiBzdGFydEJsb2NrICE9IG51bGwpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlcGxhY2VtZW50ID0ge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGE6IHR4LmRhdGEsXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZnJvbTogdHguZnJvbSxcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBub25jZTogdHgubm9uY2UsXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdG86IHR4LnRvLFxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiB0eC52YWx1ZSxcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGFydEJsb2NrOiBzdGFydEJsb2NrXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIHRoaXMuX3dhaXRGb3JUcmFuc2FjdGlvbih0eC5oYXNoLCBjb25maXJtcywgdGltZW91dCwgcmVwbGFjZW1lbnQpXTtcblx0ICAgICAgICAgICAgICAgICAgICBjYXNlIDE6XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJlY2VpcHQgPSBfYS5zZW50KCk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyZWNlaXB0ID09IG51bGwgJiYgY29uZmlybXMgPT09IDApIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCBudWxsXTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgICAgICAvLyBObyBsb25nZXIgcGVuZGluZywgYWxsb3cgdGhlIHBvbGxpbmcgbG9vcCB0byBnYXJiYWdlIGNvbGxlY3QgdGhpc1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9lbWl0dGVkW1widDpcIiArIHR4Lmhhc2hdID0gcmVjZWlwdC5ibG9ja051bWJlcjtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJlY2VpcHQuc3RhdHVzID09PSAwKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBsb2dnZXIudGhyb3dFcnJvcihcInRyYW5zYWN0aW9uIGZhaWxlZFwiLCBsaWIuTG9nZ2VyLmVycm9ycy5DQUxMX0VYQ0VQVElPTiwge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyYW5zYWN0aW9uSGFzaDogdHguaGFzaCxcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cmFuc2FjdGlvbjogdHgsXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVjZWlwdDogcmVjZWlwdFxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIHJlY2VpcHRdO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB9KTtcblx0ICAgICAgICB9KTsgfTtcblx0ICAgICAgICByZXR1cm4gcmVzdWx0O1xuXHQgICAgfTtcblx0ICAgIEJhc2VQcm92aWRlci5wcm90b3R5cGUuc2VuZFRyYW5zYWN0aW9uID0gZnVuY3Rpb24gKHNpZ25lZFRyYW5zYWN0aW9uKSB7XG5cdCAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICB2YXIgaGV4VHgsIHR4LCBibG9ja051bWJlciwgaGFzaCwgZXJyb3JfNztcblx0ICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuXHQgICAgICAgICAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkge1xuXHQgICAgICAgICAgICAgICAgICAgIGNhc2UgMDogcmV0dXJuIFs0IC8qeWllbGQqLywgdGhpcy5nZXROZXR3b3JrKCldO1xuXHQgICAgICAgICAgICAgICAgICAgIGNhc2UgMTpcblx0ICAgICAgICAgICAgICAgICAgICAgICAgX2Euc2VudCgpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCBQcm9taXNlLnJlc29sdmUoc2lnbmVkVHJhbnNhY3Rpb24pLnRoZW4oZnVuY3Rpb24gKHQpIHsgcmV0dXJuICgwLCBsaWIkMS5oZXhsaWZ5KSh0KTsgfSldO1xuXHQgICAgICAgICAgICAgICAgICAgIGNhc2UgMjpcblx0ICAgICAgICAgICAgICAgICAgICAgICAgaGV4VHggPSBfYS5zZW50KCk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHR4ID0gdGhpcy5mb3JtYXR0ZXIudHJhbnNhY3Rpb24oc2lnbmVkVHJhbnNhY3Rpb24pO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBpZiAodHguY29uZmlybWF0aW9ucyA9PSBudWxsKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eC5jb25maXJtYXRpb25zID0gMDtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCB0aGlzLl9nZXRJbnRlcm5hbEJsb2NrTnVtYmVyKDEwMCArIDIgKiB0aGlzLnBvbGxpbmdJbnRlcnZhbCldO1xuXHQgICAgICAgICAgICAgICAgICAgIGNhc2UgMzpcblx0ICAgICAgICAgICAgICAgICAgICAgICAgYmxvY2tOdW1iZXIgPSBfYS5zZW50KCk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIF9hLmxhYmVsID0gNDtcblx0ICAgICAgICAgICAgICAgICAgICBjYXNlIDQ6XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIF9hLnRyeXMucHVzaChbNCwgNiwgLCA3XSk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIHRoaXMucGVyZm9ybShcInNlbmRUcmFuc2FjdGlvblwiLCB7IHNpZ25lZFRyYW5zYWN0aW9uOiBoZXhUeCB9KV07XG5cdCAgICAgICAgICAgICAgICAgICAgY2FzZSA1OlxuXHQgICAgICAgICAgICAgICAgICAgICAgICBoYXNoID0gX2Euc2VudCgpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgdGhpcy5fd3JhcFRyYW5zYWN0aW9uKHR4LCBoYXNoLCBibG9ja051bWJlcildO1xuXHQgICAgICAgICAgICAgICAgICAgIGNhc2UgNjpcblx0ICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3JfNyA9IF9hLnNlbnQoKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3JfNy50cmFuc2FjdGlvbiA9IHR4O1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBlcnJvcl83LnRyYW5zYWN0aW9uSGFzaCA9IHR4Lmhhc2g7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IGVycm9yXzc7XG5cdCAgICAgICAgICAgICAgICAgICAgY2FzZSA3OiByZXR1cm4gWzIgLypyZXR1cm4qL107XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIH0pO1xuXHQgICAgICAgIH0pO1xuXHQgICAgfTtcblx0ICAgIEJhc2VQcm92aWRlci5wcm90b3R5cGUuX2dldFRyYW5zYWN0aW9uUmVxdWVzdCA9IGZ1bmN0aW9uICh0cmFuc2FjdGlvbikge1xuXHQgICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgdmFyIHZhbHVlcywgdHgsIF9hLCBfYjtcblx0ICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcblx0ICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYykge1xuXHQgICAgICAgICAgICAgICAgc3dpdGNoIChfYy5sYWJlbCkge1xuXHQgICAgICAgICAgICAgICAgICAgIGNhc2UgMDogcmV0dXJuIFs0IC8qeWllbGQqLywgdHJhbnNhY3Rpb25dO1xuXHQgICAgICAgICAgICAgICAgICAgIGNhc2UgMTpcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWVzID0gX2Muc2VudCgpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB0eCA9IHt9O1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBbXCJmcm9tXCIsIFwidG9cIl0uZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodmFsdWVzW2tleV0gPT0gbnVsbCkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR4W2tleV0gPSBQcm9taXNlLnJlc29sdmUodmFsdWVzW2tleV0pLnRoZW4oZnVuY3Rpb24gKHYpIHsgcmV0dXJuICh2ID8gX3RoaXMuX2dldEFkZHJlc3ModikgOiBudWxsKTsgfSk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBbXCJnYXNMaW1pdFwiLCBcImdhc1ByaWNlXCIsIFwibWF4RmVlUGVyR2FzXCIsIFwibWF4UHJpb3JpdHlGZWVQZXJHYXNcIiwgXCJ2YWx1ZVwiXS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZXNba2V5XSA9PSBudWxsKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHhba2V5XSA9IFByb21pc2UucmVzb2x2ZSh2YWx1ZXNba2V5XSkudGhlbihmdW5jdGlvbiAodikgeyByZXR1cm4gKHYgPyBsaWIkMi5CaWdOdW1iZXIuZnJvbSh2KSA6IG51bGwpOyB9KTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIFtcInR5cGVcIl0uZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodmFsdWVzW2tleV0gPT0gbnVsbCkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR4W2tleV0gPSBQcm9taXNlLnJlc29sdmUodmFsdWVzW2tleV0pLnRoZW4oZnVuY3Rpb24gKHYpIHsgcmV0dXJuICgodiAhPSBudWxsKSA/IHYgOiBudWxsKTsgfSk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBpZiAodmFsdWVzLmFjY2Vzc0xpc3QpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR4LmFjY2Vzc0xpc3QgPSB0aGlzLmZvcm1hdHRlci5hY2Nlc3NMaXN0KHZhbHVlcy5hY2Nlc3NMaXN0KTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgICAgICBbXCJkYXRhXCJdLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHZhbHVlc1trZXldID09IG51bGwpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eFtrZXldID0gUHJvbWlzZS5yZXNvbHZlKHZhbHVlc1trZXldKS50aGVuKGZ1bmN0aW9uICh2KSB7IHJldHVybiAodiA/ICgwLCBsaWIkMS5oZXhsaWZ5KSh2KSA6IG51bGwpOyB9KTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIF9iID0gKF9hID0gdGhpcy5mb3JtYXR0ZXIpLnRyYW5zYWN0aW9uUmVxdWVzdDtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgKDAsIGxpYiQzLnJlc29sdmVQcm9wZXJ0aWVzKSh0eCldO1xuXHQgICAgICAgICAgICAgICAgICAgIGNhc2UgMjogcmV0dXJuIFsyIC8qcmV0dXJuKi8sIF9iLmFwcGx5KF9hLCBbX2Muc2VudCgpXSldO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB9KTtcblx0ICAgICAgICB9KTtcblx0ICAgIH07XG5cdCAgICBCYXNlUHJvdmlkZXIucHJvdG90eXBlLl9nZXRGaWx0ZXIgPSBmdW5jdGlvbiAoZmlsdGVyKSB7XG5cdCAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICB2YXIgcmVzdWx0LCBfYSwgX2I7XG5cdCAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cdCAgICAgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2MpIHtcblx0ICAgICAgICAgICAgICAgIHN3aXRjaCAoX2MubGFiZWwpIHtcblx0ICAgICAgICAgICAgICAgICAgICBjYXNlIDA6IHJldHVybiBbNCAvKnlpZWxkKi8sIGZpbHRlcl07XG5cdCAgICAgICAgICAgICAgICAgICAgY2FzZSAxOlxuXHQgICAgICAgICAgICAgICAgICAgICAgICBmaWx0ZXIgPSBfYy5zZW50KCk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IHt9O1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZmlsdGVyLmFkZHJlc3MgIT0gbnVsbCkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LmFkZHJlc3MgPSB0aGlzLl9nZXRBZGRyZXNzKGZpbHRlci5hZGRyZXNzKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgICAgICBbXCJibG9ja0hhc2hcIiwgXCJ0b3BpY3NcIl0uZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZmlsdGVyW2tleV0gPT0gbnVsbCkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdFtrZXldID0gZmlsdGVyW2tleV07XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBbXCJmcm9tQmxvY2tcIiwgXCJ0b0Jsb2NrXCJdLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGZpbHRlcltrZXldID09IG51bGwpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHRba2V5XSA9IF90aGlzLl9nZXRCbG9ja1RhZyhmaWx0ZXJba2V5XSk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBfYiA9IChfYSA9IHRoaXMuZm9ybWF0dGVyKS5maWx0ZXI7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sICgwLCBsaWIkMy5yZXNvbHZlUHJvcGVydGllcykocmVzdWx0KV07XG5cdCAgICAgICAgICAgICAgICAgICAgY2FzZSAyOiByZXR1cm4gWzIgLypyZXR1cm4qLywgX2IuYXBwbHkoX2EsIFtfYy5zZW50KCldKV07XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIH0pO1xuXHQgICAgICAgIH0pO1xuXHQgICAgfTtcblx0ICAgIEJhc2VQcm92aWRlci5wcm90b3R5cGUuY2FsbCA9IGZ1bmN0aW9uICh0cmFuc2FjdGlvbiwgYmxvY2tUYWcpIHtcblx0ICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIHZhciBwYXJhbXMsIHJlc3VsdDtcblx0ICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuXHQgICAgICAgICAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkge1xuXHQgICAgICAgICAgICAgICAgICAgIGNhc2UgMDogcmV0dXJuIFs0IC8qeWllbGQqLywgdGhpcy5nZXROZXR3b3JrKCldO1xuXHQgICAgICAgICAgICAgICAgICAgIGNhc2UgMTpcblx0ICAgICAgICAgICAgICAgICAgICAgICAgX2Euc2VudCgpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCAoMCwgbGliJDMucmVzb2x2ZVByb3BlcnRpZXMpKHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cmFuc2FjdGlvbjogdGhpcy5fZ2V0VHJhbnNhY3Rpb25SZXF1ZXN0KHRyYW5zYWN0aW9uKSxcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBibG9ja1RhZzogdGhpcy5fZ2V0QmxvY2tUYWcoYmxvY2tUYWcpXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KV07XG5cdCAgICAgICAgICAgICAgICAgICAgY2FzZSAyOlxuXHQgICAgICAgICAgICAgICAgICAgICAgICBwYXJhbXMgPSBfYS5zZW50KCk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIHRoaXMucGVyZm9ybShcImNhbGxcIiwgcGFyYW1zKV07XG5cdCAgICAgICAgICAgICAgICAgICAgY2FzZSAzOlxuXHQgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSBfYS5zZW50KCk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHRyeSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgKDAsIGxpYiQxLmhleGxpZnkpKHJlc3VsdCldO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIGxvZ2dlci50aHJvd0Vycm9yKFwiYmFkIHJlc3VsdCBmcm9tIGJhY2tlbmRcIiwgbGliLkxvZ2dlci5lcnJvcnMuU0VSVkVSX0VSUk9SLCB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1ldGhvZDogXCJjYWxsXCIsXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhcmFtczogcGFyYW1zLFxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQ6IHJlc3VsdCxcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3I6IGVycm9yXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSldO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovXTtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgfSk7XG5cdCAgICB9O1xuXHQgICAgQmFzZVByb3ZpZGVyLnByb3RvdHlwZS5lc3RpbWF0ZUdhcyA9IGZ1bmN0aW9uICh0cmFuc2FjdGlvbikge1xuXHQgICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgdmFyIHBhcmFtcywgcmVzdWx0O1xuXHQgICAgICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG5cdCAgICAgICAgICAgICAgICBzd2l0Y2ggKF9hLmxhYmVsKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgY2FzZSAwOiByZXR1cm4gWzQgLyp5aWVsZCovLCB0aGlzLmdldE5ldHdvcmsoKV07XG5cdCAgICAgICAgICAgICAgICAgICAgY2FzZSAxOlxuXHQgICAgICAgICAgICAgICAgICAgICAgICBfYS5zZW50KCk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sICgwLCBsaWIkMy5yZXNvbHZlUHJvcGVydGllcykoe1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyYW5zYWN0aW9uOiB0aGlzLl9nZXRUcmFuc2FjdGlvblJlcXVlc3QodHJhbnNhY3Rpb24pXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KV07XG5cdCAgICAgICAgICAgICAgICAgICAgY2FzZSAyOlxuXHQgICAgICAgICAgICAgICAgICAgICAgICBwYXJhbXMgPSBfYS5zZW50KCk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIHRoaXMucGVyZm9ybShcImVzdGltYXRlR2FzXCIsIHBhcmFtcyldO1xuXHQgICAgICAgICAgICAgICAgICAgIGNhc2UgMzpcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gX2Euc2VudCgpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB0cnkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIGxpYiQyLkJpZ051bWJlci5mcm9tKHJlc3VsdCldO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIGxvZ2dlci50aHJvd0Vycm9yKFwiYmFkIHJlc3VsdCBmcm9tIGJhY2tlbmRcIiwgbGliLkxvZ2dlci5lcnJvcnMuU0VSVkVSX0VSUk9SLCB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1ldGhvZDogXCJlc3RpbWF0ZUdhc1wiLFxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXJhbXM6IHBhcmFtcyxcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0OiByZXN1bHQsXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yOiBlcnJvclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pXTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qL107XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIH0pO1xuXHQgICAgICAgIH0pO1xuXHQgICAgfTtcblx0ICAgIEJhc2VQcm92aWRlci5wcm90b3R5cGUuX2dldEFkZHJlc3MgPSBmdW5jdGlvbiAoYWRkcmVzc09yTmFtZSkge1xuXHQgICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgdmFyIGFkZHJlc3M7XG5cdCAgICAgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcblx0ICAgICAgICAgICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcblx0ICAgICAgICAgICAgICAgICAgICBjYXNlIDA6IHJldHVybiBbNCAvKnlpZWxkKi8sIGFkZHJlc3NPck5hbWVdO1xuXHQgICAgICAgICAgICAgICAgICAgIGNhc2UgMTpcblx0ICAgICAgICAgICAgICAgICAgICAgICAgYWRkcmVzc09yTmFtZSA9IF9hLnNlbnQoKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiAoYWRkcmVzc09yTmFtZSkgIT09IFwic3RyaW5nXCIpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJpbnZhbGlkIGFkZHJlc3Mgb3IgRU5TIG5hbWVcIiwgXCJuYW1lXCIsIGFkZHJlc3NPck5hbWUpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIHRoaXMucmVzb2x2ZU5hbWUoYWRkcmVzc09yTmFtZSldO1xuXHQgICAgICAgICAgICAgICAgICAgIGNhc2UgMjpcblx0ICAgICAgICAgICAgICAgICAgICAgICAgYWRkcmVzcyA9IF9hLnNlbnQoKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGFkZHJlc3MgPT0gbnVsbCkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgbG9nZ2VyLnRocm93RXJyb3IoXCJFTlMgbmFtZSBub3QgY29uZmlndXJlZFwiLCBsaWIuTG9nZ2VyLmVycm9ycy5VTlNVUFBPUlRFRF9PUEVSQVRJT04sIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcGVyYXRpb246IFwicmVzb2x2ZU5hbWUoXCIgKyBKU09OLnN0cmluZ2lmeShhZGRyZXNzT3JOYW1lKSArIFwiKVwiXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgYWRkcmVzc107XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIH0pO1xuXHQgICAgICAgIH0pO1xuXHQgICAgfTtcblx0ICAgIEJhc2VQcm92aWRlci5wcm90b3R5cGUuX2dldEJsb2NrID0gZnVuY3Rpb24gKGJsb2NrSGFzaE9yQmxvY2tUYWcsIGluY2x1ZGVUcmFuc2FjdGlvbnMpIHtcblx0ICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIHZhciBibG9ja051bWJlciwgcGFyYW1zLCBfYSwgZXJyb3JfODtcblx0ICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcblx0ICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYikge1xuXHQgICAgICAgICAgICAgICAgc3dpdGNoIChfYi5sYWJlbCkge1xuXHQgICAgICAgICAgICAgICAgICAgIGNhc2UgMDogcmV0dXJuIFs0IC8qeWllbGQqLywgdGhpcy5nZXROZXR3b3JrKCldO1xuXHQgICAgICAgICAgICAgICAgICAgIGNhc2UgMTpcblx0ICAgICAgICAgICAgICAgICAgICAgICAgX2Iuc2VudCgpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCBibG9ja0hhc2hPckJsb2NrVGFnXTtcblx0ICAgICAgICAgICAgICAgICAgICBjYXNlIDI6XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGJsb2NrSGFzaE9yQmxvY2tUYWcgPSBfYi5zZW50KCk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGJsb2NrTnVtYmVyID0gLTEyODtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcGFyYW1zID0ge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5jbHVkZVRyYW5zYWN0aW9uczogISFpbmNsdWRlVHJhbnNhY3Rpb25zXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH07XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGlmICghKDAsIGxpYiQxLmlzSGV4U3RyaW5nKShibG9ja0hhc2hPckJsb2NrVGFnLCAzMikpIHJldHVybiBbMyAvKmJyZWFrKi8sIDNdO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBwYXJhbXMuYmxvY2tIYXNoID0gYmxvY2tIYXNoT3JCbG9ja1RhZztcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFszIC8qYnJlYWsqLywgNl07XG5cdCAgICAgICAgICAgICAgICAgICAgY2FzZSAzOlxuXHQgICAgICAgICAgICAgICAgICAgICAgICBfYi50cnlzLnB1c2goWzMsIDUsICwgNl0pO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBfYSA9IHBhcmFtcztcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgdGhpcy5fZ2V0QmxvY2tUYWcoYmxvY2tIYXNoT3JCbG9ja1RhZyldO1xuXHQgICAgICAgICAgICAgICAgICAgIGNhc2UgNDpcblx0ICAgICAgICAgICAgICAgICAgICAgICAgX2EuYmxvY2tUYWcgPSBfYi5zZW50KCk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGlmICgoMCwgbGliJDEuaXNIZXhTdHJpbmcpKHBhcmFtcy5ibG9ja1RhZykpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJsb2NrTnVtYmVyID0gcGFyc2VJbnQocGFyYW1zLmJsb2NrVGFnLnN1YnN0cmluZygyKSwgMTYpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMyAvKmJyZWFrKi8sIDZdO1xuXHQgICAgICAgICAgICAgICAgICAgIGNhc2UgNTpcblx0ICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3JfOCA9IF9iLnNlbnQoKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcImludmFsaWQgYmxvY2sgaGFzaCBvciBibG9jayB0YWdcIiwgXCJibG9ja0hhc2hPckJsb2NrVGFnXCIsIGJsb2NrSGFzaE9yQmxvY2tUYWcpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzMgLypicmVhayovLCA2XTtcblx0ICAgICAgICAgICAgICAgICAgICBjYXNlIDY6IHJldHVybiBbMiAvKnJldHVybiovLCAoMCwgbGliJHEucG9sbCkoZnVuY3Rpb24gKCkgeyByZXR1cm4gX19hd2FpdGVyKF90aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGJsb2NrLCBibG9ja051bWJlcl8xLCBpLCB0eCwgY29uZmlybWF0aW9ucywgYmxvY2tXaXRoVHhzO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKF9hLmxhYmVsKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMDogcmV0dXJuIFs0IC8qeWllbGQqLywgdGhpcy5wZXJmb3JtKFwiZ2V0QmxvY2tcIiwgcGFyYW1zKV07XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMTpcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJsb2NrID0gX2Euc2VudCgpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gQmxvY2sgd2FzIG5vdCBmb3VuZFxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGJsb2NrID09IG51bGwpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBGb3IgYmxvY2toYXNoZXMsIGlmIHdlIGRpZG4ndCBzYXkgaXQgZXhpc3RlZCwgdGhhdCBibG9ja2hhc2ggbWF5XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gbm90IGV4aXN0LiBJZiB3ZSBkaWQgc2VlIGl0IHRob3VnaCwgcGVyaGFwcyBmcm9tIGEgbG9nLCB3ZSBrbm93XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gaXQgZXhpc3RzLCBhbmQgdGhpcyBub2RlIGlzIGp1c3Qgbm90IGNhdWdodCB1cCB5ZXQuXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHBhcmFtcy5ibG9ja0hhc2ggIT0gbnVsbCkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5fZW1pdHRlZFtcImI6XCIgKyBwYXJhbXMuYmxvY2tIYXNoXSA9PSBudWxsKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgbnVsbF07XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gRm9yIGJsb2NrIHRhZ3MsIGlmIHdlIGFyZSBhc2tpbmcgZm9yIGEgZnV0dXJlIGJsb2NrLCB3ZSByZXR1cm4gbnVsbFxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwYXJhbXMuYmxvY2tUYWcgIT0gbnVsbCkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoYmxvY2tOdW1iZXIgPiB0aGlzLl9lbWl0dGVkLmJsb2NrKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgbnVsbF07XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gUmV0cnkgb24gdGhlIG5leHQgYmxvY2tcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgdW5kZWZpbmVkXTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghaW5jbHVkZVRyYW5zYWN0aW9ucykgcmV0dXJuIFszIC8qYnJlYWsqLywgOF07XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBibG9ja051bWJlcl8xID0gbnVsbDtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGkgPSAwO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX2EubGFiZWwgPSAyO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDI6XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIShpIDwgYmxvY2sudHJhbnNhY3Rpb25zLmxlbmd0aCkpIHJldHVybiBbMyAvKmJyZWFrKi8sIDddO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHggPSBibG9jay50cmFuc2FjdGlvbnNbaV07XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoISh0eC5ibG9ja051bWJlciA9PSBudWxsKSkgcmV0dXJuIFszIC8qYnJlYWsqLywgM107XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eC5jb25maXJtYXRpb25zID0gMDtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMyAvKmJyZWFrKi8sIDZdO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDM6XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoISh0eC5jb25maXJtYXRpb25zID09IG51bGwpKSByZXR1cm4gWzMgLypicmVhayovLCA2XTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghKGJsb2NrTnVtYmVyXzEgPT0gbnVsbCkpIHJldHVybiBbMyAvKmJyZWFrKi8sIDVdO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgdGhpcy5fZ2V0SW50ZXJuYWxCbG9ja051bWJlcigxMDAgKyAyICogdGhpcy5wb2xsaW5nSW50ZXJ2YWwpXTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSA0OlxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYmxvY2tOdW1iZXJfMSA9IF9hLnNlbnQoKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9hLmxhYmVsID0gNTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSA1OlxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uZmlybWF0aW9ucyA9IChibG9ja051bWJlcl8xIC0gdHguYmxvY2tOdW1iZXIpICsgMTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjb25maXJtYXRpb25zIDw9IDApIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25maXJtYXRpb25zID0gMTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR4LmNvbmZpcm1hdGlvbnMgPSBjb25maXJtYXRpb25zO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX2EubGFiZWwgPSA2O1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDY6XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpKys7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzMgLypicmVhayovLCAyXTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSA3OlxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYmxvY2tXaXRoVHhzID0gdGhpcy5mb3JtYXR0ZXIuYmxvY2tXaXRoVHJhbnNhY3Rpb25zKGJsb2NrKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJsb2NrV2l0aFR4cy50cmFuc2FjdGlvbnMgPSBibG9ja1dpdGhUeHMudHJhbnNhY3Rpb25zLm1hcChmdW5jdGlvbiAodHgpIHsgcmV0dXJuIF90aGlzLl93cmFwVHJhbnNhY3Rpb24odHgpOyB9KTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCBibG9ja1dpdGhUeHNdO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDg6IHJldHVybiBbMiAvKnJldHVybiovLCB0aGlzLmZvcm1hdHRlci5ibG9jayhibG9jayldO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB9KTsgfSwgeyBvbmNlUG9sbDogdGhpcyB9KV07XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIH0pO1xuXHQgICAgICAgIH0pO1xuXHQgICAgfTtcblx0ICAgIEJhc2VQcm92aWRlci5wcm90b3R5cGUuZ2V0QmxvY2sgPSBmdW5jdGlvbiAoYmxvY2tIYXNoT3JCbG9ja1RhZykge1xuXHQgICAgICAgIHJldHVybiAodGhpcy5fZ2V0QmxvY2soYmxvY2tIYXNoT3JCbG9ja1RhZywgZmFsc2UpKTtcblx0ICAgIH07XG5cdCAgICBCYXNlUHJvdmlkZXIucHJvdG90eXBlLmdldEJsb2NrV2l0aFRyYW5zYWN0aW9ucyA9IGZ1bmN0aW9uIChibG9ja0hhc2hPckJsb2NrVGFnKSB7XG5cdCAgICAgICAgcmV0dXJuICh0aGlzLl9nZXRCbG9jayhibG9ja0hhc2hPckJsb2NrVGFnLCB0cnVlKSk7XG5cdCAgICB9O1xuXHQgICAgQmFzZVByb3ZpZGVyLnByb3RvdHlwZS5nZXRUcmFuc2FjdGlvbiA9IGZ1bmN0aW9uICh0cmFuc2FjdGlvbkhhc2gpIHtcblx0ICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIHZhciBwYXJhbXM7XG5cdCAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cdCAgICAgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcblx0ICAgICAgICAgICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcblx0ICAgICAgICAgICAgICAgICAgICBjYXNlIDA6IHJldHVybiBbNCAvKnlpZWxkKi8sIHRoaXMuZ2V0TmV0d29yaygpXTtcblx0ICAgICAgICAgICAgICAgICAgICBjYXNlIDE6XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIF9hLnNlbnQoKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgdHJhbnNhY3Rpb25IYXNoXTtcblx0ICAgICAgICAgICAgICAgICAgICBjYXNlIDI6XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHRyYW5zYWN0aW9uSGFzaCA9IF9hLnNlbnQoKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcGFyYW1zID0geyB0cmFuc2FjdGlvbkhhc2g6IHRoaXMuZm9ybWF0dGVyLmhhc2godHJhbnNhY3Rpb25IYXNoLCB0cnVlKSB9O1xuXHQgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgKDAsIGxpYiRxLnBvbGwpKGZ1bmN0aW9uICgpIHsgcmV0dXJuIF9fYXdhaXRlcihfdGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcmVzdWx0LCB0eCwgYmxvY2tOdW1iZXIsIGNvbmZpcm1hdGlvbnM7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKF9hLmxhYmVsKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDA6IHJldHVybiBbNCAvKnlpZWxkKi8sIHRoaXMucGVyZm9ybShcImdldFRyYW5zYWN0aW9uXCIsIHBhcmFtcyldO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAxOlxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IF9hLnNlbnQoKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocmVzdWx0ID09IG51bGwpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuX2VtaXR0ZWRbXCJ0OlwiICsgdHJhbnNhY3Rpb25IYXNoXSA9PSBudWxsKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgbnVsbF07XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIHVuZGVmaW5lZF07XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR4ID0gdGhpcy5mb3JtYXR0ZXIudHJhbnNhY3Rpb25SZXNwb25zZShyZXN1bHQpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghKHR4LmJsb2NrTnVtYmVyID09IG51bGwpKSByZXR1cm4gWzMgLypicmVhayovLCAyXTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eC5jb25maXJtYXRpb25zID0gMDtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzMgLypicmVhayovLCA0XTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMjpcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoISh0eC5jb25maXJtYXRpb25zID09IG51bGwpKSByZXR1cm4gWzMgLypicmVhayovLCA0XTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCB0aGlzLl9nZXRJbnRlcm5hbEJsb2NrTnVtYmVyKDEwMCArIDIgKiB0aGlzLnBvbGxpbmdJbnRlcnZhbCldO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAzOlxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJsb2NrTnVtYmVyID0gX2Euc2VudCgpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbmZpcm1hdGlvbnMgPSAoYmxvY2tOdW1iZXIgLSB0eC5ibG9ja051bWJlcikgKyAxO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjb25maXJtYXRpb25zIDw9IDApIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uZmlybWF0aW9ucyA9IDE7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR4LmNvbmZpcm1hdGlvbnMgPSBjb25maXJtYXRpb25zO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9hLmxhYmVsID0gNDtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgNDogcmV0dXJuIFsyIC8qcmV0dXJuKi8sIHRoaXMuX3dyYXBUcmFuc2FjdGlvbih0eCldO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTsgfSwgeyBvbmNlUG9sbDogdGhpcyB9KV07XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIH0pO1xuXHQgICAgICAgIH0pO1xuXHQgICAgfTtcblx0ICAgIEJhc2VQcm92aWRlci5wcm90b3R5cGUuZ2V0VHJhbnNhY3Rpb25SZWNlaXB0ID0gZnVuY3Rpb24gKHRyYW5zYWN0aW9uSGFzaCkge1xuXHQgICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgdmFyIHBhcmFtcztcblx0ICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcblx0ICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuXHQgICAgICAgICAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkge1xuXHQgICAgICAgICAgICAgICAgICAgIGNhc2UgMDogcmV0dXJuIFs0IC8qeWllbGQqLywgdGhpcy5nZXROZXR3b3JrKCldO1xuXHQgICAgICAgICAgICAgICAgICAgIGNhc2UgMTpcblx0ICAgICAgICAgICAgICAgICAgICAgICAgX2Euc2VudCgpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCB0cmFuc2FjdGlvbkhhc2hdO1xuXHQgICAgICAgICAgICAgICAgICAgIGNhc2UgMjpcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdHJhbnNhY3Rpb25IYXNoID0gX2Euc2VudCgpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBwYXJhbXMgPSB7IHRyYW5zYWN0aW9uSGFzaDogdGhpcy5mb3JtYXR0ZXIuaGFzaCh0cmFuc2FjdGlvbkhhc2gsIHRydWUpIH07XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCAoMCwgbGliJHEucG9sbCkoZnVuY3Rpb24gKCkgeyByZXR1cm4gX19hd2FpdGVyKF90aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciByZXN1bHQsIHJlY2VpcHQsIGJsb2NrTnVtYmVyLCBjb25maXJtYXRpb25zO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAwOiByZXR1cm4gWzQgLyp5aWVsZCovLCB0aGlzLnBlcmZvcm0oXCJnZXRUcmFuc2FjdGlvblJlY2VpcHRcIiwgcGFyYW1zKV07XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDE6XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gX2Euc2VudCgpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyZXN1bHQgPT0gbnVsbCkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5fZW1pdHRlZFtcInQ6XCIgKyB0cmFuc2FjdGlvbkhhc2hdID09IG51bGwpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCBudWxsXTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgdW5kZWZpbmVkXTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gXCJnZXRoLWV0Y1wiIHJldHVybnMgcmVjZWlwdHMgYmVmb3JlIHRoZXkgYXJlIHJlYWR5XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJlc3VsdC5ibG9ja0hhc2ggPT0gbnVsbCkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgdW5kZWZpbmVkXTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVjZWlwdCA9IHRoaXMuZm9ybWF0dGVyLnJlY2VpcHQocmVzdWx0KTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIShyZWNlaXB0LmJsb2NrTnVtYmVyID09IG51bGwpKSByZXR1cm4gWzMgLypicmVhayovLCAyXTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWNlaXB0LmNvbmZpcm1hdGlvbnMgPSAwO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMyAvKmJyZWFrKi8sIDRdO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAyOlxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghKHJlY2VpcHQuY29uZmlybWF0aW9ucyA9PSBudWxsKSkgcmV0dXJuIFszIC8qYnJlYWsqLywgNF07XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgdGhpcy5fZ2V0SW50ZXJuYWxCbG9ja051bWJlcigxMDAgKyAyICogdGhpcy5wb2xsaW5nSW50ZXJ2YWwpXTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMzpcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBibG9ja051bWJlciA9IF9hLnNlbnQoKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25maXJtYXRpb25zID0gKGJsb2NrTnVtYmVyIC0gcmVjZWlwdC5ibG9ja051bWJlcikgKyAxO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjb25maXJtYXRpb25zIDw9IDApIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uZmlybWF0aW9ucyA9IDE7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlY2VpcHQuY29uZmlybWF0aW9ucyA9IGNvbmZpcm1hdGlvbnM7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX2EubGFiZWwgPSA0O1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSA0OiByZXR1cm4gWzIgLypyZXR1cm4qLywgcmVjZWlwdF07XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pOyB9LCB7IG9uY2VQb2xsOiB0aGlzIH0pXTtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgfSk7XG5cdCAgICB9O1xuXHQgICAgQmFzZVByb3ZpZGVyLnByb3RvdHlwZS5nZXRMb2dzID0gZnVuY3Rpb24gKGZpbHRlcikge1xuXHQgICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgdmFyIHBhcmFtcywgbG9ncztcblx0ICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuXHQgICAgICAgICAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkge1xuXHQgICAgICAgICAgICAgICAgICAgIGNhc2UgMDogcmV0dXJuIFs0IC8qeWllbGQqLywgdGhpcy5nZXROZXR3b3JrKCldO1xuXHQgICAgICAgICAgICAgICAgICAgIGNhc2UgMTpcblx0ICAgICAgICAgICAgICAgICAgICAgICAgX2Euc2VudCgpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCAoMCwgbGliJDMucmVzb2x2ZVByb3BlcnRpZXMpKHsgZmlsdGVyOiB0aGlzLl9nZXRGaWx0ZXIoZmlsdGVyKSB9KV07XG5cdCAgICAgICAgICAgICAgICAgICAgY2FzZSAyOlxuXHQgICAgICAgICAgICAgICAgICAgICAgICBwYXJhbXMgPSBfYS5zZW50KCk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIHRoaXMucGVyZm9ybShcImdldExvZ3NcIiwgcGFyYW1zKV07XG5cdCAgICAgICAgICAgICAgICAgICAgY2FzZSAzOlxuXHQgICAgICAgICAgICAgICAgICAgICAgICBsb2dzID0gX2Euc2VudCgpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBsb2dzLmZvckVhY2goZnVuY3Rpb24gKGxvZykge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGxvZy5yZW1vdmVkID09IG51bGwpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsb2cucmVtb3ZlZCA9IGZhbHNlO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgICAgICB9KTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIGZvcm1hdHRlci5Gb3JtYXR0ZXIuYXJyYXlPZih0aGlzLmZvcm1hdHRlci5maWx0ZXJMb2cuYmluZCh0aGlzLmZvcm1hdHRlcikpKGxvZ3MpXTtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgfSk7XG5cdCAgICB9O1xuXHQgICAgQmFzZVByb3ZpZGVyLnByb3RvdHlwZS5nZXRFdGhlclByaWNlID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuXHQgICAgICAgICAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkge1xuXHQgICAgICAgICAgICAgICAgICAgIGNhc2UgMDogcmV0dXJuIFs0IC8qeWllbGQqLywgdGhpcy5nZXROZXR3b3JrKCldO1xuXHQgICAgICAgICAgICAgICAgICAgIGNhc2UgMTpcblx0ICAgICAgICAgICAgICAgICAgICAgICAgX2Euc2VudCgpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgdGhpcy5wZXJmb3JtKFwiZ2V0RXRoZXJQcmljZVwiLCB7fSldO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB9KTtcblx0ICAgICAgICB9KTtcblx0ICAgIH07XG5cdCAgICBCYXNlUHJvdmlkZXIucHJvdG90eXBlLl9nZXRCbG9ja1RhZyA9IGZ1bmN0aW9uIChibG9ja1RhZykge1xuXHQgICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgdmFyIGJsb2NrTnVtYmVyO1xuXHQgICAgICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG5cdCAgICAgICAgICAgICAgICBzd2l0Y2ggKF9hLmxhYmVsKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgY2FzZSAwOiByZXR1cm4gWzQgLyp5aWVsZCovLCBibG9ja1RhZ107XG5cdCAgICAgICAgICAgICAgICAgICAgY2FzZSAxOlxuXHQgICAgICAgICAgICAgICAgICAgICAgICBibG9ja1RhZyA9IF9hLnNlbnQoKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCEodHlwZW9mIChibG9ja1RhZykgPT09IFwibnVtYmVyXCIgJiYgYmxvY2tUYWcgPCAwKSkgcmV0dXJuIFszIC8qYnJlYWsqLywgM107XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGlmIChibG9ja1RhZyAlIDEpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJpbnZhbGlkIEJsb2NrVGFnXCIsIFwiYmxvY2tUYWdcIiwgYmxvY2tUYWcpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIHRoaXMuX2dldEludGVybmFsQmxvY2tOdW1iZXIoMTAwICsgMiAqIHRoaXMucG9sbGluZ0ludGVydmFsKV07XG5cdCAgICAgICAgICAgICAgICAgICAgY2FzZSAyOlxuXHQgICAgICAgICAgICAgICAgICAgICAgICBibG9ja051bWJlciA9IF9hLnNlbnQoKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgYmxvY2tOdW1iZXIgKz0gYmxvY2tUYWc7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGlmIChibG9ja051bWJlciA8IDApIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJsb2NrTnVtYmVyID0gMDtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgdGhpcy5mb3JtYXR0ZXIuYmxvY2tUYWcoYmxvY2tOdW1iZXIpXTtcblx0ICAgICAgICAgICAgICAgICAgICBjYXNlIDM6IHJldHVybiBbMiAvKnJldHVybiovLCB0aGlzLmZvcm1hdHRlci5ibG9ja1RhZyhibG9ja1RhZyldO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB9KTtcblx0ICAgICAgICB9KTtcblx0ICAgIH07XG5cdCAgICBCYXNlUHJvdmlkZXIucHJvdG90eXBlLmdldFJlc29sdmVyID0gZnVuY3Rpb24gKG5hbWUpIHtcblx0ICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIHZhciBhZGRyZXNzLCBlcnJvcl85O1xuXHQgICAgICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG5cdCAgICAgICAgICAgICAgICBzd2l0Y2ggKF9hLmxhYmVsKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgY2FzZSAwOlxuXHQgICAgICAgICAgICAgICAgICAgICAgICBfYS50cnlzLnB1c2goWzAsIDIsICwgM10pO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCB0aGlzLl9nZXRSZXNvbHZlcihuYW1lKV07XG5cdCAgICAgICAgICAgICAgICAgICAgY2FzZSAxOlxuXHQgICAgICAgICAgICAgICAgICAgICAgICBhZGRyZXNzID0gX2Euc2VudCgpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBpZiAoYWRkcmVzcyA9PSBudWxsKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgbnVsbF07XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIG5ldyBSZXNvbHZlcih0aGlzLCBhZGRyZXNzLCBuYW1lKV07XG5cdCAgICAgICAgICAgICAgICAgICAgY2FzZSAyOlxuXHQgICAgICAgICAgICAgICAgICAgICAgICBlcnJvcl85ID0gX2Euc2VudCgpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZXJyb3JfOS5jb2RlID09PSBsaWIuTG9nZ2VyLmVycm9ycy5DQUxMX0VYQ0VQVElPTikge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIG51bGxdO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCBudWxsXTtcblx0ICAgICAgICAgICAgICAgICAgICBjYXNlIDM6IHJldHVybiBbMiAvKnJldHVybiovXTtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgfSk7XG5cdCAgICB9O1xuXHQgICAgQmFzZVByb3ZpZGVyLnByb3RvdHlwZS5fZ2V0UmVzb2x2ZXIgPSBmdW5jdGlvbiAobmFtZSkge1xuXHQgICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgdmFyIG5ldHdvcmssIHRyYW5zYWN0aW9uLCBfYSwgX2IsIGVycm9yXzEwO1xuXHQgICAgICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9jKSB7XG5cdCAgICAgICAgICAgICAgICBzd2l0Y2ggKF9jLmxhYmVsKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgY2FzZSAwOiByZXR1cm4gWzQgLyp5aWVsZCovLCB0aGlzLmdldE5ldHdvcmsoKV07XG5cdCAgICAgICAgICAgICAgICAgICAgY2FzZSAxOlxuXHQgICAgICAgICAgICAgICAgICAgICAgICBuZXR3b3JrID0gX2Muc2VudCgpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAvLyBObyBFTlMuLi5cblx0ICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFuZXR3b3JrLmVuc0FkZHJlc3MpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxvZ2dlci50aHJvd0Vycm9yKFwibmV0d29yayBkb2VzIG5vdCBzdXBwb3J0IEVOU1wiLCBsaWIuTG9nZ2VyLmVycm9ycy5VTlNVUFBPUlRFRF9PUEVSQVRJT04sIHsgb3BlcmF0aW9uOiBcIkVOU1wiLCBuZXR3b3JrOiBuZXR3b3JrLm5hbWUgfSk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICAgICAgdHJhbnNhY3Rpb24gPSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB0bzogbmV0d29yay5lbnNBZGRyZXNzLFxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YTogKFwiMHgwMTc4YjhiZlwiICsgKDAsIGxpYiQ5Lm5hbWVoYXNoKShuYW1lKS5zdWJzdHJpbmcoMikpXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH07XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIF9jLmxhYmVsID0gMjtcblx0ICAgICAgICAgICAgICAgICAgICBjYXNlIDI6XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIF9jLnRyeXMucHVzaChbMiwgNCwgLCA1XSk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIF9iID0gKF9hID0gdGhpcy5mb3JtYXR0ZXIpLmNhbGxBZGRyZXNzO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCB0aGlzLmNhbGwodHJhbnNhY3Rpb24pXTtcblx0ICAgICAgICAgICAgICAgICAgICBjYXNlIDM6IHJldHVybiBbMiAvKnJldHVybiovLCBfYi5hcHBseShfYSwgW19jLnNlbnQoKV0pXTtcblx0ICAgICAgICAgICAgICAgICAgICBjYXNlIDQ6XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yXzEwID0gX2Muc2VudCgpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZXJyb3JfMTAuY29kZSA9PT0gbGliLkxvZ2dlci5lcnJvcnMuQ0FMTF9FWENFUFRJT04pIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCBudWxsXTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcl8xMDtcblx0ICAgICAgICAgICAgICAgICAgICBjYXNlIDU6IHJldHVybiBbMiAvKnJldHVybiovXTtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgfSk7XG5cdCAgICB9O1xuXHQgICAgQmFzZVByb3ZpZGVyLnByb3RvdHlwZS5yZXNvbHZlTmFtZSA9IGZ1bmN0aW9uIChuYW1lKSB7XG5cdCAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICB2YXIgcmVzb2x2ZXI7XG5cdCAgICAgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcblx0ICAgICAgICAgICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcblx0ICAgICAgICAgICAgICAgICAgICBjYXNlIDA6IHJldHVybiBbNCAvKnlpZWxkKi8sIG5hbWVdO1xuXHQgICAgICAgICAgICAgICAgICAgIGNhc2UgMTpcblx0ICAgICAgICAgICAgICAgICAgICAgICAgbmFtZSA9IF9hLnNlbnQoKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgLy8gSWYgaXQgaXMgYWxyZWFkeSBhbiBhZGRyZXNzLCBub3RoaW5nIHRvIHJlc29sdmVcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdHJ5IHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCBQcm9taXNlLnJlc29sdmUodGhpcy5mb3JtYXR0ZXIuYWRkcmVzcyhuYW1lKSldO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gSWYgaXMgaXMgYSBoZXhzdHJpbmcsIHRoZSBhZGRyZXNzIGlzIGJhZCAoU2VlICM2OTQpXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoKDAsIGxpYiQxLmlzSGV4U3RyaW5nKShuYW1lKSkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IGVycm9yO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgKG5hbWUpICE9PSBcInN0cmluZ1wiKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwiaW52YWxpZCBFTlMgbmFtZVwiLCBcIm5hbWVcIiwgbmFtZSk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgdGhpcy5nZXRSZXNvbHZlcihuYW1lKV07XG5cdCAgICAgICAgICAgICAgICAgICAgY2FzZSAyOlxuXHQgICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlciA9IF9hLnNlbnQoKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFyZXNvbHZlcikge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIG51bGxdO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIHJlc29sdmVyLmdldEFkZHJlc3MoKV07XG5cdCAgICAgICAgICAgICAgICAgICAgY2FzZSAzOiByZXR1cm4gWzIgLypyZXR1cm4qLywgX2Euc2VudCgpXTtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgfSk7XG5cdCAgICB9O1xuXHQgICAgQmFzZVByb3ZpZGVyLnByb3RvdHlwZS5sb29rdXBBZGRyZXNzID0gZnVuY3Rpb24gKGFkZHJlc3MpIHtcblx0ICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIHZhciByZXZlcnNlTmFtZSwgcmVzb2x2ZXJBZGRyZXNzLCBieXRlcywgX2EsIGxlbmd0aCwgbmFtZSwgYWRkcjtcblx0ICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYikge1xuXHQgICAgICAgICAgICAgICAgc3dpdGNoIChfYi5sYWJlbCkge1xuXHQgICAgICAgICAgICAgICAgICAgIGNhc2UgMDogcmV0dXJuIFs0IC8qeWllbGQqLywgYWRkcmVzc107XG5cdCAgICAgICAgICAgICAgICAgICAgY2FzZSAxOlxuXHQgICAgICAgICAgICAgICAgICAgICAgICBhZGRyZXNzID0gX2Iuc2VudCgpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBhZGRyZXNzID0gdGhpcy5mb3JtYXR0ZXIuYWRkcmVzcyhhZGRyZXNzKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcmV2ZXJzZU5hbWUgPSBhZGRyZXNzLnN1YnN0cmluZygyKS50b0xvd2VyQ2FzZSgpICsgXCIuYWRkci5yZXZlcnNlXCI7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIHRoaXMuX2dldFJlc29sdmVyKHJldmVyc2VOYW1lKV07XG5cdCAgICAgICAgICAgICAgICAgICAgY2FzZSAyOlxuXHQgICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlckFkZHJlc3MgPSBfYi5zZW50KCk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGlmICghcmVzb2x2ZXJBZGRyZXNzKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgbnVsbF07XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICAgICAgX2EgPSBsaWIkMS5hcnJheWlmeTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgdGhpcy5jYWxsKHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0bzogcmVzb2x2ZXJBZGRyZXNzLFxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGE6IChcIjB4NjkxZjM0MzFcIiArICgwLCBsaWIkOS5uYW1laGFzaCkocmV2ZXJzZU5hbWUpLnN1YnN0cmluZygyKSlcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pXTtcblx0ICAgICAgICAgICAgICAgICAgICBjYXNlIDM6XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGJ5dGVzID0gX2EuYXBwbHkodm9pZCAwLCBbX2Iuc2VudCgpXSk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIC8vIFN0cmlwIG9mZiB0aGUgZHluYW1pYyBzdHJpbmcgcG9pbnRlciAoMHgyMClcblx0ICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGJ5dGVzLmxlbmd0aCA8IDMyIHx8ICFsaWIkMi5CaWdOdW1iZXIuZnJvbShieXRlcy5zbGljZSgwLCAzMikpLmVxKDMyKSkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIG51bGxdO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGJ5dGVzID0gYnl0ZXMuc2xpY2UoMzIpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAvLyBOb3QgYSBsZW5ndGgtcHJlZml4ZWQgc3RyaW5nXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGlmIChieXRlcy5sZW5ndGggPCAzMikge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIG51bGxdO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGxlbmd0aCA9IGxpYiQyLkJpZ051bWJlci5mcm9tKGJ5dGVzLnNsaWNlKDAsIDMyKSkudG9OdW1iZXIoKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgYnl0ZXMgPSBieXRlcy5zbGljZSgzMik7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIC8vIExlbmd0aCBsb25nZXIgdGhhbiBhdmFpbGFibGUgZGF0YVxuXHQgICAgICAgICAgICAgICAgICAgICAgICBpZiAobGVuZ3RoID4gYnl0ZXMubGVuZ3RoKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgbnVsbF07XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICAgICAgbmFtZSA9ICgwLCBsaWIkOC50b1V0ZjhTdHJpbmcpKGJ5dGVzLnNsaWNlKDAsIGxlbmd0aCkpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCB0aGlzLnJlc29sdmVOYW1lKG5hbWUpXTtcblx0ICAgICAgICAgICAgICAgICAgICBjYXNlIDQ6XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGFkZHIgPSBfYi5zZW50KCk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGlmIChhZGRyICE9IGFkZHJlc3MpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCBudWxsXTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgbmFtZV07XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIH0pO1xuXHQgICAgICAgIH0pO1xuXHQgICAgfTtcblx0ICAgIEJhc2VQcm92aWRlci5wcm90b3R5cGUuZ2V0QXZhdGFyID0gZnVuY3Rpb24gKG5hbWVPckFkZHJlc3MpIHtcblx0ICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIHZhciByZXNvbHZlciwgYWRkcmVzcywgcmV2ZXJzZU5hbWUsIHJlc29sdmVyQWRkcmVzcywgYXZhdGFyO1xuXHQgICAgICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG5cdCAgICAgICAgICAgICAgICBzd2l0Y2ggKF9hLmxhYmVsKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgY2FzZSAwOlxuXHQgICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlciA9IG51bGw7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGlmICghKDAsIGxpYiQxLmlzSGV4U3RyaW5nKShuYW1lT3JBZGRyZXNzKSkgcmV0dXJuIFszIC8qYnJlYWsqLywgMl07XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGFkZHJlc3MgPSB0aGlzLmZvcm1hdHRlci5hZGRyZXNzKG5hbWVPckFkZHJlc3MpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICByZXZlcnNlTmFtZSA9IGFkZHJlc3Muc3Vic3RyaW5nKDIpLnRvTG93ZXJDYXNlKCkgKyBcIi5hZGRyLnJldmVyc2VcIjtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgdGhpcy5fZ2V0UmVzb2x2ZXIocmV2ZXJzZU5hbWUpXTtcblx0ICAgICAgICAgICAgICAgICAgICBjYXNlIDE6XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmVyQWRkcmVzcyA9IF9hLnNlbnQoKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFyZXNvbHZlckFkZHJlc3MpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCBudWxsXTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlciA9IG5ldyBSZXNvbHZlcih0aGlzLCByZXNvbHZlckFkZHJlc3MsIFwiX1wiLCBhZGRyZXNzKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFszIC8qYnJlYWsqLywgNF07XG5cdCAgICAgICAgICAgICAgICAgICAgY2FzZSAyOiByZXR1cm4gWzQgLyp5aWVsZCovLCB0aGlzLmdldFJlc29sdmVyKG5hbWVPckFkZHJlc3MpXTtcblx0ICAgICAgICAgICAgICAgICAgICBjYXNlIDM6XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIC8vIEVOUyBuYW1lOyBmb3J3YXJkIGxvb2t1cFxuXHQgICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlciA9IF9hLnNlbnQoKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgX2EubGFiZWwgPSA0O1xuXHQgICAgICAgICAgICAgICAgICAgIGNhc2UgNDogcmV0dXJuIFs0IC8qeWllbGQqLywgcmVzb2x2ZXIuZ2V0QXZhdGFyKCldO1xuXHQgICAgICAgICAgICAgICAgICAgIGNhc2UgNTpcblx0ICAgICAgICAgICAgICAgICAgICAgICAgYXZhdGFyID0gX2Euc2VudCgpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBpZiAoYXZhdGFyID09IG51bGwpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCBudWxsXTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgYXZhdGFyLnVybF07XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIH0pO1xuXHQgICAgICAgIH0pO1xuXHQgICAgfTtcblx0ICAgIEJhc2VQcm92aWRlci5wcm90b3R5cGUucGVyZm9ybSA9IGZ1bmN0aW9uIChtZXRob2QsIHBhcmFtcykge1xuXHQgICAgICAgIHJldHVybiBsb2dnZXIudGhyb3dFcnJvcihtZXRob2QgKyBcIiBub3QgaW1wbGVtZW50ZWRcIiwgbGliLkxvZ2dlci5lcnJvcnMuTk9UX0lNUExFTUVOVEVELCB7IG9wZXJhdGlvbjogbWV0aG9kIH0pO1xuXHQgICAgfTtcblx0ICAgIEJhc2VQcm92aWRlci5wcm90b3R5cGUuX3N0YXJ0RXZlbnQgPSBmdW5jdGlvbiAoZXZlbnQpIHtcblx0ICAgICAgICB0aGlzLnBvbGxpbmcgPSAodGhpcy5fZXZlbnRzLmZpbHRlcihmdW5jdGlvbiAoZSkgeyByZXR1cm4gZS5wb2xsYWJsZSgpOyB9KS5sZW5ndGggPiAwKTtcblx0ICAgIH07XG5cdCAgICBCYXNlUHJvdmlkZXIucHJvdG90eXBlLl9zdG9wRXZlbnQgPSBmdW5jdGlvbiAoZXZlbnQpIHtcblx0ICAgICAgICB0aGlzLnBvbGxpbmcgPSAodGhpcy5fZXZlbnRzLmZpbHRlcihmdW5jdGlvbiAoZSkgeyByZXR1cm4gZS5wb2xsYWJsZSgpOyB9KS5sZW5ndGggPiAwKTtcblx0ICAgIH07XG5cdCAgICBCYXNlUHJvdmlkZXIucHJvdG90eXBlLl9hZGRFdmVudExpc3RlbmVyID0gZnVuY3Rpb24gKGV2ZW50TmFtZSwgbGlzdGVuZXIsIG9uY2UpIHtcblx0ICAgICAgICB2YXIgZXZlbnQgPSBuZXcgRXZlbnQoZ2V0RXZlbnRUYWcoZXZlbnROYW1lKSwgbGlzdGVuZXIsIG9uY2UpO1xuXHQgICAgICAgIHRoaXMuX2V2ZW50cy5wdXNoKGV2ZW50KTtcblx0ICAgICAgICB0aGlzLl9zdGFydEV2ZW50KGV2ZW50KTtcblx0ICAgICAgICByZXR1cm4gdGhpcztcblx0ICAgIH07XG5cdCAgICBCYXNlUHJvdmlkZXIucHJvdG90eXBlLm9uID0gZnVuY3Rpb24gKGV2ZW50TmFtZSwgbGlzdGVuZXIpIHtcblx0ICAgICAgICByZXR1cm4gdGhpcy5fYWRkRXZlbnRMaXN0ZW5lcihldmVudE5hbWUsIGxpc3RlbmVyLCBmYWxzZSk7XG5cdCAgICB9O1xuXHQgICAgQmFzZVByb3ZpZGVyLnByb3RvdHlwZS5vbmNlID0gZnVuY3Rpb24gKGV2ZW50TmFtZSwgbGlzdGVuZXIpIHtcblx0ICAgICAgICByZXR1cm4gdGhpcy5fYWRkRXZlbnRMaXN0ZW5lcihldmVudE5hbWUsIGxpc3RlbmVyLCB0cnVlKTtcblx0ICAgIH07XG5cdCAgICBCYXNlUHJvdmlkZXIucHJvdG90eXBlLmVtaXQgPSBmdW5jdGlvbiAoZXZlbnROYW1lKSB7XG5cdCAgICAgICAgdmFyIF90aGlzID0gdGhpcztcblx0ICAgICAgICB2YXIgYXJncyA9IFtdO1xuXHQgICAgICAgIGZvciAodmFyIF9pID0gMTsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG5cdCAgICAgICAgICAgIGFyZ3NbX2kgLSAxXSA9IGFyZ3VtZW50c1tfaV07XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHZhciByZXN1bHQgPSBmYWxzZTtcblx0ICAgICAgICB2YXIgc3RvcHBlZCA9IFtdO1xuXHQgICAgICAgIHZhciBldmVudFRhZyA9IGdldEV2ZW50VGFnKGV2ZW50TmFtZSk7XG5cdCAgICAgICAgdGhpcy5fZXZlbnRzID0gdGhpcy5fZXZlbnRzLmZpbHRlcihmdW5jdGlvbiAoZXZlbnQpIHtcblx0ICAgICAgICAgICAgaWYgKGV2ZW50LnRhZyAhPT0gZXZlbnRUYWcpIHtcblx0ICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICAgICAgZXZlbnQubGlzdGVuZXIuYXBwbHkoX3RoaXMsIGFyZ3MpO1xuXHQgICAgICAgICAgICB9LCAwKTtcblx0ICAgICAgICAgICAgcmVzdWx0ID0gdHJ1ZTtcblx0ICAgICAgICAgICAgaWYgKGV2ZW50Lm9uY2UpIHtcblx0ICAgICAgICAgICAgICAgIHN0b3BwZWQucHVzaChldmVudCk7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgcmV0dXJuIHRydWU7XG5cdCAgICAgICAgfSk7XG5cdCAgICAgICAgc3RvcHBlZC5mb3JFYWNoKGZ1bmN0aW9uIChldmVudCkgeyBfdGhpcy5fc3RvcEV2ZW50KGV2ZW50KTsgfSk7XG5cdCAgICAgICAgcmV0dXJuIHJlc3VsdDtcblx0ICAgIH07XG5cdCAgICBCYXNlUHJvdmlkZXIucHJvdG90eXBlLmxpc3RlbmVyQ291bnQgPSBmdW5jdGlvbiAoZXZlbnROYW1lKSB7XG5cdCAgICAgICAgaWYgKCFldmVudE5hbWUpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2V2ZW50cy5sZW5ndGg7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHZhciBldmVudFRhZyA9IGdldEV2ZW50VGFnKGV2ZW50TmFtZSk7XG5cdCAgICAgICAgcmV0dXJuIHRoaXMuX2V2ZW50cy5maWx0ZXIoZnVuY3Rpb24gKGV2ZW50KSB7XG5cdCAgICAgICAgICAgIHJldHVybiAoZXZlbnQudGFnID09PSBldmVudFRhZyk7XG5cdCAgICAgICAgfSkubGVuZ3RoO1xuXHQgICAgfTtcblx0ICAgIEJhc2VQcm92aWRlci5wcm90b3R5cGUubGlzdGVuZXJzID0gZnVuY3Rpb24gKGV2ZW50TmFtZSkge1xuXHQgICAgICAgIGlmIChldmVudE5hbWUgPT0gbnVsbCkge1xuXHQgICAgICAgICAgICByZXR1cm4gdGhpcy5fZXZlbnRzLm1hcChmdW5jdGlvbiAoZXZlbnQpIHsgcmV0dXJuIGV2ZW50Lmxpc3RlbmVyOyB9KTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgdmFyIGV2ZW50VGFnID0gZ2V0RXZlbnRUYWcoZXZlbnROYW1lKTtcblx0ICAgICAgICByZXR1cm4gdGhpcy5fZXZlbnRzXG5cdCAgICAgICAgICAgIC5maWx0ZXIoZnVuY3Rpb24gKGV2ZW50KSB7IHJldHVybiAoZXZlbnQudGFnID09PSBldmVudFRhZyk7IH0pXG5cdCAgICAgICAgICAgIC5tYXAoZnVuY3Rpb24gKGV2ZW50KSB7IHJldHVybiBldmVudC5saXN0ZW5lcjsgfSk7XG5cdCAgICB9O1xuXHQgICAgQmFzZVByb3ZpZGVyLnByb3RvdHlwZS5vZmYgPSBmdW5jdGlvbiAoZXZlbnROYW1lLCBsaXN0ZW5lcikge1xuXHQgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cdCAgICAgICAgaWYgKGxpc3RlbmVyID09IG51bGwpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIHRoaXMucmVtb3ZlQWxsTGlzdGVuZXJzKGV2ZW50TmFtZSk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHZhciBzdG9wcGVkID0gW107XG5cdCAgICAgICAgdmFyIGZvdW5kID0gZmFsc2U7XG5cdCAgICAgICAgdmFyIGV2ZW50VGFnID0gZ2V0RXZlbnRUYWcoZXZlbnROYW1lKTtcblx0ICAgICAgICB0aGlzLl9ldmVudHMgPSB0aGlzLl9ldmVudHMuZmlsdGVyKGZ1bmN0aW9uIChldmVudCkge1xuXHQgICAgICAgICAgICBpZiAoZXZlbnQudGFnICE9PSBldmVudFRhZyB8fCBldmVudC5saXN0ZW5lciAhPSBsaXN0ZW5lcikge1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgaWYgKGZvdW5kKSB7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICBmb3VuZCA9IHRydWU7XG5cdCAgICAgICAgICAgIHN0b3BwZWQucHVzaChldmVudCk7XG5cdCAgICAgICAgICAgIHJldHVybiBmYWxzZTtcblx0ICAgICAgICB9KTtcblx0ICAgICAgICBzdG9wcGVkLmZvckVhY2goZnVuY3Rpb24gKGV2ZW50KSB7IF90aGlzLl9zdG9wRXZlbnQoZXZlbnQpOyB9KTtcblx0ICAgICAgICByZXR1cm4gdGhpcztcblx0ICAgIH07XG5cdCAgICBCYXNlUHJvdmlkZXIucHJvdG90eXBlLnJlbW92ZUFsbExpc3RlbmVycyA9IGZ1bmN0aW9uIChldmVudE5hbWUpIHtcblx0ICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXHQgICAgICAgIHZhciBzdG9wcGVkID0gW107XG5cdCAgICAgICAgaWYgKGV2ZW50TmFtZSA9PSBudWxsKSB7XG5cdCAgICAgICAgICAgIHN0b3BwZWQgPSB0aGlzLl9ldmVudHM7XG5cdCAgICAgICAgICAgIHRoaXMuX2V2ZW50cyA9IFtdO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBlbHNlIHtcblx0ICAgICAgICAgICAgdmFyIGV2ZW50VGFnXzEgPSBnZXRFdmVudFRhZyhldmVudE5hbWUpO1xuXHQgICAgICAgICAgICB0aGlzLl9ldmVudHMgPSB0aGlzLl9ldmVudHMuZmlsdGVyKGZ1bmN0aW9uIChldmVudCkge1xuXHQgICAgICAgICAgICAgICAgaWYgKGV2ZW50LnRhZyAhPT0gZXZlbnRUYWdfMSkge1xuXHQgICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgc3RvcHBlZC5wdXNoKGV2ZW50KTtcblx0ICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcblx0ICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHN0b3BwZWQuZm9yRWFjaChmdW5jdGlvbiAoZXZlbnQpIHsgX3RoaXMuX3N0b3BFdmVudChldmVudCk7IH0pO1xuXHQgICAgICAgIHJldHVybiB0aGlzO1xuXHQgICAgfTtcblx0ICAgIHJldHVybiBCYXNlUHJvdmlkZXI7XG5cdH0obGliJGIuUHJvdmlkZXIpKTtcblx0ZXhwb3J0cy5CYXNlUHJvdmlkZXIgPSBCYXNlUHJvdmlkZXI7XG5cblx0fSk7XG5cblx0dmFyIGJhc2VQcm92aWRlciQxID0gLypAX19QVVJFX18qL2dldERlZmF1bHRFeHBvcnRGcm9tQ2pzKGJhc2VQcm92aWRlcik7XG5cblx0dmFyIGpzb25ScGNQcm92aWRlciA9IGNyZWF0ZUNvbW1vbmpzTW9kdWxlKGZ1bmN0aW9uIChtb2R1bGUsIGV4cG9ydHMpIHtcblx0XCJ1c2Ugc3RyaWN0XCI7XG5cdHZhciBfX2V4dGVuZHMgPSAoY29tbW9uanNHbG9iYWwgJiYgY29tbW9uanNHbG9iYWwuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuXHQgICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBmdW5jdGlvbiAoZCwgYikge1xuXHQgICAgICAgIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcblx0ICAgICAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuXHQgICAgICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoYiwgcCkpIGRbcF0gPSBiW3BdOyB9O1xuXHQgICAgICAgIHJldHVybiBleHRlbmRTdGF0aWNzKGQsIGIpO1xuXHQgICAgfTtcblx0ICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuXHQgICAgICAgIGlmICh0eXBlb2YgYiAhPT0gXCJmdW5jdGlvblwiICYmIGIgIT09IG51bGwpXG5cdCAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDbGFzcyBleHRlbmRzIHZhbHVlIFwiICsgU3RyaW5nKGIpICsgXCIgaXMgbm90IGEgY29uc3RydWN0b3Igb3IgbnVsbFwiKTtcblx0ICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuXHQgICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuXHQgICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcblx0ICAgIH07XG5cdH0pKCk7XG5cdHZhciBfX2F3YWl0ZXIgPSAoY29tbW9uanNHbG9iYWwgJiYgY29tbW9uanNHbG9iYWwuX19hd2FpdGVyKSB8fCBmdW5jdGlvbiAodGhpc0FyZywgX2FyZ3VtZW50cywgUCwgZ2VuZXJhdG9yKSB7XG5cdCAgICBmdW5jdGlvbiBhZG9wdCh2YWx1ZSkgeyByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBQID8gdmFsdWUgOiBuZXcgUChmdW5jdGlvbiAocmVzb2x2ZSkgeyByZXNvbHZlKHZhbHVlKTsgfSk7IH1cblx0ICAgIHJldHVybiBuZXcgKFAgfHwgKFAgPSBQcm9taXNlKSkoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuXHQgICAgICAgIGZ1bmN0aW9uIGZ1bGZpbGxlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvci5uZXh0KHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cblx0ICAgICAgICBmdW5jdGlvbiByZWplY3RlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvcltcInRocm93XCJdKHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cblx0ICAgICAgICBmdW5jdGlvbiBzdGVwKHJlc3VsdCkgeyByZXN1bHQuZG9uZSA/IHJlc29sdmUocmVzdWx0LnZhbHVlKSA6IGFkb3B0KHJlc3VsdC52YWx1ZSkudGhlbihmdWxmaWxsZWQsIHJlamVjdGVkKTsgfVxuXHQgICAgICAgIHN0ZXAoKGdlbmVyYXRvciA9IGdlbmVyYXRvci5hcHBseSh0aGlzQXJnLCBfYXJndW1lbnRzIHx8IFtdKSkubmV4dCgpKTtcblx0ICAgIH0pO1xuXHR9O1xuXHR2YXIgX19nZW5lcmF0b3IgPSAoY29tbW9uanNHbG9iYWwgJiYgY29tbW9uanNHbG9iYWwuX19nZW5lcmF0b3IpIHx8IGZ1bmN0aW9uICh0aGlzQXJnLCBib2R5KSB7XG5cdCAgICB2YXIgXyA9IHsgbGFiZWw6IDAsIHNlbnQ6IGZ1bmN0aW9uKCkgeyBpZiAodFswXSAmIDEpIHRocm93IHRbMV07IHJldHVybiB0WzFdOyB9LCB0cnlzOiBbXSwgb3BzOiBbXSB9LCBmLCB5LCB0LCBnO1xuXHQgICAgcmV0dXJuIGcgPSB7IG5leHQ6IHZlcmIoMCksIFwidGhyb3dcIjogdmVyYigxKSwgXCJyZXR1cm5cIjogdmVyYigyKSB9LCB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgKGdbU3ltYm9sLml0ZXJhdG9yXSA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpczsgfSksIGc7XG5cdCAgICBmdW5jdGlvbiB2ZXJiKG4pIHsgcmV0dXJuIGZ1bmN0aW9uICh2KSB7IHJldHVybiBzdGVwKFtuLCB2XSk7IH07IH1cblx0ICAgIGZ1bmN0aW9uIHN0ZXAob3ApIHtcblx0ICAgICAgICBpZiAoZikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkdlbmVyYXRvciBpcyBhbHJlYWR5IGV4ZWN1dGluZy5cIik7XG5cdCAgICAgICAgd2hpbGUgKF8pIHRyeSB7XG5cdCAgICAgICAgICAgIGlmIChmID0gMSwgeSAmJiAodCA9IG9wWzBdICYgMiA/IHlbXCJyZXR1cm5cIl0gOiBvcFswXSA/IHlbXCJ0aHJvd1wiXSB8fCAoKHQgPSB5W1wicmV0dXJuXCJdKSAmJiB0LmNhbGwoeSksIDApIDogeS5uZXh0KSAmJiAhKHQgPSB0LmNhbGwoeSwgb3BbMV0pKS5kb25lKSByZXR1cm4gdDtcblx0ICAgICAgICAgICAgaWYgKHkgPSAwLCB0KSBvcCA9IFtvcFswXSAmIDIsIHQudmFsdWVdO1xuXHQgICAgICAgICAgICBzd2l0Y2ggKG9wWzBdKSB7XG5cdCAgICAgICAgICAgICAgICBjYXNlIDA6IGNhc2UgMTogdCA9IG9wOyBicmVhaztcblx0ICAgICAgICAgICAgICAgIGNhc2UgNDogXy5sYWJlbCsrOyByZXR1cm4geyB2YWx1ZTogb3BbMV0sIGRvbmU6IGZhbHNlIH07XG5cdCAgICAgICAgICAgICAgICBjYXNlIDU6IF8ubGFiZWwrKzsgeSA9IG9wWzFdOyBvcCA9IFswXTsgY29udGludWU7XG5cdCAgICAgICAgICAgICAgICBjYXNlIDc6IG9wID0gXy5vcHMucG9wKCk7IF8udHJ5cy5wb3AoKTsgY29udGludWU7XG5cdCAgICAgICAgICAgICAgICBkZWZhdWx0OlxuXHQgICAgICAgICAgICAgICAgICAgIGlmICghKHQgPSBfLnRyeXMsIHQgPSB0Lmxlbmd0aCA+IDAgJiYgdFt0Lmxlbmd0aCAtIDFdKSAmJiAob3BbMF0gPT09IDYgfHwgb3BbMF0gPT09IDIpKSB7IF8gPSAwOyBjb250aW51ZTsgfVxuXHQgICAgICAgICAgICAgICAgICAgIGlmIChvcFswXSA9PT0gMyAmJiAoIXQgfHwgKG9wWzFdID4gdFswXSAmJiBvcFsxXSA8IHRbM10pKSkgeyBfLmxhYmVsID0gb3BbMV07IGJyZWFrOyB9XG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKG9wWzBdID09PSA2ICYmIF8ubGFiZWwgPCB0WzFdKSB7IF8ubGFiZWwgPSB0WzFdOyB0ID0gb3A7IGJyZWFrOyB9XG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKHQgJiYgXy5sYWJlbCA8IHRbMl0pIHsgXy5sYWJlbCA9IHRbMl07IF8ub3BzLnB1c2gob3ApOyBicmVhazsgfVxuXHQgICAgICAgICAgICAgICAgICAgIGlmICh0WzJdKSBfLm9wcy5wb3AoKTtcblx0ICAgICAgICAgICAgICAgICAgICBfLnRyeXMucG9wKCk7IGNvbnRpbnVlO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIG9wID0gYm9keS5jYWxsKHRoaXNBcmcsIF8pO1xuXHQgICAgICAgIH0gY2F0Y2ggKGUpIHsgb3AgPSBbNiwgZV07IHkgPSAwOyB9IGZpbmFsbHkgeyBmID0gdCA9IDA7IH1cblx0ICAgICAgICBpZiAob3BbMF0gJiA1KSB0aHJvdyBvcFsxXTsgcmV0dXJuIHsgdmFsdWU6IG9wWzBdID8gb3BbMV0gOiB2b2lkIDAsIGRvbmU6IHRydWUgfTtcblx0ICAgIH1cblx0fTtcblx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuXHRleHBvcnRzLkpzb25ScGNQcm92aWRlciA9IGV4cG9ydHMuSnNvblJwY1NpZ25lciA9IHZvaWQgMDtcblxuXG5cblxuXG5cblxuXG5cblxuXHR2YXIgbG9nZ2VyID0gbmV3IGxpYi5Mb2dnZXIoX3ZlcnNpb24kSS52ZXJzaW9uKTtcblxuXHR2YXIgZXJyb3JHYXMgPSBbXCJjYWxsXCIsIFwiZXN0aW1hdGVHYXNcIl07XG5cdGZ1bmN0aW9uIGNoZWNrRXJyb3IobWV0aG9kLCBlcnJvciwgcGFyYW1zKSB7XG5cdCAgICAvLyBVbmRvIHRoZSBcImNvbnZlbmllbmNlXCIgc29tZSBub2RlcyBhcmUgYXR0ZW1wdGluZyB0byBwcmV2ZW50IGJhY2t3YXJkc1xuXHQgICAgLy8gaW5jb21wYXRpYmlsaXR5OyBtYXliZSBmb3IgdjYgY29uc2lkZXIgZm9yd2FyZGluZyByZXZlcnRzIGFzIGVycm9yc1xuXHQgICAgaWYgKG1ldGhvZCA9PT0gXCJjYWxsXCIgJiYgZXJyb3IuY29kZSA9PT0gbGliLkxvZ2dlci5lcnJvcnMuU0VSVkVSX0VSUk9SKSB7XG5cdCAgICAgICAgdmFyIGUgPSBlcnJvci5lcnJvcjtcblx0ICAgICAgICBpZiAoZSAmJiBlLm1lc3NhZ2UubWF0Y2goXCJyZXZlcnRlZFwiKSAmJiAoMCwgbGliJDEuaXNIZXhTdHJpbmcpKGUuZGF0YSkpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIGUuZGF0YTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgbG9nZ2VyLnRocm93RXJyb3IoXCJtaXNzaW5nIHJldmVydCBkYXRhIGluIGNhbGwgZXhjZXB0aW9uXCIsIGxpYi5Mb2dnZXIuZXJyb3JzLkNBTExfRVhDRVBUSU9OLCB7XG5cdCAgICAgICAgICAgIGVycm9yOiBlcnJvcixcblx0ICAgICAgICAgICAgZGF0YTogXCIweFwiXG5cdCAgICAgICAgfSk7XG5cdCAgICB9XG5cdCAgICB2YXIgbWVzc2FnZSA9IGVycm9yLm1lc3NhZ2U7XG5cdCAgICBpZiAoZXJyb3IuY29kZSA9PT0gbGliLkxvZ2dlci5lcnJvcnMuU0VSVkVSX0VSUk9SICYmIGVycm9yLmVycm9yICYmIHR5cGVvZiAoZXJyb3IuZXJyb3IubWVzc2FnZSkgPT09IFwic3RyaW5nXCIpIHtcblx0ICAgICAgICBtZXNzYWdlID0gZXJyb3IuZXJyb3IubWVzc2FnZTtcblx0ICAgIH1cblx0ICAgIGVsc2UgaWYgKHR5cGVvZiAoZXJyb3IuYm9keSkgPT09IFwic3RyaW5nXCIpIHtcblx0ICAgICAgICBtZXNzYWdlID0gZXJyb3IuYm9keTtcblx0ICAgIH1cblx0ICAgIGVsc2UgaWYgKHR5cGVvZiAoZXJyb3IucmVzcG9uc2VUZXh0KSA9PT0gXCJzdHJpbmdcIikge1xuXHQgICAgICAgIG1lc3NhZ2UgPSBlcnJvci5yZXNwb25zZVRleHQ7XG5cdCAgICB9XG5cdCAgICBtZXNzYWdlID0gKG1lc3NhZ2UgfHwgXCJcIikudG9Mb3dlckNhc2UoKTtcblx0ICAgIHZhciB0cmFuc2FjdGlvbiA9IHBhcmFtcy50cmFuc2FjdGlvbiB8fCBwYXJhbXMuc2lnbmVkVHJhbnNhY3Rpb247XG5cdCAgICAvLyBcImluc3VmZmljaWVudCBmdW5kcyBmb3IgZ2FzICogcHJpY2UgKyB2YWx1ZSArIGNvc3QoZGF0YSlcIlxuXHQgICAgaWYgKG1lc3NhZ2UubWF0Y2goL2luc3VmZmljaWVudCBmdW5kc3xiYXNlIGZlZSBleGNlZWRzIGdhcyBsaW1pdC8pKSB7XG5cdCAgICAgICAgbG9nZ2VyLnRocm93RXJyb3IoXCJpbnN1ZmZpY2llbnQgZnVuZHMgZm9yIGludHJpbnNpYyB0cmFuc2FjdGlvbiBjb3N0XCIsIGxpYi5Mb2dnZXIuZXJyb3JzLklOU1VGRklDSUVOVF9GVU5EUywge1xuXHQgICAgICAgICAgICBlcnJvcjogZXJyb3IsXG5cdCAgICAgICAgICAgIG1ldGhvZDogbWV0aG9kLFxuXHQgICAgICAgICAgICB0cmFuc2FjdGlvbjogdHJhbnNhY3Rpb25cblx0ICAgICAgICB9KTtcblx0ICAgIH1cblx0ICAgIC8vIFwibm9uY2UgdG9vIGxvd1wiXG5cdCAgICBpZiAobWVzc2FnZS5tYXRjaCgvbm9uY2UgdG9vIGxvdy8pKSB7XG5cdCAgICAgICAgbG9nZ2VyLnRocm93RXJyb3IoXCJub25jZSBoYXMgYWxyZWFkeSBiZWVuIHVzZWRcIiwgbGliLkxvZ2dlci5lcnJvcnMuTk9OQ0VfRVhQSVJFRCwge1xuXHQgICAgICAgICAgICBlcnJvcjogZXJyb3IsXG5cdCAgICAgICAgICAgIG1ldGhvZDogbWV0aG9kLFxuXHQgICAgICAgICAgICB0cmFuc2FjdGlvbjogdHJhbnNhY3Rpb25cblx0ICAgICAgICB9KTtcblx0ICAgIH1cblx0ICAgIC8vIFwicmVwbGFjZW1lbnQgdHJhbnNhY3Rpb24gdW5kZXJwcmljZWRcIlxuXHQgICAgaWYgKG1lc3NhZ2UubWF0Y2goL3JlcGxhY2VtZW50IHRyYW5zYWN0aW9uIHVuZGVycHJpY2VkLykpIHtcblx0ICAgICAgICBsb2dnZXIudGhyb3dFcnJvcihcInJlcGxhY2VtZW50IGZlZSB0b28gbG93XCIsIGxpYi5Mb2dnZXIuZXJyb3JzLlJFUExBQ0VNRU5UX1VOREVSUFJJQ0VELCB7XG5cdCAgICAgICAgICAgIGVycm9yOiBlcnJvcixcblx0ICAgICAgICAgICAgbWV0aG9kOiBtZXRob2QsXG5cdCAgICAgICAgICAgIHRyYW5zYWN0aW9uOiB0cmFuc2FjdGlvblxuXHQgICAgICAgIH0pO1xuXHQgICAgfVxuXHQgICAgLy8gXCJyZXBsYWNlbWVudCB0cmFuc2FjdGlvbiB1bmRlcnByaWNlZFwiXG5cdCAgICBpZiAobWVzc2FnZS5tYXRjaCgvb25seSByZXBsYXktcHJvdGVjdGVkLykpIHtcblx0ICAgICAgICBsb2dnZXIudGhyb3dFcnJvcihcImxlZ2FjeSBwcmUtZWlwLTE1NSB0cmFuc2FjdGlvbnMgbm90IHN1cHBvcnRlZFwiLCBsaWIuTG9nZ2VyLmVycm9ycy5VTlNVUFBPUlRFRF9PUEVSQVRJT04sIHtcblx0ICAgICAgICAgICAgZXJyb3I6IGVycm9yLFxuXHQgICAgICAgICAgICBtZXRob2Q6IG1ldGhvZCxcblx0ICAgICAgICAgICAgdHJhbnNhY3Rpb246IHRyYW5zYWN0aW9uXG5cdCAgICAgICAgfSk7XG5cdCAgICB9XG5cdCAgICBpZiAoZXJyb3JHYXMuaW5kZXhPZihtZXRob2QpID49IDAgJiYgbWVzc2FnZS5tYXRjaCgvZ2FzIHJlcXVpcmVkIGV4Y2VlZHMgYWxsb3dhbmNlfGFsd2F5cyBmYWlsaW5nIHRyYW5zYWN0aW9ufGV4ZWN1dGlvbiByZXZlcnRlZC8pKSB7XG5cdCAgICAgICAgbG9nZ2VyLnRocm93RXJyb3IoXCJjYW5ub3QgZXN0aW1hdGUgZ2FzOyB0cmFuc2FjdGlvbiBtYXkgZmFpbCBvciBtYXkgcmVxdWlyZSBtYW51YWwgZ2FzIGxpbWl0XCIsIGxpYi5Mb2dnZXIuZXJyb3JzLlVOUFJFRElDVEFCTEVfR0FTX0xJTUlULCB7XG5cdCAgICAgICAgICAgIGVycm9yOiBlcnJvcixcblx0ICAgICAgICAgICAgbWV0aG9kOiBtZXRob2QsXG5cdCAgICAgICAgICAgIHRyYW5zYWN0aW9uOiB0cmFuc2FjdGlvblxuXHQgICAgICAgIH0pO1xuXHQgICAgfVxuXHQgICAgdGhyb3cgZXJyb3I7XG5cdH1cblx0ZnVuY3Rpb24gdGltZXIodGltZW91dCkge1xuXHQgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlKSB7XG5cdCAgICAgICAgc2V0VGltZW91dChyZXNvbHZlLCB0aW1lb3V0KTtcblx0ICAgIH0pO1xuXHR9XG5cdGZ1bmN0aW9uIGdldFJlc3VsdChwYXlsb2FkKSB7XG5cdCAgICBpZiAocGF5bG9hZC5lcnJvcikge1xuXHQgICAgICAgIC8vIEBUT0RPOiBub3QgYW55XG5cdCAgICAgICAgdmFyIGVycm9yID0gbmV3IEVycm9yKHBheWxvYWQuZXJyb3IubWVzc2FnZSk7XG5cdCAgICAgICAgZXJyb3IuY29kZSA9IHBheWxvYWQuZXJyb3IuY29kZTtcblx0ICAgICAgICBlcnJvci5kYXRhID0gcGF5bG9hZC5lcnJvci5kYXRhO1xuXHQgICAgICAgIHRocm93IGVycm9yO1xuXHQgICAgfVxuXHQgICAgcmV0dXJuIHBheWxvYWQucmVzdWx0O1xuXHR9XG5cdGZ1bmN0aW9uIGdldExvd2VyQ2FzZSh2YWx1ZSkge1xuXHQgICAgaWYgKHZhbHVlKSB7XG5cdCAgICAgICAgcmV0dXJuIHZhbHVlLnRvTG93ZXJDYXNlKCk7XG5cdCAgICB9XG5cdCAgICByZXR1cm4gdmFsdWU7XG5cdH1cblx0dmFyIF9jb25zdHJ1Y3Rvckd1YXJkID0ge307XG5cdHZhciBKc29uUnBjU2lnbmVyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuXHQgICAgX19leHRlbmRzKEpzb25ScGNTaWduZXIsIF9zdXBlcik7XG5cdCAgICBmdW5jdGlvbiBKc29uUnBjU2lnbmVyKGNvbnN0cnVjdG9yR3VhcmQsIHByb3ZpZGVyLCBhZGRyZXNzT3JJbmRleCkge1xuXHQgICAgICAgIHZhciBfbmV3VGFyZ2V0ID0gdGhpcy5jb25zdHJ1Y3Rvcjtcblx0ICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXHQgICAgICAgIGxvZ2dlci5jaGVja05ldyhfbmV3VGFyZ2V0LCBKc29uUnBjU2lnbmVyKTtcblx0ICAgICAgICBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMpIHx8IHRoaXM7XG5cdCAgICAgICAgaWYgKGNvbnN0cnVjdG9yR3VhcmQgIT09IF9jb25zdHJ1Y3Rvckd1YXJkKSB7XG5cdCAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImRvIG5vdCBjYWxsIHRoZSBKc29uUnBjU2lnbmVyIGNvbnN0cnVjdG9yIGRpcmVjdGx5OyB1c2UgcHJvdmlkZXIuZ2V0U2lnbmVyXCIpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICAoMCwgbGliJDMuZGVmaW5lUmVhZE9ubHkpKF90aGlzLCBcInByb3ZpZGVyXCIsIHByb3ZpZGVyKTtcblx0ICAgICAgICBpZiAoYWRkcmVzc09ySW5kZXggPT0gbnVsbCkge1xuXHQgICAgICAgICAgICBhZGRyZXNzT3JJbmRleCA9IDA7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGlmICh0eXBlb2YgKGFkZHJlc3NPckluZGV4KSA9PT0gXCJzdHJpbmdcIikge1xuXHQgICAgICAgICAgICAoMCwgbGliJDMuZGVmaW5lUmVhZE9ubHkpKF90aGlzLCBcIl9hZGRyZXNzXCIsIF90aGlzLnByb3ZpZGVyLmZvcm1hdHRlci5hZGRyZXNzKGFkZHJlc3NPckluZGV4KSk7XG5cdCAgICAgICAgICAgICgwLCBsaWIkMy5kZWZpbmVSZWFkT25seSkoX3RoaXMsIFwiX2luZGV4XCIsIG51bGwpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBlbHNlIGlmICh0eXBlb2YgKGFkZHJlc3NPckluZGV4KSA9PT0gXCJudW1iZXJcIikge1xuXHQgICAgICAgICAgICAoMCwgbGliJDMuZGVmaW5lUmVhZE9ubHkpKF90aGlzLCBcIl9pbmRleFwiLCBhZGRyZXNzT3JJbmRleCk7XG5cdCAgICAgICAgICAgICgwLCBsaWIkMy5kZWZpbmVSZWFkT25seSkoX3RoaXMsIFwiX2FkZHJlc3NcIiwgbnVsbCk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGVsc2Uge1xuXHQgICAgICAgICAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwiaW52YWxpZCBhZGRyZXNzIG9yIGluZGV4XCIsIFwiYWRkcmVzc09ySW5kZXhcIiwgYWRkcmVzc09ySW5kZXgpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICByZXR1cm4gX3RoaXM7XG5cdCAgICB9XG5cdCAgICBKc29uUnBjU2lnbmVyLnByb3RvdHlwZS5jb25uZWN0ID0gZnVuY3Rpb24gKHByb3ZpZGVyKSB7XG5cdCAgICAgICAgcmV0dXJuIGxvZ2dlci50aHJvd0Vycm9yKFwiY2Fubm90IGFsdGVyIEpTT04tUlBDIFNpZ25lciBjb25uZWN0aW9uXCIsIGxpYi5Mb2dnZXIuZXJyb3JzLlVOU1VQUE9SVEVEX09QRVJBVElPTiwge1xuXHQgICAgICAgICAgICBvcGVyYXRpb246IFwiY29ubmVjdFwiXG5cdCAgICAgICAgfSk7XG5cdCAgICB9O1xuXHQgICAgSnNvblJwY1NpZ25lci5wcm90b3R5cGUuY29ubmVjdFVuY2hlY2tlZCA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICByZXR1cm4gbmV3IFVuY2hlY2tlZEpzb25ScGNTaWduZXIoX2NvbnN0cnVjdG9yR3VhcmQsIHRoaXMucHJvdmlkZXIsIHRoaXMuX2FkZHJlc3MgfHwgdGhpcy5faW5kZXgpO1xuXHQgICAgfTtcblx0ICAgIEpzb25ScGNTaWduZXIucHJvdG90eXBlLmdldEFkZHJlc3MgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgdmFyIF90aGlzID0gdGhpcztcblx0ICAgICAgICBpZiAodGhpcy5fYWRkcmVzcykge1xuXHQgICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHRoaXMuX2FkZHJlc3MpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICByZXR1cm4gdGhpcy5wcm92aWRlci5zZW5kKFwiZXRoX2FjY291bnRzXCIsIFtdKS50aGVuKGZ1bmN0aW9uIChhY2NvdW50cykge1xuXHQgICAgICAgICAgICBpZiAoYWNjb3VudHMubGVuZ3RoIDw9IF90aGlzLl9pbmRleCkge1xuXHQgICAgICAgICAgICAgICAgbG9nZ2VyLnRocm93RXJyb3IoXCJ1bmtub3duIGFjY291bnQgI1wiICsgX3RoaXMuX2luZGV4LCBsaWIuTG9nZ2VyLmVycm9ycy5VTlNVUFBPUlRFRF9PUEVSQVRJT04sIHtcblx0ICAgICAgICAgICAgICAgICAgICBvcGVyYXRpb246IFwiZ2V0QWRkcmVzc1wiXG5cdCAgICAgICAgICAgICAgICB9KTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICByZXR1cm4gX3RoaXMucHJvdmlkZXIuZm9ybWF0dGVyLmFkZHJlc3MoYWNjb3VudHNbX3RoaXMuX2luZGV4XSk7XG5cdCAgICAgICAgfSk7XG5cdCAgICB9O1xuXHQgICAgSnNvblJwY1NpZ25lci5wcm90b3R5cGUuc2VuZFVuY2hlY2tlZFRyYW5zYWN0aW9uID0gZnVuY3Rpb24gKHRyYW5zYWN0aW9uKSB7XG5cdCAgICAgICAgdmFyIF90aGlzID0gdGhpcztcblx0ICAgICAgICB0cmFuc2FjdGlvbiA9ICgwLCBsaWIkMy5zaGFsbG93Q29weSkodHJhbnNhY3Rpb24pO1xuXHQgICAgICAgIHZhciBmcm9tQWRkcmVzcyA9IHRoaXMuZ2V0QWRkcmVzcygpLnRoZW4oZnVuY3Rpb24gKGFkZHJlc3MpIHtcblx0ICAgICAgICAgICAgaWYgKGFkZHJlc3MpIHtcblx0ICAgICAgICAgICAgICAgIGFkZHJlc3MgPSBhZGRyZXNzLnRvTG93ZXJDYXNlKCk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgcmV0dXJuIGFkZHJlc3M7XG5cdCAgICAgICAgfSk7XG5cdCAgICAgICAgLy8gVGhlIEpTT04tUlBDIGZvciBldGhfc2VuZFRyYW5zYWN0aW9uIHVzZXMgOTAwMDAgZ2FzOyBpZiB0aGUgdXNlclxuXHQgICAgICAgIC8vIHdpc2hlcyB0byB1c2UgdGhpcywgaXQgaXMgZWFzeSB0byBzcGVjaWZ5IGV4cGxpY2l0bHksIG90aGVyd2lzZVxuXHQgICAgICAgIC8vIHdlIGxvb2sgaXQgdXAgZm9yIHRoZW0uXG5cdCAgICAgICAgaWYgKHRyYW5zYWN0aW9uLmdhc0xpbWl0ID09IG51bGwpIHtcblx0ICAgICAgICAgICAgdmFyIGVzdGltYXRlID0gKDAsIGxpYiQzLnNoYWxsb3dDb3B5KSh0cmFuc2FjdGlvbik7XG5cdCAgICAgICAgICAgIGVzdGltYXRlLmZyb20gPSBmcm9tQWRkcmVzcztcblx0ICAgICAgICAgICAgdHJhbnNhY3Rpb24uZ2FzTGltaXQgPSB0aGlzLnByb3ZpZGVyLmVzdGltYXRlR2FzKGVzdGltYXRlKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgaWYgKHRyYW5zYWN0aW9uLnRvICE9IG51bGwpIHtcblx0ICAgICAgICAgICAgdHJhbnNhY3Rpb24udG8gPSBQcm9taXNlLnJlc29sdmUodHJhbnNhY3Rpb24udG8pLnRoZW4oZnVuY3Rpb24gKHRvKSB7IHJldHVybiBfX2F3YWl0ZXIoX3RoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgICAgICB2YXIgYWRkcmVzcztcblx0ICAgICAgICAgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcblx0ICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKF9hLmxhYmVsKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMDpcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0byA9PSBudWxsKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIG51bGxdO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgdGhpcy5wcm92aWRlci5yZXNvbHZlTmFtZSh0byldO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDE6XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBhZGRyZXNzID0gX2Euc2VudCgpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGFkZHJlc3MgPT0gbnVsbCkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJwcm92aWRlZCBFTlMgbmFtZSByZXNvbHZlcyB0byBudWxsXCIsIFwidHgudG9cIiwgdG8pO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIGFkZHJlc3NdO1xuXHQgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgIH0pO1xuXHQgICAgICAgICAgICB9KTsgfSk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHJldHVybiAoMCwgbGliJDMucmVzb2x2ZVByb3BlcnRpZXMpKHtcblx0ICAgICAgICAgICAgdHg6ICgwLCBsaWIkMy5yZXNvbHZlUHJvcGVydGllcykodHJhbnNhY3Rpb24pLFxuXHQgICAgICAgICAgICBzZW5kZXI6IGZyb21BZGRyZXNzXG5cdCAgICAgICAgfSkudGhlbihmdW5jdGlvbiAoX2EpIHtcblx0ICAgICAgICAgICAgdmFyIHR4ID0gX2EudHgsIHNlbmRlciA9IF9hLnNlbmRlcjtcblx0ICAgICAgICAgICAgaWYgKHR4LmZyb20gIT0gbnVsbCkge1xuXHQgICAgICAgICAgICAgICAgaWYgKHR4LmZyb20udG9Mb3dlckNhc2UoKSAhPT0gc2VuZGVyKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcImZyb20gYWRkcmVzcyBtaXNtYXRjaFwiLCBcInRyYW5zYWN0aW9uXCIsIHRyYW5zYWN0aW9uKTtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICBlbHNlIHtcblx0ICAgICAgICAgICAgICAgIHR4LmZyb20gPSBzZW5kZXI7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgdmFyIGhleFR4ID0gX3RoaXMucHJvdmlkZXIuY29uc3RydWN0b3IuaGV4bGlmeVRyYW5zYWN0aW9uKHR4LCB7IGZyb206IHRydWUgfSk7XG5cdCAgICAgICAgICAgIHJldHVybiBfdGhpcy5wcm92aWRlci5zZW5kKFwiZXRoX3NlbmRUcmFuc2FjdGlvblwiLCBbaGV4VHhdKS50aGVuKGZ1bmN0aW9uIChoYXNoKSB7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gaGFzaDtcblx0ICAgICAgICAgICAgfSwgZnVuY3Rpb24gKGVycm9yKSB7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gY2hlY2tFcnJvcihcInNlbmRUcmFuc2FjdGlvblwiLCBlcnJvciwgaGV4VHgpO1xuXHQgICAgICAgICAgICB9KTtcblx0ICAgICAgICB9KTtcblx0ICAgIH07XG5cdCAgICBKc29uUnBjU2lnbmVyLnByb3RvdHlwZS5zaWduVHJhbnNhY3Rpb24gPSBmdW5jdGlvbiAodHJhbnNhY3Rpb24pIHtcblx0ICAgICAgICByZXR1cm4gbG9nZ2VyLnRocm93RXJyb3IoXCJzaWduaW5nIHRyYW5zYWN0aW9ucyBpcyB1bnN1cHBvcnRlZFwiLCBsaWIuTG9nZ2VyLmVycm9ycy5VTlNVUFBPUlRFRF9PUEVSQVRJT04sIHtcblx0ICAgICAgICAgICAgb3BlcmF0aW9uOiBcInNpZ25UcmFuc2FjdGlvblwiXG5cdCAgICAgICAgfSk7XG5cdCAgICB9O1xuXHQgICAgSnNvblJwY1NpZ25lci5wcm90b3R5cGUuc2VuZFRyYW5zYWN0aW9uID0gZnVuY3Rpb24gKHRyYW5zYWN0aW9uKSB7XG5cdCAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICB2YXIgYmxvY2tOdW1iZXIsIGhhc2gsIGVycm9yXzE7XG5cdCAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cdCAgICAgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcblx0ICAgICAgICAgICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcblx0ICAgICAgICAgICAgICAgICAgICBjYXNlIDA6IHJldHVybiBbNCAvKnlpZWxkKi8sIHRoaXMucHJvdmlkZXIuX2dldEludGVybmFsQmxvY2tOdW1iZXIoMTAwICsgMiAqIHRoaXMucHJvdmlkZXIucG9sbGluZ0ludGVydmFsKV07XG5cdCAgICAgICAgICAgICAgICAgICAgY2FzZSAxOlxuXHQgICAgICAgICAgICAgICAgICAgICAgICBibG9ja051bWJlciA9IF9hLnNlbnQoKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgdGhpcy5zZW5kVW5jaGVja2VkVHJhbnNhY3Rpb24odHJhbnNhY3Rpb24pXTtcblx0ICAgICAgICAgICAgICAgICAgICBjYXNlIDI6XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGhhc2ggPSBfYS5zZW50KCk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIF9hLmxhYmVsID0gMztcblx0ICAgICAgICAgICAgICAgICAgICBjYXNlIDM6XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIF9hLnRyeXMucHVzaChbMywgNSwgLCA2XSk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sICgwLCBsaWIkcS5wb2xsKShmdW5jdGlvbiAoKSB7IHJldHVybiBfX2F3YWl0ZXIoX3RoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHR4O1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAwOiByZXR1cm4gWzQgLyp5aWVsZCovLCB0aGlzLnByb3ZpZGVyLmdldFRyYW5zYWN0aW9uKGhhc2gpXTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMTpcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eCA9IF9hLnNlbnQoKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodHggPT09IG51bGwpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIHVuZGVmaW5lZF07XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCB0aGlzLnByb3ZpZGVyLl93cmFwVHJhbnNhY3Rpb24odHgsIGhhc2gsIGJsb2NrTnVtYmVyKV07XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pOyB9LCB7IG9uY2VQb2xsOiB0aGlzLnByb3ZpZGVyIH0pXTtcblx0ICAgICAgICAgICAgICAgICAgICBjYXNlIDQ6IFxuXHQgICAgICAgICAgICAgICAgICAgIC8vIFVuZm9ydHVuYXRlbHksIEpTT04tUlBDIG9ubHkgcHJvdmlkZXMgYW5kIG9wYXF1ZSB0cmFuc2FjdGlvbiBoYXNoXG5cdCAgICAgICAgICAgICAgICAgICAgLy8gZm9yIGEgcmVzcG9uc2UsIGFuZCB3ZSBuZWVkIHRoZSBhY3R1YWwgdHJhbnNhY3Rpb24sIHNvIHdlIHBvbGxcblx0ICAgICAgICAgICAgICAgICAgICAvLyBmb3IgaXQ7IGl0IHNob3VsZCBzaG93IHVwIHZlcnkgcXVpY2tseVxuXHQgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCBfYS5zZW50KCldO1xuXHQgICAgICAgICAgICAgICAgICAgIGNhc2UgNTpcblx0ICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3JfMSA9IF9hLnNlbnQoKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3JfMS50cmFuc2FjdGlvbkhhc2ggPSBoYXNoO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcl8xO1xuXHQgICAgICAgICAgICAgICAgICAgIGNhc2UgNjogcmV0dXJuIFsyIC8qcmV0dXJuKi9dO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB9KTtcblx0ICAgICAgICB9KTtcblx0ICAgIH07XG5cdCAgICBKc29uUnBjU2lnbmVyLnByb3RvdHlwZS5zaWduTWVzc2FnZSA9IGZ1bmN0aW9uIChtZXNzYWdlKSB7XG5cdCAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICB2YXIgZGF0YSwgYWRkcmVzcztcblx0ICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuXHQgICAgICAgICAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkge1xuXHQgICAgICAgICAgICAgICAgICAgIGNhc2UgMDpcblx0ICAgICAgICAgICAgICAgICAgICAgICAgZGF0YSA9ICgodHlwZW9mIChtZXNzYWdlKSA9PT0gXCJzdHJpbmdcIikgPyAoMCwgbGliJDgudG9VdGY4Qnl0ZXMpKG1lc3NhZ2UpIDogbWVzc2FnZSk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIHRoaXMuZ2V0QWRkcmVzcygpXTtcblx0ICAgICAgICAgICAgICAgICAgICBjYXNlIDE6XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGFkZHJlc3MgPSBfYS5zZW50KCk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIHRoaXMucHJvdmlkZXIuc2VuZChcInBlcnNvbmFsX3NpZ25cIiwgWygwLCBsaWIkMS5oZXhsaWZ5KShkYXRhKSwgYWRkcmVzcy50b0xvd2VyQ2FzZSgpXSldO1xuXHQgICAgICAgICAgICAgICAgICAgIGNhc2UgMjogcmV0dXJuIFsyIC8qcmV0dXJuKi8sIF9hLnNlbnQoKV07XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIH0pO1xuXHQgICAgICAgIH0pO1xuXHQgICAgfTtcblx0ICAgIEpzb25ScGNTaWduZXIucHJvdG90eXBlLl9sZWdhY3lTaWduTWVzc2FnZSA9IGZ1bmN0aW9uIChtZXNzYWdlKSB7XG5cdCAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICB2YXIgZGF0YSwgYWRkcmVzcztcblx0ICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuXHQgICAgICAgICAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkge1xuXHQgICAgICAgICAgICAgICAgICAgIGNhc2UgMDpcblx0ICAgICAgICAgICAgICAgICAgICAgICAgZGF0YSA9ICgodHlwZW9mIChtZXNzYWdlKSA9PT0gXCJzdHJpbmdcIikgPyAoMCwgbGliJDgudG9VdGY4Qnl0ZXMpKG1lc3NhZ2UpIDogbWVzc2FnZSk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIHRoaXMuZ2V0QWRkcmVzcygpXTtcblx0ICAgICAgICAgICAgICAgICAgICBjYXNlIDE6XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGFkZHJlc3MgPSBfYS5zZW50KCk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIHRoaXMucHJvdmlkZXIuc2VuZChcImV0aF9zaWduXCIsIFthZGRyZXNzLnRvTG93ZXJDYXNlKCksICgwLCBsaWIkMS5oZXhsaWZ5KShkYXRhKV0pXTtcblx0ICAgICAgICAgICAgICAgICAgICBjYXNlIDI6IFxuXHQgICAgICAgICAgICAgICAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9ldGhlcmV1bS93aWtpL3dpa2kvSlNPTi1SUEMjZXRoX3NpZ25cblx0ICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgX2Euc2VudCgpXTtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgfSk7XG5cdCAgICB9O1xuXHQgICAgSnNvblJwY1NpZ25lci5wcm90b3R5cGUuX3NpZ25UeXBlZERhdGEgPSBmdW5jdGlvbiAoZG9tYWluLCB0eXBlcywgdmFsdWUpIHtcblx0ICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIHZhciBwb3B1bGF0ZWQsIGFkZHJlc3M7XG5cdCAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cdCAgICAgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcblx0ICAgICAgICAgICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcblx0ICAgICAgICAgICAgICAgICAgICBjYXNlIDA6IHJldHVybiBbNCAvKnlpZWxkKi8sIGxpYiQ5Ll9UeXBlZERhdGFFbmNvZGVyLnJlc29sdmVOYW1lcyhkb21haW4sIHR5cGVzLCB2YWx1ZSwgZnVuY3Rpb24gKG5hbWUpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfdGhpcy5wcm92aWRlci5yZXNvbHZlTmFtZShuYW1lKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfSldO1xuXHQgICAgICAgICAgICAgICAgICAgIGNhc2UgMTpcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcG9wdWxhdGVkID0gX2Euc2VudCgpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCB0aGlzLmdldEFkZHJlc3MoKV07XG5cdCAgICAgICAgICAgICAgICAgICAgY2FzZSAyOlxuXHQgICAgICAgICAgICAgICAgICAgICAgICBhZGRyZXNzID0gX2Euc2VudCgpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCB0aGlzLnByb3ZpZGVyLnNlbmQoXCJldGhfc2lnblR5cGVkRGF0YV92NFwiLCBbXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYWRkcmVzcy50b0xvd2VyQ2FzZSgpLFxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIEpTT04uc3RyaW5naWZ5KGxpYiQ5Ll9UeXBlZERhdGFFbmNvZGVyLmdldFBheWxvYWQocG9wdWxhdGVkLmRvbWFpbiwgdHlwZXMsIHBvcHVsYXRlZC52YWx1ZSkpXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBdKV07XG5cdCAgICAgICAgICAgICAgICAgICAgY2FzZSAzOiByZXR1cm4gWzIgLypyZXR1cm4qLywgX2Euc2VudCgpXTtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgfSk7XG5cdCAgICB9O1xuXHQgICAgSnNvblJwY1NpZ25lci5wcm90b3R5cGUudW5sb2NrID0gZnVuY3Rpb24gKHBhc3N3b3JkKSB7XG5cdCAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICB2YXIgcHJvdmlkZXIsIGFkZHJlc3M7XG5cdCAgICAgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcblx0ICAgICAgICAgICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcblx0ICAgICAgICAgICAgICAgICAgICBjYXNlIDA6XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHByb3ZpZGVyID0gdGhpcy5wcm92aWRlcjtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgdGhpcy5nZXRBZGRyZXNzKCldO1xuXHQgICAgICAgICAgICAgICAgICAgIGNhc2UgMTpcblx0ICAgICAgICAgICAgICAgICAgICAgICAgYWRkcmVzcyA9IF9hLnNlbnQoKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIHByb3ZpZGVyLnNlbmQoXCJwZXJzb25hbF91bmxvY2tBY2NvdW50XCIsIFthZGRyZXNzLnRvTG93ZXJDYXNlKCksIHBhc3N3b3JkLCBudWxsXSldO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB9KTtcblx0ICAgICAgICB9KTtcblx0ICAgIH07XG5cdCAgICByZXR1cm4gSnNvblJwY1NpZ25lcjtcblx0fShsaWIkYy5TaWduZXIpKTtcblx0ZXhwb3J0cy5Kc29uUnBjU2lnbmVyID0gSnNvblJwY1NpZ25lcjtcblx0dmFyIFVuY2hlY2tlZEpzb25ScGNTaWduZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG5cdCAgICBfX2V4dGVuZHMoVW5jaGVja2VkSnNvblJwY1NpZ25lciwgX3N1cGVyKTtcblx0ICAgIGZ1bmN0aW9uIFVuY2hlY2tlZEpzb25ScGNTaWduZXIoKSB7XG5cdCAgICAgICAgcmV0dXJuIF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuXHQgICAgfVxuXHQgICAgVW5jaGVja2VkSnNvblJwY1NpZ25lci5wcm90b3R5cGUuc2VuZFRyYW5zYWN0aW9uID0gZnVuY3Rpb24gKHRyYW5zYWN0aW9uKSB7XG5cdCAgICAgICAgdmFyIF90aGlzID0gdGhpcztcblx0ICAgICAgICByZXR1cm4gdGhpcy5zZW5kVW5jaGVja2VkVHJhbnNhY3Rpb24odHJhbnNhY3Rpb24pLnRoZW4oZnVuY3Rpb24gKGhhc2gpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIHtcblx0ICAgICAgICAgICAgICAgIGhhc2g6IGhhc2gsXG5cdCAgICAgICAgICAgICAgICBub25jZTogbnVsbCxcblx0ICAgICAgICAgICAgICAgIGdhc0xpbWl0OiBudWxsLFxuXHQgICAgICAgICAgICAgICAgZ2FzUHJpY2U6IG51bGwsXG5cdCAgICAgICAgICAgICAgICBkYXRhOiBudWxsLFxuXHQgICAgICAgICAgICAgICAgdmFsdWU6IG51bGwsXG5cdCAgICAgICAgICAgICAgICBjaGFpbklkOiBudWxsLFxuXHQgICAgICAgICAgICAgICAgY29uZmlybWF0aW9uczogMCxcblx0ICAgICAgICAgICAgICAgIGZyb206IG51bGwsXG5cdCAgICAgICAgICAgICAgICB3YWl0OiBmdW5jdGlvbiAoY29uZmlybWF0aW9ucykgeyByZXR1cm4gX3RoaXMucHJvdmlkZXIud2FpdEZvclRyYW5zYWN0aW9uKGhhc2gsIGNvbmZpcm1hdGlvbnMpOyB9XG5cdCAgICAgICAgICAgIH07XG5cdCAgICAgICAgfSk7XG5cdCAgICB9O1xuXHQgICAgcmV0dXJuIFVuY2hlY2tlZEpzb25ScGNTaWduZXI7XG5cdH0oSnNvblJwY1NpZ25lcikpO1xuXHR2YXIgYWxsb3dlZFRyYW5zYWN0aW9uS2V5cyA9IHtcblx0ICAgIGNoYWluSWQ6IHRydWUsIGRhdGE6IHRydWUsIGdhc0xpbWl0OiB0cnVlLCBnYXNQcmljZTogdHJ1ZSwgbm9uY2U6IHRydWUsIHRvOiB0cnVlLCB2YWx1ZTogdHJ1ZSxcblx0ICAgIHR5cGU6IHRydWUsIGFjY2Vzc0xpc3Q6IHRydWUsXG5cdCAgICBtYXhGZWVQZXJHYXM6IHRydWUsIG1heFByaW9yaXR5RmVlUGVyR2FzOiB0cnVlXG5cdH07XG5cdHZhciBKc29uUnBjUHJvdmlkZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG5cdCAgICBfX2V4dGVuZHMoSnNvblJwY1Byb3ZpZGVyLCBfc3VwZXIpO1xuXHQgICAgZnVuY3Rpb24gSnNvblJwY1Byb3ZpZGVyKHVybCwgbmV0d29yaykge1xuXHQgICAgICAgIHZhciBfbmV3VGFyZ2V0ID0gdGhpcy5jb25zdHJ1Y3Rvcjtcblx0ICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXHQgICAgICAgIGxvZ2dlci5jaGVja05ldyhfbmV3VGFyZ2V0LCBKc29uUnBjUHJvdmlkZXIpO1xuXHQgICAgICAgIHZhciBuZXR3b3JrT3JSZWFkeSA9IG5ldHdvcms7XG5cdCAgICAgICAgLy8gVGhlIG5ldHdvcmsgaXMgdW5rbm93biwgcXVlcnkgdGhlIEpTT04tUlBDIGZvciBpdFxuXHQgICAgICAgIGlmIChuZXR3b3JrT3JSZWFkeSA9PSBudWxsKSB7XG5cdCAgICAgICAgICAgIG5ldHdvcmtPclJlYWR5ID0gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuXHQgICAgICAgICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgX3RoaXMuZGV0ZWN0TmV0d29yaygpLnRoZW4oZnVuY3Rpb24gKG5ldHdvcmspIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShuZXR3b3JrKTtcblx0ICAgICAgICAgICAgICAgICAgICB9LCBmdW5jdGlvbiAoZXJyb3IpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcmVqZWN0KGVycm9yKTtcblx0ICAgICAgICAgICAgICAgICAgICB9KTtcblx0ICAgICAgICAgICAgICAgIH0sIDApO1xuXHQgICAgICAgICAgICB9KTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBuZXR3b3JrT3JSZWFkeSkgfHwgdGhpcztcblx0ICAgICAgICAvLyBEZWZhdWx0IFVSTFxuXHQgICAgICAgIGlmICghdXJsKSB7XG5cdCAgICAgICAgICAgIHVybCA9ICgwLCBsaWIkMy5nZXRTdGF0aWMpKF90aGlzLmNvbnN0cnVjdG9yLCBcImRlZmF1bHRVcmxcIikoKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgaWYgKHR5cGVvZiAodXJsKSA9PT0gXCJzdHJpbmdcIikge1xuXHQgICAgICAgICAgICAoMCwgbGliJDMuZGVmaW5lUmVhZE9ubHkpKF90aGlzLCBcImNvbm5lY3Rpb25cIiwgT2JqZWN0LmZyZWV6ZSh7XG5cdCAgICAgICAgICAgICAgICB1cmw6IHVybFxuXHQgICAgICAgICAgICB9KSk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGVsc2Uge1xuXHQgICAgICAgICAgICAoMCwgbGliJDMuZGVmaW5lUmVhZE9ubHkpKF90aGlzLCBcImNvbm5lY3Rpb25cIiwgT2JqZWN0LmZyZWV6ZSgoMCwgbGliJDMuc2hhbGxvd0NvcHkpKHVybCkpKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgX3RoaXMuX25leHRJZCA9IDQyO1xuXHQgICAgICAgIHJldHVybiBfdGhpcztcblx0ICAgIH1cblx0ICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShKc29uUnBjUHJvdmlkZXIucHJvdG90eXBlLCBcIl9jYWNoZVwiLCB7XG5cdCAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIGlmICh0aGlzLl9ldmVudExvb3BDYWNoZSA9PSBudWxsKSB7XG5cdCAgICAgICAgICAgICAgICB0aGlzLl9ldmVudExvb3BDYWNoZSA9IHt9O1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIHJldHVybiB0aGlzLl9ldmVudExvb3BDYWNoZTtcblx0ICAgICAgICB9LFxuXHQgICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuXHQgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuXHQgICAgfSk7XG5cdCAgICBKc29uUnBjUHJvdmlkZXIuZGVmYXVsdFVybCA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICByZXR1cm4gXCJodHRwOi9cXC9sb2NhbGhvc3Q6ODU0NVwiO1xuXHQgICAgfTtcblx0ICAgIEpzb25ScGNQcm92aWRlci5wcm90b3R5cGUuZGV0ZWN0TmV0d29yayA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXHQgICAgICAgIGlmICghdGhpcy5fY2FjaGVbXCJkZXRlY3ROZXR3b3JrXCJdKSB7XG5cdCAgICAgICAgICAgIHRoaXMuX2NhY2hlW1wiZGV0ZWN0TmV0d29ya1wiXSA9IHRoaXMuX3VuY2FjaGVkRGV0ZWN0TmV0d29yaygpO1xuXHQgICAgICAgICAgICAvLyBDbGVhciB0aGlzIGNhY2hlIGF0IHRoZSBiZWdpbm5pbmcgb2YgdGhlIG5leHQgZXZlbnQgbG9vcFxuXHQgICAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgICAgIF90aGlzLl9jYWNoZVtcImRldGVjdE5ldHdvcmtcIl0gPSBudWxsO1xuXHQgICAgICAgICAgICB9LCAwKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgcmV0dXJuIHRoaXMuX2NhY2hlW1wiZGV0ZWN0TmV0d29ya1wiXTtcblx0ICAgIH07XG5cdCAgICBKc29uUnBjUHJvdmlkZXIucHJvdG90eXBlLl91bmNhY2hlZERldGVjdE5ldHdvcmsgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICB2YXIgY2hhaW5JZCwgZXJyb3JfMiwgZXJyb3JfMywgZ2V0TmV0d29yaztcblx0ICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuXHQgICAgICAgICAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkge1xuXHQgICAgICAgICAgICAgICAgICAgIGNhc2UgMDogcmV0dXJuIFs0IC8qeWllbGQqLywgdGltZXIoMCldO1xuXHQgICAgICAgICAgICAgICAgICAgIGNhc2UgMTpcblx0ICAgICAgICAgICAgICAgICAgICAgICAgX2Euc2VudCgpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBjaGFpbklkID0gbnVsbDtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgX2EubGFiZWwgPSAyO1xuXHQgICAgICAgICAgICAgICAgICAgIGNhc2UgMjpcblx0ICAgICAgICAgICAgICAgICAgICAgICAgX2EudHJ5cy5wdXNoKFsyLCA0LCAsIDldKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgdGhpcy5zZW5kKFwiZXRoX2NoYWluSWRcIiwgW10pXTtcblx0ICAgICAgICAgICAgICAgICAgICBjYXNlIDM6XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGNoYWluSWQgPSBfYS5zZW50KCk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMyAvKmJyZWFrKi8sIDldO1xuXHQgICAgICAgICAgICAgICAgICAgIGNhc2UgNDpcblx0ICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3JfMiA9IF9hLnNlbnQoKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgX2EubGFiZWwgPSA1O1xuXHQgICAgICAgICAgICAgICAgICAgIGNhc2UgNTpcblx0ICAgICAgICAgICAgICAgICAgICAgICAgX2EudHJ5cy5wdXNoKFs1LCA3LCAsIDhdKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgdGhpcy5zZW5kKFwibmV0X3ZlcnNpb25cIiwgW10pXTtcblx0ICAgICAgICAgICAgICAgICAgICBjYXNlIDY6XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGNoYWluSWQgPSBfYS5zZW50KCk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMyAvKmJyZWFrKi8sIDhdO1xuXHQgICAgICAgICAgICAgICAgICAgIGNhc2UgNzpcblx0ICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3JfMyA9IF9hLnNlbnQoKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFszIC8qYnJlYWsqLywgOF07XG5cdCAgICAgICAgICAgICAgICAgICAgY2FzZSA4OiByZXR1cm4gWzMgLypicmVhayovLCA5XTtcblx0ICAgICAgICAgICAgICAgICAgICBjYXNlIDk6XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjaGFpbklkICE9IG51bGwpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdldE5ldHdvcmsgPSAoMCwgbGliJDMuZ2V0U3RhdGljKSh0aGlzLmNvbnN0cnVjdG9yLCBcImdldE5ldHdvcmtcIik7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cnkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCBnZXROZXR3b3JrKGxpYiQyLkJpZ051bWJlci5mcm9tKGNoYWluSWQpLnRvTnVtYmVyKCkpXTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCBsb2dnZXIudGhyb3dFcnJvcihcImNvdWxkIG5vdCBkZXRlY3QgbmV0d29ya1wiLCBsaWIuTG9nZ2VyLmVycm9ycy5ORVRXT1JLX0VSUk9SLCB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjaGFpbklkOiBjaGFpbklkLFxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXZlbnQ6IFwiaW52YWxpZE5ldHdvcmtcIixcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlcnZlckVycm9yOiBlcnJvclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KV07XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIGxvZ2dlci50aHJvd0Vycm9yKFwiY291bGQgbm90IGRldGVjdCBuZXR3b3JrXCIsIGxpYi5Mb2dnZXIuZXJyb3JzLk5FVFdPUktfRVJST1IsIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBldmVudDogXCJub05ldHdvcmtcIlxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSldO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB9KTtcblx0ICAgICAgICB9KTtcblx0ICAgIH07XG5cdCAgICBKc29uUnBjUHJvdmlkZXIucHJvdG90eXBlLmdldFNpZ25lciA9IGZ1bmN0aW9uIChhZGRyZXNzT3JJbmRleCkge1xuXHQgICAgICAgIHJldHVybiBuZXcgSnNvblJwY1NpZ25lcihfY29uc3RydWN0b3JHdWFyZCwgdGhpcywgYWRkcmVzc09ySW5kZXgpO1xuXHQgICAgfTtcblx0ICAgIEpzb25ScGNQcm92aWRlci5wcm90b3R5cGUuZ2V0VW5jaGVja2VkU2lnbmVyID0gZnVuY3Rpb24gKGFkZHJlc3NPckluZGV4KSB7XG5cdCAgICAgICAgcmV0dXJuIHRoaXMuZ2V0U2lnbmVyKGFkZHJlc3NPckluZGV4KS5jb25uZWN0VW5jaGVja2VkKCk7XG5cdCAgICB9O1xuXHQgICAgSnNvblJwY1Byb3ZpZGVyLnByb3RvdHlwZS5saXN0QWNjb3VudHMgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgdmFyIF90aGlzID0gdGhpcztcblx0ICAgICAgICByZXR1cm4gdGhpcy5zZW5kKFwiZXRoX2FjY291bnRzXCIsIFtdKS50aGVuKGZ1bmN0aW9uIChhY2NvdW50cykge1xuXHQgICAgICAgICAgICByZXR1cm4gYWNjb3VudHMubWFwKGZ1bmN0aW9uIChhKSB7IHJldHVybiBfdGhpcy5mb3JtYXR0ZXIuYWRkcmVzcyhhKTsgfSk7XG5cdCAgICAgICAgfSk7XG5cdCAgICB9O1xuXHQgICAgSnNvblJwY1Byb3ZpZGVyLnByb3RvdHlwZS5zZW5kID0gZnVuY3Rpb24gKG1ldGhvZCwgcGFyYW1zKSB7XG5cdCAgICAgICAgdmFyIF90aGlzID0gdGhpcztcblx0ICAgICAgICB2YXIgcmVxdWVzdCA9IHtcblx0ICAgICAgICAgICAgbWV0aG9kOiBtZXRob2QsXG5cdCAgICAgICAgICAgIHBhcmFtczogcGFyYW1zLFxuXHQgICAgICAgICAgICBpZDogKHRoaXMuX25leHRJZCsrKSxcblx0ICAgICAgICAgICAganNvbnJwYzogXCIyLjBcIlxuXHQgICAgICAgIH07XG5cdCAgICAgICAgdGhpcy5lbWl0KFwiZGVidWdcIiwge1xuXHQgICAgICAgICAgICBhY3Rpb246IFwicmVxdWVzdFwiLFxuXHQgICAgICAgICAgICByZXF1ZXN0OiAoMCwgbGliJDMuZGVlcENvcHkpKHJlcXVlc3QpLFxuXHQgICAgICAgICAgICBwcm92aWRlcjogdGhpc1xuXHQgICAgICAgIH0pO1xuXHQgICAgICAgIC8vIFdlIGNhbiBleHBhbmQgdGhpcyBpbiB0aGUgZnV0dXJlIHRvIGFueSBjYWxsLCBidXQgZm9yIG5vdyB0aGVzZVxuXHQgICAgICAgIC8vIGFyZSB0aGUgYmlnZ2VzdCB3aW5zIGFuZCBkbyBub3QgcmVxdWlyZSBhbnkgc2VyaWFsaXppbmcgcGFyYW1ldGVycy5cblx0ICAgICAgICB2YXIgY2FjaGUgPSAoW1wiZXRoX2NoYWluSWRcIiwgXCJldGhfYmxvY2tOdW1iZXJcIl0uaW5kZXhPZihtZXRob2QpID49IDApO1xuXHQgICAgICAgIGlmIChjYWNoZSAmJiB0aGlzLl9jYWNoZVttZXRob2RdKSB7XG5cdCAgICAgICAgICAgIHJldHVybiB0aGlzLl9jYWNoZVttZXRob2RdO1xuXHQgICAgICAgIH1cblx0ICAgICAgICB2YXIgcmVzdWx0ID0gKDAsIGxpYiRxLmZldGNoSnNvbikodGhpcy5jb25uZWN0aW9uLCBKU09OLnN0cmluZ2lmeShyZXF1ZXN0KSwgZ2V0UmVzdWx0KS50aGVuKGZ1bmN0aW9uIChyZXN1bHQpIHtcblx0ICAgICAgICAgICAgX3RoaXMuZW1pdChcImRlYnVnXCIsIHtcblx0ICAgICAgICAgICAgICAgIGFjdGlvbjogXCJyZXNwb25zZVwiLFxuXHQgICAgICAgICAgICAgICAgcmVxdWVzdDogcmVxdWVzdCxcblx0ICAgICAgICAgICAgICAgIHJlc3BvbnNlOiByZXN1bHQsXG5cdCAgICAgICAgICAgICAgICBwcm92aWRlcjogX3RoaXNcblx0ICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG5cdCAgICAgICAgfSwgZnVuY3Rpb24gKGVycm9yKSB7XG5cdCAgICAgICAgICAgIF90aGlzLmVtaXQoXCJkZWJ1Z1wiLCB7XG5cdCAgICAgICAgICAgICAgICBhY3Rpb246IFwicmVzcG9uc2VcIixcblx0ICAgICAgICAgICAgICAgIGVycm9yOiBlcnJvcixcblx0ICAgICAgICAgICAgICAgIHJlcXVlc3Q6IHJlcXVlc3QsXG5cdCAgICAgICAgICAgICAgICBwcm92aWRlcjogX3RoaXNcblx0ICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgICAgIHRocm93IGVycm9yO1xuXHQgICAgICAgIH0pO1xuXHQgICAgICAgIC8vIENhY2hlIHRoZSBmZXRjaCwgYnV0IGNsZWFyIGl0IG9uIHRoZSBuZXh0IGV2ZW50IGxvb3Bcblx0ICAgICAgICBpZiAoY2FjaGUpIHtcblx0ICAgICAgICAgICAgdGhpcy5fY2FjaGVbbWV0aG9kXSA9IHJlc3VsdDtcblx0ICAgICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgICAgICBfdGhpcy5fY2FjaGVbbWV0aG9kXSA9IG51bGw7XG5cdCAgICAgICAgICAgIH0sIDApO1xuXHQgICAgICAgIH1cblx0ICAgICAgICByZXR1cm4gcmVzdWx0O1xuXHQgICAgfTtcblx0ICAgIEpzb25ScGNQcm92aWRlci5wcm90b3R5cGUucHJlcGFyZVJlcXVlc3QgPSBmdW5jdGlvbiAobWV0aG9kLCBwYXJhbXMpIHtcblx0ICAgICAgICBzd2l0Y2ggKG1ldGhvZCkge1xuXHQgICAgICAgICAgICBjYXNlIFwiZ2V0QmxvY2tOdW1iZXJcIjpcblx0ICAgICAgICAgICAgICAgIHJldHVybiBbXCJldGhfYmxvY2tOdW1iZXJcIiwgW11dO1xuXHQgICAgICAgICAgICBjYXNlIFwiZ2V0R2FzUHJpY2VcIjpcblx0ICAgICAgICAgICAgICAgIHJldHVybiBbXCJldGhfZ2FzUHJpY2VcIiwgW11dO1xuXHQgICAgICAgICAgICBjYXNlIFwiZ2V0QmFsYW5jZVwiOlxuXHQgICAgICAgICAgICAgICAgcmV0dXJuIFtcImV0aF9nZXRCYWxhbmNlXCIsIFtnZXRMb3dlckNhc2UocGFyYW1zLmFkZHJlc3MpLCBwYXJhbXMuYmxvY2tUYWddXTtcblx0ICAgICAgICAgICAgY2FzZSBcImdldFRyYW5zYWN0aW9uQ291bnRcIjpcblx0ICAgICAgICAgICAgICAgIHJldHVybiBbXCJldGhfZ2V0VHJhbnNhY3Rpb25Db3VudFwiLCBbZ2V0TG93ZXJDYXNlKHBhcmFtcy5hZGRyZXNzKSwgcGFyYW1zLmJsb2NrVGFnXV07XG5cdCAgICAgICAgICAgIGNhc2UgXCJnZXRDb2RlXCI6XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gW1wiZXRoX2dldENvZGVcIiwgW2dldExvd2VyQ2FzZShwYXJhbXMuYWRkcmVzcyksIHBhcmFtcy5ibG9ja1RhZ11dO1xuXHQgICAgICAgICAgICBjYXNlIFwiZ2V0U3RvcmFnZUF0XCI6XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gW1wiZXRoX2dldFN0b3JhZ2VBdFwiLCBbZ2V0TG93ZXJDYXNlKHBhcmFtcy5hZGRyZXNzKSwgcGFyYW1zLnBvc2l0aW9uLCBwYXJhbXMuYmxvY2tUYWddXTtcblx0ICAgICAgICAgICAgY2FzZSBcInNlbmRUcmFuc2FjdGlvblwiOlxuXHQgICAgICAgICAgICAgICAgcmV0dXJuIFtcImV0aF9zZW5kUmF3VHJhbnNhY3Rpb25cIiwgW3BhcmFtcy5zaWduZWRUcmFuc2FjdGlvbl1dO1xuXHQgICAgICAgICAgICBjYXNlIFwiZ2V0QmxvY2tcIjpcblx0ICAgICAgICAgICAgICAgIGlmIChwYXJhbXMuYmxvY2tUYWcpIHtcblx0ICAgICAgICAgICAgICAgICAgICByZXR1cm4gW1wiZXRoX2dldEJsb2NrQnlOdW1iZXJcIiwgW3BhcmFtcy5ibG9ja1RhZywgISFwYXJhbXMuaW5jbHVkZVRyYW5zYWN0aW9uc11dO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgZWxzZSBpZiAocGFyYW1zLmJsb2NrSGFzaCkge1xuXHQgICAgICAgICAgICAgICAgICAgIHJldHVybiBbXCJldGhfZ2V0QmxvY2tCeUhhc2hcIiwgW3BhcmFtcy5ibG9ja0hhc2gsICEhcGFyYW1zLmluY2x1ZGVUcmFuc2FjdGlvbnNdXTtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuXHQgICAgICAgICAgICBjYXNlIFwiZ2V0VHJhbnNhY3Rpb25cIjpcblx0ICAgICAgICAgICAgICAgIHJldHVybiBbXCJldGhfZ2V0VHJhbnNhY3Rpb25CeUhhc2hcIiwgW3BhcmFtcy50cmFuc2FjdGlvbkhhc2hdXTtcblx0ICAgICAgICAgICAgY2FzZSBcImdldFRyYW5zYWN0aW9uUmVjZWlwdFwiOlxuXHQgICAgICAgICAgICAgICAgcmV0dXJuIFtcImV0aF9nZXRUcmFuc2FjdGlvblJlY2VpcHRcIiwgW3BhcmFtcy50cmFuc2FjdGlvbkhhc2hdXTtcblx0ICAgICAgICAgICAgY2FzZSBcImNhbGxcIjoge1xuXHQgICAgICAgICAgICAgICAgdmFyIGhleGxpZnlUcmFuc2FjdGlvbiA9ICgwLCBsaWIkMy5nZXRTdGF0aWMpKHRoaXMuY29uc3RydWN0b3IsIFwiaGV4bGlmeVRyYW5zYWN0aW9uXCIpO1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuIFtcImV0aF9jYWxsXCIsIFtoZXhsaWZ5VHJhbnNhY3Rpb24ocGFyYW1zLnRyYW5zYWN0aW9uLCB7IGZyb206IHRydWUgfSksIHBhcmFtcy5ibG9ja1RhZ11dO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIGNhc2UgXCJlc3RpbWF0ZUdhc1wiOiB7XG5cdCAgICAgICAgICAgICAgICB2YXIgaGV4bGlmeVRyYW5zYWN0aW9uID0gKDAsIGxpYiQzLmdldFN0YXRpYykodGhpcy5jb25zdHJ1Y3RvciwgXCJoZXhsaWZ5VHJhbnNhY3Rpb25cIik7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gW1wiZXRoX2VzdGltYXRlR2FzXCIsIFtoZXhsaWZ5VHJhbnNhY3Rpb24ocGFyYW1zLnRyYW5zYWN0aW9uLCB7IGZyb206IHRydWUgfSldXTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICBjYXNlIFwiZ2V0TG9nc1wiOlxuXHQgICAgICAgICAgICAgICAgaWYgKHBhcmFtcy5maWx0ZXIgJiYgcGFyYW1zLmZpbHRlci5hZGRyZXNzICE9IG51bGwpIHtcblx0ICAgICAgICAgICAgICAgICAgICBwYXJhbXMuZmlsdGVyLmFkZHJlc3MgPSBnZXRMb3dlckNhc2UocGFyYW1zLmZpbHRlci5hZGRyZXNzKTtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgIHJldHVybiBbXCJldGhfZ2V0TG9nc1wiLCBbcGFyYW1zLmZpbHRlcl1dO1xuXHQgICAgICAgICAgICBkZWZhdWx0OlxuXHQgICAgICAgICAgICAgICAgYnJlYWs7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHJldHVybiBudWxsO1xuXHQgICAgfTtcblx0ICAgIEpzb25ScGNQcm92aWRlci5wcm90b3R5cGUucGVyZm9ybSA9IGZ1bmN0aW9uIChtZXRob2QsIHBhcmFtcykge1xuXHQgICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgdmFyIHR4LCBmZWVEYXRhLCBhcmdzLCBlcnJvcl80O1xuXHQgICAgICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG5cdCAgICAgICAgICAgICAgICBzd2l0Y2ggKF9hLmxhYmVsKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgY2FzZSAwOlxuXHQgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIShtZXRob2QgPT09IFwiY2FsbFwiIHx8IG1ldGhvZCA9PT0gXCJlc3RpbWF0ZUdhc1wiKSkgcmV0dXJuIFszIC8qYnJlYWsqLywgMl07XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHR4ID0gcGFyYW1zLnRyYW5zYWN0aW9uO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBpZiAoISh0eCAmJiB0eC50eXBlICE9IG51bGwgJiYgbGliJDIuQmlnTnVtYmVyLmZyb20odHgudHlwZSkuaXNaZXJvKCkpKSByZXR1cm4gWzMgLypicmVhayovLCAyXTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCEodHgubWF4RmVlUGVyR2FzID09IG51bGwgJiYgdHgubWF4UHJpb3JpdHlGZWVQZXJHYXMgPT0gbnVsbCkpIHJldHVybiBbMyAvKmJyZWFrKi8sIDJdO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCB0aGlzLmdldEZlZURhdGEoKV07XG5cdCAgICAgICAgICAgICAgICAgICAgY2FzZSAxOlxuXHQgICAgICAgICAgICAgICAgICAgICAgICBmZWVEYXRhID0gX2Euc2VudCgpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZmVlRGF0YS5tYXhGZWVQZXJHYXMgPT0gbnVsbCAmJiBmZWVEYXRhLm1heFByaW9yaXR5RmVlUGVyR2FzID09IG51bGwpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIE5ldHdvcmsgZG9lc24ndCBrbm93IGFib3V0IEVJUC0xNTU5IChhbmQgaGVuY2UgdHlwZSlcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhcmFtcyA9ICgwLCBsaWIkMy5zaGFsbG93Q29weSkocGFyYW1zKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhcmFtcy50cmFuc2FjdGlvbiA9ICgwLCBsaWIkMy5zaGFsbG93Q29weSkodHgpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVsZXRlIHBhcmFtcy50cmFuc2FjdGlvbi50eXBlO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIF9hLmxhYmVsID0gMjtcblx0ICAgICAgICAgICAgICAgICAgICBjYXNlIDI6XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGFyZ3MgPSB0aGlzLnByZXBhcmVSZXF1ZXN0KG1ldGhvZCwgcGFyYW1zKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGFyZ3MgPT0gbnVsbCkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgbG9nZ2VyLnRocm93RXJyb3IobWV0aG9kICsgXCIgbm90IGltcGxlbWVudGVkXCIsIGxpYi5Mb2dnZXIuZXJyb3JzLk5PVF9JTVBMRU1FTlRFRCwgeyBvcGVyYXRpb246IG1ldGhvZCB9KTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgICAgICBfYS5sYWJlbCA9IDM7XG5cdCAgICAgICAgICAgICAgICAgICAgY2FzZSAzOlxuXHQgICAgICAgICAgICAgICAgICAgICAgICBfYS50cnlzLnB1c2goWzMsIDUsICwgNl0pO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCB0aGlzLnNlbmQoYXJnc1swXSwgYXJnc1sxXSldO1xuXHQgICAgICAgICAgICAgICAgICAgIGNhc2UgNDogcmV0dXJuIFsyIC8qcmV0dXJuKi8sIF9hLnNlbnQoKV07XG5cdCAgICAgICAgICAgICAgICAgICAgY2FzZSA1OlxuXHQgICAgICAgICAgICAgICAgICAgICAgICBlcnJvcl80ID0gX2Euc2VudCgpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgY2hlY2tFcnJvcihtZXRob2QsIGVycm9yXzQsIHBhcmFtcyldO1xuXHQgICAgICAgICAgICAgICAgICAgIGNhc2UgNjogcmV0dXJuIFsyIC8qcmV0dXJuKi9dO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB9KTtcblx0ICAgICAgICB9KTtcblx0ICAgIH07XG5cdCAgICBKc29uUnBjUHJvdmlkZXIucHJvdG90eXBlLl9zdGFydEV2ZW50ID0gZnVuY3Rpb24gKGV2ZW50KSB7XG5cdCAgICAgICAgaWYgKGV2ZW50LnRhZyA9PT0gXCJwZW5kaW5nXCIpIHtcblx0ICAgICAgICAgICAgdGhpcy5fc3RhcnRQZW5kaW5nKCk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIF9zdXBlci5wcm90b3R5cGUuX3N0YXJ0RXZlbnQuY2FsbCh0aGlzLCBldmVudCk7XG5cdCAgICB9O1xuXHQgICAgSnNvblJwY1Byb3ZpZGVyLnByb3RvdHlwZS5fc3RhcnRQZW5kaW5nID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIGlmICh0aGlzLl9wZW5kaW5nRmlsdGVyICE9IG51bGwpIHtcblx0ICAgICAgICAgICAgcmV0dXJuO1xuXHQgICAgICAgIH1cblx0ICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG5cdCAgICAgICAgdmFyIHBlbmRpbmdGaWx0ZXIgPSB0aGlzLnNlbmQoXCJldGhfbmV3UGVuZGluZ1RyYW5zYWN0aW9uRmlsdGVyXCIsIFtdKTtcblx0ICAgICAgICB0aGlzLl9wZW5kaW5nRmlsdGVyID0gcGVuZGluZ0ZpbHRlcjtcblx0ICAgICAgICBwZW5kaW5nRmlsdGVyLnRoZW4oZnVuY3Rpb24gKGZpbHRlcklkKSB7XG5cdCAgICAgICAgICAgIGZ1bmN0aW9uIHBvbGwoKSB7XG5cdCAgICAgICAgICAgICAgICBzZWxmLnNlbmQoXCJldGhfZ2V0RmlsdGVyQ2hhbmdlc1wiLCBbZmlsdGVySWRdKS50aGVuKGZ1bmN0aW9uIChoYXNoZXMpIHtcblx0ICAgICAgICAgICAgICAgICAgICBpZiAoc2VsZi5fcGVuZGluZ0ZpbHRlciAhPSBwZW5kaW5nRmlsdGVyKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuXHQgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICB2YXIgc2VxID0gUHJvbWlzZS5yZXNvbHZlKCk7XG5cdCAgICAgICAgICAgICAgICAgICAgaGFzaGVzLmZvckVhY2goZnVuY3Rpb24gKGhhc2gpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgLy8gQFRPRE86IFRoaXMgc2hvdWxkIGJlIGdhcmJhZ2UgY29sbGVjdGVkIGF0IHNvbWUgcG9pbnQuLi4gSG93PyBXaGVuP1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBzZWxmLl9lbWl0dGVkW1widDpcIiArIGhhc2gudG9Mb3dlckNhc2UoKV0gPSBcInBlbmRpbmdcIjtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgc2VxID0gc2VxLnRoZW4oZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNlbGYuZ2V0VHJhbnNhY3Rpb24oaGFzaCkudGhlbihmdW5jdGlvbiAodHgpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWxmLmVtaXQoXCJwZW5kaW5nXCIsIHR4KTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB9KTtcblx0ICAgICAgICAgICAgICAgICAgICB9KTtcblx0ICAgICAgICAgICAgICAgICAgICByZXR1cm4gc2VxLnRoZW4oZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGltZXIoMTAwMCk7XG5cdCAgICAgICAgICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgICAgICAgICB9KS50aGVuKGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgICAgICAgICBpZiAoc2VsZi5fcGVuZGluZ0ZpbHRlciAhPSBwZW5kaW5nRmlsdGVyKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuc2VuZChcImV0aF91bmluc3RhbGxGaWx0ZXJcIiwgW2ZpbHRlcklkXSk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcblx0ICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7IHBvbGwoKTsgfSwgMCk7XG5cdCAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG5cdCAgICAgICAgICAgICAgICB9KS5jYXRjaChmdW5jdGlvbiAoZXJyb3IpIHsgfSk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgcG9sbCgpO1xuXHQgICAgICAgICAgICByZXR1cm4gZmlsdGVySWQ7XG5cdCAgICAgICAgfSkuY2F0Y2goZnVuY3Rpb24gKGVycm9yKSB7IH0pO1xuXHQgICAgfTtcblx0ICAgIEpzb25ScGNQcm92aWRlci5wcm90b3R5cGUuX3N0b3BFdmVudCA9IGZ1bmN0aW9uIChldmVudCkge1xuXHQgICAgICAgIGlmIChldmVudC50YWcgPT09IFwicGVuZGluZ1wiICYmIHRoaXMubGlzdGVuZXJDb3VudChcInBlbmRpbmdcIikgPT09IDApIHtcblx0ICAgICAgICAgICAgdGhpcy5fcGVuZGluZ0ZpbHRlciA9IG51bGw7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIF9zdXBlci5wcm90b3R5cGUuX3N0b3BFdmVudC5jYWxsKHRoaXMsIGV2ZW50KTtcblx0ICAgIH07XG5cdCAgICAvLyBDb252ZXJ0IGFuIGV0aGVycy5qcyB0cmFuc2FjdGlvbiBpbnRvIGEgSlNPTi1SUEMgdHJhbnNhY3Rpb25cblx0ICAgIC8vICAtIGdhc0xpbWl0ID0+IGdhc1xuXHQgICAgLy8gIC0gQWxsIHZhbHVlcyBoZXhsaWZpZWRcblx0ICAgIC8vICAtIEFsbCBudW1lcmljIHZhbHVlcyB6ZXJvLXN0cmlwZWRcblx0ICAgIC8vICAtIEFsbCBhZGRyZXNzZXMgYXJlIGxvd2VyY2FzZWRcblx0ICAgIC8vIE5PVEU6IFRoaXMgYWxsb3dzIGEgVHJhbnNhY3Rpb25SZXF1ZXN0LCBidXQgYWxsIHZhbHVlcyBzaG91bGQgYmUgcmVzb2x2ZWRcblx0ICAgIC8vICAgICAgIGJlZm9yZSB0aGlzIGlzIGNhbGxlZFxuXHQgICAgLy8gQFRPRE86IFRoaXMgd2lsbCBsaWtlbHkgYmUgcmVtb3ZlZCBpbiBmdXR1cmUgdmVyc2lvbnMgYW5kIHByZXBhcmVSZXF1ZXN0XG5cdCAgICAvLyAgICAgICAgd2lsbCBiZSB0aGUgcHJlZmVycmVkIG1ldGhvZCBmb3IgdGhpcy5cblx0ICAgIEpzb25ScGNQcm92aWRlci5oZXhsaWZ5VHJhbnNhY3Rpb24gPSBmdW5jdGlvbiAodHJhbnNhY3Rpb24sIGFsbG93RXh0cmEpIHtcblx0ICAgICAgICAvLyBDaGVjayBvbmx5IGFsbG93ZWQgcHJvcGVydGllcyBhcmUgZ2l2ZW5cblx0ICAgICAgICB2YXIgYWxsb3dlZCA9ICgwLCBsaWIkMy5zaGFsbG93Q29weSkoYWxsb3dlZFRyYW5zYWN0aW9uS2V5cyk7XG5cdCAgICAgICAgaWYgKGFsbG93RXh0cmEpIHtcblx0ICAgICAgICAgICAgZm9yICh2YXIga2V5IGluIGFsbG93RXh0cmEpIHtcblx0ICAgICAgICAgICAgICAgIGlmIChhbGxvd0V4dHJhW2tleV0pIHtcblx0ICAgICAgICAgICAgICAgICAgICBhbGxvd2VkW2tleV0gPSB0cnVlO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfVxuXHQgICAgICAgICgwLCBsaWIkMy5jaGVja1Byb3BlcnRpZXMpKHRyYW5zYWN0aW9uLCBhbGxvd2VkKTtcblx0ICAgICAgICB2YXIgcmVzdWx0ID0ge307XG5cdCAgICAgICAgLy8gU29tZSBub2RlcyAoSU5GVVJBIHJvcHN0ZW47IElORlVSQSBtYWlubmV0IGlzIGZpbmUpIGRvIG5vdCBsaWtlIGxlYWRpbmcgemVyb3MuXG5cdCAgICAgICAgW1wiZ2FzTGltaXRcIiwgXCJnYXNQcmljZVwiLCBcInR5cGVcIiwgXCJtYXhGZWVQZXJHYXNcIiwgXCJtYXhQcmlvcml0eUZlZVBlckdhc1wiLCBcIm5vbmNlXCIsIFwidmFsdWVcIl0uZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG5cdCAgICAgICAgICAgIGlmICh0cmFuc2FjdGlvbltrZXldID09IG51bGwpIHtcblx0ICAgICAgICAgICAgICAgIHJldHVybjtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB2YXIgdmFsdWUgPSAoMCwgbGliJDEuaGV4VmFsdWUpKHRyYW5zYWN0aW9uW2tleV0pO1xuXHQgICAgICAgICAgICBpZiAoa2V5ID09PSBcImdhc0xpbWl0XCIpIHtcblx0ICAgICAgICAgICAgICAgIGtleSA9IFwiZ2FzXCI7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgcmVzdWx0W2tleV0gPSB2YWx1ZTtcblx0ICAgICAgICB9KTtcblx0ICAgICAgICBbXCJmcm9tXCIsIFwidG9cIiwgXCJkYXRhXCJdLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuXHQgICAgICAgICAgICBpZiAodHJhbnNhY3Rpb25ba2V5XSA9PSBudWxsKSB7XG5cdCAgICAgICAgICAgICAgICByZXR1cm47XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgcmVzdWx0W2tleV0gPSAoMCwgbGliJDEuaGV4bGlmeSkodHJhbnNhY3Rpb25ba2V5XSk7XG5cdCAgICAgICAgfSk7XG5cdCAgICAgICAgaWYgKHRyYW5zYWN0aW9uLmFjY2Vzc0xpc3QpIHtcblx0ICAgICAgICAgICAgcmVzdWx0W1wiYWNjZXNzTGlzdFwiXSA9ICgwLCBsaWIkZS5hY2Nlc3NMaXN0aWZ5KSh0cmFuc2FjdGlvbi5hY2Nlc3NMaXN0KTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgcmV0dXJuIHJlc3VsdDtcblx0ICAgIH07XG5cdCAgICByZXR1cm4gSnNvblJwY1Byb3ZpZGVyO1xuXHR9KGJhc2VQcm92aWRlci5CYXNlUHJvdmlkZXIpKTtcblx0ZXhwb3J0cy5Kc29uUnBjUHJvdmlkZXIgPSBKc29uUnBjUHJvdmlkZXI7XG5cblx0fSk7XG5cblx0dmFyIGpzb25ScGNQcm92aWRlciQxID0gLypAX19QVVJFX18qL2dldERlZmF1bHRFeHBvcnRGcm9tQ2pzKGpzb25ScGNQcm92aWRlcik7XG5cblx0dmFyIGJyb3dzZXJXcyA9IGNyZWF0ZUNvbW1vbmpzTW9kdWxlKGZ1bmN0aW9uIChtb2R1bGUsIGV4cG9ydHMpIHtcblx0XCJ1c2Ugc3RyaWN0XCI7XG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcblx0ZXhwb3J0cy5XZWJTb2NrZXQgPSB2b2lkIDA7XG5cblxuXHR2YXIgV1MgPSBudWxsO1xuXHRleHBvcnRzLldlYlNvY2tldCA9IFdTO1xuXHR0cnkge1xuXHQgICAgZXhwb3J0cy5XZWJTb2NrZXQgPSBXUyA9IFdlYlNvY2tldDtcblx0ICAgIGlmIChXUyA9PSBudWxsKSB7XG5cdCAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiaW5qZWN0IHBsZWFzZVwiKTtcblx0ICAgIH1cblx0fVxuXHRjYXRjaCAoZXJyb3IpIHtcblx0ICAgIHZhciBsb2dnZXJfMiA9IG5ldyBsaWIuTG9nZ2VyKF92ZXJzaW9uJEkudmVyc2lvbik7XG5cdCAgICBleHBvcnRzLldlYlNvY2tldCA9IFdTID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIGxvZ2dlcl8yLnRocm93RXJyb3IoXCJXZWJTb2NrZXRzIG5vdCBzdXBwb3J0ZWQgaW4gdGhpcyBlbnZpcm9ubWVudFwiLCBsaWIuTG9nZ2VyLmVycm9ycy5VTlNVUFBPUlRFRF9PUEVSQVRJT04sIHtcblx0ICAgICAgICAgICAgb3BlcmF0aW9uOiBcIm5ldyBXZWJTb2NrZXQoKVwiXG5cdCAgICAgICAgfSk7XG5cdCAgICB9O1xuXHR9XG5cblx0fSk7XG5cblx0dmFyIGJyb3dzZXJXcyQxID0gLypAX19QVVJFX18qL2dldERlZmF1bHRFeHBvcnRGcm9tQ2pzKGJyb3dzZXJXcyk7XG5cblx0dmFyIHdlYnNvY2tldFByb3ZpZGVyID0gY3JlYXRlQ29tbW9uanNNb2R1bGUoZnVuY3Rpb24gKG1vZHVsZSwgZXhwb3J0cykge1xuXHRcInVzZSBzdHJpY3RcIjtcblx0dmFyIF9fZXh0ZW5kcyA9IChjb21tb25qc0dsb2JhbCAmJiBjb21tb25qc0dsb2JhbC5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG5cdCAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IGZ1bmN0aW9uIChkLCBiKSB7XG5cdCAgICAgICAgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuXHQgICAgICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG5cdCAgICAgICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChiLCBwKSkgZFtwXSA9IGJbcF07IH07XG5cdCAgICAgICAgcmV0dXJuIGV4dGVuZFN0YXRpY3MoZCwgYik7XG5cdCAgICB9O1xuXHQgICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG5cdCAgICAgICAgaWYgKHR5cGVvZiBiICE9PSBcImZ1bmN0aW9uXCIgJiYgYiAhPT0gbnVsbClcblx0ICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNsYXNzIGV4dGVuZHMgdmFsdWUgXCIgKyBTdHJpbmcoYikgKyBcIiBpcyBub3QgYSBjb25zdHJ1Y3RvciBvciBudWxsXCIpO1xuXHQgICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG5cdCAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG5cdCAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuXHQgICAgfTtcblx0fSkoKTtcblx0dmFyIF9fYXdhaXRlciA9IChjb21tb25qc0dsb2JhbCAmJiBjb21tb25qc0dsb2JhbC5fX2F3YWl0ZXIpIHx8IGZ1bmN0aW9uICh0aGlzQXJnLCBfYXJndW1lbnRzLCBQLCBnZW5lcmF0b3IpIHtcblx0ICAgIGZ1bmN0aW9uIGFkb3B0KHZhbHVlKSB7IHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIFAgPyB2YWx1ZSA6IG5ldyBQKGZ1bmN0aW9uIChyZXNvbHZlKSB7IHJlc29sdmUodmFsdWUpOyB9KTsgfVxuXHQgICAgcmV0dXJuIG5ldyAoUCB8fCAoUCA9IFByb21pc2UpKShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG5cdCAgICAgICAgZnVuY3Rpb24gZnVsZmlsbGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yLm5leHQodmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuXHQgICAgICAgIGZ1bmN0aW9uIHJlamVjdGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yW1widGhyb3dcIl0odmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuXHQgICAgICAgIGZ1bmN0aW9uIHN0ZXAocmVzdWx0KSB7IHJlc3VsdC5kb25lID8gcmVzb2x2ZShyZXN1bHQudmFsdWUpIDogYWRvcHQocmVzdWx0LnZhbHVlKS50aGVuKGZ1bGZpbGxlZCwgcmVqZWN0ZWQpOyB9XG5cdCAgICAgICAgc3RlcCgoZ2VuZXJhdG9yID0gZ2VuZXJhdG9yLmFwcGx5KHRoaXNBcmcsIF9hcmd1bWVudHMgfHwgW10pKS5uZXh0KCkpO1xuXHQgICAgfSk7XG5cdH07XG5cdHZhciBfX2dlbmVyYXRvciA9IChjb21tb25qc0dsb2JhbCAmJiBjb21tb25qc0dsb2JhbC5fX2dlbmVyYXRvcikgfHwgZnVuY3Rpb24gKHRoaXNBcmcsIGJvZHkpIHtcblx0ICAgIHZhciBfID0geyBsYWJlbDogMCwgc2VudDogZnVuY3Rpb24oKSB7IGlmICh0WzBdICYgMSkgdGhyb3cgdFsxXTsgcmV0dXJuIHRbMV07IH0sIHRyeXM6IFtdLCBvcHM6IFtdIH0sIGYsIHksIHQsIGc7XG5cdCAgICByZXR1cm4gZyA9IHsgbmV4dDogdmVyYigwKSwgXCJ0aHJvd1wiOiB2ZXJiKDEpLCBcInJldHVyblwiOiB2ZXJiKDIpIH0sIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiAoZ1tTeW1ib2wuaXRlcmF0b3JdID0gZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzOyB9KSwgZztcblx0ICAgIGZ1bmN0aW9uIHZlcmIobikgeyByZXR1cm4gZnVuY3Rpb24gKHYpIHsgcmV0dXJuIHN0ZXAoW24sIHZdKTsgfTsgfVxuXHQgICAgZnVuY3Rpb24gc3RlcChvcCkge1xuXHQgICAgICAgIGlmIChmKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiR2VuZXJhdG9yIGlzIGFscmVhZHkgZXhlY3V0aW5nLlwiKTtcblx0ICAgICAgICB3aGlsZSAoXykgdHJ5IHtcblx0ICAgICAgICAgICAgaWYgKGYgPSAxLCB5ICYmICh0ID0gb3BbMF0gJiAyID8geVtcInJldHVyblwiXSA6IG9wWzBdID8geVtcInRocm93XCJdIHx8ICgodCA9IHlbXCJyZXR1cm5cIl0pICYmIHQuY2FsbCh5KSwgMCkgOiB5Lm5leHQpICYmICEodCA9IHQuY2FsbCh5LCBvcFsxXSkpLmRvbmUpIHJldHVybiB0O1xuXHQgICAgICAgICAgICBpZiAoeSA9IDAsIHQpIG9wID0gW29wWzBdICYgMiwgdC52YWx1ZV07XG5cdCAgICAgICAgICAgIHN3aXRjaCAob3BbMF0pIHtcblx0ICAgICAgICAgICAgICAgIGNhc2UgMDogY2FzZSAxOiB0ID0gb3A7IGJyZWFrO1xuXHQgICAgICAgICAgICAgICAgY2FzZSA0OiBfLmxhYmVsKys7IHJldHVybiB7IHZhbHVlOiBvcFsxXSwgZG9uZTogZmFsc2UgfTtcblx0ICAgICAgICAgICAgICAgIGNhc2UgNTogXy5sYWJlbCsrOyB5ID0gb3BbMV07IG9wID0gWzBdOyBjb250aW51ZTtcblx0ICAgICAgICAgICAgICAgIGNhc2UgNzogb3AgPSBfLm9wcy5wb3AoKTsgXy50cnlzLnBvcCgpOyBjb250aW51ZTtcblx0ICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKCEodCA9IF8udHJ5cywgdCA9IHQubGVuZ3RoID4gMCAmJiB0W3QubGVuZ3RoIC0gMV0pICYmIChvcFswXSA9PT0gNiB8fCBvcFswXSA9PT0gMikpIHsgXyA9IDA7IGNvbnRpbnVlOyB9XG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKG9wWzBdID09PSAzICYmICghdCB8fCAob3BbMV0gPiB0WzBdICYmIG9wWzFdIDwgdFszXSkpKSB7IF8ubGFiZWwgPSBvcFsxXTsgYnJlYWs7IH1cblx0ICAgICAgICAgICAgICAgICAgICBpZiAob3BbMF0gPT09IDYgJiYgXy5sYWJlbCA8IHRbMV0pIHsgXy5sYWJlbCA9IHRbMV07IHQgPSBvcDsgYnJlYWs7IH1cblx0ICAgICAgICAgICAgICAgICAgICBpZiAodCAmJiBfLmxhYmVsIDwgdFsyXSkgeyBfLmxhYmVsID0gdFsyXTsgXy5vcHMucHVzaChvcCk7IGJyZWFrOyB9XG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKHRbMl0pIF8ub3BzLnBvcCgpO1xuXHQgICAgICAgICAgICAgICAgICAgIF8udHJ5cy5wb3AoKTsgY29udGludWU7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgb3AgPSBib2R5LmNhbGwodGhpc0FyZywgXyk7XG5cdCAgICAgICAgfSBjYXRjaCAoZSkgeyBvcCA9IFs2LCBlXTsgeSA9IDA7IH0gZmluYWxseSB7IGYgPSB0ID0gMDsgfVxuXHQgICAgICAgIGlmIChvcFswXSAmIDUpIHRocm93IG9wWzFdOyByZXR1cm4geyB2YWx1ZTogb3BbMF0gPyBvcFsxXSA6IHZvaWQgMCwgZG9uZTogdHJ1ZSB9O1xuXHQgICAgfVxuXHR9O1xuXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5cdGV4cG9ydHMuV2ViU29ja2V0UHJvdmlkZXIgPSB2b2lkIDA7XG5cblxuXG5cblxuXG5cdHZhciBsb2dnZXIgPSBuZXcgbGliLkxvZ2dlcihfdmVyc2lvbiRJLnZlcnNpb24pO1xuXHQvKipcblx0ICogIE5vdGVzOlxuXHQgKlxuXHQgKiAgVGhpcyBwcm92aWRlciBkaWZmZXJzIGEgYml0IGZyb20gdGhlIHBvbGxpbmcgcHJvdmlkZXJzLiBPbmUgbWFpblxuXHQgKiAgZGlmZmVyZW5jZSBpcyBob3cgaXQgaGFuZGxlcyBjb25zaXN0ZW5jeS4gVGhlIHBvbGxpbmcgcHJvdmlkZXJzXG5cdCAqICB3aWxsIHN0YWxsIHJlc3BvbnNlcyB0byBlbnN1cmUgYSBjb25zaXN0ZW50IHN0YXRlLCB3aGlsZSB0aGlzXG5cdCAqICBXZWJTb2NrZXQgcHJvdmlkZXIgYXNzdW1lcyB0aGUgY29ubmVjdGVkIGJhY2tlbmQgd2lsbCBtYW5hZ2UgdGhpcy5cblx0ICpcblx0ICogIEZvciBleGFtcGxlLCBpZiBhIHBvbGxpbmcgcHJvdmlkZXIgZW1pdHMgYW4gZXZlbnQgd2hpY2ggaW5kaWNhdGVzXG5cdCAqICB0aGUgZXZlbnQgb2NjdXJyZWQgaW4gYmxvY2toYXNoIFhYWCwgYSBjYWxsIHRvIGZldGNoIHRoYXQgYmxvY2sgYnlcblx0ICogIGl0cyBoYXNoIFhYWCwgaWYgbm90IHByZXNlbnQgd2lsbCByZXRyeSB1bnRpbCBpdCBpcyBwcmVzZW50LiBUaGlzXG5cdCAqICBjYW4gb2NjdXIgd2hlbiBxdWVyeWluZyBhIHBvb2wgb2Ygbm9kZXMgdGhhdCBhcmUgbWlsZGx5IG91dCBvZiBzeW5jXG5cdCAqICB3aXRoIGVhY2ggb3RoZXIuXG5cdCAqL1xuXHR2YXIgTmV4dElkID0gMTtcblx0Ly8gRm9yIG1vcmUgaW5mbyBhYm91dCB0aGUgUmVhbC10aW1lIEV2ZW50IEFQSSBzZWU6XG5cdC8vICAgaHR0cHM6Ly9nZXRoLmV0aGVyZXVtLm9yZy9kb2NzL3JwYy9wdWJzdWJcblx0dmFyIFdlYlNvY2tldFByb3ZpZGVyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuXHQgICAgX19leHRlbmRzKFdlYlNvY2tldFByb3ZpZGVyLCBfc3VwZXIpO1xuXHQgICAgZnVuY3Rpb24gV2ViU29ja2V0UHJvdmlkZXIodXJsLCBuZXR3b3JrKSB7XG5cdCAgICAgICAgdmFyIF90aGlzID0gdGhpcztcblx0ICAgICAgICAvLyBUaGlzIHdpbGwgYmUgYWRkZWQgaW4gdGhlIGZ1dHVyZTsgcGxlYXNlIG9wZW4gYW4gaXNzdWUgdG8gZXhwZWRpdGVcblx0ICAgICAgICBpZiAobmV0d29yayA9PT0gXCJhbnlcIikge1xuXHQgICAgICAgICAgICBsb2dnZXIudGhyb3dFcnJvcihcIldlYlNvY2tldFByb3ZpZGVyIGRvZXMgbm90IHN1cHBvcnQgJ2FueScgbmV0d29yayB5ZXRcIiwgbGliLkxvZ2dlci5lcnJvcnMuVU5TVVBQT1JURURfT1BFUkFUSU9OLCB7XG5cdCAgICAgICAgICAgICAgICBvcGVyYXRpb246IFwibmV0d29yazphbnlcIlxuXHQgICAgICAgICAgICB9KTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCB1cmwsIG5ldHdvcmspIHx8IHRoaXM7XG5cdCAgICAgICAgX3RoaXMuX3BvbGxpbmdJbnRlcnZhbCA9IC0xO1xuXHQgICAgICAgIF90aGlzLl93c1JlYWR5ID0gZmFsc2U7XG5cdCAgICAgICAgKDAsIGxpYiQzLmRlZmluZVJlYWRPbmx5KShfdGhpcywgXCJfd2Vic29ja2V0XCIsIG5ldyBicm93c2VyV3MuV2ViU29ja2V0KF90aGlzLmNvbm5lY3Rpb24udXJsKSk7XG5cdCAgICAgICAgKDAsIGxpYiQzLmRlZmluZVJlYWRPbmx5KShfdGhpcywgXCJfcmVxdWVzdHNcIiwge30pO1xuXHQgICAgICAgICgwLCBsaWIkMy5kZWZpbmVSZWFkT25seSkoX3RoaXMsIFwiX3N1YnNcIiwge30pO1xuXHQgICAgICAgICgwLCBsaWIkMy5kZWZpbmVSZWFkT25seSkoX3RoaXMsIFwiX3N1Yklkc1wiLCB7fSk7XG5cdCAgICAgICAgKDAsIGxpYiQzLmRlZmluZVJlYWRPbmx5KShfdGhpcywgXCJfZGV0ZWN0TmV0d29ya1wiLCBfc3VwZXIucHJvdG90eXBlLmRldGVjdE5ldHdvcmsuY2FsbChfdGhpcykpO1xuXHQgICAgICAgIC8vIFN0YWxsIHNlbmRpbmcgcmVxdWVzdHMgdW50aWwgdGhlIHNvY2tldCBpcyBvcGVuLi4uXG5cdCAgICAgICAgX3RoaXMuX3dlYnNvY2tldC5vbm9wZW4gPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIF90aGlzLl93c1JlYWR5ID0gdHJ1ZTtcblx0ICAgICAgICAgICAgT2JqZWN0LmtleXMoX3RoaXMuX3JlcXVlc3RzKS5mb3JFYWNoKGZ1bmN0aW9uIChpZCkge1xuXHQgICAgICAgICAgICAgICAgX3RoaXMuX3dlYnNvY2tldC5zZW5kKF90aGlzLl9yZXF1ZXN0c1tpZF0ucGF5bG9hZCk7XG5cdCAgICAgICAgICAgIH0pO1xuXHQgICAgICAgIH07XG5cdCAgICAgICAgX3RoaXMuX3dlYnNvY2tldC5vbm1lc3NhZ2UgPSBmdW5jdGlvbiAobWVzc2FnZUV2ZW50KSB7XG5cdCAgICAgICAgICAgIHZhciBkYXRhID0gbWVzc2FnZUV2ZW50LmRhdGE7XG5cdCAgICAgICAgICAgIHZhciByZXN1bHQgPSBKU09OLnBhcnNlKGRhdGEpO1xuXHQgICAgICAgICAgICBpZiAocmVzdWx0LmlkICE9IG51bGwpIHtcblx0ICAgICAgICAgICAgICAgIHZhciBpZCA9IFN0cmluZyhyZXN1bHQuaWQpO1xuXHQgICAgICAgICAgICAgICAgdmFyIHJlcXVlc3QgPSBfdGhpcy5fcmVxdWVzdHNbaWRdO1xuXHQgICAgICAgICAgICAgICAgZGVsZXRlIF90aGlzLl9yZXF1ZXN0c1tpZF07XG5cdCAgICAgICAgICAgICAgICBpZiAocmVzdWx0LnJlc3VsdCAhPT0gdW5kZWZpbmVkKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgcmVxdWVzdC5jYWxsYmFjayhudWxsLCByZXN1bHQucmVzdWx0KTtcblx0ICAgICAgICAgICAgICAgICAgICBfdGhpcy5lbWl0KFwiZGVidWdcIiwge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBhY3Rpb246IFwicmVzcG9uc2VcIixcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcmVxdWVzdDogSlNPTi5wYXJzZShyZXF1ZXN0LnBheWxvYWQpLFxuXHQgICAgICAgICAgICAgICAgICAgICAgICByZXNwb25zZTogcmVzdWx0LnJlc3VsdCxcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcHJvdmlkZXI6IF90aGlzXG5cdCAgICAgICAgICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICBlbHNlIHtcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgZXJyb3IgPSBudWxsO1xuXHQgICAgICAgICAgICAgICAgICAgIGlmIChyZXN1bHQuZXJyb3IpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3IgPSBuZXcgRXJyb3IocmVzdWx0LmVycm9yLm1lc3NhZ2UgfHwgXCJ1bmtub3duIGVycm9yXCIpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAoMCwgbGliJDMuZGVmaW5lUmVhZE9ubHkpKGVycm9yLCBcImNvZGVcIiwgcmVzdWx0LmVycm9yLmNvZGUgfHwgbnVsbCk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICgwLCBsaWIkMy5kZWZpbmVSZWFkT25seSkoZXJyb3IsIFwicmVzcG9uc2VcIiwgZGF0YSk7XG5cdCAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBlcnJvciA9IG5ldyBFcnJvcihcInVua25vd24gZXJyb3JcIik7XG5cdCAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgIHJlcXVlc3QuY2FsbGJhY2soZXJyb3IsIHVuZGVmaW5lZCk7XG5cdCAgICAgICAgICAgICAgICAgICAgX3RoaXMuZW1pdChcImRlYnVnXCIsIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgYWN0aW9uOiBcInJlc3BvbnNlXCIsXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yOiBlcnJvcixcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcmVxdWVzdDogSlNPTi5wYXJzZShyZXF1ZXN0LnBheWxvYWQpLFxuXHQgICAgICAgICAgICAgICAgICAgICAgICBwcm92aWRlcjogX3RoaXNcblx0ICAgICAgICAgICAgICAgICAgICB9KTtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICBlbHNlIGlmIChyZXN1bHQubWV0aG9kID09PSBcImV0aF9zdWJzY3JpcHRpb25cIikge1xuXHQgICAgICAgICAgICAgICAgLy8gU3Vic2NyaXB0aW9uLi4uXG5cdCAgICAgICAgICAgICAgICB2YXIgc3ViID0gX3RoaXMuX3N1YnNbcmVzdWx0LnBhcmFtcy5zdWJzY3JpcHRpb25dO1xuXHQgICAgICAgICAgICAgICAgaWYgKHN1Yikge1xuXHQgICAgICAgICAgICAgICAgICAgIC8vdGhpcy5lbWl0LmFwcGx5KHRoaXMsICAgICAgICAgICAgICAgICAgKTtcblx0ICAgICAgICAgICAgICAgICAgICBzdWIucHJvY2Vzc0Z1bmMocmVzdWx0LnBhcmFtcy5yZXN1bHQpO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIGVsc2Uge1xuXHQgICAgICAgICAgICAgICAgY29uc29sZS53YXJuKFwidGhpcyBzaG91bGQgbm90IGhhcHBlblwiKTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH07XG5cdCAgICAgICAgLy8gVGhpcyBQcm92aWRlciBkb2VzIG5vdCBhY3R1YWxseSBwb2xsLCBidXQgd2Ugd2FudCB0byB0cmlnZ2VyXG5cdCAgICAgICAgLy8gcG9sbCBldmVudHMgZm9yIHRoaW5ncyB0aGF0IGRlcGVuZCBvbiB0aGVtIChsaWtlIHN0YWxsaW5nIGZvclxuXHQgICAgICAgIC8vIGJsb2NrIGFuZCB0cmFuc2FjdGlvbiBsb29rdXBzKVxuXHQgICAgICAgIHZhciBmYXV4UG9sbCA9IHNldEludGVydmFsKGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgX3RoaXMuZW1pdChcInBvbGxcIik7XG5cdCAgICAgICAgfSwgMTAwMCk7XG5cdCAgICAgICAgaWYgKGZhdXhQb2xsLnVucmVmKSB7XG5cdCAgICAgICAgICAgIGZhdXhQb2xsLnVucmVmKCk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHJldHVybiBfdGhpcztcblx0ICAgIH1cblx0ICAgIFdlYlNvY2tldFByb3ZpZGVyLnByb3RvdHlwZS5kZXRlY3ROZXR3b3JrID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIHJldHVybiB0aGlzLl9kZXRlY3ROZXR3b3JrO1xuXHQgICAgfTtcblx0ICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShXZWJTb2NrZXRQcm92aWRlci5wcm90b3R5cGUsIFwicG9sbGluZ0ludGVydmFsXCIsIHtcblx0ICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIDA7XG5cdCAgICAgICAgfSxcblx0ICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSkge1xuXHQgICAgICAgICAgICBsb2dnZXIudGhyb3dFcnJvcihcImNhbm5vdCBzZXQgcG9sbGluZyBpbnRlcnZhbCBvbiBXZWJTb2NrZXRQcm92aWRlclwiLCBsaWIuTG9nZ2VyLmVycm9ycy5VTlNVUFBPUlRFRF9PUEVSQVRJT04sIHtcblx0ICAgICAgICAgICAgICAgIG9wZXJhdGlvbjogXCJzZXRQb2xsaW5nSW50ZXJ2YWxcIlxuXHQgICAgICAgICAgICB9KTtcblx0ICAgICAgICB9LFxuXHQgICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuXHQgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuXHQgICAgfSk7XG5cdCAgICBXZWJTb2NrZXRQcm92aWRlci5wcm90b3R5cGUucmVzZXRFdmVudHNCbG9jayA9IGZ1bmN0aW9uIChibG9ja051bWJlcikge1xuXHQgICAgICAgIGxvZ2dlci50aHJvd0Vycm9yKFwiY2Fubm90IHJlc2V0IGV2ZW50cyBibG9jayBvbiBXZWJTb2NrZXRQcm92aWRlclwiLCBsaWIuTG9nZ2VyLmVycm9ycy5VTlNVUFBPUlRFRF9PUEVSQVRJT04sIHtcblx0ICAgICAgICAgICAgb3BlcmF0aW9uOiBcInJlc2V0RXZlbnRCbG9ja1wiXG5cdCAgICAgICAgfSk7XG5cdCAgICB9O1xuXHQgICAgV2ViU29ja2V0UHJvdmlkZXIucHJvdG90eXBlLnBvbGwgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgbnVsbF07XG5cdCAgICAgICAgICAgIH0pO1xuXHQgICAgICAgIH0pO1xuXHQgICAgfTtcblx0ICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShXZWJTb2NrZXRQcm92aWRlci5wcm90b3R5cGUsIFwicG9sbGluZ1wiLCB7XG5cdCAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpIHtcblx0ICAgICAgICAgICAgaWYgKCF2YWx1ZSkge1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIGxvZ2dlci50aHJvd0Vycm9yKFwiY2Fubm90IHNldCBwb2xsaW5nIG9uIFdlYlNvY2tldFByb3ZpZGVyXCIsIGxpYi5Mb2dnZXIuZXJyb3JzLlVOU1VQUE9SVEVEX09QRVJBVElPTiwge1xuXHQgICAgICAgICAgICAgICAgb3BlcmF0aW9uOiBcInNldFBvbGxpbmdcIlxuXHQgICAgICAgICAgICB9KTtcblx0ICAgICAgICB9LFxuXHQgICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuXHQgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuXHQgICAgfSk7XG5cdCAgICBXZWJTb2NrZXRQcm92aWRlci5wcm90b3R5cGUuc2VuZCA9IGZ1bmN0aW9uIChtZXRob2QsIHBhcmFtcykge1xuXHQgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cdCAgICAgICAgdmFyIHJpZCA9IE5leHRJZCsrO1xuXHQgICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG5cdCAgICAgICAgICAgIGZ1bmN0aW9uIGNhbGxiYWNrKGVycm9yLCByZXN1bHQpIHtcblx0ICAgICAgICAgICAgICAgIGlmIChlcnJvcikge1xuXHQgICAgICAgICAgICAgICAgICAgIHJldHVybiByZWplY3QoZXJyb3IpO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgcmV0dXJuIHJlc29sdmUocmVzdWx0KTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB2YXIgcGF5bG9hZCA9IEpTT04uc3RyaW5naWZ5KHtcblx0ICAgICAgICAgICAgICAgIG1ldGhvZDogbWV0aG9kLFxuXHQgICAgICAgICAgICAgICAgcGFyYW1zOiBwYXJhbXMsXG5cdCAgICAgICAgICAgICAgICBpZDogcmlkLFxuXHQgICAgICAgICAgICAgICAganNvbnJwYzogXCIyLjBcIlxuXHQgICAgICAgICAgICB9KTtcblx0ICAgICAgICAgICAgX3RoaXMuZW1pdChcImRlYnVnXCIsIHtcblx0ICAgICAgICAgICAgICAgIGFjdGlvbjogXCJyZXF1ZXN0XCIsXG5cdCAgICAgICAgICAgICAgICByZXF1ZXN0OiBKU09OLnBhcnNlKHBheWxvYWQpLFxuXHQgICAgICAgICAgICAgICAgcHJvdmlkZXI6IF90aGlzXG5cdCAgICAgICAgICAgIH0pO1xuXHQgICAgICAgICAgICBfdGhpcy5fcmVxdWVzdHNbU3RyaW5nKHJpZCldID0geyBjYWxsYmFjazogY2FsbGJhY2ssIHBheWxvYWQ6IHBheWxvYWQgfTtcblx0ICAgICAgICAgICAgaWYgKF90aGlzLl93c1JlYWR5KSB7XG5cdCAgICAgICAgICAgICAgICBfdGhpcy5fd2Vic29ja2V0LnNlbmQocGF5bG9hZCk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9KTtcblx0ICAgIH07XG5cdCAgICBXZWJTb2NrZXRQcm92aWRlci5kZWZhdWx0VXJsID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIHJldHVybiBcIndzOi9cXC9sb2NhbGhvc3Q6ODU0NlwiO1xuXHQgICAgfTtcblx0ICAgIFdlYlNvY2tldFByb3ZpZGVyLnByb3RvdHlwZS5fc3Vic2NyaWJlID0gZnVuY3Rpb24gKHRhZywgcGFyYW0sIHByb2Nlc3NGdW5jKSB7XG5cdCAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICB2YXIgc3ViSWRQcm9taXNlLCBzdWJJZDtcblx0ICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcblx0ICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuXHQgICAgICAgICAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkge1xuXHQgICAgICAgICAgICAgICAgICAgIGNhc2UgMDpcblx0ICAgICAgICAgICAgICAgICAgICAgICAgc3ViSWRQcm9taXNlID0gdGhpcy5fc3ViSWRzW3RhZ107XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzdWJJZFByb21pc2UgPT0gbnVsbCkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3ViSWRQcm9taXNlID0gUHJvbWlzZS5hbGwocGFyYW0pLnRoZW4oZnVuY3Rpb24gKHBhcmFtKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF90aGlzLnNlbmQoXCJldGhfc3Vic2NyaWJlXCIsIHBhcmFtKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fc3ViSWRzW3RhZ10gPSBzdWJJZFByb21pc2U7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgc3ViSWRQcm9taXNlXTtcblx0ICAgICAgICAgICAgICAgICAgICBjYXNlIDE6XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHN1YklkID0gX2Euc2VudCgpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9zdWJzW3N1YklkXSA9IHsgdGFnOiB0YWcsIHByb2Nlc3NGdW5jOiBwcm9jZXNzRnVuYyB9O1xuXHQgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qL107XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIH0pO1xuXHQgICAgICAgIH0pO1xuXHQgICAgfTtcblx0ICAgIFdlYlNvY2tldFByb3ZpZGVyLnByb3RvdHlwZS5fc3RhcnRFdmVudCA9IGZ1bmN0aW9uIChldmVudCkge1xuXHQgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cdCAgICAgICAgc3dpdGNoIChldmVudC50eXBlKSB7XG5cdCAgICAgICAgICAgIGNhc2UgXCJibG9ja1wiOlxuXHQgICAgICAgICAgICAgICAgdGhpcy5fc3Vic2NyaWJlKFwiYmxvY2tcIiwgW1wibmV3SGVhZHNcIl0sIGZ1bmN0aW9uIChyZXN1bHQpIHtcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgYmxvY2tOdW1iZXIgPSBsaWIkMi5CaWdOdW1iZXIuZnJvbShyZXN1bHQubnVtYmVyKS50b051bWJlcigpO1xuXHQgICAgICAgICAgICAgICAgICAgIF90aGlzLl9lbWl0dGVkLmJsb2NrID0gYmxvY2tOdW1iZXI7XG5cdCAgICAgICAgICAgICAgICAgICAgX3RoaXMuZW1pdChcImJsb2NrXCIsIGJsb2NrTnVtYmVyKTtcblx0ICAgICAgICAgICAgICAgIH0pO1xuXHQgICAgICAgICAgICAgICAgYnJlYWs7XG5cdCAgICAgICAgICAgIGNhc2UgXCJwZW5kaW5nXCI6XG5cdCAgICAgICAgICAgICAgICB0aGlzLl9zdWJzY3JpYmUoXCJwZW5kaW5nXCIsIFtcIm5ld1BlbmRpbmdUcmFuc2FjdGlvbnNcIl0sIGZ1bmN0aW9uIChyZXN1bHQpIHtcblx0ICAgICAgICAgICAgICAgICAgICBfdGhpcy5lbWl0KFwicGVuZGluZ1wiLCByZXN1bHQpO1xuXHQgICAgICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgICAgICAgICBicmVhaztcblx0ICAgICAgICAgICAgY2FzZSBcImZpbHRlclwiOlxuXHQgICAgICAgICAgICAgICAgdGhpcy5fc3Vic2NyaWJlKGV2ZW50LnRhZywgW1wibG9nc1wiLCB0aGlzLl9nZXRGaWx0ZXIoZXZlbnQuZmlsdGVyKV0sIGZ1bmN0aW9uIChyZXN1bHQpIHtcblx0ICAgICAgICAgICAgICAgICAgICBpZiAocmVzdWx0LnJlbW92ZWQgPT0gbnVsbCkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQucmVtb3ZlZCA9IGZhbHNlO1xuXHQgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICBfdGhpcy5lbWl0KGV2ZW50LmZpbHRlciwgX3RoaXMuZm9ybWF0dGVyLmZpbHRlckxvZyhyZXN1bHQpKTtcblx0ICAgICAgICAgICAgICAgIH0pO1xuXHQgICAgICAgICAgICAgICAgYnJlYWs7XG5cdCAgICAgICAgICAgIGNhc2UgXCJ0eFwiOiB7XG5cdCAgICAgICAgICAgICAgICB2YXIgZW1pdFJlY2VpcHRfMSA9IGZ1bmN0aW9uIChldmVudCkge1xuXHQgICAgICAgICAgICAgICAgICAgIHZhciBoYXNoID0gZXZlbnQuaGFzaDtcblx0ICAgICAgICAgICAgICAgICAgICBfdGhpcy5nZXRUcmFuc2FjdGlvblJlY2VpcHQoaGFzaCkudGhlbihmdW5jdGlvbiAocmVjZWlwdCkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXJlY2VpcHQpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5lbWl0KGhhc2gsIHJlY2VpcHQpO1xuXHQgICAgICAgICAgICAgICAgICAgIH0pO1xuXHQgICAgICAgICAgICAgICAgfTtcblx0ICAgICAgICAgICAgICAgIC8vIEluIGNhc2UgaXQgaXMgYWxyZWFkeSBtaW5lZFxuXHQgICAgICAgICAgICAgICAgZW1pdFJlY2VpcHRfMShldmVudCk7XG5cdCAgICAgICAgICAgICAgICAvLyBUbyBrZWVwIHRoaW5ncyBzaW1wbGUsIHdlIHN0YXJ0IHVwIGEgc2luZ2xlIG5ld0hlYWRzIHN1YnNjcmlwdGlvblxuXHQgICAgICAgICAgICAgICAgLy8gdG8ga2VlcCBhbiBleWUgb3V0IGZvciB0cmFuc2FjdGlvbnMgd2UgYXJlIHdhdGNoaW5nIGZvci5cblx0ICAgICAgICAgICAgICAgIC8vIFN0YXJ0aW5nIGEgc3Vic2NyaXB0aW9uIGZvciBhbiBldmVudCAoaS5lLiBcInR4XCIpIHRoYXQgaXMgYWxyZWFkeVxuXHQgICAgICAgICAgICAgICAgLy8gcnVubmluZyBpcyAoYmFzaWNhbGx5KSBhIG5vcC5cblx0ICAgICAgICAgICAgICAgIHRoaXMuX3N1YnNjcmliZShcInR4XCIsIFtcIm5ld0hlYWRzXCJdLCBmdW5jdGlvbiAocmVzdWx0KSB7XG5cdCAgICAgICAgICAgICAgICAgICAgX3RoaXMuX2V2ZW50cy5maWx0ZXIoZnVuY3Rpb24gKGUpIHsgcmV0dXJuIChlLnR5cGUgPT09IFwidHhcIik7IH0pLmZvckVhY2goZW1pdFJlY2VpcHRfMSk7XG5cdCAgICAgICAgICAgICAgICB9KTtcblx0ICAgICAgICAgICAgICAgIGJyZWFrO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIC8vIE5vdGhpbmcgaXMgbmVlZGVkXG5cdCAgICAgICAgICAgIGNhc2UgXCJkZWJ1Z1wiOlxuXHQgICAgICAgICAgICBjYXNlIFwicG9sbFwiOlxuXHQgICAgICAgICAgICBjYXNlIFwid2lsbFBvbGxcIjpcblx0ICAgICAgICAgICAgY2FzZSBcImRpZFBvbGxcIjpcblx0ICAgICAgICAgICAgY2FzZSBcImVycm9yXCI6XG5cdCAgICAgICAgICAgICAgICBicmVhaztcblx0ICAgICAgICAgICAgZGVmYXVsdDpcblx0ICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwidW5oYW5kbGVkOlwiLCBldmVudCk7XG5cdCAgICAgICAgICAgICAgICBicmVhaztcblx0ICAgICAgICB9XG5cdCAgICB9O1xuXHQgICAgV2ViU29ja2V0UHJvdmlkZXIucHJvdG90eXBlLl9zdG9wRXZlbnQgPSBmdW5jdGlvbiAoZXZlbnQpIHtcblx0ICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXHQgICAgICAgIHZhciB0YWcgPSBldmVudC50YWc7XG5cdCAgICAgICAgaWYgKGV2ZW50LnR5cGUgPT09IFwidHhcIikge1xuXHQgICAgICAgICAgICAvLyBUaGVyZSBhcmUgcmVtYWluaW5nIHRyYW5zYWN0aW9uIGV2ZW50IGxpc3RlbmVyc1xuXHQgICAgICAgICAgICBpZiAodGhpcy5fZXZlbnRzLmZpbHRlcihmdW5jdGlvbiAoZSkgeyByZXR1cm4gKGUudHlwZSA9PT0gXCJ0eFwiKTsgfSkubGVuZ3RoKSB7XG5cdCAgICAgICAgICAgICAgICByZXR1cm47XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgdGFnID0gXCJ0eFwiO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBlbHNlIGlmICh0aGlzLmxpc3RlbmVyQ291bnQoZXZlbnQuZXZlbnQpKSB7XG5cdCAgICAgICAgICAgIC8vIFRoZXJlIGFyZSByZW1haW5pbmcgZXZlbnQgbGlzdGVuZXJzXG5cdCAgICAgICAgICAgIHJldHVybjtcblx0ICAgICAgICB9XG5cdCAgICAgICAgdmFyIHN1YklkID0gdGhpcy5fc3ViSWRzW3RhZ107XG5cdCAgICAgICAgaWYgKCFzdWJJZCkge1xuXHQgICAgICAgICAgICByZXR1cm47XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGRlbGV0ZSB0aGlzLl9zdWJJZHNbdGFnXTtcblx0ICAgICAgICBzdWJJZC50aGVuKGZ1bmN0aW9uIChzdWJJZCkge1xuXHQgICAgICAgICAgICBpZiAoIV90aGlzLl9zdWJzW3N1YklkXSkge1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIGRlbGV0ZSBfdGhpcy5fc3Vic1tzdWJJZF07XG5cdCAgICAgICAgICAgIF90aGlzLnNlbmQoXCJldGhfdW5zdWJzY3JpYmVcIiwgW3N1YklkXSk7XG5cdCAgICAgICAgfSk7XG5cdCAgICB9O1xuXHQgICAgV2ViU29ja2V0UHJvdmlkZXIucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXHQgICAgICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG5cdCAgICAgICAgICAgICAgICBzd2l0Y2ggKF9hLmxhYmVsKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgY2FzZSAwOlxuXHQgICAgICAgICAgICAgICAgICAgICAgICBpZiAoISh0aGlzLl93ZWJzb2NrZXQucmVhZHlTdGF0ZSA9PT0gYnJvd3NlcldzLldlYlNvY2tldC5DT05ORUNUSU5HKSkgcmV0dXJuIFszIC8qYnJlYWsqLywgMl07XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIChuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLl93ZWJzb2NrZXQub25vcGVuID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlKHRydWUpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH07XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuX3dlYnNvY2tldC5vbmVycm9yID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlKGZhbHNlKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSkpXTtcblx0ICAgICAgICAgICAgICAgICAgICBjYXNlIDE6XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIF9hLnNlbnQoKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgX2EubGFiZWwgPSAyO1xuXHQgICAgICAgICAgICAgICAgICAgIGNhc2UgMjpcblx0ICAgICAgICAgICAgICAgICAgICAgICAgLy8gSGFuZ3VwXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIC8vIFNlZTogaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0Nsb3NlRXZlbnQjU3RhdHVzX2NvZGVzXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3dlYnNvY2tldC5jbG9zZSgxMDAwKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi9dO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB9KTtcblx0ICAgICAgICB9KTtcblx0ICAgIH07XG5cdCAgICByZXR1cm4gV2ViU29ja2V0UHJvdmlkZXI7XG5cdH0oanNvblJwY1Byb3ZpZGVyLkpzb25ScGNQcm92aWRlcikpO1xuXHRleHBvcnRzLldlYlNvY2tldFByb3ZpZGVyID0gV2ViU29ja2V0UHJvdmlkZXI7XG5cblx0fSk7XG5cblx0dmFyIHdlYnNvY2tldFByb3ZpZGVyJDEgPSAvKkBfX1BVUkVfXyovZ2V0RGVmYXVsdEV4cG9ydEZyb21DanMod2Vic29ja2V0UHJvdmlkZXIpO1xuXG5cdHZhciB1cmxKc29uUnBjUHJvdmlkZXIgPSBjcmVhdGVDb21tb25qc01vZHVsZShmdW5jdGlvbiAobW9kdWxlLCBleHBvcnRzKSB7XG5cdFwidXNlIHN0cmljdFwiO1xuXHR2YXIgX19leHRlbmRzID0gKGNvbW1vbmpzR2xvYmFsICYmIGNvbW1vbmpzR2xvYmFsLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcblx0ICAgIHZhciBleHRlbmRTdGF0aWNzID0gZnVuY3Rpb24gKGQsIGIpIHtcblx0ICAgICAgICBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG5cdCAgICAgICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcblx0ICAgICAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGIsIHApKSBkW3BdID0gYltwXTsgfTtcblx0ICAgICAgICByZXR1cm4gZXh0ZW5kU3RhdGljcyhkLCBiKTtcblx0ICAgIH07XG5cdCAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcblx0ICAgICAgICBpZiAodHlwZW9mIGIgIT09IFwiZnVuY3Rpb25cIiAmJiBiICE9PSBudWxsKVxuXHQgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2xhc3MgZXh0ZW5kcyB2YWx1ZSBcIiArIFN0cmluZyhiKSArIFwiIGlzIG5vdCBhIGNvbnN0cnVjdG9yIG9yIG51bGxcIik7XG5cdCAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcblx0ICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cblx0ICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG5cdCAgICB9O1xuXHR9KSgpO1xuXHR2YXIgX19hd2FpdGVyID0gKGNvbW1vbmpzR2xvYmFsICYmIGNvbW1vbmpzR2xvYmFsLl9fYXdhaXRlcikgfHwgZnVuY3Rpb24gKHRoaXNBcmcsIF9hcmd1bWVudHMsIFAsIGdlbmVyYXRvcikge1xuXHQgICAgZnVuY3Rpb24gYWRvcHQodmFsdWUpIHsgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgUCA/IHZhbHVlIDogbmV3IFAoZnVuY3Rpb24gKHJlc29sdmUpIHsgcmVzb2x2ZSh2YWx1ZSk7IH0pOyB9XG5cdCAgICByZXR1cm4gbmV3IChQIHx8IChQID0gUHJvbWlzZSkpKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcblx0ICAgICAgICBmdW5jdGlvbiBmdWxmaWxsZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3IubmV4dCh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG5cdCAgICAgICAgZnVuY3Rpb24gcmVqZWN0ZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3JbXCJ0aHJvd1wiXSh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG5cdCAgICAgICAgZnVuY3Rpb24gc3RlcChyZXN1bHQpIHsgcmVzdWx0LmRvbmUgPyByZXNvbHZlKHJlc3VsdC52YWx1ZSkgOiBhZG9wdChyZXN1bHQudmFsdWUpLnRoZW4oZnVsZmlsbGVkLCByZWplY3RlZCk7IH1cblx0ICAgICAgICBzdGVwKChnZW5lcmF0b3IgPSBnZW5lcmF0b3IuYXBwbHkodGhpc0FyZywgX2FyZ3VtZW50cyB8fCBbXSkpLm5leHQoKSk7XG5cdCAgICB9KTtcblx0fTtcblx0dmFyIF9fZ2VuZXJhdG9yID0gKGNvbW1vbmpzR2xvYmFsICYmIGNvbW1vbmpzR2xvYmFsLl9fZ2VuZXJhdG9yKSB8fCBmdW5jdGlvbiAodGhpc0FyZywgYm9keSkge1xuXHQgICAgdmFyIF8gPSB7IGxhYmVsOiAwLCBzZW50OiBmdW5jdGlvbigpIHsgaWYgKHRbMF0gJiAxKSB0aHJvdyB0WzFdOyByZXR1cm4gdFsxXTsgfSwgdHJ5czogW10sIG9wczogW10gfSwgZiwgeSwgdCwgZztcblx0ICAgIHJldHVybiBnID0geyBuZXh0OiB2ZXJiKDApLCBcInRocm93XCI6IHZlcmIoMSksIFwicmV0dXJuXCI6IHZlcmIoMikgfSwgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIChnW1N5bWJvbC5pdGVyYXRvcl0gPSBmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXM7IH0pLCBnO1xuXHQgICAgZnVuY3Rpb24gdmVyYihuKSB7IHJldHVybiBmdW5jdGlvbiAodikgeyByZXR1cm4gc3RlcChbbiwgdl0pOyB9OyB9XG5cdCAgICBmdW5jdGlvbiBzdGVwKG9wKSB7XG5cdCAgICAgICAgaWYgKGYpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJHZW5lcmF0b3IgaXMgYWxyZWFkeSBleGVjdXRpbmcuXCIpO1xuXHQgICAgICAgIHdoaWxlIChfKSB0cnkge1xuXHQgICAgICAgICAgICBpZiAoZiA9IDEsIHkgJiYgKHQgPSBvcFswXSAmIDIgPyB5W1wicmV0dXJuXCJdIDogb3BbMF0gPyB5W1widGhyb3dcIl0gfHwgKCh0ID0geVtcInJldHVyblwiXSkgJiYgdC5jYWxsKHkpLCAwKSA6IHkubmV4dCkgJiYgISh0ID0gdC5jYWxsKHksIG9wWzFdKSkuZG9uZSkgcmV0dXJuIHQ7XG5cdCAgICAgICAgICAgIGlmICh5ID0gMCwgdCkgb3AgPSBbb3BbMF0gJiAyLCB0LnZhbHVlXTtcblx0ICAgICAgICAgICAgc3dpdGNoIChvcFswXSkge1xuXHQgICAgICAgICAgICAgICAgY2FzZSAwOiBjYXNlIDE6IHQgPSBvcDsgYnJlYWs7XG5cdCAgICAgICAgICAgICAgICBjYXNlIDQ6IF8ubGFiZWwrKzsgcmV0dXJuIHsgdmFsdWU6IG9wWzFdLCBkb25lOiBmYWxzZSB9O1xuXHQgICAgICAgICAgICAgICAgY2FzZSA1OiBfLmxhYmVsKys7IHkgPSBvcFsxXTsgb3AgPSBbMF07IGNvbnRpbnVlO1xuXHQgICAgICAgICAgICAgICAgY2FzZSA3OiBvcCA9IF8ub3BzLnBvcCgpOyBfLnRyeXMucG9wKCk7IGNvbnRpbnVlO1xuXHQgICAgICAgICAgICAgICAgZGVmYXVsdDpcblx0ICAgICAgICAgICAgICAgICAgICBpZiAoISh0ID0gXy50cnlzLCB0ID0gdC5sZW5ndGggPiAwICYmIHRbdC5sZW5ndGggLSAxXSkgJiYgKG9wWzBdID09PSA2IHx8IG9wWzBdID09PSAyKSkgeyBfID0gMDsgY29udGludWU7IH1cblx0ICAgICAgICAgICAgICAgICAgICBpZiAob3BbMF0gPT09IDMgJiYgKCF0IHx8IChvcFsxXSA+IHRbMF0gJiYgb3BbMV0gPCB0WzNdKSkpIHsgXy5sYWJlbCA9IG9wWzFdOyBicmVhazsgfVxuXHQgICAgICAgICAgICAgICAgICAgIGlmIChvcFswXSA9PT0gNiAmJiBfLmxhYmVsIDwgdFsxXSkgeyBfLmxhYmVsID0gdFsxXTsgdCA9IG9wOyBicmVhazsgfVxuXHQgICAgICAgICAgICAgICAgICAgIGlmICh0ICYmIF8ubGFiZWwgPCB0WzJdKSB7IF8ubGFiZWwgPSB0WzJdOyBfLm9wcy5wdXNoKG9wKTsgYnJlYWs7IH1cblx0ICAgICAgICAgICAgICAgICAgICBpZiAodFsyXSkgXy5vcHMucG9wKCk7XG5cdCAgICAgICAgICAgICAgICAgICAgXy50cnlzLnBvcCgpOyBjb250aW51ZTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICBvcCA9IGJvZHkuY2FsbCh0aGlzQXJnLCBfKTtcblx0ICAgICAgICB9IGNhdGNoIChlKSB7IG9wID0gWzYsIGVdOyB5ID0gMDsgfSBmaW5hbGx5IHsgZiA9IHQgPSAwOyB9XG5cdCAgICAgICAgaWYgKG9wWzBdICYgNSkgdGhyb3cgb3BbMV07IHJldHVybiB7IHZhbHVlOiBvcFswXSA/IG9wWzFdIDogdm9pZCAwLCBkb25lOiB0cnVlIH07XG5cdCAgICB9XG5cdH07XG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcblx0ZXhwb3J0cy5VcmxKc29uUnBjUHJvdmlkZXIgPSBleHBvcnRzLlN0YXRpY0pzb25ScGNQcm92aWRlciA9IHZvaWQgMDtcblxuXG5cblx0dmFyIGxvZ2dlciA9IG5ldyBsaWIuTG9nZ2VyKF92ZXJzaW9uJEkudmVyc2lvbik7XG5cblx0Ly8gQSBTdGF0aWNKc29uUnBjUHJvdmlkZXIgaXMgdXNlZnVsIHdoZW4geW91ICprbm93KiBmb3IgY2VydGFpbiB0aGF0XG5cdC8vIHRoZSBiYWNrZW5kIHdpbGwgbmV2ZXIgY2hhbmdlLCBhcyBpdCBuZXZlciBjYWxscyBldGhfY2hhaW5JZCB0b1xuXHQvLyB2ZXJpZnkgaXRzIGJhY2tlbmQuIEhvd2V2ZXIsIGlmIHRoZSBiYWNrZW5kIGRvZXMgY2hhbmdlLCB0aGUgZWZmZWN0c1xuXHQvLyBhcmUgdW5kZWZpbmVkIGFuZCBtYXkgaW5jbHVkZTpcblx0Ly8gLSBpbmNvbnNpc3RlbnQgcmVzdWx0c1xuXHQvLyAtIGxvY2tpbmcgdXAgdGhlIFVJXG5cdC8vIC0gYmxvY2sgc2tldyB3YXJuaW5nc1xuXHQvLyAtIHdyb25nIHJlc3VsdHNcblx0Ly8gSWYgdGhlIG5ldHdvcmsgaXMgbm90IGV4cGxpY2l0IChpLmUuIGF1dG8tZGV0ZWN0aW9uIGlzIGV4cGVjdGVkKSwgdGhlXG5cdC8vIG5vZGUgTVVTVCBiZSBydW5uaW5nIGFuZCBhdmFpbGFibGUgdG8gcmVzcG9uZCB0byByZXF1ZXN0cyBCRUZPUkUgdGhpc1xuXHQvLyBpcyBpbnN0YW50aWF0ZWQuXG5cdHZhciBTdGF0aWNKc29uUnBjUHJvdmlkZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG5cdCAgICBfX2V4dGVuZHMoU3RhdGljSnNvblJwY1Byb3ZpZGVyLCBfc3VwZXIpO1xuXHQgICAgZnVuY3Rpb24gU3RhdGljSnNvblJwY1Byb3ZpZGVyKCkge1xuXHQgICAgICAgIHJldHVybiBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcblx0ICAgIH1cblx0ICAgIFN0YXRpY0pzb25ScGNQcm92aWRlci5wcm90b3R5cGUuZGV0ZWN0TmV0d29yayA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIHZhciBuZXR3b3JrO1xuXHQgICAgICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG5cdCAgICAgICAgICAgICAgICBzd2l0Y2ggKF9hLmxhYmVsKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgY2FzZSAwOlxuXHQgICAgICAgICAgICAgICAgICAgICAgICBuZXR3b3JrID0gdGhpcy5uZXR3b3JrO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIShuZXR3b3JrID09IG51bGwpKSByZXR1cm4gWzMgLypicmVhayovLCAyXTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgX3N1cGVyLnByb3RvdHlwZS5kZXRlY3ROZXR3b3JrLmNhbGwodGhpcyldO1xuXHQgICAgICAgICAgICAgICAgICAgIGNhc2UgMTpcblx0ICAgICAgICAgICAgICAgICAgICAgICAgbmV0d29yayA9IF9hLnNlbnQoKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFuZXR3b3JrKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBsb2dnZXIudGhyb3dFcnJvcihcIm5vIG5ldHdvcmsgZGV0ZWN0ZWRcIiwgbGliLkxvZ2dlci5lcnJvcnMuVU5LTk9XTl9FUlJPUiwge30pO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIC8vIElmIHN0aWxsIG5vdCBzZXQsIHNldCBpdFxuXHQgICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5fbmV0d29yayA9PSBudWxsKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBBIHN0YXRpYyBuZXR3b3JrIGRvZXMgbm90IHN1cHBvcnQgXCJhbnlcIlxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgKDAsIGxpYiQzLmRlZmluZVJlYWRPbmx5KSh0aGlzLCBcIl9uZXR3b3JrXCIsIG5ldHdvcmspO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5lbWl0KFwibmV0d29ya1wiLCBuZXR3b3JrLCBudWxsKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgICAgICBfYS5sYWJlbCA9IDI7XG5cdCAgICAgICAgICAgICAgICAgICAgY2FzZSAyOiByZXR1cm4gWzIgLypyZXR1cm4qLywgbmV0d29ya107XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIH0pO1xuXHQgICAgICAgIH0pO1xuXHQgICAgfTtcblx0ICAgIHJldHVybiBTdGF0aWNKc29uUnBjUHJvdmlkZXI7XG5cdH0oanNvblJwY1Byb3ZpZGVyLkpzb25ScGNQcm92aWRlcikpO1xuXHRleHBvcnRzLlN0YXRpY0pzb25ScGNQcm92aWRlciA9IFN0YXRpY0pzb25ScGNQcm92aWRlcjtcblx0dmFyIFVybEpzb25ScGNQcm92aWRlciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcblx0ICAgIF9fZXh0ZW5kcyhVcmxKc29uUnBjUHJvdmlkZXIsIF9zdXBlcik7XG5cdCAgICBmdW5jdGlvbiBVcmxKc29uUnBjUHJvdmlkZXIobmV0d29yaywgYXBpS2V5KSB7XG5cdCAgICAgICAgdmFyIF9uZXdUYXJnZXQgPSB0aGlzLmNvbnN0cnVjdG9yO1xuXHQgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cdCAgICAgICAgbG9nZ2VyLmNoZWNrQWJzdHJhY3QoX25ld1RhcmdldCwgVXJsSnNvblJwY1Byb3ZpZGVyKTtcblx0ICAgICAgICAvLyBOb3JtYWxpemUgdGhlIE5ldHdvcmsgYW5kIEFQSSBLZXlcblx0ICAgICAgICBuZXR3b3JrID0gKDAsIGxpYiQzLmdldFN0YXRpYykoX25ld1RhcmdldCwgXCJnZXROZXR3b3JrXCIpKG5ldHdvcmspO1xuXHQgICAgICAgIGFwaUtleSA9ICgwLCBsaWIkMy5nZXRTdGF0aWMpKF9uZXdUYXJnZXQsIFwiZ2V0QXBpS2V5XCIpKGFwaUtleSk7XG5cdCAgICAgICAgdmFyIGNvbm5lY3Rpb24gPSAoMCwgbGliJDMuZ2V0U3RhdGljKShfbmV3VGFyZ2V0LCBcImdldFVybFwiKShuZXR3b3JrLCBhcGlLZXkpO1xuXHQgICAgICAgIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgY29ubmVjdGlvbiwgbmV0d29yaykgfHwgdGhpcztcblx0ICAgICAgICBpZiAodHlwZW9mIChhcGlLZXkpID09PSBcInN0cmluZ1wiKSB7XG5cdCAgICAgICAgICAgICgwLCBsaWIkMy5kZWZpbmVSZWFkT25seSkoX3RoaXMsIFwiYXBpS2V5XCIsIGFwaUtleSk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGVsc2UgaWYgKGFwaUtleSAhPSBudWxsKSB7XG5cdCAgICAgICAgICAgIE9iamVjdC5rZXlzKGFwaUtleSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG5cdCAgICAgICAgICAgICAgICAoMCwgbGliJDMuZGVmaW5lUmVhZE9ubHkpKF90aGlzLCBrZXksIGFwaUtleVtrZXldKTtcblx0ICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHJldHVybiBfdGhpcztcblx0ICAgIH1cblx0ICAgIFVybEpzb25ScGNQcm92aWRlci5wcm90b3R5cGUuX3N0YXJ0UGVuZGluZyA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICBsb2dnZXIud2FybihcIldBUk5JTkc6IEFQSSBwcm92aWRlciBkb2VzIG5vdCBzdXBwb3J0IHBlbmRpbmcgZmlsdGVyc1wiKTtcblx0ICAgIH07XG5cdCAgICBVcmxKc29uUnBjUHJvdmlkZXIucHJvdG90eXBlLmlzQ29tbXVuaXR5UmVzb3VyY2UgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgcmV0dXJuIGZhbHNlO1xuXHQgICAgfTtcblx0ICAgIFVybEpzb25ScGNQcm92aWRlci5wcm90b3R5cGUuZ2V0U2lnbmVyID0gZnVuY3Rpb24gKGFkZHJlc3MpIHtcblx0ICAgICAgICByZXR1cm4gbG9nZ2VyLnRocm93RXJyb3IoXCJBUEkgcHJvdmlkZXIgZG9lcyBub3Qgc3VwcG9ydCBzaWduaW5nXCIsIGxpYi5Mb2dnZXIuZXJyb3JzLlVOU1VQUE9SVEVEX09QRVJBVElPTiwgeyBvcGVyYXRpb246IFwiZ2V0U2lnbmVyXCIgfSk7XG5cdCAgICB9O1xuXHQgICAgVXJsSnNvblJwY1Byb3ZpZGVyLnByb3RvdHlwZS5saXN0QWNjb3VudHMgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShbXSk7XG5cdCAgICB9O1xuXHQgICAgLy8gUmV0dXJuIGEgZGVmYXVsdEFwaUtleSBpZiBudWxsLCBvdGhlcndpc2UgdmFsaWRhdGUgdGhlIEFQSSBrZXlcblx0ICAgIFVybEpzb25ScGNQcm92aWRlci5nZXRBcGlLZXkgPSBmdW5jdGlvbiAoYXBpS2V5KSB7XG5cdCAgICAgICAgcmV0dXJuIGFwaUtleTtcblx0ICAgIH07XG5cdCAgICAvLyBSZXR1cm5zIHRoZSB1cmwgb3IgY29ubmVjdGlvbiBmb3IgdGhlIGdpdmVuIG5ldHdvcmsgYW5kIEFQSSBrZXkuIFRoZVxuXHQgICAgLy8gQVBJIGtleSB3aWxsIGhhdmUgYmVlbiBzYW5pdGl6ZWQgYnkgdGhlIGdldEFwaUtleSBmaXJzdCwgc28gYW55IHZhbGlkYXRpb25cblx0ICAgIC8vIG9yIHRyYW5zZm9ybWF0aW9ucyBjYW4gYmUgZG9uZSB0aGVyZS5cblx0ICAgIFVybEpzb25ScGNQcm92aWRlci5nZXRVcmwgPSBmdW5jdGlvbiAobmV0d29yaywgYXBpS2V5KSB7XG5cdCAgICAgICAgcmV0dXJuIGxvZ2dlci50aHJvd0Vycm9yKFwibm90IGltcGxlbWVudGVkOyBzdWItY2xhc3NlcyBtdXN0IG92ZXJyaWRlIGdldFVybFwiLCBsaWIuTG9nZ2VyLmVycm9ycy5OT1RfSU1QTEVNRU5URUQsIHtcblx0ICAgICAgICAgICAgb3BlcmF0aW9uOiBcImdldFVybFwiXG5cdCAgICAgICAgfSk7XG5cdCAgICB9O1xuXHQgICAgcmV0dXJuIFVybEpzb25ScGNQcm92aWRlcjtcblx0fShTdGF0aWNKc29uUnBjUHJvdmlkZXIpKTtcblx0ZXhwb3J0cy5VcmxKc29uUnBjUHJvdmlkZXIgPSBVcmxKc29uUnBjUHJvdmlkZXI7XG5cblx0fSk7XG5cblx0dmFyIHVybEpzb25ScGNQcm92aWRlciQxID0gLypAX19QVVJFX18qL2dldERlZmF1bHRFeHBvcnRGcm9tQ2pzKHVybEpzb25ScGNQcm92aWRlcik7XG5cblx0dmFyIGFsY2hlbXlQcm92aWRlciA9IGNyZWF0ZUNvbW1vbmpzTW9kdWxlKGZ1bmN0aW9uIChtb2R1bGUsIGV4cG9ydHMpIHtcblx0XCJ1c2Ugc3RyaWN0XCI7XG5cdHZhciBfX2V4dGVuZHMgPSAoY29tbW9uanNHbG9iYWwgJiYgY29tbW9uanNHbG9iYWwuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuXHQgICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBmdW5jdGlvbiAoZCwgYikge1xuXHQgICAgICAgIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcblx0ICAgICAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuXHQgICAgICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoYiwgcCkpIGRbcF0gPSBiW3BdOyB9O1xuXHQgICAgICAgIHJldHVybiBleHRlbmRTdGF0aWNzKGQsIGIpO1xuXHQgICAgfTtcblx0ICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuXHQgICAgICAgIGlmICh0eXBlb2YgYiAhPT0gXCJmdW5jdGlvblwiICYmIGIgIT09IG51bGwpXG5cdCAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDbGFzcyBleHRlbmRzIHZhbHVlIFwiICsgU3RyaW5nKGIpICsgXCIgaXMgbm90IGEgY29uc3RydWN0b3Igb3IgbnVsbFwiKTtcblx0ICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuXHQgICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuXHQgICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcblx0ICAgIH07XG5cdH0pKCk7XG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcblx0ZXhwb3J0cy5BbGNoZW15UHJvdmlkZXIgPSBleHBvcnRzLkFsY2hlbXlXZWJTb2NrZXRQcm92aWRlciA9IHZvaWQgMDtcblxuXG5cblxuXG5cdHZhciBsb2dnZXIgPSBuZXcgbGliLkxvZ2dlcihfdmVyc2lvbiRJLnZlcnNpb24pO1xuXG5cdC8vIFRoaXMga2V5IHdhcyBwcm92aWRlZCB0byBldGhlcnMuanMgYnkgQWxjaGVteSB0byBiZSB1c2VkIGJ5IHRoZVxuXHQvLyBkZWZhdWx0IHByb3ZpZGVyLCBidXQgaXQgaXMgcmVjb21tZW5kZWQgdGhhdCBmb3IgeW91ciBvd25cblx0Ly8gcHJvZHVjdGlvbiBlbnZpcm9ubWVudHMsIHRoYXQgeW91IGFjcXVpcmUgeW91ciBvd24gQVBJIGtleSBhdDpcblx0Ly8gICBodHRwczovL2Rhc2hib2FyZC5hbGNoZW15YXBpLmlvXG5cdHZhciBkZWZhdWx0QXBpS2V5ID0gXCJfZ2c3d1NTaTBLTUJzZEtuR1ZmSER1ZXE2eE1COUVrQ1wiO1xuXHR2YXIgQWxjaGVteVdlYlNvY2tldFByb3ZpZGVyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuXHQgICAgX19leHRlbmRzKEFsY2hlbXlXZWJTb2NrZXRQcm92aWRlciwgX3N1cGVyKTtcblx0ICAgIGZ1bmN0aW9uIEFsY2hlbXlXZWJTb2NrZXRQcm92aWRlcihuZXR3b3JrLCBhcGlLZXkpIHtcblx0ICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXHQgICAgICAgIHZhciBwcm92aWRlciA9IG5ldyBBbGNoZW15UHJvdmlkZXIobmV0d29yaywgYXBpS2V5KTtcblx0ICAgICAgICB2YXIgdXJsID0gcHJvdmlkZXIuY29ubmVjdGlvbi51cmwucmVwbGFjZSgvXmh0dHAvaSwgXCJ3c1wiKVxuXHQgICAgICAgICAgICAucmVwbGFjZShcIi5hbGNoZW15YXBpLlwiLCBcIi53cy5hbGNoZW15YXBpLlwiKTtcblx0ICAgICAgICBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIHVybCwgcHJvdmlkZXIubmV0d29yaykgfHwgdGhpcztcblx0ICAgICAgICAoMCwgbGliJDMuZGVmaW5lUmVhZE9ubHkpKF90aGlzLCBcImFwaUtleVwiLCBwcm92aWRlci5hcGlLZXkpO1xuXHQgICAgICAgIHJldHVybiBfdGhpcztcblx0ICAgIH1cblx0ICAgIEFsY2hlbXlXZWJTb2NrZXRQcm92aWRlci5wcm90b3R5cGUuaXNDb21tdW5pdHlSZXNvdXJjZSA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICByZXR1cm4gKHRoaXMuYXBpS2V5ID09PSBkZWZhdWx0QXBpS2V5KTtcblx0ICAgIH07XG5cdCAgICByZXR1cm4gQWxjaGVteVdlYlNvY2tldFByb3ZpZGVyO1xuXHR9KHdlYnNvY2tldFByb3ZpZGVyLldlYlNvY2tldFByb3ZpZGVyKSk7XG5cdGV4cG9ydHMuQWxjaGVteVdlYlNvY2tldFByb3ZpZGVyID0gQWxjaGVteVdlYlNvY2tldFByb3ZpZGVyO1xuXHR2YXIgQWxjaGVteVByb3ZpZGVyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuXHQgICAgX19leHRlbmRzKEFsY2hlbXlQcm92aWRlciwgX3N1cGVyKTtcblx0ICAgIGZ1bmN0aW9uIEFsY2hlbXlQcm92aWRlcigpIHtcblx0ICAgICAgICByZXR1cm4gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG5cdCAgICB9XG5cdCAgICBBbGNoZW15UHJvdmlkZXIuZ2V0V2ViU29ja2V0UHJvdmlkZXIgPSBmdW5jdGlvbiAobmV0d29yaywgYXBpS2V5KSB7XG5cdCAgICAgICAgcmV0dXJuIG5ldyBBbGNoZW15V2ViU29ja2V0UHJvdmlkZXIobmV0d29yaywgYXBpS2V5KTtcblx0ICAgIH07XG5cdCAgICBBbGNoZW15UHJvdmlkZXIuZ2V0QXBpS2V5ID0gZnVuY3Rpb24gKGFwaUtleSkge1xuXHQgICAgICAgIGlmIChhcGlLZXkgPT0gbnVsbCkge1xuXHQgICAgICAgICAgICByZXR1cm4gZGVmYXVsdEFwaUtleTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgaWYgKGFwaUtleSAmJiB0eXBlb2YgKGFwaUtleSkgIT09IFwic3RyaW5nXCIpIHtcblx0ICAgICAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcImludmFsaWQgYXBpS2V5XCIsIFwiYXBpS2V5XCIsIGFwaUtleSk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHJldHVybiBhcGlLZXk7XG5cdCAgICB9O1xuXHQgICAgQWxjaGVteVByb3ZpZGVyLmdldFVybCA9IGZ1bmN0aW9uIChuZXR3b3JrLCBhcGlLZXkpIHtcblx0ICAgICAgICB2YXIgaG9zdCA9IG51bGw7XG5cdCAgICAgICAgc3dpdGNoIChuZXR3b3JrLm5hbWUpIHtcblx0ICAgICAgICAgICAgY2FzZSBcImhvbWVzdGVhZFwiOlxuXHQgICAgICAgICAgICAgICAgaG9zdCA9IFwiZXRoLW1haW5uZXQuYWxjaGVteWFwaS5pby92Mi9cIjtcblx0ICAgICAgICAgICAgICAgIGJyZWFrO1xuXHQgICAgICAgICAgICBjYXNlIFwicm9wc3RlblwiOlxuXHQgICAgICAgICAgICAgICAgaG9zdCA9IFwiZXRoLXJvcHN0ZW4uYWxjaGVteWFwaS5pby92Mi9cIjtcblx0ICAgICAgICAgICAgICAgIGJyZWFrO1xuXHQgICAgICAgICAgICBjYXNlIFwicmlua2VieVwiOlxuXHQgICAgICAgICAgICAgICAgaG9zdCA9IFwiZXRoLXJpbmtlYnkuYWxjaGVteWFwaS5pby92Mi9cIjtcblx0ICAgICAgICAgICAgICAgIGJyZWFrO1xuXHQgICAgICAgICAgICBjYXNlIFwiZ29lcmxpXCI6XG5cdCAgICAgICAgICAgICAgICBob3N0ID0gXCJldGgtZ29lcmxpLmFsY2hlbXlhcGkuaW8vdjIvXCI7XG5cdCAgICAgICAgICAgICAgICBicmVhaztcblx0ICAgICAgICAgICAgY2FzZSBcImtvdmFuXCI6XG5cdCAgICAgICAgICAgICAgICBob3N0ID0gXCJldGgta292YW4uYWxjaGVteWFwaS5pby92Mi9cIjtcblx0ICAgICAgICAgICAgICAgIGJyZWFrO1xuXHQgICAgICAgICAgICBjYXNlIFwibWF0aWNcIjpcblx0ICAgICAgICAgICAgICAgIGhvc3QgPSBcInBvbHlnb24tbWFpbm5ldC5nLmFsY2hlbXkuY29tL3YyL1wiO1xuXHQgICAgICAgICAgICAgICAgYnJlYWs7XG5cdCAgICAgICAgICAgIGNhc2UgXCJtYXRpY211bVwiOlxuXHQgICAgICAgICAgICAgICAgaG9zdCA9IFwicG9seWdvbi1tdW1iYWkuZy5hbGNoZW15LmNvbS92Mi9cIjtcblx0ICAgICAgICAgICAgICAgIGJyZWFrO1xuXHQgICAgICAgICAgICBkZWZhdWx0OlxuXHQgICAgICAgICAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcInVuc3VwcG9ydGVkIG5ldHdvcmtcIiwgXCJuZXR3b3JrXCIsIGFyZ3VtZW50c1swXSk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHJldHVybiB7XG5cdCAgICAgICAgICAgIGFsbG93R3ppcDogdHJ1ZSxcblx0ICAgICAgICAgICAgdXJsOiAoXCJodHRwczovXCIgKyBcIi9cIiArIGhvc3QgKyBhcGlLZXkpLFxuXHQgICAgICAgICAgICB0aHJvdHRsZUNhbGxiYWNrOiBmdW5jdGlvbiAoYXR0ZW1wdCwgdXJsKSB7XG5cdCAgICAgICAgICAgICAgICBpZiAoYXBpS2V5ID09PSBkZWZhdWx0QXBpS2V5KSB7XG5cdCAgICAgICAgICAgICAgICAgICAgKDAsIGZvcm1hdHRlci5zaG93VGhyb3R0bGVNZXNzYWdlKSgpO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh0cnVlKTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH07XG5cdCAgICB9O1xuXHQgICAgQWxjaGVteVByb3ZpZGVyLnByb3RvdHlwZS5pc0NvbW11bml0eVJlc291cmNlID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIHJldHVybiAodGhpcy5hcGlLZXkgPT09IGRlZmF1bHRBcGlLZXkpO1xuXHQgICAgfTtcblx0ICAgIHJldHVybiBBbGNoZW15UHJvdmlkZXI7XG5cdH0odXJsSnNvblJwY1Byb3ZpZGVyLlVybEpzb25ScGNQcm92aWRlcikpO1xuXHRleHBvcnRzLkFsY2hlbXlQcm92aWRlciA9IEFsY2hlbXlQcm92aWRlcjtcblxuXHR9KTtcblxuXHR2YXIgYWxjaGVteVByb3ZpZGVyJDEgPSAvKkBfX1BVUkVfXyovZ2V0RGVmYXVsdEV4cG9ydEZyb21DanMoYWxjaGVteVByb3ZpZGVyKTtcblxuXHR2YXIgY2xvdWRmbGFyZVByb3ZpZGVyID0gY3JlYXRlQ29tbW9uanNNb2R1bGUoZnVuY3Rpb24gKG1vZHVsZSwgZXhwb3J0cykge1xuXHRcInVzZSBzdHJpY3RcIjtcblx0dmFyIF9fZXh0ZW5kcyA9IChjb21tb25qc0dsb2JhbCAmJiBjb21tb25qc0dsb2JhbC5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG5cdCAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IGZ1bmN0aW9uIChkLCBiKSB7XG5cdCAgICAgICAgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuXHQgICAgICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG5cdCAgICAgICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChiLCBwKSkgZFtwXSA9IGJbcF07IH07XG5cdCAgICAgICAgcmV0dXJuIGV4dGVuZFN0YXRpY3MoZCwgYik7XG5cdCAgICB9O1xuXHQgICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG5cdCAgICAgICAgaWYgKHR5cGVvZiBiICE9PSBcImZ1bmN0aW9uXCIgJiYgYiAhPT0gbnVsbClcblx0ICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNsYXNzIGV4dGVuZHMgdmFsdWUgXCIgKyBTdHJpbmcoYikgKyBcIiBpcyBub3QgYSBjb25zdHJ1Y3RvciBvciBudWxsXCIpO1xuXHQgICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG5cdCAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG5cdCAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuXHQgICAgfTtcblx0fSkoKTtcblx0dmFyIF9fYXdhaXRlciA9IChjb21tb25qc0dsb2JhbCAmJiBjb21tb25qc0dsb2JhbC5fX2F3YWl0ZXIpIHx8IGZ1bmN0aW9uICh0aGlzQXJnLCBfYXJndW1lbnRzLCBQLCBnZW5lcmF0b3IpIHtcblx0ICAgIGZ1bmN0aW9uIGFkb3B0KHZhbHVlKSB7IHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIFAgPyB2YWx1ZSA6IG5ldyBQKGZ1bmN0aW9uIChyZXNvbHZlKSB7IHJlc29sdmUodmFsdWUpOyB9KTsgfVxuXHQgICAgcmV0dXJuIG5ldyAoUCB8fCAoUCA9IFByb21pc2UpKShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG5cdCAgICAgICAgZnVuY3Rpb24gZnVsZmlsbGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yLm5leHQodmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuXHQgICAgICAgIGZ1bmN0aW9uIHJlamVjdGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yW1widGhyb3dcIl0odmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuXHQgICAgICAgIGZ1bmN0aW9uIHN0ZXAocmVzdWx0KSB7IHJlc3VsdC5kb25lID8gcmVzb2x2ZShyZXN1bHQudmFsdWUpIDogYWRvcHQocmVzdWx0LnZhbHVlKS50aGVuKGZ1bGZpbGxlZCwgcmVqZWN0ZWQpOyB9XG5cdCAgICAgICAgc3RlcCgoZ2VuZXJhdG9yID0gZ2VuZXJhdG9yLmFwcGx5KHRoaXNBcmcsIF9hcmd1bWVudHMgfHwgW10pKS5uZXh0KCkpO1xuXHQgICAgfSk7XG5cdH07XG5cdHZhciBfX2dlbmVyYXRvciA9IChjb21tb25qc0dsb2JhbCAmJiBjb21tb25qc0dsb2JhbC5fX2dlbmVyYXRvcikgfHwgZnVuY3Rpb24gKHRoaXNBcmcsIGJvZHkpIHtcblx0ICAgIHZhciBfID0geyBsYWJlbDogMCwgc2VudDogZnVuY3Rpb24oKSB7IGlmICh0WzBdICYgMSkgdGhyb3cgdFsxXTsgcmV0dXJuIHRbMV07IH0sIHRyeXM6IFtdLCBvcHM6IFtdIH0sIGYsIHksIHQsIGc7XG5cdCAgICByZXR1cm4gZyA9IHsgbmV4dDogdmVyYigwKSwgXCJ0aHJvd1wiOiB2ZXJiKDEpLCBcInJldHVyblwiOiB2ZXJiKDIpIH0sIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiAoZ1tTeW1ib2wuaXRlcmF0b3JdID0gZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzOyB9KSwgZztcblx0ICAgIGZ1bmN0aW9uIHZlcmIobikgeyByZXR1cm4gZnVuY3Rpb24gKHYpIHsgcmV0dXJuIHN0ZXAoW24sIHZdKTsgfTsgfVxuXHQgICAgZnVuY3Rpb24gc3RlcChvcCkge1xuXHQgICAgICAgIGlmIChmKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiR2VuZXJhdG9yIGlzIGFscmVhZHkgZXhlY3V0aW5nLlwiKTtcblx0ICAgICAgICB3aGlsZSAoXykgdHJ5IHtcblx0ICAgICAgICAgICAgaWYgKGYgPSAxLCB5ICYmICh0ID0gb3BbMF0gJiAyID8geVtcInJldHVyblwiXSA6IG9wWzBdID8geVtcInRocm93XCJdIHx8ICgodCA9IHlbXCJyZXR1cm5cIl0pICYmIHQuY2FsbCh5KSwgMCkgOiB5Lm5leHQpICYmICEodCA9IHQuY2FsbCh5LCBvcFsxXSkpLmRvbmUpIHJldHVybiB0O1xuXHQgICAgICAgICAgICBpZiAoeSA9IDAsIHQpIG9wID0gW29wWzBdICYgMiwgdC52YWx1ZV07XG5cdCAgICAgICAgICAgIHN3aXRjaCAob3BbMF0pIHtcblx0ICAgICAgICAgICAgICAgIGNhc2UgMDogY2FzZSAxOiB0ID0gb3A7IGJyZWFrO1xuXHQgICAgICAgICAgICAgICAgY2FzZSA0OiBfLmxhYmVsKys7IHJldHVybiB7IHZhbHVlOiBvcFsxXSwgZG9uZTogZmFsc2UgfTtcblx0ICAgICAgICAgICAgICAgIGNhc2UgNTogXy5sYWJlbCsrOyB5ID0gb3BbMV07IG9wID0gWzBdOyBjb250aW51ZTtcblx0ICAgICAgICAgICAgICAgIGNhc2UgNzogb3AgPSBfLm9wcy5wb3AoKTsgXy50cnlzLnBvcCgpOyBjb250aW51ZTtcblx0ICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKCEodCA9IF8udHJ5cywgdCA9IHQubGVuZ3RoID4gMCAmJiB0W3QubGVuZ3RoIC0gMV0pICYmIChvcFswXSA9PT0gNiB8fCBvcFswXSA9PT0gMikpIHsgXyA9IDA7IGNvbnRpbnVlOyB9XG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKG9wWzBdID09PSAzICYmICghdCB8fCAob3BbMV0gPiB0WzBdICYmIG9wWzFdIDwgdFszXSkpKSB7IF8ubGFiZWwgPSBvcFsxXTsgYnJlYWs7IH1cblx0ICAgICAgICAgICAgICAgICAgICBpZiAob3BbMF0gPT09IDYgJiYgXy5sYWJlbCA8IHRbMV0pIHsgXy5sYWJlbCA9IHRbMV07IHQgPSBvcDsgYnJlYWs7IH1cblx0ICAgICAgICAgICAgICAgICAgICBpZiAodCAmJiBfLmxhYmVsIDwgdFsyXSkgeyBfLmxhYmVsID0gdFsyXTsgXy5vcHMucHVzaChvcCk7IGJyZWFrOyB9XG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKHRbMl0pIF8ub3BzLnBvcCgpO1xuXHQgICAgICAgICAgICAgICAgICAgIF8udHJ5cy5wb3AoKTsgY29udGludWU7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgb3AgPSBib2R5LmNhbGwodGhpc0FyZywgXyk7XG5cdCAgICAgICAgfSBjYXRjaCAoZSkgeyBvcCA9IFs2LCBlXTsgeSA9IDA7IH0gZmluYWxseSB7IGYgPSB0ID0gMDsgfVxuXHQgICAgICAgIGlmIChvcFswXSAmIDUpIHRocm93IG9wWzFdOyByZXR1cm4geyB2YWx1ZTogb3BbMF0gPyBvcFsxXSA6IHZvaWQgMCwgZG9uZTogdHJ1ZSB9O1xuXHQgICAgfVxuXHR9O1xuXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5cdGV4cG9ydHMuQ2xvdWRmbGFyZVByb3ZpZGVyID0gdm9pZCAwO1xuXG5cblxuXHR2YXIgbG9nZ2VyID0gbmV3IGxpYi5Mb2dnZXIoX3ZlcnNpb24kSS52ZXJzaW9uKTtcblx0dmFyIENsb3VkZmxhcmVQcm92aWRlciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcblx0ICAgIF9fZXh0ZW5kcyhDbG91ZGZsYXJlUHJvdmlkZXIsIF9zdXBlcik7XG5cdCAgICBmdW5jdGlvbiBDbG91ZGZsYXJlUHJvdmlkZXIoKSB7XG5cdCAgICAgICAgcmV0dXJuIF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuXHQgICAgfVxuXHQgICAgQ2xvdWRmbGFyZVByb3ZpZGVyLmdldEFwaUtleSA9IGZ1bmN0aW9uIChhcGlLZXkpIHtcblx0ICAgICAgICBpZiAoYXBpS2V5ICE9IG51bGwpIHtcblx0ICAgICAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcImFwaUtleSBub3Qgc3VwcG9ydGVkIGZvciBjbG91ZGZsYXJlXCIsIFwiYXBpS2V5XCIsIGFwaUtleSk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHJldHVybiBudWxsO1xuXHQgICAgfTtcblx0ICAgIENsb3VkZmxhcmVQcm92aWRlci5nZXRVcmwgPSBmdW5jdGlvbiAobmV0d29yaywgYXBpS2V5KSB7XG5cdCAgICAgICAgdmFyIGhvc3QgPSBudWxsO1xuXHQgICAgICAgIHN3aXRjaCAobmV0d29yay5uYW1lKSB7XG5cdCAgICAgICAgICAgIGNhc2UgXCJob21lc3RlYWRcIjpcblx0ICAgICAgICAgICAgICAgIGhvc3QgPSBcImh0dHBzOi8vY2xvdWRmbGFyZS1ldGguY29tL1wiO1xuXHQgICAgICAgICAgICAgICAgYnJlYWs7XG5cdCAgICAgICAgICAgIGRlZmF1bHQ6XG5cdCAgICAgICAgICAgICAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwidW5zdXBwb3J0ZWQgbmV0d29ya1wiLCBcIm5ldHdvcmtcIiwgYXJndW1lbnRzWzBdKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgcmV0dXJuIGhvc3Q7XG5cdCAgICB9O1xuXHQgICAgQ2xvdWRmbGFyZVByb3ZpZGVyLnByb3RvdHlwZS5wZXJmb3JtID0gZnVuY3Rpb24gKG1ldGhvZCwgcGFyYW1zKSB7XG5cdCAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICB2YXIgYmxvY2s7XG5cdCAgICAgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcblx0ICAgICAgICAgICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcblx0ICAgICAgICAgICAgICAgICAgICBjYXNlIDA6XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGlmICghKG1ldGhvZCA9PT0gXCJnZXRCbG9ja051bWJlclwiKSkgcmV0dXJuIFszIC8qYnJlYWsqLywgMl07XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIF9zdXBlci5wcm90b3R5cGUucGVyZm9ybS5jYWxsKHRoaXMsIFwiZ2V0QmxvY2tcIiwgeyBibG9ja1RhZzogXCJsYXRlc3RcIiB9KV07XG5cdCAgICAgICAgICAgICAgICAgICAgY2FzZSAxOlxuXHQgICAgICAgICAgICAgICAgICAgICAgICBibG9jayA9IF9hLnNlbnQoKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIGJsb2NrLm51bWJlcl07XG5cdCAgICAgICAgICAgICAgICAgICAgY2FzZSAyOiByZXR1cm4gWzIgLypyZXR1cm4qLywgX3N1cGVyLnByb3RvdHlwZS5wZXJmb3JtLmNhbGwodGhpcywgbWV0aG9kLCBwYXJhbXMpXTtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgfSk7XG5cdCAgICB9O1xuXHQgICAgcmV0dXJuIENsb3VkZmxhcmVQcm92aWRlcjtcblx0fSh1cmxKc29uUnBjUHJvdmlkZXIuVXJsSnNvblJwY1Byb3ZpZGVyKSk7XG5cdGV4cG9ydHMuQ2xvdWRmbGFyZVByb3ZpZGVyID0gQ2xvdWRmbGFyZVByb3ZpZGVyO1xuXG5cdH0pO1xuXG5cdHZhciBjbG91ZGZsYXJlUHJvdmlkZXIkMSA9IC8qQF9fUFVSRV9fKi9nZXREZWZhdWx0RXhwb3J0RnJvbUNqcyhjbG91ZGZsYXJlUHJvdmlkZXIpO1xuXG5cdHZhciBldGhlcnNjYW5Qcm92aWRlciA9IGNyZWF0ZUNvbW1vbmpzTW9kdWxlKGZ1bmN0aW9uIChtb2R1bGUsIGV4cG9ydHMpIHtcblx0XCJ1c2Ugc3RyaWN0XCI7XG5cdHZhciBfX2V4dGVuZHMgPSAoY29tbW9uanNHbG9iYWwgJiYgY29tbW9uanNHbG9iYWwuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuXHQgICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBmdW5jdGlvbiAoZCwgYikge1xuXHQgICAgICAgIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcblx0ICAgICAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuXHQgICAgICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoYiwgcCkpIGRbcF0gPSBiW3BdOyB9O1xuXHQgICAgICAgIHJldHVybiBleHRlbmRTdGF0aWNzKGQsIGIpO1xuXHQgICAgfTtcblx0ICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuXHQgICAgICAgIGlmICh0eXBlb2YgYiAhPT0gXCJmdW5jdGlvblwiICYmIGIgIT09IG51bGwpXG5cdCAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDbGFzcyBleHRlbmRzIHZhbHVlIFwiICsgU3RyaW5nKGIpICsgXCIgaXMgbm90IGEgY29uc3RydWN0b3Igb3IgbnVsbFwiKTtcblx0ICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuXHQgICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuXHQgICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcblx0ICAgIH07XG5cdH0pKCk7XG5cdHZhciBfX2F3YWl0ZXIgPSAoY29tbW9uanNHbG9iYWwgJiYgY29tbW9uanNHbG9iYWwuX19hd2FpdGVyKSB8fCBmdW5jdGlvbiAodGhpc0FyZywgX2FyZ3VtZW50cywgUCwgZ2VuZXJhdG9yKSB7XG5cdCAgICBmdW5jdGlvbiBhZG9wdCh2YWx1ZSkgeyByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBQID8gdmFsdWUgOiBuZXcgUChmdW5jdGlvbiAocmVzb2x2ZSkgeyByZXNvbHZlKHZhbHVlKTsgfSk7IH1cblx0ICAgIHJldHVybiBuZXcgKFAgfHwgKFAgPSBQcm9taXNlKSkoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuXHQgICAgICAgIGZ1bmN0aW9uIGZ1bGZpbGxlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvci5uZXh0KHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cblx0ICAgICAgICBmdW5jdGlvbiByZWplY3RlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvcltcInRocm93XCJdKHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cblx0ICAgICAgICBmdW5jdGlvbiBzdGVwKHJlc3VsdCkgeyByZXN1bHQuZG9uZSA/IHJlc29sdmUocmVzdWx0LnZhbHVlKSA6IGFkb3B0KHJlc3VsdC52YWx1ZSkudGhlbihmdWxmaWxsZWQsIHJlamVjdGVkKTsgfVxuXHQgICAgICAgIHN0ZXAoKGdlbmVyYXRvciA9IGdlbmVyYXRvci5hcHBseSh0aGlzQXJnLCBfYXJndW1lbnRzIHx8IFtdKSkubmV4dCgpKTtcblx0ICAgIH0pO1xuXHR9O1xuXHR2YXIgX19nZW5lcmF0b3IgPSAoY29tbW9uanNHbG9iYWwgJiYgY29tbW9uanNHbG9iYWwuX19nZW5lcmF0b3IpIHx8IGZ1bmN0aW9uICh0aGlzQXJnLCBib2R5KSB7XG5cdCAgICB2YXIgXyA9IHsgbGFiZWw6IDAsIHNlbnQ6IGZ1bmN0aW9uKCkgeyBpZiAodFswXSAmIDEpIHRocm93IHRbMV07IHJldHVybiB0WzFdOyB9LCB0cnlzOiBbXSwgb3BzOiBbXSB9LCBmLCB5LCB0LCBnO1xuXHQgICAgcmV0dXJuIGcgPSB7IG5leHQ6IHZlcmIoMCksIFwidGhyb3dcIjogdmVyYigxKSwgXCJyZXR1cm5cIjogdmVyYigyKSB9LCB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgKGdbU3ltYm9sLml0ZXJhdG9yXSA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpczsgfSksIGc7XG5cdCAgICBmdW5jdGlvbiB2ZXJiKG4pIHsgcmV0dXJuIGZ1bmN0aW9uICh2KSB7IHJldHVybiBzdGVwKFtuLCB2XSk7IH07IH1cblx0ICAgIGZ1bmN0aW9uIHN0ZXAob3ApIHtcblx0ICAgICAgICBpZiAoZikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkdlbmVyYXRvciBpcyBhbHJlYWR5IGV4ZWN1dGluZy5cIik7XG5cdCAgICAgICAgd2hpbGUgKF8pIHRyeSB7XG5cdCAgICAgICAgICAgIGlmIChmID0gMSwgeSAmJiAodCA9IG9wWzBdICYgMiA/IHlbXCJyZXR1cm5cIl0gOiBvcFswXSA/IHlbXCJ0aHJvd1wiXSB8fCAoKHQgPSB5W1wicmV0dXJuXCJdKSAmJiB0LmNhbGwoeSksIDApIDogeS5uZXh0KSAmJiAhKHQgPSB0LmNhbGwoeSwgb3BbMV0pKS5kb25lKSByZXR1cm4gdDtcblx0ICAgICAgICAgICAgaWYgKHkgPSAwLCB0KSBvcCA9IFtvcFswXSAmIDIsIHQudmFsdWVdO1xuXHQgICAgICAgICAgICBzd2l0Y2ggKG9wWzBdKSB7XG5cdCAgICAgICAgICAgICAgICBjYXNlIDA6IGNhc2UgMTogdCA9IG9wOyBicmVhaztcblx0ICAgICAgICAgICAgICAgIGNhc2UgNDogXy5sYWJlbCsrOyByZXR1cm4geyB2YWx1ZTogb3BbMV0sIGRvbmU6IGZhbHNlIH07XG5cdCAgICAgICAgICAgICAgICBjYXNlIDU6IF8ubGFiZWwrKzsgeSA9IG9wWzFdOyBvcCA9IFswXTsgY29udGludWU7XG5cdCAgICAgICAgICAgICAgICBjYXNlIDc6IG9wID0gXy5vcHMucG9wKCk7IF8udHJ5cy5wb3AoKTsgY29udGludWU7XG5cdCAgICAgICAgICAgICAgICBkZWZhdWx0OlxuXHQgICAgICAgICAgICAgICAgICAgIGlmICghKHQgPSBfLnRyeXMsIHQgPSB0Lmxlbmd0aCA+IDAgJiYgdFt0Lmxlbmd0aCAtIDFdKSAmJiAob3BbMF0gPT09IDYgfHwgb3BbMF0gPT09IDIpKSB7IF8gPSAwOyBjb250aW51ZTsgfVxuXHQgICAgICAgICAgICAgICAgICAgIGlmIChvcFswXSA9PT0gMyAmJiAoIXQgfHwgKG9wWzFdID4gdFswXSAmJiBvcFsxXSA8IHRbM10pKSkgeyBfLmxhYmVsID0gb3BbMV07IGJyZWFrOyB9XG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKG9wWzBdID09PSA2ICYmIF8ubGFiZWwgPCB0WzFdKSB7IF8ubGFiZWwgPSB0WzFdOyB0ID0gb3A7IGJyZWFrOyB9XG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKHQgJiYgXy5sYWJlbCA8IHRbMl0pIHsgXy5sYWJlbCA9IHRbMl07IF8ub3BzLnB1c2gob3ApOyBicmVhazsgfVxuXHQgICAgICAgICAgICAgICAgICAgIGlmICh0WzJdKSBfLm9wcy5wb3AoKTtcblx0ICAgICAgICAgICAgICAgICAgICBfLnRyeXMucG9wKCk7IGNvbnRpbnVlO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIG9wID0gYm9keS5jYWxsKHRoaXNBcmcsIF8pO1xuXHQgICAgICAgIH0gY2F0Y2ggKGUpIHsgb3AgPSBbNiwgZV07IHkgPSAwOyB9IGZpbmFsbHkgeyBmID0gdCA9IDA7IH1cblx0ICAgICAgICBpZiAob3BbMF0gJiA1KSB0aHJvdyBvcFsxXTsgcmV0dXJuIHsgdmFsdWU6IG9wWzBdID8gb3BbMV0gOiB2b2lkIDAsIGRvbmU6IHRydWUgfTtcblx0ICAgIH1cblx0fTtcblx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuXHRleHBvcnRzLkV0aGVyc2NhblByb3ZpZGVyID0gdm9pZCAwO1xuXG5cblxuXG5cblxuXG5cdHZhciBsb2dnZXIgPSBuZXcgbGliLkxvZ2dlcihfdmVyc2lvbiRJLnZlcnNpb24pO1xuXG5cdC8vIFRoZSB0cmFuc2FjdGlvbiBoYXMgYWxyZWFkeSBiZWVuIHNhbml0aXplZCBieSB0aGUgY2FsbHMgaW4gUHJvdmlkZXJcblx0ZnVuY3Rpb24gZ2V0VHJhbnNhY3Rpb25Qb3N0RGF0YSh0cmFuc2FjdGlvbikge1xuXHQgICAgdmFyIHJlc3VsdCA9IHt9O1xuXHQgICAgZm9yICh2YXIga2V5IGluIHRyYW5zYWN0aW9uKSB7XG5cdCAgICAgICAgaWYgKHRyYW5zYWN0aW9uW2tleV0gPT0gbnVsbCkge1xuXHQgICAgICAgICAgICBjb250aW51ZTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgdmFyIHZhbHVlID0gdHJhbnNhY3Rpb25ba2V5XTtcblx0ICAgICAgICBpZiAoa2V5ID09PSBcInR5cGVcIiAmJiB2YWx1ZSA9PT0gMCkge1xuXHQgICAgICAgICAgICBjb250aW51ZTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgLy8gUXVhbnRpdHktdHlwZXMgcmVxdWlyZSBubyBsZWFkaW5nIHplcm8sIHVubGVzcyAwXG5cdCAgICAgICAgaWYgKHsgdHlwZTogdHJ1ZSwgZ2FzTGltaXQ6IHRydWUsIGdhc1ByaWNlOiB0cnVlLCBtYXhGZWVQZXJHczogdHJ1ZSwgbWF4UHJpb3JpdHlGZWVQZXJHYXM6IHRydWUsIG5vbmNlOiB0cnVlLCB2YWx1ZTogdHJ1ZSB9W2tleV0pIHtcblx0ICAgICAgICAgICAgdmFsdWUgPSAoMCwgbGliJDEuaGV4VmFsdWUpKCgwLCBsaWIkMS5oZXhsaWZ5KSh2YWx1ZSkpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBlbHNlIGlmIChrZXkgPT09IFwiYWNjZXNzTGlzdFwiKSB7XG5cdCAgICAgICAgICAgIHZhbHVlID0gXCJbXCIgKyAoMCwgbGliJGUuYWNjZXNzTGlzdGlmeSkodmFsdWUpLm1hcChmdW5jdGlvbiAoc2V0KSB7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gXCJ7YWRkcmVzczpcXFwiXCIgKyBzZXQuYWRkcmVzcyArIFwiXFxcIixzdG9yYWdlS2V5czpbXFxcIlwiICsgc2V0LnN0b3JhZ2VLZXlzLmpvaW4oJ1wiLFwiJykgKyBcIlxcXCJdfVwiO1xuXHQgICAgICAgICAgICB9KS5qb2luKFwiLFwiKSArIFwiXVwiO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBlbHNlIHtcblx0ICAgICAgICAgICAgdmFsdWUgPSAoMCwgbGliJDEuaGV4bGlmeSkodmFsdWUpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICByZXN1bHRba2V5XSA9IHZhbHVlO1xuXHQgICAgfVxuXHQgICAgcmV0dXJuIHJlc3VsdDtcblx0fVxuXHRmdW5jdGlvbiBnZXRSZXN1bHQocmVzdWx0KSB7XG5cdCAgICAvLyBnZXRMb2dzLCBnZXRIaXN0b3J5IGhhdmUgd2VpcmQgc3VjY2VzcyByZXNwb25zZXNcblx0ICAgIGlmIChyZXN1bHQuc3RhdHVzID09IDAgJiYgKHJlc3VsdC5tZXNzYWdlID09PSBcIk5vIHJlY29yZHMgZm91bmRcIiB8fCByZXN1bHQubWVzc2FnZSA9PT0gXCJObyB0cmFuc2FjdGlvbnMgZm91bmRcIikpIHtcblx0ICAgICAgICByZXR1cm4gcmVzdWx0LnJlc3VsdDtcblx0ICAgIH1cblx0ICAgIGlmIChyZXN1bHQuc3RhdHVzICE9IDEgfHwgcmVzdWx0Lm1lc3NhZ2UgIT0gXCJPS1wiKSB7XG5cdCAgICAgICAgdmFyIGVycm9yID0gbmV3IEVycm9yKFwiaW52YWxpZCByZXNwb25zZVwiKTtcblx0ICAgICAgICBlcnJvci5yZXN1bHQgPSBKU09OLnN0cmluZ2lmeShyZXN1bHQpO1xuXHQgICAgICAgIGlmICgocmVzdWx0LnJlc3VsdCB8fCBcIlwiKS50b0xvd2VyQ2FzZSgpLmluZGV4T2YoXCJyYXRlIGxpbWl0XCIpID49IDApIHtcblx0ICAgICAgICAgICAgZXJyb3IudGhyb3R0bGVSZXRyeSA9IHRydWU7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHRocm93IGVycm9yO1xuXHQgICAgfVxuXHQgICAgcmV0dXJuIHJlc3VsdC5yZXN1bHQ7XG5cdH1cblx0ZnVuY3Rpb24gZ2V0SnNvblJlc3VsdChyZXN1bHQpIHtcblx0ICAgIC8vIFRoaXMgcmVzcG9uc2UgaW5kaWNhdGVzIHdlIGFyZSBiZWluZyB0aHJvdHRsZWRcblx0ICAgIGlmIChyZXN1bHQgJiYgcmVzdWx0LnN0YXR1cyA9PSAwICYmIHJlc3VsdC5tZXNzYWdlID09IFwiTk9UT0tcIiAmJiAocmVzdWx0LnJlc3VsdCB8fCBcIlwiKS50b0xvd2VyQ2FzZSgpLmluZGV4T2YoXCJyYXRlIGxpbWl0XCIpID49IDApIHtcblx0ICAgICAgICB2YXIgZXJyb3IgPSBuZXcgRXJyb3IoXCJ0aHJvdHRsZWQgcmVzcG9uc2VcIik7XG5cdCAgICAgICAgZXJyb3IucmVzdWx0ID0gSlNPTi5zdHJpbmdpZnkocmVzdWx0KTtcblx0ICAgICAgICBlcnJvci50aHJvdHRsZVJldHJ5ID0gdHJ1ZTtcblx0ICAgICAgICB0aHJvdyBlcnJvcjtcblx0ICAgIH1cblx0ICAgIGlmIChyZXN1bHQuanNvbnJwYyAhPSBcIjIuMFwiKSB7XG5cdCAgICAgICAgLy8gQFRPRE86IG5vdCBhbnlcblx0ICAgICAgICB2YXIgZXJyb3IgPSBuZXcgRXJyb3IoXCJpbnZhbGlkIHJlc3BvbnNlXCIpO1xuXHQgICAgICAgIGVycm9yLnJlc3VsdCA9IEpTT04uc3RyaW5naWZ5KHJlc3VsdCk7XG5cdCAgICAgICAgdGhyb3cgZXJyb3I7XG5cdCAgICB9XG5cdCAgICBpZiAocmVzdWx0LmVycm9yKSB7XG5cdCAgICAgICAgLy8gQFRPRE86IG5vdCBhbnlcblx0ICAgICAgICB2YXIgZXJyb3IgPSBuZXcgRXJyb3IocmVzdWx0LmVycm9yLm1lc3NhZ2UgfHwgXCJ1bmtub3duIGVycm9yXCIpO1xuXHQgICAgICAgIGlmIChyZXN1bHQuZXJyb3IuY29kZSkge1xuXHQgICAgICAgICAgICBlcnJvci5jb2RlID0gcmVzdWx0LmVycm9yLmNvZGU7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGlmIChyZXN1bHQuZXJyb3IuZGF0YSkge1xuXHQgICAgICAgICAgICBlcnJvci5kYXRhID0gcmVzdWx0LmVycm9yLmRhdGE7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHRocm93IGVycm9yO1xuXHQgICAgfVxuXHQgICAgcmV0dXJuIHJlc3VsdC5yZXN1bHQ7XG5cdH1cblx0Ly8gVGhlIGJsb2NrVGFnIHdhcyBub3JtYWxpemVkIGFzIGEgc3RyaW5nIGJ5IHRoZSBQcm92aWRlciBwcmUtcGVyZm9ybSBvcGVyYXRpb25zXG5cdGZ1bmN0aW9uIGNoZWNrTG9nVGFnKGJsb2NrVGFnKSB7XG5cdCAgICBpZiAoYmxvY2tUYWcgPT09IFwicGVuZGluZ1wiKSB7XG5cdCAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwicGVuZGluZyBub3Qgc3VwcG9ydGVkXCIpO1xuXHQgICAgfVxuXHQgICAgaWYgKGJsb2NrVGFnID09PSBcImxhdGVzdFwiKSB7XG5cdCAgICAgICAgcmV0dXJuIGJsb2NrVGFnO1xuXHQgICAgfVxuXHQgICAgcmV0dXJuIHBhcnNlSW50KGJsb2NrVGFnLnN1YnN0cmluZygyKSwgMTYpO1xuXHR9XG5cdHZhciBkZWZhdWx0QXBpS2V5ID0gXCI5RDEzWkU3WFNCVEo5NE45Qk5KMk1BMzNWTUFZMllQSVJCXCI7XG5cdGZ1bmN0aW9uIGNoZWNrRXJyb3IobWV0aG9kLCBlcnJvciwgdHJhbnNhY3Rpb24pIHtcblx0ICAgIC8vIFVuZG8gdGhlIFwiY29udmVuaWVuY2VcIiBzb21lIG5vZGVzIGFyZSBhdHRlbXB0aW5nIHRvIHByZXZlbnQgYmFja3dhcmRzXG5cdCAgICAvLyBpbmNvbXBhdGliaWxpdHk7IG1heWJlIGZvciB2NiBjb25zaWRlciBmb3J3YXJkaW5nIHJldmVydHMgYXMgZXJyb3JzXG5cdCAgICBpZiAobWV0aG9kID09PSBcImNhbGxcIiAmJiBlcnJvci5jb2RlID09PSBsaWIuTG9nZ2VyLmVycm9ycy5TRVJWRVJfRVJST1IpIHtcblx0ICAgICAgICB2YXIgZSA9IGVycm9yLmVycm9yO1xuXHQgICAgICAgIC8vIEV0aGVyc2NhbiBrZWVwcyBjaGFuZ2luZyB0aGVpciBzdHJpbmdcblx0ICAgICAgICBpZiAoZSAmJiAoZS5tZXNzYWdlLm1hdGNoKC9yZXZlcnRlZC9pKSB8fCBlLm1lc3NhZ2UubWF0Y2goL1ZNIGV4ZWN1dGlvbiBlcnJvci9pKSkpIHtcblx0ICAgICAgICAgICAgLy8gRXRoZXJzY2FuIHByZWZpeGVzIHRoZSBkYXRhIGxpa2UgXCJSZXZlcnRlZCAweDEyMzRcIlxuXHQgICAgICAgICAgICB2YXIgZGF0YSA9IGUuZGF0YTtcblx0ICAgICAgICAgICAgaWYgKGRhdGEpIHtcblx0ICAgICAgICAgICAgICAgIGRhdGEgPSBcIjB4XCIgKyBkYXRhLnJlcGxhY2UoL14uKjB4L2ksIFwiXCIpO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIGlmICgoMCwgbGliJDEuaXNIZXhTdHJpbmcpKGRhdGEpKSB7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gZGF0YTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICBsb2dnZXIudGhyb3dFcnJvcihcIm1pc3NpbmcgcmV2ZXJ0IGRhdGEgaW4gY2FsbCBleGNlcHRpb25cIiwgbGliLkxvZ2dlci5lcnJvcnMuQ0FMTF9FWENFUFRJT04sIHtcblx0ICAgICAgICAgICAgICAgIGVycm9yOiBlcnJvcixcblx0ICAgICAgICAgICAgICAgIGRhdGE6IFwiMHhcIlxuXHQgICAgICAgICAgICB9KTtcblx0ICAgICAgICB9XG5cdCAgICB9XG5cdCAgICAvLyBHZXQgdGhlIG1lc3NhZ2UgZnJvbSBhbnkgbmVzdGVkIGVycm9yIHN0cnVjdHVyZVxuXHQgICAgdmFyIG1lc3NhZ2UgPSBlcnJvci5tZXNzYWdlO1xuXHQgICAgaWYgKGVycm9yLmNvZGUgPT09IGxpYi5Mb2dnZXIuZXJyb3JzLlNFUlZFUl9FUlJPUikge1xuXHQgICAgICAgIGlmIChlcnJvci5lcnJvciAmJiB0eXBlb2YgKGVycm9yLmVycm9yLm1lc3NhZ2UpID09PSBcInN0cmluZ1wiKSB7XG5cdCAgICAgICAgICAgIG1lc3NhZ2UgPSBlcnJvci5lcnJvci5tZXNzYWdlO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBlbHNlIGlmICh0eXBlb2YgKGVycm9yLmJvZHkpID09PSBcInN0cmluZ1wiKSB7XG5cdCAgICAgICAgICAgIG1lc3NhZ2UgPSBlcnJvci5ib2R5O1xuXHQgICAgICAgIH1cblx0ICAgICAgICBlbHNlIGlmICh0eXBlb2YgKGVycm9yLnJlc3BvbnNlVGV4dCkgPT09IFwic3RyaW5nXCIpIHtcblx0ICAgICAgICAgICAgbWVzc2FnZSA9IGVycm9yLnJlc3BvbnNlVGV4dDtcblx0ICAgICAgICB9XG5cdCAgICB9XG5cdCAgICBtZXNzYWdlID0gKG1lc3NhZ2UgfHwgXCJcIikudG9Mb3dlckNhc2UoKTtcblx0ICAgIC8vIFwiSW5zdWZmaWNpZW50IGZ1bmRzLiBUaGUgYWNjb3VudCB5b3UgdHJpZWQgdG8gc2VuZCB0cmFuc2FjdGlvbiBmcm9tIGRvZXMgbm90IGhhdmUgZW5vdWdoIGZ1bmRzLiBSZXF1aXJlZCAyMTQ2NDAwMDAwMDAwMCBhbmQgZ290OiAwXCJcblx0ICAgIGlmIChtZXNzYWdlLm1hdGNoKC9pbnN1ZmZpY2llbnQgZnVuZHMvKSkge1xuXHQgICAgICAgIGxvZ2dlci50aHJvd0Vycm9yKFwiaW5zdWZmaWNpZW50IGZ1bmRzIGZvciBpbnRyaW5zaWMgdHJhbnNhY3Rpb24gY29zdFwiLCBsaWIuTG9nZ2VyLmVycm9ycy5JTlNVRkZJQ0lFTlRfRlVORFMsIHtcblx0ICAgICAgICAgICAgZXJyb3I6IGVycm9yLFxuXHQgICAgICAgICAgICBtZXRob2Q6IG1ldGhvZCxcblx0ICAgICAgICAgICAgdHJhbnNhY3Rpb246IHRyYW5zYWN0aW9uXG5cdCAgICAgICAgfSk7XG5cdCAgICB9XG5cdCAgICAvLyBcIlRyYW5zYWN0aW9uIHdpdGggdGhlIHNhbWUgaGFzaCB3YXMgYWxyZWFkeSBpbXBvcnRlZC5cIlxuXHQgICAgaWYgKG1lc3NhZ2UubWF0Y2goL3NhbWUgaGFzaCB3YXMgYWxyZWFkeSBpbXBvcnRlZHx0cmFuc2FjdGlvbiBub25jZSBpcyB0b28gbG93fG5vbmNlIHRvbyBsb3cvKSkge1xuXHQgICAgICAgIGxvZ2dlci50aHJvd0Vycm9yKFwibm9uY2UgaGFzIGFscmVhZHkgYmVlbiB1c2VkXCIsIGxpYi5Mb2dnZXIuZXJyb3JzLk5PTkNFX0VYUElSRUQsIHtcblx0ICAgICAgICAgICAgZXJyb3I6IGVycm9yLFxuXHQgICAgICAgICAgICBtZXRob2Q6IG1ldGhvZCxcblx0ICAgICAgICAgICAgdHJhbnNhY3Rpb246IHRyYW5zYWN0aW9uXG5cdCAgICAgICAgfSk7XG5cdCAgICB9XG5cdCAgICAvLyBcIlRyYW5zYWN0aW9uIGdhcyBwcmljZSBpcyB0b28gbG93LiBUaGVyZSBpcyBhbm90aGVyIHRyYW5zYWN0aW9uIHdpdGggc2FtZSBub25jZSBpbiB0aGUgcXVldWUuIFRyeSBpbmNyZWFzaW5nIHRoZSBnYXMgcHJpY2Ugb3IgaW5jcmVtZW50aW5nIHRoZSBub25jZS5cIlxuXHQgICAgaWYgKG1lc3NhZ2UubWF0Y2goL2Fub3RoZXIgdHJhbnNhY3Rpb24gd2l0aCBzYW1lIG5vbmNlLykpIHtcblx0ICAgICAgICBsb2dnZXIudGhyb3dFcnJvcihcInJlcGxhY2VtZW50IGZlZSB0b28gbG93XCIsIGxpYi5Mb2dnZXIuZXJyb3JzLlJFUExBQ0VNRU5UX1VOREVSUFJJQ0VELCB7XG5cdCAgICAgICAgICAgIGVycm9yOiBlcnJvcixcblx0ICAgICAgICAgICAgbWV0aG9kOiBtZXRob2QsXG5cdCAgICAgICAgICAgIHRyYW5zYWN0aW9uOiB0cmFuc2FjdGlvblxuXHQgICAgICAgIH0pO1xuXHQgICAgfVxuXHQgICAgaWYgKG1lc3NhZ2UubWF0Y2goL2V4ZWN1dGlvbiBmYWlsZWQgZHVlIHRvIGFuIGV4Y2VwdGlvbnxleGVjdXRpb24gcmV2ZXJ0ZWQvKSkge1xuXHQgICAgICAgIGxvZ2dlci50aHJvd0Vycm9yKFwiY2Fubm90IGVzdGltYXRlIGdhczsgdHJhbnNhY3Rpb24gbWF5IGZhaWwgb3IgbWF5IHJlcXVpcmUgbWFudWFsIGdhcyBsaW1pdFwiLCBsaWIuTG9nZ2VyLmVycm9ycy5VTlBSRURJQ1RBQkxFX0dBU19MSU1JVCwge1xuXHQgICAgICAgICAgICBlcnJvcjogZXJyb3IsXG5cdCAgICAgICAgICAgIG1ldGhvZDogbWV0aG9kLFxuXHQgICAgICAgICAgICB0cmFuc2FjdGlvbjogdHJhbnNhY3Rpb25cblx0ICAgICAgICB9KTtcblx0ICAgIH1cblx0ICAgIHRocm93IGVycm9yO1xuXHR9XG5cdHZhciBFdGhlcnNjYW5Qcm92aWRlciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcblx0ICAgIF9fZXh0ZW5kcyhFdGhlcnNjYW5Qcm92aWRlciwgX3N1cGVyKTtcblx0ICAgIGZ1bmN0aW9uIEV0aGVyc2NhblByb3ZpZGVyKG5ldHdvcmssIGFwaUtleSkge1xuXHQgICAgICAgIHZhciBfbmV3VGFyZ2V0ID0gdGhpcy5jb25zdHJ1Y3Rvcjtcblx0ICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXHQgICAgICAgIGxvZ2dlci5jaGVja05ldyhfbmV3VGFyZ2V0LCBFdGhlcnNjYW5Qcm92aWRlcik7XG5cdCAgICAgICAgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBuZXR3b3JrKSB8fCB0aGlzO1xuXHQgICAgICAgICgwLCBsaWIkMy5kZWZpbmVSZWFkT25seSkoX3RoaXMsIFwiYmFzZVVybFwiLCBfdGhpcy5nZXRCYXNlVXJsKCkpO1xuXHQgICAgICAgICgwLCBsaWIkMy5kZWZpbmVSZWFkT25seSkoX3RoaXMsIFwiYXBpS2V5XCIsIGFwaUtleSB8fCBkZWZhdWx0QXBpS2V5KTtcblx0ICAgICAgICByZXR1cm4gX3RoaXM7XG5cdCAgICB9XG5cdCAgICBFdGhlcnNjYW5Qcm92aWRlci5wcm90b3R5cGUuZ2V0QmFzZVVybCA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICBzd2l0Y2ggKHRoaXMubmV0d29yayA/IHRoaXMubmV0d29yay5uYW1lIDogXCJpbnZhbGlkXCIpIHtcblx0ICAgICAgICAgICAgY2FzZSBcImhvbWVzdGVhZFwiOlxuXHQgICAgICAgICAgICAgICAgcmV0dXJuIFwiaHR0cHM6L1xcL2FwaS5ldGhlcnNjYW4uaW9cIjtcblx0ICAgICAgICAgICAgY2FzZSBcInJvcHN0ZW5cIjpcblx0ICAgICAgICAgICAgICAgIHJldHVybiBcImh0dHBzOi9cXC9hcGktcm9wc3Rlbi5ldGhlcnNjYW4uaW9cIjtcblx0ICAgICAgICAgICAgY2FzZSBcInJpbmtlYnlcIjpcblx0ICAgICAgICAgICAgICAgIHJldHVybiBcImh0dHBzOi9cXC9hcGktcmlua2VieS5ldGhlcnNjYW4uaW9cIjtcblx0ICAgICAgICAgICAgY2FzZSBcImtvdmFuXCI6XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gXCJodHRwczovXFwvYXBpLWtvdmFuLmV0aGVyc2Nhbi5pb1wiO1xuXHQgICAgICAgICAgICBjYXNlIFwiZ29lcmxpXCI6XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gXCJodHRwczovXFwvYXBpLWdvZXJsaS5ldGhlcnNjYW4uaW9cIjtcblx0ICAgICAgICAgICAgZGVmYXVsdDpcblx0ICAgICAgICB9XG5cdCAgICAgICAgcmV0dXJuIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJ1bnN1cHBvcnRlZCBuZXR3b3JrXCIsIFwibmV0d29ya1wiLCBuYW1lKTtcblx0ICAgIH07XG5cdCAgICBFdGhlcnNjYW5Qcm92aWRlci5wcm90b3R5cGUuZ2V0VXJsID0gZnVuY3Rpb24gKG1vZHVsZSwgcGFyYW1zKSB7XG5cdCAgICAgICAgdmFyIHF1ZXJ5ID0gT2JqZWN0LmtleXMocGFyYW1zKS5yZWR1Y2UoZnVuY3Rpb24gKGFjY3VtLCBrZXkpIHtcblx0ICAgICAgICAgICAgdmFyIHZhbHVlID0gcGFyYW1zW2tleV07XG5cdCAgICAgICAgICAgIGlmICh2YWx1ZSAhPSBudWxsKSB7XG5cdCAgICAgICAgICAgICAgICBhY2N1bSArPSBcIiZcIiArIGtleSArIFwiPVwiICsgdmFsdWU7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgcmV0dXJuIGFjY3VtO1xuXHQgICAgICAgIH0sIFwiXCIpO1xuXHQgICAgICAgIHZhciBhcGlLZXkgPSAoKHRoaXMuYXBpS2V5KSA/IFwiJmFwaWtleT1cIiArIHRoaXMuYXBpS2V5IDogXCJcIik7XG5cdCAgICAgICAgcmV0dXJuIHRoaXMuYmFzZVVybCArIFwiL2FwaT9tb2R1bGU9XCIgKyBtb2R1bGUgKyBxdWVyeSArIGFwaUtleTtcblx0ICAgIH07XG5cdCAgICBFdGhlcnNjYW5Qcm92aWRlci5wcm90b3R5cGUuZ2V0UG9zdFVybCA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICByZXR1cm4gdGhpcy5iYXNlVXJsICsgXCIvYXBpXCI7XG5cdCAgICB9O1xuXHQgICAgRXRoZXJzY2FuUHJvdmlkZXIucHJvdG90eXBlLmdldFBvc3REYXRhID0gZnVuY3Rpb24gKG1vZHVsZSwgcGFyYW1zKSB7XG5cdCAgICAgICAgcGFyYW1zLm1vZHVsZSA9IG1vZHVsZTtcblx0ICAgICAgICBwYXJhbXMuYXBpa2V5ID0gdGhpcy5hcGlLZXk7XG5cdCAgICAgICAgcmV0dXJuIHBhcmFtcztcblx0ICAgIH07XG5cdCAgICBFdGhlcnNjYW5Qcm92aWRlci5wcm90b3R5cGUuZmV0Y2ggPSBmdW5jdGlvbiAobW9kdWxlLCBwYXJhbXMsIHBvc3QpIHtcblx0ICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIHZhciB1cmwsIHBheWxvYWQsIHByb2NGdW5jLCBjb25uZWN0aW9uLCBwYXlsb2FkU3RyLCByZXN1bHQ7XG5cdCAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cdCAgICAgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcblx0ICAgICAgICAgICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcblx0ICAgICAgICAgICAgICAgICAgICBjYXNlIDA6XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHVybCA9IChwb3N0ID8gdGhpcy5nZXRQb3N0VXJsKCkgOiB0aGlzLmdldFVybChtb2R1bGUsIHBhcmFtcykpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBwYXlsb2FkID0gKHBvc3QgPyB0aGlzLmdldFBvc3REYXRhKG1vZHVsZSwgcGFyYW1zKSA6IG51bGwpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBwcm9jRnVuYyA9IChtb2R1bGUgPT09IFwicHJveHlcIikgPyBnZXRKc29uUmVzdWx0IDogZ2V0UmVzdWx0O1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmVtaXQoXCJkZWJ1Z1wiLCB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBhY3Rpb246IFwicmVxdWVzdFwiLFxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVxdWVzdDogdXJsLFxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJvdmlkZXI6IHRoaXNcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGNvbm5lY3Rpb24gPSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB1cmw6IHVybCxcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm90dGxlU2xvdEludGVydmFsOiAxMDAwLFxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3R0bGVDYWxsYmFjazogZnVuY3Rpb24gKGF0dGVtcHQsIHVybCkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChfdGhpcy5pc0NvbW11bml0eVJlc291cmNlKCkpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKDAsIGZvcm1hdHRlci5zaG93VGhyb3R0bGVNZXNzYWdlKSgpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHRydWUpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgICAgICB9O1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBwYXlsb2FkU3RyID0gbnVsbDtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHBheWxvYWQpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbm5lY3Rpb24uaGVhZGVycyA9IHsgXCJjb250ZW50LXR5cGVcIjogXCJhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWQ7IGNoYXJzZXQ9VVRGLThcIiB9O1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGF5bG9hZFN0ciA9IE9iamVjdC5rZXlzKHBheWxvYWQpLm1hcChmdW5jdGlvbiAoa2V5KSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGtleSArIFwiPVwiICsgcGF5bG9hZFtrZXldO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSkuam9pbihcIiZcIik7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgKDAsIGxpYiRxLmZldGNoSnNvbikoY29ubmVjdGlvbiwgcGF5bG9hZFN0ciwgcHJvY0Z1bmMgfHwgZ2V0SnNvblJlc3VsdCldO1xuXHQgICAgICAgICAgICAgICAgICAgIGNhc2UgMTpcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gX2Euc2VudCgpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmVtaXQoXCJkZWJ1Z1wiLCB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBhY3Rpb246IFwicmVzcG9uc2VcIixcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlcXVlc3Q6IHVybCxcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlOiAoMCwgbGliJDMuZGVlcENvcHkpKHJlc3VsdCksXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcm92aWRlcjogdGhpc1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB9KTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIHJlc3VsdF07XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIH0pO1xuXHQgICAgICAgIH0pO1xuXHQgICAgfTtcblx0ICAgIEV0aGVyc2NhblByb3ZpZGVyLnByb3RvdHlwZS5kZXRlY3ROZXR3b3JrID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIHRoaXMubmV0d29ya107XG5cdCAgICAgICAgICAgIH0pO1xuXHQgICAgICAgIH0pO1xuXHQgICAgfTtcblx0ICAgIEV0aGVyc2NhblByb3ZpZGVyLnByb3RvdHlwZS5wZXJmb3JtID0gZnVuY3Rpb24gKG1ldGhvZCwgcGFyYW1zKSB7XG5cdCAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICB2YXIgX2EsIHBvc3REYXRhLCBlcnJvcl8xLCBwb3N0RGF0YSwgZXJyb3JfMiwgYXJncywgdG9waWMwLCBsb2dzLCBibG9ja3MsIGksIGxvZywgYmxvY2ssIF9iO1xuXHQgICAgICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9jKSB7XG5cdCAgICAgICAgICAgICAgICBzd2l0Y2ggKF9jLmxhYmVsKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgY2FzZSAwOlxuXHQgICAgICAgICAgICAgICAgICAgICAgICBfYSA9IG1ldGhvZDtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChfYSkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcImdldEJsb2NrTnVtYmVyXCI6IHJldHVybiBbMyAvKmJyZWFrKi8sIDFdO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcImdldEdhc1ByaWNlXCI6IHJldHVybiBbMyAvKmJyZWFrKi8sIDJdO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcImdldEJhbGFuY2VcIjogcmV0dXJuIFszIC8qYnJlYWsqLywgM107XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwiZ2V0VHJhbnNhY3Rpb25Db3VudFwiOiByZXR1cm4gWzMgLypicmVhayovLCA0XTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCJnZXRDb2RlXCI6IHJldHVybiBbMyAvKmJyZWFrKi8sIDVdO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcImdldFN0b3JhZ2VBdFwiOiByZXR1cm4gWzMgLypicmVhayovLCA2XTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCJzZW5kVHJhbnNhY3Rpb25cIjogcmV0dXJuIFszIC8qYnJlYWsqLywgN107XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwiZ2V0QmxvY2tcIjogcmV0dXJuIFszIC8qYnJlYWsqLywgOF07XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwiZ2V0VHJhbnNhY3Rpb25cIjogcmV0dXJuIFszIC8qYnJlYWsqLywgOV07XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwiZ2V0VHJhbnNhY3Rpb25SZWNlaXB0XCI6IHJldHVybiBbMyAvKmJyZWFrKi8sIDEwXTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCJjYWxsXCI6IHJldHVybiBbMyAvKmJyZWFrKi8sIDExXTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCJlc3RpbWF0ZUdhc1wiOiByZXR1cm4gWzMgLypicmVhayovLCAxNV07XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwiZ2V0TG9nc1wiOiByZXR1cm4gWzMgLypicmVhayovLCAxOV07XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwiZ2V0RXRoZXJQcmljZVwiOiByZXR1cm4gWzMgLypicmVhayovLCAyNl07XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFszIC8qYnJlYWsqLywgMjhdO1xuXHQgICAgICAgICAgICAgICAgICAgIGNhc2UgMTogcmV0dXJuIFsyIC8qcmV0dXJuKi8sIHRoaXMuZmV0Y2goXCJwcm94eVwiLCB7IGFjdGlvbjogXCJldGhfYmxvY2tOdW1iZXJcIiB9KV07XG5cdCAgICAgICAgICAgICAgICAgICAgY2FzZSAyOiByZXR1cm4gWzIgLypyZXR1cm4qLywgdGhpcy5mZXRjaChcInByb3h5XCIsIHsgYWN0aW9uOiBcImV0aF9nYXNQcmljZVwiIH0pXTtcblx0ICAgICAgICAgICAgICAgICAgICBjYXNlIDM6IFxuXHQgICAgICAgICAgICAgICAgICAgIC8vIFJldHVybnMgYmFzZS0xMCByZXN1bHRcblx0ICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgdGhpcy5mZXRjaChcImFjY291bnRcIiwge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgYWN0aW9uOiBcImJhbGFuY2VcIixcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFkZHJlc3M6IHBhcmFtcy5hZGRyZXNzLFxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGFnOiBwYXJhbXMuYmxvY2tUYWdcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfSldO1xuXHQgICAgICAgICAgICAgICAgICAgIGNhc2UgNDogcmV0dXJuIFsyIC8qcmV0dXJuKi8sIHRoaXMuZmV0Y2goXCJwcm94eVwiLCB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBhY3Rpb246IFwiZXRoX2dldFRyYW5zYWN0aW9uQ291bnRcIixcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFkZHJlc3M6IHBhcmFtcy5hZGRyZXNzLFxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGFnOiBwYXJhbXMuYmxvY2tUYWdcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfSldO1xuXHQgICAgICAgICAgICAgICAgICAgIGNhc2UgNTogcmV0dXJuIFsyIC8qcmV0dXJuKi8sIHRoaXMuZmV0Y2goXCJwcm94eVwiLCB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBhY3Rpb246IFwiZXRoX2dldENvZGVcIixcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFkZHJlc3M6IHBhcmFtcy5hZGRyZXNzLFxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGFnOiBwYXJhbXMuYmxvY2tUYWdcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfSldO1xuXHQgICAgICAgICAgICAgICAgICAgIGNhc2UgNjogcmV0dXJuIFsyIC8qcmV0dXJuKi8sIHRoaXMuZmV0Y2goXCJwcm94eVwiLCB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBhY3Rpb246IFwiZXRoX2dldFN0b3JhZ2VBdFwiLFxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgYWRkcmVzczogcGFyYW1zLmFkZHJlc3MsXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBwb3NpdGlvbjogcGFyYW1zLnBvc2l0aW9uLFxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGFnOiBwYXJhbXMuYmxvY2tUYWdcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfSldO1xuXHQgICAgICAgICAgICAgICAgICAgIGNhc2UgNzogcmV0dXJuIFsyIC8qcmV0dXJuKi8sIHRoaXMuZmV0Y2goXCJwcm94eVwiLCB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBhY3Rpb246IFwiZXRoX3NlbmRSYXdUcmFuc2FjdGlvblwiLFxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgaGV4OiBwYXJhbXMuc2lnbmVkVHJhbnNhY3Rpb25cblx0ICAgICAgICAgICAgICAgICAgICAgICAgfSwgdHJ1ZSkuY2F0Y2goZnVuY3Rpb24gKGVycm9yKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gY2hlY2tFcnJvcihcInNlbmRUcmFuc2FjdGlvblwiLCBlcnJvciwgcGFyYW1zLnNpZ25lZFRyYW5zYWN0aW9uKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfSldO1xuXHQgICAgICAgICAgICAgICAgICAgIGNhc2UgODpcblx0ICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHBhcmFtcy5ibG9ja1RhZykge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIHRoaXMuZmV0Y2goXCJwcm94eVwiLCB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFjdGlvbjogXCJldGhfZ2V0QmxvY2tCeU51bWJlclwiLFxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0YWc6IHBhcmFtcy5ibG9ja1RhZyxcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYm9vbGVhbjogKHBhcmFtcy5pbmNsdWRlVHJhbnNhY3Rpb25zID8gXCJ0cnVlXCIgOiBcImZhbHNlXCIpXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSldO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImdldEJsb2NrIGJ5IGJsb2NrSGFzaCBub3QgaW1wbGVtZW50ZWRcIik7XG5cdCAgICAgICAgICAgICAgICAgICAgY2FzZSA5OiByZXR1cm4gWzIgLypyZXR1cm4qLywgdGhpcy5mZXRjaChcInByb3h5XCIsIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFjdGlvbjogXCJldGhfZ2V0VHJhbnNhY3Rpb25CeUhhc2hcIixcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR4aGFzaDogcGFyYW1zLnRyYW5zYWN0aW9uSGFzaFxuXHQgICAgICAgICAgICAgICAgICAgICAgICB9KV07XG5cdCAgICAgICAgICAgICAgICAgICAgY2FzZSAxMDogcmV0dXJuIFsyIC8qcmV0dXJuKi8sIHRoaXMuZmV0Y2goXCJwcm94eVwiLCB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBhY3Rpb246IFwiZXRoX2dldFRyYW5zYWN0aW9uUmVjZWlwdFwiLFxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHhoYXNoOiBwYXJhbXMudHJhbnNhY3Rpb25IYXNoXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH0pXTtcblx0ICAgICAgICAgICAgICAgICAgICBjYXNlIDExOlxuXHQgICAgICAgICAgICAgICAgICAgICAgICBpZiAocGFyYW1zLmJsb2NrVGFnICE9PSBcImxhdGVzdFwiKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJFdGhlcnNjYW5Qcm92aWRlciBkb2VzIG5vdCBzdXBwb3J0IGJsb2NrVGFnIGZvciBjYWxsXCIpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHBvc3REYXRhID0gZ2V0VHJhbnNhY3Rpb25Qb3N0RGF0YShwYXJhbXMudHJhbnNhY3Rpb24pO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBwb3N0RGF0YS5tb2R1bGUgPSBcInByb3h5XCI7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHBvc3REYXRhLmFjdGlvbiA9IFwiZXRoX2NhbGxcIjtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgX2MubGFiZWwgPSAxMjtcblx0ICAgICAgICAgICAgICAgICAgICBjYXNlIDEyOlxuXHQgICAgICAgICAgICAgICAgICAgICAgICBfYy50cnlzLnB1c2goWzEyLCAxNCwgLCAxNV0pO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCB0aGlzLmZldGNoKFwicHJveHlcIiwgcG9zdERhdGEsIHRydWUpXTtcblx0ICAgICAgICAgICAgICAgICAgICBjYXNlIDEzOiByZXR1cm4gWzIgLypyZXR1cm4qLywgX2Muc2VudCgpXTtcblx0ICAgICAgICAgICAgICAgICAgICBjYXNlIDE0OlxuXHQgICAgICAgICAgICAgICAgICAgICAgICBlcnJvcl8xID0gX2Muc2VudCgpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgY2hlY2tFcnJvcihcImNhbGxcIiwgZXJyb3JfMSwgcGFyYW1zLnRyYW5zYWN0aW9uKV07XG5cdCAgICAgICAgICAgICAgICAgICAgY2FzZSAxNTpcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcG9zdERhdGEgPSBnZXRUcmFuc2FjdGlvblBvc3REYXRhKHBhcmFtcy50cmFuc2FjdGlvbik7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHBvc3REYXRhLm1vZHVsZSA9IFwicHJveHlcIjtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcG9zdERhdGEuYWN0aW9uID0gXCJldGhfZXN0aW1hdGVHYXNcIjtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgX2MubGFiZWwgPSAxNjtcblx0ICAgICAgICAgICAgICAgICAgICBjYXNlIDE2OlxuXHQgICAgICAgICAgICAgICAgICAgICAgICBfYy50cnlzLnB1c2goWzE2LCAxOCwgLCAxOV0pO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCB0aGlzLmZldGNoKFwicHJveHlcIiwgcG9zdERhdGEsIHRydWUpXTtcblx0ICAgICAgICAgICAgICAgICAgICBjYXNlIDE3OiByZXR1cm4gWzIgLypyZXR1cm4qLywgX2Muc2VudCgpXTtcblx0ICAgICAgICAgICAgICAgICAgICBjYXNlIDE4OlxuXHQgICAgICAgICAgICAgICAgICAgICAgICBlcnJvcl8yID0gX2Muc2VudCgpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgY2hlY2tFcnJvcihcImVzdGltYXRlR2FzXCIsIGVycm9yXzIsIHBhcmFtcy50cmFuc2FjdGlvbildO1xuXHQgICAgICAgICAgICAgICAgICAgIGNhc2UgMTk6XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGFyZ3MgPSB7IGFjdGlvbjogXCJnZXRMb2dzXCIgfTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHBhcmFtcy5maWx0ZXIuZnJvbUJsb2NrKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcmdzLmZyb21CbG9jayA9IGNoZWNrTG9nVGFnKHBhcmFtcy5maWx0ZXIuZnJvbUJsb2NrKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgICAgICBpZiAocGFyYW1zLmZpbHRlci50b0Jsb2NrKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcmdzLnRvQmxvY2sgPSBjaGVja0xvZ1RhZyhwYXJhbXMuZmlsdGVyLnRvQmxvY2spO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwYXJhbXMuZmlsdGVyLmFkZHJlc3MpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFyZ3MuYWRkcmVzcyA9IHBhcmFtcy5maWx0ZXIuYWRkcmVzcztcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgICAgICAvLyBAVE9ETzogV2UgY2FuIGhhbmRsZSBzbGlnaHRseSBtb3JlIGNvbXBsaWNhdGVkIGxvZ3MgdXNpbmcgdGhlIGxvZ3MgQVBJXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwYXJhbXMuZmlsdGVyLnRvcGljcyAmJiBwYXJhbXMuZmlsdGVyLnRvcGljcy5sZW5ndGggPiAwKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocGFyYW1zLmZpbHRlci50b3BpY3MubGVuZ3RoID4gMSkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxvZ2dlci50aHJvd0Vycm9yKFwidW5zdXBwb3J0ZWQgdG9waWMgY291bnRcIiwgbGliLkxvZ2dlci5lcnJvcnMuVU5TVVBQT1JURURfT1BFUkFUSU9OLCB7IHRvcGljczogcGFyYW1zLmZpbHRlci50b3BpY3MgfSk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocGFyYW1zLmZpbHRlci50b3BpY3MubGVuZ3RoID09PSAxKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdG9waWMwID0gcGFyYW1zLmZpbHRlci50b3BpY3NbMF07XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiAodG9waWMwKSAhPT0gXCJzdHJpbmdcIiB8fCB0b3BpYzAubGVuZ3RoICE9PSA2Nikge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsb2dnZXIudGhyb3dFcnJvcihcInVuc3VwcG9ydGVkIHRvcGljIGZvcm1hdFwiLCBsaWIuTG9nZ2VyLmVycm9ycy5VTlNVUFBPUlRFRF9PUEVSQVRJT04sIHsgdG9waWMwOiB0b3BpYzAgfSk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFyZ3MudG9waWMwID0gdG9waWMwO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIHRoaXMuZmV0Y2goXCJsb2dzXCIsIGFyZ3MpXTtcblx0ICAgICAgICAgICAgICAgICAgICBjYXNlIDIwOlxuXHQgICAgICAgICAgICAgICAgICAgICAgICBsb2dzID0gX2Muc2VudCgpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBibG9ja3MgPSB7fTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgaSA9IDA7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIF9jLmxhYmVsID0gMjE7XG5cdCAgICAgICAgICAgICAgICAgICAgY2FzZSAyMTpcblx0ICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCEoaSA8IGxvZ3MubGVuZ3RoKSkgcmV0dXJuIFszIC8qYnJlYWsqLywgMjVdO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBsb2cgPSBsb2dzW2ldO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBpZiAobG9nLmJsb2NrSGFzaCAhPSBudWxsKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzMgLypicmVhayovLCAyNF07XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCEoYmxvY2tzW2xvZy5ibG9ja051bWJlcl0gPT0gbnVsbCkpIHJldHVybiBbMyAvKmJyZWFrKi8sIDIzXTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgdGhpcy5nZXRCbG9jayhsb2cuYmxvY2tOdW1iZXIpXTtcblx0ICAgICAgICAgICAgICAgICAgICBjYXNlIDIyOlxuXHQgICAgICAgICAgICAgICAgICAgICAgICBibG9jayA9IF9jLnNlbnQoKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGJsb2NrKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBibG9ja3NbbG9nLmJsb2NrTnVtYmVyXSA9IGJsb2NrLmhhc2g7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICAgICAgX2MubGFiZWwgPSAyMztcblx0ICAgICAgICAgICAgICAgICAgICBjYXNlIDIzOlxuXHQgICAgICAgICAgICAgICAgICAgICAgICBsb2cuYmxvY2tIYXNoID0gYmxvY2tzW2xvZy5ibG9ja051bWJlcl07XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIF9jLmxhYmVsID0gMjQ7XG5cdCAgICAgICAgICAgICAgICAgICAgY2FzZSAyNDpcblx0ICAgICAgICAgICAgICAgICAgICAgICAgaSsrO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzMgLypicmVhayovLCAyMV07XG5cdCAgICAgICAgICAgICAgICAgICAgY2FzZSAyNTogcmV0dXJuIFsyIC8qcmV0dXJuKi8sIGxvZ3NdO1xuXHQgICAgICAgICAgICAgICAgICAgIGNhc2UgMjY6XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLm5ldHdvcmsubmFtZSAhPT0gXCJob21lc3RlYWRcIikge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIDAuMF07XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICAgICAgX2IgPSBwYXJzZUZsb2F0O1xuXHQgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCB0aGlzLmZldGNoKFwic3RhdHNcIiwgeyBhY3Rpb246IFwiZXRocHJpY2VcIiB9KV07XG5cdCAgICAgICAgICAgICAgICAgICAgY2FzZSAyNzogcmV0dXJuIFsyIC8qcmV0dXJuKi8sIF9iLmFwcGx5KHZvaWQgMCwgWyhfYy5zZW50KCkpLmV0aHVzZF0pXTtcblx0ICAgICAgICAgICAgICAgICAgICBjYXNlIDI4OiByZXR1cm4gWzMgLypicmVhayovLCAyOV07XG5cdCAgICAgICAgICAgICAgICAgICAgY2FzZSAyOTogcmV0dXJuIFsyIC8qcmV0dXJuKi8sIF9zdXBlci5wcm90b3R5cGUucGVyZm9ybS5jYWxsKHRoaXMsIG1ldGhvZCwgcGFyYW1zKV07XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIH0pO1xuXHQgICAgICAgIH0pO1xuXHQgICAgfTtcblx0ICAgIC8vIE5vdGU6IFRoZSBgcGFnZWAgcGFnZSBwYXJhbWV0ZXIgb25seSBhbGxvd3MgcGFnaW5hdGlvbiB3aXRoaW4gdGhlXG5cdCAgICAvLyAgICAgICAxMCwwMDAgd2luZG93IGF2YWlsYWJsZSB3aXRob3V0IGEgcGFnZSBhbmQgb2Zmc2V0IHBhcmFtZXRlclxuXHQgICAgLy8gICAgICAgRXJyb3I6IFJlc3VsdCB3aW5kb3cgaXMgdG9vIGxhcmdlLCBQYWdlTm8geCBPZmZzZXQgc2l6ZSBtdXN0XG5cdCAgICAvLyAgICAgICAgICAgICAgYmUgbGVzcyB0aGFuIG9yIGVxdWFsIHRvIDEwMDAwXG5cdCAgICBFdGhlcnNjYW5Qcm92aWRlci5wcm90b3R5cGUuZ2V0SGlzdG9yeSA9IGZ1bmN0aW9uIChhZGRyZXNzT3JOYW1lLCBzdGFydEJsb2NrLCBlbmRCbG9jaykge1xuXHQgICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgdmFyIHBhcmFtcywgcmVzdWx0O1xuXHQgICAgICAgICAgICB2YXIgX2E7XG5cdCAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cdCAgICAgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2IpIHtcblx0ICAgICAgICAgICAgICAgIHN3aXRjaCAoX2IubGFiZWwpIHtcblx0ICAgICAgICAgICAgICAgICAgICBjYXNlIDA6XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIF9hID0ge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgYWN0aW9uOiBcInR4bGlzdFwiXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH07XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIHRoaXMucmVzb2x2ZU5hbWUoYWRkcmVzc09yTmFtZSldO1xuXHQgICAgICAgICAgICAgICAgICAgIGNhc2UgMTpcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcGFyYW1zID0gKF9hLmFkZHJlc3MgPSAoX2Iuc2VudCgpKSxcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9hLnN0YXJ0YmxvY2sgPSAoKHN0YXJ0QmxvY2sgPT0gbnVsbCkgPyAwIDogc3RhcnRCbG9jayksXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBfYS5lbmRibG9jayA9ICgoZW5kQmxvY2sgPT0gbnVsbCkgPyA5OTk5OTk5OSA6IGVuZEJsb2NrKSxcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9hLnNvcnQgPSBcImFzY1wiLFxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgX2EpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCB0aGlzLmZldGNoKFwiYWNjb3VudFwiLCBwYXJhbXMpXTtcblx0ICAgICAgICAgICAgICAgICAgICBjYXNlIDI6XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IF9iLnNlbnQoKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIHJlc3VsdC5tYXAoZnVuY3Rpb24gKHR4KSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgW1wiY29udHJhY3RBZGRyZXNzXCIsIFwidG9cIl0uZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0eFtrZXldID09IFwiXCIpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlbGV0ZSB0eFtrZXldO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHR4LmNyZWF0ZXMgPT0gbnVsbCAmJiB0eC5jb250cmFjdEFkZHJlc3MgIT0gbnVsbCkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eC5jcmVhdGVzID0gdHguY29udHJhY3RBZGRyZXNzO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgaXRlbSA9IF90aGlzLmZvcm1hdHRlci50cmFuc2FjdGlvblJlc3BvbnNlKHR4KTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodHgudGltZVN0YW1wKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGl0ZW0udGltZXN0YW1wID0gcGFyc2VJbnQodHgudGltZVN0YW1wKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGl0ZW07XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KV07XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIH0pO1xuXHQgICAgICAgIH0pO1xuXHQgICAgfTtcblx0ICAgIEV0aGVyc2NhblByb3ZpZGVyLnByb3RvdHlwZS5pc0NvbW11bml0eVJlc291cmNlID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIHJldHVybiAodGhpcy5hcGlLZXkgPT09IGRlZmF1bHRBcGlLZXkpO1xuXHQgICAgfTtcblx0ICAgIHJldHVybiBFdGhlcnNjYW5Qcm92aWRlcjtcblx0fShiYXNlUHJvdmlkZXIuQmFzZVByb3ZpZGVyKSk7XG5cdGV4cG9ydHMuRXRoZXJzY2FuUHJvdmlkZXIgPSBFdGhlcnNjYW5Qcm92aWRlcjtcblxuXHR9KTtcblxuXHR2YXIgZXRoZXJzY2FuUHJvdmlkZXIkMSA9IC8qQF9fUFVSRV9fKi9nZXREZWZhdWx0RXhwb3J0RnJvbUNqcyhldGhlcnNjYW5Qcm92aWRlcik7XG5cblx0dmFyIGZhbGxiYWNrUHJvdmlkZXIgPSBjcmVhdGVDb21tb25qc01vZHVsZShmdW5jdGlvbiAobW9kdWxlLCBleHBvcnRzKSB7XG5cdFwidXNlIHN0cmljdFwiO1xuXHR2YXIgX19leHRlbmRzID0gKGNvbW1vbmpzR2xvYmFsICYmIGNvbW1vbmpzR2xvYmFsLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcblx0ICAgIHZhciBleHRlbmRTdGF0aWNzID0gZnVuY3Rpb24gKGQsIGIpIHtcblx0ICAgICAgICBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG5cdCAgICAgICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcblx0ICAgICAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGIsIHApKSBkW3BdID0gYltwXTsgfTtcblx0ICAgICAgICByZXR1cm4gZXh0ZW5kU3RhdGljcyhkLCBiKTtcblx0ICAgIH07XG5cdCAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcblx0ICAgICAgICBpZiAodHlwZW9mIGIgIT09IFwiZnVuY3Rpb25cIiAmJiBiICE9PSBudWxsKVxuXHQgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2xhc3MgZXh0ZW5kcyB2YWx1ZSBcIiArIFN0cmluZyhiKSArIFwiIGlzIG5vdCBhIGNvbnN0cnVjdG9yIG9yIG51bGxcIik7XG5cdCAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcblx0ICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cblx0ICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG5cdCAgICB9O1xuXHR9KSgpO1xuXHR2YXIgX19hd2FpdGVyID0gKGNvbW1vbmpzR2xvYmFsICYmIGNvbW1vbmpzR2xvYmFsLl9fYXdhaXRlcikgfHwgZnVuY3Rpb24gKHRoaXNBcmcsIF9hcmd1bWVudHMsIFAsIGdlbmVyYXRvcikge1xuXHQgICAgZnVuY3Rpb24gYWRvcHQodmFsdWUpIHsgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgUCA/IHZhbHVlIDogbmV3IFAoZnVuY3Rpb24gKHJlc29sdmUpIHsgcmVzb2x2ZSh2YWx1ZSk7IH0pOyB9XG5cdCAgICByZXR1cm4gbmV3IChQIHx8IChQID0gUHJvbWlzZSkpKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcblx0ICAgICAgICBmdW5jdGlvbiBmdWxmaWxsZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3IubmV4dCh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG5cdCAgICAgICAgZnVuY3Rpb24gcmVqZWN0ZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3JbXCJ0aHJvd1wiXSh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG5cdCAgICAgICAgZnVuY3Rpb24gc3RlcChyZXN1bHQpIHsgcmVzdWx0LmRvbmUgPyByZXNvbHZlKHJlc3VsdC52YWx1ZSkgOiBhZG9wdChyZXN1bHQudmFsdWUpLnRoZW4oZnVsZmlsbGVkLCByZWplY3RlZCk7IH1cblx0ICAgICAgICBzdGVwKChnZW5lcmF0b3IgPSBnZW5lcmF0b3IuYXBwbHkodGhpc0FyZywgX2FyZ3VtZW50cyB8fCBbXSkpLm5leHQoKSk7XG5cdCAgICB9KTtcblx0fTtcblx0dmFyIF9fZ2VuZXJhdG9yID0gKGNvbW1vbmpzR2xvYmFsICYmIGNvbW1vbmpzR2xvYmFsLl9fZ2VuZXJhdG9yKSB8fCBmdW5jdGlvbiAodGhpc0FyZywgYm9keSkge1xuXHQgICAgdmFyIF8gPSB7IGxhYmVsOiAwLCBzZW50OiBmdW5jdGlvbigpIHsgaWYgKHRbMF0gJiAxKSB0aHJvdyB0WzFdOyByZXR1cm4gdFsxXTsgfSwgdHJ5czogW10sIG9wczogW10gfSwgZiwgeSwgdCwgZztcblx0ICAgIHJldHVybiBnID0geyBuZXh0OiB2ZXJiKDApLCBcInRocm93XCI6IHZlcmIoMSksIFwicmV0dXJuXCI6IHZlcmIoMikgfSwgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIChnW1N5bWJvbC5pdGVyYXRvcl0gPSBmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXM7IH0pLCBnO1xuXHQgICAgZnVuY3Rpb24gdmVyYihuKSB7IHJldHVybiBmdW5jdGlvbiAodikgeyByZXR1cm4gc3RlcChbbiwgdl0pOyB9OyB9XG5cdCAgICBmdW5jdGlvbiBzdGVwKG9wKSB7XG5cdCAgICAgICAgaWYgKGYpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJHZW5lcmF0b3IgaXMgYWxyZWFkeSBleGVjdXRpbmcuXCIpO1xuXHQgICAgICAgIHdoaWxlIChfKSB0cnkge1xuXHQgICAgICAgICAgICBpZiAoZiA9IDEsIHkgJiYgKHQgPSBvcFswXSAmIDIgPyB5W1wicmV0dXJuXCJdIDogb3BbMF0gPyB5W1widGhyb3dcIl0gfHwgKCh0ID0geVtcInJldHVyblwiXSkgJiYgdC5jYWxsKHkpLCAwKSA6IHkubmV4dCkgJiYgISh0ID0gdC5jYWxsKHksIG9wWzFdKSkuZG9uZSkgcmV0dXJuIHQ7XG5cdCAgICAgICAgICAgIGlmICh5ID0gMCwgdCkgb3AgPSBbb3BbMF0gJiAyLCB0LnZhbHVlXTtcblx0ICAgICAgICAgICAgc3dpdGNoIChvcFswXSkge1xuXHQgICAgICAgICAgICAgICAgY2FzZSAwOiBjYXNlIDE6IHQgPSBvcDsgYnJlYWs7XG5cdCAgICAgICAgICAgICAgICBjYXNlIDQ6IF8ubGFiZWwrKzsgcmV0dXJuIHsgdmFsdWU6IG9wWzFdLCBkb25lOiBmYWxzZSB9O1xuXHQgICAgICAgICAgICAgICAgY2FzZSA1OiBfLmxhYmVsKys7IHkgPSBvcFsxXTsgb3AgPSBbMF07IGNvbnRpbnVlO1xuXHQgICAgICAgICAgICAgICAgY2FzZSA3OiBvcCA9IF8ub3BzLnBvcCgpOyBfLnRyeXMucG9wKCk7IGNvbnRpbnVlO1xuXHQgICAgICAgICAgICAgICAgZGVmYXVsdDpcblx0ICAgICAgICAgICAgICAgICAgICBpZiAoISh0ID0gXy50cnlzLCB0ID0gdC5sZW5ndGggPiAwICYmIHRbdC5sZW5ndGggLSAxXSkgJiYgKG9wWzBdID09PSA2IHx8IG9wWzBdID09PSAyKSkgeyBfID0gMDsgY29udGludWU7IH1cblx0ICAgICAgICAgICAgICAgICAgICBpZiAob3BbMF0gPT09IDMgJiYgKCF0IHx8IChvcFsxXSA+IHRbMF0gJiYgb3BbMV0gPCB0WzNdKSkpIHsgXy5sYWJlbCA9IG9wWzFdOyBicmVhazsgfVxuXHQgICAgICAgICAgICAgICAgICAgIGlmIChvcFswXSA9PT0gNiAmJiBfLmxhYmVsIDwgdFsxXSkgeyBfLmxhYmVsID0gdFsxXTsgdCA9IG9wOyBicmVhazsgfVxuXHQgICAgICAgICAgICAgICAgICAgIGlmICh0ICYmIF8ubGFiZWwgPCB0WzJdKSB7IF8ubGFiZWwgPSB0WzJdOyBfLm9wcy5wdXNoKG9wKTsgYnJlYWs7IH1cblx0ICAgICAgICAgICAgICAgICAgICBpZiAodFsyXSkgXy5vcHMucG9wKCk7XG5cdCAgICAgICAgICAgICAgICAgICAgXy50cnlzLnBvcCgpOyBjb250aW51ZTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICBvcCA9IGJvZHkuY2FsbCh0aGlzQXJnLCBfKTtcblx0ICAgICAgICB9IGNhdGNoIChlKSB7IG9wID0gWzYsIGVdOyB5ID0gMDsgfSBmaW5hbGx5IHsgZiA9IHQgPSAwOyB9XG5cdCAgICAgICAgaWYgKG9wWzBdICYgNSkgdGhyb3cgb3BbMV07IHJldHVybiB7IHZhbHVlOiBvcFswXSA/IG9wWzFdIDogdm9pZCAwLCBkb25lOiB0cnVlIH07XG5cdCAgICB9XG5cdH07XG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcblx0ZXhwb3J0cy5GYWxsYmFja1Byb3ZpZGVyID0gdm9pZCAwO1xuXG5cblxuXG5cblxuXG5cblxuXG5cdHZhciBsb2dnZXIgPSBuZXcgbGliLkxvZ2dlcihfdmVyc2lvbiRJLnZlcnNpb24pO1xuXHRmdW5jdGlvbiBub3coKSB7IHJldHVybiAobmV3IERhdGUoKSkuZ2V0VGltZSgpOyB9XG5cdC8vIFJldHVybnMgdG8gbmV0d29yayBhcyBsb25nIGFzIGFsbCBhZ3JlZSwgb3IgbnVsbCBpZiBhbnkgaXMgbnVsbC5cblx0Ly8gVGhyb3dzIGFuIGVycm9yIGlmIGFueSB0d28gbmV0d29ya3MgZG8gbm90IG1hdGNoLlxuXHRmdW5jdGlvbiBjaGVja05ldHdvcmtzKG5ldHdvcmtzKSB7XG5cdCAgICB2YXIgcmVzdWx0ID0gbnVsbDtcblx0ICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbmV0d29ya3MubGVuZ3RoOyBpKyspIHtcblx0ICAgICAgICB2YXIgbmV0d29yayA9IG5ldHdvcmtzW2ldO1xuXHQgICAgICAgIC8vIE51bGwhIFdlIGRvIG5vdCBrbm93IG91ciBuZXR3b3JrOyBiYWlsLlxuXHQgICAgICAgIGlmIChuZXR3b3JrID09IG51bGwpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIG51bGw7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGlmIChyZXN1bHQpIHtcblx0ICAgICAgICAgICAgLy8gTWFrZSBzdXJlIHRoZSBuZXR3b3JrIG1hdGNoZXMgdGhlIHByZXZpb3VzIG5ldHdvcmtzXG5cdCAgICAgICAgICAgIGlmICghKHJlc3VsdC5uYW1lID09PSBuZXR3b3JrLm5hbWUgJiYgcmVzdWx0LmNoYWluSWQgPT09IG5ldHdvcmsuY2hhaW5JZCAmJlxuXHQgICAgICAgICAgICAgICAgKChyZXN1bHQuZW5zQWRkcmVzcyA9PT0gbmV0d29yay5lbnNBZGRyZXNzKSB8fCAocmVzdWx0LmVuc0FkZHJlc3MgPT0gbnVsbCAmJiBuZXR3b3JrLmVuc0FkZHJlc3MgPT0gbnVsbCkpKSkge1xuXHQgICAgICAgICAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcInByb3ZpZGVyIG1pc21hdGNoXCIsIFwibmV0d29ya3NcIiwgbmV0d29ya3MpO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGVsc2Uge1xuXHQgICAgICAgICAgICByZXN1bHQgPSBuZXR3b3JrO1xuXHQgICAgICAgIH1cblx0ICAgIH1cblx0ICAgIHJldHVybiByZXN1bHQ7XG5cdH1cblx0ZnVuY3Rpb24gbWVkaWFuKHZhbHVlcywgbWF4RGVsdGEpIHtcblx0ICAgIHZhbHVlcyA9IHZhbHVlcy5zbGljZSgpLnNvcnQoKTtcblx0ICAgIHZhciBtaWRkbGUgPSBNYXRoLmZsb29yKHZhbHVlcy5sZW5ndGggLyAyKTtcblx0ICAgIC8vIE9kZCBsZW5ndGg7IHRha2UgdGhlIG1pZGRsZVxuXHQgICAgaWYgKHZhbHVlcy5sZW5ndGggJSAyKSB7XG5cdCAgICAgICAgcmV0dXJuIHZhbHVlc1ttaWRkbGVdO1xuXHQgICAgfVxuXHQgICAgLy8gRXZlbiBsZW5ndGg7IHRha2UgdGhlIGF2ZXJhZ2Ugb2YgdGhlIHR3byBtaWRkbGVcblx0ICAgIHZhciBhID0gdmFsdWVzW21pZGRsZSAtIDFdLCBiID0gdmFsdWVzW21pZGRsZV07XG5cdCAgICBpZiAobWF4RGVsdGEgIT0gbnVsbCAmJiBNYXRoLmFicyhhIC0gYikgPiBtYXhEZWx0YSkge1xuXHQgICAgICAgIHJldHVybiBudWxsO1xuXHQgICAgfVxuXHQgICAgcmV0dXJuIChhICsgYikgLyAyO1xuXHR9XG5cdGZ1bmN0aW9uIHNlcmlhbGl6ZSh2YWx1ZSkge1xuXHQgICAgaWYgKHZhbHVlID09PSBudWxsKSB7XG5cdCAgICAgICAgcmV0dXJuIFwibnVsbFwiO1xuXHQgICAgfVxuXHQgICAgZWxzZSBpZiAodHlwZW9mICh2YWx1ZSkgPT09IFwibnVtYmVyXCIgfHwgdHlwZW9mICh2YWx1ZSkgPT09IFwiYm9vbGVhblwiKSB7XG5cdCAgICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHZhbHVlKTtcblx0ICAgIH1cblx0ICAgIGVsc2UgaWYgKHR5cGVvZiAodmFsdWUpID09PSBcInN0cmluZ1wiKSB7XG5cdCAgICAgICAgcmV0dXJuIHZhbHVlO1xuXHQgICAgfVxuXHQgICAgZWxzZSBpZiAobGliJDIuQmlnTnVtYmVyLmlzQmlnTnVtYmVyKHZhbHVlKSkge1xuXHQgICAgICAgIHJldHVybiB2YWx1ZS50b1N0cmluZygpO1xuXHQgICAgfVxuXHQgICAgZWxzZSBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcblx0ICAgICAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkodmFsdWUubWFwKGZ1bmN0aW9uIChpKSB7IHJldHVybiBzZXJpYWxpemUoaSk7IH0pKTtcblx0ICAgIH1cblx0ICAgIGVsc2UgaWYgKHR5cGVvZiAodmFsdWUpID09PSBcIm9iamVjdFwiKSB7XG5cdCAgICAgICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyh2YWx1ZSk7XG5cdCAgICAgICAga2V5cy5zb3J0KCk7XG5cdCAgICAgICAgcmV0dXJuIFwie1wiICsga2V5cy5tYXAoZnVuY3Rpb24gKGtleSkge1xuXHQgICAgICAgICAgICB2YXIgdiA9IHZhbHVlW2tleV07XG5cdCAgICAgICAgICAgIGlmICh0eXBlb2YgKHYpID09PSBcImZ1bmN0aW9uXCIpIHtcblx0ICAgICAgICAgICAgICAgIHYgPSBcIltmdW5jdGlvbl1cIjtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICBlbHNlIHtcblx0ICAgICAgICAgICAgICAgIHYgPSBzZXJpYWxpemUodik7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KGtleSkgKyBcIjpcIiArIHY7XG5cdCAgICAgICAgfSkuam9pbihcIixcIikgKyBcIn1cIjtcblx0ICAgIH1cblx0ICAgIHRocm93IG5ldyBFcnJvcihcInVua25vd24gdmFsdWUgdHlwZTogXCIgKyB0eXBlb2YgKHZhbHVlKSk7XG5cdH1cblx0Ly8gTmV4dCByZXF1ZXN0IElEIHRvIHVzZSBmb3IgZW1pdHRpbmcgZGVidWcgaW5mb1xuXHR2YXIgbmV4dFJpZCA9IDE7XG5cdDtcblx0ZnVuY3Rpb24gc3RhbGwoZHVyYXRpb24pIHtcblx0ICAgIHZhciBjYW5jZWwgPSBudWxsO1xuXHQgICAgdmFyIHRpbWVyID0gbnVsbDtcblx0ICAgIHZhciBwcm9taXNlID0gKG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlKSB7XG5cdCAgICAgICAgY2FuY2VsID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICBpZiAodGltZXIpIHtcblx0ICAgICAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aW1lcik7XG5cdCAgICAgICAgICAgICAgICB0aW1lciA9IG51bGw7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgcmVzb2x2ZSgpO1xuXHQgICAgICAgIH07XG5cdCAgICAgICAgdGltZXIgPSBzZXRUaW1lb3V0KGNhbmNlbCwgZHVyYXRpb24pO1xuXHQgICAgfSkpO1xuXHQgICAgdmFyIHdhaXQgPSBmdW5jdGlvbiAoZnVuYykge1xuXHQgICAgICAgIHByb21pc2UgPSBwcm9taXNlLnRoZW4oZnVuYyk7XG5cdCAgICAgICAgcmV0dXJuIHByb21pc2U7XG5cdCAgICB9O1xuXHQgICAgZnVuY3Rpb24gZ2V0UHJvbWlzZSgpIHtcblx0ICAgICAgICByZXR1cm4gcHJvbWlzZTtcblx0ICAgIH1cblx0ICAgIHJldHVybiB7IGNhbmNlbDogY2FuY2VsLCBnZXRQcm9taXNlOiBnZXRQcm9taXNlLCB3YWl0OiB3YWl0IH07XG5cdH1cblx0dmFyIEZvcndhcmRFcnJvcnMgPSBbXG5cdCAgICBsaWIuTG9nZ2VyLmVycm9ycy5DQUxMX0VYQ0VQVElPTixcblx0ICAgIGxpYi5Mb2dnZXIuZXJyb3JzLklOU1VGRklDSUVOVF9GVU5EUyxcblx0ICAgIGxpYi5Mb2dnZXIuZXJyb3JzLk5PTkNFX0VYUElSRUQsXG5cdCAgICBsaWIuTG9nZ2VyLmVycm9ycy5SRVBMQUNFTUVOVF9VTkRFUlBSSUNFRCxcblx0ICAgIGxpYi5Mb2dnZXIuZXJyb3JzLlVOUFJFRElDVEFCTEVfR0FTX0xJTUlUXG5cdF07XG5cdHZhciBGb3J3YXJkUHJvcGVydGllcyA9IFtcblx0ICAgIFwiYWRkcmVzc1wiLFxuXHQgICAgXCJhcmdzXCIsXG5cdCAgICBcImVycm9yQXJnc1wiLFxuXHQgICAgXCJlcnJvclNpZ25hdHVyZVwiLFxuXHQgICAgXCJtZXRob2RcIixcblx0ICAgIFwidHJhbnNhY3Rpb25cIixcblx0XTtcblx0O1xuXHRmdW5jdGlvbiBleHBvc2VEZWJ1Z0NvbmZpZyhjb25maWcsIG5vdykge1xuXHQgICAgdmFyIHJlc3VsdCA9IHtcblx0ICAgICAgICB3ZWlnaHQ6IGNvbmZpZy53ZWlnaHRcblx0ICAgIH07XG5cdCAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkocmVzdWx0LCBcInByb3ZpZGVyXCIsIHsgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBjb25maWcucHJvdmlkZXI7IH0gfSk7XG5cdCAgICBpZiAoY29uZmlnLnN0YXJ0KSB7XG5cdCAgICAgICAgcmVzdWx0LnN0YXJ0ID0gY29uZmlnLnN0YXJ0O1xuXHQgICAgfVxuXHQgICAgaWYgKG5vdykge1xuXHQgICAgICAgIHJlc3VsdC5kdXJhdGlvbiA9IChub3cgLSBjb25maWcuc3RhcnQpO1xuXHQgICAgfVxuXHQgICAgaWYgKGNvbmZpZy5kb25lKSB7XG5cdCAgICAgICAgaWYgKGNvbmZpZy5lcnJvcikge1xuXHQgICAgICAgICAgICByZXN1bHQuZXJyb3IgPSBjb25maWcuZXJyb3I7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGVsc2Uge1xuXHQgICAgICAgICAgICByZXN1bHQucmVzdWx0ID0gY29uZmlnLnJlc3VsdCB8fCBudWxsO1xuXHQgICAgICAgIH1cblx0ICAgIH1cblx0ICAgIHJldHVybiByZXN1bHQ7XG5cdH1cblx0ZnVuY3Rpb24gbm9ybWFsaXplZFRhbGx5KG5vcm1hbGl6ZSwgcXVvcnVtKSB7XG5cdCAgICByZXR1cm4gZnVuY3Rpb24gKGNvbmZpZ3MpIHtcblx0ICAgICAgICAvLyBDb3VudCB0aGUgdm90ZXMgZm9yIGVhY2ggcmVzdWx0XG5cdCAgICAgICAgdmFyIHRhbGx5ID0ge307XG5cdCAgICAgICAgY29uZmlncy5mb3JFYWNoKGZ1bmN0aW9uIChjKSB7XG5cdCAgICAgICAgICAgIHZhciB2YWx1ZSA9IG5vcm1hbGl6ZShjLnJlc3VsdCk7XG5cdCAgICAgICAgICAgIGlmICghdGFsbHlbdmFsdWVdKSB7XG5cdCAgICAgICAgICAgICAgICB0YWxseVt2YWx1ZV0gPSB7IGNvdW50OiAwLCByZXN1bHQ6IGMucmVzdWx0IH07XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgdGFsbHlbdmFsdWVdLmNvdW50Kys7XG5cdCAgICAgICAgfSk7XG5cdCAgICAgICAgLy8gQ2hlY2sgZm9yIGEgcXVvcnVtIG9uIGFueSBnaXZlbiByZXN1bHRcblx0ICAgICAgICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKHRhbGx5KTtcblx0ICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcblx0ICAgICAgICAgICAgdmFyIGNoZWNrID0gdGFsbHlba2V5c1tpXV07XG5cdCAgICAgICAgICAgIGlmIChjaGVjay5jb3VudCA+PSBxdW9ydW0pIHtcblx0ICAgICAgICAgICAgICAgIHJldHVybiBjaGVjay5yZXN1bHQ7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9XG5cdCAgICAgICAgLy8gTm8gcXVyb3VtXG5cdCAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcblx0ICAgIH07XG5cdH1cblx0ZnVuY3Rpb24gZ2V0UHJvY2Vzc0Z1bmMocHJvdmlkZXIsIG1ldGhvZCwgcGFyYW1zKSB7XG5cdCAgICB2YXIgbm9ybWFsaXplID0gc2VyaWFsaXplO1xuXHQgICAgc3dpdGNoIChtZXRob2QpIHtcblx0ICAgICAgICBjYXNlIFwiZ2V0QmxvY2tOdW1iZXJcIjpcblx0ICAgICAgICAgICAgLy8gUmV0dXJuIHRoZSBtZWRpYW4gdmFsdWUsIHVubGVzcyB0aGVyZSBpcyAobWVkaWFuICsgMSkgaXMgYWxzb1xuXHQgICAgICAgICAgICAvLyBwcmVzZW50LCBpbiB3aGljaCBjYXNlIHRoYXQgaXMgcHJvYmFibHkgdHJ1ZSBhbmQgdGhlIG1lZGlhblxuXHQgICAgICAgICAgICAvLyBpcyBnb2luZyB0byBiZSBzdGFsZSBzb29uLiBJbiB0aGUgZXZlbnQgb2YgYSBtYWxpY2lvdXMgbm9kZSxcblx0ICAgICAgICAgICAgLy8gdGhlIGxpZSB3aWxsIGJlIHRydWUgc29vbiBlbm91Z2guXG5cdCAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoY29uZmlncykge1xuXHQgICAgICAgICAgICAgICAgdmFyIHZhbHVlcyA9IGNvbmZpZ3MubWFwKGZ1bmN0aW9uIChjKSB7IHJldHVybiBjLnJlc3VsdDsgfSk7XG5cdCAgICAgICAgICAgICAgICAvLyBHZXQgdGhlIG1lZGlhbiBibG9jayBudW1iZXJcblx0ICAgICAgICAgICAgICAgIHZhciBibG9ja051bWJlciA9IG1lZGlhbihjb25maWdzLm1hcChmdW5jdGlvbiAoYykgeyByZXR1cm4gYy5yZXN1bHQ7IH0pLCAyKTtcblx0ICAgICAgICAgICAgICAgIGlmIChibG9ja051bWJlciA9PSBudWxsKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgIGJsb2NrTnVtYmVyID0gTWF0aC5jZWlsKGJsb2NrTnVtYmVyKTtcblx0ICAgICAgICAgICAgICAgIC8vIElmIHRoZSBuZXh0IGJsb2NrIGhlaWdodCBpcyBwcmVzZW50LCBpdHMgcHJvbGx5IHNhZmUgdG8gdXNlXG5cdCAgICAgICAgICAgICAgICBpZiAodmFsdWVzLmluZGV4T2YoYmxvY2tOdW1iZXIgKyAxKSA+PSAwKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgYmxvY2tOdW1iZXIrKztcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgIC8vIERvbid0IGV2ZXIgcm9sbCBiYWNrIHRoZSBibG9ja051bWJlclxuXHQgICAgICAgICAgICAgICAgaWYgKGJsb2NrTnVtYmVyID49IHByb3ZpZGVyLl9oaWdoZXN0QmxvY2tOdW1iZXIpIHtcblx0ICAgICAgICAgICAgICAgICAgICBwcm92aWRlci5faGlnaGVzdEJsb2NrTnVtYmVyID0gYmxvY2tOdW1iZXI7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gcHJvdmlkZXIuX2hpZ2hlc3RCbG9ja051bWJlcjtcblx0ICAgICAgICAgICAgfTtcblx0ICAgICAgICBjYXNlIFwiZ2V0R2FzUHJpY2VcIjpcblx0ICAgICAgICAgICAgLy8gUmV0dXJuIHRoZSBtaWRkbGUgKHJvdW5kIGluZGV4IHVwKSB2YWx1ZSwgc2ltaWxhciB0byBtZWRpYW5cblx0ICAgICAgICAgICAgLy8gYnV0IGRvIG5vdCBhdmVyYWdlIGV2ZW4gZW50cmllcyBhbmQgY2hvb3NlIHRoZSBoaWdoZXIuXG5cdCAgICAgICAgICAgIC8vIE1hbGljaW91cyBhY3RvcnMgbXVzdCBjb21wcm9taXNlIDUwJSBvZiB0aGUgbm9kZXMgdG8gbGllLlxuXHQgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGNvbmZpZ3MpIHtcblx0ICAgICAgICAgICAgICAgIHZhciB2YWx1ZXMgPSBjb25maWdzLm1hcChmdW5jdGlvbiAoYykgeyByZXR1cm4gYy5yZXN1bHQ7IH0pO1xuXHQgICAgICAgICAgICAgICAgdmFsdWVzLnNvcnQoKTtcblx0ICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZXNbTWF0aC5mbG9vcih2YWx1ZXMubGVuZ3RoIC8gMildO1xuXHQgICAgICAgICAgICB9O1xuXHQgICAgICAgIGNhc2UgXCJnZXRFdGhlclByaWNlXCI6XG5cdCAgICAgICAgICAgIC8vIFJldHVybnMgdGhlIG1lZGlhbiBwcmljZS4gTWFsaWNpb3VzIGFjdG9ycyBtdXN0IGNvbXByb21pc2UgYXRcblx0ICAgICAgICAgICAgLy8gbGVhc3QgNTAlIG9mIHRoZSBub2RlcyB0byBsaWUgKGluIGEgbWVhbmluZ2Z1bCB3YXkpLlxuXHQgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGNvbmZpZ3MpIHtcblx0ICAgICAgICAgICAgICAgIHJldHVybiBtZWRpYW4oY29uZmlncy5tYXAoZnVuY3Rpb24gKGMpIHsgcmV0dXJuIGMucmVzdWx0OyB9KSk7XG5cdCAgICAgICAgICAgIH07XG5cdCAgICAgICAgLy8gTm8gYWRkaXRpb25hbCBub3JtYWxpemluZyByZXF1aXJlZDsgc2VyaWFsaXplIGlzIGVub3VnaFxuXHQgICAgICAgIGNhc2UgXCJnZXRCYWxhbmNlXCI6XG5cdCAgICAgICAgY2FzZSBcImdldFRyYW5zYWN0aW9uQ291bnRcIjpcblx0ICAgICAgICBjYXNlIFwiZ2V0Q29kZVwiOlxuXHQgICAgICAgIGNhc2UgXCJnZXRTdG9yYWdlQXRcIjpcblx0ICAgICAgICBjYXNlIFwiY2FsbFwiOlxuXHQgICAgICAgIGNhc2UgXCJlc3RpbWF0ZUdhc1wiOlxuXHQgICAgICAgIGNhc2UgXCJnZXRMb2dzXCI6XG5cdCAgICAgICAgICAgIGJyZWFrO1xuXHQgICAgICAgIC8vIFdlIGRyb3AgdGhlIGNvbmZpcm1hdGlvbnMgZnJvbSB0cmFuc2FjdGlvbnMgYXMgaXQgaXMgYXBwcm94aW1hdGVcblx0ICAgICAgICBjYXNlIFwiZ2V0VHJhbnNhY3Rpb25cIjpcblx0ICAgICAgICBjYXNlIFwiZ2V0VHJhbnNhY3Rpb25SZWNlaXB0XCI6XG5cdCAgICAgICAgICAgIG5vcm1hbGl6ZSA9IGZ1bmN0aW9uICh0eCkge1xuXHQgICAgICAgICAgICAgICAgaWYgKHR4ID09IG51bGwpIHtcblx0ICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgIHR4ID0gKDAsIGxpYiQzLnNoYWxsb3dDb3B5KSh0eCk7XG5cdCAgICAgICAgICAgICAgICB0eC5jb25maXJtYXRpb25zID0gLTE7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gc2VyaWFsaXplKHR4KTtcblx0ICAgICAgICAgICAgfTtcblx0ICAgICAgICAgICAgYnJlYWs7XG5cdCAgICAgICAgLy8gV2UgZHJvcCB0aGUgY29uZmlybWF0aW9ucyBmcm9tIHRyYW5zYWN0aW9ucyBhcyBpdCBpcyBhcHByb3hpbWF0ZVxuXHQgICAgICAgIGNhc2UgXCJnZXRCbG9ja1wiOlxuXHQgICAgICAgICAgICAvLyBXZSBkcm9wIHRoZSBjb25maXJtYXRpb25zIGZyb20gdHJhbnNhY3Rpb25zIGFzIGl0IGlzIGFwcHJveGltYXRlXG5cdCAgICAgICAgICAgIGlmIChwYXJhbXMuaW5jbHVkZVRyYW5zYWN0aW9ucykge1xuXHQgICAgICAgICAgICAgICAgbm9ybWFsaXplID0gZnVuY3Rpb24gKGJsb2NrKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKGJsb2NrID09IG51bGwpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG5cdCAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgIGJsb2NrID0gKDAsIGxpYiQzLnNoYWxsb3dDb3B5KShibG9jayk7XG5cdCAgICAgICAgICAgICAgICAgICAgYmxvY2sudHJhbnNhY3Rpb25zID0gYmxvY2sudHJhbnNhY3Rpb25zLm1hcChmdW5jdGlvbiAodHgpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdHggPSAoMCwgbGliJDMuc2hhbGxvd0NvcHkpKHR4KTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdHguY29uZmlybWF0aW9ucyA9IC0xO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHg7XG5cdCAgICAgICAgICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNlcmlhbGl6ZShibG9jayk7XG5cdCAgICAgICAgICAgICAgICB9O1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIGVsc2Uge1xuXHQgICAgICAgICAgICAgICAgbm9ybWFsaXplID0gZnVuY3Rpb24gKGJsb2NrKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKGJsb2NrID09IG51bGwpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG5cdCAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgIHJldHVybiBzZXJpYWxpemUoYmxvY2spO1xuXHQgICAgICAgICAgICAgICAgfTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICBicmVhaztcblx0ICAgICAgICBkZWZhdWx0OlxuXHQgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJ1bmtub3duIG1ldGhvZDogXCIgKyBtZXRob2QpO1xuXHQgICAgfVxuXHQgICAgLy8gUmV0dXJuIHRoZSByZXN1bHQgaWYgYW5kIG9ubHkgaWYgdGhlIGV4cGVjdGVkIHF1b3J1bSBpc1xuXHQgICAgLy8gc2F0aXNmaWVkIGFuZCBhZ3JlZWQgdXBvbiBmb3IgdGhlIGZpbmFsIHJlc3VsdC5cblx0ICAgIHJldHVybiBub3JtYWxpemVkVGFsbHkobm9ybWFsaXplLCBwcm92aWRlci5xdW9ydW0pO1xuXHR9XG5cdC8vIElmIHdlIGFyZSBkb2luZyBhIGJsb2NrVGFnIHF1ZXJ5LCB3ZSBuZWVkIHRvIG1ha2Ugc3VyZSB0aGUgYmFja2VuZCBpc1xuXHQvLyBjYXVnaHQgdXAgdG8gdGhlIEZhbGxiYWNrUHJvdmlkZXIsIGJlZm9yZSBzZW5kaW5nIGEgcmVxdWVzdCB0byBpdC5cblx0ZnVuY3Rpb24gd2FpdEZvclN5bmMoY29uZmlnLCBibG9ja051bWJlcikge1xuXHQgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIHZhciBwcm92aWRlcjtcblx0ICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG5cdCAgICAgICAgICAgIHByb3ZpZGVyID0gKGNvbmZpZy5wcm92aWRlcik7XG5cdCAgICAgICAgICAgIGlmICgocHJvdmlkZXIuYmxvY2tOdW1iZXIgIT0gbnVsbCAmJiBwcm92aWRlci5ibG9ja051bWJlciA+PSBibG9ja051bWJlcikgfHwgYmxvY2tOdW1iZXIgPT09IC0xKSB7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgcHJvdmlkZXJdO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCAoMCwgbGliJHEucG9sbCkoZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gV2UgYXJlIHN5bmNlZFxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHByb3ZpZGVyLmJsb2NrTnVtYmVyID49IGJsb2NrTnVtYmVyKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc29sdmUocHJvdmlkZXIpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gV2UncmUgZG9uZTsganVzdCBxdWl0XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoY29uZmlnLmNhbmNlbGxlZCkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZXNvbHZlKG51bGwpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gVHJ5IGFnYWluLCBuZXh0IGJsb2NrXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzb2x2ZSh1bmRlZmluZWQpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB9LCAwKTtcblx0ICAgICAgICAgICAgICAgICAgICB9KTtcblx0ICAgICAgICAgICAgICAgIH0sIHsgb25jZVBvbGw6IHByb3ZpZGVyIH0pXTtcblx0ICAgICAgICB9KTtcblx0ICAgIH0pO1xuXHR9XG5cdGZ1bmN0aW9uIGdldFJ1bm5lcihjb25maWcsIGN1cnJlbnRCbG9ja051bWJlciwgbWV0aG9kLCBwYXJhbXMpIHtcblx0ICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICB2YXIgcHJvdmlkZXIsIF9hLCBmaWx0ZXI7XG5cdCAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYikge1xuXHQgICAgICAgICAgICBzd2l0Y2ggKF9iLmxhYmVsKSB7XG5cdCAgICAgICAgICAgICAgICBjYXNlIDA6XG5cdCAgICAgICAgICAgICAgICAgICAgcHJvdmlkZXIgPSBjb25maWcucHJvdmlkZXI7XG5cdCAgICAgICAgICAgICAgICAgICAgX2EgPSBtZXRob2Q7XG5cdCAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChfYSkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwiZ2V0QmxvY2tOdW1iZXJcIjogcmV0dXJuIFszIC8qYnJlYWsqLywgMV07XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCJnZXRHYXNQcmljZVwiOiByZXR1cm4gWzMgLypicmVhayovLCAxXTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcImdldEV0aGVyUHJpY2VcIjogcmV0dXJuIFszIC8qYnJlYWsqLywgMl07XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCJnZXRCYWxhbmNlXCI6IHJldHVybiBbMyAvKmJyZWFrKi8sIDNdO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwiZ2V0VHJhbnNhY3Rpb25Db3VudFwiOiByZXR1cm4gWzMgLypicmVhayovLCAzXTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcImdldENvZGVcIjogcmV0dXJuIFszIC8qYnJlYWsqLywgM107XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCJnZXRTdG9yYWdlQXRcIjogcmV0dXJuIFszIC8qYnJlYWsqLywgNl07XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCJnZXRCbG9ja1wiOiByZXR1cm4gWzMgLypicmVhayovLCA5XTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcImNhbGxcIjogcmV0dXJuIFszIC8qYnJlYWsqLywgMTJdO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwiZXN0aW1hdGVHYXNcIjogcmV0dXJuIFszIC8qYnJlYWsqLywgMTJdO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwiZ2V0VHJhbnNhY3Rpb25cIjogcmV0dXJuIFszIC8qYnJlYWsqLywgMTVdO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwiZ2V0VHJhbnNhY3Rpb25SZWNlaXB0XCI6IHJldHVybiBbMyAvKmJyZWFrKi8sIDE1XTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcImdldExvZ3NcIjogcmV0dXJuIFszIC8qYnJlYWsqLywgMTZdO1xuXHQgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzMgLypicmVhayovLCAxOV07XG5cdCAgICAgICAgICAgICAgICBjYXNlIDE6IHJldHVybiBbMiAvKnJldHVybiovLCBwcm92aWRlclttZXRob2RdKCldO1xuXHQgICAgICAgICAgICAgICAgY2FzZSAyOlxuXHQgICAgICAgICAgICAgICAgICAgIGlmIChwcm92aWRlci5nZXRFdGhlclByaWNlKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCBwcm92aWRlci5nZXRFdGhlclByaWNlKCldO1xuXHQgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzMgLypicmVhayovLCAxOV07XG5cdCAgICAgICAgICAgICAgICBjYXNlIDM6XG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKCEocGFyYW1zLmJsb2NrVGFnICYmICgwLCBsaWIkMS5pc0hleFN0cmluZykocGFyYW1zLmJsb2NrVGFnKSkpIHJldHVybiBbMyAvKmJyZWFrKi8sIDVdO1xuXHQgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIHdhaXRGb3JTeW5jKGNvbmZpZywgY3VycmVudEJsb2NrTnVtYmVyKV07XG5cdCAgICAgICAgICAgICAgICBjYXNlIDQ6XG5cdCAgICAgICAgICAgICAgICAgICAgcHJvdmlkZXIgPSBfYi5zZW50KCk7XG5cdCAgICAgICAgICAgICAgICAgICAgX2IubGFiZWwgPSA1O1xuXHQgICAgICAgICAgICAgICAgY2FzZSA1OiByZXR1cm4gWzIgLypyZXR1cm4qLywgcHJvdmlkZXJbbWV0aG9kXShwYXJhbXMuYWRkcmVzcywgcGFyYW1zLmJsb2NrVGFnIHx8IFwibGF0ZXN0XCIpXTtcblx0ICAgICAgICAgICAgICAgIGNhc2UgNjpcblx0ICAgICAgICAgICAgICAgICAgICBpZiAoIShwYXJhbXMuYmxvY2tUYWcgJiYgKDAsIGxpYiQxLmlzSGV4U3RyaW5nKShwYXJhbXMuYmxvY2tUYWcpKSkgcmV0dXJuIFszIC8qYnJlYWsqLywgOF07XG5cdCAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgd2FpdEZvclN5bmMoY29uZmlnLCBjdXJyZW50QmxvY2tOdW1iZXIpXTtcblx0ICAgICAgICAgICAgICAgIGNhc2UgNzpcblx0ICAgICAgICAgICAgICAgICAgICBwcm92aWRlciA9IF9iLnNlbnQoKTtcblx0ICAgICAgICAgICAgICAgICAgICBfYi5sYWJlbCA9IDg7XG5cdCAgICAgICAgICAgICAgICBjYXNlIDg6IHJldHVybiBbMiAvKnJldHVybiovLCBwcm92aWRlci5nZXRTdG9yYWdlQXQocGFyYW1zLmFkZHJlc3MsIHBhcmFtcy5wb3NpdGlvbiwgcGFyYW1zLmJsb2NrVGFnIHx8IFwibGF0ZXN0XCIpXTtcblx0ICAgICAgICAgICAgICAgIGNhc2UgOTpcblx0ICAgICAgICAgICAgICAgICAgICBpZiAoIShwYXJhbXMuYmxvY2tUYWcgJiYgKDAsIGxpYiQxLmlzSGV4U3RyaW5nKShwYXJhbXMuYmxvY2tUYWcpKSkgcmV0dXJuIFszIC8qYnJlYWsqLywgMTFdO1xuXHQgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIHdhaXRGb3JTeW5jKGNvbmZpZywgY3VycmVudEJsb2NrTnVtYmVyKV07XG5cdCAgICAgICAgICAgICAgICBjYXNlIDEwOlxuXHQgICAgICAgICAgICAgICAgICAgIHByb3ZpZGVyID0gX2Iuc2VudCgpO1xuXHQgICAgICAgICAgICAgICAgICAgIF9iLmxhYmVsID0gMTE7XG5cdCAgICAgICAgICAgICAgICBjYXNlIDExOiByZXR1cm4gWzIgLypyZXR1cm4qLywgcHJvdmlkZXJbKHBhcmFtcy5pbmNsdWRlVHJhbnNhY3Rpb25zID8gXCJnZXRCbG9ja1dpdGhUcmFuc2FjdGlvbnNcIiA6IFwiZ2V0QmxvY2tcIildKHBhcmFtcy5ibG9ja1RhZyB8fCBwYXJhbXMuYmxvY2tIYXNoKV07XG5cdCAgICAgICAgICAgICAgICBjYXNlIDEyOlxuXHQgICAgICAgICAgICAgICAgICAgIGlmICghKHBhcmFtcy5ibG9ja1RhZyAmJiAoMCwgbGliJDEuaXNIZXhTdHJpbmcpKHBhcmFtcy5ibG9ja1RhZykpKSByZXR1cm4gWzMgLypicmVhayovLCAxNF07XG5cdCAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgd2FpdEZvclN5bmMoY29uZmlnLCBjdXJyZW50QmxvY2tOdW1iZXIpXTtcblx0ICAgICAgICAgICAgICAgIGNhc2UgMTM6XG5cdCAgICAgICAgICAgICAgICAgICAgcHJvdmlkZXIgPSBfYi5zZW50KCk7XG5cdCAgICAgICAgICAgICAgICAgICAgX2IubGFiZWwgPSAxNDtcblx0ICAgICAgICAgICAgICAgIGNhc2UgMTQ6IHJldHVybiBbMiAvKnJldHVybiovLCBwcm92aWRlclttZXRob2RdKHBhcmFtcy50cmFuc2FjdGlvbildO1xuXHQgICAgICAgICAgICAgICAgY2FzZSAxNTogcmV0dXJuIFsyIC8qcmV0dXJuKi8sIHByb3ZpZGVyW21ldGhvZF0ocGFyYW1zLnRyYW5zYWN0aW9uSGFzaCldO1xuXHQgICAgICAgICAgICAgICAgY2FzZSAxNjpcblx0ICAgICAgICAgICAgICAgICAgICBmaWx0ZXIgPSBwYXJhbXMuZmlsdGVyO1xuXHQgICAgICAgICAgICAgICAgICAgIGlmICghKChmaWx0ZXIuZnJvbUJsb2NrICYmICgwLCBsaWIkMS5pc0hleFN0cmluZykoZmlsdGVyLmZyb21CbG9jaykpIHx8IChmaWx0ZXIudG9CbG9jayAmJiAoMCwgbGliJDEuaXNIZXhTdHJpbmcpKGZpbHRlci50b0Jsb2NrKSkpKSByZXR1cm4gWzMgLypicmVhayovLCAxOF07XG5cdCAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgd2FpdEZvclN5bmMoY29uZmlnLCBjdXJyZW50QmxvY2tOdW1iZXIpXTtcblx0ICAgICAgICAgICAgICAgIGNhc2UgMTc6XG5cdCAgICAgICAgICAgICAgICAgICAgcHJvdmlkZXIgPSBfYi5zZW50KCk7XG5cdCAgICAgICAgICAgICAgICAgICAgX2IubGFiZWwgPSAxODtcblx0ICAgICAgICAgICAgICAgIGNhc2UgMTg6IHJldHVybiBbMiAvKnJldHVybiovLCBwcm92aWRlci5nZXRMb2dzKGZpbHRlcildO1xuXHQgICAgICAgICAgICAgICAgY2FzZSAxOTogcmV0dXJuIFsyIC8qcmV0dXJuKi8sIGxvZ2dlci50aHJvd0Vycm9yKFwidW5rbm93biBtZXRob2QgZXJyb3JcIiwgbGliLkxvZ2dlci5lcnJvcnMuVU5LTk9XTl9FUlJPUiwge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBtZXRob2Q6IG1ldGhvZCxcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcGFyYW1zOiBwYXJhbXNcblx0ICAgICAgICAgICAgICAgICAgICB9KV07XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9KTtcblx0ICAgIH0pO1xuXHR9XG5cdHZhciBGYWxsYmFja1Byb3ZpZGVyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuXHQgICAgX19leHRlbmRzKEZhbGxiYWNrUHJvdmlkZXIsIF9zdXBlcik7XG5cdCAgICBmdW5jdGlvbiBGYWxsYmFja1Byb3ZpZGVyKHByb3ZpZGVycywgcXVvcnVtKSB7XG5cdCAgICAgICAgdmFyIF9uZXdUYXJnZXQgPSB0aGlzLmNvbnN0cnVjdG9yO1xuXHQgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cdCAgICAgICAgbG9nZ2VyLmNoZWNrTmV3KF9uZXdUYXJnZXQsIEZhbGxiYWNrUHJvdmlkZXIpO1xuXHQgICAgICAgIGlmIChwcm92aWRlcnMubGVuZ3RoID09PSAwKSB7XG5cdCAgICAgICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJtaXNzaW5nIHByb3ZpZGVyc1wiLCBcInByb3ZpZGVyc1wiLCBwcm92aWRlcnMpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICB2YXIgcHJvdmlkZXJDb25maWdzID0gcHJvdmlkZXJzLm1hcChmdW5jdGlvbiAoY29uZmlnT3JQcm92aWRlciwgaW5kZXgpIHtcblx0ICAgICAgICAgICAgaWYgKGxpYiRiLlByb3ZpZGVyLmlzUHJvdmlkZXIoY29uZmlnT3JQcm92aWRlcikpIHtcblx0ICAgICAgICAgICAgICAgIHZhciBzdGFsbFRpbWVvdXQgPSAoMCwgZm9ybWF0dGVyLmlzQ29tbXVuaXR5UmVzb3VyY2UpKGNvbmZpZ09yUHJvdmlkZXIpID8gMjAwMCA6IDc1MDtcblx0ICAgICAgICAgICAgICAgIHZhciBwcmlvcml0eSA9IDE7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gT2JqZWN0LmZyZWV6ZSh7IHByb3ZpZGVyOiBjb25maWdPclByb3ZpZGVyLCB3ZWlnaHQ6IDEsIHN0YWxsVGltZW91dDogc3RhbGxUaW1lb3V0LCBwcmlvcml0eTogcHJpb3JpdHkgfSk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgdmFyIGNvbmZpZyA9ICgwLCBsaWIkMy5zaGFsbG93Q29weSkoY29uZmlnT3JQcm92aWRlcik7XG5cdCAgICAgICAgICAgIGlmIChjb25maWcucHJpb3JpdHkgPT0gbnVsbCkge1xuXHQgICAgICAgICAgICAgICAgY29uZmlnLnByaW9yaXR5ID0gMTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICBpZiAoY29uZmlnLnN0YWxsVGltZW91dCA9PSBudWxsKSB7XG5cdCAgICAgICAgICAgICAgICBjb25maWcuc3RhbGxUaW1lb3V0ID0gKDAsIGZvcm1hdHRlci5pc0NvbW11bml0eVJlc291cmNlKShjb25maWdPclByb3ZpZGVyKSA/IDIwMDAgOiA3NTA7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgaWYgKGNvbmZpZy53ZWlnaHQgPT0gbnVsbCkge1xuXHQgICAgICAgICAgICAgICAgY29uZmlnLndlaWdodCA9IDE7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgdmFyIHdlaWdodCA9IGNvbmZpZy53ZWlnaHQ7XG5cdCAgICAgICAgICAgIGlmICh3ZWlnaHQgJSAxIHx8IHdlaWdodCA+IDUxMiB8fCB3ZWlnaHQgPCAxKSB7XG5cdCAgICAgICAgICAgICAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwiaW52YWxpZCB3ZWlnaHQ7IG11c3QgYmUgaW50ZWdlciBpbiBbMSwgNTEyXVwiLCBcInByb3ZpZGVyc1tcIiArIGluZGV4ICsgXCJdLndlaWdodFwiLCB3ZWlnaHQpO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIHJldHVybiBPYmplY3QuZnJlZXplKGNvbmZpZyk7XG5cdCAgICAgICAgfSk7XG5cdCAgICAgICAgdmFyIHRvdGFsID0gcHJvdmlkZXJDb25maWdzLnJlZHVjZShmdW5jdGlvbiAoYWNjdW0sIGMpIHsgcmV0dXJuIChhY2N1bSArIGMud2VpZ2h0KTsgfSwgMCk7XG5cdCAgICAgICAgaWYgKHF1b3J1bSA9PSBudWxsKSB7XG5cdCAgICAgICAgICAgIHF1b3J1bSA9IHRvdGFsIC8gMjtcblx0ICAgICAgICB9XG5cdCAgICAgICAgZWxzZSBpZiAocXVvcnVtID4gdG90YWwpIHtcblx0ICAgICAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcInF1b3J1bSB3aWxsIGFsd2F5cyBmYWlsOyBsYXJnZXIgdGhhbiB0b3RhbCB3ZWlnaHRcIiwgXCJxdW9ydW1cIiwgcXVvcnVtKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgLy8gQXJlIGFsbCBwcm92aWRlcnMnIG5ldHdvcmtzIGFyZSBrbm93blxuXHQgICAgICAgIHZhciBuZXR3b3JrT3JSZWFkeSA9IGNoZWNrTmV0d29ya3MocHJvdmlkZXJDb25maWdzLm1hcChmdW5jdGlvbiAoYykgeyByZXR1cm4gKGMucHJvdmlkZXIpLm5ldHdvcms7IH0pKTtcblx0ICAgICAgICAvLyBOb3QgYWxsIG5ldHdvcmtzIGFyZSBrbm93bjsgd2UgbXVzdCBzdGFsbFxuXHQgICAgICAgIGlmIChuZXR3b3JrT3JSZWFkeSA9PSBudWxsKSB7XG5cdCAgICAgICAgICAgIG5ldHdvcmtPclJlYWR5ID0gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuXHQgICAgICAgICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgX3RoaXMuZGV0ZWN0TmV0d29yaygpLnRoZW4ocmVzb2x2ZSwgcmVqZWN0KTtcblx0ICAgICAgICAgICAgICAgIH0sIDApO1xuXHQgICAgICAgICAgICB9KTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBuZXR3b3JrT3JSZWFkeSkgfHwgdGhpcztcblx0ICAgICAgICAvLyBQcmVzZXJ2ZSBhIGNvcHksIHNvIHdlIGRvIG5vdCBnZXQgbXV0YXRlZFxuXHQgICAgICAgICgwLCBsaWIkMy5kZWZpbmVSZWFkT25seSkoX3RoaXMsIFwicHJvdmlkZXJDb25maWdzXCIsIE9iamVjdC5mcmVlemUocHJvdmlkZXJDb25maWdzKSk7XG5cdCAgICAgICAgKDAsIGxpYiQzLmRlZmluZVJlYWRPbmx5KShfdGhpcywgXCJxdW9ydW1cIiwgcXVvcnVtKTtcblx0ICAgICAgICBfdGhpcy5faGlnaGVzdEJsb2NrTnVtYmVyID0gLTE7XG5cdCAgICAgICAgcmV0dXJuIF90aGlzO1xuXHQgICAgfVxuXHQgICAgRmFsbGJhY2tQcm92aWRlci5wcm90b3R5cGUuZGV0ZWN0TmV0d29yayA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIHZhciBuZXR3b3Jrcztcblx0ICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuXHQgICAgICAgICAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkge1xuXHQgICAgICAgICAgICAgICAgICAgIGNhc2UgMDogcmV0dXJuIFs0IC8qeWllbGQqLywgUHJvbWlzZS5hbGwodGhpcy5wcm92aWRlckNvbmZpZ3MubWFwKGZ1bmN0aW9uIChjKSB7IHJldHVybiBjLnByb3ZpZGVyLmdldE5ldHdvcmsoKTsgfSkpXTtcblx0ICAgICAgICAgICAgICAgICAgICBjYXNlIDE6XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIG5ldHdvcmtzID0gX2Euc2VudCgpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgY2hlY2tOZXR3b3JrcyhuZXR3b3JrcyldO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB9KTtcblx0ICAgICAgICB9KTtcblx0ICAgIH07XG5cdCAgICBGYWxsYmFja1Byb3ZpZGVyLnByb3RvdHlwZS5wZXJmb3JtID0gZnVuY3Rpb24gKG1ldGhvZCwgcGFyYW1zKSB7XG5cdCAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICB2YXIgcmVzdWx0cywgaV8xLCByZXN1bHQsIHByb2Nlc3NGdW5jLCBjb25maWdzLCBjdXJyZW50QmxvY2tOdW1iZXIsIGksIGZpcnN0LCBfbG9vcF8xLCB0aGlzXzEsIHN0YXRlXzE7XG5cdCAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cdCAgICAgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcblx0ICAgICAgICAgICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcblx0ICAgICAgICAgICAgICAgICAgICBjYXNlIDA6XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGlmICghKG1ldGhvZCA9PT0gXCJzZW5kVHJhbnNhY3Rpb25cIikpIHJldHVybiBbMyAvKmJyZWFrKi8sIDJdO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCBQcm9taXNlLmFsbCh0aGlzLnByb3ZpZGVyQ29uZmlncy5tYXAoZnVuY3Rpb24gKGMpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gYy5wcm92aWRlci5zZW5kVHJhbnNhY3Rpb24ocGFyYW1zLnNpZ25lZFRyYW5zYWN0aW9uKS50aGVuKGZ1bmN0aW9uIChyZXN1bHQpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdC5oYXNoO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sIGZ1bmN0aW9uIChlcnJvcikge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZXJyb3I7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KSldO1xuXHQgICAgICAgICAgICAgICAgICAgIGNhc2UgMTpcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0cyA9IF9hLnNlbnQoKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgLy8gQW55IHN1Y2Nlc3MgaXMgZ29vZCBlbm91Z2ggKG90aGVyIGVycm9ycyBhcmUgbGlrZWx5IFwiYWxyZWFkeSBzZWVuXCIgZXJyb3JzXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoaV8xID0gMDsgaV8xIDwgcmVzdWx0cy5sZW5ndGg7IGlfMSsrKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSByZXN1bHRzW2lfMV07XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIChyZXN1bHQpID09PSBcInN0cmluZ1wiKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIHJlc3VsdF07XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICAgICAgLy8gVGhleSB3ZXJlIGFsbCBhbiBlcnJvcjsgcGljayB0aGUgZmlyc3QgZXJyb3Jcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgcmVzdWx0c1swXTtcblx0ICAgICAgICAgICAgICAgICAgICBjYXNlIDI6XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGlmICghKHRoaXMuX2hpZ2hlc3RCbG9ja051bWJlciA9PT0gLTEgJiYgbWV0aG9kICE9PSBcImdldEJsb2NrTnVtYmVyXCIpKSByZXR1cm4gWzMgLypicmVhayovLCA0XTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgdGhpcy5nZXRCbG9ja051bWJlcigpXTtcblx0ICAgICAgICAgICAgICAgICAgICBjYXNlIDM6XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIF9hLnNlbnQoKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgX2EubGFiZWwgPSA0O1xuXHQgICAgICAgICAgICAgICAgICAgIGNhc2UgNDpcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcHJvY2Vzc0Z1bmMgPSBnZXRQcm9jZXNzRnVuYyh0aGlzLCBtZXRob2QsIHBhcmFtcyk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGNvbmZpZ3MgPSAoMCwgbGliJGwuc2h1ZmZsZWQpKHRoaXMucHJvdmlkZXJDb25maWdzLm1hcChsaWIkMy5zaGFsbG93Q29weSkpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBjb25maWdzLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHsgcmV0dXJuIChhLnByaW9yaXR5IC0gYi5wcmlvcml0eSk7IH0pO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50QmxvY2tOdW1iZXIgPSB0aGlzLl9oaWdoZXN0QmxvY2tOdW1iZXI7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGkgPSAwO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBmaXJzdCA9IHRydWU7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIF9sb29wXzEgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgdDAsIGluZmxpZ2h0V2VpZ2h0LCBfbG9vcF8yLCB3YWl0aW5nLCByZXN1bHRzLCByZXN1bHQsIGVycm9ycztcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2IpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKF9iLmxhYmVsKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMDpcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHQwID0gbm93KCk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbmZsaWdodFdlaWdodCA9IGNvbmZpZ3MuZmlsdGVyKGZ1bmN0aW9uIChjKSB7IHJldHVybiAoYy5ydW5uZXIgJiYgKCh0MCAtIGMuc3RhcnQpIDwgYy5zdGFsbFRpbWVvdXQpKTsgfSlcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAucmVkdWNlKGZ1bmN0aW9uIChhY2N1bSwgYykgeyByZXR1cm4gKGFjY3VtICsgYy53ZWlnaHQpOyB9LCAwKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9sb29wXzIgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGNvbmZpZyA9IGNvbmZpZ3NbaSsrXTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcmlkID0gbmV4dFJpZCsrO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbmZpZy5zdGFydCA9IG5vdygpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbmZpZy5zdGFsbGVyID0gc3RhbGwoY29uZmlnLnN0YWxsVGltZW91dCk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uZmlnLnN0YWxsZXIud2FpdChmdW5jdGlvbiAoKSB7IGNvbmZpZy5zdGFsbGVyID0gbnVsbDsgfSk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uZmlnLnJ1bm5lciA9IGdldFJ1bm5lcihjb25maWcsIGN1cnJlbnRCbG9ja051bWJlciwgbWV0aG9kLCBwYXJhbXMpLnRoZW4oZnVuY3Rpb24gKHJlc3VsdCkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25maWcuZG9uZSA9IHRydWU7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbmZpZy5yZXN1bHQgPSByZXN1bHQ7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChfdGhpcy5saXN0ZW5lckNvdW50KFwiZGVidWdcIikpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLmVtaXQoXCJkZWJ1Z1wiLCB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYWN0aW9uOiBcInJlcXVlc3RcIixcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByaWQ6IHJpZCxcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBiYWNrZW5kOiBleHBvc2VEZWJ1Z0NvbmZpZyhjb25maWcsIG5vdygpKSxcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXF1ZXN0OiB7IG1ldGhvZDogbWV0aG9kLCBwYXJhbXM6ICgwLCBsaWIkMy5kZWVwQ29weSkocGFyYW1zKSB9LFxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByb3ZpZGVyOiBfdGhpc1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LCBmdW5jdGlvbiAoZXJyb3IpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uZmlnLmRvbmUgPSB0cnVlO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25maWcuZXJyb3IgPSBlcnJvcjtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKF90aGlzLmxpc3RlbmVyQ291bnQoXCJkZWJ1Z1wiKSkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuZW1pdChcImRlYnVnXCIsIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhY3Rpb246IFwicmVxdWVzdFwiLFxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJpZDogcmlkLFxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJhY2tlbmQ6IGV4cG9zZURlYnVnQ29uZmlnKGNvbmZpZywgbm93KCkpLFxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlcXVlc3Q6IHsgbWV0aG9kOiBtZXRob2QsIHBhcmFtczogKDAsIGxpYiQzLmRlZXBDb3B5KShwYXJhbXMpIH0sXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJvdmlkZXI6IF90aGlzXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzXzEubGlzdGVuZXJDb3VudChcImRlYnVnXCIpKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXNfMS5lbWl0KFwiZGVidWdcIiwge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYWN0aW9uOiBcInJlcXVlc3RcIixcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJpZDogcmlkLFxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYmFja2VuZDogZXhwb3NlRGVidWdDb25maWcoY29uZmlnLCBudWxsKSxcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlcXVlc3Q6IHsgbWV0aG9kOiBtZXRob2QsIHBhcmFtczogKDAsIGxpYiQzLmRlZXBDb3B5KShwYXJhbXMpIH0sXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcm92aWRlcjogdGhpc18xXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbmZsaWdodFdlaWdodCArPSBjb25maWcud2VpZ2h0O1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFN0YXJ0IHJ1bm5pbmcgZW5vdWdoIHRvIG1lZXQgcXVvcnVtXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aGlsZSAoaW5mbGlnaHRXZWlnaHQgPCB0aGlzXzEucXVvcnVtICYmIGkgPCBjb25maWdzLmxlbmd0aCkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9sb29wXzIoKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdhaXRpbmcgPSBbXTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbmZpZ3MuZm9yRWFjaChmdW5jdGlvbiAoYykge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjLmRvbmUgfHwgIWMucnVubmVyKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd2FpdGluZy5wdXNoKGMucnVubmVyKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoYy5zdGFsbGVyKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdhaXRpbmcucHVzaChjLnN0YWxsZXIuZ2V0UHJvbWlzZSgpKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghd2FpdGluZy5sZW5ndGgpIHJldHVybiBbMyAvKmJyZWFrKi8sIDJdO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgUHJvbWlzZS5yYWNlKHdhaXRpbmcpXTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAxOlxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX2Iuc2VudCgpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX2IubGFiZWwgPSAyO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDI6XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHRzID0gY29uZmlncy5maWx0ZXIoZnVuY3Rpb24gKGMpIHsgcmV0dXJuIChjLmRvbmUgJiYgYy5lcnJvciA9PSBudWxsKTsgfSk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIShyZXN1bHRzLmxlbmd0aCA+PSB0aGlzXzEucXVvcnVtKSkgcmV0dXJuIFszIC8qYnJlYWsqLywgNV07XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSBwcm9jZXNzRnVuYyhyZXN1bHRzKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyZXN1bHQgIT09IHVuZGVmaW5lZCkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFNodXQgZG93biBhbnkgc3RhbGxlcnNcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25maWdzLmZvckVhY2goZnVuY3Rpb24gKGMpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGMuc3RhbGxlcikge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYy5zdGFsbGVyLmNhbmNlbCgpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGMuY2FuY2VsbGVkID0gdHJ1ZTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgeyB2YWx1ZTogcmVzdWx0IH1dO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCEhZmlyc3QpIHJldHVybiBbMyAvKmJyZWFrKi8sIDRdO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgc3RhbGwoMTAwKS5nZXRQcm9taXNlKCldO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDM6XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfYi5zZW50KCk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfYi5sYWJlbCA9IDQ7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgNDpcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZpcnN0ID0gZmFsc2U7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfYi5sYWJlbCA9IDU7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgNTpcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVycm9ycyA9IGNvbmZpZ3MucmVkdWNlKGZ1bmN0aW9uIChhY2N1bSwgYykge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghYy5kb25lIHx8IGMuZXJyb3IgPT0gbnVsbCkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gYWNjdW07XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjb2RlID0gKGMuZXJyb3IpLmNvZGU7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKEZvcndhcmRFcnJvcnMuaW5kZXhPZihjb2RlKSA+PSAwKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghYWNjdW1bY29kZV0pIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFjY3VtW2NvZGVdID0geyBlcnJvcjogYy5lcnJvciwgd2VpZ2h0OiAwIH07XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYWNjdW1bY29kZV0ud2VpZ2h0ICs9IGMud2VpZ2h0O1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gYWNjdW07XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LCAoe30pKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE9iamVjdC5rZXlzKGVycm9ycykuZm9yRWFjaChmdW5jdGlvbiAoZXJyb3JDb2RlKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHRhbGx5ID0gZXJyb3JzW2Vycm9yQ29kZV07XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRhbGx5LndlaWdodCA8IF90aGlzLnF1b3J1bSkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFNodXQgZG93biBhbnkgc3RhbGxlcnNcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25maWdzLmZvckVhY2goZnVuY3Rpb24gKGMpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGMuc3RhbGxlcikge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYy5zdGFsbGVyLmNhbmNlbCgpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGMuY2FuY2VsbGVkID0gdHJ1ZTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZSA9ICh0YWxseS5lcnJvcik7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHByb3BzID0ge307XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgRm9yd2FyZFByb3BlcnRpZXMuZm9yRWFjaChmdW5jdGlvbiAobmFtZSkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZVtuYW1lXSA9PSBudWxsKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJvcHNbbmFtZV0gPSBlW25hbWVdO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxvZ2dlci50aHJvd0Vycm9yKGUucmVhc29uIHx8IGUubWVzc2FnZSwgZXJyb3JDb2RlLCBwcm9wcyk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEFsbCBjb25maWdzIGhhdmUgcnVuIHRvIGNvbXBsZXRpb247IHdlIHdpbGwgbmV2ZXIgZ2V0IG1vcmUgZGF0YVxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNvbmZpZ3MuZmlsdGVyKGZ1bmN0aW9uIChjKSB7IHJldHVybiAhYy5kb25lOyB9KS5sZW5ndGggPT09IDApIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgXCJicmVha1wiXTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovXTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdGhpc18xID0gdGhpcztcblx0ICAgICAgICAgICAgICAgICAgICAgICAgX2EubGFiZWwgPSA1O1xuXHQgICAgICAgICAgICAgICAgICAgIGNhc2UgNTpcblx0ICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCF0cnVlKSByZXR1cm4gWzMgLypicmVhayovLCA3XTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs1IC8qeWllbGQqKi8sIF9sb29wXzEoKV07XG5cdCAgICAgICAgICAgICAgICAgICAgY2FzZSA2OlxuXHQgICAgICAgICAgICAgICAgICAgICAgICBzdGF0ZV8xID0gX2Euc2VudCgpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHN0YXRlXzEgPT09IFwib2JqZWN0XCIpXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgc3RhdGVfMS52YWx1ZV07XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzdGF0ZV8xID09PSBcImJyZWFrXCIpXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzMgLypicmVhayovLCA3XTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFszIC8qYnJlYWsqLywgNV07XG5cdCAgICAgICAgICAgICAgICAgICAgY2FzZSA3OlxuXHQgICAgICAgICAgICAgICAgICAgICAgICAvLyBTaHV0IGRvd24gYW55IHN0YWxsZXJzOyBzaG91bGRuJ3QgYmUgYW55XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGNvbmZpZ3MuZm9yRWFjaChmdW5jdGlvbiAoYykge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGMuc3RhbGxlcikge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGMuc3RhbGxlci5jYW5jZWwoKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGMuY2FuY2VsbGVkID0gdHJ1ZTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCBsb2dnZXIudGhyb3dFcnJvcihcImZhaWxlZCB0byBtZWV0IHF1b3J1bVwiLCBsaWIuTG9nZ2VyLmVycm9ycy5TRVJWRVJfRVJST1IsIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXRob2Q6IG1ldGhvZCxcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXJhbXM6IHBhcmFtcyxcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL3Jlc3VsdHM6IGNvbmZpZ3MubWFwKChjKSA9PiBjLnJlc3VsdCksXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9lcnJvcnM6IGNvbmZpZ3MubWFwKChjKSA9PiBjLmVycm9yKSxcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHRzOiBjb25maWdzLm1hcChmdW5jdGlvbiAoYykgeyByZXR1cm4gZXhwb3NlRGVidWdDb25maWcoYyk7IH0pLFxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByb3ZpZGVyOiB0aGlzXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KV07XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIH0pO1xuXHQgICAgICAgIH0pO1xuXHQgICAgfTtcblx0ICAgIHJldHVybiBGYWxsYmFja1Byb3ZpZGVyO1xuXHR9KGJhc2VQcm92aWRlci5CYXNlUHJvdmlkZXIpKTtcblx0ZXhwb3J0cy5GYWxsYmFja1Byb3ZpZGVyID0gRmFsbGJhY2tQcm92aWRlcjtcblxuXHR9KTtcblxuXHR2YXIgZmFsbGJhY2tQcm92aWRlciQxID0gLypAX19QVVJFX18qL2dldERlZmF1bHRFeHBvcnRGcm9tQ2pzKGZhbGxiYWNrUHJvdmlkZXIpO1xuXG5cdHZhciBicm93c2VySXBjUHJvdmlkZXIgPSBjcmVhdGVDb21tb25qc01vZHVsZShmdW5jdGlvbiAobW9kdWxlLCBleHBvcnRzKSB7XG5cdFwidXNlIHN0cmljdFwiO1xuXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5cdGV4cG9ydHMuSXBjUHJvdmlkZXIgPSB2b2lkIDA7XG5cdHZhciBJcGNQcm92aWRlciA9IG51bGw7XG5cdGV4cG9ydHMuSXBjUHJvdmlkZXIgPSBJcGNQcm92aWRlcjtcblxuXHR9KTtcblxuXHR2YXIgYnJvd3NlcklwY1Byb3ZpZGVyJDEgPSAvKkBfX1BVUkVfXyovZ2V0RGVmYXVsdEV4cG9ydEZyb21DanMoYnJvd3NlcklwY1Byb3ZpZGVyKTtcblxuXHR2YXIgaW5mdXJhUHJvdmlkZXIgPSBjcmVhdGVDb21tb25qc01vZHVsZShmdW5jdGlvbiAobW9kdWxlLCBleHBvcnRzKSB7XG5cdFwidXNlIHN0cmljdFwiO1xuXHR2YXIgX19leHRlbmRzID0gKGNvbW1vbmpzR2xvYmFsICYmIGNvbW1vbmpzR2xvYmFsLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcblx0ICAgIHZhciBleHRlbmRTdGF0aWNzID0gZnVuY3Rpb24gKGQsIGIpIHtcblx0ICAgICAgICBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG5cdCAgICAgICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcblx0ICAgICAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGIsIHApKSBkW3BdID0gYltwXTsgfTtcblx0ICAgICAgICByZXR1cm4gZXh0ZW5kU3RhdGljcyhkLCBiKTtcblx0ICAgIH07XG5cdCAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcblx0ICAgICAgICBpZiAodHlwZW9mIGIgIT09IFwiZnVuY3Rpb25cIiAmJiBiICE9PSBudWxsKVxuXHQgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2xhc3MgZXh0ZW5kcyB2YWx1ZSBcIiArIFN0cmluZyhiKSArIFwiIGlzIG5vdCBhIGNvbnN0cnVjdG9yIG9yIG51bGxcIik7XG5cdCAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcblx0ICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cblx0ICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG5cdCAgICB9O1xuXHR9KSgpO1xuXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5cdGV4cG9ydHMuSW5mdXJhUHJvdmlkZXIgPSBleHBvcnRzLkluZnVyYVdlYlNvY2tldFByb3ZpZGVyID0gdm9pZCAwO1xuXG5cblxuXG5cblx0dmFyIGxvZ2dlciA9IG5ldyBsaWIuTG9nZ2VyKF92ZXJzaW9uJEkudmVyc2lvbik7XG5cblx0dmFyIGRlZmF1bHRQcm9qZWN0SWQgPSBcIjg0ODQyMDc4YjA5OTQ2NjM4YzAzMTU3ZjgzNDA1MjEzXCI7XG5cdHZhciBJbmZ1cmFXZWJTb2NrZXRQcm92aWRlciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcblx0ICAgIF9fZXh0ZW5kcyhJbmZ1cmFXZWJTb2NrZXRQcm92aWRlciwgX3N1cGVyKTtcblx0ICAgIGZ1bmN0aW9uIEluZnVyYVdlYlNvY2tldFByb3ZpZGVyKG5ldHdvcmssIGFwaUtleSkge1xuXHQgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cdCAgICAgICAgdmFyIHByb3ZpZGVyID0gbmV3IEluZnVyYVByb3ZpZGVyKG5ldHdvcmssIGFwaUtleSk7XG5cdCAgICAgICAgdmFyIGNvbm5lY3Rpb24gPSBwcm92aWRlci5jb25uZWN0aW9uO1xuXHQgICAgICAgIGlmIChjb25uZWN0aW9uLnBhc3N3b3JkKSB7XG5cdCAgICAgICAgICAgIGxvZ2dlci50aHJvd0Vycm9yKFwiSU5GVVJBIFdlYlNvY2tldCBwcm9qZWN0IHNlY3JldHMgdW5zdXBwb3J0ZWRcIiwgbGliLkxvZ2dlci5lcnJvcnMuVU5TVVBQT1JURURfT1BFUkFUSU9OLCB7XG5cdCAgICAgICAgICAgICAgICBvcGVyYXRpb246IFwiSW5mdXJhUHJvdmlkZXIuZ2V0V2ViU29ja2V0UHJvdmlkZXIoKVwiXG5cdCAgICAgICAgICAgIH0pO1xuXHQgICAgICAgIH1cblx0ICAgICAgICB2YXIgdXJsID0gY29ubmVjdGlvbi51cmwucmVwbGFjZSgvXmh0dHAvaSwgXCJ3c1wiKS5yZXBsYWNlKFwiL3YzL1wiLCBcIi93cy92My9cIik7XG5cdCAgICAgICAgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCB1cmwsIG5ldHdvcmspIHx8IHRoaXM7XG5cdCAgICAgICAgKDAsIGxpYiQzLmRlZmluZVJlYWRPbmx5KShfdGhpcywgXCJhcGlLZXlcIiwgcHJvdmlkZXIucHJvamVjdElkKTtcblx0ICAgICAgICAoMCwgbGliJDMuZGVmaW5lUmVhZE9ubHkpKF90aGlzLCBcInByb2plY3RJZFwiLCBwcm92aWRlci5wcm9qZWN0SWQpO1xuXHQgICAgICAgICgwLCBsaWIkMy5kZWZpbmVSZWFkT25seSkoX3RoaXMsIFwicHJvamVjdFNlY3JldFwiLCBwcm92aWRlci5wcm9qZWN0U2VjcmV0KTtcblx0ICAgICAgICByZXR1cm4gX3RoaXM7XG5cdCAgICB9XG5cdCAgICBJbmZ1cmFXZWJTb2NrZXRQcm92aWRlci5wcm90b3R5cGUuaXNDb21tdW5pdHlSZXNvdXJjZSA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICByZXR1cm4gKHRoaXMucHJvamVjdElkID09PSBkZWZhdWx0UHJvamVjdElkKTtcblx0ICAgIH07XG5cdCAgICByZXR1cm4gSW5mdXJhV2ViU29ja2V0UHJvdmlkZXI7XG5cdH0od2Vic29ja2V0UHJvdmlkZXIuV2ViU29ja2V0UHJvdmlkZXIpKTtcblx0ZXhwb3J0cy5JbmZ1cmFXZWJTb2NrZXRQcm92aWRlciA9IEluZnVyYVdlYlNvY2tldFByb3ZpZGVyO1xuXHR2YXIgSW5mdXJhUHJvdmlkZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG5cdCAgICBfX2V4dGVuZHMoSW5mdXJhUHJvdmlkZXIsIF9zdXBlcik7XG5cdCAgICBmdW5jdGlvbiBJbmZ1cmFQcm92aWRlcigpIHtcblx0ICAgICAgICByZXR1cm4gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG5cdCAgICB9XG5cdCAgICBJbmZ1cmFQcm92aWRlci5nZXRXZWJTb2NrZXRQcm92aWRlciA9IGZ1bmN0aW9uIChuZXR3b3JrLCBhcGlLZXkpIHtcblx0ICAgICAgICByZXR1cm4gbmV3IEluZnVyYVdlYlNvY2tldFByb3ZpZGVyKG5ldHdvcmssIGFwaUtleSk7XG5cdCAgICB9O1xuXHQgICAgSW5mdXJhUHJvdmlkZXIuZ2V0QXBpS2V5ID0gZnVuY3Rpb24gKGFwaUtleSkge1xuXHQgICAgICAgIHZhciBhcGlLZXlPYmogPSB7XG5cdCAgICAgICAgICAgIGFwaUtleTogZGVmYXVsdFByb2plY3RJZCxcblx0ICAgICAgICAgICAgcHJvamVjdElkOiBkZWZhdWx0UHJvamVjdElkLFxuXHQgICAgICAgICAgICBwcm9qZWN0U2VjcmV0OiBudWxsXG5cdCAgICAgICAgfTtcblx0ICAgICAgICBpZiAoYXBpS2V5ID09IG51bGwpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIGFwaUtleU9iajtcblx0ICAgICAgICB9XG5cdCAgICAgICAgaWYgKHR5cGVvZiAoYXBpS2V5KSA9PT0gXCJzdHJpbmdcIikge1xuXHQgICAgICAgICAgICBhcGlLZXlPYmoucHJvamVjdElkID0gYXBpS2V5O1xuXHQgICAgICAgIH1cblx0ICAgICAgICBlbHNlIGlmIChhcGlLZXkucHJvamVjdFNlY3JldCAhPSBudWxsKSB7XG5cdCAgICAgICAgICAgIGxvZ2dlci5hc3NlcnRBcmd1bWVudCgodHlwZW9mIChhcGlLZXkucHJvamVjdElkKSA9PT0gXCJzdHJpbmdcIiksIFwicHJvamVjdFNlY3JldCByZXF1aXJlcyBhIHByb2plY3RJZFwiLCBcInByb2plY3RJZFwiLCBhcGlLZXkucHJvamVjdElkKTtcblx0ICAgICAgICAgICAgbG9nZ2VyLmFzc2VydEFyZ3VtZW50KCh0eXBlb2YgKGFwaUtleS5wcm9qZWN0U2VjcmV0KSA9PT0gXCJzdHJpbmdcIiksIFwiaW52YWxpZCBwcm9qZWN0U2VjcmV0XCIsIFwicHJvamVjdFNlY3JldFwiLCBcIltSRURBQ1RFRF1cIik7XG5cdCAgICAgICAgICAgIGFwaUtleU9iai5wcm9qZWN0SWQgPSBhcGlLZXkucHJvamVjdElkO1xuXHQgICAgICAgICAgICBhcGlLZXlPYmoucHJvamVjdFNlY3JldCA9IGFwaUtleS5wcm9qZWN0U2VjcmV0O1xuXHQgICAgICAgIH1cblx0ICAgICAgICBlbHNlIGlmIChhcGlLZXkucHJvamVjdElkKSB7XG5cdCAgICAgICAgICAgIGFwaUtleU9iai5wcm9qZWN0SWQgPSBhcGlLZXkucHJvamVjdElkO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBhcGlLZXlPYmouYXBpS2V5ID0gYXBpS2V5T2JqLnByb2plY3RJZDtcblx0ICAgICAgICByZXR1cm4gYXBpS2V5T2JqO1xuXHQgICAgfTtcblx0ICAgIEluZnVyYVByb3ZpZGVyLmdldFVybCA9IGZ1bmN0aW9uIChuZXR3b3JrLCBhcGlLZXkpIHtcblx0ICAgICAgICB2YXIgaG9zdCA9IG51bGw7XG5cdCAgICAgICAgc3dpdGNoIChuZXR3b3JrID8gbmV0d29yay5uYW1lIDogXCJ1bmtub3duXCIpIHtcblx0ICAgICAgICAgICAgY2FzZSBcImhvbWVzdGVhZFwiOlxuXHQgICAgICAgICAgICAgICAgaG9zdCA9IFwibWFpbm5ldC5pbmZ1cmEuaW9cIjtcblx0ICAgICAgICAgICAgICAgIGJyZWFrO1xuXHQgICAgICAgICAgICBjYXNlIFwicm9wc3RlblwiOlxuXHQgICAgICAgICAgICAgICAgaG9zdCA9IFwicm9wc3Rlbi5pbmZ1cmEuaW9cIjtcblx0ICAgICAgICAgICAgICAgIGJyZWFrO1xuXHQgICAgICAgICAgICBjYXNlIFwicmlua2VieVwiOlxuXHQgICAgICAgICAgICAgICAgaG9zdCA9IFwicmlua2VieS5pbmZ1cmEuaW9cIjtcblx0ICAgICAgICAgICAgICAgIGJyZWFrO1xuXHQgICAgICAgICAgICBjYXNlIFwia292YW5cIjpcblx0ICAgICAgICAgICAgICAgIGhvc3QgPSBcImtvdmFuLmluZnVyYS5pb1wiO1xuXHQgICAgICAgICAgICAgICAgYnJlYWs7XG5cdCAgICAgICAgICAgIGNhc2UgXCJnb2VybGlcIjpcblx0ICAgICAgICAgICAgICAgIGhvc3QgPSBcImdvZXJsaS5pbmZ1cmEuaW9cIjtcblx0ICAgICAgICAgICAgICAgIGJyZWFrO1xuXHQgICAgICAgICAgICBjYXNlIFwibWF0aWNcIjpcblx0ICAgICAgICAgICAgICAgIGhvc3QgPSBcInBvbHlnb24tbWFpbm5ldC5pbmZ1cmEuaW9cIjtcblx0ICAgICAgICAgICAgICAgIGJyZWFrO1xuXHQgICAgICAgICAgICBjYXNlIFwibWF0aWNtdW1cIjpcblx0ICAgICAgICAgICAgICAgIGhvc3QgPSBcInBvbHlnb24tbXVtYmFpLmluZnVyYS5pb1wiO1xuXHQgICAgICAgICAgICAgICAgYnJlYWs7XG5cdCAgICAgICAgICAgIGRlZmF1bHQ6XG5cdCAgICAgICAgICAgICAgICBsb2dnZXIudGhyb3dFcnJvcihcInVuc3VwcG9ydGVkIG5ldHdvcmtcIiwgbGliLkxvZ2dlci5lcnJvcnMuSU5WQUxJRF9BUkdVTUVOVCwge1xuXHQgICAgICAgICAgICAgICAgICAgIGFyZ3VtZW50OiBcIm5ldHdvcmtcIixcblx0ICAgICAgICAgICAgICAgICAgICB2YWx1ZTogbmV0d29ya1xuXHQgICAgICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHZhciBjb25uZWN0aW9uID0ge1xuXHQgICAgICAgICAgICBhbGxvd0d6aXA6IHRydWUsXG5cdCAgICAgICAgICAgIHVybDogKFwiaHR0cHM6L1wiICsgXCIvXCIgKyBob3N0ICsgXCIvdjMvXCIgKyBhcGlLZXkucHJvamVjdElkKSxcblx0ICAgICAgICAgICAgdGhyb3R0bGVDYWxsYmFjazogZnVuY3Rpb24gKGF0dGVtcHQsIHVybCkge1xuXHQgICAgICAgICAgICAgICAgaWYgKGFwaUtleS5wcm9qZWN0SWQgPT09IGRlZmF1bHRQcm9qZWN0SWQpIHtcblx0ICAgICAgICAgICAgICAgICAgICAoMCwgZm9ybWF0dGVyLnNob3dUaHJvdHRsZU1lc3NhZ2UpKCk7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHRydWUpO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfTtcblx0ICAgICAgICBpZiAoYXBpS2V5LnByb2plY3RTZWNyZXQgIT0gbnVsbCkge1xuXHQgICAgICAgICAgICBjb25uZWN0aW9uLnVzZXIgPSBcIlwiO1xuXHQgICAgICAgICAgICBjb25uZWN0aW9uLnBhc3N3b3JkID0gYXBpS2V5LnByb2plY3RTZWNyZXQ7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHJldHVybiBjb25uZWN0aW9uO1xuXHQgICAgfTtcblx0ICAgIEluZnVyYVByb3ZpZGVyLnByb3RvdHlwZS5pc0NvbW11bml0eVJlc291cmNlID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIHJldHVybiAodGhpcy5wcm9qZWN0SWQgPT09IGRlZmF1bHRQcm9qZWN0SWQpO1xuXHQgICAgfTtcblx0ICAgIHJldHVybiBJbmZ1cmFQcm92aWRlcjtcblx0fSh1cmxKc29uUnBjUHJvdmlkZXIuVXJsSnNvblJwY1Byb3ZpZGVyKSk7XG5cdGV4cG9ydHMuSW5mdXJhUHJvdmlkZXIgPSBJbmZ1cmFQcm92aWRlcjtcblxuXHR9KTtcblxuXHR2YXIgaW5mdXJhUHJvdmlkZXIkMSA9IC8qQF9fUFVSRV9fKi9nZXREZWZhdWx0RXhwb3J0RnJvbUNqcyhpbmZ1cmFQcm92aWRlcik7XG5cblx0dmFyIGpzb25ScGNCYXRjaFByb3ZpZGVyID0gY3JlYXRlQ29tbW9uanNNb2R1bGUoZnVuY3Rpb24gKG1vZHVsZSwgZXhwb3J0cykge1xuXHRcInVzZSBzdHJpY3RcIjtcblx0dmFyIF9fZXh0ZW5kcyA9IChjb21tb25qc0dsb2JhbCAmJiBjb21tb25qc0dsb2JhbC5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG5cdCAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IGZ1bmN0aW9uIChkLCBiKSB7XG5cdCAgICAgICAgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuXHQgICAgICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG5cdCAgICAgICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChiLCBwKSkgZFtwXSA9IGJbcF07IH07XG5cdCAgICAgICAgcmV0dXJuIGV4dGVuZFN0YXRpY3MoZCwgYik7XG5cdCAgICB9O1xuXHQgICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG5cdCAgICAgICAgaWYgKHR5cGVvZiBiICE9PSBcImZ1bmN0aW9uXCIgJiYgYiAhPT0gbnVsbClcblx0ICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNsYXNzIGV4dGVuZHMgdmFsdWUgXCIgKyBTdHJpbmcoYikgKyBcIiBpcyBub3QgYSBjb25zdHJ1Y3RvciBvciBudWxsXCIpO1xuXHQgICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG5cdCAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG5cdCAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuXHQgICAgfTtcblx0fSkoKTtcblx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuXHRleHBvcnRzLkpzb25ScGNCYXRjaFByb3ZpZGVyID0gdm9pZCAwO1xuXG5cblxuXHQvLyBFeHBlcmltZW50YWxcblx0dmFyIEpzb25ScGNCYXRjaFByb3ZpZGVyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuXHQgICAgX19leHRlbmRzKEpzb25ScGNCYXRjaFByb3ZpZGVyLCBfc3VwZXIpO1xuXHQgICAgZnVuY3Rpb24gSnNvblJwY0JhdGNoUHJvdmlkZXIoKSB7XG5cdCAgICAgICAgcmV0dXJuIF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuXHQgICAgfVxuXHQgICAgSnNvblJwY0JhdGNoUHJvdmlkZXIucHJvdG90eXBlLnNlbmQgPSBmdW5jdGlvbiAobWV0aG9kLCBwYXJhbXMpIHtcblx0ICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXHQgICAgICAgIHZhciByZXF1ZXN0ID0ge1xuXHQgICAgICAgICAgICBtZXRob2Q6IG1ldGhvZCxcblx0ICAgICAgICAgICAgcGFyYW1zOiBwYXJhbXMsXG5cdCAgICAgICAgICAgIGlkOiAodGhpcy5fbmV4dElkKyspLFxuXHQgICAgICAgICAgICBqc29ucnBjOiBcIjIuMFwiXG5cdCAgICAgICAgfTtcblx0ICAgICAgICBpZiAodGhpcy5fcGVuZGluZ0JhdGNoID09IG51bGwpIHtcblx0ICAgICAgICAgICAgdGhpcy5fcGVuZGluZ0JhdGNoID0gW107XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHZhciBpbmZsaWdodFJlcXVlc3QgPSB7IHJlcXVlc3Q6IHJlcXVlc3QsIHJlc29sdmU6IG51bGwsIHJlamVjdDogbnVsbCB9O1xuXHQgICAgICAgIHZhciBwcm9taXNlID0gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuXHQgICAgICAgICAgICBpbmZsaWdodFJlcXVlc3QucmVzb2x2ZSA9IHJlc29sdmU7XG5cdCAgICAgICAgICAgIGluZmxpZ2h0UmVxdWVzdC5yZWplY3QgPSByZWplY3Q7XG5cdCAgICAgICAgfSk7XG5cdCAgICAgICAgdGhpcy5fcGVuZGluZ0JhdGNoLnB1c2goaW5mbGlnaHRSZXF1ZXN0KTtcblx0ICAgICAgICBpZiAoIXRoaXMuX3BlbmRpbmdCYXRjaEFnZ3JlZ2F0b3IpIHtcblx0ICAgICAgICAgICAgLy8gU2NoZWR1bGUgYmF0Y2ggZm9yIG5leHQgZXZlbnQgbG9vcCArIHNob3J0IGR1cmF0aW9uXG5cdCAgICAgICAgICAgIHRoaXMuX3BlbmRpbmdCYXRjaEFnZ3JlZ2F0b3IgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgICAgIC8vIEdldCB0ZWggY3VycmVudCBiYXRjaCBhbmQgY2xlYXIgaXQsIHNvIG5ldyByZXF1ZXN0c1xuXHQgICAgICAgICAgICAgICAgLy8gZ28gaW50byB0aGUgbmV4dCBiYXRjaFxuXHQgICAgICAgICAgICAgICAgdmFyIGJhdGNoID0gX3RoaXMuX3BlbmRpbmdCYXRjaDtcblx0ICAgICAgICAgICAgICAgIF90aGlzLl9wZW5kaW5nQmF0Y2ggPSBudWxsO1xuXHQgICAgICAgICAgICAgICAgX3RoaXMuX3BlbmRpbmdCYXRjaEFnZ3JlZ2F0b3IgPSBudWxsO1xuXHQgICAgICAgICAgICAgICAgLy8gR2V0IHRoZSByZXF1ZXN0IGFzIGFuIGFycmF5IG9mIHJlcXVlc3RzXG5cdCAgICAgICAgICAgICAgICB2YXIgcmVxdWVzdCA9IGJhdGNoLm1hcChmdW5jdGlvbiAoaW5mbGlnaHQpIHsgcmV0dXJuIGluZmxpZ2h0LnJlcXVlc3Q7IH0pO1xuXHQgICAgICAgICAgICAgICAgX3RoaXMuZW1pdChcImRlYnVnXCIsIHtcblx0ICAgICAgICAgICAgICAgICAgICBhY3Rpb246IFwicmVxdWVzdEJhdGNoXCIsXG5cdCAgICAgICAgICAgICAgICAgICAgcmVxdWVzdDogKDAsIGxpYiQzLmRlZXBDb3B5KShyZXF1ZXN0KSxcblx0ICAgICAgICAgICAgICAgICAgICBwcm92aWRlcjogX3RoaXNcblx0ICAgICAgICAgICAgICAgIH0pO1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuICgwLCBsaWIkcS5mZXRjaEpzb24pKF90aGlzLmNvbm5lY3Rpb24sIEpTT04uc3RyaW5naWZ5KHJlcXVlc3QpKS50aGVuKGZ1bmN0aW9uIChyZXN1bHQpIHtcblx0ICAgICAgICAgICAgICAgICAgICBfdGhpcy5lbWl0KFwiZGVidWdcIiwge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBhY3Rpb246IFwicmVzcG9uc2VcIixcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcmVxdWVzdDogcmVxdWVzdCxcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2U6IHJlc3VsdCxcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcHJvdmlkZXI6IF90aGlzXG5cdCAgICAgICAgICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgICAgICAgICAgICAgLy8gRm9yIGVhY2ggcmVzdWx0LCBmZWVkIGl0IHRvIHRoZSBjb3JyZWN0IFByb21pc2UsIGRlcGVuZGluZ1xuXHQgICAgICAgICAgICAgICAgICAgIC8vIG9uIHdoZXRoZXIgaXQgd2FzIGEgc3VjY2VzcyBvciBlcnJvclxuXHQgICAgICAgICAgICAgICAgICAgIGJhdGNoLmZvckVhY2goZnVuY3Rpb24gKGluZmxpZ2h0UmVxdWVzdCwgaW5kZXgpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHBheWxvYWQgPSByZXN1bHRbaW5kZXhdO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBpZiAocGF5bG9hZC5lcnJvcikge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGVycm9yID0gbmV3IEVycm9yKHBheWxvYWQuZXJyb3IubWVzc2FnZSk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBlcnJvci5jb2RlID0gcGF5bG9hZC5lcnJvci5jb2RlO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3IuZGF0YSA9IHBheWxvYWQuZXJyb3IuZGF0YTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluZmxpZ2h0UmVxdWVzdC5yZWplY3QoZXJyb3IpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5mbGlnaHRSZXF1ZXN0LnJlc29sdmUocGF5bG9hZC5yZXN1bHQpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgICAgICAgICB9LCBmdW5jdGlvbiAoZXJyb3IpIHtcblx0ICAgICAgICAgICAgICAgICAgICBfdGhpcy5lbWl0KFwiZGVidWdcIiwge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBhY3Rpb246IFwicmVzcG9uc2VcIixcblx0ICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3I6IGVycm9yLFxuXHQgICAgICAgICAgICAgICAgICAgICAgICByZXF1ZXN0OiByZXF1ZXN0LFxuXHQgICAgICAgICAgICAgICAgICAgICAgICBwcm92aWRlcjogX3RoaXNcblx0ICAgICAgICAgICAgICAgICAgICB9KTtcblx0ICAgICAgICAgICAgICAgICAgICBiYXRjaC5mb3JFYWNoKGZ1bmN0aW9uIChpbmZsaWdodFJlcXVlc3QpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgaW5mbGlnaHRSZXF1ZXN0LnJlamVjdChlcnJvcik7XG5cdCAgICAgICAgICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgICAgICAgICB9KTtcblx0ICAgICAgICAgICAgfSwgMTApO1xuXHQgICAgICAgIH1cblx0ICAgICAgICByZXR1cm4gcHJvbWlzZTtcblx0ICAgIH07XG5cdCAgICByZXR1cm4gSnNvblJwY0JhdGNoUHJvdmlkZXI7XG5cdH0oanNvblJwY1Byb3ZpZGVyLkpzb25ScGNQcm92aWRlcikpO1xuXHRleHBvcnRzLkpzb25ScGNCYXRjaFByb3ZpZGVyID0gSnNvblJwY0JhdGNoUHJvdmlkZXI7XG5cblx0fSk7XG5cblx0dmFyIGpzb25ScGNCYXRjaFByb3ZpZGVyJDEgPSAvKkBfX1BVUkVfXyovZ2V0RGVmYXVsdEV4cG9ydEZyb21DanMoanNvblJwY0JhdGNoUHJvdmlkZXIpO1xuXG5cdHZhciBub2Rlc21pdGhQcm92aWRlciA9IGNyZWF0ZUNvbW1vbmpzTW9kdWxlKGZ1bmN0aW9uIChtb2R1bGUsIGV4cG9ydHMpIHtcblx0LyogaXN0YW5idWwgaWdub3JlIGZpbGUgKi9cblx0XCJ1c2Ugc3RyaWN0XCI7XG5cdHZhciBfX2V4dGVuZHMgPSAoY29tbW9uanNHbG9iYWwgJiYgY29tbW9uanNHbG9iYWwuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuXHQgICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBmdW5jdGlvbiAoZCwgYikge1xuXHQgICAgICAgIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcblx0ICAgICAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuXHQgICAgICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoYiwgcCkpIGRbcF0gPSBiW3BdOyB9O1xuXHQgICAgICAgIHJldHVybiBleHRlbmRTdGF0aWNzKGQsIGIpO1xuXHQgICAgfTtcblx0ICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuXHQgICAgICAgIGlmICh0eXBlb2YgYiAhPT0gXCJmdW5jdGlvblwiICYmIGIgIT09IG51bGwpXG5cdCAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDbGFzcyBleHRlbmRzIHZhbHVlIFwiICsgU3RyaW5nKGIpICsgXCIgaXMgbm90IGEgY29uc3RydWN0b3Igb3IgbnVsbFwiKTtcblx0ICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuXHQgICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuXHQgICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcblx0ICAgIH07XG5cdH0pKCk7XG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcblx0ZXhwb3J0cy5Ob2Rlc21pdGhQcm92aWRlciA9IHZvaWQgMDtcblxuXG5cblx0dmFyIGxvZ2dlciA9IG5ldyBsaWIuTG9nZ2VyKF92ZXJzaW9uJEkudmVyc2lvbik7XG5cdC8vIFNwZWNpYWwgQVBJIGtleSBwcm92aWRlZCBieSBOb2Rlc21pdGggZm9yIGV0aGVycy5qc1xuXHR2YXIgZGVmYXVsdEFwaUtleSA9IFwiRVRIRVJTX0pTX1NIQVJFRFwiO1xuXHR2YXIgTm9kZXNtaXRoUHJvdmlkZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG5cdCAgICBfX2V4dGVuZHMoTm9kZXNtaXRoUHJvdmlkZXIsIF9zdXBlcik7XG5cdCAgICBmdW5jdGlvbiBOb2Rlc21pdGhQcm92aWRlcigpIHtcblx0ICAgICAgICByZXR1cm4gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG5cdCAgICB9XG5cdCAgICBOb2Rlc21pdGhQcm92aWRlci5nZXRBcGlLZXkgPSBmdW5jdGlvbiAoYXBpS2V5KSB7XG5cdCAgICAgICAgaWYgKGFwaUtleSAmJiB0eXBlb2YgKGFwaUtleSkgIT09IFwic3RyaW5nXCIpIHtcblx0ICAgICAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcImludmFsaWQgYXBpS2V5XCIsIFwiYXBpS2V5XCIsIGFwaUtleSk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHJldHVybiBhcGlLZXkgfHwgZGVmYXVsdEFwaUtleTtcblx0ICAgIH07XG5cdCAgICBOb2Rlc21pdGhQcm92aWRlci5nZXRVcmwgPSBmdW5jdGlvbiAobmV0d29yaywgYXBpS2V5KSB7XG5cdCAgICAgICAgbG9nZ2VyLndhcm4oXCJOb2RlU21pdGggd2lsbCBiZSBkaXNjb250aW51ZWQgb24gMjAxOS0xMi0yMDsgcGxlYXNlIG1pZ3JhdGUgdG8gYW5vdGhlciBwbGF0Zm9ybS5cIik7XG5cdCAgICAgICAgdmFyIGhvc3QgPSBudWxsO1xuXHQgICAgICAgIHN3aXRjaCAobmV0d29yay5uYW1lKSB7XG5cdCAgICAgICAgICAgIGNhc2UgXCJob21lc3RlYWRcIjpcblx0ICAgICAgICAgICAgICAgIGhvc3QgPSBcImh0dHBzOi8vZXRoZXJldW0uYXBpLm5vZGVzbWl0aC5pby92MS9tYWlubmV0L2pzb25ycGNcIjtcblx0ICAgICAgICAgICAgICAgIGJyZWFrO1xuXHQgICAgICAgICAgICBjYXNlIFwicm9wc3RlblwiOlxuXHQgICAgICAgICAgICAgICAgaG9zdCA9IFwiaHR0cHM6Ly9ldGhlcmV1bS5hcGkubm9kZXNtaXRoLmlvL3YxL3JvcHN0ZW4vanNvbnJwY1wiO1xuXHQgICAgICAgICAgICAgICAgYnJlYWs7XG5cdCAgICAgICAgICAgIGNhc2UgXCJyaW5rZWJ5XCI6XG5cdCAgICAgICAgICAgICAgICBob3N0ID0gXCJodHRwczovL2V0aGVyZXVtLmFwaS5ub2Rlc21pdGguaW8vdjEvcmlua2VieS9qc29ucnBjXCI7XG5cdCAgICAgICAgICAgICAgICBicmVhaztcblx0ICAgICAgICAgICAgY2FzZSBcImdvZXJsaVwiOlxuXHQgICAgICAgICAgICAgICAgaG9zdCA9IFwiaHR0cHM6Ly9ldGhlcmV1bS5hcGkubm9kZXNtaXRoLmlvL3YxL2dvZXJsaS9qc29ucnBjXCI7XG5cdCAgICAgICAgICAgICAgICBicmVhaztcblx0ICAgICAgICAgICAgY2FzZSBcImtvdmFuXCI6XG5cdCAgICAgICAgICAgICAgICBob3N0ID0gXCJodHRwczovL2V0aGVyZXVtLmFwaS5ub2Rlc21pdGguaW8vdjEva292YW4vanNvbnJwY1wiO1xuXHQgICAgICAgICAgICAgICAgYnJlYWs7XG5cdCAgICAgICAgICAgIGRlZmF1bHQ6XG5cdCAgICAgICAgICAgICAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwidW5zdXBwb3J0ZWQgbmV0d29ya1wiLCBcIm5ldHdvcmtcIiwgYXJndW1lbnRzWzBdKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgcmV0dXJuIChob3N0ICsgXCI/YXBpS2V5PVwiICsgYXBpS2V5KTtcblx0ICAgIH07XG5cdCAgICByZXR1cm4gTm9kZXNtaXRoUHJvdmlkZXI7XG5cdH0odXJsSnNvblJwY1Byb3ZpZGVyLlVybEpzb25ScGNQcm92aWRlcikpO1xuXHRleHBvcnRzLk5vZGVzbWl0aFByb3ZpZGVyID0gTm9kZXNtaXRoUHJvdmlkZXI7XG5cblx0fSk7XG5cblx0dmFyIG5vZGVzbWl0aFByb3ZpZGVyJDEgPSAvKkBfX1BVUkVfXyovZ2V0RGVmYXVsdEV4cG9ydEZyb21DanMobm9kZXNtaXRoUHJvdmlkZXIpO1xuXG5cdHZhciBwb2NrZXRQcm92aWRlciA9IGNyZWF0ZUNvbW1vbmpzTW9kdWxlKGZ1bmN0aW9uIChtb2R1bGUsIGV4cG9ydHMpIHtcblx0XCJ1c2Ugc3RyaWN0XCI7XG5cdHZhciBfX2V4dGVuZHMgPSAoY29tbW9uanNHbG9iYWwgJiYgY29tbW9uanNHbG9iYWwuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuXHQgICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBmdW5jdGlvbiAoZCwgYikge1xuXHQgICAgICAgIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcblx0ICAgICAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuXHQgICAgICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoYiwgcCkpIGRbcF0gPSBiW3BdOyB9O1xuXHQgICAgICAgIHJldHVybiBleHRlbmRTdGF0aWNzKGQsIGIpO1xuXHQgICAgfTtcblx0ICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuXHQgICAgICAgIGlmICh0eXBlb2YgYiAhPT0gXCJmdW5jdGlvblwiICYmIGIgIT09IG51bGwpXG5cdCAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDbGFzcyBleHRlbmRzIHZhbHVlIFwiICsgU3RyaW5nKGIpICsgXCIgaXMgbm90IGEgY29uc3RydWN0b3Igb3IgbnVsbFwiKTtcblx0ICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuXHQgICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuXHQgICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcblx0ICAgIH07XG5cdH0pKCk7XG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcblx0ZXhwb3J0cy5Qb2NrZXRQcm92aWRlciA9IHZvaWQgMDtcblxuXG5cblx0dmFyIGxvZ2dlciA9IG5ldyBsaWIuTG9nZ2VyKF92ZXJzaW9uJEkudmVyc2lvbik7XG5cblx0Ly8gVGhlc2UgYXJlIGxvYWQtYmFsYW5jZXItYmFzZWQgYXBwbGljYXRpb24gSURzXG5cdHZhciBkZWZhdWx0QXBwbGljYXRpb25JZHMgPSB7XG5cdCAgICBob21lc3RlYWQ6IFwiNjAwNGJjZDEwMDQwMjYxNjMzYWRlOTkwXCIsXG5cdCAgICByb3BzdGVuOiBcIjYwMDRiZDRkMDA0MDI2MTYzM2FkZTk5MVwiLFxuXHQgICAgcmlua2VieTogXCI2MDA0YmRhMjAwNDAyNjE2MzNhZGU5OTRcIixcblx0ICAgIGdvZXJsaTogXCI2MDA0YmQ4NjAwNDAyNjE2MzNhZGU5OTJcIixcblx0fTtcblx0dmFyIFBvY2tldFByb3ZpZGVyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuXHQgICAgX19leHRlbmRzKFBvY2tldFByb3ZpZGVyLCBfc3VwZXIpO1xuXHQgICAgZnVuY3Rpb24gUG9ja2V0UHJvdmlkZXIobmV0d29yaywgYXBpS2V5KSB7XG5cdCAgICAgICAgLy8gV2UgbmVlZCBhIGJpdCBvZiBjcmVhdGl2aXR5IGluIHRoZSBjb25zdHJ1Y3RvciBiZWNhdXNlXG5cdCAgICAgICAgLy8gUG9ja2V0IHVzZXMgZGlmZmVyZW50IGRlZmF1bHQgQVBJIGtleXMgYmFzZWQgb24gdGhlIG5ldHdvcmtcblx0ICAgICAgICB2YXIgX25ld1RhcmdldCA9IHRoaXMuY29uc3RydWN0b3I7XG5cdCAgICAgICAgdmFyIF90aGlzID0gdGhpcztcblx0ICAgICAgICBpZiAoYXBpS2V5ID09IG51bGwpIHtcblx0ICAgICAgICAgICAgdmFyIG4gPSAoMCwgbGliJDMuZ2V0U3RhdGljKShfbmV3VGFyZ2V0LCBcImdldE5ldHdvcmtcIikobmV0d29yayk7XG5cdCAgICAgICAgICAgIGlmIChuKSB7XG5cdCAgICAgICAgICAgICAgICB2YXIgYXBwbGljYXRpb25JZCA9IGRlZmF1bHRBcHBsaWNhdGlvbklkc1tuLm5hbWVdO1xuXHQgICAgICAgICAgICAgICAgaWYgKGFwcGxpY2F0aW9uSWQpIHtcblx0ICAgICAgICAgICAgICAgICAgICBhcGlLZXkgPSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGFwcGxpY2F0aW9uSWQ6IGFwcGxpY2F0aW9uSWQsXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGxvYWRCYWxhbmNlcjogdHJ1ZVxuXHQgICAgICAgICAgICAgICAgICAgIH07XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgLy8gSWYgdGhlcmUgd2FzIGFueSBpc3N1ZSBhYm92ZSwgd2UgZG9uJ3Qga25vdyB0aGlzIG5ldHdvcmtcblx0ICAgICAgICAgICAgaWYgKGFwaUtleSA9PSBudWxsKSB7XG5cdCAgICAgICAgICAgICAgICBsb2dnZXIudGhyb3dFcnJvcihcInVuc3VwcG9ydGVkIG5ldHdvcmtcIiwgbGliLkxvZ2dlci5lcnJvcnMuSU5WQUxJRF9BUkdVTUVOVCwge1xuXHQgICAgICAgICAgICAgICAgICAgIGFyZ3VtZW50OiBcIm5ldHdvcmtcIixcblx0ICAgICAgICAgICAgICAgICAgICB2YWx1ZTogbmV0d29ya1xuXHQgICAgICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9XG5cdCAgICAgICAgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBuZXR3b3JrLCBhcGlLZXkpIHx8IHRoaXM7XG5cdCAgICAgICAgcmV0dXJuIF90aGlzO1xuXHQgICAgfVxuXHQgICAgUG9ja2V0UHJvdmlkZXIuZ2V0QXBpS2V5ID0gZnVuY3Rpb24gKGFwaUtleSkge1xuXHQgICAgICAgIC8vIE1vc3QgQVBJIFByb3ZpZGVycyBhbGxvdyBudWxsIHRvIGdldCB0aGUgZGVmYXVsdCBjb25maWd1cmF0aW9uLCBidXRcblx0ICAgICAgICAvLyBQb2NrZXQgcmVxdWlyZXMgdGhlIG5ldHdvcmsgdG8gZGVjaWRlIHRoZSBkZWZhdWx0IHByb3ZpZGVyLCBzbyB3ZVxuXHQgICAgICAgIC8vIHJlbHkgb24gaGlqYWNraW5nIHRoZSBjb25zdHJ1Y3RvciB0byBhZGQgYSBzZW5zaWJsZSBkZWZhdWx0IGZvciB1c1xuXHQgICAgICAgIGlmIChhcGlLZXkgPT0gbnVsbCkge1xuXHQgICAgICAgICAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwiUG9ja2V0UHJvdmlkZXIuZ2V0QXBpS2V5IGRvZXMgbm90IHN1cHBvcnQgbnVsbCBhcGlLZXlcIiwgXCJhcGlLZXlcIiwgYXBpS2V5KTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgdmFyIGFwaUtleU9iaiA9IHtcblx0ICAgICAgICAgICAgYXBwbGljYXRpb25JZDogbnVsbCxcblx0ICAgICAgICAgICAgbG9hZEJhbGFuY2VyOiBmYWxzZSxcblx0ICAgICAgICAgICAgYXBwbGljYXRpb25TZWNyZXRLZXk6IG51bGxcblx0ICAgICAgICB9O1xuXHQgICAgICAgIC8vIFBhcnNlIGFwcGxpY2F0aW9uSWQgYW5kIGFwcGxpY2F0aW9uU2VjcmV0S2V5XG5cdCAgICAgICAgaWYgKHR5cGVvZiAoYXBpS2V5KSA9PT0gXCJzdHJpbmdcIikge1xuXHQgICAgICAgICAgICBhcGlLZXlPYmouYXBwbGljYXRpb25JZCA9IGFwaUtleTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgZWxzZSBpZiAoYXBpS2V5LmFwcGxpY2F0aW9uU2VjcmV0S2V5ICE9IG51bGwpIHtcblx0ICAgICAgICAgICAgbG9nZ2VyLmFzc2VydEFyZ3VtZW50KCh0eXBlb2YgKGFwaUtleS5hcHBsaWNhdGlvbklkKSA9PT0gXCJzdHJpbmdcIiksIFwiYXBwbGljYXRpb25TZWNyZXRLZXkgcmVxdWlyZXMgYW4gYXBwbGljYXRpb25JZFwiLCBcImFwcGxpY2F0aW9uSWRcIiwgYXBpS2V5LmFwcGxpY2F0aW9uSWQpO1xuXHQgICAgICAgICAgICBsb2dnZXIuYXNzZXJ0QXJndW1lbnQoKHR5cGVvZiAoYXBpS2V5LmFwcGxpY2F0aW9uU2VjcmV0S2V5KSA9PT0gXCJzdHJpbmdcIiksIFwiaW52YWxpZCBhcHBsaWNhdGlvblNlY3JldEtleVwiLCBcImFwcGxpY2F0aW9uU2VjcmV0S2V5XCIsIFwiW1JFREFDVEVEXVwiKTtcblx0ICAgICAgICAgICAgYXBpS2V5T2JqLmFwcGxpY2F0aW9uSWQgPSBhcGlLZXkuYXBwbGljYXRpb25JZDtcblx0ICAgICAgICAgICAgYXBpS2V5T2JqLmFwcGxpY2F0aW9uU2VjcmV0S2V5ID0gYXBpS2V5LmFwcGxpY2F0aW9uU2VjcmV0S2V5O1xuXHQgICAgICAgICAgICBhcGlLZXlPYmoubG9hZEJhbGFuY2VyID0gISFhcGlLZXkubG9hZEJhbGFuY2VyO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBlbHNlIGlmIChhcGlLZXkuYXBwbGljYXRpb25JZCkge1xuXHQgICAgICAgICAgICBsb2dnZXIuYXNzZXJ0QXJndW1lbnQoKHR5cGVvZiAoYXBpS2V5LmFwcGxpY2F0aW9uSWQpID09PSBcInN0cmluZ1wiKSwgXCJhcGlLZXkuYXBwbGljYXRpb25JZCBtdXN0IGJlIGEgc3RyaW5nXCIsIFwiYXBpS2V5LmFwcGxpY2F0aW9uSWRcIiwgYXBpS2V5LmFwcGxpY2F0aW9uSWQpO1xuXHQgICAgICAgICAgICBhcGlLZXlPYmouYXBwbGljYXRpb25JZCA9IGFwaUtleS5hcHBsaWNhdGlvbklkO1xuXHQgICAgICAgICAgICBhcGlLZXlPYmoubG9hZEJhbGFuY2VyID0gISFhcGlLZXkubG9hZEJhbGFuY2VyO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBlbHNlIHtcblx0ICAgICAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcInVuc3VwcG9ydGVkIFBvY2tldFByb3ZpZGVyIGFwaUtleVwiLCBcImFwaUtleVwiLCBhcGlLZXkpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICByZXR1cm4gYXBpS2V5T2JqO1xuXHQgICAgfTtcblx0ICAgIFBvY2tldFByb3ZpZGVyLmdldFVybCA9IGZ1bmN0aW9uIChuZXR3b3JrLCBhcGlLZXkpIHtcblx0ICAgICAgICB2YXIgaG9zdCA9IG51bGw7XG5cdCAgICAgICAgc3dpdGNoIChuZXR3b3JrID8gbmV0d29yay5uYW1lIDogXCJ1bmtub3duXCIpIHtcblx0ICAgICAgICAgICAgY2FzZSBcImhvbWVzdGVhZFwiOlxuXHQgICAgICAgICAgICAgICAgaG9zdCA9IFwiZXRoLW1haW5uZXQuZ2F0ZXdheS5wb2t0Lm5ldHdvcmtcIjtcblx0ICAgICAgICAgICAgICAgIGJyZWFrO1xuXHQgICAgICAgICAgICBjYXNlIFwicm9wc3RlblwiOlxuXHQgICAgICAgICAgICAgICAgaG9zdCA9IFwiZXRoLXJvcHN0ZW4uZ2F0ZXdheS5wb2t0Lm5ldHdvcmtcIjtcblx0ICAgICAgICAgICAgICAgIGJyZWFrO1xuXHQgICAgICAgICAgICBjYXNlIFwicmlua2VieVwiOlxuXHQgICAgICAgICAgICAgICAgaG9zdCA9IFwiZXRoLXJpbmtlYnkuZ2F0ZXdheS5wb2t0Lm5ldHdvcmtcIjtcblx0ICAgICAgICAgICAgICAgIGJyZWFrO1xuXHQgICAgICAgICAgICBjYXNlIFwiZ29lcmxpXCI6XG5cdCAgICAgICAgICAgICAgICBob3N0ID0gXCJldGgtZ29lcmxpLmdhdGV3YXkucG9rdC5uZXR3b3JrXCI7XG5cdCAgICAgICAgICAgICAgICBicmVhaztcblx0ICAgICAgICAgICAgZGVmYXVsdDpcblx0ICAgICAgICAgICAgICAgIGxvZ2dlci50aHJvd0Vycm9yKFwidW5zdXBwb3J0ZWQgbmV0d29ya1wiLCBsaWIuTG9nZ2VyLmVycm9ycy5JTlZBTElEX0FSR1VNRU5ULCB7XG5cdCAgICAgICAgICAgICAgICAgICAgYXJndW1lbnQ6IFwibmV0d29ya1wiLFxuXHQgICAgICAgICAgICAgICAgICAgIHZhbHVlOiBuZXR3b3JrXG5cdCAgICAgICAgICAgICAgICB9KTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgdmFyIHVybCA9IG51bGw7XG5cdCAgICAgICAgaWYgKGFwaUtleS5sb2FkQmFsYW5jZXIpIHtcblx0ICAgICAgICAgICAgdXJsID0gXCJodHRwczovL1wiICsgaG9zdCArIFwiL3YxL2xiL1wiICsgYXBpS2V5LmFwcGxpY2F0aW9uSWQ7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGVsc2Uge1xuXHQgICAgICAgICAgICB1cmwgPSBcImh0dHBzOi8vXCIgKyBob3N0ICsgXCIvdjEvXCIgKyBhcGlLZXkuYXBwbGljYXRpb25JZDtcblx0ICAgICAgICB9XG5cdCAgICAgICAgdmFyIGNvbm5lY3Rpb24gPSB7IHVybDogdXJsIH07XG5cdCAgICAgICAgLy8gSW5pdGlhbGl6ZSBlbXB0eSBoZWFkZXJzXG5cdCAgICAgICAgY29ubmVjdGlvbi5oZWFkZXJzID0ge307XG5cdCAgICAgICAgLy8gQXBwbHkgYXBwbGljYXRpb24gc2VjcmV0IGtleVxuXHQgICAgICAgIGlmIChhcGlLZXkuYXBwbGljYXRpb25TZWNyZXRLZXkgIT0gbnVsbCkge1xuXHQgICAgICAgICAgICBjb25uZWN0aW9uLnVzZXIgPSBcIlwiO1xuXHQgICAgICAgICAgICBjb25uZWN0aW9uLnBhc3N3b3JkID0gYXBpS2V5LmFwcGxpY2F0aW9uU2VjcmV0S2V5O1xuXHQgICAgICAgIH1cblx0ICAgICAgICByZXR1cm4gY29ubmVjdGlvbjtcblx0ICAgIH07XG5cdCAgICBQb2NrZXRQcm92aWRlci5wcm90b3R5cGUuaXNDb21tdW5pdHlSZXNvdXJjZSA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICByZXR1cm4gKHRoaXMuYXBwbGljYXRpb25JZCA9PT0gZGVmYXVsdEFwcGxpY2F0aW9uSWRzW3RoaXMubmV0d29yay5uYW1lXSk7XG5cdCAgICB9O1xuXHQgICAgcmV0dXJuIFBvY2tldFByb3ZpZGVyO1xuXHR9KHVybEpzb25ScGNQcm92aWRlci5VcmxKc29uUnBjUHJvdmlkZXIpKTtcblx0ZXhwb3J0cy5Qb2NrZXRQcm92aWRlciA9IFBvY2tldFByb3ZpZGVyO1xuXG5cdH0pO1xuXG5cdHZhciBwb2NrZXRQcm92aWRlciQxID0gLypAX19QVVJFX18qL2dldERlZmF1bHRFeHBvcnRGcm9tQ2pzKHBvY2tldFByb3ZpZGVyKTtcblxuXHR2YXIgd2ViM1Byb3ZpZGVyID0gY3JlYXRlQ29tbW9uanNNb2R1bGUoZnVuY3Rpb24gKG1vZHVsZSwgZXhwb3J0cykge1xuXHRcInVzZSBzdHJpY3RcIjtcblx0dmFyIF9fZXh0ZW5kcyA9IChjb21tb25qc0dsb2JhbCAmJiBjb21tb25qc0dsb2JhbC5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG5cdCAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IGZ1bmN0aW9uIChkLCBiKSB7XG5cdCAgICAgICAgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuXHQgICAgICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG5cdCAgICAgICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChiLCBwKSkgZFtwXSA9IGJbcF07IH07XG5cdCAgICAgICAgcmV0dXJuIGV4dGVuZFN0YXRpY3MoZCwgYik7XG5cdCAgICB9O1xuXHQgICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG5cdCAgICAgICAgaWYgKHR5cGVvZiBiICE9PSBcImZ1bmN0aW9uXCIgJiYgYiAhPT0gbnVsbClcblx0ICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNsYXNzIGV4dGVuZHMgdmFsdWUgXCIgKyBTdHJpbmcoYikgKyBcIiBpcyBub3QgYSBjb25zdHJ1Y3RvciBvciBudWxsXCIpO1xuXHQgICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG5cdCAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG5cdCAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuXHQgICAgfTtcblx0fSkoKTtcblx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuXHRleHBvcnRzLldlYjNQcm92aWRlciA9IHZvaWQgMDtcblxuXG5cblx0dmFyIGxvZ2dlciA9IG5ldyBsaWIuTG9nZ2VyKF92ZXJzaW9uJEkudmVyc2lvbik7XG5cblx0dmFyIF9uZXh0SWQgPSAxO1xuXHRmdW5jdGlvbiBidWlsZFdlYjNMZWdhY3lGZXRjaGVyKHByb3ZpZGVyLCBzZW5kRnVuYykge1xuXHQgICAgdmFyIGZldGNoZXIgPSBcIldlYjNMZWdhY3lGZXRjaGVyXCI7XG5cdCAgICByZXR1cm4gZnVuY3Rpb24gKG1ldGhvZCwgcGFyYW1zKSB7XG5cdCAgICAgICAgdmFyIF90aGlzID0gdGhpcztcblx0ICAgICAgICB2YXIgcmVxdWVzdCA9IHtcblx0ICAgICAgICAgICAgbWV0aG9kOiBtZXRob2QsXG5cdCAgICAgICAgICAgIHBhcmFtczogcGFyYW1zLFxuXHQgICAgICAgICAgICBpZDogKF9uZXh0SWQrKyksXG5cdCAgICAgICAgICAgIGpzb25ycGM6IFwiMi4wXCJcblx0ICAgICAgICB9O1xuXHQgICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG5cdCAgICAgICAgICAgIF90aGlzLmVtaXQoXCJkZWJ1Z1wiLCB7XG5cdCAgICAgICAgICAgICAgICBhY3Rpb246IFwicmVxdWVzdFwiLFxuXHQgICAgICAgICAgICAgICAgZmV0Y2hlcjogZmV0Y2hlcixcblx0ICAgICAgICAgICAgICAgIHJlcXVlc3Q6ICgwLCBsaWIkMy5kZWVwQ29weSkocmVxdWVzdCksXG5cdCAgICAgICAgICAgICAgICBwcm92aWRlcjogX3RoaXNcblx0ICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgICAgIHNlbmRGdW5jKHJlcXVlc3QsIGZ1bmN0aW9uIChlcnJvciwgcmVzcG9uc2UpIHtcblx0ICAgICAgICAgICAgICAgIGlmIChlcnJvcikge1xuXHQgICAgICAgICAgICAgICAgICAgIF90aGlzLmVtaXQoXCJkZWJ1Z1wiLCB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGFjdGlvbjogXCJyZXNwb25zZVwiLFxuXHQgICAgICAgICAgICAgICAgICAgICAgICBmZXRjaGVyOiBmZXRjaGVyLFxuXHQgICAgICAgICAgICAgICAgICAgICAgICBlcnJvcjogZXJyb3IsXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJlcXVlc3Q6IHJlcXVlc3QsXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHByb3ZpZGVyOiBfdGhpc1xuXHQgICAgICAgICAgICAgICAgICAgIH0pO1xuXHQgICAgICAgICAgICAgICAgICAgIHJldHVybiByZWplY3QoZXJyb3IpO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgX3RoaXMuZW1pdChcImRlYnVnXCIsIHtcblx0ICAgICAgICAgICAgICAgICAgICBhY3Rpb246IFwicmVzcG9uc2VcIixcblx0ICAgICAgICAgICAgICAgICAgICBmZXRjaGVyOiBmZXRjaGVyLFxuXHQgICAgICAgICAgICAgICAgICAgIHJlcXVlc3Q6IHJlcXVlc3QsXG5cdCAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2U6IHJlc3BvbnNlLFxuXHQgICAgICAgICAgICAgICAgICAgIHByb3ZpZGVyOiBfdGhpc1xuXHQgICAgICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgICAgICAgICBpZiAocmVzcG9uc2UuZXJyb3IpIHtcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgZXJyb3JfMSA9IG5ldyBFcnJvcihyZXNwb25zZS5lcnJvci5tZXNzYWdlKTtcblx0ICAgICAgICAgICAgICAgICAgICBlcnJvcl8xLmNvZGUgPSByZXNwb25zZS5lcnJvci5jb2RlO1xuXHQgICAgICAgICAgICAgICAgICAgIGVycm9yXzEuZGF0YSA9IHJlc3BvbnNlLmVycm9yLmRhdGE7XG5cdCAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlamVjdChlcnJvcl8xKTtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgIHJlc29sdmUocmVzcG9uc2UucmVzdWx0KTtcblx0ICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgfSk7XG5cdCAgICB9O1xuXHR9XG5cdGZ1bmN0aW9uIGJ1aWxkRWlwMTE5M0ZldGNoZXIocHJvdmlkZXIpIHtcblx0ICAgIHJldHVybiBmdW5jdGlvbiAobWV0aG9kLCBwYXJhbXMpIHtcblx0ICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXHQgICAgICAgIGlmIChwYXJhbXMgPT0gbnVsbCkge1xuXHQgICAgICAgICAgICBwYXJhbXMgPSBbXTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgdmFyIHJlcXVlc3QgPSB7IG1ldGhvZDogbWV0aG9kLCBwYXJhbXM6IHBhcmFtcyB9O1xuXHQgICAgICAgIHRoaXMuZW1pdChcImRlYnVnXCIsIHtcblx0ICAgICAgICAgICAgYWN0aW9uOiBcInJlcXVlc3RcIixcblx0ICAgICAgICAgICAgZmV0Y2hlcjogXCJFaXAxMTkzRmV0Y2hlclwiLFxuXHQgICAgICAgICAgICByZXF1ZXN0OiAoMCwgbGliJDMuZGVlcENvcHkpKHJlcXVlc3QpLFxuXHQgICAgICAgICAgICBwcm92aWRlcjogdGhpc1xuXHQgICAgICAgIH0pO1xuXHQgICAgICAgIHJldHVybiBwcm92aWRlci5yZXF1ZXN0KHJlcXVlc3QpLnRoZW4oZnVuY3Rpb24gKHJlc3BvbnNlKSB7XG5cdCAgICAgICAgICAgIF90aGlzLmVtaXQoXCJkZWJ1Z1wiLCB7XG5cdCAgICAgICAgICAgICAgICBhY3Rpb246IFwicmVzcG9uc2VcIixcblx0ICAgICAgICAgICAgICAgIGZldGNoZXI6IFwiRWlwMTE5M0ZldGNoZXJcIixcblx0ICAgICAgICAgICAgICAgIHJlcXVlc3Q6IHJlcXVlc3QsXG5cdCAgICAgICAgICAgICAgICByZXNwb25zZTogcmVzcG9uc2UsXG5cdCAgICAgICAgICAgICAgICBwcm92aWRlcjogX3RoaXNcblx0ICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgICAgIHJldHVybiByZXNwb25zZTtcblx0ICAgICAgICB9LCBmdW5jdGlvbiAoZXJyb3IpIHtcblx0ICAgICAgICAgICAgX3RoaXMuZW1pdChcImRlYnVnXCIsIHtcblx0ICAgICAgICAgICAgICAgIGFjdGlvbjogXCJyZXNwb25zZVwiLFxuXHQgICAgICAgICAgICAgICAgZmV0Y2hlcjogXCJFaXAxMTkzRmV0Y2hlclwiLFxuXHQgICAgICAgICAgICAgICAgcmVxdWVzdDogcmVxdWVzdCxcblx0ICAgICAgICAgICAgICAgIGVycm9yOiBlcnJvcixcblx0ICAgICAgICAgICAgICAgIHByb3ZpZGVyOiBfdGhpc1xuXHQgICAgICAgICAgICB9KTtcblx0ICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG5cdCAgICAgICAgfSk7XG5cdCAgICB9O1xuXHR9XG5cdHZhciBXZWIzUHJvdmlkZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG5cdCAgICBfX2V4dGVuZHMoV2ViM1Byb3ZpZGVyLCBfc3VwZXIpO1xuXHQgICAgZnVuY3Rpb24gV2ViM1Byb3ZpZGVyKHByb3ZpZGVyLCBuZXR3b3JrKSB7XG5cdCAgICAgICAgdmFyIF9uZXdUYXJnZXQgPSB0aGlzLmNvbnN0cnVjdG9yO1xuXHQgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cdCAgICAgICAgbG9nZ2VyLmNoZWNrTmV3KF9uZXdUYXJnZXQsIFdlYjNQcm92aWRlcik7XG5cdCAgICAgICAgaWYgKHByb3ZpZGVyID09IG51bGwpIHtcblx0ICAgICAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcIm1pc3NpbmcgcHJvdmlkZXJcIiwgXCJwcm92aWRlclwiLCBwcm92aWRlcik7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHZhciBwYXRoID0gbnVsbDtcblx0ICAgICAgICB2YXIganNvblJwY0ZldGNoRnVuYyA9IG51bGw7XG5cdCAgICAgICAgdmFyIHN1YnByb3ZpZGVyID0gbnVsbDtcblx0ICAgICAgICBpZiAodHlwZW9mIChwcm92aWRlcikgPT09IFwiZnVuY3Rpb25cIikge1xuXHQgICAgICAgICAgICBwYXRoID0gXCJ1bmtub3duOlwiO1xuXHQgICAgICAgICAgICBqc29uUnBjRmV0Y2hGdW5jID0gcHJvdmlkZXI7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGVsc2Uge1xuXHQgICAgICAgICAgICBwYXRoID0gcHJvdmlkZXIuaG9zdCB8fCBwcm92aWRlci5wYXRoIHx8IFwiXCI7XG5cdCAgICAgICAgICAgIGlmICghcGF0aCAmJiBwcm92aWRlci5pc01ldGFNYXNrKSB7XG5cdCAgICAgICAgICAgICAgICBwYXRoID0gXCJtZXRhbWFza1wiO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIHN1YnByb3ZpZGVyID0gcHJvdmlkZXI7XG5cdCAgICAgICAgICAgIGlmIChwcm92aWRlci5yZXF1ZXN0KSB7XG5cdCAgICAgICAgICAgICAgICBpZiAocGF0aCA9PT0gXCJcIikge1xuXHQgICAgICAgICAgICAgICAgICAgIHBhdGggPSBcImVpcC0xMTkzOlwiO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAganNvblJwY0ZldGNoRnVuYyA9IGJ1aWxkRWlwMTE5M0ZldGNoZXIocHJvdmlkZXIpO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIGVsc2UgaWYgKHByb3ZpZGVyLnNlbmRBc3luYykge1xuXHQgICAgICAgICAgICAgICAganNvblJwY0ZldGNoRnVuYyA9IGJ1aWxkV2ViM0xlZ2FjeUZldGNoZXIocHJvdmlkZXIsIHByb3ZpZGVyLnNlbmRBc3luYy5iaW5kKHByb3ZpZGVyKSk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgZWxzZSBpZiAocHJvdmlkZXIuc2VuZCkge1xuXHQgICAgICAgICAgICAgICAganNvblJwY0ZldGNoRnVuYyA9IGJ1aWxkV2ViM0xlZ2FjeUZldGNoZXIocHJvdmlkZXIsIHByb3ZpZGVyLnNlbmQuYmluZChwcm92aWRlcikpO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIGVsc2Uge1xuXHQgICAgICAgICAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcInVuc3VwcG9ydGVkIHByb3ZpZGVyXCIsIFwicHJvdmlkZXJcIiwgcHJvdmlkZXIpO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIGlmICghcGF0aCkge1xuXHQgICAgICAgICAgICAgICAgcGF0aCA9IFwidW5rbm93bjpcIjtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH1cblx0ICAgICAgICBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIHBhdGgsIG5ldHdvcmspIHx8IHRoaXM7XG5cdCAgICAgICAgKDAsIGxpYiQzLmRlZmluZVJlYWRPbmx5KShfdGhpcywgXCJqc29uUnBjRmV0Y2hGdW5jXCIsIGpzb25ScGNGZXRjaEZ1bmMpO1xuXHQgICAgICAgICgwLCBsaWIkMy5kZWZpbmVSZWFkT25seSkoX3RoaXMsIFwicHJvdmlkZXJcIiwgc3VicHJvdmlkZXIpO1xuXHQgICAgICAgIHJldHVybiBfdGhpcztcblx0ICAgIH1cblx0ICAgIFdlYjNQcm92aWRlci5wcm90b3R5cGUuc2VuZCA9IGZ1bmN0aW9uIChtZXRob2QsIHBhcmFtcykge1xuXHQgICAgICAgIHJldHVybiB0aGlzLmpzb25ScGNGZXRjaEZ1bmMobWV0aG9kLCBwYXJhbXMpO1xuXHQgICAgfTtcblx0ICAgIHJldHVybiBXZWIzUHJvdmlkZXI7XG5cdH0oanNvblJwY1Byb3ZpZGVyLkpzb25ScGNQcm92aWRlcikpO1xuXHRleHBvcnRzLldlYjNQcm92aWRlciA9IFdlYjNQcm92aWRlcjtcblxuXHR9KTtcblxuXHR2YXIgd2ViM1Byb3ZpZGVyJDEgPSAvKkBfX1BVUkVfXyovZ2V0RGVmYXVsdEV4cG9ydEZyb21DanMod2ViM1Byb3ZpZGVyKTtcblxuXHR2YXIgbGliJHIgPSBjcmVhdGVDb21tb25qc01vZHVsZShmdW5jdGlvbiAobW9kdWxlLCBleHBvcnRzKSB7XG5cdFwidXNlIHN0cmljdFwiO1xuXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5cdGV4cG9ydHMuRm9ybWF0dGVyID0gZXhwb3J0cy5zaG93VGhyb3R0bGVNZXNzYWdlID0gZXhwb3J0cy5pc0NvbW11bml0eVJlc291cmNhYmxlID0gZXhwb3J0cy5pc0NvbW11bml0eVJlc291cmNlID0gZXhwb3J0cy5nZXROZXR3b3JrID0gZXhwb3J0cy5nZXREZWZhdWx0UHJvdmlkZXIgPSBleHBvcnRzLkpzb25ScGNTaWduZXIgPSBleHBvcnRzLklwY1Byb3ZpZGVyID0gZXhwb3J0cy5XZWJTb2NrZXRQcm92aWRlciA9IGV4cG9ydHMuV2ViM1Byb3ZpZGVyID0gZXhwb3J0cy5TdGF0aWNKc29uUnBjUHJvdmlkZXIgPSBleHBvcnRzLlBvY2tldFByb3ZpZGVyID0gZXhwb3J0cy5Ob2Rlc21pdGhQcm92aWRlciA9IGV4cG9ydHMuSnNvblJwY0JhdGNoUHJvdmlkZXIgPSBleHBvcnRzLkpzb25ScGNQcm92aWRlciA9IGV4cG9ydHMuSW5mdXJhV2ViU29ja2V0UHJvdmlkZXIgPSBleHBvcnRzLkluZnVyYVByb3ZpZGVyID0gZXhwb3J0cy5FdGhlcnNjYW5Qcm92aWRlciA9IGV4cG9ydHMuQ2xvdWRmbGFyZVByb3ZpZGVyID0gZXhwb3J0cy5BbGNoZW15V2ViU29ja2V0UHJvdmlkZXIgPSBleHBvcnRzLkFsY2hlbXlQcm92aWRlciA9IGV4cG9ydHMuRmFsbGJhY2tQcm92aWRlciA9IGV4cG9ydHMuVXJsSnNvblJwY1Byb3ZpZGVyID0gZXhwb3J0cy5SZXNvbHZlciA9IGV4cG9ydHMuQmFzZVByb3ZpZGVyID0gZXhwb3J0cy5Qcm92aWRlciA9IHZvaWQgMDtcblxuXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJQcm92aWRlclwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gbGliJGIuUHJvdmlkZXI7IH0gfSk7XG5cblx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiZ2V0TmV0d29ya1wiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gbGliJG8uZ2V0TmV0d29yazsgfSB9KTtcblxuXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJCYXNlUHJvdmlkZXJcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGJhc2VQcm92aWRlci5CYXNlUHJvdmlkZXI7IH0gfSk7XG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlJlc29sdmVyXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBiYXNlUHJvdmlkZXIuUmVzb2x2ZXI7IH0gfSk7XG5cblx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiQWxjaGVteVByb3ZpZGVyXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBhbGNoZW15UHJvdmlkZXIuQWxjaGVteVByb3ZpZGVyOyB9IH0pO1xuXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJBbGNoZW15V2ViU29ja2V0UHJvdmlkZXJcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGFsY2hlbXlQcm92aWRlci5BbGNoZW15V2ViU29ja2V0UHJvdmlkZXI7IH0gfSk7XG5cblx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiQ2xvdWRmbGFyZVByb3ZpZGVyXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBjbG91ZGZsYXJlUHJvdmlkZXIuQ2xvdWRmbGFyZVByb3ZpZGVyOyB9IH0pO1xuXG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkV0aGVyc2NhblByb3ZpZGVyXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBldGhlcnNjYW5Qcm92aWRlci5FdGhlcnNjYW5Qcm92aWRlcjsgfSB9KTtcblxuXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJGYWxsYmFja1Byb3ZpZGVyXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBmYWxsYmFja1Byb3ZpZGVyLkZhbGxiYWNrUHJvdmlkZXI7IH0gfSk7XG5cblx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiSXBjUHJvdmlkZXJcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGJyb3dzZXJJcGNQcm92aWRlci5JcGNQcm92aWRlcjsgfSB9KTtcblxuXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJJbmZ1cmFQcm92aWRlclwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gaW5mdXJhUHJvdmlkZXIuSW5mdXJhUHJvdmlkZXI7IH0gfSk7XG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkluZnVyYVdlYlNvY2tldFByb3ZpZGVyXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBpbmZ1cmFQcm92aWRlci5JbmZ1cmFXZWJTb2NrZXRQcm92aWRlcjsgfSB9KTtcblxuXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJKc29uUnBjUHJvdmlkZXJcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGpzb25ScGNQcm92aWRlci5Kc29uUnBjUHJvdmlkZXI7IH0gfSk7XG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkpzb25ScGNTaWduZXJcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGpzb25ScGNQcm92aWRlci5Kc29uUnBjU2lnbmVyOyB9IH0pO1xuXG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkpzb25ScGNCYXRjaFByb3ZpZGVyXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBqc29uUnBjQmF0Y2hQcm92aWRlci5Kc29uUnBjQmF0Y2hQcm92aWRlcjsgfSB9KTtcblxuXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJOb2Rlc21pdGhQcm92aWRlclwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gbm9kZXNtaXRoUHJvdmlkZXIuTm9kZXNtaXRoUHJvdmlkZXI7IH0gfSk7XG5cblx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiUG9ja2V0UHJvdmlkZXJcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHBvY2tldFByb3ZpZGVyLlBvY2tldFByb3ZpZGVyOyB9IH0pO1xuXG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlN0YXRpY0pzb25ScGNQcm92aWRlclwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdXJsSnNvblJwY1Byb3ZpZGVyLlN0YXRpY0pzb25ScGNQcm92aWRlcjsgfSB9KTtcblx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiVXJsSnNvblJwY1Byb3ZpZGVyXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB1cmxKc29uUnBjUHJvdmlkZXIuVXJsSnNvblJwY1Byb3ZpZGVyOyB9IH0pO1xuXG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIldlYjNQcm92aWRlclwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gd2ViM1Byb3ZpZGVyLldlYjNQcm92aWRlcjsgfSB9KTtcblxuXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJXZWJTb2NrZXRQcm92aWRlclwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gd2Vic29ja2V0UHJvdmlkZXIuV2ViU29ja2V0UHJvdmlkZXI7IH0gfSk7XG5cblx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiRm9ybWF0dGVyXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBmb3JtYXR0ZXIuRm9ybWF0dGVyOyB9IH0pO1xuXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJpc0NvbW11bml0eVJlc291cmNhYmxlXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBmb3JtYXR0ZXIuaXNDb21tdW5pdHlSZXNvdXJjYWJsZTsgfSB9KTtcblx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiaXNDb21tdW5pdHlSZXNvdXJjZVwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gZm9ybWF0dGVyLmlzQ29tbXVuaXR5UmVzb3VyY2U7IH0gfSk7XG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcInNob3dUaHJvdHRsZU1lc3NhZ2VcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGZvcm1hdHRlci5zaG93VGhyb3R0bGVNZXNzYWdlOyB9IH0pO1xuXG5cblx0dmFyIGxvZ2dlciA9IG5ldyBsaWIuTG9nZ2VyKF92ZXJzaW9uJEkudmVyc2lvbik7XG5cdC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXHQvLyBIZWxwZXIgRnVuY3Rpb25zXG5cdGZ1bmN0aW9uIGdldERlZmF1bHRQcm92aWRlcihuZXR3b3JrLCBvcHRpb25zKSB7XG5cdCAgICBpZiAobmV0d29yayA9PSBudWxsKSB7XG5cdCAgICAgICAgbmV0d29yayA9IFwiaG9tZXN0ZWFkXCI7XG5cdCAgICB9XG5cdCAgICAvLyBJZiBwYXNzZWQgYSBVUkwsIGZpZ3VyZSBvdXQgdGhlIHJpZ2h0IHR5cGUgb2YgcHJvdmlkZXIgYmFzZWQgb24gdGhlIHNjaGVtZVxuXHQgICAgaWYgKHR5cGVvZiAobmV0d29yaykgPT09IFwic3RyaW5nXCIpIHtcblx0ICAgICAgICAvLyBAVE9ETzogQWRkIHN1cHBvcnQgZm9yIElwY1Byb3ZpZGVyOyBtYXliZSBpZiBpdCBlbmRzIGluIFwiLmlwY1wiP1xuXHQgICAgICAgIC8vIEhhbmRsZSBodHRwIGFuZCB3cyAoYW5kIHRoZWlyIHNlY3VyZSB2YXJpYW50cylcblx0ICAgICAgICB2YXIgbWF0Y2ggPSBuZXR3b3JrLm1hdGNoKC9eKHdzfGh0dHApcz86L2kpO1xuXHQgICAgICAgIGlmIChtYXRjaCkge1xuXHQgICAgICAgICAgICBzd2l0Y2ggKG1hdGNoWzFdKSB7XG5cdCAgICAgICAgICAgICAgICBjYXNlIFwiaHR0cFwiOlxuXHQgICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcganNvblJwY1Byb3ZpZGVyLkpzb25ScGNQcm92aWRlcihuZXR3b3JrKTtcblx0ICAgICAgICAgICAgICAgIGNhc2UgXCJ3c1wiOlxuXHQgICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgd2Vic29ja2V0UHJvdmlkZXIuV2ViU29ja2V0UHJvdmlkZXIobmV0d29yayk7XG5cdCAgICAgICAgICAgICAgICBkZWZhdWx0OlxuXHQgICAgICAgICAgICAgICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJ1bnN1cHBvcnRlZCBVUkwgc2NoZW1lXCIsIFwibmV0d29ya1wiLCBuZXR3b3JrKTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH1cblx0ICAgIH1cblx0ICAgIHZhciBuID0gKDAsIGxpYiRvLmdldE5ldHdvcmspKG5ldHdvcmspO1xuXHQgICAgaWYgKCFuIHx8ICFuLl9kZWZhdWx0UHJvdmlkZXIpIHtcblx0ICAgICAgICBsb2dnZXIudGhyb3dFcnJvcihcInVuc3VwcG9ydGVkIGdldERlZmF1bHRQcm92aWRlciBuZXR3b3JrXCIsIGxpYi5Mb2dnZXIuZXJyb3JzLk5FVFdPUktfRVJST1IsIHtcblx0ICAgICAgICAgICAgb3BlcmF0aW9uOiBcImdldERlZmF1bHRQcm92aWRlclwiLFxuXHQgICAgICAgICAgICBuZXR3b3JrOiBuZXR3b3JrXG5cdCAgICAgICAgfSk7XG5cdCAgICB9XG5cdCAgICByZXR1cm4gbi5fZGVmYXVsdFByb3ZpZGVyKHtcblx0ICAgICAgICBGYWxsYmFja1Byb3ZpZGVyOiBmYWxsYmFja1Byb3ZpZGVyLkZhbGxiYWNrUHJvdmlkZXIsXG5cdCAgICAgICAgQWxjaGVteVByb3ZpZGVyOiBhbGNoZW15UHJvdmlkZXIuQWxjaGVteVByb3ZpZGVyLFxuXHQgICAgICAgIENsb3VkZmxhcmVQcm92aWRlcjogY2xvdWRmbGFyZVByb3ZpZGVyLkNsb3VkZmxhcmVQcm92aWRlcixcblx0ICAgICAgICBFdGhlcnNjYW5Qcm92aWRlcjogZXRoZXJzY2FuUHJvdmlkZXIuRXRoZXJzY2FuUHJvdmlkZXIsXG5cdCAgICAgICAgSW5mdXJhUHJvdmlkZXI6IGluZnVyYVByb3ZpZGVyLkluZnVyYVByb3ZpZGVyLFxuXHQgICAgICAgIEpzb25ScGNQcm92aWRlcjoganNvblJwY1Byb3ZpZGVyLkpzb25ScGNQcm92aWRlcixcblx0ICAgICAgICBOb2Rlc21pdGhQcm92aWRlcjogbm9kZXNtaXRoUHJvdmlkZXIuTm9kZXNtaXRoUHJvdmlkZXIsXG5cdCAgICAgICAgUG9ja2V0UHJvdmlkZXI6IHBvY2tldFByb3ZpZGVyLlBvY2tldFByb3ZpZGVyLFxuXHQgICAgICAgIFdlYjNQcm92aWRlcjogd2ViM1Byb3ZpZGVyLldlYjNQcm92aWRlcixcblx0ICAgICAgICBJcGNQcm92aWRlcjogYnJvd3NlcklwY1Byb3ZpZGVyLklwY1Byb3ZpZGVyLFxuXHQgICAgfSwgb3B0aW9ucyk7XG5cdH1cblx0ZXhwb3J0cy5nZXREZWZhdWx0UHJvdmlkZXIgPSBnZXREZWZhdWx0UHJvdmlkZXI7XG5cblx0fSk7XG5cblx0dmFyIGluZGV4JHIgPSAvKkBfX1BVUkVfXyovZ2V0RGVmYXVsdEV4cG9ydEZyb21DanMobGliJHIpO1xuXG5cdHZhciBfdmVyc2lvbiRLID0gY3JlYXRlQ29tbW9uanNNb2R1bGUoZnVuY3Rpb24gKG1vZHVsZSwgZXhwb3J0cykge1xuXHRcInVzZSBzdHJpY3RcIjtcblx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuXHRleHBvcnRzLnZlcnNpb24gPSB2b2lkIDA7XG5cdGV4cG9ydHMudmVyc2lvbiA9IFwic29saWRpdHkvNS41LjBcIjtcblxuXHR9KTtcblxuXHR2YXIgX3ZlcnNpb24kTCA9IC8qQF9fUFVSRV9fKi9nZXREZWZhdWx0RXhwb3J0RnJvbUNqcyhfdmVyc2lvbiRLKTtcblxuXHR2YXIgbGliJHMgPSBjcmVhdGVDb21tb25qc01vZHVsZShmdW5jdGlvbiAobW9kdWxlLCBleHBvcnRzKSB7XG5cdFwidXNlIHN0cmljdFwiO1xuXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5cdGV4cG9ydHMuc2hhMjU2ID0gZXhwb3J0cy5rZWNjYWsyNTYgPSBleHBvcnRzLnBhY2sgPSB2b2lkIDA7XG5cblxuXG5cblxuXHR2YXIgcmVnZXhCeXRlcyA9IG5ldyBSZWdFeHAoXCJeYnl0ZXMoWzAtOV0rKSRcIik7XG5cdHZhciByZWdleE51bWJlciA9IG5ldyBSZWdFeHAoXCJeKHU/aW50KShbMC05XSopJFwiKTtcblx0dmFyIHJlZ2V4QXJyYXkgPSBuZXcgUmVnRXhwKFwiXiguKilcXFxcWyhbMC05XSopXFxcXF0kXCIpO1xuXHR2YXIgWmVyb3MgPSBcIjAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDBcIjtcblxuXG5cdHZhciBsb2dnZXIgPSBuZXcgbGliLkxvZ2dlcihfdmVyc2lvbiRLLnZlcnNpb24pO1xuXHRmdW5jdGlvbiBfcGFjayh0eXBlLCB2YWx1ZSwgaXNBcnJheSkge1xuXHQgICAgc3dpdGNoICh0eXBlKSB7XG5cdCAgICAgICAgY2FzZSBcImFkZHJlc3NcIjpcblx0ICAgICAgICAgICAgaWYgKGlzQXJyYXkpIHtcblx0ICAgICAgICAgICAgICAgIHJldHVybiAoMCwgbGliJDEuemVyb1BhZCkodmFsdWUsIDMyKTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICByZXR1cm4gKDAsIGxpYiQxLmFycmF5aWZ5KSh2YWx1ZSk7XG5cdCAgICAgICAgY2FzZSBcInN0cmluZ1wiOlxuXHQgICAgICAgICAgICByZXR1cm4gKDAsIGxpYiQ4LnRvVXRmOEJ5dGVzKSh2YWx1ZSk7XG5cdCAgICAgICAgY2FzZSBcImJ5dGVzXCI6XG5cdCAgICAgICAgICAgIHJldHVybiAoMCwgbGliJDEuYXJyYXlpZnkpKHZhbHVlKTtcblx0ICAgICAgICBjYXNlIFwiYm9vbFwiOlxuXHQgICAgICAgICAgICB2YWx1ZSA9ICh2YWx1ZSA/IFwiMHgwMVwiIDogXCIweDAwXCIpO1xuXHQgICAgICAgICAgICBpZiAoaXNBcnJheSkge1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuICgwLCBsaWIkMS56ZXJvUGFkKSh2YWx1ZSwgMzIpO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIHJldHVybiAoMCwgbGliJDEuYXJyYXlpZnkpKHZhbHVlKTtcblx0ICAgIH1cblx0ICAgIHZhciBtYXRjaCA9IHR5cGUubWF0Y2gocmVnZXhOdW1iZXIpO1xuXHQgICAgaWYgKG1hdGNoKSB7XG5cdCAgICAgICAgLy9sZXQgc2lnbmVkID0gKG1hdGNoWzFdID09PSBcImludFwiKVxuXHQgICAgICAgIHZhciBzaXplID0gcGFyc2VJbnQobWF0Y2hbMl0gfHwgXCIyNTZcIik7XG5cdCAgICAgICAgaWYgKChtYXRjaFsyXSAmJiBTdHJpbmcoc2l6ZSkgIT09IG1hdGNoWzJdKSB8fCAoc2l6ZSAlIDggIT09IDApIHx8IHNpemUgPT09IDAgfHwgc2l6ZSA+IDI1Nikge1xuXHQgICAgICAgICAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwiaW52YWxpZCBudW1iZXIgdHlwZVwiLCBcInR5cGVcIiwgdHlwZSk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGlmIChpc0FycmF5KSB7XG5cdCAgICAgICAgICAgIHNpemUgPSAyNTY7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHZhbHVlID0gbGliJDIuQmlnTnVtYmVyLmZyb20odmFsdWUpLnRvVHdvcyhzaXplKTtcblx0ICAgICAgICByZXR1cm4gKDAsIGxpYiQxLnplcm9QYWQpKHZhbHVlLCBzaXplIC8gOCk7XG5cdCAgICB9XG5cdCAgICBtYXRjaCA9IHR5cGUubWF0Y2gocmVnZXhCeXRlcyk7XG5cdCAgICBpZiAobWF0Y2gpIHtcblx0ICAgICAgICB2YXIgc2l6ZSA9IHBhcnNlSW50KG1hdGNoWzFdKTtcblx0ICAgICAgICBpZiAoU3RyaW5nKHNpemUpICE9PSBtYXRjaFsxXSB8fCBzaXplID09PSAwIHx8IHNpemUgPiAzMikge1xuXHQgICAgICAgICAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwiaW52YWxpZCBieXRlcyB0eXBlXCIsIFwidHlwZVwiLCB0eXBlKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgaWYgKCgwLCBsaWIkMS5hcnJheWlmeSkodmFsdWUpLmJ5dGVMZW5ndGggIT09IHNpemUpIHtcblx0ICAgICAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcImludmFsaWQgdmFsdWUgZm9yIFwiICsgdHlwZSwgXCJ2YWx1ZVwiLCB2YWx1ZSk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGlmIChpc0FycmF5KSB7XG5cdCAgICAgICAgICAgIHJldHVybiAoMCwgbGliJDEuYXJyYXlpZnkpKCh2YWx1ZSArIFplcm9zKS5zdWJzdHJpbmcoMCwgNjYpKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgcmV0dXJuIHZhbHVlO1xuXHQgICAgfVxuXHQgICAgbWF0Y2ggPSB0eXBlLm1hdGNoKHJlZ2V4QXJyYXkpO1xuXHQgICAgaWYgKG1hdGNoICYmIEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG5cdCAgICAgICAgdmFyIGJhc2VUeXBlXzEgPSBtYXRjaFsxXTtcblx0ICAgICAgICB2YXIgY291bnQgPSBwYXJzZUludChtYXRjaFsyXSB8fCBTdHJpbmcodmFsdWUubGVuZ3RoKSk7XG5cdCAgICAgICAgaWYgKGNvdW50ICE9IHZhbHVlLmxlbmd0aCkge1xuXHQgICAgICAgICAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwiaW52YWxpZCBhcnJheSBsZW5ndGggZm9yIFwiICsgdHlwZSwgXCJ2YWx1ZVwiLCB2YWx1ZSk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHZhciByZXN1bHRfMSA9IFtdO1xuXHQgICAgICAgIHZhbHVlLmZvckVhY2goZnVuY3Rpb24gKHZhbHVlKSB7XG5cdCAgICAgICAgICAgIHJlc3VsdF8xLnB1c2goX3BhY2soYmFzZVR5cGVfMSwgdmFsdWUsIHRydWUpKTtcblx0ICAgICAgICB9KTtcblx0ICAgICAgICByZXR1cm4gKDAsIGxpYiQxLmNvbmNhdCkocmVzdWx0XzEpO1xuXHQgICAgfVxuXHQgICAgcmV0dXJuIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJpbnZhbGlkIHR5cGVcIiwgXCJ0eXBlXCIsIHR5cGUpO1xuXHR9XG5cdC8vIEBUT0RPOiBBcnJheSBFbnVtXG5cdGZ1bmN0aW9uIHBhY2sodHlwZXMsIHZhbHVlcykge1xuXHQgICAgaWYgKHR5cGVzLmxlbmd0aCAhPSB2YWx1ZXMubGVuZ3RoKSB7XG5cdCAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcIndyb25nIG51bWJlciBvZiB2YWx1ZXM7IGV4cGVjdGVkICR7IHR5cGVzLmxlbmd0aCB9XCIsIFwidmFsdWVzXCIsIHZhbHVlcyk7XG5cdCAgICB9XG5cdCAgICB2YXIgdGlnaHQgPSBbXTtcblx0ICAgIHR5cGVzLmZvckVhY2goZnVuY3Rpb24gKHR5cGUsIGluZGV4KSB7XG5cdCAgICAgICAgdGlnaHQucHVzaChfcGFjayh0eXBlLCB2YWx1ZXNbaW5kZXhdKSk7XG5cdCAgICB9KTtcblx0ICAgIHJldHVybiAoMCwgbGliJDEuaGV4bGlmeSkoKDAsIGxpYiQxLmNvbmNhdCkodGlnaHQpKTtcblx0fVxuXHRleHBvcnRzLnBhY2sgPSBwYWNrO1xuXHRmdW5jdGlvbiBrZWNjYWsyNTYodHlwZXMsIHZhbHVlcykge1xuXHQgICAgcmV0dXJuICgwLCBsaWIkNC5rZWNjYWsyNTYpKHBhY2sodHlwZXMsIHZhbHVlcykpO1xuXHR9XG5cdGV4cG9ydHMua2VjY2FrMjU2ID0ga2VjY2FrMjU2O1xuXHRmdW5jdGlvbiBzaGEyNTYodHlwZXMsIHZhbHVlcykge1xuXHQgICAgcmV0dXJuICgwLCBsaWIkaC5zaGEyNTYpKHBhY2sodHlwZXMsIHZhbHVlcykpO1xuXHR9XG5cdGV4cG9ydHMuc2hhMjU2ID0gc2hhMjU2O1xuXG5cdH0pO1xuXG5cdHZhciBpbmRleCRzID0gLypAX19QVVJFX18qL2dldERlZmF1bHRFeHBvcnRGcm9tQ2pzKGxpYiRzKTtcblxuXHR2YXIgX3ZlcnNpb24kTSA9IGNyZWF0ZUNvbW1vbmpzTW9kdWxlKGZ1bmN0aW9uIChtb2R1bGUsIGV4cG9ydHMpIHtcblx0XCJ1c2Ugc3RyaWN0XCI7XG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcblx0ZXhwb3J0cy52ZXJzaW9uID0gdm9pZCAwO1xuXHRleHBvcnRzLnZlcnNpb24gPSBcInVuaXRzLzUuNS4wXCI7XG5cblx0fSk7XG5cblx0dmFyIF92ZXJzaW9uJE4gPSAvKkBfX1BVUkVfXyovZ2V0RGVmYXVsdEV4cG9ydEZyb21DanMoX3ZlcnNpb24kTSk7XG5cblx0dmFyIGxpYiR0ID0gY3JlYXRlQ29tbW9uanNNb2R1bGUoZnVuY3Rpb24gKG1vZHVsZSwgZXhwb3J0cykge1xuXHRcInVzZSBzdHJpY3RcIjtcblx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuXHRleHBvcnRzLnBhcnNlRXRoZXIgPSBleHBvcnRzLmZvcm1hdEV0aGVyID0gZXhwb3J0cy5wYXJzZVVuaXRzID0gZXhwb3J0cy5mb3JtYXRVbml0cyA9IGV4cG9ydHMuY29tbWlmeSA9IHZvaWQgMDtcblxuXG5cblx0dmFyIGxvZ2dlciA9IG5ldyBsaWIuTG9nZ2VyKF92ZXJzaW9uJE0udmVyc2lvbik7XG5cdHZhciBuYW1lcyA9IFtcblx0ICAgIFwid2VpXCIsXG5cdCAgICBcImt3ZWlcIixcblx0ICAgIFwibXdlaVwiLFxuXHQgICAgXCJnd2VpXCIsXG5cdCAgICBcInN6YWJvXCIsXG5cdCAgICBcImZpbm5leVwiLFxuXHQgICAgXCJldGhlclwiLFxuXHRdO1xuXHQvLyBTb21lIGVudmlyb25tZW50cyBoYXZlIGlzc3VlcyB3aXRoIFJlZ0V4IHRoYXQgY29udGFpbiBiYWNrLXRyYWNraW5nLCBzbyB3ZSBjYW5ub3Rcblx0Ly8gdXNlIHRoZW0uXG5cdGZ1bmN0aW9uIGNvbW1pZnkodmFsdWUpIHtcblx0ICAgIHZhciBjb21wcyA9IFN0cmluZyh2YWx1ZSkuc3BsaXQoXCIuXCIpO1xuXHQgICAgaWYgKGNvbXBzLmxlbmd0aCA+IDIgfHwgIWNvbXBzWzBdLm1hdGNoKC9eLT9bMC05XSokLykgfHwgKGNvbXBzWzFdICYmICFjb21wc1sxXS5tYXRjaCgvXlswLTldKiQvKSkgfHwgdmFsdWUgPT09IFwiLlwiIHx8IHZhbHVlID09PSBcIi0uXCIpIHtcblx0ICAgICAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwiaW52YWxpZCB2YWx1ZVwiLCBcInZhbHVlXCIsIHZhbHVlKTtcblx0ICAgIH1cblx0ICAgIC8vIE1ha2Ugc3VyZSB3ZSBoYXZlIGF0IGxlYXN0IG9uZSB3aG9sZSBkaWdpdCAoMCBpZiBub25lKVxuXHQgICAgdmFyIHdob2xlID0gY29tcHNbMF07XG5cdCAgICB2YXIgbmVnYXRpdmUgPSBcIlwiO1xuXHQgICAgaWYgKHdob2xlLnN1YnN0cmluZygwLCAxKSA9PT0gXCItXCIpIHtcblx0ICAgICAgICBuZWdhdGl2ZSA9IFwiLVwiO1xuXHQgICAgICAgIHdob2xlID0gd2hvbGUuc3Vic3RyaW5nKDEpO1xuXHQgICAgfVxuXHQgICAgLy8gTWFrZSBzdXJlIHdlIGhhdmUgYXQgbGVhc3QgMSB3aG9sZSBkaWdpdCB3aXRoIG5vIGxlYWRpbmcgemVyb3Ncblx0ICAgIHdoaWxlICh3aG9sZS5zdWJzdHJpbmcoMCwgMSkgPT09IFwiMFwiKSB7XG5cdCAgICAgICAgd2hvbGUgPSB3aG9sZS5zdWJzdHJpbmcoMSk7XG5cdCAgICB9XG5cdCAgICBpZiAod2hvbGUgPT09IFwiXCIpIHtcblx0ICAgICAgICB3aG9sZSA9IFwiMFwiO1xuXHQgICAgfVxuXHQgICAgdmFyIHN1ZmZpeCA9IFwiXCI7XG5cdCAgICBpZiAoY29tcHMubGVuZ3RoID09PSAyKSB7XG5cdCAgICAgICAgc3VmZml4ID0gXCIuXCIgKyAoY29tcHNbMV0gfHwgXCIwXCIpO1xuXHQgICAgfVxuXHQgICAgd2hpbGUgKHN1ZmZpeC5sZW5ndGggPiAyICYmIHN1ZmZpeFtzdWZmaXgubGVuZ3RoIC0gMV0gPT09IFwiMFwiKSB7XG5cdCAgICAgICAgc3VmZml4ID0gc3VmZml4LnN1YnN0cmluZygwLCBzdWZmaXgubGVuZ3RoIC0gMSk7XG5cdCAgICB9XG5cdCAgICB2YXIgZm9ybWF0dGVkID0gW107XG5cdCAgICB3aGlsZSAod2hvbGUubGVuZ3RoKSB7XG5cdCAgICAgICAgaWYgKHdob2xlLmxlbmd0aCA8PSAzKSB7XG5cdCAgICAgICAgICAgIGZvcm1hdHRlZC51bnNoaWZ0KHdob2xlKTtcblx0ICAgICAgICAgICAgYnJlYWs7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGVsc2Uge1xuXHQgICAgICAgICAgICB2YXIgaW5kZXggPSB3aG9sZS5sZW5ndGggLSAzO1xuXHQgICAgICAgICAgICBmb3JtYXR0ZWQudW5zaGlmdCh3aG9sZS5zdWJzdHJpbmcoaW5kZXgpKTtcblx0ICAgICAgICAgICAgd2hvbGUgPSB3aG9sZS5zdWJzdHJpbmcoMCwgaW5kZXgpO1xuXHQgICAgICAgIH1cblx0ICAgIH1cblx0ICAgIHJldHVybiBuZWdhdGl2ZSArIGZvcm1hdHRlZC5qb2luKFwiLFwiKSArIHN1ZmZpeDtcblx0fVxuXHRleHBvcnRzLmNvbW1pZnkgPSBjb21taWZ5O1xuXHRmdW5jdGlvbiBmb3JtYXRVbml0cyh2YWx1ZSwgdW5pdE5hbWUpIHtcblx0ICAgIGlmICh0eXBlb2YgKHVuaXROYW1lKSA9PT0gXCJzdHJpbmdcIikge1xuXHQgICAgICAgIHZhciBpbmRleCA9IG5hbWVzLmluZGV4T2YodW5pdE5hbWUpO1xuXHQgICAgICAgIGlmIChpbmRleCAhPT0gLTEpIHtcblx0ICAgICAgICAgICAgdW5pdE5hbWUgPSAzICogaW5kZXg7XG5cdCAgICAgICAgfVxuXHQgICAgfVxuXHQgICAgcmV0dXJuICgwLCBsaWIkMi5mb3JtYXRGaXhlZCkodmFsdWUsICh1bml0TmFtZSAhPSBudWxsKSA/IHVuaXROYW1lIDogMTgpO1xuXHR9XG5cdGV4cG9ydHMuZm9ybWF0VW5pdHMgPSBmb3JtYXRVbml0cztcblx0ZnVuY3Rpb24gcGFyc2VVbml0cyh2YWx1ZSwgdW5pdE5hbWUpIHtcblx0ICAgIGlmICh0eXBlb2YgKHZhbHVlKSAhPT0gXCJzdHJpbmdcIikge1xuXHQgICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJ2YWx1ZSBtdXN0IGJlIGEgc3RyaW5nXCIsIFwidmFsdWVcIiwgdmFsdWUpO1xuXHQgICAgfVxuXHQgICAgaWYgKHR5cGVvZiAodW5pdE5hbWUpID09PSBcInN0cmluZ1wiKSB7XG5cdCAgICAgICAgdmFyIGluZGV4ID0gbmFtZXMuaW5kZXhPZih1bml0TmFtZSk7XG5cdCAgICAgICAgaWYgKGluZGV4ICE9PSAtMSkge1xuXHQgICAgICAgICAgICB1bml0TmFtZSA9IDMgKiBpbmRleDtcblx0ICAgICAgICB9XG5cdCAgICB9XG5cdCAgICByZXR1cm4gKDAsIGxpYiQyLnBhcnNlRml4ZWQpKHZhbHVlLCAodW5pdE5hbWUgIT0gbnVsbCkgPyB1bml0TmFtZSA6IDE4KTtcblx0fVxuXHRleHBvcnRzLnBhcnNlVW5pdHMgPSBwYXJzZVVuaXRzO1xuXHRmdW5jdGlvbiBmb3JtYXRFdGhlcih3ZWkpIHtcblx0ICAgIHJldHVybiBmb3JtYXRVbml0cyh3ZWksIDE4KTtcblx0fVxuXHRleHBvcnRzLmZvcm1hdEV0aGVyID0gZm9ybWF0RXRoZXI7XG5cdGZ1bmN0aW9uIHBhcnNlRXRoZXIoZXRoZXIpIHtcblx0ICAgIHJldHVybiBwYXJzZVVuaXRzKGV0aGVyLCAxOCk7XG5cdH1cblx0ZXhwb3J0cy5wYXJzZUV0aGVyID0gcGFyc2VFdGhlcjtcblxuXHR9KTtcblxuXHR2YXIgaW5kZXgkdCA9IC8qQF9fUFVSRV9fKi9nZXREZWZhdWx0RXhwb3J0RnJvbUNqcyhsaWIkdCk7XG5cblx0dmFyIHV0aWxzJDMgPSBjcmVhdGVDb21tb25qc01vZHVsZShmdW5jdGlvbiAobW9kdWxlLCBleHBvcnRzKSB7XG5cdFwidXNlIHN0cmljdFwiO1xuXHR2YXIgX19jcmVhdGVCaW5kaW5nID0gKGNvbW1vbmpzR2xvYmFsICYmIGNvbW1vbmpzR2xvYmFsLl9fY3JlYXRlQmluZGluZykgfHwgKE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcblx0ICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG5cdCAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgazIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIG1ba107IH0gfSk7XG5cdH0pIDogKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG5cdCAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuXHQgICAgb1trMl0gPSBtW2tdO1xuXHR9KSk7XG5cdHZhciBfX3NldE1vZHVsZURlZmF1bHQgPSAoY29tbW9uanNHbG9iYWwgJiYgY29tbW9uanNHbG9iYWwuX19zZXRNb2R1bGVEZWZhdWx0KSB8fCAoT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCB2KSB7XG5cdCAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgXCJkZWZhdWx0XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgdmFsdWU6IHYgfSk7XG5cdH0pIDogZnVuY3Rpb24obywgdikge1xuXHQgICAgb1tcImRlZmF1bHRcIl0gPSB2O1xuXHR9KTtcblx0dmFyIF9faW1wb3J0U3RhciA9IChjb21tb25qc0dsb2JhbCAmJiBjb21tb25qc0dsb2JhbC5fX2ltcG9ydFN0YXIpIHx8IGZ1bmN0aW9uIChtb2QpIHtcblx0ICAgIGlmIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpIHJldHVybiBtb2Q7XG5cdCAgICB2YXIgcmVzdWx0ID0ge307XG5cdCAgICBpZiAobW9kICE9IG51bGwpIGZvciAodmFyIGsgaW4gbW9kKSBpZiAoayAhPT0gXCJkZWZhdWx0XCIgJiYgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG1vZCwgaykpIF9fY3JlYXRlQmluZGluZyhyZXN1bHQsIG1vZCwgayk7XG5cdCAgICBfX3NldE1vZHVsZURlZmF1bHQocmVzdWx0LCBtb2QpO1xuXHQgICAgcmV0dXJuIHJlc3VsdDtcblx0fTtcblx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuXHRleHBvcnRzLmZvcm1hdEJ5dGVzMzJTdHJpbmcgPSBleHBvcnRzLlV0ZjhFcnJvckZ1bmNzID0gZXhwb3J0cy50b1V0ZjhTdHJpbmcgPSBleHBvcnRzLnRvVXRmOENvZGVQb2ludHMgPSBleHBvcnRzLnRvVXRmOEJ5dGVzID0gZXhwb3J0cy5fdG9Fc2NhcGVkVXRmOFN0cmluZyA9IGV4cG9ydHMubmFtZXByZXAgPSBleHBvcnRzLmhleERhdGFTbGljZSA9IGV4cG9ydHMuaGV4RGF0YUxlbmd0aCA9IGV4cG9ydHMuaGV4WmVyb1BhZCA9IGV4cG9ydHMuaGV4VmFsdWUgPSBleHBvcnRzLmhleFN0cmlwWmVyb3MgPSBleHBvcnRzLmhleENvbmNhdCA9IGV4cG9ydHMuaXNIZXhTdHJpbmcgPSBleHBvcnRzLmhleGxpZnkgPSBleHBvcnRzLmJhc2U2NCA9IGV4cG9ydHMuYmFzZTU4ID0gZXhwb3J0cy5UcmFuc2FjdGlvbkRlc2NyaXB0aW9uID0gZXhwb3J0cy5Mb2dEZXNjcmlwdGlvbiA9IGV4cG9ydHMuSW50ZXJmYWNlID0gZXhwb3J0cy5TaWduaW5nS2V5ID0gZXhwb3J0cy5IRE5vZGUgPSBleHBvcnRzLmRlZmF1bHRQYXRoID0gZXhwb3J0cy5pc0J5dGVzTGlrZSA9IGV4cG9ydHMuaXNCeXRlcyA9IGV4cG9ydHMuemVyb1BhZCA9IGV4cG9ydHMuc3RyaXBaZXJvcyA9IGV4cG9ydHMuY29uY2F0ID0gZXhwb3J0cy5hcnJheWlmeSA9IGV4cG9ydHMuc2hhbGxvd0NvcHkgPSBleHBvcnRzLnJlc29sdmVQcm9wZXJ0aWVzID0gZXhwb3J0cy5nZXRTdGF0aWMgPSBleHBvcnRzLmRlZmluZVJlYWRPbmx5ID0gZXhwb3J0cy5kZWVwQ29weSA9IGV4cG9ydHMuY2hlY2tQcm9wZXJ0aWVzID0gZXhwb3J0cy5wb2xsID0gZXhwb3J0cy5mZXRjaEpzb24gPSBleHBvcnRzLl9mZXRjaERhdGEgPSBleHBvcnRzLlJMUCA9IGV4cG9ydHMuTG9nZ2VyID0gZXhwb3J0cy5jaGVja1Jlc3VsdEVycm9ycyA9IGV4cG9ydHMuRm9ybWF0VHlwZXMgPSBleHBvcnRzLlBhcmFtVHlwZSA9IGV4cG9ydHMuRnVuY3Rpb25GcmFnbWVudCA9IGV4cG9ydHMuRXZlbnRGcmFnbWVudCA9IGV4cG9ydHMuRXJyb3JGcmFnbWVudCA9IGV4cG9ydHMuQ29uc3RydWN0b3JGcmFnbWVudCA9IGV4cG9ydHMuRnJhZ21lbnQgPSBleHBvcnRzLmRlZmF1bHRBYmlDb2RlciA9IGV4cG9ydHMuQWJpQ29kZXIgPSB2b2lkIDA7XG5cdGV4cG9ydHMuSW5kZXhlZCA9IGV4cG9ydHMuVXRmOEVycm9yUmVhc29uID0gZXhwb3J0cy5Vbmljb2RlTm9ybWFsaXphdGlvbkZvcm0gPSBleHBvcnRzLlN1cHBvcnRlZEFsZ29yaXRobSA9IGV4cG9ydHMubW5lbW9uaWNUb1NlZWQgPSBleHBvcnRzLmlzVmFsaWRNbmVtb25pYyA9IGV4cG9ydHMuZW50cm9weVRvTW5lbW9uaWMgPSBleHBvcnRzLm1uZW1vbmljVG9FbnRyb3B5ID0gZXhwb3J0cy5nZXRBY2NvdW50UGF0aCA9IGV4cG9ydHMudmVyaWZ5VHlwZWREYXRhID0gZXhwb3J0cy52ZXJpZnlNZXNzYWdlID0gZXhwb3J0cy5yZWNvdmVyUHVibGljS2V5ID0gZXhwb3J0cy5jb21wdXRlUHVibGljS2V5ID0gZXhwb3J0cy5yZWNvdmVyQWRkcmVzcyA9IGV4cG9ydHMuY29tcHV0ZUFkZHJlc3MgPSBleHBvcnRzLmdldEpzb25XYWxsZXRBZGRyZXNzID0gZXhwb3J0cy5UcmFuc2FjdGlvblR5cGVzID0gZXhwb3J0cy5zZXJpYWxpemVUcmFuc2FjdGlvbiA9IGV4cG9ydHMucGFyc2VUcmFuc2FjdGlvbiA9IGV4cG9ydHMuYWNjZXNzTGlzdGlmeSA9IGV4cG9ydHMuam9pblNpZ25hdHVyZSA9IGV4cG9ydHMuc3BsaXRTaWduYXR1cmUgPSBleHBvcnRzLnNvbGlkaXR5U2hhMjU2ID0gZXhwb3J0cy5zb2xpZGl0eUtlY2NhazI1NiA9IGV4cG9ydHMuc29saWRpdHlQYWNrID0gZXhwb3J0cy5zaHVmZmxlZCA9IGV4cG9ydHMucmFuZG9tQnl0ZXMgPSBleHBvcnRzLnNoYTUxMiA9IGV4cG9ydHMuc2hhMjU2ID0gZXhwb3J0cy5yaXBlbWQxNjAgPSBleHBvcnRzLmtlY2NhazI1NiA9IGV4cG9ydHMuY29tcHV0ZUhtYWMgPSBleHBvcnRzLmNvbW1pZnkgPSBleHBvcnRzLnBhcnNlVW5pdHMgPSBleHBvcnRzLmZvcm1hdFVuaXRzID0gZXhwb3J0cy5wYXJzZUV0aGVyID0gZXhwb3J0cy5mb3JtYXRFdGhlciA9IGV4cG9ydHMuaXNBZGRyZXNzID0gZXhwb3J0cy5nZXRDcmVhdGUyQWRkcmVzcyA9IGV4cG9ydHMuZ2V0Q29udHJhY3RBZGRyZXNzID0gZXhwb3J0cy5nZXRJY2FwQWRkcmVzcyA9IGV4cG9ydHMuZ2V0QWRkcmVzcyA9IGV4cG9ydHMuX1R5cGVkRGF0YUVuY29kZXIgPSBleHBvcnRzLmlkID0gZXhwb3J0cy5pc1ZhbGlkTmFtZSA9IGV4cG9ydHMubmFtZWhhc2ggPSBleHBvcnRzLmhhc2hNZXNzYWdlID0gZXhwb3J0cy5wYXJzZUJ5dGVzMzJTdHJpbmcgPSB2b2lkIDA7XG5cblx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiQWJpQ29kZXJcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGxpYiRhLkFiaUNvZGVyOyB9IH0pO1xuXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJjaGVja1Jlc3VsdEVycm9yc1wiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gbGliJGEuY2hlY2tSZXN1bHRFcnJvcnM7IH0gfSk7XG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkNvbnN0cnVjdG9yRnJhZ21lbnRcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGxpYiRhLkNvbnN0cnVjdG9yRnJhZ21lbnQ7IH0gfSk7XG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImRlZmF1bHRBYmlDb2RlclwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gbGliJGEuZGVmYXVsdEFiaUNvZGVyOyB9IH0pO1xuXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJFcnJvckZyYWdtZW50XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBsaWIkYS5FcnJvckZyYWdtZW50OyB9IH0pO1xuXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJFdmVudEZyYWdtZW50XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBsaWIkYS5FdmVudEZyYWdtZW50OyB9IH0pO1xuXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJGb3JtYXRUeXBlc1wiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gbGliJGEuRm9ybWF0VHlwZXM7IH0gfSk7XG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkZyYWdtZW50XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBsaWIkYS5GcmFnbWVudDsgfSB9KTtcblx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiRnVuY3Rpb25GcmFnbWVudFwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gbGliJGEuRnVuY3Rpb25GcmFnbWVudDsgfSB9KTtcblx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiSW5kZXhlZFwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gbGliJGEuSW5kZXhlZDsgfSB9KTtcblx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiSW50ZXJmYWNlXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBsaWIkYS5JbnRlcmZhY2U7IH0gfSk7XG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkxvZ0Rlc2NyaXB0aW9uXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBsaWIkYS5Mb2dEZXNjcmlwdGlvbjsgfSB9KTtcblx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiUGFyYW1UeXBlXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBsaWIkYS5QYXJhbVR5cGU7IH0gfSk7XG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlRyYW5zYWN0aW9uRGVzY3JpcHRpb25cIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGxpYiRhLlRyYW5zYWN0aW9uRGVzY3JpcHRpb247IH0gfSk7XG5cblx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiZ2V0QWRkcmVzc1wiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gbGliJDYuZ2V0QWRkcmVzczsgfSB9KTtcblx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiZ2V0Q3JlYXRlMkFkZHJlc3NcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGxpYiQ2LmdldENyZWF0ZTJBZGRyZXNzOyB9IH0pO1xuXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJnZXRDb250cmFjdEFkZHJlc3NcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGxpYiQ2LmdldENvbnRyYWN0QWRkcmVzczsgfSB9KTtcblx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiZ2V0SWNhcEFkZHJlc3NcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGxpYiQ2LmdldEljYXBBZGRyZXNzOyB9IH0pO1xuXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJpc0FkZHJlc3NcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGxpYiQ2LmlzQWRkcmVzczsgfSB9KTtcblx0dmFyIGJhc2U2NCA9IF9faW1wb3J0U3RhcihsaWIkcCk7XG5cdGV4cG9ydHMuYmFzZTY0ID0gYmFzZTY0O1xuXG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImJhc2U1OFwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gbGliJGcuQmFzZTU4OyB9IH0pO1xuXG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImFycmF5aWZ5XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBsaWIkMS5hcnJheWlmeTsgfSB9KTtcblx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiY29uY2F0XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBsaWIkMS5jb25jYXQ7IH0gfSk7XG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImhleENvbmNhdFwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gbGliJDEuaGV4Q29uY2F0OyB9IH0pO1xuXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJoZXhEYXRhU2xpY2VcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGxpYiQxLmhleERhdGFTbGljZTsgfSB9KTtcblx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiaGV4RGF0YUxlbmd0aFwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gbGliJDEuaGV4RGF0YUxlbmd0aDsgfSB9KTtcblx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiaGV4bGlmeVwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gbGliJDEuaGV4bGlmeTsgfSB9KTtcblx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiaGV4U3RyaXBaZXJvc1wiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gbGliJDEuaGV4U3RyaXBaZXJvczsgfSB9KTtcblx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiaGV4VmFsdWVcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGxpYiQxLmhleFZhbHVlOyB9IH0pO1xuXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJoZXhaZXJvUGFkXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBsaWIkMS5oZXhaZXJvUGFkOyB9IH0pO1xuXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJpc0J5dGVzXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBsaWIkMS5pc0J5dGVzOyB9IH0pO1xuXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJpc0J5dGVzTGlrZVwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gbGliJDEuaXNCeXRlc0xpa2U7IH0gfSk7XG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImlzSGV4U3RyaW5nXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBsaWIkMS5pc0hleFN0cmluZzsgfSB9KTtcblx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiam9pblNpZ25hdHVyZVwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gbGliJDEuam9pblNpZ25hdHVyZTsgfSB9KTtcblx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiemVyb1BhZFwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gbGliJDEuemVyb1BhZDsgfSB9KTtcblx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwic3BsaXRTaWduYXR1cmVcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGxpYiQxLnNwbGl0U2lnbmF0dXJlOyB9IH0pO1xuXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJzdHJpcFplcm9zXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBsaWIkMS5zdHJpcFplcm9zOyB9IH0pO1xuXG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9UeXBlZERhdGFFbmNvZGVyXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBsaWIkOS5fVHlwZWREYXRhRW5jb2RlcjsgfSB9KTtcblx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiaGFzaE1lc3NhZ2VcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGxpYiQ5Lmhhc2hNZXNzYWdlOyB9IH0pO1xuXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJpZFwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gbGliJDkuaWQ7IH0gfSk7XG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImlzVmFsaWROYW1lXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBsaWIkOS5pc1ZhbGlkTmFtZTsgfSB9KTtcblx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwibmFtZWhhc2hcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGxpYiQ5Lm5hbWVoYXNoOyB9IH0pO1xuXG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImRlZmF1bHRQYXRoXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBsaWIkay5kZWZhdWx0UGF0aDsgfSB9KTtcblx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiZW50cm9weVRvTW5lbW9uaWNcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGxpYiRrLmVudHJvcHlUb01uZW1vbmljOyB9IH0pO1xuXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJnZXRBY2NvdW50UGF0aFwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gbGliJGsuZ2V0QWNjb3VudFBhdGg7IH0gfSk7XG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkhETm9kZVwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gbGliJGsuSEROb2RlOyB9IH0pO1xuXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJpc1ZhbGlkTW5lbW9uaWNcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGxpYiRrLmlzVmFsaWRNbmVtb25pYzsgfSB9KTtcblx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwibW5lbW9uaWNUb0VudHJvcHlcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGxpYiRrLm1uZW1vbmljVG9FbnRyb3B5OyB9IH0pO1xuXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJtbmVtb25pY1RvU2VlZFwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gbGliJGsubW5lbW9uaWNUb1NlZWQ7IH0gfSk7XG5cblx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiZ2V0SnNvbldhbGxldEFkZHJlc3NcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGxpYiRtLmdldEpzb25XYWxsZXRBZGRyZXNzOyB9IH0pO1xuXG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImtlY2NhazI1NlwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gbGliJDQua2VjY2FrMjU2OyB9IH0pO1xuXG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkxvZ2dlclwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gbGliLkxvZ2dlcjsgfSB9KTtcblxuXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJjb21wdXRlSG1hY1wiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gbGliJGguY29tcHV0ZUhtYWM7IH0gfSk7XG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcInJpcGVtZDE2MFwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gbGliJGgucmlwZW1kMTYwOyB9IH0pO1xuXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJzaGEyNTZcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGxpYiRoLnNoYTI1NjsgfSB9KTtcblx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwic2hhNTEyXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBsaWIkaC5zaGE1MTI7IH0gfSk7XG5cblx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwic29saWRpdHlLZWNjYWsyNTZcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGxpYiRzLmtlY2NhazI1NjsgfSB9KTtcblx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwic29saWRpdHlQYWNrXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBsaWIkcy5wYWNrOyB9IH0pO1xuXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJzb2xpZGl0eVNoYTI1NlwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gbGliJHMuc2hhMjU2OyB9IH0pO1xuXG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcInJhbmRvbUJ5dGVzXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBsaWIkbC5yYW5kb21CeXRlczsgfSB9KTtcblx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwic2h1ZmZsZWRcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGxpYiRsLnNodWZmbGVkOyB9IH0pO1xuXG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImNoZWNrUHJvcGVydGllc1wiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gbGliJDMuY2hlY2tQcm9wZXJ0aWVzOyB9IH0pO1xuXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJkZWVwQ29weVwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gbGliJDMuZGVlcENvcHk7IH0gfSk7XG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImRlZmluZVJlYWRPbmx5XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBsaWIkMy5kZWZpbmVSZWFkT25seTsgfSB9KTtcblx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiZ2V0U3RhdGljXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBsaWIkMy5nZXRTdGF0aWM7IH0gfSk7XG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcInJlc29sdmVQcm9wZXJ0aWVzXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBsaWIkMy5yZXNvbHZlUHJvcGVydGllczsgfSB9KTtcblx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwic2hhbGxvd0NvcHlcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGxpYiQzLnNoYWxsb3dDb3B5OyB9IH0pO1xuXHR2YXIgUkxQID0gX19pbXBvcnRTdGFyKGxpYiQ1KTtcblx0ZXhwb3J0cy5STFAgPSBSTFA7XG5cblx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiY29tcHV0ZVB1YmxpY0tleVwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gbGliJGQuY29tcHV0ZVB1YmxpY0tleTsgfSB9KTtcblx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwicmVjb3ZlclB1YmxpY0tleVwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gbGliJGQucmVjb3ZlclB1YmxpY0tleTsgfSB9KTtcblx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiU2lnbmluZ0tleVwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gbGliJGQuU2lnbmluZ0tleTsgfSB9KTtcblxuXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJmb3JtYXRCeXRlczMyU3RyaW5nXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBsaWIkOC5mb3JtYXRCeXRlczMyU3RyaW5nOyB9IH0pO1xuXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJuYW1lcHJlcFwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gbGliJDgubmFtZXByZXA7IH0gfSk7XG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcInBhcnNlQnl0ZXMzMlN0cmluZ1wiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gbGliJDgucGFyc2VCeXRlczMyU3RyaW5nOyB9IH0pO1xuXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfdG9Fc2NhcGVkVXRmOFN0cmluZ1wiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gbGliJDguX3RvRXNjYXBlZFV0ZjhTdHJpbmc7IH0gfSk7XG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcInRvVXRmOEJ5dGVzXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBsaWIkOC50b1V0ZjhCeXRlczsgfSB9KTtcblx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwidG9VdGY4Q29kZVBvaW50c1wiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gbGliJDgudG9VdGY4Q29kZVBvaW50czsgfSB9KTtcblx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwidG9VdGY4U3RyaW5nXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBsaWIkOC50b1V0ZjhTdHJpbmc7IH0gfSk7XG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlV0ZjhFcnJvckZ1bmNzXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBsaWIkOC5VdGY4RXJyb3JGdW5jczsgfSB9KTtcblxuXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJhY2Nlc3NMaXN0aWZ5XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBsaWIkZS5hY2Nlc3NMaXN0aWZ5OyB9IH0pO1xuXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJjb21wdXRlQWRkcmVzc1wiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gbGliJGUuY29tcHV0ZUFkZHJlc3M7IH0gfSk7XG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcInBhcnNlVHJhbnNhY3Rpb25cIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGxpYiRlLnBhcnNlOyB9IH0pO1xuXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJyZWNvdmVyQWRkcmVzc1wiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gbGliJGUucmVjb3ZlckFkZHJlc3M7IH0gfSk7XG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcInNlcmlhbGl6ZVRyYW5zYWN0aW9uXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBsaWIkZS5zZXJpYWxpemU7IH0gfSk7XG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlRyYW5zYWN0aW9uVHlwZXNcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGxpYiRlLlRyYW5zYWN0aW9uVHlwZXM7IH0gfSk7XG5cblx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiY29tbWlmeVwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gbGliJHQuY29tbWlmeTsgfSB9KTtcblx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiZm9ybWF0RXRoZXJcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGxpYiR0LmZvcm1hdEV0aGVyOyB9IH0pO1xuXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJwYXJzZUV0aGVyXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBsaWIkdC5wYXJzZUV0aGVyOyB9IH0pO1xuXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJmb3JtYXRVbml0c1wiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gbGliJHQuZm9ybWF0VW5pdHM7IH0gfSk7XG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcInBhcnNlVW5pdHNcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGxpYiR0LnBhcnNlVW5pdHM7IH0gfSk7XG5cblx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwidmVyaWZ5TWVzc2FnZVwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gbGliJG4udmVyaWZ5TWVzc2FnZTsgfSB9KTtcblx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwidmVyaWZ5VHlwZWREYXRhXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBsaWIkbi52ZXJpZnlUeXBlZERhdGE7IH0gfSk7XG5cblx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX2ZldGNoRGF0YVwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gbGliJHEuX2ZldGNoRGF0YTsgfSB9KTtcblx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiZmV0Y2hKc29uXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBsaWIkcS5mZXRjaEpzb247IH0gfSk7XG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcInBvbGxcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGxpYiRxLnBvbGw7IH0gfSk7XG5cdC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXHQvLyBFbnVtc1xuXHR2YXIgc2hhMl8yID0gbGliJGg7XG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlN1cHBvcnRlZEFsZ29yaXRobVwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gc2hhMl8yLlN1cHBvcnRlZEFsZ29yaXRobTsgfSB9KTtcblx0dmFyIHN0cmluZ3NfMiA9IGxpYiQ4O1xuXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJVbmljb2RlTm9ybWFsaXphdGlvbkZvcm1cIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHN0cmluZ3NfMi5Vbmljb2RlTm9ybWFsaXphdGlvbkZvcm07IH0gfSk7XG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlV0ZjhFcnJvclJlYXNvblwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gc3RyaW5nc18yLlV0ZjhFcnJvclJlYXNvbjsgfSB9KTtcblxuXHR9KTtcblxuXHR2YXIgdXRpbHMkNCA9IC8qQF9fUFVSRV9fKi9nZXREZWZhdWx0RXhwb3J0RnJvbUNqcyh1dGlscyQzKTtcblxuXHR2YXIgX3ZlcnNpb24kTyA9IGNyZWF0ZUNvbW1vbmpzTW9kdWxlKGZ1bmN0aW9uIChtb2R1bGUsIGV4cG9ydHMpIHtcblx0XCJ1c2Ugc3RyaWN0XCI7XG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcblx0ZXhwb3J0cy52ZXJzaW9uID0gdm9pZCAwO1xuXHRleHBvcnRzLnZlcnNpb24gPSBcImV0aGVycy81LjUuMVwiO1xuXG5cdH0pO1xuXG5cdHZhciBfdmVyc2lvbiRQID0gLypAX19QVVJFX18qL2dldERlZmF1bHRFeHBvcnRGcm9tQ2pzKF92ZXJzaW9uJE8pO1xuXG5cdHZhciBldGhlcnMgPSBjcmVhdGVDb21tb25qc01vZHVsZShmdW5jdGlvbiAobW9kdWxlLCBleHBvcnRzKSB7XG5cdFwidXNlIHN0cmljdFwiO1xuXHR2YXIgX19jcmVhdGVCaW5kaW5nID0gKGNvbW1vbmpzR2xvYmFsICYmIGNvbW1vbmpzR2xvYmFsLl9fY3JlYXRlQmluZGluZykgfHwgKE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcblx0ICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG5cdCAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgazIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIG1ba107IH0gfSk7XG5cdH0pIDogKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG5cdCAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuXHQgICAgb1trMl0gPSBtW2tdO1xuXHR9KSk7XG5cdHZhciBfX3NldE1vZHVsZURlZmF1bHQgPSAoY29tbW9uanNHbG9iYWwgJiYgY29tbW9uanNHbG9iYWwuX19zZXRNb2R1bGVEZWZhdWx0KSB8fCAoT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCB2KSB7XG5cdCAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgXCJkZWZhdWx0XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgdmFsdWU6IHYgfSk7XG5cdH0pIDogZnVuY3Rpb24obywgdikge1xuXHQgICAgb1tcImRlZmF1bHRcIl0gPSB2O1xuXHR9KTtcblx0dmFyIF9faW1wb3J0U3RhciA9IChjb21tb25qc0dsb2JhbCAmJiBjb21tb25qc0dsb2JhbC5fX2ltcG9ydFN0YXIpIHx8IGZ1bmN0aW9uIChtb2QpIHtcblx0ICAgIGlmIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpIHJldHVybiBtb2Q7XG5cdCAgICB2YXIgcmVzdWx0ID0ge307XG5cdCAgICBpZiAobW9kICE9IG51bGwpIGZvciAodmFyIGsgaW4gbW9kKSBpZiAoayAhPT0gXCJkZWZhdWx0XCIgJiYgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG1vZCwgaykpIF9fY3JlYXRlQmluZGluZyhyZXN1bHQsIG1vZCwgayk7XG5cdCAgICBfX3NldE1vZHVsZURlZmF1bHQocmVzdWx0LCBtb2QpO1xuXHQgICAgcmV0dXJuIHJlc3VsdDtcblx0fTtcblx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuXHRleHBvcnRzLldvcmRsaXN0ID0gZXhwb3J0cy52ZXJzaW9uID0gZXhwb3J0cy53b3JkbGlzdHMgPSBleHBvcnRzLnV0aWxzID0gZXhwb3J0cy5sb2dnZXIgPSBleHBvcnRzLmVycm9ycyA9IGV4cG9ydHMuY29uc3RhbnRzID0gZXhwb3J0cy5GaXhlZE51bWJlciA9IGV4cG9ydHMuQmlnTnVtYmVyID0gZXhwb3J0cy5Db250cmFjdEZhY3RvcnkgPSBleHBvcnRzLkNvbnRyYWN0ID0gZXhwb3J0cy5CYXNlQ29udHJhY3QgPSBleHBvcnRzLnByb3ZpZGVycyA9IGV4cG9ydHMuZ2V0RGVmYXVsdFByb3ZpZGVyID0gZXhwb3J0cy5Wb2lkU2lnbmVyID0gZXhwb3J0cy5XYWxsZXQgPSBleHBvcnRzLlNpZ25lciA9IHZvaWQgMDtcblxuXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJCYXNlQ29udHJhY3RcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGxpYiRmLkJhc2VDb250cmFjdDsgfSB9KTtcblx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiQ29udHJhY3RcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGxpYiRmLkNvbnRyYWN0OyB9IH0pO1xuXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJDb250cmFjdEZhY3RvcnlcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGxpYiRmLkNvbnRyYWN0RmFjdG9yeTsgfSB9KTtcblxuXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJCaWdOdW1iZXJcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGxpYiQyLkJpZ051bWJlcjsgfSB9KTtcblx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiRml4ZWROdW1iZXJcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGxpYiQyLkZpeGVkTnVtYmVyOyB9IH0pO1xuXG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlNpZ25lclwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gbGliJGMuU2lnbmVyOyB9IH0pO1xuXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJWb2lkU2lnbmVyXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBsaWIkYy5Wb2lkU2lnbmVyOyB9IH0pO1xuXG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIldhbGxldFwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gbGliJG4uV2FsbGV0OyB9IH0pO1xuXHR2YXIgY29uc3RhbnRzID0gX19pbXBvcnRTdGFyKGxpYiQ3KTtcblx0ZXhwb3J0cy5jb25zdGFudHMgPSBjb25zdGFudHM7XG5cdHZhciBwcm92aWRlcnMgPSBfX2ltcG9ydFN0YXIobGliJHIpO1xuXHRleHBvcnRzLnByb3ZpZGVycyA9IHByb3ZpZGVycztcblx0dmFyIHByb3ZpZGVyc18xID0gbGliJHI7XG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImdldERlZmF1bHRQcm92aWRlclwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gcHJvdmlkZXJzXzEuZ2V0RGVmYXVsdFByb3ZpZGVyOyB9IH0pO1xuXG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIldvcmRsaXN0XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBsaWIkai5Xb3JkbGlzdDsgfSB9KTtcblx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwid29yZGxpc3RzXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBsaWIkai53b3JkbGlzdHM7IH0gfSk7XG5cdHZhciB1dGlscyA9IF9faW1wb3J0U3Rhcih1dGlscyQzKTtcblx0ZXhwb3J0cy51dGlscyA9IHV0aWxzO1xuXG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImVycm9yc1wiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gbGliLkVycm9yQ29kZTsgfSB9KTtcblx0Ly8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5cdC8vIENvbXBpbGUtVGltZSBDb25zdGFudHNcblx0Ly8gVGhpcyBpcyBnZW5lcmF0ZWQgYnkgXCJucG0gcnVuIGRpc3RcIlxuXG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcInZlcnNpb25cIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIF92ZXJzaW9uJE8udmVyc2lvbjsgfSB9KTtcblx0dmFyIGxvZ2dlciA9IG5ldyBsaWIuTG9nZ2VyKF92ZXJzaW9uJE8udmVyc2lvbik7XG5cdGV4cG9ydHMubG9nZ2VyID0gbG9nZ2VyO1xuXG5cdH0pO1xuXG5cdHZhciBldGhlcnMkMSA9IC8qQF9fUFVSRV9fKi9nZXREZWZhdWx0RXhwb3J0RnJvbUNqcyhldGhlcnMpO1xuXG5cdHZhciBsaWIkdSA9IGNyZWF0ZUNvbW1vbmpzTW9kdWxlKGZ1bmN0aW9uIChtb2R1bGUsIGV4cG9ydHMpIHtcblx0XCJ1c2Ugc3RyaWN0XCI7XG5cdHZhciBfX2NyZWF0ZUJpbmRpbmcgPSAoY29tbW9uanNHbG9iYWwgJiYgY29tbW9uanNHbG9iYWwuX19jcmVhdGVCaW5kaW5nKSB8fCAoT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuXHQgICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcblx0ICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBrMiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gbVtrXTsgfSB9KTtcblx0fSkgOiAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcblx0ICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG5cdCAgICBvW2syXSA9IG1ba107XG5cdH0pKTtcblx0dmFyIF9fc2V0TW9kdWxlRGVmYXVsdCA9IChjb21tb25qc0dsb2JhbCAmJiBjb21tb25qc0dsb2JhbC5fX3NldE1vZHVsZURlZmF1bHQpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIHYpIHtcblx0ICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBcImRlZmF1bHRcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCB2YWx1ZTogdiB9KTtcblx0fSkgOiBmdW5jdGlvbihvLCB2KSB7XG5cdCAgICBvW1wiZGVmYXVsdFwiXSA9IHY7XG5cdH0pO1xuXHR2YXIgX19pbXBvcnRTdGFyID0gKGNvbW1vbmpzR2xvYmFsICYmIGNvbW1vbmpzR2xvYmFsLl9faW1wb3J0U3RhcikgfHwgZnVuY3Rpb24gKG1vZCkge1xuXHQgICAgaWYgKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgcmV0dXJuIG1vZDtcblx0ICAgIHZhciByZXN1bHQgPSB7fTtcblx0ICAgIGlmIChtb2QgIT0gbnVsbCkgZm9yICh2YXIgayBpbiBtb2QpIGlmIChrICE9PSBcImRlZmF1bHRcIiAmJiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwobW9kLCBrKSkgX19jcmVhdGVCaW5kaW5nKHJlc3VsdCwgbW9kLCBrKTtcblx0ICAgIF9fc2V0TW9kdWxlRGVmYXVsdChyZXN1bHQsIG1vZCk7XG5cdCAgICByZXR1cm4gcmVzdWx0O1xuXHR9O1xuXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5cdGV4cG9ydHMuV29yZGxpc3QgPSBleHBvcnRzLnZlcnNpb24gPSBleHBvcnRzLndvcmRsaXN0cyA9IGV4cG9ydHMudXRpbHMgPSBleHBvcnRzLmxvZ2dlciA9IGV4cG9ydHMuZXJyb3JzID0gZXhwb3J0cy5jb25zdGFudHMgPSBleHBvcnRzLkZpeGVkTnVtYmVyID0gZXhwb3J0cy5CaWdOdW1iZXIgPSBleHBvcnRzLkNvbnRyYWN0RmFjdG9yeSA9IGV4cG9ydHMuQ29udHJhY3QgPSBleHBvcnRzLkJhc2VDb250cmFjdCA9IGV4cG9ydHMucHJvdmlkZXJzID0gZXhwb3J0cy5nZXREZWZhdWx0UHJvdmlkZXIgPSBleHBvcnRzLlZvaWRTaWduZXIgPSBleHBvcnRzLldhbGxldCA9IGV4cG9ydHMuU2lnbmVyID0gZXhwb3J0cy5ldGhlcnMgPSB2b2lkIDA7XG5cdC8vIFRvIG1vZGlmeSB0aGlzIGZpbGUsIHlvdSBtdXN0IHVwZGF0ZSAuL21pc2MvYWRtaW4vbGliL2NtZHMvdXBkYXRlLWV4cG9ydHMuanNcblx0dmFyIGV0aGVycyQxID0gX19pbXBvcnRTdGFyKGV0aGVycyk7XG5cdGV4cG9ydHMuZXRoZXJzID0gZXRoZXJzJDE7XG5cdHRyeSB7XG5cdCAgICB2YXIgYW55R2xvYmFsID0gd2luZG93O1xuXHQgICAgaWYgKGFueUdsb2JhbC5fZXRoZXJzID09IG51bGwpIHtcblx0ICAgICAgICBhbnlHbG9iYWwuX2V0aGVycyA9IGV0aGVycyQxO1xuXHQgICAgfVxuXHR9XG5cdGNhdGNoIChlcnJvcikgeyB9XG5cdHZhciBldGhlcnNfMSA9IGV0aGVycztcblx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiU2lnbmVyXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBldGhlcnNfMS5TaWduZXI7IH0gfSk7XG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIldhbGxldFwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gZXRoZXJzXzEuV2FsbGV0OyB9IH0pO1xuXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJWb2lkU2lnbmVyXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBldGhlcnNfMS5Wb2lkU2lnbmVyOyB9IH0pO1xuXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJnZXREZWZhdWx0UHJvdmlkZXJcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGV0aGVyc18xLmdldERlZmF1bHRQcm92aWRlcjsgfSB9KTtcblx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwicHJvdmlkZXJzXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBldGhlcnNfMS5wcm92aWRlcnM7IH0gfSk7XG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkJhc2VDb250cmFjdFwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gZXRoZXJzXzEuQmFzZUNvbnRyYWN0OyB9IH0pO1xuXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJDb250cmFjdFwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gZXRoZXJzXzEuQ29udHJhY3Q7IH0gfSk7XG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkNvbnRyYWN0RmFjdG9yeVwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gZXRoZXJzXzEuQ29udHJhY3RGYWN0b3J5OyB9IH0pO1xuXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJCaWdOdW1iZXJcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGV0aGVyc18xLkJpZ051bWJlcjsgfSB9KTtcblx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiRml4ZWROdW1iZXJcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGV0aGVyc18xLkZpeGVkTnVtYmVyOyB9IH0pO1xuXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJjb25zdGFudHNcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGV0aGVyc18xLmNvbnN0YW50czsgfSB9KTtcblx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiZXJyb3JzXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBldGhlcnNfMS5lcnJvcnM7IH0gfSk7XG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImxvZ2dlclwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gZXRoZXJzXzEubG9nZ2VyOyB9IH0pO1xuXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJ1dGlsc1wiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gZXRoZXJzXzEudXRpbHM7IH0gfSk7XG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIndvcmRsaXN0c1wiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gZXRoZXJzXzEud29yZGxpc3RzOyB9IH0pO1xuXHQvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cblx0Ly8gQ29tcGlsZS1UaW1lIENvbnN0YW50c1xuXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJ2ZXJzaW9uXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBldGhlcnNfMS52ZXJzaW9uOyB9IH0pO1xuXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJXb3JkbGlzdFwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gZXRoZXJzXzEuV29yZGxpc3Q7IH0gfSk7XG5cblx0fSk7XG5cblx0dmFyIGluZGV4JHUgPSAvKkBfX1BVUkVfXyovZ2V0RGVmYXVsdEV4cG9ydEZyb21DanMobGliJHUpO1xuXG5cdHJldHVybiBpbmRleCR1O1xuXG59KSkpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZXRoZXJzLnVtZC5qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../node_modules/ethers/dist/ethers.umd.js\n");

/***/ }),

/***/ "../node_modules/process/browser.js":
/*!******************************************!*\
  !*** ../node_modules/process/browser.js ***!
  \******************************************/
/***/ (function(module) {

eval("// shim for using process in browser\nvar process = module.exports = {};\n\n// cached from whatever global is present so that test runners that stub it\n// don't break things.  But we need to wrap it in a try catch in case it is\n// wrapped in strict mode code which doesn't define any globals.  It's inside a\n// function because try/catches deoptimize in certain engines.\n\nvar cachedSetTimeout;\nvar cachedClearTimeout;\n\nfunction defaultSetTimout() {\n    throw new Error('setTimeout has not been defined');\n}\nfunction defaultClearTimeout () {\n    throw new Error('clearTimeout has not been defined');\n}\n(function () {\n    try {\n        if (typeof setTimeout === 'function') {\n            cachedSetTimeout = setTimeout;\n        } else {\n            cachedSetTimeout = defaultSetTimout;\n        }\n    } catch (e) {\n        cachedSetTimeout = defaultSetTimout;\n    }\n    try {\n        if (typeof clearTimeout === 'function') {\n            cachedClearTimeout = clearTimeout;\n        } else {\n            cachedClearTimeout = defaultClearTimeout;\n        }\n    } catch (e) {\n        cachedClearTimeout = defaultClearTimeout;\n    }\n} ())\nfunction runTimeout(fun) {\n    if (cachedSetTimeout === setTimeout) {\n        //normal enviroments in sane situations\n        return setTimeout(fun, 0);\n    }\n    // if setTimeout wasn't available but was latter defined\n    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\n        cachedSetTimeout = setTimeout;\n        return setTimeout(fun, 0);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedSetTimeout(fun, 0);\n    } catch(e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\n            return cachedSetTimeout.call(null, fun, 0);\n        } catch(e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\n            return cachedSetTimeout.call(this, fun, 0);\n        }\n    }\n\n\n}\nfunction runClearTimeout(marker) {\n    if (cachedClearTimeout === clearTimeout) {\n        //normal enviroments in sane situations\n        return clearTimeout(marker);\n    }\n    // if clearTimeout wasn't available but was latter defined\n    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\n        cachedClearTimeout = clearTimeout;\n        return clearTimeout(marker);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedClearTimeout(marker);\n    } catch (e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\n            return cachedClearTimeout.call(null, marker);\n        } catch (e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\n            // Some versions of I.E. have different rules for clearTimeout vs setTimeout\n            return cachedClearTimeout.call(this, marker);\n        }\n    }\n\n\n\n}\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n    if (!draining || !currentQueue) {\n        return;\n    }\n    draining = false;\n    if (currentQueue.length) {\n        queue = currentQueue.concat(queue);\n    } else {\n        queueIndex = -1;\n    }\n    if (queue.length) {\n        drainQueue();\n    }\n}\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    var timeout = runTimeout(cleanUpNextTick);\n    draining = true;\n\n    var len = queue.length;\n    while(len) {\n        currentQueue = queue;\n        queue = [];\n        while (++queueIndex < len) {\n            if (currentQueue) {\n                currentQueue[queueIndex].run();\n            }\n        }\n        queueIndex = -1;\n        len = queue.length;\n    }\n    currentQueue = null;\n    draining = false;\n    runClearTimeout(timeout);\n}\n\nprocess.nextTick = function (fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) {\n        for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n        }\n    }\n    queue.push(new Item(fun, args));\n    if (queue.length === 1 && !draining) {\n        runTimeout(drainQueue);\n    }\n};\n\n// v8 likes predictible objects\nfunction Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\nItem.prototype.run = function () {\n    this.fun.apply(null, this.array);\n};\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\nprocess.prependListener = noop;\nprocess.prependOnceListener = noop;\n\nprocess.listeners = function (name) { return [] }\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function() { return 0; };\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vbm9kZV9tb2R1bGVzL3Byb2Nlc3MvYnJvd3Nlci5qcy5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLHNCQUFzQjtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0Qjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsc0NBQXNDOztBQUV0QztBQUNBO0FBQ0E7O0FBRUEsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi4vbm9kZV9tb2R1bGVzL3Byb2Nlc3MvYnJvd3Nlci5qcz9lNDhiIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIHNoaW0gZm9yIHVzaW5nIHByb2Nlc3MgaW4gYnJvd3NlclxudmFyIHByb2Nlc3MgPSBtb2R1bGUuZXhwb3J0cyA9IHt9O1xuXG4vLyBjYWNoZWQgZnJvbSB3aGF0ZXZlciBnbG9iYWwgaXMgcHJlc2VudCBzbyB0aGF0IHRlc3QgcnVubmVycyB0aGF0IHN0dWIgaXRcbi8vIGRvbid0IGJyZWFrIHRoaW5ncy4gIEJ1dCB3ZSBuZWVkIHRvIHdyYXAgaXQgaW4gYSB0cnkgY2F0Y2ggaW4gY2FzZSBpdCBpc1xuLy8gd3JhcHBlZCBpbiBzdHJpY3QgbW9kZSBjb2RlIHdoaWNoIGRvZXNuJ3QgZGVmaW5lIGFueSBnbG9iYWxzLiAgSXQncyBpbnNpZGUgYVxuLy8gZnVuY3Rpb24gYmVjYXVzZSB0cnkvY2F0Y2hlcyBkZW9wdGltaXplIGluIGNlcnRhaW4gZW5naW5lcy5cblxudmFyIGNhY2hlZFNldFRpbWVvdXQ7XG52YXIgY2FjaGVkQ2xlYXJUaW1lb3V0O1xuXG5mdW5jdGlvbiBkZWZhdWx0U2V0VGltb3V0KCkge1xuICAgIHRocm93IG5ldyBFcnJvcignc2V0VGltZW91dCBoYXMgbm90IGJlZW4gZGVmaW5lZCcpO1xufVxuZnVuY3Rpb24gZGVmYXVsdENsZWFyVGltZW91dCAoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdjbGVhclRpbWVvdXQgaGFzIG5vdCBiZWVuIGRlZmluZWQnKTtcbn1cbihmdW5jdGlvbiAoKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgaWYgKHR5cGVvZiBzZXRUaW1lb3V0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gc2V0VGltZW91dDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBkZWZhdWx0U2V0VGltb3V0O1xuICAgICAgICB9XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gZGVmYXVsdFNldFRpbW91dDtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgaWYgKHR5cGVvZiBjbGVhclRpbWVvdXQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGNsZWFyVGltZW91dDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGRlZmF1bHRDbGVhclRpbWVvdXQ7XG4gICAgICAgIH1cbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGRlZmF1bHRDbGVhclRpbWVvdXQ7XG4gICAgfVxufSAoKSlcbmZ1bmN0aW9uIHJ1blRpbWVvdXQoZnVuKSB7XG4gICAgaWYgKGNhY2hlZFNldFRpbWVvdXQgPT09IHNldFRpbWVvdXQpIHtcbiAgICAgICAgLy9ub3JtYWwgZW52aXJvbWVudHMgaW4gc2FuZSBzaXR1YXRpb25zXG4gICAgICAgIHJldHVybiBzZXRUaW1lb3V0KGZ1biwgMCk7XG4gICAgfVxuICAgIC8vIGlmIHNldFRpbWVvdXQgd2Fzbid0IGF2YWlsYWJsZSBidXQgd2FzIGxhdHRlciBkZWZpbmVkXG4gICAgaWYgKChjYWNoZWRTZXRUaW1lb3V0ID09PSBkZWZhdWx0U2V0VGltb3V0IHx8ICFjYWNoZWRTZXRUaW1lb3V0KSAmJiBzZXRUaW1lb3V0KSB7XG4gICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBzZXRUaW1lb3V0O1xuICAgICAgICByZXR1cm4gc2V0VGltZW91dChmdW4sIDApO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICAvLyB3aGVuIHdoZW4gc29tZWJvZHkgaGFzIHNjcmV3ZWQgd2l0aCBzZXRUaW1lb3V0IGJ1dCBubyBJLkUuIG1hZGRuZXNzXG4gICAgICAgIHJldHVybiBjYWNoZWRTZXRUaW1lb3V0KGZ1biwgMCk7XG4gICAgfSBjYXRjaChlKXtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIFdoZW4gd2UgYXJlIGluIEkuRS4gYnV0IHRoZSBzY3JpcHQgaGFzIGJlZW4gZXZhbGVkIHNvIEkuRS4gZG9lc24ndCB0cnVzdCB0aGUgZ2xvYmFsIG9iamVjdCB3aGVuIGNhbGxlZCBub3JtYWxseVxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZFNldFRpbWVvdXQuY2FsbChudWxsLCBmdW4sIDApO1xuICAgICAgICB9IGNhdGNoKGUpe1xuICAgICAgICAgICAgLy8gc2FtZSBhcyBhYm92ZSBidXQgd2hlbiBpdCdzIGEgdmVyc2lvbiBvZiBJLkUuIHRoYXQgbXVzdCBoYXZlIHRoZSBnbG9iYWwgb2JqZWN0IGZvciAndGhpcycsIGhvcGZ1bGx5IG91ciBjb250ZXh0IGNvcnJlY3Qgb3RoZXJ3aXNlIGl0IHdpbGwgdGhyb3cgYSBnbG9iYWwgZXJyb3JcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRTZXRUaW1lb3V0LmNhbGwodGhpcywgZnVuLCAwKTtcbiAgICAgICAgfVxuICAgIH1cblxuXG59XG5mdW5jdGlvbiBydW5DbGVhclRpbWVvdXQobWFya2VyKSB7XG4gICAgaWYgKGNhY2hlZENsZWFyVGltZW91dCA9PT0gY2xlYXJUaW1lb3V0KSB7XG4gICAgICAgIC8vbm9ybWFsIGVudmlyb21lbnRzIGluIHNhbmUgc2l0dWF0aW9uc1xuICAgICAgICByZXR1cm4gY2xlYXJUaW1lb3V0KG1hcmtlcik7XG4gICAgfVxuICAgIC8vIGlmIGNsZWFyVGltZW91dCB3YXNuJ3QgYXZhaWxhYmxlIGJ1dCB3YXMgbGF0dGVyIGRlZmluZWRcbiAgICBpZiAoKGNhY2hlZENsZWFyVGltZW91dCA9PT0gZGVmYXVsdENsZWFyVGltZW91dCB8fCAhY2FjaGVkQ2xlYXJUaW1lb3V0KSAmJiBjbGVhclRpbWVvdXQpIHtcbiAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gY2xlYXJUaW1lb3V0O1xuICAgICAgICByZXR1cm4gY2xlYXJUaW1lb3V0KG1hcmtlcik7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIC8vIHdoZW4gd2hlbiBzb21lYm9keSBoYXMgc2NyZXdlZCB3aXRoIHNldFRpbWVvdXQgYnV0IG5vIEkuRS4gbWFkZG5lc3NcbiAgICAgICAgcmV0dXJuIGNhY2hlZENsZWFyVGltZW91dChtYXJrZXIpO1xuICAgIH0gY2F0Y2ggKGUpe1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gV2hlbiB3ZSBhcmUgaW4gSS5FLiBidXQgdGhlIHNjcmlwdCBoYXMgYmVlbiBldmFsZWQgc28gSS5FLiBkb2Vzbid0ICB0cnVzdCB0aGUgZ2xvYmFsIG9iamVjdCB3aGVuIGNhbGxlZCBub3JtYWxseVxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZENsZWFyVGltZW91dC5jYWxsKG51bGwsIG1hcmtlcik7XG4gICAgICAgIH0gY2F0Y2ggKGUpe1xuICAgICAgICAgICAgLy8gc2FtZSBhcyBhYm92ZSBidXQgd2hlbiBpdCdzIGEgdmVyc2lvbiBvZiBJLkUuIHRoYXQgbXVzdCBoYXZlIHRoZSBnbG9iYWwgb2JqZWN0IGZvciAndGhpcycsIGhvcGZ1bGx5IG91ciBjb250ZXh0IGNvcnJlY3Qgb3RoZXJ3aXNlIGl0IHdpbGwgdGhyb3cgYSBnbG9iYWwgZXJyb3IuXG4gICAgICAgICAgICAvLyBTb21lIHZlcnNpb25zIG9mIEkuRS4gaGF2ZSBkaWZmZXJlbnQgcnVsZXMgZm9yIGNsZWFyVGltZW91dCB2cyBzZXRUaW1lb3V0XG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkQ2xlYXJUaW1lb3V0LmNhbGwodGhpcywgbWFya2VyKTtcbiAgICAgICAgfVxuICAgIH1cblxuXG5cbn1cbnZhciBxdWV1ZSA9IFtdO1xudmFyIGRyYWluaW5nID0gZmFsc2U7XG52YXIgY3VycmVudFF1ZXVlO1xudmFyIHF1ZXVlSW5kZXggPSAtMTtcblxuZnVuY3Rpb24gY2xlYW5VcE5leHRUaWNrKCkge1xuICAgIGlmICghZHJhaW5pbmcgfHwgIWN1cnJlbnRRdWV1ZSkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGRyYWluaW5nID0gZmFsc2U7XG4gICAgaWYgKGN1cnJlbnRRdWV1ZS5sZW5ndGgpIHtcbiAgICAgICAgcXVldWUgPSBjdXJyZW50UXVldWUuY29uY2F0KHF1ZXVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBxdWV1ZUluZGV4ID0gLTE7XG4gICAgfVxuICAgIGlmIChxdWV1ZS5sZW5ndGgpIHtcbiAgICAgICAgZHJhaW5RdWV1ZSgpO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gZHJhaW5RdWV1ZSgpIHtcbiAgICBpZiAoZHJhaW5pbmcpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgdGltZW91dCA9IHJ1blRpbWVvdXQoY2xlYW5VcE5leHRUaWNrKTtcbiAgICBkcmFpbmluZyA9IHRydWU7XG5cbiAgICB2YXIgbGVuID0gcXVldWUubGVuZ3RoO1xuICAgIHdoaWxlKGxlbikge1xuICAgICAgICBjdXJyZW50UXVldWUgPSBxdWV1ZTtcbiAgICAgICAgcXVldWUgPSBbXTtcbiAgICAgICAgd2hpbGUgKCsrcXVldWVJbmRleCA8IGxlbikge1xuICAgICAgICAgICAgaWYgKGN1cnJlbnRRdWV1ZSkge1xuICAgICAgICAgICAgICAgIGN1cnJlbnRRdWV1ZVtxdWV1ZUluZGV4XS5ydW4oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBxdWV1ZUluZGV4ID0gLTE7XG4gICAgICAgIGxlbiA9IHF1ZXVlLmxlbmd0aDtcbiAgICB9XG4gICAgY3VycmVudFF1ZXVlID0gbnVsbDtcbiAgICBkcmFpbmluZyA9IGZhbHNlO1xuICAgIHJ1bkNsZWFyVGltZW91dCh0aW1lb3V0KTtcbn1cblxucHJvY2Vzcy5uZXh0VGljayA9IGZ1bmN0aW9uIChmdW4pIHtcbiAgICB2YXIgYXJncyA9IG5ldyBBcnJheShhcmd1bWVudHMubGVuZ3RoIC0gMSk7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAxKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBhcmdzW2kgLSAxXSA9IGFyZ3VtZW50c1tpXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBxdWV1ZS5wdXNoKG5ldyBJdGVtKGZ1biwgYXJncykpO1xuICAgIGlmIChxdWV1ZS5sZW5ndGggPT09IDEgJiYgIWRyYWluaW5nKSB7XG4gICAgICAgIHJ1blRpbWVvdXQoZHJhaW5RdWV1ZSk7XG4gICAgfVxufTtcblxuLy8gdjggbGlrZXMgcHJlZGljdGlibGUgb2JqZWN0c1xuZnVuY3Rpb24gSXRlbShmdW4sIGFycmF5KSB7XG4gICAgdGhpcy5mdW4gPSBmdW47XG4gICAgdGhpcy5hcnJheSA9IGFycmF5O1xufVxuSXRlbS5wcm90b3R5cGUucnVuID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuZnVuLmFwcGx5KG51bGwsIHRoaXMuYXJyYXkpO1xufTtcbnByb2Nlc3MudGl0bGUgPSAnYnJvd3Nlcic7XG5wcm9jZXNzLmJyb3dzZXIgPSB0cnVlO1xucHJvY2Vzcy5lbnYgPSB7fTtcbnByb2Nlc3MuYXJndiA9IFtdO1xucHJvY2Vzcy52ZXJzaW9uID0gJyc7IC8vIGVtcHR5IHN0cmluZyB0byBhdm9pZCByZWdleHAgaXNzdWVzXG5wcm9jZXNzLnZlcnNpb25zID0ge307XG5cbmZ1bmN0aW9uIG5vb3AoKSB7fVxuXG5wcm9jZXNzLm9uID0gbm9vcDtcbnByb2Nlc3MuYWRkTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5vbmNlID0gbm9vcDtcbnByb2Nlc3Mub2ZmID0gbm9vcDtcbnByb2Nlc3MucmVtb3ZlTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5yZW1vdmVBbGxMaXN0ZW5lcnMgPSBub29wO1xucHJvY2Vzcy5lbWl0ID0gbm9vcDtcbnByb2Nlc3MucHJlcGVuZExpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3MucHJlcGVuZE9uY2VMaXN0ZW5lciA9IG5vb3A7XG5cbnByb2Nlc3MubGlzdGVuZXJzID0gZnVuY3Rpb24gKG5hbWUpIHsgcmV0dXJuIFtdIH1cblxucHJvY2Vzcy5iaW5kaW5nID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3Byb2Nlc3MuYmluZGluZyBpcyBub3Qgc3VwcG9ydGVkJyk7XG59O1xuXG5wcm9jZXNzLmN3ZCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuICcvJyB9O1xucHJvY2Vzcy5jaGRpciA9IGZ1bmN0aW9uIChkaXIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3Byb2Nlc3MuY2hkaXIgaXMgbm90IHN1cHBvcnRlZCcpO1xufTtcbnByb2Nlc3MudW1hc2sgPSBmdW5jdGlvbigpIHsgcmV0dXJuIDA7IH07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../node_modules/process/browser.js\n");

/***/ })

});